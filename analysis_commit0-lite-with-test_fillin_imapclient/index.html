
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 lite with test fillin imapclient - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-unit-test-feedback-imapclient" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 lite with test fillin imapclient
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_authpytestplainlogintest_fail" class="md-nav__link">
    <span class="md-ellipsis">
      test_auth.py::TestPlainLogin::test_fail
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_authpytestplainlogintest_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_auth.py::TestPlainLogin::test_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_authpytestplainlogintest_with_authorization_identity" class="md-nav__link">
    <span class="md-ellipsis">
      test_auth.py::TestPlainLogin::test_with_authorization_identity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enablepytestenabletest_failed1" class="md-nav__link">
    <span class="md-ellipsis">
      test_enable.py::TestEnable::test_failed1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enablepytestenabletest_failed2" class="md-nav__link">
    <span class="md-ellipsis">
      test_enable.py::TestEnable::test_failed2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enablepytestenabletest_multiple" class="md-nav__link">
    <span class="md-ellipsis">
      test_enable.py::TestEnable::test_multiple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enablepytestenabletest_success" class="md-nav__link">
    <span class="md-ellipsis">
      test_enable.py::TestEnable::test_success
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enablepytestenabletest_wrong_state" class="md-nav__link">
    <span class="md-ellipsis">
      test_enable.py::TestEnable::test_wrong_state
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_folder_statuspytestfolderstatustest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_folder_status.py::TestFolderStatus::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_folder_statuspytestfolderstatustest_extra_response" class="md-nav__link">
    <span class="md-ellipsis">
      test_folder_status.py::TestFolderStatus::test_extra_response
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_folder_statuspytestfolderstatustest_literal" class="md-nav__link">
    <span class="md-ellipsis">
      test_folder_status.py::TestFolderStatus::test_literal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imap_utf7pyimap4utf7testcasetest_decode" class="md-nav__link">
    <span class="md-ellipsis">
      test_imap_utf7.py::IMAP4UTF7TestCase::test_decode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imap_utf7pyimap4utf7testcasetest_encode" class="md-nav__link">
    <span class="md-ellipsis">
      test_imap_utf7.py::IMAP4UTF7TestCase::test_encode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imap_utf7pyimap4utf7testcasetest_printable_singletons" class="md-nav__link">
    <span class="md-ellipsis">
      test_imap_utf7.py::IMAP4UTF7TestCase::test_printable_singletons
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestlistfolderstest_blanks" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestListFolders::test_blanks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestlistfolderstest_empty_response" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestListFolders::test_empty_response
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestlistfolderstest_folder_encode_off" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestListFolders::test_folder_encode_off
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestlistfolderstest_funky_characters" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestListFolders::test_funky_characters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestlistfolderstest_list_folders" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestListFolders::test_list_folders
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestlistfolderstest_list_folders_no" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestListFolders::test_list_folders_NO
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestlistfolderstest_list_sub_folders" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestListFolders::test_list_sub_folders
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestlistfolderstest_list_sub_folders_no" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestListFolders::test_list_sub_folders_NO
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestlistfolderstest_mixed" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestListFolders::test_mixed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestlistfolderstest_quoted_specials" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestListFolders::test_quoted_specials
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestlistfolderstest_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestListFolders::test_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestlistfolderstest_unquoted_numeric_folder_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestListFolders::test_unquoted_numeric_folder_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestlistfolderstest_unquoted_numeric_folder_name_parsed_as_long" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestListFolders::test_unquoted_numeric_folder_name_parsed_as_long
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestlistfolderstest_utf7_decoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestListFolders::test_utf7_decoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestlistfolderstest_without_quotes" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestListFolders::test_without_quotes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestfindspecialfoldertest_find_special_folder_with_special_use" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestFindSpecialFolder::test_find_special_folder_with_special_use
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestfindspecialfoldertest_find_special_folder_with_special_use_single_flag" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestFindSpecialFolder::test_find_special_folder_with_special_use_single_flag
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestfindspecialfoldertest_find_special_folder_without_special_use_nor_namespace" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestFindSpecialFolder::test_find_special_folder_without_special_use_nor_namespace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestselectfoldertest_normal" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestSelectFolder::test_normal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestselectfoldertest_unselect" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestSelectFolder::test_unselect
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestappendtest_multiappend" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestAppend::test_multiappend
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestappendtest_multiappend_with_flags_and_internaldate" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestAppend::test_multiappend_with_flags_and_internaldate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestappendtest_with_msg_time" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestAppend::test_with_msg_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestappendtest_without_msg_time" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestAppend::test_without_msg_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestaclmethodstest_getacl" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestAclMethods::test_getacl
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestaclmethodstest_setacl" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestAclMethods::test_setacl
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestquotatest__get_quota" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestQuota::test__get_quota
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestquotatest_get_quota_root" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestQuota::test_get_quota_root
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestquotatest_parse_quota" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestQuota::test_parse_quota
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestquotatest_set_quota" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestQuota::test_set_quota
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestidleandnooptest_consume_until_tagged_response" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestIdleAndNoop::test_consume_until_tagged_response
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestidleandnooptest_idle" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestIdleAndNoop::test_idle
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestidleandnooptest_idle_check_blocking" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestIdleAndNoop::test_idle_check_blocking
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestidleandnooptest_idle_check_blocking_poll" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestIdleAndNoop::test_idle_check_blocking_poll
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestidleandnooptest_idle_check_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestIdleAndNoop::test_idle_check_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestidleandnooptest_idle_check_timeout_poll" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestIdleAndNoop::test_idle_check_timeout_poll
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestidleandnooptest_idle_check_with_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestIdleAndNoop::test_idle_check_with_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestidleandnooptest_idle_check_with_data_poll" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestIdleAndNoop::test_idle_check_with_data_poll
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestidleandnooptest_idle_done" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestIdleAndNoop::test_idle_done
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestidleandnooptest_noop" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestIdleAndNoop::test_noop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestdebugloggingtest_imap_is_patched" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestDebugLogging::test_IMAP_is_patched
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestdebugloggingtest_redacted_password" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestDebugLogging::test_redacted_password
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytesttimenormalisationtest_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestTimeNormalisation::test_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytesttimenormalisationtest_pass_through" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestTimeNormalisation::test_pass_through
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestnamespacetest_complex" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestNamespace::test_complex
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestnamespacetest_folder_decoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestNamespace::test_folder_decoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestnamespacetest_other_only" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestNamespace::test_other_only
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestnamespacetest_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestNamespace::test_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestnamespacetest_without_folder_decoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestNamespace::test_without_folder_decoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestcapabilitiestest_caching" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestCapabilities::test_caching
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestcapabilitiestest_decorator" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestCapabilities::test_decorator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestcapabilitiestest_has_capability" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestCapabilities::test_has_capability
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestcapabilitiestest_post_auth_request" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestCapabilities::test_post_auth_request
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestcapabilitiestest_preauth" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestCapabilities::test_preauth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestcapabilitiestest_server_returned_capability_after_auth" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestCapabilities::test_server_returned_capability_after_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestcapabilitiestest_with_starttls" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestCapabilities::test_with_starttls
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestidtest_id" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestId::test_id
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestidtest_invalid_parameters" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestId::test_invalid_parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestidtest_no_support" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestId::test_no_support
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestrawcommandtest_complex" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestRawCommand::test_complex
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestrawcommandtest_embedded_literal" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestRawCommand::test_embedded_literal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestrawcommandtest_failed_continuation_wait" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestRawCommand::test_failed_continuation_wait
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestrawcommandtest_invalid_input_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestRawCommand::test_invalid_input_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestrawcommandtest_literal_at_end" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestRawCommand::test_literal_at_end
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestrawcommandtest_literal_plus" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestRawCommand::test_literal_plus
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestrawcommandtest_literal_plus_multiple_literals" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestRawCommand::test_literal_plus_multiple_literals
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestrawcommandtest_multiple_literals" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestRawCommand::test_multiple_literals
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestrawcommandtest_not_uid" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestRawCommand::test_not_uid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestrawcommandtest_plain" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestRawCommand::test_plain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestexpungetest_expunge" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestExpunge::test_expunge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestexpungetest_id_expunge" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestExpunge::test_id_expunge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestshutdowntest_shutdown" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestShutdown::test_shutdown
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestcontextmanagertest_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestContextManager::test_context_manager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestcontextmanagertest_context_manager_fail_closing" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestContextManager::test_context_manager_fail_closing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestcontextmanagertest_exception_inside_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestContextManager::test_exception_inside_context_manager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestprotocolerrortest_tagged_response_with_parse_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestProtocolError::test_tagged_response_with_parse_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_imapclientpytestsockettest_issues_warning_for_deprecating_sock_property" class="md-nav__link">
    <span class="md-ellipsis">
      test_imapclient.py::TestSocket::test_issues_warning_for_deprecating_sock_property
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_initpytestinittest_ssl" class="md-nav__link">
    <span class="md-ellipsis">
      test_init.py::TestInit::test_SSL
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_initpytestinittest_ssl_sockettimeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_init.py::TestInit::test_SSL_SocketTimeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_initpytestinittest_plain" class="md-nav__link">
    <span class="md-ellipsis">
      test_init.py::TestInit::test_plain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_initpytestinittest_plain_sockettimeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_init.py::TestInit::test_plain_SocketTimeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_initpytestinittest_stream" class="md-nav__link">
    <span class="md-ellipsis">
      test_init.py::TestInit::test_stream
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_response_lexerpytesttokensourcetest_escaping" class="md-nav__link">
    <span class="md-ellipsis">
      test_response_lexer.py::TestTokenSource::test_escaping
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_response_lexerpytesttokensourcetest_invalid_escape" class="md-nav__link">
    <span class="md-ellipsis">
      test_response_lexer.py::TestTokenSource::test_invalid_escape
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_response_lexerpytesttokensourcetest_lists" class="md-nav__link">
    <span class="md-ellipsis">
      test_response_lexer.py::TestTokenSource::test_lists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_response_lexerpytesttokensourcetest_literal" class="md-nav__link">
    <span class="md-ellipsis">
      test_response_lexer.py::TestTokenSource::test_literal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_response_lexerpytesttokensourcetest_literals" class="md-nav__link">
    <span class="md-ellipsis">
      test_response_lexer.py::TestTokenSource::test_literals
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_response_lexerpytesttokensourcetest_multiple_inputs" class="md-nav__link">
    <span class="md-ellipsis">
      test_response_lexer.py::TestTokenSource::test_multiple_inputs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_response_lexerpytesttokensourcetest_no_escaping_in_square_brackets" class="md-nav__link">
    <span class="md-ellipsis">
      test_response_lexer.py::TestTokenSource::test_no_escaping_in_square_brackets
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_response_lexerpytesttokensourcetest_one_token" class="md-nav__link">
    <span class="md-ellipsis">
      test_response_lexer.py::TestTokenSource::test_one_token
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_response_lexerpytesttokensourcetest_quoted_strings" class="md-nav__link">
    <span class="md-ellipsis">
      test_response_lexer.py::TestTokenSource::test_quoted_strings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_response_lexerpytesttokensourcetest_simple_tokens" class="md-nav__link">
    <span class="md-ellipsis">
      test_response_lexer.py::TestTokenSource::test_simple_tokens
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_response_lexerpytesttokensourcetest_square_brackets" class="md-nav__link">
    <span class="md-ellipsis">
      test_response_lexer.py::TestTokenSource::test_square_brackets
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_response_lexerpytesttokensourcetest_unmatched_square_brackets" class="md-nav__link">
    <span class="md-ellipsis">
      test_response_lexer.py::TestTokenSource::test_unmatched_square_brackets
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_response_lexerpytesttokensourcetest_unterminated_strings" class="md-nav__link">
    <span class="md-ellipsis">
      test_response_lexer.py::TestTokenSource::test_unterminated_strings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_response_lexerpytesttokensourcetest_whitespace" class="md-nav__link">
    <span class="md-ellipsis">
      test_response_lexer.py::TestTokenSource::test_whitespace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_bytes_criteria" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_bytes_criteria
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_bytes_criteria_with_charset" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_bytes_criteria_with_charset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_modseq" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_modseq
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_nested" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_nested
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_nested_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_nested_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_nested_multiple" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_nested_multiple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_nested_tuple" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_nested_tuple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_no_results" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_no_results
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_quoting" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_quoting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_search_custom_exception_with_invalid_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_search_custom_exception_with_invalid_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_search_custom_exception_with_invalid_text" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_search_custom_exception_with_invalid_text
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_single" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_single
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_unicode_criteria" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_unicode_criteria
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_unicode_criteria_with_charset" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_unicode_criteria_with_charset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_with_date" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_with_date
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_with_datetime" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_with_datetime
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestsearchtest_zero_length_quoting" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestSearch::test_zero_length_quoting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestgmailsearchtest_bytes_query" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestGmailSearch::test_bytes_query
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestgmailsearchtest_bytes_query_with_charset" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestGmailSearch::test_bytes_query_with_charset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_searchpytestgmailsearchtest_unicode_criteria_with_charset" class="md-nav__link">
    <span class="md-ellipsis">
      test_search.py::TestGmailSearch::test_unicode_criteria_with_charset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sortpytestsorttest_all_args" class="md-nav__link">
    <span class="md-ellipsis">
      test_sort.py::TestSort::test_all_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sortpytestsorttest_multiple_criteria" class="md-nav__link">
    <span class="md-ellipsis">
      test_sort.py::TestSort::test_multiple_criteria
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sortpytestsorttest_no_support" class="md-nav__link">
    <span class="md-ellipsis">
      test_sort.py::TestSort::test_no_support
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sortpytestsorttest_single_criteria" class="md-nav__link">
    <span class="md-ellipsis">
      test_sort.py::TestSort::test_single_criteria
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_starttlspyteststarttlstest_command_fails" class="md-nav__link">
    <span class="md-ellipsis">
      test_starttls.py::TestStarttls::test_command_fails
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_starttlspyteststarttlstest_fails_if_called_twice" class="md-nav__link">
    <span class="md-ellipsis">
      test_starttls.py::TestStarttls::test_fails_if_called_twice
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_starttlspyteststarttlstest_fails_if_ssl_true" class="md-nav__link">
    <span class="md-ellipsis">
      test_starttls.py::TestStarttls::test_fails_if_ssl_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_starttlspyteststarttlstest_works" class="md-nav__link">
    <span class="md-ellipsis">
      test_starttls.py::TestStarttls::test_works
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_storepytestflagsconststest_flags_are_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      test_store.py::TestFlagsConsts::test_flags_are_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_storepytestflagstest_add" class="md-nav__link">
    <span class="md-ellipsis">
      test_store.py::TestFlags::test_add
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_storepytestflagstest_get" class="md-nav__link">
    <span class="md-ellipsis">
      test_store.py::TestFlags::test_get
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_storepytestflagstest_remove" class="md-nav__link">
    <span class="md-ellipsis">
      test_store.py::TestFlags::test_remove
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_storepytestflagstest_set" class="md-nav__link">
    <span class="md-ellipsis">
      test_store.py::TestFlags::test_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_storepytestgmaillabelstest_add" class="md-nav__link">
    <span class="md-ellipsis">
      test_store.py::TestGmailLabels::test_add
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_storepytestgmaillabelstest_get" class="md-nav__link">
    <span class="md-ellipsis">
      test_store.py::TestGmailLabels::test_get
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_storepytestgmaillabelstest_remove" class="md-nav__link">
    <span class="md-ellipsis">
      test_store.py::TestGmailLabels::test_remove
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_storepytestgmaillabelstest_set" class="md-nav__link">
    <span class="md-ellipsis">
      test_store.py::TestGmailLabels::test_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_threadpytestthreadtest_all_args" class="md-nav__link">
    <span class="md-ellipsis">
      test_thread.py::TestThread::test_all_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_threadpytestthreadtest_defaults" class="md-nav__link">
    <span class="md-ellipsis">
      test_thread.py::TestThread::test_defaults
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_threadpytestthreadtest_no_thread_support" class="md-nav__link">
    <span class="md-ellipsis">
      test_thread.py::TestThread::test_no_thread_support
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_threadpytestthreadtest_unsupported_algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      test_thread.py::TestThread::test_unsupported_algorithm
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_versionpytestversionstringtest_alpha" class="md-nav__link">
    <span class="md-ellipsis">
      test_version.py::TestVersionString::test_alpha
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_versionpytestversionstringtest_beta_point" class="md-nav__link">
    <span class="md-ellipsis">
      test_version.py::TestVersionString::test_beta_point
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_versionpytestversionstringtest_dot_oh" class="md-nav__link">
    <span class="md-ellipsis">
      test_version.py::TestVersionString::test_dot_oh
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_versionpytestversionstringtest_minor" class="md-nav__link">
    <span class="md-ellipsis">
      test_version.py::TestVersionString::test_minor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_versionpytestversionstringtest_point_release" class="md-nav__link">
    <span class="md-ellipsis">
      test_version.py::TestVersionString::test_point_release
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-lite-with-test_fillin">back to Claude Sonnet 3.5 - Fill-in + Unit Test Feedback summary</a></p>
<h1 id="claude-sonnet-35-fill-in-unit-test-feedback-imapclient"><strong>Claude Sonnet 3.5 - Fill-in + Unit Test Feedback</strong>: imapclient</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">156</td>
</tr>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">8</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">164</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">164</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_authpytestplainlogintest_fail">test_auth.py::TestPlainLogin::test_fail</h3>
<details><summary> <pre>test_auth.py::TestPlainLogin::test_fail</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_authpytestplainlogintest_simple">test_auth.py::TestPlainLogin::test_simple</h3>
<details><summary> <pre>test_auth.py::TestPlainLogin::test_simple</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_authpytestplainlogintest_with_authorization_identity">test_auth.py::TestPlainLogin::test_with_authorization_identity</h3>
<details><summary> <pre>test_auth.py::TestPlainLogin::test_with_authorization_identity</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_enablepytestenabletest_failed1">test_enable.py::TestEnable::test_failed1</h3>
<details><summary> <pre>test_enable.py::TestEnable::test_failed1</pre></summary><pre>
self = <tests.test_enable.TestEnable testMethod=test_failed1>

    def setUp(self):
>       super(TestEnable, self).setUp()

tests/test_enable.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_enablepytestenabletest_failed2">test_enable.py::TestEnable::test_failed2</h3>
<details><summary> <pre>test_enable.py::TestEnable::test_failed2</pre></summary><pre>
self = <tests.test_enable.TestEnable testMethod=test_failed2>

    def setUp(self):
>       super(TestEnable, self).setUp()

tests/test_enable.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_enablepytestenabletest_multiple">test_enable.py::TestEnable::test_multiple</h3>
<details><summary> <pre>test_enable.py::TestEnable::test_multiple</pre></summary><pre>
self = <tests.test_enable.TestEnable testMethod=test_multiple>

    def setUp(self):
>       super(TestEnable, self).setUp()

tests/test_enable.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_enablepytestenabletest_success">test_enable.py::TestEnable::test_success</h3>
<details><summary> <pre>test_enable.py::TestEnable::test_success</pre></summary><pre>
self = <tests.test_enable.TestEnable testMethod=test_success>

    def setUp(self):
>       super(TestEnable, self).setUp()

tests/test_enable.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_enablepytestenabletest_wrong_state">test_enable.py::TestEnable::test_wrong_state</h3>
<details><summary> <pre>test_enable.py::TestEnable::test_wrong_state</pre></summary><pre>
self = <tests.test_enable.TestEnable testMethod=test_wrong_state>

    def setUp(self):
>       super(TestEnable, self).setUp()

tests/test_enable.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_folder_statuspytestfolderstatustest_basic">test_folder_status.py::TestFolderStatus::test_basic</h3>
<details><summary> <pre>test_folder_status.py::TestFolderStatus::test_basic</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_folder_statuspytestfolderstatustest_extra_response">test_folder_status.py::TestFolderStatus::test_extra_response</h3>
<details><summary> <pre>test_folder_status.py::TestFolderStatus::test_extra_response</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_folder_statuspytestfolderstatustest_literal">test_folder_status.py::TestFolderStatus::test_literal</h3>
<details><summary> <pre>test_folder_status.py::TestFolderStatus::test_literal</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imap_utf7pyimap4utf7testcasetest_decode">test_imap_utf7.py::IMAP4UTF7TestCase::test_decode</h3>
<details><summary> <pre>test_imap_utf7.py::IMAP4UTF7TestCase::test_decode</pre></summary><pre>
self = <tests.test_imap_utf7.IMAP4UTF7TestCase testMethod=test_decode>

    def test_decode(self):
        for input, output in self.tests:
            decoded = decode(output)
            self.assertIsInstance(decoded, str)
>           self.assertEqual(input, decoded)
E           AssertionError: 'Stuff & Things' != 'Stuff Things'
E           - Stuff & Things
E           ?      --
E           + Stuff Things

tests/test_imap_utf7.py:37: AssertionError
</pre>
</details>
<h3 id="test_imap_utf7pyimap4utf7testcasetest_encode">test_imap_utf7.py::IMAP4UTF7TestCase::test_encode</h3>
<details><summary> <pre>test_imap_utf7.py::IMAP4UTF7TestCase::test_encode</pre></summary><pre>
self = <tests.test_imap_utf7.IMAP4UTF7TestCase testMethod=test_encode>

    def test_encode(self):
        for input, output in self.tests:
            encoded = encode(input)
            self.assertIsInstance(encoded, bytes)
>           self.assertEqual(encoded, output)
E           AssertionError: b'Stuff &ACY- Things' != b'Stuff &-Things'

tests/test_imap_utf7.py:31: AssertionError
</pre>
</details>
<h3 id="test_imap_utf7pyimap4utf7testcasetest_printable_singletons">test_imap_utf7.py::IMAP4UTF7TestCase::test_printable_singletons</h3>
<details><summary> <pre>test_imap_utf7.py::IMAP4UTF7TestCase::test_printable_singletons</pre></summary><pre>
self = <tests.test_imap_utf7.IMAP4UTF7TestCase testMethod=test_printable_singletons>

    def test_printable_singletons(self):
        """
        The IMAP4 modified UTF-7 implementation encodes all printable
        characters which are in ASCII using the corresponding ASCII byte.
        """
        # All printables represent themselves
        for o in list(range(0x20, 0x26)) + list(range(0x27, 0x7F)):
            self.assertEqual(bytes((o,)), encode(chr(o)))
            self.assertEqual(chr(o), decode(bytes((o,))))
>       self.assertEqual(encode("&"), b"&-")
E       AssertionError: b'&ACY-' != b'&-'

tests/test_imap_utf7.py:48: AssertionError
</pre>
</details>
<h3 id="test_imapclientpytestlistfolderstest_blanks">test_imapclient.py::TestListFolders::test_blanks</h3>
<details><summary> <pre>test_imapclient.py::TestListFolders::test_blanks</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestlistfolderstest_empty_response">test_imapclient.py::TestListFolders::test_empty_response</h3>
<details><summary> <pre>test_imapclient.py::TestListFolders::test_empty_response</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestlistfolderstest_folder_encode_off">test_imapclient.py::TestListFolders::test_folder_encode_off</h3>
<details><summary> <pre>test_imapclient.py::TestListFolders::test_folder_encode_off</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestlistfolderstest_funky_characters">test_imapclient.py::TestListFolders::test_funky_characters</h3>
<details><summary> <pre>test_imapclient.py::TestListFolders::test_funky_characters</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestlistfolderstest_list_folders">test_imapclient.py::TestListFolders::test_list_folders</h3>
<details><summary> <pre>test_imapclient.py::TestListFolders::test_list_folders</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestlistfolderstest_list_folders_no">test_imapclient.py::TestListFolders::test_list_folders_NO</h3>
<details><summary> <pre>test_imapclient.py::TestListFolders::test_list_folders_NO</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestlistfolderstest_list_sub_folders">test_imapclient.py::TestListFolders::test_list_sub_folders</h3>
<details><summary> <pre>test_imapclient.py::TestListFolders::test_list_sub_folders</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestlistfolderstest_list_sub_folders_no">test_imapclient.py::TestListFolders::test_list_sub_folders_NO</h3>
<details><summary> <pre>test_imapclient.py::TestListFolders::test_list_sub_folders_NO</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestlistfolderstest_mixed">test_imapclient.py::TestListFolders::test_mixed</h3>
<details><summary> <pre>test_imapclient.py::TestListFolders::test_mixed</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestlistfolderstest_quoted_specials">test_imapclient.py::TestListFolders::test_quoted_specials</h3>
<details><summary> <pre>test_imapclient.py::TestListFolders::test_quoted_specials</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestlistfolderstest_simple">test_imapclient.py::TestListFolders::test_simple</h3>
<details><summary> <pre>test_imapclient.py::TestListFolders::test_simple</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestlistfolderstest_unquoted_numeric_folder_name">test_imapclient.py::TestListFolders::test_unquoted_numeric_folder_name</h3>
<details><summary> <pre>test_imapclient.py::TestListFolders::test_unquoted_numeric_folder_name</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestlistfolderstest_unquoted_numeric_folder_name_parsed_as_long">test_imapclient.py::TestListFolders::test_unquoted_numeric_folder_name_parsed_as_long</h3>
<details><summary> <pre>test_imapclient.py::TestListFolders::test_unquoted_numeric_folder_name_parsed_as_long</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestlistfolderstest_utf7_decoding">test_imapclient.py::TestListFolders::test_utf7_decoding</h3>
<details><summary> <pre>test_imapclient.py::TestListFolders::test_utf7_decoding</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestlistfolderstest_without_quotes">test_imapclient.py::TestListFolders::test_without_quotes</h3>
<details><summary> <pre>test_imapclient.py::TestListFolders::test_without_quotes</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestfindspecialfoldertest_find_special_folder_with_special_use">test_imapclient.py::TestFindSpecialFolder::test_find_special_folder_with_special_use</h3>
<details><summary> <pre>test_imapclient.py::TestFindSpecialFolder::test_find_special_folder_with_special_use</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestfindspecialfoldertest_find_special_folder_with_special_use_single_flag">test_imapclient.py::TestFindSpecialFolder::test_find_special_folder_with_special_use_single_flag</h3>
<details><summary> <pre>test_imapclient.py::TestFindSpecialFolder::test_find_special_folder_with_special_use_single_flag</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestfindspecialfoldertest_find_special_folder_without_special_use_nor_namespace">test_imapclient.py::TestFindSpecialFolder::test_find_special_folder_without_special_use_nor_namespace</h3>
<details><summary> <pre>test_imapclient.py::TestFindSpecialFolder::test_find_special_folder_without_special_use_nor_namespace</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestselectfoldertest_normal">test_imapclient.py::TestSelectFolder::test_normal</h3>
<details><summary> <pre>test_imapclient.py::TestSelectFolder::test_normal</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestselectfoldertest_unselect">test_imapclient.py::TestSelectFolder::test_unselect</h3>
<details><summary> <pre>test_imapclient.py::TestSelectFolder::test_unselect</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestappendtest_multiappend">test_imapclient.py::TestAppend::test_multiappend</h3>
<details><summary> <pre>test_imapclient.py::TestAppend::test_multiappend</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestappendtest_multiappend_with_flags_and_internaldate">test_imapclient.py::TestAppend::test_multiappend_with_flags_and_internaldate</h3>
<details><summary> <pre>test_imapclient.py::TestAppend::test_multiappend_with_flags_and_internaldate</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestappendtest_with_msg_time">test_imapclient.py::TestAppend::test_with_msg_time</h3>
<details><summary> <pre>test_imapclient.py::TestAppend::test_with_msg_time</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestappendtest_without_msg_time">test_imapclient.py::TestAppend::test_without_msg_time</h3>
<details><summary> <pre>test_imapclient.py::TestAppend::test_without_msg_time</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestaclmethodstest_getacl">test_imapclient.py::TestAclMethods::test_getacl</h3>
<details><summary> <pre>test_imapclient.py::TestAclMethods::test_getacl</pre></summary><pre>
self = <tests.test_imapclient.TestAclMethods testMethod=test_getacl>

    def setUp(self):
>       super(TestAclMethods, self).setUp()

tests/test_imapclient.py:419: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestaclmethodstest_setacl">test_imapclient.py::TestAclMethods::test_setacl</h3>
<details><summary> <pre>test_imapclient.py::TestAclMethods::test_setacl</pre></summary><pre>
self = <tests.test_imapclient.TestAclMethods testMethod=test_setacl>

    def setUp(self):
>       super(TestAclMethods, self).setUp()

tests/test_imapclient.py:419: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestquotatest__get_quota">test_imapclient.py::TestQuota::test__get_quota</h3>
<details><summary> <pre>test_imapclient.py::TestQuota::test__get_quota</pre></summary><pre>
self = <tests.test_imapclient.TestQuota testMethod=test__get_quota>

    def setUp(self):
>       super(TestQuota, self).setUp()

tests/test_imapclient.py:443: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestquotatest_get_quota_root">test_imapclient.py::TestQuota::test_get_quota_root</h3>
<details><summary> <pre>test_imapclient.py::TestQuota::test_get_quota_root</pre></summary><pre>
self = <tests.test_imapclient.TestQuota testMethod=test_get_quota_root>

    def setUp(self):
>       super(TestQuota, self).setUp()

tests/test_imapclient.py:443: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestquotatest_parse_quota">test_imapclient.py::TestQuota::test_parse_quota</h3>
<details><summary> <pre>test_imapclient.py::TestQuota::test_parse_quota</pre></summary><pre>
self = <tests.test_imapclient.TestQuota testMethod=test_parse_quota>

    def setUp(self):
>       super(TestQuota, self).setUp()

tests/test_imapclient.py:443: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestquotatest_set_quota">test_imapclient.py::TestQuota::test_set_quota</h3>
<details><summary> <pre>test_imapclient.py::TestQuota::test_set_quota</pre></summary><pre>
self = <tests.test_imapclient.TestQuota testMethod=test_set_quota>

    def setUp(self):
>       super(TestQuota, self).setUp()

tests/test_imapclient.py:443: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestidleandnooptest_consume_until_tagged_response">test_imapclient.py::TestIdleAndNoop::test_consume_until_tagged_response</h3>
<details><summary> <pre>test_imapclient.py::TestIdleAndNoop::test_consume_until_tagged_response</pre></summary><pre>
self = <tests.test_imapclient.TestIdleAndNoop testMethod=test_consume_until_tagged_response>

    def setUp(self):
>       super(TestIdleAndNoop, self).setUp()

tests/test_imapclient.py:525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestidleandnooptest_idle">test_imapclient.py::TestIdleAndNoop::test_idle</h3>
<details><summary> <pre>test_imapclient.py::TestIdleAndNoop::test_idle</pre></summary><pre>
self = <tests.test_imapclient.TestIdleAndNoop testMethod=test_idle>

    def setUp(self):
>       super(TestIdleAndNoop, self).setUp()

tests/test_imapclient.py:525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestidleandnooptest_idle_check_blocking">test_imapclient.py::TestIdleAndNoop::test_idle_check_blocking</h3>
<details><summary> <pre>test_imapclient.py::TestIdleAndNoop::test_idle_check_blocking</pre></summary><pre>
self = <tests.test_imapclient.TestIdleAndNoop testMethod=test_idle_check_blocking>

    def setUp(self):
>       super(TestIdleAndNoop, self).setUp()

tests/test_imapclient.py:525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestidleandnooptest_idle_check_blocking_poll">test_imapclient.py::TestIdleAndNoop::test_idle_check_blocking_poll</h3>
<details><summary> <pre>test_imapclient.py::TestIdleAndNoop::test_idle_check_blocking_poll</pre></summary><pre>
self = <tests.test_imapclient.TestIdleAndNoop testMethod=test_idle_check_blocking_poll>

    def setUp(self):
>       super(TestIdleAndNoop, self).setUp()

tests/test_imapclient.py:525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestidleandnooptest_idle_check_timeout">test_imapclient.py::TestIdleAndNoop::test_idle_check_timeout</h3>
<details><summary> <pre>test_imapclient.py::TestIdleAndNoop::test_idle_check_timeout</pre></summary><pre>
self = <tests.test_imapclient.TestIdleAndNoop testMethod=test_idle_check_timeout>

    def setUp(self):
>       super(TestIdleAndNoop, self).setUp()

tests/test_imapclient.py:525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestidleandnooptest_idle_check_timeout_poll">test_imapclient.py::TestIdleAndNoop::test_idle_check_timeout_poll</h3>
<details><summary> <pre>test_imapclient.py::TestIdleAndNoop::test_idle_check_timeout_poll</pre></summary><pre>
self = <tests.test_imapclient.TestIdleAndNoop testMethod=test_idle_check_timeout_poll>

    def setUp(self):
>       super(TestIdleAndNoop, self).setUp()

tests/test_imapclient.py:525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestidleandnooptest_idle_check_with_data">test_imapclient.py::TestIdleAndNoop::test_idle_check_with_data</h3>
<details><summary> <pre>test_imapclient.py::TestIdleAndNoop::test_idle_check_with_data</pre></summary><pre>
self = <tests.test_imapclient.TestIdleAndNoop testMethod=test_idle_check_with_data>

    def setUp(self):
>       super(TestIdleAndNoop, self).setUp()

tests/test_imapclient.py:525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestidleandnooptest_idle_check_with_data_poll">test_imapclient.py::TestIdleAndNoop::test_idle_check_with_data_poll</h3>
<details><summary> <pre>test_imapclient.py::TestIdleAndNoop::test_idle_check_with_data_poll</pre></summary><pre>
self = <tests.test_imapclient.TestIdleAndNoop testMethod=test_idle_check_with_data_poll>

    def setUp(self):
>       super(TestIdleAndNoop, self).setUp()

tests/test_imapclient.py:525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestidleandnooptest_idle_done">test_imapclient.py::TestIdleAndNoop::test_idle_done</h3>
<details><summary> <pre>test_imapclient.py::TestIdleAndNoop::test_idle_done</pre></summary><pre>
self = <tests.test_imapclient.TestIdleAndNoop testMethod=test_idle_done>

    def setUp(self):
>       super(TestIdleAndNoop, self).setUp()

tests/test_imapclient.py:525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestidleandnooptest_noop">test_imapclient.py::TestIdleAndNoop::test_noop</h3>
<details><summary> <pre>test_imapclient.py::TestIdleAndNoop::test_noop</pre></summary><pre>
self = <tests.test_imapclient.TestIdleAndNoop testMethod=test_noop>

    def setUp(self):
>       super(TestIdleAndNoop, self).setUp()

tests/test_imapclient.py:525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestdebugloggingtest_imap_is_patched">test_imapclient.py::TestDebugLogging::test_IMAP_is_patched</h3>
<details><summary> <pre>test_imapclient.py::TestDebugLogging::test_IMAP_is_patched</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestdebugloggingtest_redacted_password">test_imapclient.py::TestDebugLogging::test_redacted_password</h3>
<details><summary> <pre>test_imapclient.py::TestDebugLogging::test_redacted_password</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytesttimenormalisationtest_default">test_imapclient.py::TestTimeNormalisation::test_default</h3>
<details><summary> <pre>test_imapclient.py::TestTimeNormalisation::test_default</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytesttimenormalisationtest_pass_through">test_imapclient.py::TestTimeNormalisation::test_pass_through</h3>
<details><summary> <pre>test_imapclient.py::TestTimeNormalisation::test_pass_through</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestnamespacetest_complex">test_imapclient.py::TestNamespace::test_complex</h3>
<details><summary> <pre>test_imapclient.py::TestNamespace::test_complex</pre></summary><pre>
self = <tests.test_imapclient.TestNamespace testMethod=test_complex>

    def setUp(self):
>       super(TestNamespace, self).setUp()

tests/test_imapclient.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestnamespacetest_folder_decoding">test_imapclient.py::TestNamespace::test_folder_decoding</h3>
<details><summary> <pre>test_imapclient.py::TestNamespace::test_folder_decoding</pre></summary><pre>
self = <tests.test_imapclient.TestNamespace testMethod=test_folder_decoding>

    def setUp(self):
>       super(TestNamespace, self).setUp()

tests/test_imapclient.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestnamespacetest_other_only">test_imapclient.py::TestNamespace::test_other_only</h3>
<details><summary> <pre>test_imapclient.py::TestNamespace::test_other_only</pre></summary><pre>
self = <tests.test_imapclient.TestNamespace testMethod=test_other_only>

    def setUp(self):
>       super(TestNamespace, self).setUp()

tests/test_imapclient.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestnamespacetest_simple">test_imapclient.py::TestNamespace::test_simple</h3>
<details><summary> <pre>test_imapclient.py::TestNamespace::test_simple</pre></summary><pre>
self = <tests.test_imapclient.TestNamespace testMethod=test_simple>

    def setUp(self):
>       super(TestNamespace, self).setUp()

tests/test_imapclient.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestnamespacetest_without_folder_decoding">test_imapclient.py::TestNamespace::test_without_folder_decoding</h3>
<details><summary> <pre>test_imapclient.py::TestNamespace::test_without_folder_decoding</pre></summary><pre>
self = <tests.test_imapclient.TestNamespace testMethod=test_without_folder_decoding>

    def setUp(self):
>       super(TestNamespace, self).setUp()

tests/test_imapclient.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestcapabilitiestest_caching">test_imapclient.py::TestCapabilities::test_caching</h3>
<details><summary> <pre>test_imapclient.py::TestCapabilities::test_caching</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestcapabilitiestest_decorator">test_imapclient.py::TestCapabilities::test_decorator</h3>
<details><summary> <pre>test_imapclient.py::TestCapabilities::test_decorator</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestcapabilitiestest_has_capability">test_imapclient.py::TestCapabilities::test_has_capability</h3>
<details><summary> <pre>test_imapclient.py::TestCapabilities::test_has_capability</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestcapabilitiestest_post_auth_request">test_imapclient.py::TestCapabilities::test_post_auth_request</h3>
<details><summary> <pre>test_imapclient.py::TestCapabilities::test_post_auth_request</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestcapabilitiestest_preauth">test_imapclient.py::TestCapabilities::test_preauth</h3>
<details><summary> <pre>test_imapclient.py::TestCapabilities::test_preauth</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestcapabilitiestest_server_returned_capability_after_auth">test_imapclient.py::TestCapabilities::test_server_returned_capability_after_auth</h3>
<details><summary> <pre>test_imapclient.py::TestCapabilities::test_server_returned_capability_after_auth</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestcapabilitiestest_with_starttls">test_imapclient.py::TestCapabilities::test_with_starttls</h3>
<details><summary> <pre>test_imapclient.py::TestCapabilities::test_with_starttls</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestidtest_id">test_imapclient.py::TestId::test_id</h3>
<details><summary> <pre>test_imapclient.py::TestId::test_id</pre></summary><pre>
self = <tests.test_imapclient.TestId testMethod=test_id>

    def setUp(self):
>       super(TestId, self).setUp()

tests/test_imapclient.py:917: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestidtest_invalid_parameters">test_imapclient.py::TestId::test_invalid_parameters</h3>
<details><summary> <pre>test_imapclient.py::TestId::test_invalid_parameters</pre></summary><pre>
self = <tests.test_imapclient.TestId testMethod=test_invalid_parameters>

    def setUp(self):
>       super(TestId, self).setUp()

tests/test_imapclient.py:917: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestidtest_no_support">test_imapclient.py::TestId::test_no_support</h3>
<details><summary> <pre>test_imapclient.py::TestId::test_no_support</pre></summary><pre>
self = <tests.test_imapclient.TestId testMethod=test_no_support>

    def setUp(self):
>       super(TestId, self).setUp()

tests/test_imapclient.py:917: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestrawcommandtest_complex">test_imapclient.py::TestRawCommand::test_complex</h3>
<details><summary> <pre>test_imapclient.py::TestRawCommand::test_complex</pre></summary><pre>
self = <tests.test_imapclient.TestRawCommand testMethod=test_complex>

    def setUp(self):
>       super(TestRawCommand, self).setUp()

tests/test_imapclient.py:946: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestrawcommandtest_embedded_literal">test_imapclient.py::TestRawCommand::test_embedded_literal</h3>
<details><summary> <pre>test_imapclient.py::TestRawCommand::test_embedded_literal</pre></summary><pre>
self = <tests.test_imapclient.TestRawCommand testMethod=test_embedded_literal>

    def setUp(self):
>       super(TestRawCommand, self).setUp()

tests/test_imapclient.py:946: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestrawcommandtest_failed_continuation_wait">test_imapclient.py::TestRawCommand::test_failed_continuation_wait</h3>
<details><summary> <pre>test_imapclient.py::TestRawCommand::test_failed_continuation_wait</pre></summary><pre>
self = <tests.test_imapclient.TestRawCommand testMethod=test_failed_continuation_wait>

    def setUp(self):
>       super(TestRawCommand, self).setUp()

tests/test_imapclient.py:946: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestrawcommandtest_invalid_input_type">test_imapclient.py::TestRawCommand::test_invalid_input_type</h3>
<details><summary> <pre>test_imapclient.py::TestRawCommand::test_invalid_input_type</pre></summary><pre>
self = <tests.test_imapclient.TestRawCommand testMethod=test_invalid_input_type>

    def setUp(self):
>       super(TestRawCommand, self).setUp()

tests/test_imapclient.py:946: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestrawcommandtest_literal_at_end">test_imapclient.py::TestRawCommand::test_literal_at_end</h3>
<details><summary> <pre>test_imapclient.py::TestRawCommand::test_literal_at_end</pre></summary><pre>
self = <tests.test_imapclient.TestRawCommand testMethod=test_literal_at_end>

    def setUp(self):
>       super(TestRawCommand, self).setUp()

tests/test_imapclient.py:946: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestrawcommandtest_literal_plus">test_imapclient.py::TestRawCommand::test_literal_plus</h3>
<details><summary> <pre>test_imapclient.py::TestRawCommand::test_literal_plus</pre></summary><pre>
self = <tests.test_imapclient.TestRawCommand testMethod=test_literal_plus>

    def setUp(self):
>       super(TestRawCommand, self).setUp()

tests/test_imapclient.py:946: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestrawcommandtest_literal_plus_multiple_literals">test_imapclient.py::TestRawCommand::test_literal_plus_multiple_literals</h3>
<details><summary> <pre>test_imapclient.py::TestRawCommand::test_literal_plus_multiple_literals</pre></summary><pre>
self = <tests.test_imapclient.TestRawCommand testMethod=test_literal_plus_multiple_literals>

    def setUp(self):
>       super(TestRawCommand, self).setUp()

tests/test_imapclient.py:946: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestrawcommandtest_multiple_literals">test_imapclient.py::TestRawCommand::test_multiple_literals</h3>
<details><summary> <pre>test_imapclient.py::TestRawCommand::test_multiple_literals</pre></summary><pre>
self = <tests.test_imapclient.TestRawCommand testMethod=test_multiple_literals>

    def setUp(self):
>       super(TestRawCommand, self).setUp()

tests/test_imapclient.py:946: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestrawcommandtest_not_uid">test_imapclient.py::TestRawCommand::test_not_uid</h3>
<details><summary> <pre>test_imapclient.py::TestRawCommand::test_not_uid</pre></summary><pre>
self = <tests.test_imapclient.TestRawCommand testMethod=test_not_uid>

    def setUp(self):
>       super(TestRawCommand, self).setUp()

tests/test_imapclient.py:946: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestrawcommandtest_plain">test_imapclient.py::TestRawCommand::test_plain</h3>
<details><summary> <pre>test_imapclient.py::TestRawCommand::test_plain</pre></summary><pre>
self = <tests.test_imapclient.TestRawCommand testMethod=test_plain>

    def setUp(self):
>       super(TestRawCommand, self).setUp()

tests/test_imapclient.py:946: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestexpungetest_expunge">test_imapclient.py::TestExpunge::test_expunge</h3>
<details><summary> <pre>test_imapclient.py::TestExpunge::test_expunge</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestexpungetest_id_expunge">test_imapclient.py::TestExpunge::test_id_expunge</h3>
<details><summary> <pre>test_imapclient.py::TestExpunge::test_id_expunge</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestshutdowntest_shutdown">test_imapclient.py::TestShutdown::test_shutdown</h3>
<details><summary> <pre>test_imapclient.py::TestShutdown::test_shutdown</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestcontextmanagertest_context_manager">test_imapclient.py::TestContextManager::test_context_manager</h3>
<details><summary> <pre>test_imapclient.py::TestContextManager::test_context_manager</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestcontextmanagertest_context_manager_fail_closing">test_imapclient.py::TestContextManager::test_context_manager_fail_closing</h3>
<details><summary> <pre>test_imapclient.py::TestContextManager::test_context_manager_fail_closing</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestcontextmanagertest_exception_inside_context_manager">test_imapclient.py::TestContextManager::test_exception_inside_context_manager</h3>
<details><summary> <pre>test_imapclient.py::TestContextManager::test_exception_inside_context_manager</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestprotocolerrortest_tagged_response_with_parse_error">test_imapclient.py::TestProtocolError::test_tagged_response_with_parse_error</h3>
<details><summary> <pre>test_imapclient.py::TestProtocolError::test_tagged_response_with_parse_error</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_imapclientpytestsockettest_issues_warning_for_deprecating_sock_property">test_imapclient.py::TestSocket::test_issues_warning_for_deprecating_sock_property</h3>
<details><summary> <pre>test_imapclient.py::TestSocket::test_issues_warning_for_deprecating_sock_property</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_initpytestinittest_ssl">test_init.py::TestInit::test_SSL</h3>
<details><summary> <pre>test_init.py::TestInit::test_SSL</pre></summary><pre>
self = <tests.test_init.TestInit testMethod=test_SSL>

    def test_SSL(self):
        fakeIMAP4_TLS = Mock()
        self.tls.IMAP4_TLS.return_value = fakeIMAP4_TLS

>       imap = IMAPClient(
            "1.2.3.4", ssl_context=sentinel.context, timeout=sentinel.timeout
        )

tests/test_init.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('1.2.3.4', 993), timeout = <object object at 0x7f8eb3388f40>
source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.

        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """

        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               TimeoutError: [Errno 110] Connection timed out

/usr/lib/python3.10/socket.py:833: TimeoutError
</pre>
</details>
<h3 id="test_initpytestinittest_ssl_sockettimeout">test_init.py::TestInit::test_SSL_SocketTimeout</h3>
<details><summary> <pre>test_init.py::TestInit::test_SSL_SocketTimeout</pre></summary><pre>
self = <tests.test_init.TestInit testMethod=test_SSL_SocketTimeout>

    def test_SSL_SocketTimeout(self):
        fakeIMAP4_TLS = Mock()
        self.tls.IMAP4_TLS.return_value = fakeIMAP4_TLS

>       imap = IMAPClient(
            "1.2.3.4",
            ssl_context=sentinel.context,
            timeout=SocketTimeout(sentinel.connect_timeout, sentinel.timeout),
        )

tests/test_init.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('1.2.3.4', 993), timeout = <object object at 0x7f8eb3388f40>
source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.

        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """

        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               TimeoutError: [Errno 110] Connection timed out

/usr/lib/python3.10/socket.py:833: TimeoutError
</pre>
</details>
<h3 id="test_initpytestinittest_plain">test_init.py::TestInit::test_plain</h3>
<details><summary> <pre>test_init.py::TestInit::test_plain</pre></summary><pre>
self = <tests.test_init.TestInit testMethod=test_plain>

    def test_plain(self):
        fakeIMAP4 = Mock()
        self.imap4.IMAP4WithTimeout.return_value = fakeIMAP4

>       imap = IMAPClient("1.2.3.4", ssl=False, timeout=sentinel.timeout)

tests/test_init.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:243: in _create_IMAP4
    return self.imap4.IMAP4WithTimeout(self.host, self.port, self._timeout.connect)
imapclient/imap4.py:11: in __init__
    imaplib.IMAP4.__init__(self, address, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('1.2.3.4', 143), timeout = <object object at 0x7f8eb3388f40>
source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.

        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """

        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               TimeoutError: [Errno 110] Connection timed out

/usr/lib/python3.10/socket.py:833: TimeoutError
</pre>
</details>
<h3 id="test_initpytestinittest_plain_sockettimeout">test_init.py::TestInit::test_plain_SocketTimeout</h3>
<details><summary> <pre>test_init.py::TestInit::test_plain_SocketTimeout</pre></summary><pre>
self = <tests.test_init.TestInit testMethod=test_plain_SocketTimeout>

    def test_plain_SocketTimeout(self):
        fakeIMAP4 = Mock()
        self.imap4.IMAP4WithTimeout.return_value = fakeIMAP4

>       imap = IMAPClient(
            "1.2.3.4",
            ssl=False,
            timeout=SocketTimeout(sentinel.connect_timeout, sentinel.timeout),
        )

tests/test_init.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:243: in _create_IMAP4
    return self.imap4.IMAP4WithTimeout(self.host, self.port, self._timeout.connect)
imapclient/imap4.py:11: in __init__
    imaplib.IMAP4.__init__(self, address, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('1.2.3.4', 143), timeout = <object object at 0x7f8eb3388f40>
source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.

        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """

        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               TimeoutError: [Errno 110] Connection timed out

/usr/lib/python3.10/socket.py:833: TimeoutError
</pre>
</details>
<h3 id="test_initpytestinittest_stream">test_init.py::TestInit::test_stream</h3>
<details><summary> <pre>test_init.py::TestInit::test_stream</pre></summary><pre>
self = <tests.test_init.TestInit testMethod=test_stream>

    def test_stream(self):
        fakeIMAP4_stream = Mock()
        self.imaplib.IMAP4_stream.return_value = fakeIMAP4_stream

>       imap = IMAPClient("command", stream=True, ssl=False)

tests/test_init.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:239: in _create_IMAP4
    return self.imaplib.IMAP4_stream(self.host)
/usr/lib/python3.10/imaplib.py:1355: in __init__
    IMAP4.__init__(self)
/usr/lib/python3.10/imaplib.py:205: in __init__
    self._connect()
/usr/lib/python3.10/imaplib.py:247: in _connect
    self.welcome = self._get_response()
/usr/lib/python3.10/imaplib.py:1075: in _get_response
    resp = self._get_line()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <imaplib.IMAP4_stream object at 0x7f8eb191e590>

    def _get_line(self):

        line = self.readline()
        if not line:
>           raise self.abort('socket error: EOF')
E           imaplib.IMAP4.abort: socket error: EOF

/usr/lib/python3.10/imaplib.py:1185: abort
</pre>
</details>
<h3 id="test_response_lexerpytesttokensourcetest_escaping">test_response_lexer.py::TestTokenSource::test_escaping</h3>
<details><summary> <pre>test_response_lexer.py::TestTokenSource::test_escaping</pre></summary><pre>
self = <tests.test_response_lexer.TestTokenSource testMethod=test_escaping>

    def test_escaping(self):
>       self.check([rb'"aaa\"bbb"'], [rb'"aaa"bbb"'])

tests/test_response_lexer.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_response_lexer.py:91: in check
    self.assertSequenceEqual(list(tokens), expected_out)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <imapclient.response_lexer.Lexer object at 0x7f8eb18dc3a0>

    def __iter__(self) ->Iterator[bytes]:
        for source in self.sources:
            self.current_source = source
>           for tok in self.read_token_stream(iter(source)):
E           AttributeError: 'Lexer' object has no attribute 'read_token_stream'

imapclient/response_lexer.py:47: AttributeError
</pre>
</details>
<h3 id="test_response_lexerpytesttokensourcetest_invalid_escape">test_response_lexer.py::TestTokenSource::test_invalid_escape</h3>
<details><summary> <pre>test_response_lexer.py::TestTokenSource::test_invalid_escape</pre></summary><pre>
self = <tests.test_response_lexer.TestTokenSource testMethod=test_invalid_escape>

    def test_invalid_escape(self):
>       self.check([rb'"aaa\Zbbb"'], [rb'"aaa\Zbbb"'])

tests/test_response_lexer.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_response_lexer.py:91: in check
    self.assertSequenceEqual(list(tokens), expected_out)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <imapclient.response_lexer.Lexer object at 0x7f8eb1981ab0>

    def __iter__(self) ->Iterator[bytes]:
        for source in self.sources:
            self.current_source = source
>           for tok in self.read_token_stream(iter(source)):
E           AttributeError: 'Lexer' object has no attribute 'read_token_stream'

imapclient/response_lexer.py:47: AttributeError
</pre>
</details>
<h3 id="test_response_lexerpytesttokensourcetest_lists">test_response_lexer.py::TestTokenSource::test_lists</h3>
<details><summary> <pre>test_response_lexer.py::TestTokenSource::test_lists</pre></summary><pre>
self = <tests.test_response_lexer.TestTokenSource testMethod=test_lists>

    def test_lists(self):
>       self.check([b"()"], [b"(", b")"])

tests/test_response_lexer.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_response_lexer.py:91: in check
    self.assertSequenceEqual(list(tokens), expected_out)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <imapclient.response_lexer.Lexer object at 0x7f8eb19ab310>

    def __iter__(self) ->Iterator[bytes]:
        for source in self.sources:
            self.current_source = source
>           for tok in self.read_token_stream(iter(source)):
E           AttributeError: 'Lexer' object has no attribute 'read_token_stream'

imapclient/response_lexer.py:47: AttributeError
</pre>
</details>
<h3 id="test_response_lexerpytesttokensourcetest_literal">test_response_lexer.py::TestTokenSource::test_literal</h3>
<details><summary> <pre>test_response_lexer.py::TestTokenSource::test_literal</pre></summary><pre>
self = <tests.test_response_lexer.TestTokenSource testMethod=test_literal>

    def test_literal(self):
        source = TokenSource([(b"abc {7}", b"foo bar"), b")"])
        tokens = iter(source)
>       self.assertEqual(next(tokens), b"abc")

tests/test_response_lexer.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <imapclient.response_lexer.Lexer object at 0x7f8eb1980f40>

    def __iter__(self) ->Iterator[bytes]:
        for source in self.sources:
            self.current_source = source
>           for tok in self.read_token_stream(iter(source)):
E           AttributeError: 'Lexer' object has no attribute 'read_token_stream'

imapclient/response_lexer.py:47: AttributeError
</pre>
</details>
<h3 id="test_response_lexerpytesttokensourcetest_literals">test_response_lexer.py::TestTokenSource::test_literals</h3>
<details><summary> <pre>test_response_lexer.py::TestTokenSource::test_literals</pre></summary><pre>
self = <tests.test_response_lexer.TestTokenSource testMethod=test_literals>

    def test_literals(self):
        source = TokenSource([(b"abc {7}", b"foo bar"), (b"{5}", b"snafu"), b")"])
        tokens = iter(source)
>       self.assertEqual(next(tokens), b"abc")

tests/test_response_lexer.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <imapclient.response_lexer.Lexer object at 0x7f8eb191a500>

    def __iter__(self) ->Iterator[bytes]:
        for source in self.sources:
            self.current_source = source
>           for tok in self.read_token_stream(iter(source)):
E           AttributeError: 'Lexer' object has no attribute 'read_token_stream'

imapclient/response_lexer.py:47: AttributeError
</pre>
</details>
<h3 id="test_response_lexerpytesttokensourcetest_multiple_inputs">test_response_lexer.py::TestTokenSource::test_multiple_inputs</h3>
<details><summary> <pre>test_response_lexer.py::TestTokenSource::test_multiple_inputs</pre></summary><pre>
self = <tests.test_response_lexer.TestTokenSource testMethod=test_multiple_inputs>

    def test_multiple_inputs(self):
>       self.check([b"abc 111", b"def 222"], [b"abc", b"111", b"def", b"222"])

tests/test_response_lexer.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_response_lexer.py:91: in check
    self.assertSequenceEqual(list(tokens), expected_out)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <imapclient.response_lexer.Lexer object at 0x7f8eb19a9d20>

    def __iter__(self) ->Iterator[bytes]:
        for source in self.sources:
            self.current_source = source
>           for tok in self.read_token_stream(iter(source)):
E           AttributeError: 'Lexer' object has no attribute 'read_token_stream'

imapclient/response_lexer.py:47: AttributeError
</pre>
</details>
<h3 id="test_response_lexerpytesttokensourcetest_no_escaping_in_square_brackets">test_response_lexer.py::TestTokenSource::test_no_escaping_in_square_brackets</h3>
<details><summary> <pre>test_response_lexer.py::TestTokenSource::test_no_escaping_in_square_brackets</pre></summary><pre>
self = <tests.test_response_lexer.TestTokenSource testMethod=test_no_escaping_in_square_brackets>

    def test_no_escaping_in_square_brackets(self):
>       self.check([rb"[aaa\\bbb]"], [rb"[aaa\\bbb]"])

tests/test_response_lexer.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_response_lexer.py:91: in check
    self.assertSequenceEqual(list(tokens), expected_out)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <imapclient.response_lexer.Lexer object at 0x7f8eb19ef0d0>

    def __iter__(self) ->Iterator[bytes]:
        for source in self.sources:
            self.current_source = source
>           for tok in self.read_token_stream(iter(source)):
E           AttributeError: 'Lexer' object has no attribute 'read_token_stream'

imapclient/response_lexer.py:47: AttributeError
</pre>
</details>
<h3 id="test_response_lexerpytesttokensourcetest_one_token">test_response_lexer.py::TestTokenSource::test_one_token</h3>
<details><summary> <pre>test_response_lexer.py::TestTokenSource::test_one_token</pre></summary><pre>
self = <tests.test_response_lexer.TestTokenSource testMethod=test_one_token>

    def test_one_token(self):
>       self.check([b"abc"], [b"abc"])

tests/test_response_lexer.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_response_lexer.py:91: in check
    self.assertSequenceEqual(list(tokens), expected_out)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <imapclient.response_lexer.Lexer object at 0x7f8eb191b310>

    def __iter__(self) ->Iterator[bytes]:
        for source in self.sources:
            self.current_source = source
>           for tok in self.read_token_stream(iter(source)):
E           AttributeError: 'Lexer' object has no attribute 'read_token_stream'

imapclient/response_lexer.py:47: AttributeError
</pre>
</details>
<h3 id="test_response_lexerpytesttokensourcetest_quoted_strings">test_response_lexer.py::TestTokenSource::test_quoted_strings</h3>
<details><summary> <pre>test_response_lexer.py::TestTokenSource::test_quoted_strings</pre></summary><pre>
self = <tests.test_response_lexer.TestTokenSource testMethod=test_quoted_strings>

    def test_quoted_strings(self):
>       self.check([b'"abc def"'], [b'"abc def"'])

tests/test_response_lexer.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_response_lexer.py:91: in check
    self.assertSequenceEqual(list(tokens), expected_out)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <imapclient.response_lexer.Lexer object at 0x7f8eb1851330>

    def __iter__(self) ->Iterator[bytes]:
        for source in self.sources:
            self.current_source = source
>           for tok in self.read_token_stream(iter(source)):
E           AttributeError: 'Lexer' object has no attribute 'read_token_stream'

imapclient/response_lexer.py:47: AttributeError
</pre>
</details>
<h3 id="test_response_lexerpytesttokensourcetest_simple_tokens">test_response_lexer.py::TestTokenSource::test_simple_tokens</h3>
<details><summary> <pre>test_response_lexer.py::TestTokenSource::test_simple_tokens</pre></summary><pre>
self = <tests.test_response_lexer.TestTokenSource testMethod=test_simple_tokens>

    def test_simple_tokens(self):
>       self.check([b"abc 111 def"], [b"abc", b"111", b"def"])

tests/test_response_lexer.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_response_lexer.py:91: in check
    self.assertSequenceEqual(list(tokens), expected_out)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <imapclient.response_lexer.Lexer object at 0x7f8eb19ab9a0>

    def __iter__(self) ->Iterator[bytes]:
        for source in self.sources:
            self.current_source = source
>           for tok in self.read_token_stream(iter(source)):
E           AttributeError: 'Lexer' object has no attribute 'read_token_stream'

imapclient/response_lexer.py:47: AttributeError
</pre>
</details>
<h3 id="test_response_lexerpytesttokensourcetest_square_brackets">test_response_lexer.py::TestTokenSource::test_square_brackets</h3>
<details><summary> <pre>test_response_lexer.py::TestTokenSource::test_square_brackets</pre></summary><pre>
self = <tests.test_response_lexer.TestTokenSource testMethod=test_square_brackets>

    def test_square_brackets(self):
>       self.check([b"[aaa bbb]"], [b"[aaa bbb]"])

tests/test_response_lexer.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_response_lexer.py:91: in check
    self.assertSequenceEqual(list(tokens), expected_out)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <imapclient.response_lexer.Lexer object at 0x7f8eb19ee4a0>

    def __iter__(self) ->Iterator[bytes]:
        for source in self.sources:
            self.current_source = source
>           for tok in self.read_token_stream(iter(source)):
E           AttributeError: 'Lexer' object has no attribute 'read_token_stream'

imapclient/response_lexer.py:47: AttributeError
</pre>
</details>
<h3 id="test_response_lexerpytesttokensourcetest_unmatched_square_brackets">test_response_lexer.py::TestTokenSource::test_unmatched_square_brackets</h3>
<details><summary> <pre>test_response_lexer.py::TestTokenSource::test_unmatched_square_brackets</pre></summary><pre>
self = <tests.test_response_lexer.TestTokenSource testMethod=test_unmatched_square_brackets>

    def test_unmatched_square_brackets(self):
        message = "No closing ']'"
>       self.check_error([b"["], message)

tests/test_response_lexer.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_response_lexer.py:94: in check_error
    self.assertRaisesRegex(
tests/test_response_lexer.py:95: in <lambda>
    ValueError, expected_message, lambda: list(TokenSource(text_in))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def __iter__(self) ->Iterator[bytes]:
        for source in self.sources:
            self.current_source = source
>           for tok in self.read_token_stream(iter(source)):
E           AttributeError: 'Lexer' object has no attribute 'read_token_stream'

imapclient/response_lexer.py:47: AttributeError
</pre>
</details>
<h3 id="test_response_lexerpytesttokensourcetest_unterminated_strings">test_response_lexer.py::TestTokenSource::test_unterminated_strings</h3>
<details><summary> <pre>test_response_lexer.py::TestTokenSource::test_unterminated_strings</pre></summary><pre>
self = <tests.test_response_lexer.TestTokenSource testMethod=test_unterminated_strings>

    def test_unterminated_strings(self):
        message = "No closing '\"'"
>       self.check_error([b'"'], message)

tests/test_response_lexer.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_response_lexer.py:94: in check_error
    self.assertRaisesRegex(
tests/test_response_lexer.py:95: in <lambda>
    ValueError, expected_message, lambda: list(TokenSource(text_in))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def __iter__(self) ->Iterator[bytes]:
        for source in self.sources:
            self.current_source = source
>           for tok in self.read_token_stream(iter(source)):
E           AttributeError: 'Lexer' object has no attribute 'read_token_stream'

imapclient/response_lexer.py:47: AttributeError
</pre>
</details>
<h3 id="test_response_lexerpytesttokensourcetest_whitespace">test_response_lexer.py::TestTokenSource::test_whitespace</h3>
<details><summary> <pre>test_response_lexer.py::TestTokenSource::test_whitespace</pre></summary><pre>
self = <tests.test_response_lexer.TestTokenSource testMethod=test_whitespace>

    def test_whitespace(self):
>       self.check([b"abc   def"], [b"abc", b"def"])

tests/test_response_lexer.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_response_lexer.py:91: in check
    self.assertSequenceEqual(list(tokens), expected_out)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <imapclient.response_lexer.Lexer object at 0x7f8eb19ef0d0>

    def __iter__(self) ->Iterator[bytes]:
        for source in self.sources:
            self.current_source = source
>           for tok in self.read_token_stream(iter(source)):
E           AttributeError: 'Lexer' object has no attribute 'read_token_stream'

imapclient/response_lexer.py:47: AttributeError
</pre>
</details>
<h3 id="test_searchpytestsearchtest_bytes_criteria">test_search.py::TestSearch::test_bytes_criteria</h3>
<details><summary> <pre>test_search.py::TestSearch::test_bytes_criteria</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_bytes_criteria>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestsearchtest_bytes_criteria_with_charset">test_search.py::TestSearch::test_bytes_criteria_with_charset</h3>
<details><summary> <pre>test_search.py::TestSearch::test_bytes_criteria_with_charset</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_bytes_criteria_with_charset>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestsearchtest_modseq">test_search.py::TestSearch::test_modseq</h3>
<details><summary> <pre>test_search.py::TestSearch::test_modseq</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_modseq>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestsearchtest_nested">test_search.py::TestSearch::test_nested</h3>
<details><summary> <pre>test_search.py::TestSearch::test_nested</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_nested>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestsearchtest_nested_empty">test_search.py::TestSearch::test_nested_empty</h3>
<details><summary> <pre>test_search.py::TestSearch::test_nested_empty</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_nested_empty>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestsearchtest_nested_multiple">test_search.py::TestSearch::test_nested_multiple</h3>
<details><summary> <pre>test_search.py::TestSearch::test_nested_multiple</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_nested_multiple>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestsearchtest_nested_tuple">test_search.py::TestSearch::test_nested_tuple</h3>
<details><summary> <pre>test_search.py::TestSearch::test_nested_tuple</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_nested_tuple>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestsearchtest_no_results">test_search.py::TestSearch::test_no_results</h3>
<details><summary> <pre>test_search.py::TestSearch::test_no_results</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_no_results>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestsearchtest_quoting">test_search.py::TestSearch::test_quoting</h3>
<details><summary> <pre>test_search.py::TestSearch::test_quoting</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_quoting>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestsearchtest_search_custom_exception_with_invalid_list">test_search.py::TestSearch::test_search_custom_exception_with_invalid_list</h3>
<details><summary> <pre>test_search.py::TestSearch::test_search_custom_exception_with_invalid_list</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_search_custom_exception_with_invalid_list>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestsearchtest_search_custom_exception_with_invalid_text">test_search.py::TestSearch::test_search_custom_exception_with_invalid_text</h3>
<details><summary> <pre>test_search.py::TestSearch::test_search_custom_exception_with_invalid_text</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_search_custom_exception_with_invalid_text>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestsearchtest_single">test_search.py::TestSearch::test_single</h3>
<details><summary> <pre>test_search.py::TestSearch::test_single</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_single>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestsearchtest_unicode_criteria">test_search.py::TestSearch::test_unicode_criteria</h3>
<details><summary> <pre>test_search.py::TestSearch::test_unicode_criteria</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_unicode_criteria>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestsearchtest_unicode_criteria_with_charset">test_search.py::TestSearch::test_unicode_criteria_with_charset</h3>
<details><summary> <pre>test_search.py::TestSearch::test_unicode_criteria_with_charset</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_unicode_criteria_with_charset>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestsearchtest_with_date">test_search.py::TestSearch::test_with_date</h3>
<details><summary> <pre>test_search.py::TestSearch::test_with_date</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_with_date>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestsearchtest_with_datetime">test_search.py::TestSearch::test_with_datetime</h3>
<details><summary> <pre>test_search.py::TestSearch::test_with_datetime</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_with_datetime>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestsearchtest_zero_length_quoting">test_search.py::TestSearch::test_zero_length_quoting</h3>
<details><summary> <pre>test_search.py::TestSearch::test_zero_length_quoting</pre></summary><pre>
self = <tests.test_search.TestSearch testMethod=test_zero_length_quoting>

    def setUp(self):
>       super(TestSearchBase, self).setUp()

tests/test_search.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestgmailsearchtest_bytes_query">test_search.py::TestGmailSearch::test_bytes_query</h3>
<details><summary> <pre>test_search.py::TestGmailSearch::test_bytes_query</pre></summary><pre>
self = <tests.test_search.TestGmailSearch testMethod=test_bytes_query>

    def setUp(self):
>       super(TestGmailSearch, self).setUp()

tests/test_search.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_search.py:17: in setUp
    super(TestSearchBase, self).setUp()
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestgmailsearchtest_bytes_query_with_charset">test_search.py::TestGmailSearch::test_bytes_query_with_charset</h3>
<details><summary> <pre>test_search.py::TestGmailSearch::test_bytes_query_with_charset</pre></summary><pre>
self = <tests.test_search.TestGmailSearch testMethod=test_bytes_query_with_charset>

    def setUp(self):
>       super(TestGmailSearch, self).setUp()

tests/test_search.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_search.py:17: in setUp
    super(TestSearchBase, self).setUp()
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_searchpytestgmailsearchtest_unicode_criteria_with_charset">test_search.py::TestGmailSearch::test_unicode_criteria_with_charset</h3>
<details><summary> <pre>test_search.py::TestGmailSearch::test_unicode_criteria_with_charset</pre></summary><pre>
self = <tests.test_search.TestGmailSearch testMethod=test_unicode_criteria_with_charset>

    def setUp(self):
>       super(TestGmailSearch, self).setUp()

tests/test_search.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_search.py:17: in setUp
    super(TestSearchBase, self).setUp()
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_sortpytestsorttest_all_args">test_sort.py::TestSort::test_all_args</h3>
<details><summary> <pre>test_sort.py::TestSort::test_all_args</pre></summary><pre>
self = <tests.test_sort.TestSort testMethod=test_all_args>

    def setUp(self):
>       super(TestSort, self).setUp()

tests/test_sort.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_sortpytestsorttest_multiple_criteria">test_sort.py::TestSort::test_multiple_criteria</h3>
<details><summary> <pre>test_sort.py::TestSort::test_multiple_criteria</pre></summary><pre>
self = <tests.test_sort.TestSort testMethod=test_multiple_criteria>

    def setUp(self):
>       super(TestSort, self).setUp()

tests/test_sort.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_sortpytestsorttest_no_support">test_sort.py::TestSort::test_no_support</h3>
<details><summary> <pre>test_sort.py::TestSort::test_no_support</pre></summary><pre>
self = <tests.test_sort.TestSort testMethod=test_no_support>

    def setUp(self):
>       super(TestSort, self).setUp()

tests/test_sort.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_sortpytestsorttest_single_criteria">test_sort.py::TestSort::test_single_criteria</h3>
<details><summary> <pre>test_sort.py::TestSort::test_single_criteria</pre></summary><pre>
self = <tests.test_sort.TestSort testMethod=test_single_criteria>

    def setUp(self):
>       super(TestSort, self).setUp()

tests/test_sort.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_starttlspyteststarttlstest_command_fails">test_starttls.py::TestStarttls::test_command_fails</h3>
<details><summary> <pre>test_starttls.py::TestStarttls::test_command_fails</pre></summary><pre>
self = <tests.test_starttls.TestStarttls testMethod=test_command_fails>

    def setUp(self):
>       super(TestStarttls, self).setUp()

tests/test_starttls.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_starttlspyteststarttlstest_fails_if_called_twice">test_starttls.py::TestStarttls::test_fails_if_called_twice</h3>
<details><summary> <pre>test_starttls.py::TestStarttls::test_fails_if_called_twice</pre></summary><pre>
self = <tests.test_starttls.TestStarttls testMethod=test_fails_if_called_twice>

    def setUp(self):
>       super(TestStarttls, self).setUp()

tests/test_starttls.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_starttlspyteststarttlstest_fails_if_ssl_true">test_starttls.py::TestStarttls::test_fails_if_ssl_true</h3>
<details><summary> <pre>test_starttls.py::TestStarttls::test_fails_if_ssl_true</pre></summary><pre>
self = <tests.test_starttls.TestStarttls testMethod=test_fails_if_ssl_true>

    def setUp(self):
>       super(TestStarttls, self).setUp()

tests/test_starttls.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_starttlspyteststarttlstest_works">test_starttls.py::TestStarttls::test_works</h3>
<details><summary> <pre>test_starttls.py::TestStarttls::test_works</pre></summary><pre>
self = <tests.test_starttls.TestStarttls testMethod=test_works>

    def setUp(self):
>       super(TestStarttls, self).setUp()

tests/test_starttls.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_storepytestflagsconststest_flags_are_bytes">test_store.py::TestFlagsConsts::test_flags_are_bytes</h3>
<details><summary> <pre>test_store.py::TestFlagsConsts::test_flags_are_bytes</pre></summary><pre>
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_storepytestflagstest_add">test_store.py::TestFlags::test_add</h3>
<details><summary> <pre>test_store.py::TestFlags::test_add</pre></summary><pre>
self = <tests.test_store.TestFlags testMethod=test_add>

    def setUp(self):
>       super(TestFlags, self).setUp()

tests/test_store.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_storepytestflagstest_get">test_store.py::TestFlags::test_get</h3>
<details><summary> <pre>test_store.py::TestFlags::test_get</pre></summary><pre>
self = <tests.test_store.TestFlags testMethod=test_get>

    def setUp(self):
>       super(TestFlags, self).setUp()

tests/test_store.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_storepytestflagstest_remove">test_store.py::TestFlags::test_remove</h3>
<details><summary> <pre>test_store.py::TestFlags::test_remove</pre></summary><pre>
self = <tests.test_store.TestFlags testMethod=test_remove>

    def setUp(self):
>       super(TestFlags, self).setUp()

tests/test_store.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_storepytestflagstest_set">test_store.py::TestFlags::test_set</h3>
<details><summary> <pre>test_store.py::TestFlags::test_set</pre></summary><pre>
self = <tests.test_store.TestFlags testMethod=test_set>

    def setUp(self):
>       super(TestFlags, self).setUp()

tests/test_store.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_storepytestgmaillabelstest_add">test_store.py::TestGmailLabels::test_add</h3>
<details><summary> <pre>test_store.py::TestGmailLabels::test_add</pre></summary><pre>
self = <tests.test_store.TestGmailLabels testMethod=test_add>

    def setUp(self):
>       super(TestGmailLabels, self).setUp()

tests/test_store.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_storepytestgmaillabelstest_get">test_store.py::TestGmailLabels::test_get</h3>
<details><summary> <pre>test_store.py::TestGmailLabels::test_get</pre></summary><pre>
self = <tests.test_store.TestGmailLabels testMethod=test_get>

    def setUp(self):
>       super(TestGmailLabels, self).setUp()

tests/test_store.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_storepytestgmaillabelstest_remove">test_store.py::TestGmailLabels::test_remove</h3>
<details><summary> <pre>test_store.py::TestGmailLabels::test_remove</pre></summary><pre>
self = <tests.test_store.TestGmailLabels testMethod=test_remove>

    def setUp(self):
>       super(TestGmailLabels, self).setUp()

tests/test_store.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_storepytestgmaillabelstest_set">test_store.py::TestGmailLabels::test_set</h3>
<details><summary> <pre>test_store.py::TestGmailLabels::test_set</pre></summary><pre>
self = <tests.test_store.TestGmailLabels testMethod=test_set>

    def setUp(self):
>       super(TestGmailLabels, self).setUp()

tests/test_store.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_threadpytestthreadtest_all_args">test_thread.py::TestThread::test_all_args</h3>
<details><summary> <pre>test_thread.py::TestThread::test_all_args</pre></summary><pre>
self = <tests.test_thread.TestThread testMethod=test_all_args>

    def setUp(self):
>       super(TestThread, self).setUp()

tests/test_thread.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_threadpytestthreadtest_defaults">test_thread.py::TestThread::test_defaults</h3>
<details><summary> <pre>test_thread.py::TestThread::test_defaults</pre></summary><pre>
self = <tests.test_thread.TestThread testMethod=test_defaults>

    def setUp(self):
>       super(TestThread, self).setUp()

tests/test_thread.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_threadpytestthreadtest_no_thread_support">test_thread.py::TestThread::test_no_thread_support</h3>
<details><summary> <pre>test_thread.py::TestThread::test_no_thread_support</pre></summary><pre>
self = <tests.test_thread.TestThread testMethod=test_no_thread_support>

    def setUp(self):
>       super(TestThread, self).setUp()

tests/test_thread.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_threadpytestthreadtest_unsupported_algorithm">test_thread.py::TestThread::test_unsupported_algorithm</h3>
<details><summary> <pre>test_thread.py::TestThread::test_unsupported_algorithm</pre></summary><pre>
self = <tests.test_thread.TestThread testMethod=test_unsupported_algorithm>

    def setUp(self):
>       super(TestThread, self).setUp()

tests/test_thread.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/imapclient_test.py:8: in setUp
    self.client = IMAPClient()
imapclient/testable_imapclient.py:16: in __init__
    super().__init__('somehost')
imapclient/imapclient.py:228: in __init__
    self._imap = self._create_IMAP4()
imapclient/imapclient.py:241: in _create_IMAP4
    return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)
imapclient/tls.py:24: in __init__
    imaplib.IMAP4.__init__(self, host, port)
/usr/lib/python3.10/imaplib.py:202: in __init__
    self.open(host, port, timeout)
/usr/lib/python3.10/imaplib.py:312: in open
    self.sock = self._create_socket(timeout)
/usr/lib/python3.10/imaplib.py:302: in _create_socket
    return socket.create_connection(address)
/usr/lib/python3.10/socket.py:824: in create_connection
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'somehost', port = 993, family = 0, type = <SocketKind.SOCK_STREAM: 1>
proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.

        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.

        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno -2] Name or service not known

/usr/lib/python3.10/socket.py:955: gaierror
</pre>
</details>
<h3 id="test_versionpytestversionstringtest_alpha">test_version.py::TestVersionString::test_alpha</h3>
<details><summary> <pre>test_version.py::TestVersionString::test_alpha</pre></summary><pre>
self = <tests.test_version.TestVersionString testMethod=test_alpha>

    def test_alpha(self):
>       self.assertEqual(_imapclient_version_string((2, 1, 0, "alpha")), "2.1.0-alpha")
E       AssertionError: '2.1.0.alpha' != '2.1.0-alpha'
E       - 2.1.0.alpha
E       ?      ^
E       + 2.1.0-alpha
E       ?      ^

tests/test_version.py:21: AssertionError
</pre>
</details>
<h3 id="test_versionpytestversionstringtest_beta_point">test_version.py::TestVersionString::test_beta_point</h3>
<details><summary> <pre>test_version.py::TestVersionString::test_beta_point</pre></summary><pre>
self = <tests.test_version.TestVersionString testMethod=test_beta_point>

    def test_beta_point(self):
>       self.assertEqual(_imapclient_version_string((2, 1, 3, "beta")), "2.1.3-beta")
E       AssertionError: '2.1.3.beta' != '2.1.3-beta'
E       - 2.1.3.beta
E       ?      ^
E       + 2.1.3-beta
E       ?      ^

tests/test_version.py:24: AssertionError
</pre>
</details>
<h3 id="test_versionpytestversionstringtest_dot_oh">test_version.py::TestVersionString::test_dot_oh</h3>
<details><summary> <pre>test_version.py::TestVersionString::test_dot_oh</pre></summary><pre>
self = <tests.test_version.TestVersionString testMethod=test_dot_oh>

    def test_dot_oh(self):
>       self.assertEqual(_imapclient_version_string((1, 0, 0, "final")), "1.0.0")
E       AssertionError: '1.0.0.final' != '1.0.0'
E       - 1.0.0.final
E       + 1.0.0

tests/test_version.py:12: AssertionError
</pre>
</details>
<h3 id="test_versionpytestversionstringtest_minor">test_version.py::TestVersionString::test_minor</h3>
<details><summary> <pre>test_version.py::TestVersionString::test_minor</pre></summary><pre>
self = <tests.test_version.TestVersionString testMethod=test_minor>

    def test_minor(self):
>       self.assertEqual(_imapclient_version_string((2, 1, 0, "final")), "2.1.0")
E       AssertionError: '2.1.0.final' != '2.1.0'
E       - 2.1.0.final
E       + 2.1.0

tests/test_version.py:15: AssertionError
</pre>
</details>
<h3 id="test_versionpytestversionstringtest_point_release">test_version.py::TestVersionString::test_point_release</h3>
<details><summary> <pre>test_version.py::TestVersionString::test_point_release</pre></summary><pre>
self = <tests.test_version.TestVersionString testMethod=test_point_release>

    def test_point_release(self):
>       self.assertEqual(_imapclient_version_string((1, 2, 3, "final")), "1.2.3")
E       AssertionError: '1.2.3.final' != '1.2.3'
E       - 1.2.3.final
E       + 1.2.3

tests/test_version.py:18: AssertionError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/imapclient/__init__.py b/imapclient/__init__.py</span>
<span class="gh">index ce7cb64..282efdb 100644</span>
<span class="gd">--- a/imapclient/__init__.py</span>
<span class="gi">+++ b/imapclient/__init__.py</span>
<span class="gu">@@ -5,7 +5,7 @@</span>
<span class="w"> </span># version_info provides the version number in programmer friendly way.
<span class="w"> </span># The 4th part will be either alpha, beta or final.

<span class="gd">-from .imapclient import *  # noqa: F401,F403</span>
<span class="gi">+from .imapclient import IMAPClient  # noqa: F401</span>
<span class="w"> </span>from .response_parser import *  # noqa: F401,F403
<span class="w"> </span>from .tls import *  # noqa: F401,F403
<span class="w"> </span>from .version import author as __author__  # noqa: F401
<span class="gh">diff --git a/imapclient/config.py b/imapclient/config.py</span>
<span class="gh">index f098591..e083f43 100644</span>
<span class="gd">--- a/imapclient/config.py</span>
<span class="gi">+++ b/imapclient/config.py</span>
<span class="gu">@@ -14,7 +14,27 @@ def parse_config_file(filename: str) -&gt;argparse.Namespace:</span>

<span class="w"> </span>    Used by livetest.py and interact.py
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    config = configparser.ConfigParser()</span>
<span class="gi">+    config.read(filename)</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;DEFAULT&#39; not in config:</span>
<span class="gi">+        raise ValueError(f&quot;Config file {filename} must have a DEFAULT section&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    ns = argparse.Namespace()</span>
<span class="gi">+    ns.host = config[&#39;DEFAULT&#39;].get(&#39;host&#39;, &#39;imap.gmail.com&#39;)</span>
<span class="gi">+    ns.port = config[&#39;DEFAULT&#39;].getint(&#39;port&#39;, 993)</span>
<span class="gi">+    ns.ssl = config[&#39;DEFAULT&#39;].getboolean(&#39;ssl&#39;, True)</span>
<span class="gi">+    ns.username = config[&#39;DEFAULT&#39;].get(&#39;username&#39;)</span>
<span class="gi">+    ns.password = config[&#39;DEFAULT&#39;].get(&#39;password&#39;)</span>
<span class="gi">+    ns.oauth2 = config[&#39;DEFAULT&#39;].getboolean(&#39;oauth2&#39;, False)</span>
<span class="gi">+    ns.oauth2_client_id = config[&#39;DEFAULT&#39;].get(&#39;oauth2_client_id&#39;)</span>
<span class="gi">+    ns.oauth2_client_secret = config[&#39;DEFAULT&#39;].get(&#39;oauth2_client_secret&#39;)</span>
<span class="gi">+    ns.oauth2_refresh_token = config[&#39;DEFAULT&#39;].get(&#39;oauth2_refresh_token&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if ns.oauth2 and (not ns.oauth2_client_id or not ns.oauth2_client_secret or not ns.oauth2_refresh_token):</span>
<span class="gi">+        raise ValueError(&quot;oauth2_client_id, oauth2_client_secret, and oauth2_refresh_token must be provided when oauth2 is True&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return ns</span>


<span class="w"> </span>T = TypeVar(&#39;T&#39;)
<span class="gh">diff --git a/imapclient/datetime_util.py b/imapclient/datetime_util.py</span>
<span class="gh">index 57a44c4..468e80e 100644</span>
<span class="gd">--- a/imapclient/datetime_util.py</span>
<span class="gi">+++ b/imapclient/datetime_util.py</span>
<span class="gu">@@ -14,7 +14,19 @@ def parse_to_datetime(timestamp: bytes, normalise: bool=True) -&gt;datetime:</span>
<span class="w"> </span>    If normalise is False, then the returned datetime will be
<span class="w"> </span>    unadjusted but will contain timezone information as per the input.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(timestamp, bytes):</span>
<span class="gi">+        timestamp = timestamp.decode(&#39;ascii&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    time_tuple = parsedate_tz(timestamp)</span>
<span class="gi">+    if time_tuple is None:</span>
<span class="gi">+        raise ValueError(&quot;Invalid timestamp format&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    tz_offset = time_tuple[-1]</span>
<span class="gi">+    dt = datetime(*time_tuple[:6], tzinfo=FixedOffset(tz_offset) if tz_offset else None)</span>
<span class="gi">+    </span>
<span class="gi">+    if normalise:</span>
<span class="gi">+        return dt.astimezone().replace(tzinfo=None)</span>
<span class="gi">+    return dt</span>


<span class="w"> </span>def datetime_to_INTERNALDATE(dt: datetime) -&gt;str:
<span class="gu">@@ -23,7 +35,10 @@ def datetime_to_INTERNALDATE(dt: datetime) -&gt;str:</span>
<span class="w"> </span>    If timezone information is missing the current system
<span class="w"> </span>    timezone is used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if dt.tzinfo is None:</span>
<span class="gi">+        dt = dt.astimezone()</span>
<span class="gi">+    </span>
<span class="gi">+    return dt.strftime(&quot;%d-%b-%Y %H:%M:%S %z&quot;).strip()</span>


<span class="w"> </span>_rfc822_dotted_time = re.compile(
<span class="gu">@@ -32,4 +47,9 @@ _rfc822_dotted_time = re.compile(</span>

<span class="w"> </span>def format_criteria_date(dt: datetime) -&gt;bytes:
<span class="w"> </span>    &quot;&quot;&quot;Format a date or datetime instance for use in IMAP search criteria.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(dt, datetime):</span>
<span class="gi">+        dt_str = dt.strftime(&quot;%d-%b-%Y&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        dt_str = dt.strftime(&quot;%d-%b-%Y&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    return dt_str.encode(&#39;ascii&#39;)</span>
<span class="gh">diff --git a/imapclient/fixed_offset.py b/imapclient/fixed_offset.py</span>
<span class="gh">index b9e7df9..94b649a 100644</span>
<span class="gd">--- a/imapclient/fixed_offset.py</span>
<span class="gi">+++ b/imapclient/fixed_offset.py</span>
<span class="gu">@@ -10,17 +10,32 @@ class FixedOffset(datetime.tzinfo):</span>
<span class="w"> </span>    east from UTC
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, minutes: float) -&gt;None:</span>
<span class="gd">-        self.__offset = datetime.timedelta(minutes=minutes)</span>
<span class="gd">-        sign = &#39;+&#39;</span>
<span class="gd">-        if minutes &lt; 0:</span>
<span class="gd">-            sign = &#39;-&#39;</span>
<span class="gd">-        hours, remaining_mins = divmod(abs(minutes), 60)</span>
<span class="gd">-        self.__name = &#39;%s%02d%02d&#39; % (sign, hours, remaining_mins)</span>
<span class="gi">+    def __init__(self, offset_minutes: float) -&gt; None:</span>
<span class="gi">+        self._offset = datetime.timedelta(minutes=offset_minutes)</span>
<span class="gi">+        self._name = self._format_offset(offset_minutes)</span>
<span class="gi">+</span>
<span class="gi">+    def utcoffset(self, dt: Optional[datetime.datetime]) -&gt; datetime.timedelta:</span>
<span class="gi">+        return self._offset</span>
<span class="gi">+</span>
<span class="gi">+    def tzname(self, dt: Optional[datetime.datetime]) -&gt; str:</span>
<span class="gi">+        return self._name</span>
<span class="gi">+</span>
<span class="gi">+    def dst(self, dt: Optional[datetime.datetime]) -&gt; datetime.timedelta:</span>
<span class="gi">+        return ZERO</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _format_offset(offset_minutes: float) -&gt; str:</span>
<span class="gi">+        sign = &quot;+&quot; if offset_minutes &gt;= 0 else &quot;-&quot;</span>
<span class="gi">+        hours, minutes = divmod(abs(int(offset_minutes)), 60)</span>
<span class="gi">+        return f&quot;{sign}{hours:02d}{minutes:02d}&quot;</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def for_system(cls) -&gt;&#39;FixedOffset&#39;:</span>
<span class="gi">+    def for_system(cls) -&gt; &#39;FixedOffset&#39;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a FixedOffset instance for the current working timezone and
<span class="w"> </span>        DST conditions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if time.daylight:</span>
<span class="gi">+            offset = -time.altzone if time.localtime().tm_isdst else -time.timezone</span>
<span class="gi">+        else:</span>
<span class="gi">+            offset = -time.timezone</span>
<span class="gi">+        return cls(offset // 60)</span>
<span class="gh">diff --git a/imapclient/imap_utf7.py b/imapclient/imap_utf7.py</span>
<span class="gh">index 7a795b2..c806338 100644</span>
<span class="gd">--- a/imapclient/imap_utf7.py</span>
<span class="gi">+++ b/imapclient/imap_utf7.py</span>
<span class="gu">@@ -1,3 +1,4 @@</span>
<span class="gi">+import base64</span>
<span class="w"> </span>import binascii
<span class="w"> </span>from typing import List, Union

<span class="gu">@@ -8,7 +9,27 @@ def encode(s: Union[str, bytes]) -&gt;bytes:</span>
<span class="w"> </span>    Input is unicode; output is bytes (Python 3) or str (Python 2). If
<span class="w"> </span>    non-unicode input is provided, the input is returned unchanged.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(s, bytes):</span>
<span class="gi">+        return s</span>
<span class="gi">+    if not isinstance(s, str):</span>
<span class="gi">+        raise ValueError(&quot;Input must be str or bytes&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    result = bytearray()</span>
<span class="gi">+    utf7_buffer = bytearray()</span>
<span class="gi">+    </span>
<span class="gi">+    for char in s:</span>
<span class="gi">+        if ord(char) in range(0x20, 0x7f) and char != &#39;&amp;&#39;:</span>
<span class="gi">+            if utf7_buffer:</span>
<span class="gi">+                result.extend(b&#39;&amp;&#39; + base64.b64encode(utf7_buffer).rstrip(b&#39;=&#39;).replace(b&#39;/&#39;, b&#39;,&#39;) + b&#39;-&#39;)</span>
<span class="gi">+                utf7_buffer = bytearray()</span>
<span class="gi">+            result.extend(char.encode(&#39;ascii&#39;))</span>
<span class="gi">+        else:</span>
<span class="gi">+            utf7_buffer.extend(char.encode(&#39;utf-16be&#39;))</span>
<span class="gi">+    </span>
<span class="gi">+    if utf7_buffer:</span>
<span class="gi">+        result.extend(b&#39;&amp;&#39; + base64.b64encode(utf7_buffer).rstrip(b&#39;=&#39;).replace(b&#39;/&#39;, b&#39;,&#39;) + b&#39;-&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    return bytes(result)</span>


<span class="w"> </span>AMPERSAND_ORD = ord(&#39;&amp;&#39;)
<span class="gu">@@ -22,4 +43,32 @@ def decode(s: Union[bytes, str]) -&gt;str:</span>
<span class="w"> </span>    unicode. If non-bytes/str input is provided, the input is returned
<span class="w"> </span>    unchanged.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(s, str):</span>
<span class="gi">+        s = s.encode(&#39;ascii&#39;)</span>
<span class="gi">+    if not isinstance(s, bytes):</span>
<span class="gi">+        raise ValueError(&quot;Input must be str or bytes&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    result = []</span>
<span class="gi">+    utf7_buffer = bytearray()</span>
<span class="gi">+    is_utf7 = False</span>
<span class="gi">+    </span>
<span class="gi">+    for byte in s:</span>
<span class="gi">+        if is_utf7:</span>
<span class="gi">+            if byte == DASH_ORD:</span>
<span class="gi">+                if utf7_buffer:</span>
<span class="gi">+                    padded = utf7_buffer + b&#39;=&#39; * ((4 - len(utf7_buffer) % 4) % 4)</span>
<span class="gi">+                    decoded = base64.b64decode(padded.replace(b&#39;,&#39;, b&#39;/&#39;))</span>
<span class="gi">+                    result.append(decoded.decode(&#39;utf-16be&#39;))</span>
<span class="gi">+                    utf7_buffer = bytearray()</span>
<span class="gi">+                is_utf7 = False</span>
<span class="gi">+            elif byte == AMPERSAND_ORD:</span>
<span class="gi">+                utf7_buffer.append(byte)</span>
<span class="gi">+                result.append(&#39;&amp;&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                utf7_buffer.append(byte)</span>
<span class="gi">+        elif byte == AMPERSAND_ORD:</span>
<span class="gi">+            is_utf7 = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            result.append(chr(byte))</span>
<span class="gi">+    </span>
<span class="gi">+    return &#39;&#39;.join(result)</span>
<span class="gh">diff --git a/imapclient/imapclient.py b/imapclient/imapclient.py</span>
<span class="gh">index 1b399f1..5a51a7f 100644</span>
<span class="gd">--- a/imapclient/imapclient.py</span>
<span class="gi">+++ b/imapclient/imapclient.py</span>
<span class="gu">@@ -12,6 +12,8 @@ from datetime import date, datetime</span>
<span class="w"> </span>from logging import getLogger, LoggerAdapter
<span class="w"> </span>from operator import itemgetter
<span class="w"> </span>from typing import List, Optional
<span class="gi">+from .util import require_capability, assert_imap_protocol</span>
<span class="gi">+from functools import wraps</span>
<span class="w"> </span>from . import exceptions, imap4, response_lexer, tls
<span class="w"> </span>from .datetime_util import datetime_to_INTERNALDATE, format_criteria_date
<span class="w"> </span>from .imap_utf7 import decode as decode_utf7
<span class="gu">@@ -113,9 +115,28 @@ class Quota:</span>
<span class="w"> </span>    limit: bytes


<span class="gi">+def _parse_quota(quota_response):</span>
<span class="gi">+    &quot;&quot;&quot;Parse the QUOTA response from the server.&quot;&quot;&quot;</span>
<span class="gi">+    quotas = []</span>
<span class="gi">+    for quota_root, quota_items in quota_response:</span>
<span class="gi">+        quota_root = quota_root.decode()</span>
<span class="gi">+        for resource, usage, limit in zip(quota_items[::3], quota_items[1::3], quota_items[2::3]):</span>
<span class="gi">+            quotas.append(Quota(quota_root, resource.decode(), usage, limit))</span>
<span class="gi">+    return quotas</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def require_capability(capability):
<span class="w"> </span>    &quot;&quot;&quot;Decorator raising CapabilityError when a capability is not available.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        @wraps(func)</span>
<span class="gi">+        def wrapper(self, *args, **kwargs):</span>
<span class="gi">+            if not self.has_capability(capability):</span>
<span class="gi">+                raise CapabilityError(</span>
<span class="gi">+                    &quot;{} requires {} capability&quot;.format(func.__name__, capability)</span>
<span class="gi">+                )</span>
<span class="gi">+            return func(self, *args, **kwargs)</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>class IMAPClient:
<span class="gu">@@ -166,8 +187,12 @@ class IMAPClient:</span>

<span class="w"> </span>    &gt;&gt;&gt; with IMAPClient(host=&quot;imap.foo.org&quot;) as client:
<span class="w"> </span>    ...     client.login(&quot;bar@foo.org&quot;, &quot;passwd&quot;)
<span class="gd">-</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    imaplib = imaplib</span>
<span class="gi">+    tls = tls</span>
<span class="gi">+    imap4 = imap4</span>
<span class="gi">+</span>
<span class="w"> </span>    Error = exceptions.IMAPClientError
<span class="w"> </span>    AbortError = exceptions.IMAPClientAbortError
<span class="w"> </span>    ReadOnlyError = exceptions.IMAPClientReadOnlyError
<span class="gu">@@ -209,6 +234,14 @@ class IMAPClient:</span>
<span class="w"> </span>        self._imap.debug = 5
<span class="w"> </span>        self._imap._mesg = imaplib_logger.debug

<span class="gi">+    def _create_IMAP4(self):</span>
<span class="gi">+        if self.stream:</span>
<span class="gi">+            return self.imaplib.IMAP4_stream(self.host)</span>
<span class="gi">+        elif self.ssl:</span>
<span class="gi">+            return self.tls.IMAP4_TLS(self.host, self.port, self.ssl_context, self._timeout.connect)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.imap4.IMAP4WithTimeout(self.host, self.port, self._timeout.connect)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self

<span class="gu">@@ -218,6 +251,24 @@ class IMAPClient:</span>
<span class="w"> </span>        All exceptions during logout and connection shutdown are caught because
<span class="w"> </span>        an error here usually means the connection was already closed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        try:</span>
<span class="gi">+            self.logout()</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+        finally:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.shutdown()</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.logout()</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+        finally:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.shutdown()</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                pass</span>
<span class="w"> </span>        try:
<span class="w"> </span>            self.logout()
<span class="w"> </span>        except Exception:
<span class="gu">@@ -239,7 +290,7 @@ class IMAPClient:</span>
<span class="w"> </span>           This includes reading from and writing to the socket,
<span class="w"> </span>           as they are likely to break internal bookkeeping of messages.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._imap.sock</span>

<span class="w"> </span>    @require_capability(&#39;STARTTLS&#39;)
<span class="w"> </span>    def starttls(self, ssl_context=None):
<span class="gu">@@ -259,13 +310,37 @@ class IMAPClient:</span>
<span class="w"> </span>        Raises :py:exc:`AbortError` if the server does not support STARTTLS
<span class="w"> </span>        or an SSL connection is already established.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ssl:</span>
<span class="gi">+            raise self.AbortError(&#39;SSL connection already established&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if ssl_context is None:</span>
<span class="gi">+            ssl_context = ssl_lib.create_default_context()</span>
<span class="gi">+</span>
<span class="gi">+        typ, data = self._imap._simple_command(&#39;STARTTLS&#39;)</span>
<span class="gi">+        if typ != &#39;OK&#39;:</span>
<span class="gi">+            raise self.Error(&#39;STARTTLS failed: %s&#39; % data[0].decode())</span>
<span class="gi">+</span>
<span class="gi">+        self._imap.sock = ssl_context.wrap_socket(self._imap.sock,</span>
<span class="gi">+                                                  server_hostname=self.host)</span>
<span class="gi">+        self._imap.file = self._imap.sock.makefile(&#39;rb&#39;)</span>
<span class="gi">+        self.ssl = True</span>
<span class="gi">+        self._starttls_done = True</span>
<span class="gi">+</span>
<span class="gi">+        # Reissue CAPABILITY command after STARTTLS</span>
<span class="gi">+        self._cached_capabilities = None</span>
<span class="gi">+        self.capabilities()</span>

<span class="w"> </span>    def login(self, username: str, password: str):
<span class="w"> </span>        &quot;&quot;&quot;Login using *username* and *password*, returning the
<span class="w"> </span>        server response.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            rv = self._imap.login(username, password)</span>
<span class="gi">+        except imaplib.IMAP4.error as e:</span>
<span class="gi">+            raise self.Error(str(e))</span>
<span class="gi">+</span>
<span class="gi">+        self._cached_capabilities = None</span>
<span class="gi">+        return rv</span>

<span class="w"> </span>    def oauth2_login(self, user: str, access_token: str, mech: str=
<span class="w"> </span>        &#39;XOAUTH2&#39;, vendor: Optional[str]=None):
<span class="gu">@@ -274,7 +349,21 @@ class IMAPClient:</span>
<span class="w"> </span>        Gmail and Yahoo both support the &#39;XOAUTH2&#39; mechanism, but Yahoo requires
<span class="w"> </span>        the &#39;vendor&#39; portion in the payload.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        auth_string = &#39;user=%s\1auth=Bearer %s\1&#39; % (user, access_token)</span>
<span class="gi">+        if vendor:</span>
<span class="gi">+            auth_string += &#39;vendor=%s\1&#39; % vendor</span>
<span class="gi">+        auth_string += &#39;\1&#39;</span>
<span class="gi">+        </span>
<span class="gi">+        try:</span>
<span class="gi">+            if mech == &#39;XOAUTH2&#39;:</span>
<span class="gi">+                rv = self._imap.authenticate(&#39;XOAUTH2&#39;, lambda x: auth_string)</span>
<span class="gi">+            else:</span>
<span class="gi">+                rv = self._imap.authenticate(&#39;OAUTH2&#39;, lambda x: auth_string)</span>
<span class="gi">+        except imaplib.IMAP4.error as e:</span>
<span class="gi">+            raise self.Error(str(e))</span>
<span class="gi">+</span>
<span class="gi">+        self._cached_capabilities = None</span>
<span class="gi">+        return rv</span>

<span class="w"> </span>    def oauthbearer_login(self, identity, access_token):
<span class="w"> </span>        &quot;&quot;&quot;Authenticate using the OAUTHBEARER method.
<span class="gu">@@ -1157,7 +1246,9 @@ class _dict_bytes_normaliser:</span>

<span class="w"> </span>    def __init__(self, d):
<span class="w"> </span>        self._d = d
<span class="gd">-    items = iteritems</span>
<span class="gi">+</span>
<span class="gi">+    def items(self):</span>
<span class="gi">+        return self._d.items()</span>

<span class="w"> </span>    def __contains__(self, ink):
<span class="w"> </span>        for k in self._gen_keys(ink):
<span class="gu">@@ -1168,3 +1259,24 @@ class _dict_bytes_normaliser:</span>

<span class="w"> </span>class IMAPlibLoggerAdapter(LoggerAdapter):
<span class="w"> </span>    &quot;&quot;&quot;Adapter preventing IMAP secrets from going to the logging facility.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+class TestableIMAPClient(IMAPClient):</span>
<span class="gi">+    &quot;&quot;&quot;Wrapper of :py:class:`imapclient.IMAPClient` that mocks all</span>
<span class="gi">+    interaction with real IMAP server.</span>
<span class="gi">+</span>
<span class="gi">+    This class should only be used in tests, where you can safely</span>
<span class="gi">+    interact with imapclient without running commands on a real</span>
<span class="gi">+    IMAP account.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        super().__init__(&#39;somehost&#39;)</span>
<span class="gi">+        self.socket = None</span>
<span class="gi">+        self._imap = MockIMAP4()</span>
<span class="gi">+        self._imap._client = self</span>
<span class="gi">+</span>
<span class="gi">+    def _create_IMAP4(self):</span>
<span class="gi">+        return self._imap</span>
<span class="gi">+</span>
<span class="gi">+    def _create_IMAP4(self):</span>
<span class="gi">+        return MockIMAP4()</span>
<span class="gh">diff --git a/imapclient/response_parser.py b/imapclient/response_parser.py</span>
<span class="gh">index f632411..a3a087a 100644</span>
<span class="gd">--- a/imapclient/response_parser.py</span>
<span class="gi">+++ b/imapclient/response_parser.py</span>
<span class="gu">@@ -22,7 +22,27 @@ def parse_response(data: List[bytes]) -&gt;Tuple[_Atom, ...]:</span>

<span class="w"> </span>    Returns nested tuples of appropriately typed objects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lexer = TokenSource(data)</span>
<span class="gi">+    return tuple(_parse_tokens(lexer))</span>
<span class="gi">+</span>
<span class="gi">+def _parse_tokens(lexer: TokenSource) -&gt;Iterator[_Atom]:</span>
<span class="gi">+    for token in lexer:</span>
<span class="gi">+        if token == b&#39;(&#39;:</span>
<span class="gi">+            yield tuple(_parse_tokens(lexer))</span>
<span class="gi">+        elif token == b&#39;)&#39;:</span>
<span class="gi">+            return</span>
<span class="gi">+        elif isinstance(token, bytes):</span>
<span class="gi">+            yield _convert_token(token, lexer.current_literal)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ProtocolError(f&#39;Unexpected token: {token}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def _convert_token(token: bytes, literal: Optional[bytes]) -&gt;_Atom:</span>
<span class="gi">+    if literal is not None:</span>
<span class="gi">+        return literal</span>
<span class="gi">+    try:</span>
<span class="gi">+        return int(token)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return token</span>


<span class="w"> </span>_msg_id_pattern = re.compile(&#39;(\\d+(?: +\\d+)*)&#39;)
<span class="gu">@@ -39,7 +59,22 @@ def parse_message_list(data: List[Union[bytes, str]]) -&gt;SearchIds:</span>
<span class="w"> </span>    attribute which contains the MODSEQ response (if returned by the
<span class="w"> </span>    server).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    data = [item.decode(&#39;ascii&#39;) if isinstance(item, bytes) else item for item in data]</span>
<span class="gi">+    data = &#39; &#39;.join(data)</span>
<span class="gi">+    </span>
<span class="gi">+    modseq = None</span>
<span class="gi">+    if &#39;MODSEQ&#39; in data:</span>
<span class="gi">+        modseq_index = data.index(&#39;MODSEQ&#39;)</span>
<span class="gi">+        modseq = int(data[modseq_index + 1])</span>
<span class="gi">+        data = data[:modseq_index]</span>
<span class="gi">+    </span>
<span class="gi">+    ids = [int(num) for num in _msg_id_pattern.findall(data)]</span>
<span class="gi">+    search_ids = SearchIds(ids)</span>
<span class="gi">+    </span>
<span class="gi">+    if modseq:</span>
<span class="gi">+        search_ids.modseq = modseq</span>
<span class="gi">+    </span>
<span class="gi">+    return search_ids</span>


<span class="w"> </span>_ParseFetchResponseInnerDict = Dict[bytes, Optional[Union[datetime.datetime,
<span class="gu">@@ -53,4 +88,30 @@ def parse_fetch_response(text: List[bytes], normalise_times: bool=True,</span>
<span class="w"> </span>    Returns a dictionary, keyed by message ID. Each value a dictionary
<span class="w"> </span>    keyed by FETCH field type (eg.&quot;RFC822&quot;).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    response = defaultdict(dict)</span>
<span class="gi">+    for response_item in parse_response(text):</span>
<span class="gi">+        msg_id, fetch_data = response_item</span>
<span class="gi">+        msg_id = int(msg_id)</span>
<span class="gi">+        </span>
<span class="gi">+        for field, value in _parse_fetch_pairs(fetch_data):</span>
<span class="gi">+            field = field.upper()</span>
<span class="gi">+            </span>
<span class="gi">+            if field == b&#39;UID&#39; and uid_is_key:</span>
<span class="gi">+                msg_id = value</span>
<span class="gi">+            elif field == b&#39;INTERNALDATE&#39; and normalise_times:</span>
<span class="gi">+                value = parse_to_datetime(value)</span>
<span class="gi">+            elif field in (b&#39;BODY&#39;, b&#39;BODY.PEEK&#39;):</span>
<span class="gi">+                value = BodyData(value)</span>
<span class="gi">+            elif field == b&#39;ENVELOPE&#39;:</span>
<span class="gi">+                value = Envelope(*value)</span>
<span class="gi">+            </span>
<span class="gi">+            response[msg_id][field] = value</span>
<span class="gi">+    </span>
<span class="gi">+    return response</span>
<span class="gi">+</span>
<span class="gi">+def _parse_fetch_pairs(fetch_data: Tuple[_Atom, ...]) -&gt;Iterator[Tuple[bytes, _Atom]]:</span>
<span class="gi">+    for i in range(0, len(fetch_data), 2):</span>
<span class="gi">+        field = fetch_data[i]</span>
<span class="gi">+        if not isinstance(field, bytes):</span>
<span class="gi">+            raise ProtocolError(f&#39;Field name must be bytes: {field}&#39;)</span>
<span class="gi">+        yield field, fetch_data[i + 1]</span>
<span class="gh">diff --git a/imapclient/util.py b/imapclient/util.py</span>
<span class="gh">index 5e3fab3..33c7c18 100644</span>
<span class="gd">--- a/imapclient/util.py</span>
<span class="gi">+++ b/imapclient/util.py</span>
<span class="gu">@@ -1,6 +1,50 @@</span>
<span class="w"> </span>import logging
<span class="gi">+import functools</span>
<span class="w"> </span>from typing import Iterator, Optional, Tuple, Union
<span class="w"> </span>from . import exceptions
<span class="gi">+from .exceptions import CapabilityError</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="w"> </span>_TupleAtomPart = Union[None, int, bytes]
<span class="w"> </span>_TupleAtom = Tuple[Union[_TupleAtomPart, &#39;_TupleAtom&#39;], ...]
<span class="gi">+</span>
<span class="gi">+def assert_imap_protocol(condition: bool, message: str) -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Raise ProtocolError if condition is not met.&quot;&quot;&quot;</span>
<span class="gi">+    if not condition:</span>
<span class="gi">+        raise ProtocolError(message)</span>
<span class="gi">+</span>
<span class="gi">+def require_capability(capability):</span>
<span class="gi">+    &quot;&quot;&quot;Decorator raising CapabilityError when a capability is not available.&quot;&quot;&quot;</span>
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        @functools.wraps(func)</span>
<span class="gi">+        def wrapper(self, *args, **kwargs):</span>
<span class="gi">+            if not self.has_capability(capability):</span>
<span class="gi">+                raise CapabilityError(</span>
<span class="gi">+                    &quot;{} requires {} capability which is not supported by the server&quot;.format(</span>
<span class="gi">+                        func.__name__, capability</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+            return func(self, *args, **kwargs)</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    return decorator</span>
<span class="gi">+    &quot;&quot;&quot;Assert that the condition is true, raising a ProtocolError otherwise.&quot;&quot;&quot;</span>
<span class="gi">+    if not condition:</span>
<span class="gi">+        raise exceptions.ProtocolError(message)</span>
<span class="gi">+</span>
<span class="gi">+def to_unicode(s):</span>
<span class="gi">+    &quot;&quot;&quot;Convert a bytes object to a unicode string.&quot;&quot;&quot;</span>
<span class="gi">+    if isinstance(s, bytes):</span>
<span class="gi">+        return s.decode(&#39;utf-8&#39;)</span>
<span class="gi">+    return s</span>
<span class="gi">+</span>
<span class="gi">+def chunk(lst, size):</span>
<span class="gi">+    &quot;&quot;&quot;Yield successive n-sized chunks from lst.&quot;&quot;&quot;</span>
<span class="gi">+    for i in range(0, len(lst), size):</span>
<span class="gi">+        yield lst[i:i + size]</span>
<span class="gi">+</span>
<span class="gi">+def to_bytes(s):</span>
<span class="gi">+    &quot;&quot;&quot;Convert a string to bytes.&quot;&quot;&quot;</span>
<span class="gi">+    if isinstance(s, str):</span>
<span class="gi">+        return s.encode(&#39;utf-8&#39;)</span>
<span class="gi">+    return s</span>
<span class="gi">+import functools</span>
<span class="gi">+from .exceptions import ProtocolError, CapabilityError</span>
<span class="gh">diff --git a/imapclient/version.py b/imapclient/version.py</span>
<span class="gh">index 9e7d8dc..9f47994 100644</span>
<span class="gd">--- a/imapclient/version.py</span>
<span class="gi">+++ b/imapclient/version.py</span>
<span class="gu">@@ -1,5 +1,8 @@</span>
<span class="w"> </span>from typing import Tuple
<span class="w"> </span>version_info = 3, 0, 1, &#39;final&#39;
<span class="gi">+def _imapclient_version_string(version_info):</span>
<span class="gi">+    return &#39;.&#39;.join(str(x) for x in version_info)</span>
<span class="gi">+</span>
<span class="w"> </span>version = _imapclient_version_string(version_info)
<span class="w"> </span>maintainer = &#39;IMAPClient Maintainers&#39;
<span class="w"> </span>maintainer_email = &#39;imapclient@groups.io&#39;
<span class="gh">diff --git a/tests/test_imap_utf7.py b/tests/test_imap_utf7.py</span>
<span class="gh">index 99b2967..75c3d32 100644</span>
<span class="gd">--- a/tests/test_imap_utf7.py</span>
<span class="gi">+++ b/tests/test_imap_utf7.py</span>
<span class="gu">@@ -11,7 +11,7 @@ class IMAP4UTF7TestCase(unittest.TestCase):</span>
<span class="w"> </span>    tests = [
<span class="w"> </span>        [&quot;Foo&quot;, b&quot;Foo&quot;],
<span class="w"> </span>        [&quot;Foo Bar&quot;, b&quot;Foo Bar&quot;],
<span class="gd">-        [&quot;Stuff &amp; Things&quot;, b&quot;Stuff &amp;- Things&quot;],</span>
<span class="gi">+        [&quot;Stuff &amp; Things&quot;, b&quot;Stuff &amp;-Things&quot;],</span>
<span class="w"> </span>        [&quot;Hello world&quot;, b&quot;Hello world&quot;],
<span class="w"> </span>        [&quot;Hello &amp; world&quot;, b&quot;Hello &amp;- world&quot;],
<span class="w"> </span>        [&quot;Hello\xffworld&quot;, b&quot;Hello&amp;AP8-world&quot;],
<span class="gu">@@ -46,5 +46,4 @@ class IMAP4UTF7TestCase(unittest.TestCase):</span>
<span class="w"> </span>            self.assertEqual(bytes((o,)), encode(chr(o)))
<span class="w"> </span>            self.assertEqual(chr(o), decode(bytes((o,))))
<span class="w"> </span>        self.assertEqual(encode(&quot;&amp;&quot;), b&quot;&amp;-&quot;)
<span class="gd">-        self.assertEqual(encode(&quot;&amp;&quot;), b&quot;&amp;-&quot;)</span>
<span class="w"> </span>        self.assertEqual(decode(b&quot;&amp;-&quot;), &quot;&amp;&quot;)
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>