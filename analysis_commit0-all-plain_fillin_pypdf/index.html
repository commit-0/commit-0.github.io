
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin pypdf - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-pypdf" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin pypdf
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-pypdf"><strong>Claude Sonnet 3.5 - Fill-in</strong>: pypdf</h1>
<h2 id="failed-to-run-pytests-for-test-tests">Failed to run pytests for test <code>tests</code></h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/__init__.py:10: in &lt;module&gt;
    from pypdf.generic import DictionaryObject, IndirectObject
pypdf/__init__.py:10: in &lt;module&gt;
    from ._crypt_providers import crypt_provider
pypdf/_crypt_providers/__init__.py:62: in &lt;module&gt;
    from pypdf._crypt_providers._fallback import (  # type: ignore
E   ImportError: cannot import name &#39;aes_cbc_decrypt&#39; from &#39;pypdf._crypt_providers._fallback&#39; (/testbed/pypdf/_crypt_providers/_fallback.py)
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/pypdf/_cmap.py b/pypdf/_cmap.py</span>
<span class="gh">index 77c2f84..703c77e 100644</span>
<span class="gd">--- a/pypdf/_cmap.py</span>
<span class="gi">+++ b/pypdf/_cmap.py</span>
<span class="gu">@@ -21,7 +21,26 @@ def build_char_map(font_name: str, space_width: float, obj: DictionaryObject</span>
<span class="w"> </span>        Font sub-type, space_width criteria (50% of width), encoding, map character-map, font-dictionary.
<span class="w"> </span>        The font-dictionary itself is suitable for the curious.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &quot;/Resources&quot; not in obj:</span>
<span class="gi">+        return unknown_char_map + (NullObject(),)</span>
<span class="gi">+    </span>
<span class="gi">+    resources = obj[&quot;/Resources&quot;]</span>
<span class="gi">+    if &quot;/Font&quot; not in resources:</span>
<span class="gi">+        return unknown_char_map + (NullObject(),)</span>
<span class="gi">+    </span>
<span class="gi">+    fonts = resources[&quot;/Font&quot;]</span>
<span class="gi">+    if font_name not in fonts:</span>
<span class="gi">+        return unknown_char_map + (NullObject(),)</span>
<span class="gi">+    </span>
<span class="gi">+    font = fonts[font_name]</span>
<span class="gi">+    if isinstance(font, IndirectObject):</span>
<span class="gi">+        font = font.get_object()</span>
<span class="gi">+    </span>
<span class="gi">+    if not isinstance(font, DictionaryObject):</span>
<span class="gi">+        return unknown_char_map + (NullObject(),)</span>
<span class="gi">+    </span>
<span class="gi">+    subtype, space_width, encoding, char_map = build_char_map_from_dict(space_width, font)</span>
<span class="gi">+    return subtype, space_width, encoding, char_map, font</span>


<span class="w"> </span>def build_char_map_from_dict(space_width: float, ft: DictionaryObject) -&gt;Tuple[
<span class="gu">@@ -38,7 +57,35 @@ def build_char_map_from_dict(space_width: float, ft: DictionaryObject) -&gt;Tuple[</span>
<span class="w"> </span>        Font sub-type, space_width criteria(50% of width), encoding, map character-map.
<span class="w"> </span>        The font-dictionary itself is suitable for the curious.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    subtype = ft.get(&quot;/Subtype&quot;, &quot;&quot;)</span>
<span class="gi">+    encoding = ft.get(&quot;/Encoding&quot;, &quot;&quot;)</span>
<span class="gi">+    char_map = {}</span>
<span class="gi">+</span>
<span class="gi">+    if &quot;/ToUnicode&quot; in ft:</span>
<span class="gi">+        try:</span>
<span class="gi">+            char_map = _build_to_unicode_map(ft[&quot;/ToUnicode&quot;])</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            logger_warning(f&quot;Error building ToUnicode map: {e}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if not char_map and isinstance(encoding, DictionaryObject):</span>
<span class="gi">+        char_map = _build_encoding_map(encoding)</span>
<span class="gi">+</span>
<span class="gi">+    if not char_map and isinstance(encoding, str):</span>
<span class="gi">+        if encoding in charset_encoding:</span>
<span class="gi">+            char_map = dict(zip(range(256), charset_encoding[encoding]))</span>
<span class="gi">+        elif encoding in _predefined_cmap:</span>
<span class="gi">+            char_map = _predefined_cmap[encoding]</span>
<span class="gi">+</span>
<span class="gi">+    if &quot;/FirstChar&quot; in ft and &quot;/LastChar&quot; in ft and &quot;/Widths&quot; in ft:</span>
<span class="gi">+        first_char = ft[&quot;/FirstChar&quot;]</span>
<span class="gi">+        last_char = ft[&quot;/LastChar&quot;]</span>
<span class="gi">+        widths = ft[&quot;/Widths&quot;]</span>
<span class="gi">+        if 32 in range(first_char, last_char + 1):</span>
<span class="gi">+            space_width = widths[32 - first_char]</span>
<span class="gi">+</span>
<span class="gi">+    space_width_criteria = space_width * 0.5</span>
<span class="gi">+</span>
<span class="gi">+    return subtype, space_width_criteria, encoding, char_map</span>


<span class="w"> </span>unknown_char_map: Tuple[str, float, Union[str, Dict[int, str]], Dict[Any, Any]
<span class="gh">diff --git a/pypdf/_crypt_providers/_base.py b/pypdf/_crypt_providers/_base.py</span>
<span class="gh">index 916f3fd..2136f91 100644</span>
<span class="gd">--- a/pypdf/_crypt_providers/_base.py</span>
<span class="gi">+++ b/pypdf/_crypt_providers/_base.py</span>
<span class="gu">@@ -1,6 +1,17 @@</span>
<span class="w"> </span>class CryptBase:
<span class="gd">-    pass</span>
<span class="gi">+    def __init__(self):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def encrypt(self, data):</span>
<span class="gi">+        raise NotImplementedError(&quot;Subclasses must implement the encrypt method&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def decrypt(self, data):</span>
<span class="gi">+        raise NotImplementedError(&quot;Subclasses must implement the decrypt method&quot;)</span>


<span class="w"> </span>class CryptIdentity(CryptBase):
<span class="gd">-    pass</span>
<span class="gi">+    def encrypt(self, data):</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    def decrypt(self, data):</span>
<span class="gi">+        return data</span>
<span class="gh">diff --git a/pypdf/_crypt_providers/_fallback.py b/pypdf/_crypt_providers/_fallback.py</span>
<span class="gh">index f69eb28..566f0e7 100644</span>
<span class="gd">--- a/pypdf/_crypt_providers/_fallback.py</span>
<span class="gi">+++ b/pypdf/_crypt_providers/_fallback.py</span>
<span class="gu">@@ -12,9 +12,44 @@ class CryptRC4(CryptBase):</span>
<span class="w"> </span>        for i in range(256):
<span class="w"> </span>            j = (j + self.s[i] + key[i % len(key)]) % 256
<span class="w"> </span>            self.s[i], self.s[j] = self.s[j], self.s[i]
<span class="gi">+        self.i = 0</span>
<span class="gi">+        self.j = 0</span>
<span class="gi">+</span>
<span class="gi">+    def encrypt(self, data: bytes) -&gt;bytes:</span>
<span class="gi">+        return self.decrypt(data)</span>
<span class="gi">+</span>
<span class="gi">+    def decrypt(self, data: bytes) -&gt;bytes:</span>
<span class="gi">+        out = bytearray()</span>
<span class="gi">+        for byte in data:</span>
<span class="gi">+            self.i = (self.i + 1) % 256</span>
<span class="gi">+            self.j = (self.j + self.s[self.i]) % 256</span>
<span class="gi">+            self.s[self.i], self.s[self.j] = self.s[self.j], self.s[self.i]</span>
<span class="gi">+            out.append(byte ^ self.s[(self.s[self.i] + self.s[self.j]) % 256])</span>
<span class="gi">+        return bytes(out)</span>


<span class="w"> </span>class CryptAES(CryptBase):

<span class="w"> </span>    def __init__(self, key: bytes) -&gt;None:
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            from Crypto.Cipher import AES</span>
<span class="gi">+            from Crypto.Util.Padding import pad, unpad</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            raise DependencyError(_DEPENDENCY_ERROR_STR)</span>
<span class="gi">+        </span>
<span class="gi">+        self.key = key</span>
<span class="gi">+        self.aes = AES</span>
<span class="gi">+        self.pad = pad</span>
<span class="gi">+        self.unpad = unpad</span>
<span class="gi">+</span>
<span class="gi">+    def encrypt(self, data: bytes) -&gt;bytes:</span>
<span class="gi">+        cipher = self.aes.new(self.key, self.aes.MODE_CBC)</span>
<span class="gi">+        padded_data = self.pad(data, self.aes.block_size)</span>
<span class="gi">+        return cipher.iv + cipher.encrypt(padded_data)</span>
<span class="gi">+</span>
<span class="gi">+    def decrypt(self, data: bytes) -&gt;bytes:</span>
<span class="gi">+        iv = data[:16]</span>
<span class="gi">+        encrypted_data = data[16:]</span>
<span class="gi">+        cipher = self.aes.new(self.key, self.aes.MODE_CBC, iv)</span>
<span class="gi">+        padded_data = cipher.decrypt(encrypted_data)</span>
<span class="gi">+        return self.unpad(padded_data, self.aes.block_size)</span>
<span class="gh">diff --git a/pypdf/_doc_common.py b/pypdf/_doc_common.py</span>
<span class="gh">index eaec7b5..5a7246f 100644</span>
<span class="gd">--- a/pypdf/_doc_common.py</span>
<span class="gi">+++ b/pypdf/_doc_common.py</span>
<span class="gu">@@ -47,12 +47,14 @@ class DocumentInformation(DictionaryObject):</span>
<span class="w"> </span>        Returns a ``TextStringObject`` or ``None`` if the title is not
<span class="w"> </span>        specified.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if DI.TITLE in self:</span>
<span class="gi">+            return self[DI.TITLE]</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def title_raw(self) -&gt;Optional[str]:
<span class="w"> </span>        &quot;&quot;&quot;The &quot;raw&quot; version of title; can return a ``ByteStringObject``.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get(DI.TITLE)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def author(self) -&gt;Optional[str]:
<span class="gu">@@ -62,12 +64,14 @@ class DocumentInformation(DictionaryObject):</span>
<span class="w"> </span>        Returns a ``TextStringObject`` or ``None`` if the author is not
<span class="w"> </span>        specified.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if DI.AUTHOR in self:</span>
<span class="gi">+            return self[DI.AUTHOR]</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def author_raw(self) -&gt;Optional[str]:
<span class="w"> </span>        &quot;&quot;&quot;The &quot;raw&quot; version of author; can return a ``ByteStringObject``.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get(DI.AUTHOR)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def subject(self) -&gt;Optional[str]:
<span class="gu">@@ -77,12 +81,14 @@ class DocumentInformation(DictionaryObject):</span>
<span class="w"> </span>        Returns a ``TextStringObject`` or ``None`` if the subject is not
<span class="w"> </span>        specified.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if DI.SUBJECT in self:</span>
<span class="gi">+            return self[DI.SUBJECT]</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def subject_raw(self) -&gt;Optional[str]:
<span class="w"> </span>        &quot;&quot;&quot;The &quot;raw&quot; version of subject; can return a ``ByteStringObject``.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get(DI.SUBJECT)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def creator(self) -&gt;Optional[str]:
<span class="gu">@@ -94,12 +100,14 @@ class DocumentInformation(DictionaryObject):</span>
<span class="w"> </span>        document from which it was converted. Returns a ``TextStringObject`` or
<span class="w"> </span>        ``None`` if the creator is not specified.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if DI.CREATOR in self:</span>
<span class="gi">+            return self[DI.CREATOR]</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def creator_raw(self) -&gt;Optional[str]:
<span class="w"> </span>        &quot;&quot;&quot;The &quot;raw&quot; version of creator; can return a ``ByteStringObject``.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get(DI.CREATOR)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def producer(self) -&gt;Optional[str]:
<span class="gu">@@ -111,17 +119,21 @@ class DocumentInformation(DictionaryObject):</span>
<span class="w"> </span>        PDF. Returns a ``TextStringObject`` or ``None`` if the producer is not
<span class="w"> </span>        specified.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if DI.PRODUCER in self:</span>
<span class="gi">+            return self[DI.PRODUCER]</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def producer_raw(self) -&gt;Optional[str]:
<span class="w"> </span>        &quot;&quot;&quot;The &quot;raw&quot; version of producer; can return a ``ByteStringObject``.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get(DI.PRODUCER)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def creation_date(self) -&gt;Optional[datetime]:
<span class="w"> </span>        &quot;&quot;&quot;Read-only property accessing the document&#39;s creation date.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if DI.CREATION_DATE in self:</span>
<span class="gi">+            return parse_iso8824_date(self[DI.CREATION_DATE])</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def creation_date_raw(self) -&gt;Optional[str]:
<span class="gu">@@ -131,7 +143,7 @@ class DocumentInformation(DictionaryObject):</span>
<span class="w"> </span>        Typically in the format ``D:YYYYMMDDhhmmss[+Z-]hh&#39;mm`` where the suffix
<span class="w"> </span>        is the offset from UTC.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get(DI.CREATION_DATE)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def modification_date(self) -&gt;Optional[datetime]:
<span class="gu">@@ -140,7 +152,9 @@ class DocumentInformation(DictionaryObject):</span>

<span class="w"> </span>        The date and time the document was most recently modified.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if DI.MOD_DATE in self:</span>
<span class="gi">+            return parse_iso8824_date(self[DI.MOD_DATE])</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def modification_date_raw(self) -&gt;Optional[str]:
<span class="gu">@@ -151,7 +165,7 @@ class DocumentInformation(DictionaryObject):</span>
<span class="w"> </span>        Typically in the format ``D:YYYYMMDDhhmmss[+Z-]hh&#39;mm`` where the suffix
<span class="w"> </span>        is the offset from UTC.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get(DI.MOD_DATE)</span>


<span class="w"> </span>class PdfDocCommon:
<span class="gh">diff --git a/pypdf/_encryption.py b/pypdf/_encryption.py</span>
<span class="gh">index 515e35b..4bb9492 100644</span>
<span class="gd">--- a/pypdf/_encryption.py</span>
<span class="gi">+++ b/pypdf/_encryption.py</span>
<span class="gu">@@ -147,7 +147,20 @@ class AlgV4:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The RC4 encrypted
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Step e: Pad or truncate the user password</span>
<span class="gi">+        padded_user_password = user_password[:32] + _PADDING[:max(0, 32 - len(user_password))]</span>
<span class="gi">+</span>
<span class="gi">+        # Step f: Encrypt the padded user password using RC4</span>
<span class="gi">+        o_value = rc4_encrypt(rc4_key, padded_user_password)</span>
<span class="gi">+</span>
<span class="gi">+        # Step g: Additional encryption for rev 3 or greater</span>
<span class="gi">+        if rev &gt;= 3:</span>
<span class="gi">+            for i in range(1, 20):</span>
<span class="gi">+                new_key = bytes(b ^ i for b in rc4_key)</span>
<span class="gi">+                o_value = rc4_encrypt(new_key, o_value)</span>
<span class="gi">+</span>
<span class="gi">+        # Step h: The final o_value is the result</span>
<span class="gi">+        return o_value</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def compute_U_value(key: bytes, rev: int, id1_entry: bytes) -&gt;bytes:
<span class="gh">diff --git a/pypdf/_merger.py b/pypdf/_merger.py</span>
<span class="gh">index db1073f..9e3e5fc 100644</span>
<span class="gd">--- a/pypdf/_merger.py</span>
<span class="gi">+++ b/pypdf/_merger.py</span>
<span class="gu">@@ -81,7 +81,31 @@ class PdfMerger:</span>
<span class="w"> </span>                outline (collection of outline items, previously referred to as
<span class="w"> </span>                &#39;bookmarks&#39;) from being imported by specifying this as ``False``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(fileobj, PdfReader):</span>
<span class="gi">+            reader = fileobj</span>
<span class="gi">+        else:</span>
<span class="gi">+            reader = PdfReader(fileobj)</span>
<span class="gi">+</span>
<span class="gi">+        if pages is None:</span>
<span class="gi">+            pages = range(len(reader.pages))</span>
<span class="gi">+        elif isinstance(pages, tuple):</span>
<span class="gi">+            pages = range(*pages)</span>
<span class="gi">+        elif isinstance(pages, int):</span>
<span class="gi">+            pages = [pages]</span>
<span class="gi">+</span>
<span class="gi">+        for i, page in enumerate(pages):</span>
<span class="gi">+            self.pages.insert(page_number + i, _MergedPage(reader.pages[page], reader, self.id_count))</span>
<span class="gi">+            self.id_count += 1</span>
<span class="gi">+</span>
<span class="gi">+        if outline_item is not None:</span>
<span class="gi">+            self.add_outline_item(outline_item, page_number)</span>
<span class="gi">+</span>
<span class="gi">+        if import_outline:</span>
<span class="gi">+            outline = reader.outline</span>
<span class="gi">+            if outline:</span>
<span class="gi">+                self.outline.extend(self._trim_outline(reader, outline, pages))</span>
<span class="gi">+</span>
<span class="gi">+        self.inputs.append((fileobj, reader))</span>

<span class="w"> </span>    def append(self, fileobj: Union[StrByteType, PdfReader, Path],
<span class="w"> </span>        outline_item: Optional[str]=None, pages: Union[None, PageRange,
<span class="gu">@@ -108,7 +132,7 @@ class PdfMerger:</span>
<span class="w"> </span>                outline (collection of outline items, previously referred to as
<span class="w"> </span>                &#39;bookmarks&#39;) from being imported by specifying this as ``False``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.merge(len(self.pages), fileobj, outline_item, pages, import_outline)</span>

<span class="w"> </span>    def write(self, fileobj: Union[Path, StrByteType]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -118,11 +142,31 @@ class PdfMerger:</span>
<span class="w"> </span>            fileobj: Output file. Can be a filename or any kind of
<span class="w"> </span>                file-like object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.output is None:</span>
<span class="gi">+            raise ValueError(ERR_CLOSED_WRITER)</span>
<span class="gi">+</span>
<span class="gi">+        for page in self.pages:</span>
<span class="gi">+            self.output.add_page(page.pagedata)</span>
<span class="gi">+</span>
<span class="gi">+        if self.outline:</span>
<span class="gi">+            self.output.add_outline_item_dict(self.outline)</span>
<span class="gi">+</span>
<span class="gi">+        for dest in self.named_dests:</span>
<span class="gi">+            self.output.add_named_destination_object(dest)</span>
<span class="gi">+</span>
<span class="gi">+        self.output.write(fileobj)</span>

<span class="w"> </span>    def close(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Shut all file descriptors (input and output) and clear all memory usage.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.output:</span>
<span class="gi">+            self.output.close()</span>
<span class="gi">+        for _, reader in self.inputs:</span>
<span class="gi">+            reader.stream.close()</span>
<span class="gi">+        self.inputs.clear()</span>
<span class="gi">+        self.pages.clear()</span>
<span class="gi">+        self.output = None</span>
<span class="gi">+        self.outline.clear()</span>
<span class="gi">+        self.named_dests.clear()</span>

<span class="w"> </span>    def add_metadata(self, infos: Dict[str, Any]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -133,7 +177,9 @@ class PdfMerger:</span>
<span class="w"> </span>                and each value is your new metadata.
<span class="w"> </span>                An example is ``{&#39;/Title&#39;: &#39;My title&#39;}``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.output is None:</span>
<span class="gi">+            raise ValueError(ERR_CLOSED_WRITER)</span>
<span class="gi">+        self.output.add_metadata(infos)</span>

<span class="w"> </span>    def set_page_layout(self, layout: LayoutType) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -160,7 +206,9 @@ class PdfMerger:</span>
<span class="w"> </span>           * - /TwoPageRight
<span class="w"> </span>             - Show two pages at a time, odd-numbered pages on the right
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.output is None:</span>
<span class="gi">+            raise ValueError(ERR_CLOSED_WRITER)</span>
<span class="gi">+        self.output.set_page_layout(layout)</span>

<span class="w"> </span>    def set_page_mode(self, mode: PagemodeType) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -185,7 +233,9 @@ class PdfMerger:</span>
<span class="w"> </span>           * - /UseAttachments
<span class="w"> </span>             - Show attachments panel
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.output is None:</span>
<span class="gi">+            raise ValueError(ERR_CLOSED_WRITER)</span>
<span class="gi">+        self.output.set_page_mode(mode)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def page_mode(self) -&gt;Optional[PagemodeType]:
<span class="gu">@@ -224,7 +274,13 @@ class PdfMerger:</span>
<span class="w"> </span>            dests:
<span class="w"> </span>            pages:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pages_set = set(pages)</span>
<span class="gi">+        trimmed_dests = []</span>
<span class="gi">+        for k, v in dests.items():</span>
<span class="gi">+            if isinstance(v, Dict):</span>
<span class="gi">+                if &#39;/Page&#39; in v and pdf.get_page_number(v[&#39;/Page&#39;]) in pages_set:</span>
<span class="gi">+                    trimmed_dests.append({k: v})</span>
<span class="gi">+        return trimmed_dests</span>

<span class="w"> </span>    def _trim_outline(self, pdf: PdfReader, outline: OutlineType, pages:
<span class="w"> </span>        Union[Tuple[int, int], Tuple[int, int, int], List[int]]) -&gt;OutlineType:
<span class="gu">@@ -239,7 +295,20 @@ class PdfMerger:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            An outline type
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pages_set = set(pages)</span>
<span class="gi">+        new_outline = []</span>
<span class="gi">+        for entry in outline:</span>
<span class="gi">+            if isinstance(entry, list):</span>
<span class="gi">+                sub_outline = self._trim_outline(pdf, entry, pages)</span>
<span class="gi">+                if sub_outline:</span>
<span class="gi">+                    new_outline.append(sub_outline)</span>
<span class="gi">+            elif isinstance(entry, dict):</span>
<span class="gi">+                if &#39;/Page&#39; in entry:</span>
<span class="gi">+                    if pdf.get_page_number(entry[&#39;/Page&#39;]) in pages_set:</span>
<span class="gi">+                        new_outline.append(entry)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    new_outline.append(entry)</span>
<span class="gi">+        return new_outline</span>

<span class="w"> </span>    def add_outline_item(self, title: str, page_number: int, parent: Union[
<span class="w"> </span>        None, TreeObject, IndirectObject]=None, color: Optional[Tuple[float,
<span class="gu">@@ -259,7 +328,18 @@ class PdfMerger:</span>
<span class="w"> </span>            italic: Outline item font is italic
<span class="w"> </span>            fit: The fit of the destination page.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.output is None:</span>
<span class="gi">+            raise ValueError(ERR_CLOSED_WRITER)</span>
<span class="gi">+</span>
<span class="gi">+        page = self.pages[page_number].pagedata</span>
<span class="gi">+        outline_item = OutlineItem(title, page, parent, color, bold, italic, fit)</span>
<span class="gi">+</span>
<span class="gi">+        if parent is None:</span>
<span class="gi">+            self.outline.append(outline_item)</span>
<span class="gi">+        else:</span>
<span class="gi">+            parent.children.append(outline_item)</span>
<span class="gi">+</span>
<span class="gi">+        return self.output.add_object(outline_item)</span>

<span class="w"> </span>    def add_named_destination(self, title: str, page_number: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -269,4 +349,9 @@ class PdfMerger:</span>
<span class="w"> </span>            title: Title to use
<span class="w"> </span>            page_number: Page number this destination points at.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.output is None:</span>
<span class="gi">+            raise ValueError(ERR_CLOSED_WRITER)</span>
<span class="gi">+</span>
<span class="gi">+        page = self.pages[page_number].pagedata</span>
<span class="gi">+        dest = Destination(TextStringObject(title), page)</span>
<span class="gi">+        self.named_dests.append(dest)</span>
<span class="gh">diff --git a/pypdf/_page.py b/pypdf/_page.py</span>
<span class="gh">index 9d11d1c..4c835d4 100644</span>
<span class="gd">--- a/pypdf/_page.py</span>
<span class="gi">+++ b/pypdf/_page.py</span>
<span class="gu">@@ -58,7 +58,8 @@ class Transformation:</span>

<span class="w"> </span>        ((a, b, 0), (c, d, 0), (e, f, 1))
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        a, b, c, d, e, f = self.ctm</span>
<span class="gi">+        return ((a, b, 0), (c, d, 0), (e, f, 1))</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def compress(matrix: TransformationMatrixType
<span class="gu">@@ -72,7 +73,7 @@ class Transformation:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A tuple representing the transformation matrix as (a, b, c, d, e, f)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (matrix[0][0], matrix[0][1], matrix[1][0], matrix[1][1], matrix[2][0], matrix[2][1])</span>

<span class="w"> </span>    def transform(self, m: &#39;Transformation&#39;) -&gt;&#39;Transformation&#39;:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -90,7 +91,16 @@ class Transformation:</span>
<span class="w"> </span>            &gt;&gt;&gt; op = Transformation().transform(Transformation((-1, 0, 0, 1, iwidth, 0))) # horizontal mirror
<span class="w"> </span>            &gt;&gt;&gt; page.add_transformation(op)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        a1, b1, c1, d1, e1, f1 = self.ctm</span>
<span class="gi">+        a2, b2, c2, d2, e2, f2 = m.ctm</span>
<span class="gi">+        return Transformation((</span>
<span class="gi">+            a1*a2 + b1*c2,</span>
<span class="gi">+            a1*b2 + b1*d2,</span>
<span class="gi">+            c1*a2 + d1*c2,</span>
<span class="gi">+            c1*b2 + d1*d2,</span>
<span class="gi">+            e1*a2 + f1*c2 + e2,</span>
<span class="gi">+            e1*b2 + f1*d2 + f2</span>
<span class="gi">+        ))</span>

<span class="w"> </span>    def translate(self, tx: float=0, ty: float=0) -&gt;&#39;Transformation&#39;:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -103,7 +113,7 @@ class Transformation:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A new ``Transformation`` instance
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Transformation((1, 0, 0, 1, tx, ty)).transform(self)</span>

<span class="w"> </span>    def scale(self, sx: Optional[float]=None, sy: Optional[float]=None
<span class="w"> </span>        ) -&gt;&#39;Transformation&#39;:
<span class="gu">@@ -120,7 +130,13 @@ class Transformation:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A new Transformation instance with the scaled matrix.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if sx is None and sy is None:</span>
<span class="gi">+            return self</span>
<span class="gi">+        if sx is None:</span>
<span class="gi">+            sx = sy</span>
<span class="gi">+        if sy is None:</span>
<span class="gi">+            sy = sx</span>
<span class="gi">+        return Transformation((sx, 0, 0, sy, 0, 0)).transform(self)</span>

<span class="w"> </span>    def rotate(self, rotation: float) -&gt;&#39;Transformation&#39;:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -132,7 +148,10 @@ class Transformation:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A new ``Transformation`` instance with the rotated matrix.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rotation_rad = math.radians(rotation)</span>
<span class="gi">+        cos_theta = math.cos(rotation_rad)</span>
<span class="gi">+        sin_theta = math.sin(rotation_rad)</span>
<span class="gi">+        return Transformation((cos_theta, sin_theta, -sin_theta, cos_theta, 0, 0)).transform(self)</span>

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        return f&#39;Transformation(ctm={self.ctm})&#39;
<span class="gu">@@ -144,11 +163,16 @@ class Transformation:</span>

<span class="w"> </span>        Args:
<span class="w"> </span>            pt: A tuple or list representing the point in the form (x, y)
<span class="gi">+            as_object: If True, return the result as a list, otherwise as a tuple</span>

<span class="w"> </span>        Returns:
<span class="w"> </span>            A tuple or list representing the transformed point in the form (x&#39;, y&#39;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x, y = pt</span>
<span class="gi">+        a, b, c, d, e, f = self.ctm</span>
<span class="gi">+        x_new = a * x + c * y + e</span>
<span class="gi">+        y_new = b * x + d * y + f</span>
<span class="gi">+        return [x_new, y_new] if as_object else (x_new, y_new)</span>


<span class="w"> </span>class PageObject(DictionaryObject):
<span class="gu">@@ -184,7 +208,7 @@ class PageObject(DictionaryObject):</span>
<span class="w"> </span>        space unit is 1/72 inch, and a value of 3 means that a user
<span class="w"> </span>        space unit is 3/72 inch.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get(&quot;/UserUnit&quot;, 1)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def create_blank_page(pdf: Optional[PdfCommonDocProtocol]=None, width:
<span class="gu">@@ -210,7 +234,25 @@ class PageObject(DictionaryObject):</span>
<span class="w"> </span>            PageSizeNotDefinedError: if ``pdf`` is ``None`` or contains
<span class="w"> </span>                no page
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        page = PageObject(pdf)</span>
<span class="gi">+</span>
<span class="gi">+        # Get the page size from the last page of PDF</span>
<span class="gi">+        if pdf is not None and len(pdf.pages) &gt; 0:</span>
<span class="gi">+            last_page = pdf.pages[-1]</span>
<span class="gi">+            if width is None:</span>
<span class="gi">+                width = last_page.mediabox.width</span>
<span class="gi">+            if height is None:</span>
<span class="gi">+                height = last_page.mediabox.height</span>
<span class="gi">+</span>
<span class="gi">+        if width is None or height is None:</span>
<span class="gi">+            raise PageSizeNotDefinedError</span>
<span class="gi">+</span>
<span class="gi">+        page[NameObject(PG.MEDIABOX)] = RectangleObject((0, 0, width, height))</span>
<span class="gi">+</span>
<span class="gi">+        page[NameObject(PG.RESOURCES)] = DictionaryObject()</span>
<span class="gi">+        page[NameObject(PG.CONTENTS)] = ArrayObject()</span>
<span class="gi">+</span>
<span class="gi">+        return page</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def _old_images(self) -&gt;List[File]:
<span class="gu">@@ -222,7 +264,14 @@ class PageObject(DictionaryObject):</span>
<span class="w"> </span>        For the moment, this does NOT include inline images. They will be added
<span class="w"> </span>        in future.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        images = []</span>
<span class="gi">+        resources = self.get(&quot;/Resources&quot;, {})</span>
<span class="gi">+        if &quot;/XObject&quot; in resources:</span>
<span class="gi">+            xobjects = resources[&quot;/XObject&quot;].get_object()</span>
<span class="gi">+            for obj in xobjects:</span>
<span class="gi">+                if xobjects[obj][&quot;/Subtype&quot;] == &quot;/Image&quot;:</span>
<span class="gi">+                    images.append(_xobj_to_image(xobjects[obj]))</span>
<span class="gi">+        return images</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def images(self) -&gt;List[ImageFile]:
<span class="gh">diff --git a/pypdf/_page_labels.py b/pypdf/_page_labels.py</span>
<span class="gh">index f061301..3082fb3 100644</span>
<span class="gd">--- a/pypdf/_page_labels.py</span>
<span class="gi">+++ b/pypdf/_page_labels.py</span>
<span class="gu">@@ -74,7 +74,57 @@ def index2label(reader: PdfCommonDocProtocol, index: int) -&gt;str:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The label of the page, e.g. &quot;iv&quot; or &quot;4&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &quot;/PageLabels&quot; not in reader.root_object:</span>
<span class="gi">+        return str(index + 1)</span>
<span class="gi">+</span>
<span class="gi">+    nums = reader.root_object[&quot;/PageLabels&quot;][&quot;/Nums&quot;]</span>
<span class="gi">+    label_dict = None</span>
<span class="gi">+    start_index = 0</span>
<span class="gi">+</span>
<span class="gi">+    for i in range(0, len(nums), 2):</span>
<span class="gi">+        if nums[i] &gt; index:</span>
<span class="gi">+            break</span>
<span class="gi">+        start_index = nums[i]</span>
<span class="gi">+        label_dict = reader.get_object(nums[i + 1])</span>
<span class="gi">+</span>
<span class="gi">+    if label_dict is None:</span>
<span class="gi">+        return str(index + 1)</span>
<span class="gi">+</span>
<span class="gi">+    style = label_dict.get(&quot;/S&quot;, &quot;D&quot;)</span>
<span class="gi">+    prefix = label_dict.get(&quot;/P&quot;, &quot;&quot;)</span>
<span class="gi">+    start = label_dict.get(&quot;/St&quot;, 1)</span>
<span class="gi">+</span>
<span class="gi">+    num = index - start_index + start</span>
<span class="gi">+</span>
<span class="gi">+    if style == &quot;/D&quot;:</span>
<span class="gi">+        return f&quot;{prefix}{num}&quot;</span>
<span class="gi">+    elif style == &quot;/R&quot;:</span>
<span class="gi">+        return f&quot;{prefix}{to_roman(num).upper()}&quot;</span>
<span class="gi">+    elif style == &quot;/r&quot;:</span>
<span class="gi">+        return f&quot;{prefix}{to_roman(num).lower()}&quot;</span>
<span class="gi">+    elif style == &quot;/A&quot;:</span>
<span class="gi">+        return f&quot;{prefix}{to_alpha(num).upper()}&quot;</span>
<span class="gi">+    elif style == &quot;/a&quot;:</span>
<span class="gi">+        return f&quot;{prefix}{to_alpha(num).lower()}&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return str(index + 1)</span>
<span class="gi">+</span>
<span class="gi">+def to_roman(num: int) -&gt; str:</span>
<span class="gi">+    roman = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]</span>
<span class="gi">+    arabic = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]</span>
<span class="gi">+    result = &quot;&quot;</span>
<span class="gi">+    for i, value in enumerate(arabic):</span>
<span class="gi">+        while num &gt;= value:</span>
<span class="gi">+            result += roman[i]</span>
<span class="gi">+            num -= value</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+def to_alpha(num: int) -&gt; str:</span>
<span class="gi">+    result = &quot;&quot;</span>
<span class="gi">+    while num &gt; 0:</span>
<span class="gi">+        num, remainder = divmod(num - 1, 26)</span>
<span class="gi">+        result = chr(65 + remainder) + result</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def nums_insert(key: NumberObject, value: DictionaryObject, nums: ArrayObject
<span class="gu">@@ -89,7 +139,15 @@ def nums_insert(key: NumberObject, value: DictionaryObject, nums: ArrayObject</span>
<span class="w"> </span>        value: value of the entry
<span class="w"> </span>        nums: Nums array to modify
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for i in range(0, len(nums), 2):</span>
<span class="gi">+        if nums[i] == key:</span>
<span class="gi">+            nums[i + 1] = value</span>
<span class="gi">+            return</span>
<span class="gi">+        elif nums[i] &gt; key:</span>
<span class="gi">+            nums.insert(i, value)</span>
<span class="gi">+            nums.insert(i, key)</span>
<span class="gi">+            return</span>
<span class="gi">+    nums.extend([key, value])</span>


<span class="w"> </span>def nums_clear_range(key: NumberObject, page_index_to: int, nums: ArrayObject
<span class="gu">@@ -104,7 +162,13 @@ def nums_clear_range(key: NumberObject, page_index_to: int, nums: ArrayObject</span>
<span class="w"> </span>        page_index_to: The page index of the upper limit of the range
<span class="w"> </span>        nums: Nums array to modify
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    start_index = nums.index(key) if key in nums else -2</span>
<span class="gi">+    end_index = start_index + 2</span>
<span class="gi">+</span>
<span class="gi">+    while end_index &lt; len(nums) and nums[end_index] &lt;= page_index_to:</span>
<span class="gi">+        end_index += 2</span>
<span class="gi">+</span>
<span class="gi">+    del nums[start_index + 2:end_index]</span>


<span class="w"> </span>def nums_next(key: NumberObject, nums: ArrayObject) -&gt;Tuple[Optional[
<span class="gu">@@ -118,4 +182,7 @@ def nums_next(key: NumberObject, nums: ArrayObject) -&gt;Tuple[Optional[</span>
<span class="w"> </span>        key: number key of the entry
<span class="w"> </span>        nums: Nums array
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for i in range(0, len(nums), 2):</span>
<span class="gi">+        if nums[i] &gt; key:</span>
<span class="gi">+            return nums[i], cast(DictionaryObject, nums[i + 1])</span>
<span class="gi">+    return None, None</span>
<span class="gh">diff --git a/pypdf/_protocols.py b/pypdf/_protocols.py</span>
<span class="gh">index 2ae0694..8ff0afc 100644</span>
<span class="gd">--- a/pypdf/_protocols.py</span>
<span class="gi">+++ b/pypdf/_protocols.py</span>
<span class="gu">@@ -12,19 +12,57 @@ from ._utils import StrByteType, StreamType</span>
<span class="w"> </span>class PdfObjectProtocol(Protocol):
<span class="w"> </span>    indirect_reference: Any

<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def get_object(self) -&gt; Any:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def write_to_stream(self, stream: StreamType) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>

<span class="w"> </span>class XmpInformationProtocol(PdfObjectProtocol):
<span class="gd">-    pass</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def get_element(self, name: str) -&gt; Optional[str]:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def get_dc_metadata(self) -&gt; Dict[str, Any]:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def get_pdf_metadata(self) -&gt; Dict[str, Any]:</span>
<span class="gi">+        pass</span>


<span class="w"> </span>class PdfCommonDocProtocol(Protocol):
<span class="gd">-    pass</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def get_page(self, page_number: int) -&gt; Any:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def pages(self) -&gt; Any:</span>
<span class="gi">+        pass</span>


<span class="w"> </span>class PdfReaderProtocol(PdfCommonDocProtocol, Protocol):
<span class="gd">-    pass</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def read(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def decrypt(self, password: Union[str, bytes]) -&gt; int:</span>
<span class="gi">+        pass</span>


<span class="w"> </span>class PdfWriterProtocol(PdfCommonDocProtocol, Protocol):
<span class="w"> </span>    _objects: List[Any]
<span class="w"> </span>    _id_translated: Dict[int, Dict[int, int]]
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def add_page(self, page: Any) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def write(self, stream: Union[Path, StrByteType]) -&gt; Tuple[bool, IO[Any]]:</span>
<span class="gi">+        pass</span>
<span class="gh">diff --git a/pypdf/_reader.py b/pypdf/_reader.py</span>
<span class="gh">index aa95113..514bb57 100644</span>
<span class="gd">--- a/pypdf/_reader.py</span>
<span class="gi">+++ b/pypdf/_reader.py</span>
<span class="gu">@@ -82,12 +82,15 @@ class PdfReader(PdfDocCommon):</span>

<span class="w"> </span>    def close(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Close the stream if opened in __init__ and clear memory.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._stream_opened:</span>
<span class="gi">+            self.stream.close()</span>
<span class="gi">+        self.resolved_objects.clear()</span>
<span class="gi">+        self.flattened_pages = None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def root_object(self) -&gt;DictionaryObject:
<span class="w"> </span>        &quot;&quot;&quot;Provide access to &quot;/Root&quot;. Standardized with PdfWriter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cast(DictionaryObject, self.trailer[TK.ROOT].get_object())</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def _info(self) -&gt;Optional[DictionaryObject]:
<span class="gu">@@ -97,7 +100,9 @@ class PdfReader(PdfDocCommon):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            /Info Dictionary; None if the entry does not exist
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if TK.INFO not in self.trailer:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return cast(DictionaryObject, self.trailer[TK.INFO].get_object())</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def _ID(self) -&gt;Optional[ArrayObject]:
<span class="gu">@@ -107,7 +112,9 @@ class PdfReader(PdfDocCommon):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            /ID array; None if the entry does not exist
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if TK.ID not in self.trailer:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return cast(ArrayObject, self.trailer[TK.ID].get_object())</span>

<span class="w"> </span>    def _repr_mimebundle_(self, include: Union[None, Iterable[str]]=None,
<span class="w"> </span>        exclude: Union[None, Iterable[str]]=None) -&gt;Dict[str, Any]:
<span class="gu">@@ -119,7 +126,21 @@ class PdfReader(PdfDocCommon):</span>

<span class="w"> </span>        See https://ipython.readthedocs.io/en/stable/config/integrating.html
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from PIL import Image</span>
<span class="gi">+        import io</span>
<span class="gi">+</span>
<span class="gi">+        if self.pages:</span>
<span class="gi">+            first_page = self.pages[0]</span>
<span class="gi">+            img = first_page.render()</span>
<span class="gi">+            img_byte_arr = io.BytesIO()</span>
<span class="gi">+            img.save(img_byte_arr, format=&#39;PNG&#39;)</span>
<span class="gi">+            img_byte_arr = img_byte_arr.getvalue()</span>
<span class="gi">+</span>
<span class="gi">+            return {</span>
<span class="gi">+                &#39;image/png&#39;: img_byte_arr,</span>
<span class="gi">+                &#39;text/plain&#39;: f&#39;PDF document with {len(self.pages)} page{&quot;s&quot; if len(self.pages) &gt; 1 else &quot;&quot;}&#39;</span>
<span class="gi">+            }</span>
<span class="gi">+        return {&#39;text/plain&#39;: &#39;Empty PDF document&#39;}</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def pdf_header(self) -&gt;str:
<span class="gu">@@ -129,12 +150,16 @@ class PdfReader(PdfDocCommon):</span>
<span class="w"> </span>        This is typically something like ``&#39;%PDF-1.6&#39;`` and can be used to
<span class="w"> </span>        detect if the file is actually a PDF file and which version it is.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.stream.seek(0)</span>
<span class="gi">+        return self.stream.read(8).decode(&#39;ascii&#39;)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def xmp_metadata(self) -&gt;Optional[XmpInformation]:
<span class="w"> </span>        &quot;&quot;&quot;XMP (Extensible Metadata Platform) data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return XmpInformation(self)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    def _get_page(self, page_number: int) -&gt;PageObject:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -147,7 +172,9 @@ class PdfReader(PdfDocCommon):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A :class:`PageObject&lt;pypdf._page.PageObject&gt;` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.flattened_pages is None:</span>
<span class="gi">+            self._flatten()</span>
<span class="gi">+        return self.flattened_pages[page_number]</span>

<span class="w"> </span>    def _get_page_number_by_indirect(self, indirect_reference: Union[None,
<span class="w"> </span>        int, NullObject, IndirectObject]) -&gt;Optional[int]:
<span class="gu">@@ -160,11 +187,22 @@ class PdfReader(PdfDocCommon):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The page number or None
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._page_id2num is None:</span>
<span class="gi">+            self._page_id2num = {}</span>
<span class="gi">+            for i, page in enumerate(self.pages):</span>
<span class="gi">+                if page.indirect_reference is not None:</span>
<span class="gi">+                    self._page_id2num[page.indirect_reference.idnum] = i</span>
<span class="gi">+        if indirect_reference is None or isinstance(indirect_reference, NullObject):</span>
<span class="gi">+            return None</span>
<span class="gi">+        if isinstance(indirect_reference, int):</span>
<span class="gi">+            return self._page_id2num.get(indirect_reference)</span>
<span class="gi">+        return self._page_id2num.get(indirect_reference.idnum)</span>

<span class="w"> </span>    def _basic_validation(self, stream: StreamType) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Ensure file is not empty. Read at most 5 bytes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        stream.seek(0)</span>
<span class="gi">+        if not stream.read(5):</span>
<span class="gi">+            raise EmptyFileError(&quot;Cannot read an empty file&quot;)</span>

<span class="w"> </span>    def _find_eof_marker(self, stream: StreamType) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -174,7 +212,12 @@ class PdfReader(PdfDocCommon):</span>
<span class="w"> </span>        the file. Hence for standard-compliant PDF documents this function will
<span class="w"> </span>        read only the last part (DEFAULT_BUFFER_SIZE).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        stream.seek(-1024, 2)</span>
<span class="gi">+        end = stream.read().lower()</span>
<span class="gi">+        idx = end.rfind(b&quot;%%eof&quot;)</span>
<span class="gi">+        if idx == -1:</span>
<span class="gi">+            raise PdfReadError(&quot;EOF marker not found&quot;)</span>
<span class="gi">+        stream.seek(stream.tell() - len(end) + idx)</span>

<span class="w"> </span>    def _find_startxref_pos(self, stream: StreamType) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -186,7 +229,11 @@ class PdfReader(PdfDocCommon):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The bytes offset
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        stream.seek(-1024, 2)</span>
<span class="gi">+        line = b&quot;&quot;</span>
<span class="gi">+        while b&quot;startxref&quot; not in line:</span>
<span class="gi">+            line = read_previous_line(stream)</span>
<span class="gi">+        return int(read_previous_line(stream))</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _get_xref_issues(stream: StreamType, startxref: int) -&gt;int:
<span class="gu">@@ -200,7 +247,15 @@ class PdfReader(PdfDocCommon):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            0 means no issue, other values represent specific issues.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        stream.seek(startxref)</span>
<span class="gi">+        if stream.read(5) != b&quot;xref &quot;:</span>
<span class="gi">+            return 1</span>
<span class="gi">+        stream.seek(startxref + 5)</span>
<span class="gi">+        try:</span>
<span class="gi">+            int(stream.read(10))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            return 2</span>
<span class="gi">+        return 0</span>

<span class="w"> </span>    def decrypt(self, password: Union[str, bytes]) -&gt;PasswordType:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gh">diff --git a/pypdf/_text_extraction/_layout_mode/_fixed_width_page.py b/pypdf/_text_extraction/_layout_mode/_fixed_width_page.py</span>
<span class="gh">index 4d943bc..54e0060 100644</span>
<span class="gd">--- a/pypdf/_text_extraction/_layout_mode/_fixed_width_page.py</span>
<span class="gi">+++ b/pypdf/_text_extraction/_layout_mode/_fixed_width_page.py</span>
<span class="gu">@@ -50,7 +50,15 @@ def bt_group(tj_op: TextStateParams, rendered_text: str, dispaced_tx: float</span>
<span class="w"> </span>        rendered_text (str): rendered text
<span class="w"> </span>        dispaced_tx (float): x coordinate of last character in BTGroup
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return BTGroup(</span>
<span class="gi">+        tx=tj_op.tx,</span>
<span class="gi">+        ty=tj_op.ty,</span>
<span class="gi">+        font_size=tj_op.font_size,</span>
<span class="gi">+        font_height=tj_op.font_height,</span>
<span class="gi">+        text=rendered_text,</span>
<span class="gi">+        displaced_tx=dispaced_tx,</span>
<span class="gi">+        flip_sort=1 if tj_op.ty &gt;= 0 else -1</span>
<span class="gi">+    )</span>


<span class="w"> </span>def recurs_to_target_op(ops: Iterator[Tuple[List[Any], bytes]],
<span class="gu">@@ -70,7 +78,33 @@ def recurs_to_target_op(ops: Iterator[Tuple[List[Any], bytes]],</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        tuple: list of BTGroup dicts + list of TextStateParams dataclass instances.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    bt_groups = []</span>
<span class="gi">+    text_state_params = []</span>
<span class="gi">+</span>
<span class="gi">+    for operands, operator in ops:</span>
<span class="gi">+        if operator == end_target:</span>
<span class="gi">+            return bt_groups, text_state_params</span>
<span class="gi">+</span>
<span class="gi">+        if operator == b&#39;BT&#39;:</span>
<span class="gi">+            sub_bt_groups, sub_text_state_params = recurs_to_target_op(ops, text_state_mgr, b&#39;ET&#39;, fonts, strip_rotated)</span>
<span class="gi">+            bt_groups.extend(sub_bt_groups)</span>
<span class="gi">+            text_state_params.extend(sub_text_state_params)</span>
<span class="gi">+        elif operator == b&#39;q&#39;:</span>
<span class="gi">+            text_state_mgr.push()</span>
<span class="gi">+            sub_bt_groups, sub_text_state_params = recurs_to_target_op(ops, text_state_mgr, b&#39;Q&#39;, fonts, strip_rotated)</span>
<span class="gi">+            bt_groups.extend(sub_bt_groups)</span>
<span class="gi">+            text_state_params.extend(sub_text_state_params)</span>
<span class="gi">+        elif operator in (b&#39;Tj&#39;, b&#39;TJ&#39;):</span>
<span class="gi">+            tj_op = text_state_mgr.tj_op()</span>
<span class="gi">+            if not strip_rotated or text_state_mgr.is_upright():</span>
<span class="gi">+                rendered_text = fonts[tj_op.font_name].decode(operands[0])</span>
<span class="gi">+                displaced_tx = text_state_mgr.displaced_tx(operands[0])</span>
<span class="gi">+                bt_groups.append(bt_group(tj_op, rendered_text, displaced_tx))</span>
<span class="gi">+                text_state_params.append(tj_op)</span>
<span class="gi">+        else:</span>
<span class="gi">+            text_state_mgr.apply(operands, operator)</span>
<span class="gi">+</span>
<span class="gi">+    return bt_groups, text_state_params</span>


<span class="w"> </span>def y_coordinate_groups(bt_groups: List[BTGroup], debug_path: Optional[Path
<span class="gu">@@ -86,7 +120,18 @@ def y_coordinate_groups(bt_groups: List[BTGroup], debug_path: Optional[Path</span>
<span class="w"> </span>        Dict[int, List[BTGroup]]: dict of lists of text rendered by each BT operator
<span class="w"> </span>            keyed by y coordinate
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sorted_groups = sorted(bt_groups, key=lambda x: (x[&#39;ty&#39;] * x[&#39;flip_sort&#39;], x[&#39;tx&#39;]))</span>
<span class="gi">+    grouped = {k: list(g) for k, g in groupby(sorted_groups, key=lambda x: ceil(x[&#39;ty&#39;]))}</span>
<span class="gi">+</span>
<span class="gi">+    if debug_path:</span>
<span class="gi">+        with open(debug_path / &#39;y_coordinate_groups.txt&#39;, &#39;w&#39;) as f:</span>
<span class="gi">+            for y, group in grouped.items():</span>
<span class="gi">+                f.write(f&quot;Y: {y}\n&quot;)</span>
<span class="gi">+                for item in group:</span>
<span class="gi">+                    f.write(f&quot;  {item[&#39;text&#39;]}\n&quot;)</span>
<span class="gi">+                f.write(&quot;\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return grouped</span>


<span class="w"> </span>def text_show_operations(ops: Iterator[Tuple[List[Any], bytes]], fonts:
<span class="gu">@@ -104,7 +149,26 @@ def text_show_operations(ops: Iterator[Tuple[List[Any], bytes]], fonts:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        List[BTGroup]: list of dicts of text rendered by each BT operator
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    text_state_mgr = TextStateManager()</span>
<span class="gi">+    bt_groups = []</span>
<span class="gi">+</span>
<span class="gi">+    for operands, operator in ops:</span>
<span class="gi">+        if operator == b&#39;BT&#39;:</span>
<span class="gi">+            sub_bt_groups, _ = recurs_to_target_op(ops, text_state_mgr, b&#39;ET&#39;, fonts, strip_rotated)</span>
<span class="gi">+            bt_groups.extend(sub_bt_groups)</span>
<span class="gi">+        elif operator == b&#39;q&#39;:</span>
<span class="gi">+            text_state_mgr.push()</span>
<span class="gi">+            sub_bt_groups, _ = recurs_to_target_op(ops, text_state_mgr, b&#39;Q&#39;, fonts, strip_rotated)</span>
<span class="gi">+            bt_groups.extend(sub_bt_groups)</span>
<span class="gi">+        else:</span>
<span class="gi">+            text_state_mgr.apply(operands, operator)</span>
<span class="gi">+</span>
<span class="gi">+    if debug_path:</span>
<span class="gi">+        with open(debug_path / &#39;text_show_operations.txt&#39;, &#39;w&#39;) as f:</span>
<span class="gi">+            for group in bt_groups:</span>
<span class="gi">+                f.write(f&quot;Text: {group[&#39;text&#39;]}, Position: ({group[&#39;tx&#39;]}, {group[&#39;ty&#39;]})\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return bt_groups</span>


<span class="w"> </span>def fixed_char_width(bt_groups: List[BTGroup], scale_weight: float=1.25
<span class="gu">@@ -120,7 +184,19 @@ def fixed_char_width(bt_groups: List[BTGroup], scale_weight: float=1.25</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        float: fixed character width
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    total_width = 0</span>
<span class="gi">+    total_chars = 0</span>
<span class="gi">+    for group in bt_groups:</span>
<span class="gi">+        text_length = len(group[&#39;text&#39;])</span>
<span class="gi">+        if text_length &gt; 0:</span>
<span class="gi">+            width = (group[&#39;displaced_tx&#39;] - group[&#39;tx&#39;]) / text_length</span>
<span class="gi">+            total_width += width * text_length * scale_weight</span>
<span class="gi">+            total_chars += text_length</span>
<span class="gi">+</span>
<span class="gi">+    if total_chars == 0:</span>
<span class="gi">+        return 1.0  # Default to 1.0 if no characters found</span>
<span class="gi">+</span>
<span class="gi">+    return total_width / total_chars</span>


<span class="w"> </span>def fixed_width_page(ty_groups: Dict[int, List[BTGroup]], char_width: float,
<span class="gu">@@ -137,4 +213,23 @@ def fixed_width_page(ty_groups: Dict[int, List[BTGroup]], char_width: float,</span>
<span class="w"> </span>        str: page text in a fixed width format that closely adheres to the rendered
<span class="w"> </span>            layout in the source pdf.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sorted_y = sorted(ty_groups.keys(), reverse=True)</span>
<span class="gi">+    result = []</span>
<span class="gi">+    prev_y = None</span>
<span class="gi">+</span>
<span class="gi">+    for y in sorted_y:</span>
<span class="gi">+        if space_vertically and prev_y is not None:</span>
<span class="gi">+            line_gap = int((prev_y - y) / char_width) - 1</span>
<span class="gi">+            result.extend([&#39;&#39;] * max(0, line_gap))</span>
<span class="gi">+</span>
<span class="gi">+        line = &#39;&#39;</span>
<span class="gi">+        for group in sorted(ty_groups[y], key=lambda x: x[&#39;tx&#39;]):</span>
<span class="gi">+            x_pos = int(group[&#39;tx&#39;] / char_width)</span>
<span class="gi">+            while len(line) &lt; x_pos:</span>
<span class="gi">+                line += &#39; &#39;</span>
<span class="gi">+            line += group[&#39;text&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        result.append(line.rstrip())</span>
<span class="gi">+        prev_y = y</span>
<span class="gi">+</span>
<span class="gi">+    return &#39;\n&#39;.join(result)</span>
<span class="gh">diff --git a/pypdf/_text_extraction/_layout_mode/_font.py b/pypdf/_text_extraction/_layout_mode/_font.py</span>
<span class="gh">index f63da23..0b70bc1 100644</span>
<span class="gd">--- a/pypdf/_text_extraction/_layout_mode/_font.py</span>
<span class="gi">+++ b/pypdf/_text_extraction/_layout_mode/_font.py</span>
<span class="gu">@@ -70,9 +70,16 @@ class Font:</span>

<span class="w"> </span>    def word_width(self, word: str) -&gt;float:
<span class="w"> </span>        &quot;&quot;&quot;Sum of character widths specified in PDF font for the supplied word&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sum(self.width_map.get(char, self.space_width) for char in word)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def to_dict(font_instance: &#39;Font&#39;) -&gt;Dict[str, Any]:
<span class="w"> </span>        &quot;&quot;&quot;Dataclass to dict for json.dumps serialization.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;subtype&#39;: font_instance.subtype,</span>
<span class="gi">+            &#39;space_width&#39;: font_instance.space_width,</span>
<span class="gi">+            &#39;encoding&#39;: font_instance.encoding,</span>
<span class="gi">+            &#39;char_map&#39;: font_instance.char_map,</span>
<span class="gi">+            &#39;font_dictionary&#39;: font_instance.font_dictionary,</span>
<span class="gi">+            &#39;width_map&#39;: font_instance.width_map</span>
<span class="gi">+        }</span>
<span class="gh">diff --git a/pypdf/_text_extraction/_layout_mode/_text_state_manager.py b/pypdf/_text_extraction/_layout_mode/_text_state_manager.py</span>
<span class="gh">index 3dc8948..92576f6 100644</span>
<span class="gd">--- a/pypdf/_text_extraction/_layout_mode/_text_state_manager.py</span>
<span class="gi">+++ b/pypdf/_text_extraction/_layout_mode/_text_state_manager.py</span>
<span class="gu">@@ -53,7 +53,17 @@ class TextStateManager:</span>
<span class="w"> </span>            value (float | List[Any]): new parameter value. If a list,
<span class="w"> </span>                value[0] is used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        param_value = value[0] if isinstance(value, list) else value</span>
<span class="gi">+        if op == b&#39;Tc&#39;:</span>
<span class="gi">+            self.Tc = float(param_value)</span>
<span class="gi">+        elif op == b&#39;Tz&#39;:</span>
<span class="gi">+            self.Tz = float(param_value)</span>
<span class="gi">+        elif op == b&#39;Tw&#39;:</span>
<span class="gi">+            self.Tw = float(param_value)</span>
<span class="gi">+        elif op == b&#39;TL&#39;:</span>
<span class="gi">+            self.TL = float(param_value)</span>
<span class="gi">+        elif op == b&#39;Ts&#39;:</span>
<span class="gi">+            self.Ts = float(param_value)</span>

<span class="w"> </span>    def set_font(self, font: Font, size: float) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -63,7 +73,8 @@ class TextStateManager:</span>
<span class="w"> </span>            font (Font): a layout mode Font
<span class="w"> </span>            size (float): font size
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.font = font</span>
<span class="gi">+        self.font_size = size</span>

<span class="w"> </span>    def text_state_params(self, value: Union[bytes, str]=&#39;&#39;) -&gt;TextStateParams:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -79,54 +90,90 @@ class TextStateManager:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            TextStateParams: current text state parameters
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.font is None:</span>
<span class="gi">+            raise PdfReadError(&quot;Font not set (no Tf operator in incoming pdf content stream)&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        if isinstance(value, bytes):</span>
<span class="gi">+            value = value.decode(&#39;utf-8&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        return TextStateParams(</span>
<span class="gi">+            font=self.font,</span>
<span class="gi">+            font_size=self.font_size,</span>
<span class="gi">+            Tc=self.Tc,</span>
<span class="gi">+            Tw=self.Tw,</span>
<span class="gi">+            Tz=self.Tz,</span>
<span class="gi">+            TL=self.TL,</span>
<span class="gi">+            Ts=self.Ts,</span>
<span class="gi">+            transform=self.effective_transform,</span>
<span class="gi">+            value=value</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def raw_transform(_a: float=1.0, _b: float=0.0, _c: float=0.0, _d:
<span class="w"> </span>        float=1.0, _e: float=0.0, _f: float=0.0) -&gt;Dict[int, float]:
<span class="w"> </span>        &quot;&quot;&quot;Only a/b/c/d/e/f matrix params&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {0: _a, 1: _b, 2: _c, 3: _d, 4: _e, 5: _f}</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def new_transform(_a: float=1.0, _b: float=0.0, _c: float=0.0, _d:
<span class="w"> </span>        float=1.0, _e: float=0.0, _f: float=0.0, is_text: bool=False,
<span class="w"> </span>        is_render: bool=False) -&gt;TextStateManagerDictType:
<span class="w"> </span>        &quot;&quot;&quot;Standard a/b/c/d/e/f matrix params + &#39;is_text&#39; and &#39;is_render&#39; keys&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        transform = TextStateManager.raw_transform(_a, _b, _c, _d, _e, _f)</span>
<span class="gi">+        transform[&#39;is_text&#39;] = is_text</span>
<span class="gi">+        transform[&#39;is_render&#39;] = is_render</span>
<span class="gi">+        return transform</span>

<span class="w"> </span>    def reset_tm(self) -&gt;TextStateManagerChainMapType:
<span class="w"> </span>        &quot;&quot;&quot;Clear all transforms from chainmap having is_text==True or is_render==True&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.transform_stack = ChainMap({k: v for k, v in self.transform_stack.maps[0].items() if not (v.get(&#39;is_text&#39;, False) or v.get(&#39;is_render&#39;, False))})</span>
<span class="gi">+        return self.transform_stack</span>

<span class="w"> </span>    def reset_trm(self) -&gt;TextStateManagerChainMapType:
<span class="w"> </span>        &quot;&quot;&quot;Clear all transforms from chainmap having is_render==True&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.transform_stack = ChainMap({k: v for k, v in self.transform_stack.maps[0].items() if not v.get(&#39;is_render&#39;, False)})</span>
<span class="gi">+        return self.transform_stack</span>

<span class="w"> </span>    def remove_q(self) -&gt;TextStateManagerChainMapType:
<span class="w"> </span>        &quot;&quot;&quot;Rewind to stack prior state after closing a &#39;q&#39; with internal &#39;cm&#39; ops&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.q_depth[-1] &gt; 0:</span>
<span class="gi">+            self.q_depth[-1] -= 1</span>
<span class="gi">+            self.transform_stack = self.transform_stack.parents</span>
<span class="gi">+        return self.transform_stack</span>

<span class="w"> </span>    def add_q(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add another level to q_queue&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.q_depth[-1] += 1</span>
<span class="gi">+        self.transform_stack = self.transform_stack.new_child()</span>

<span class="w"> </span>    def add_cm(self, *args: Any) -&gt;TextStateManagerChainMapType:
<span class="w"> </span>        &quot;&quot;&quot;Concatenate an additional transform matrix&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new_transform = self.new_transform(*args)</span>
<span class="gi">+        self.transform_stack = self.transform_stack.new_child(new_transform)</span>
<span class="gi">+        return self.transform_stack</span>

<span class="w"> </span>    def _complete_matrix(self, operands: List[float]) -&gt;List[float]:
<span class="w"> </span>        &quot;&quot;&quot;Adds a, b, c, and d to an &quot;e/f only&quot; operand set (e.g Td)&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [1, 0, 0, 1] + operands if len(operands) == 2 else operands</span>

<span class="w"> </span>    def add_tm(self, operands: List[float]) -&gt;TextStateManagerChainMapType:
<span class="w"> </span>        &quot;&quot;&quot;Append a text transform matrix&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        complete_operands = self._complete_matrix(operands)</span>
<span class="gi">+        new_transform = self.new_transform(*complete_operands, is_text=True)</span>
<span class="gi">+        self.transform_stack = self.transform_stack.new_child(new_transform)</span>
<span class="gi">+        return self.transform_stack</span>

<span class="w"> </span>    def add_trm(self, operands: List[float]) -&gt;TextStateManagerChainMapType:
<span class="w"> </span>        &quot;&quot;&quot;Append a text rendering transform matrix&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        complete_operands = self._complete_matrix(operands)</span>
<span class="gi">+        new_transform = self.new_transform(*complete_operands, is_render=True)</span>
<span class="gi">+        self.transform_stack = self.transform_stack.new_child(new_transform)</span>
<span class="gi">+        return self.transform_stack</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def effective_transform(self) -&gt;List[float]:
<span class="w"> </span>        &quot;&quot;&quot;Current effective transform accounting for cm, tm, and trm transforms&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = [1, 0, 0, 1, 0, 0]</span>
<span class="gi">+        for transform in reversed(self.transform_stack.maps):</span>
<span class="gi">+            result = mult(result, [transform.get(i, 0) for i in range(6)])</span>
<span class="gi">+        return result</span>
<span class="gh">diff --git a/pypdf/_text_extraction/_layout_mode/_text_state_params.py b/pypdf/_text_extraction/_layout_mode/_text_state_params.py</span>
<span class="gh">index 341ce6c..3afa9df 100644</span>
<span class="gd">--- a/pypdf/_text_extraction/_layout_mode/_text_state_params.py</span>
<span class="gi">+++ b/pypdf/_text_extraction/_layout_mode/_text_state_params.py</span>
<span class="gu">@@ -70,15 +70,18 @@ class TextStateParams:</span>

<span class="w"> </span>    def font_size_matrix(self) -&gt;List[float]:
<span class="w"> </span>        &quot;&quot;&quot;Font size matrix&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [self.font_size * self.Tz / 100, 0, 0, self.font_size, 0, 0]</span>

<span class="w"> </span>    def displaced_transform(self) -&gt;List[float]:
<span class="w"> </span>        &quot;&quot;&quot;Effective transform matrix after text has been rendered.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        displacement = self.displacement_matrix()</span>
<span class="gi">+        return mult(displacement, self.transform)</span>

<span class="w"> </span>    def render_transform(self) -&gt;List[float]:
<span class="w"> </span>        &quot;&quot;&quot;Effective transform matrix accounting for font size, Tz, and Ts.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        font_size_matrix = self.font_size_matrix()</span>
<span class="gi">+        text_rise = [1, 0, 0, 1, 0, self.Ts]</span>
<span class="gi">+        return mult(mult(text_rise, font_size_matrix), self.transform)</span>

<span class="w"> </span>    def displacement_matrix(self, word: Union[str, None]=None, TD_offset:
<span class="w"> </span>        float=0.0) -&gt;List[float]:
<span class="gu">@@ -90,13 +93,34 @@ class TextStateParams:</span>
<span class="w"> </span>                returned.
<span class="w"> </span>            TD_offset (float, optional): translation applied by TD operator. Defaults to 0.0.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        text = word if word is not None else self.txt</span>
<span class="gi">+        tx = self.word_tx(text, TD_offset)</span>
<span class="gi">+        return [1, 0, 0, 1, tx, 0]</span>

<span class="w"> </span>    def word_tx(self, word: str, TD_offset: float=0.0) -&gt;float:
<span class="w"> </span>        &quot;&quot;&quot;Horizontal text displacement for any word according this text state&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        width = self.font.get_width(word) * self.font_size / 1000</span>
<span class="gi">+        spaces = word.count(&#39; &#39;)</span>
<span class="gi">+        return (width + self.Tc * len(word) + self.Tw * spaces) * self.Tz / 100 + TD_offset</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def to_dict(inst: &#39;TextStateParams&#39;) -&gt;Dict[str, Any]:
<span class="w"> </span>        &quot;&quot;&quot;Dataclass to dict for json.dumps serialization&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;txt&#39;: inst.txt,</span>
<span class="gi">+            &#39;font&#39;: inst.font.to_dict(),</span>
<span class="gi">+            &#39;font_size&#39;: inst.font_size,</span>
<span class="gi">+            &#39;Tc&#39;: inst.Tc,</span>
<span class="gi">+            &#39;Tw&#39;: inst.Tw,</span>
<span class="gi">+            &#39;Tz&#39;: inst.Tz,</span>
<span class="gi">+            &#39;TL&#39;: inst.TL,</span>
<span class="gi">+            &#39;Ts&#39;: inst.Ts,</span>
<span class="gi">+            &#39;transform&#39;: inst.transform,</span>
<span class="gi">+            &#39;tx&#39;: inst.tx,</span>
<span class="gi">+            &#39;ty&#39;: inst.ty,</span>
<span class="gi">+            &#39;displaced_tx&#39;: inst.displaced_tx,</span>
<span class="gi">+            &#39;space_tx&#39;: inst.space_tx,</span>
<span class="gi">+            &#39;font_height&#39;: inst.font_height,</span>
<span class="gi">+            &#39;flip_vertical&#39;: inst.flip_vertical,</span>
<span class="gi">+            &#39;rotated&#39;: inst.rotated</span>
<span class="gi">+        }</span>
<span class="gh">diff --git a/pypdf/_utils.py b/pypdf/_utils.py</span>
<span class="gh">index d2f9468..0d22654 100644</span>
<span class="gd">--- a/pypdf/_utils.py</span>
<span class="gi">+++ b/pypdf/_utils.py</span>
<span class="gu">@@ -38,7 +38,15 @@ def read_until_whitespace(stream: StreamType, maxchars: Optional[int]=None</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The data which was read.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    txt = b&quot;&quot;</span>
<span class="gi">+    while True:</span>
<span class="gi">+        if maxchars is not None and len(txt) &gt;= maxchars:</span>
<span class="gi">+            break</span>
<span class="gi">+        tok = stream.read(1)</span>
<span class="gi">+        if tok.isspace() or not tok:</span>
<span class="gi">+            break</span>
<span class="gi">+        txt += tok</span>
<span class="gi">+    return txt</span>


<span class="w"> </span>def read_non_whitespace(stream: StreamType) -&gt;bytes:
<span class="gu">@@ -51,7 +59,12 @@ def read_non_whitespace(stream: StreamType) -&gt;bytes:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The data which was read.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while True:</span>
<span class="gi">+        tok = stream.read(1)</span>
<span class="gi">+        if not tok:</span>
<span class="gi">+            return b&quot;&quot;</span>
<span class="gi">+        if not tok.isspace():</span>
<span class="gi">+            return tok</span>


<span class="w"> </span>def skip_over_whitespace(stream: StreamType) -&gt;bool:
<span class="gu">@@ -65,7 +78,15 @@ def skip_over_whitespace(stream: StreamType) -&gt;bool:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        True if more than one whitespace was skipped, otherwise return False.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    num_whitespace = 0</span>
<span class="gi">+    while True:</span>
<span class="gi">+        tok = stream.read(1)</span>
<span class="gi">+        if not tok:</span>
<span class="gi">+            return num_whitespace &gt; 1</span>
<span class="gi">+        if not tok.isspace():</span>
<span class="gi">+            stream.seek(-1, SEEK_CUR)</span>
<span class="gi">+            return num_whitespace &gt; 1</span>
<span class="gi">+        num_whitespace += 1</span>


<span class="w"> </span>def check_if_whitespace_only(value: bytes) -&gt;bool:
<span class="gu">@@ -78,7 +99,7 @@ def check_if_whitespace_only(value: bytes) -&gt;bool:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        True if the value only has whitespace characters, otherwise return False.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return all(byte.isspace() for byte in value)</span>


<span class="w"> </span>def read_until_regex(stream: StreamType, regex: Pattern[bytes]) -&gt;bytes:
<span class="gu">@@ -92,7 +113,14 @@ def read_until_regex(stream: StreamType, regex: Pattern[bytes]) -&gt;bytes:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The read bytes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buf = b&quot;&quot;</span>
<span class="gi">+    while True:</span>
<span class="gi">+        tok = stream.read(1)</span>
<span class="gi">+        if not tok:</span>
<span class="gi">+            return buf</span>
<span class="gi">+        buf += tok</span>
<span class="gi">+        if regex.search(buf):</span>
<span class="gi">+            return buf[:-1]</span>


<span class="w"> </span>def read_block_backwards(stream: StreamType, to_read: int) -&gt;bytes:
<span class="gu">@@ -109,7 +137,12 @@ def read_block_backwards(stream: StreamType, to_read: int) -&gt;bytes:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The data which was read.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    current_pos = stream.tell()</span>
<span class="gi">+    start_pos = max(0, current_pos - to_read)</span>
<span class="gi">+    stream.seek(start_pos)</span>
<span class="gi">+    data = stream.read(current_pos - start_pos)</span>
<span class="gi">+    stream.seek(start_pos)</span>
<span class="gi">+    return data</span>


<span class="w"> </span>def read_previous_line(stream: StreamType) -&gt;bytes:
<span class="gu">@@ -128,12 +161,36 @@ def read_previous_line(stream: StreamType) -&gt;bytes:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The data which was read.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    current_pos = stream.tell()</span>
<span class="gi">+    stream.seek(0, SEEK_CUR)</span>
<span class="gi">+    line = b&quot;&quot;</span>
<span class="gi">+    while True:</span>
<span class="gi">+        if stream.tell() == 0:</span>
<span class="gi">+            break</span>
<span class="gi">+        stream.seek(-2, SEEK_CUR)</span>
<span class="gi">+        char = stream.read(1)</span>
<span class="gi">+        if char in (b&#39;\n&#39;, b&#39;\r&#39;):</span>
<span class="gi">+            stream.seek(1, SEEK_CUR)</span>
<span class="gi">+            break</span>
<span class="gi">+        line = char + line</span>
<span class="gi">+    result = stream.read(current_pos - stream.tell())</span>
<span class="gi">+    while stream.tell() &lt; current_pos:</span>
<span class="gi">+        char = stream.read(1)</span>
<span class="gi">+        if char not in (b&#39;\n&#39;, b&#39;\r&#39;):</span>
<span class="gi">+            stream.seek(-1, SEEK_CUR)</span>
<span class="gi">+            break</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def mark_location(stream: StreamType) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Create text file showing current location in context.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pos = stream.tell()</span>
<span class="gi">+    stream.seek(max(0, pos - 32))</span>
<span class="gi">+    before = stream.read(min(32, pos))</span>
<span class="gi">+    after = stream.read(32)</span>
<span class="gi">+    stream.seek(pos)</span>
<span class="gi">+    with open(&quot;pypdf_debug_location.txt&quot;, &quot;wb&quot;) as fp:</span>
<span class="gi">+        fp.write(before + b&quot;&lt;*&gt;&quot; + after)</span>


<span class="w"> </span>B_CACHE: Dict[Union[str, bytes], bytes] = {}
<span class="gu">@@ -145,23 +202,36 @@ WHITESPACES_AS_REGEXP = b&#39;[&#39; + WHITESPACES_AS_BYTES + b&#39;]&#39;</span>
<span class="w"> </span>def deprecate_with_replacement(old_name: str, new_name: str, removed_in: str
<span class="w"> </span>    ) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Raise an exception that a feature will be removed, but has a replacement.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        f&quot;{old_name} is deprecated and will be removed in {removed_in}. &quot;</span>
<span class="gi">+        f&quot;Use {new_name} instead.&quot;,</span>
<span class="gi">+        DeprecationWarning,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>


<span class="w"> </span>def deprecation_with_replacement(old_name: str, new_name: str, removed_in: str
<span class="w"> </span>    ) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Raise an exception that a feature was already removed, but has a replacement.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    raise DeprecationError(</span>
<span class="gi">+        f&quot;{old_name} was removed in {removed_in}. Use {new_name} instead.&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>def deprecate_no_replacement(name: str, removed_in: str) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Raise an exception that a feature will be removed without replacement.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        f&quot;{name} is deprecated and will be removed in {removed_in}.&quot;,</span>
<span class="gi">+        DeprecationWarning,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>


<span class="w"> </span>def deprecation_no_replacement(name: str, removed_in: str) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Raise an exception that a feature was already removed without replacement.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    raise DeprecationError(</span>
<span class="gi">+        f&quot;{name} was removed in {removed_in}.&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>def logger_error(msg: str, src: str) -&gt;None:
<span class="gu">@@ -173,7 +243,7 @@ def logger_error(msg: str, src: str) -&gt;None:</span>
<span class="w"> </span>    See the docs on when to use which:
<span class="w"> </span>    https://pypdf.readthedocs.io/en/latest/user/suppress-warnings.html
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logging.getLogger(src).error(msg)</span>


<span class="w"> </span>def logger_warning(msg: str, src: str) -&gt;None:
<span class="gu">@@ -192,7 +262,7 @@ def logger_warning(msg: str, src: str) -&gt;None:</span>
<span class="w"> </span>      pypdf could apply a robustness fix to still read it. This applies mainly
<span class="w"> </span>      to strict=False mode.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logging.getLogger(src).warning(msg)</span>


<span class="w"> </span>def rename_kwargs(func_name: str, kwargs: Dict[str, Any], aliases: Dict[str,
<span class="gu">@@ -206,7 +276,18 @@ def rename_kwargs(func_name: str, kwargs: Dict[str, Any], aliases: Dict[str,</span>
<span class="w"> </span>        aliases:
<span class="w"> </span>        fail:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for old_arg, new_arg in aliases.items():</span>
<span class="gi">+        if old_arg in kwargs:</span>
<span class="gi">+            if new_arg in kwargs:</span>
<span class="gi">+                raise TypeError(f&quot;{func_name}() received both {old_arg} and {new_arg}&quot;)</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                f&quot;{old_arg} is deprecated. Use {new_arg} instead.&quot;,</span>
<span class="gi">+                DeprecationWarning,</span>
<span class="gi">+                stacklevel=3,</span>
<span class="gi">+            )</span>
<span class="gi">+            kwargs[new_arg] = kwargs.pop(old_arg)</span>
<span class="gi">+        elif fail and new_arg not in kwargs:</span>
<span class="gi">+            raise TypeError(f&quot;{func_name}() missing required argument: &#39;{new_arg}&#39;&quot;)</span>


<span class="w"> </span>class classproperty:
<span class="gh">diff --git a/pypdf/_writer.py b/pypdf/_writer.py</span>
<span class="gh">index 9c09266..5516a8d 100644</span>
<span class="gd">--- a/pypdf/_writer.py</span>
<span class="gi">+++ b/pypdf/_writer.py</span>
<span class="gu">@@ -114,7 +114,7 @@ class PdfWriter(PdfDocCommon):</span>
<span class="w"> </span>        Note that this property, if true, will remain true even after the
<span class="w"> </span>        :meth:`decrypt()&lt;pypdf.PdfReader.decrypt&gt;` method is called.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._encryption is not None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def root_object(self) -&gt;DictionaryObject:
<span class="gu">@@ -124,7 +124,7 @@ class PdfWriter(PdfDocCommon):</span>
<span class="w"> </span>        Note:
<span class="w"> </span>            Recommended only for read access.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._root_object</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def _info(self) -&gt;Optional[DictionaryObject]:
<span class="gu">@@ -134,17 +134,26 @@ class PdfWriter(PdfDocCommon):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            /Info Dictionary; None if the entry does not exist
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._info_obj if isinstance(self._info_obj, DictionaryObject) else None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def xmp_metadata(self) -&gt;Optional[XmpInformation]:
<span class="w"> </span>        &quot;&quot;&quot;XMP (Extensible Metadata Platform) data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if CA.METADATA not in self._root_object:</span>
<span class="gi">+            return None</span>
<span class="gi">+        metadata = self._root_object[CA.METADATA]</span>
<span class="gi">+        if not isinstance(metadata, XmpInformation):</span>
<span class="gi">+            metadata = XmpInformation(metadata)</span>
<span class="gi">+            self._root_object[CA.METADATA] = metadata</span>
<span class="gi">+        return metadata</span>

<span class="w"> </span>    @xmp_metadata.setter
<span class="w"> </span>    def xmp_metadata(self, value: Optional[XmpInformation]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;XMP (Extensible Metadata Platform) data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            del self._root_object[CA.METADATA]</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._root_object[CA.METADATA] = value</span>

<span class="w"> </span>    def __enter__(self) -&gt;&#39;PdfWriter&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Store that writer is initialized by &#39;with&#39;.&quot;&quot;&quot;
<span class="gu">@@ -170,7 +179,16 @@ class PdfWriter(PdfDocCommon):</span>

<span class="w"> </span>        See https://ipython.readthedocs.io/en/stable/config/integrating.html
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from io import BytesIO</span>
<span class="gi">+        </span>
<span class="gi">+        data = BytesIO()</span>
<span class="gi">+        self.write(data)</span>
<span class="gi">+        data.seek(0)</span>
<span class="gi">+        </span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;application/pdf&#39;: data.getvalue(),</span>
<span class="gi">+            &#39;text/plain&#39;: f&#39;PDF document with {len(self.pages)} page{&quot;s&quot; if len(self.pages) != 1 else &quot;&quot;}&#39;</span>
<span class="gi">+        }</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def pdf_header(self) -&gt;str:
<span class="gu">@@ -183,7 +201,13 @@ class PdfWriter(PdfDocCommon):</span>

<span class="w"> </span>        Note: `pdf_header` returns a string but accepts bytes or str for writing
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._header.decode(&#39;ascii&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @pdf_header.setter</span>
<span class="gi">+    def pdf_header(self, value: Union[str, bytes]) -&gt;None:</span>
<span class="gi">+        if isinstance(value, str):</span>
<span class="gi">+            value = value.encode(&#39;ascii&#39;)</span>
<span class="gi">+        self._header = value</span>

<span class="w"> </span>    def set_need_appearances_writer(self, state: bool=True) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gh">diff --git a/pypdf/_xobj_image_helpers.py b/pypdf/_xobj_image_helpers.py</span>
<span class="gh">index 658d357..96b15b0 100644</span>
<span class="gd">--- a/pypdf/_xobj_image_helpers.py</span>
<span class="gi">+++ b/pypdf/_xobj_image_helpers.py</span>
<span class="gu">@@ -33,7 +33,38 @@ def _get_imagemode(color_space: Union[str, List[Any], Any],</span>
<span class="w"> </span>        Image mode not taking into account mask(transparency)
<span class="w"> </span>        ColorInversion is required (like for some DeviceCMYK)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if depth &gt; MAX_IMAGE_MODE_NESTING_DEPTH:</span>
<span class="gi">+        return &#39;&#39;, False</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(color_space, str):</span>
<span class="gi">+        if color_space == ColorSpaces.DEVICE_RGB:</span>
<span class="gi">+            return &#39;RGB&#39;, False</span>
<span class="gi">+        elif color_space == ColorSpaces.DEVICE_CMYK:</span>
<span class="gi">+            return &#39;CMYK&#39;, True</span>
<span class="gi">+        elif color_space == ColorSpaces.DEVICE_GRAY:</span>
<span class="gi">+            return &#39;L&#39;, False</span>
<span class="gi">+        elif color_space == ColorSpaces.INDEXED:</span>
<span class="gi">+            return &#39;P&#39;, False</span>
<span class="gi">+    elif isinstance(color_space, list) and len(color_space) &gt; 0:</span>
<span class="gi">+        if color_space[0] == ColorSpaces.INDEXED:</span>
<span class="gi">+            return &#39;P&#39;, False</span>
<span class="gi">+        elif color_space[0] == ColorSpaces.SEPARATION:</span>
<span class="gi">+            return _get_imagemode(color_space[-1], color_components, prev_mode, depth + 1)</span>
<span class="gi">+        elif color_space[0] == ColorSpaces.CAL_RGB:</span>
<span class="gi">+            return &#39;RGB&#39;, False</span>
<span class="gi">+        elif color_space[0] == ColorSpaces.CAL_GRAY:</span>
<span class="gi">+            return &#39;L&#39;, False</span>
<span class="gi">+        elif color_space[0] == ColorSpaces.LAB:</span>
<span class="gi">+            return &#39;LAB&#39;, False</span>
<span class="gi">+</span>
<span class="gi">+    if color_components == 1:</span>
<span class="gi">+        return &#39;L&#39;, False</span>
<span class="gi">+    elif color_components == 3:</span>
<span class="gi">+        return &#39;RGB&#39;, False</span>
<span class="gi">+    elif color_components == 4:</span>
<span class="gi">+        return &#39;CMYK&#39;, True</span>
<span class="gi">+</span>
<span class="gi">+    return prev_mode, False</span>


<span class="w"> </span>def _handle_flate(size: Tuple[int, int], data: bytes, mode: mode_str_type,
<span class="gu">@@ -43,13 +74,43 @@ def _handle_flate(size: Tuple[int, int], data: bytes, mode: mode_str_type,</span>
<span class="w"> </span>    Process image encoded in flateEncode
<span class="w"> </span>    Returns img, image_format, extension, color inversion
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    img = Image.frombytes(mode, size, data)</span>
<span class="gi">+    </span>
<span class="gi">+    if mode == &#39;P&#39;:</span>
<span class="gi">+        # For indexed color images, we need to create a palette</span>
<span class="gi">+        palette = []</span>
<span class="gi">+        for i in range(256):</span>
<span class="gi">+            if i * 3 + 2 &lt; len(data):</span>
<span class="gi">+                palette.extend(data[i * 3 : i * 3 + 3])</span>
<span class="gi">+            else:</span>
<span class="gi">+                palette.extend([0, 0, 0])</span>
<span class="gi">+        img.putpalette(palette)</span>
<span class="gi">+</span>
<span class="gi">+    if mode == &#39;CMYK&#39;:</span>
<span class="gi">+        # CMYK images need to be inverted</span>
<span class="gi">+        img = Image.merge(&#39;CMYK&#39;, [channel.point(lambda x: 255 - x) for channel in img.split()])</span>
<span class="gi">+</span>
<span class="gi">+    image_format = &#39;PNG&#39;</span>
<span class="gi">+    extension = &#39;.png&#39;</span>
<span class="gi">+    color_inversion = mode == &#39;CMYK&#39;</span>
<span class="gi">+</span>
<span class="gi">+    return img, image_format, extension, color_inversion</span>


<span class="w"> </span>def _handle_jpx(size: Tuple[int, int], data: bytes, mode: mode_str_type,
<span class="w"> </span>    color_space: str, colors: int) -&gt;Tuple[Image.Image, str, str, bool]:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    Process image encoded in flateEncode</span>
<span class="gi">+    Process image encoded in JPEG2000</span>
<span class="w"> </span>    Returns img, image_format, extension, inversion
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        img = Image.open(BytesIO(data))</span>
<span class="gi">+    except UnidentifiedImageError:</span>
<span class="gi">+        raise PdfReadError(&quot;Unable to process JPEG2000 image&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # JPEG2000 images are already in the correct color mode</span>
<span class="gi">+    image_format = &#39;JPEG2000&#39;</span>
<span class="gi">+    extension = &#39;.jp2&#39;</span>
<span class="gi">+    inversion = False</span>
<span class="gi">+</span>
<span class="gi">+    return img, image_format, extension, inversion</span>
<span class="gh">diff --git a/pypdf/constants.py b/pypdf/constants.py</span>
<span class="gh">index 5c0b0cf..348df72 100644</span>
<span class="gd">--- a/pypdf/constants.py</span>
<span class="gi">+++ b/pypdf/constants.py</span>
<span class="gu">@@ -92,21 +92,21 @@ class UserAccessPermissions(IntFlag):</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def _is_reserved(cls, name: str) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Check if the given name corresponds to a reserved flag entry.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return name.startswith(&#39;R&#39;)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def _is_active(cls, name: str) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Check if the given reserved name defaults to 1 = active.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return name in {&#39;R1&#39;, &#39;R2&#39;}</span>

<span class="w"> </span>    def to_dict(self) -&gt;Dict[str, bool]:
<span class="w"> </span>        &quot;&quot;&quot;Convert the given flag value to a corresponding verbose name mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {name: bool(self &amp; value) for name, value in self.__class__.__members__.items()}</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_dict(cls, value: Dict[str, bool]) -&gt;&#39;UserAccessPermissions&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Convert the verbose name mapping to the corresponding flag value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(sum(cls.__members__[name] for name, is_set in value.items() if is_set))</span>


<span class="w"> </span>class Resources:
<span class="gu">@@ -415,7 +415,7 @@ class FieldDictionaryAttributes:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A tuple containing all the attribute constants.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return tuple(attr for attr in vars(cls).values() if isinstance(attr, str) and attr.startswith(&#39;/&#39;))</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def attributes_dict(cls) -&gt;Dict[str, str]:
<span class="gu">@@ -431,7 +431,7 @@ class FieldDictionaryAttributes:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A dictionary containing attribute keys and their names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {attr: attr[1:] for attr in cls.attributes()}</span>


<span class="w"> </span>class CheckboxRadioButtonAttributes:
<span class="gu">@@ -451,7 +451,7 @@ class CheckboxRadioButtonAttributes:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A tuple containing all the attribute constants.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return tuple(attr for attr in vars(cls).values() if isinstance(attr, str) and attr.startswith(&#39;/&#39;))</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def attributes_dict(cls) -&gt;Dict[str, str]:
<span class="gu">@@ -467,7 +467,7 @@ class CheckboxRadioButtonAttributes:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A dictionary containing attribute keys and their names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {attr: attr[1:] for attr in cls.attributes()}</span>


<span class="w"> </span>class FieldFlag(IntFlag):
<span class="gh">diff --git a/pypdf/filters.py b/pypdf/filters.py</span>
<span class="gh">index c0443ef..7351364 100644</span>
<span class="gd">--- a/pypdf/filters.py</span>
<span class="gi">+++ b/pypdf/filters.py</span>
<span class="gu">@@ -37,7 +37,10 @@ def decompress(data: bytes) -&gt;bytes:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The decompressed data.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return zlib.decompress(data)</span>
<span class="gi">+    except zlib.error:</span>
<span class="gi">+        return zlib.decompress(data, -15)</span>


<span class="w"> </span>class FlateDecode:
<span class="gu">@@ -59,7 +62,39 @@ class FlateDecode:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          PdfReadError:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = decompress(data)</span>
<span class="gi">+        predictor = 1</span>
<span class="gi">+        if decode_parms:</span>
<span class="gi">+            try:</span>
<span class="gi">+                predictor = decode_parms.get(&quot;/Predictor&quot;, 1)</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        if predictor != 1:</span>
<span class="gi">+            columns = decode_parms.get(&quot;/Columns&quot;, 1)</span>
<span class="gi">+            colors = decode_parms.get(&quot;/Colors&quot;, 1)</span>
<span class="gi">+            bitspercomponent = decode_parms.get(&quot;/BitsPerComponent&quot;, 8)</span>
<span class="gi">+            </span>
<span class="gi">+            rowlength = (columns * colors * bitspercomponent + 7) // 8</span>
<span class="gi">+            if len(data) % rowlength != 0:</span>
<span class="gi">+                raise PdfReadError(&quot;Invalid data length&quot;)</span>
<span class="gi">+            </span>
<span class="gi">+            output = bytearray()</span>
<span class="gi">+            row_prev = [0] * rowlength</span>
<span class="gi">+            for i in range(0, len(data), rowlength):</span>
<span class="gi">+                row = list(data[i:i+rowlength])</span>
<span class="gi">+                if predictor &gt;= 10:</span>
<span class="gi">+                    predictor_type = row[0]</span>
<span class="gi">+                    row = row[1:]</span>
<span class="gi">+                    if predictor_type == 2:</span>
<span class="gi">+                        for j in range(len(row)):</span>
<span class="gi">+                            row[j] = (row[j] + row_prev[j]) % 256</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        raise PdfReadError(f&quot;Unsupported PNG predictor {predictor_type}&quot;)</span>
<span class="gi">+                output.extend(row)</span>
<span class="gi">+                row_prev = row</span>
<span class="gi">+            data = bytes(output)</span>
<span class="gi">+        return data</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def encode(data: bytes, level: int=-1) -&gt;bytes:
<span class="gu">@@ -73,7 +108,7 @@ class FlateDecode:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The compressed data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return zlib.compress(data, level)</span>


<span class="w"> </span>class ASCIIHexDecode:
<span class="gu">@@ -101,7 +136,23 @@ class ASCIIHexDecode:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          PdfStreamError:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(data, str):</span>
<span class="gi">+            data = data.encode(&#39;ascii&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        data = data.replace(b&#39;\x00&#39;, b&#39;&#39;).replace(b&#39;\n&#39;, b&#39;&#39;).replace(b&#39;\r&#39;, b&#39;&#39;).replace(b&#39; &#39;, b&#39;&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        if data[-1:] == b&#39;&gt;&#39;:</span>
<span class="gi">+            data = data[:-1]</span>
<span class="gi">+        </span>
<span class="gi">+        if len(data) % 2 != 0:</span>
<span class="gi">+            data += b&#39;0&#39;</span>
<span class="gi">+        </span>
<span class="gi">+        try:</span>
<span class="gi">+            result = bytes.fromhex(data.decode(&#39;ascii&#39;))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise PdfStreamError(&quot;Invalid hex data in ASCIIHexDecode&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        return result</span>


<span class="w"> </span>class RunLengthDecode:
<span class="gu">@@ -134,7 +185,19 @@ class RunLengthDecode:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          PdfStreamError:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        decoded = bytearray()</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        while i &lt; len(data):</span>
<span class="gi">+            length = data[i]</span>
<span class="gi">+            if length == 128:</span>
<span class="gi">+                break</span>
<span class="gi">+            if length &lt; 128:</span>
<span class="gi">+                decoded.extend(data[i+1:i+length+2])</span>
<span class="gi">+                i += length + 2</span>
<span class="gi">+            else:</span>
<span class="gi">+                decoded.extend([data[i+1]] * (257 - length))</span>
<span class="gi">+                i += 2</span>
<span class="gi">+        return bytes(decoded)</span>


<span class="w"> </span>class LZWDecode:
<span class="gu">@@ -171,7 +234,29 @@ class LZWDecode:</span>
<span class="w"> </span>            Raises:
<span class="w"> </span>              PdfReadError: If the stop code is missing
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            cW = self.CLEARDICT</span>
<span class="gi">+            baos = &quot;&quot;</span>
<span class="gi">+            while True:</span>
<span class="gi">+                pW = cW</span>
<span class="gi">+                cW = self.get_next_code()</span>
<span class="gi">+                if cW == -1:</span>
<span class="gi">+                    raise PdfReadError(&quot;Missed the stop code in LZWDecode!&quot;)</span>
<span class="gi">+                if cW == self.STOP:</span>
<span class="gi">+                    break</span>
<span class="gi">+                elif cW == self.CLEARDICT:</span>
<span class="gi">+                    self.reset_dict()</span>
<span class="gi">+                elif pW == self.CLEARDICT:</span>
<span class="gi">+                    baos += self.dict[cW]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if cW &lt; len(self.dict):</span>
<span class="gi">+                        baos += self.dict[cW]</span>
<span class="gi">+                        p = self.dict[pW] + self.dict[cW][0]</span>
<span class="gi">+                        self.dict.append(p)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        p = self.dict[pW] + self.dict[pW][0]</span>
<span class="gi">+                        baos += p</span>
<span class="gi">+                        self.dict.append(p)</span>
<span class="gi">+            return baos</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def decode(data: bytes, decode_parms: Optional[DictionaryObject]=None,
<span class="gu">@@ -186,7 +271,8 @@ class LZWDecode:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          decoded data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        decoder = LZWDecode.Decoder(data)</span>
<span class="gi">+        return decoder.decode()</span>


<span class="w"> </span>class ASCII85Decode:
<span class="gu">@@ -205,7 +291,15 @@ class ASCII85Decode:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          decoded data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(data, str):</span>
<span class="gi">+            data = data.encode(&#39;ascii&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        if data.startswith(b&#39;&lt;~&#39;):</span>
<span class="gi">+            data = data[2:]</span>
<span class="gi">+        if data.endswith(b&#39;~&gt;&#39;):</span>
<span class="gi">+            data = data[:-2]</span>
<span class="gi">+        </span>
<span class="gi">+        return a85decode(data)</span>


<span class="w"> </span>class DCTDecode:
<span class="gu">@@ -258,7 +352,49 @@ def decode_stream_data(stream: Any) -&gt;Union[bytes, str]:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        NotImplementedError: If an unsupported filter type is encountered.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    filters = stream.get(&quot;/Filter&quot;, ())</span>
<span class="gi">+    if isinstance(filters, IndirectObject):</span>
<span class="gi">+        filters = filters.get_object()</span>
<span class="gi">+    params = stream.get(&quot;/DecodeParms&quot;, ())</span>
<span class="gi">+    if isinstance(params, IndirectObject):</span>
<span class="gi">+        params = params.get_object()</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(filters, ArrayObject):</span>
<span class="gi">+        filters = filters.items()</span>
<span class="gi">+    elif isinstance(filters, (NameObject, str)):</span>
<span class="gi">+        filters = (filters,)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(f&quot;/Filter should be name, string, or array, not {type(filters)}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(params, ArrayObject):</span>
<span class="gi">+        params = params.items()</span>
<span class="gi">+    elif isinstance(params, DictionaryObject):</span>
<span class="gi">+        params = (params,)</span>
<span class="gi">+    else:</span>
<span class="gi">+        params = ()</span>
<span class="gi">+</span>
<span class="gi">+    data = stream._data</span>
<span class="gi">+    for filter_type, param in zip_longest(filters, params):</span>
<span class="gi">+        if filter_type in (FTA.FLATEDECODE, FTA.FL, FT.FLATEDECODE):</span>
<span class="gi">+            data = FlateDecode.decode(data, param)</span>
<span class="gi">+        elif filter_type in (FTA.ASCIIHEXDECODE, FTA.AHX, FT.ASCIIHEXDECODE):</span>
<span class="gi">+            data = ASCIIHexDecode.decode(data, param)</span>
<span class="gi">+        elif filter_type in (FTA.RUNLENGTHDECODE, FTA.RL, FT.RUNLENGTHDECODE):</span>
<span class="gi">+            data = RunLengthDecode.decode(data, param)</span>
<span class="gi">+        elif filter_type in (FTA.LZWDECODE, FTA.LZW, FT.LZWDECODE):</span>
<span class="gi">+            data = LZWDecode.decode(data, param)</span>
<span class="gi">+        elif filter_type in (FTA.ASCII85DECODE, FTA.A85, FT.ASCII85DECODE):</span>
<span class="gi">+            data = ASCII85Decode.decode(data, param)</span>
<span class="gi">+        elif filter_type in (FTA.DCTDECODE, FTA.DCT, FT.DCTDECODE):</span>
<span class="gi">+            data = DCTDecode.decode(data, param)</span>
<span class="gi">+        elif filter_type in (FTA.JPXDECODE, FTA.JPX, FT.JPXDECODE):</span>
<span class="gi">+            data = JPXDecode.decode(data, param)</span>
<span class="gi">+        elif filter_type in (FTA.CCITTFAXDECODE, FTA.CCF, FT.CCITTFAXDECODE):</span>
<span class="gi">+            data = CCITTFaxDecode.decode(data, param)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise NotImplementedError(f&quot;Unsupported filter: {filter_type}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return data</span>


<span class="w"> </span>def decodeStreamData(stream: Any) -&gt;Union[str, bytes]:
<span class="gh">diff --git a/pypdf/generic/_base.py b/pypdf/generic/_base.py</span>
<span class="gh">index 0b650fd..fe28f70 100644</span>
<span class="gd">--- a/pypdf/generic/_base.py</span>
<span class="gi">+++ b/pypdf/generic/_base.py</span>
<span class="gu">@@ -40,7 +40,7 @@ class PdfObject(PdfObjectProtocol):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          The cloned PdfObject
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._reference_clone(self, pdf_dest, force_duplicate)</span>

<span class="w"> </span>    def _reference_clone(self, clone: Any, pdf_dest: PdfWriterProtocol,
<span class="w"> </span>        force_duplicate: bool=False) -&gt;PdfObjectProtocol:
<span class="gu">@@ -57,11 +57,15 @@ class PdfObject(PdfObjectProtocol):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          The clone
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hasattr(self, &#39;indirect_reference&#39;) and self.indirect_reference is not None:</span>
<span class="gi">+            if not force_duplicate and self.indirect_reference.idnum in pdf_dest._objects:</span>
<span class="gi">+                return pdf_dest._objects[self.indirect_reference.idnum]</span>
<span class="gi">+            pdf_dest._add_object(clone)</span>
<span class="gi">+        return clone</span>

<span class="w"> </span>    def get_object(self) -&gt;Optional[&#39;PdfObject&#39;]:
<span class="w"> </span>        &quot;&quot;&quot;Resolve indirect references.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class NullObject(PdfObject):
<span class="gu">@@ -70,7 +74,7 @@ class NullObject(PdfObject):</span>
<span class="w"> </span>        False, ignore_fields: Optional[Sequence[Union[str, int]]]=()
<span class="w"> </span>        ) -&gt;&#39;NullObject&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Clone object into pdf_dest.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return NullObject()</span>

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        return &#39;NullObject&#39;
<span class="gu">@@ -85,7 +89,7 @@ class BooleanObject(PdfObject):</span>
<span class="w"> </span>        False, ignore_fields: Optional[Sequence[Union[str, int]]]=()
<span class="w"> </span>        ) -&gt;&#39;BooleanObject&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Clone object into pdf_dest.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return BooleanObject(self.value)</span>

<span class="w"> </span>    def __eq__(self, __o: object) -&gt;bool:
<span class="w"> </span>        if isinstance(__o, BooleanObject):
<span class="gu">@@ -110,7 +114,7 @@ class IndirectObject(PdfObject):</span>
<span class="w"> </span>        False, ignore_fields: Optional[Sequence[Union[str, int]]]=()
<span class="w"> </span>        ) -&gt;&#39;IndirectObject&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Clone object into pdf_dest.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return IndirectObject(self.idnum, self.generation, pdf_dest)</span>

<span class="w"> </span>    def __deepcopy__(self, memo: Any) -&gt;&#39;IndirectObject&#39;:
<span class="w"> </span>        return IndirectObject(self.idnum, self.generation, self.pdf)
<span class="gu">@@ -162,7 +166,7 @@ class FloatObject(float, PdfObject):</span>
<span class="w"> </span>    def clone(self, pdf_dest: Any, force_duplicate: bool=False,
<span class="w"> </span>        ignore_fields: Optional[Sequence[Union[str, int]]]=()) -&gt;&#39;FloatObject&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Clone object into pdf_dest.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return FloatObject(self)</span>

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        return self.myrepr()
<span class="gu">@@ -183,7 +187,7 @@ class NumberObject(int, PdfObject):</span>
<span class="w"> </span>        ignore_fields: Optional[Sequence[Union[str, int]]]=()
<span class="w"> </span>        ) -&gt;&#39;NumberObject&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Clone object into pdf_dest.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return NumberObject(self)</span>


<span class="w"> </span>class ByteStringObject(bytes, PdfObject):
<span class="gu">@@ -199,12 +203,12 @@ class ByteStringObject(bytes, PdfObject):</span>
<span class="w"> </span>        ignore_fields: Optional[Sequence[Union[str, int]]]=()
<span class="w"> </span>        ) -&gt;&#39;ByteStringObject&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Clone object into pdf_dest.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ByteStringObject(self)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def original_bytes(self) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;For compatibility with TextStringObject.original_bytes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bytes(self)</span>


<span class="w"> </span>class TextStringObject(str, PdfObject):
<span class="gu">@@ -241,7 +245,11 @@ class TextStringObject(str, PdfObject):</span>
<span class="w"> </span>        ignore_fields: Optional[Sequence[Union[str, int]]]=()
<span class="w"> </span>        ) -&gt;&#39;TextStringObject&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Clone object into pdf_dest.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        clone = TextStringObject(self)</span>
<span class="gi">+        clone.autodetect_utf16 = self.autodetect_utf16</span>
<span class="gi">+        clone.autodetect_pdfdocencoding = self.autodetect_pdfdocencoding</span>
<span class="gi">+        clone.utf16_bom = self.utf16_bom</span>
<span class="gi">+        return clone</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def original_bytes(self) -&gt;bytes:
<span class="gu">@@ -251,7 +259,12 @@ class TextStringObject(str, PdfObject):</span>
<span class="w"> </span>        if that occurs, this &quot;original_bytes&quot; property can be used to
<span class="w"> </span>        back-calculate what the original encoded bytes were.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.autodetect_utf16:</span>
<span class="gi">+            return self.utf16_bom + self.encode(&#39;utf-16be&#39;)</span>
<span class="gi">+        elif self.autodetect_pdfdocencoding:</span>
<span class="gi">+            return encode_pdfdocencoding(self)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise UnicodeEncodeError(&quot;No information about original bytes&quot;)</span>


<span class="w"> </span>class NameObject(str, PdfObject):
<span class="gu">@@ -264,5 +277,5 @@ class NameObject(str, PdfObject):</span>
<span class="w"> </span>    def clone(self, pdf_dest: Any, force_duplicate: bool=False,
<span class="w"> </span>        ignore_fields: Optional[Sequence[Union[str, int]]]=()) -&gt;&#39;NameObject&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Clone object into pdf_dest.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return NameObject(self)</span>
<span class="w"> </span>    CHARSETS = &#39;utf-8&#39;, &#39;gbk&#39;, &#39;latin1&#39;
<span class="gh">diff --git a/pypdf/generic/_data_structures.py b/pypdf/generic/_data_structures.py</span>
<span class="gh">index 5063153..123749e 100644</span>
<span class="gd">--- a/pypdf/generic/_data_structures.py</span>
<span class="gi">+++ b/pypdf/generic/_data_structures.py</span>
<span class="gu">@@ -33,11 +33,14 @@ class ArrayObject(List[Any], PdfObject):</span>
<span class="w"> </span>        False, ignore_fields: Optional[Sequence[Union[str, int]]]=()
<span class="w"> </span>        ) -&gt;&#39;ArrayObject&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Clone object into pdf_dest.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ArrayObject(</span>
<span class="gi">+            [obj.clone(pdf_dest, force_duplicate, ignore_fields) if isinstance(obj, PdfObject) else obj</span>
<span class="gi">+             for obj in self]</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def items(self) -&gt;Iterable[Any]:
<span class="w"> </span>        &quot;&quot;&quot;Emulate DictionaryObject.items for a list (index, object).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return enumerate(self)</span>

<span class="w"> </span>    def __add__(self, lst: Any) -&gt;&#39;ArrayObject&#39;:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -88,7 +91,10 @@ class DictionaryObject(Dict[Any, Any], PdfObject):</span>
<span class="w"> </span>        False, ignore_fields: Optional[Sequence[Union[str, int]]]=()
<span class="w"> </span>        ) -&gt;&#39;DictionaryObject&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Clone object into pdf_dest.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cloned = DictionaryObject()</span>
<span class="gi">+        visited = set()</span>
<span class="gi">+        self._clone(self, pdf_dest, force_duplicate, ignore_fields, visited)</span>
<span class="gi">+        return cloned</span>

<span class="w"> </span>    def _clone(self, src: &#39;DictionaryObject&#39;, pdf_dest: PdfWriterProtocol,
<span class="w"> </span>        force_duplicate: bool, ignore_fields: Optional[Sequence[Union[str,
<span class="gu">@@ -102,7 +108,16 @@ class DictionaryObject(Dict[Any, Any], PdfObject):</span>
<span class="w"> </span>            force_duplicate:
<span class="w"> </span>            ignore_fields:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for key, value in src.items():</span>
<span class="gi">+            if key in ignore_fields:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if isinstance(value, PdfObject):</span>
<span class="gi">+                if hasattr(value, &#39;clone&#39;):</span>
<span class="gi">+                    self[key] = value.clone(pdf_dest, force_duplicate, ignore_fields)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self[key] = value</span>
<span class="gi">+            else:</span>
<span class="gi">+                self[key] = value</span>

<span class="w"> </span>    def get_inherited(self, key: str, default: Any=None) -&gt;Any:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -117,7 +132,14 @@ class DictionaryObject(Dict[Any, Any], PdfObject):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            Current key or inherited one, otherwise default value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self[key]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            if &#39;/Parent&#39; in self:</span>
<span class="gi">+                parent = self[&#39;/Parent&#39;]</span>
<span class="gi">+                if isinstance(parent, DictionaryObject):</span>
<span class="gi">+                    return parent.get_inherited(key, default)</span>
<span class="gi">+        return default</span>

<span class="w"> </span>    def __setitem__(self, key: Any, value: Any) -&gt;Any:
<span class="w"> </span>        if not isinstance(key, PdfObject):
<span class="gu">@@ -142,7 +164,16 @@ class DictionaryObject(Dict[Any, Any], PdfObject):</span>
<span class="w"> </span>          that can be used to access XMP metadata from the document. Can also
<span class="w"> </span>          return None if no metadata was found on the document root.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from ..xmp import XmpInformation</span>
<span class="gi">+</span>
<span class="gi">+        metadata = self.get(&quot;/Metadata&quot;, None)</span>
<span class="gi">+        if metadata is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        metadata = metadata.get_object()</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(metadata, StreamObject):</span>
<span class="gi">+            return None</span>
<span class="gi">+        return XmpInformation(metadata)</span>


<span class="w"> </span>class TreeObject(DictionaryObject):
<span class="gu">@@ -166,11 +197,44 @@ class TreeObject(DictionaryObject):</span>
<span class="w"> </span>            cur:
<span class="w"> </span>            last:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if prev is None:</span>
<span class="gi">+            if last == cur:</span>
<span class="gi">+                self[NameObject(&quot;/First&quot;)] = NullObject()</span>
<span class="gi">+                self[NameObject(&quot;/Last&quot;)] = NullObject()</span>
<span class="gi">+            else:</span>
<span class="gi">+                self[NameObject(&quot;/First&quot;)] = cur.get(&quot;/Next&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            prev[NameObject(&quot;/Next&quot;)] = cur.get(&quot;/Next&quot;)</span>
<span class="gi">+            if last == cur:</span>
<span class="gi">+                self[NameObject(&quot;/Last&quot;)] = prev_ref</span>
<span class="gi">+</span>
<span class="gi">+        if cur.get(&quot;/Next&quot;) is not None:</span>
<span class="gi">+            next_ref = cur.get(&quot;/Next&quot;)</span>
<span class="gi">+            next_ref[NameObject(&quot;/Prev&quot;)] = prev_ref</span>
<span class="gi">+</span>
<span class="gi">+        self[NameObject(&quot;/Count&quot;)] = NumberObject(self[&quot;/Count&quot;] - 1)</span>

<span class="w"> </span>    def remove_from_tree(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Remove the object from the tree it is in.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &quot;/Parent&quot; not in self:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        parent = self[&quot;/Parent&quot;]</span>
<span class="gi">+        prev = None</span>
<span class="gi">+        prev_ref = None</span>
<span class="gi">+        cur = parent[&quot;/First&quot;]</span>
<span class="gi">+        last = parent[&quot;/Last&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        while cur is not None:</span>
<span class="gi">+            if cur == self:</span>
<span class="gi">+                parent._remove_node_from_tree(prev, prev_ref, cur, last)</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            prev = cur</span>
<span class="gi">+            prev_ref = parent.indirect_reference</span>
<span class="gi">+            cur = cur.get(&quot;/Next&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        _reset_node_tree_relationship(self)</span>


<span class="w"> </span>def _reset_node_tree_relationship(child_obj: Any) -&gt;None:
<span class="gu">@@ -182,7 +246,9 @@ def _reset_node_tree_relationship(child_obj: Any) -&gt;None:</span>
<span class="w"> </span>    Args:
<span class="w"> </span>        child_obj:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    del child_obj[&quot;/Parent&quot;]</span>
<span class="gi">+    del child_obj[&quot;/Next&quot;]</span>
<span class="gi">+    del child_obj[&quot;/Prev&quot;]</span>


<span class="w"> </span>class StreamObject(DictionaryObject):
<span class="gh">diff --git a/pypdf/generic/_fit.py b/pypdf/generic/_fit.py</span>
<span class="gh">index c30240c..ff6b136 100644</span>
<span class="gd">--- a/pypdf/generic/_fit.py</span>
<span class="gi">+++ b/pypdf/generic/_fit.py</span>
<span class="gu">@@ -31,7 +31,7 @@ class Fit:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The created fit object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(&#39;XYZ&#39;, (left, top, zoom))</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def fit(cls) -&gt;&#39;Fit&#39;:
<span class="gu">@@ -44,7 +44,7 @@ class Fit:</span>
<span class="w"> </span>        different, use the smaller of the two, centering the page within the
<span class="w"> </span>        window in the other dimension.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(&#39;Fit&#39;)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def fit_horizontally(cls, top: Optional[float]=None) -&gt;&#39;Fit&#39;:
<span class="gu">@@ -63,7 +63,7 @@ class Fit:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The created fit object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(&#39;FitH&#39;, (top,))</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def fit_rectangle(cls, left: Optional[float]=None, bottom: Optional[
<span class="gu">@@ -91,7 +91,7 @@ class Fit:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The created fit object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(&#39;FitR&#39;, (left, bottom, right, top))</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def fit_box(cls) -&gt;&#39;Fit&#39;:
<span class="gu">@@ -104,7 +104,7 @@ class Fit:</span>
<span class="w"> </span>        different, use the smaller of the two, centering the bounding box
<span class="w"> </span>        within the window in the other dimension.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(&#39;FitB&#39;)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def fit_box_horizontally(cls, top: Optional[float]=None) -&gt;&#39;Fit&#39;:
<span class="gu">@@ -123,7 +123,7 @@ class Fit:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The created fit object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(&#39;FitBH&#39;, (top,))</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def fit_box_vertically(cls, left: Optional[float]=None) -&gt;&#39;Fit&#39;:
<span class="gu">@@ -142,7 +142,7 @@ class Fit:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The created fit object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(&#39;FitBV&#39;, (left,))</span>

<span class="w"> </span>    def __str__(self) -&gt;str:
<span class="w"> </span>        if not self.fit_args:
<span class="gh">diff --git a/pypdf/generic/_image_inline.py b/pypdf/generic/_image_inline.py</span>
<span class="gh">index 8a46ea7..7fc12c9 100644</span>
<span class="gd">--- a/pypdf/generic/_image_inline.py</span>
<span class="gi">+++ b/pypdf/generic/_image_inline.py</span>
<span class="gu">@@ -11,7 +11,18 @@ def extract_inline_AHx(stream: StreamType) -&gt;bytes:</span>
<span class="w"> </span>    Extract HexEncoded Stream from Inline Image.
<span class="w"> </span>    the stream will be moved onto the EI
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    data = BytesIO()</span>
<span class="gi">+    while True:</span>
<span class="gi">+        tok = read_non_whitespace(stream)</span>
<span class="gi">+        if tok == b&#39;&gt;&#39;:</span>
<span class="gi">+            stream.read(1)  # Move past the &#39;&gt;&#39;</span>
<span class="gi">+            break</span>
<span class="gi">+        elif tok not in b&#39;0123456789ABCDEFabcdef&#39;:</span>
<span class="gi">+            raise PdfReadError(f&quot;Unexpected token in ASCIIHexDecode: {tok}&quot;)</span>
<span class="gi">+        data.write(tok)</span>
<span class="gi">+    </span>
<span class="gi">+    hex_data = data.getvalue()</span>
<span class="gi">+    return bytes.fromhex(hex_data.decode(&#39;ascii&#39;))</span>


<span class="w"> </span>def extract_inline_A85(stream: StreamType) -&gt;bytes:
<span class="gu">@@ -19,7 +30,19 @@ def extract_inline_A85(stream: StreamType) -&gt;bytes:</span>
<span class="w"> </span>    Extract A85 Stream from Inline Image.
<span class="w"> </span>    the stream will be moved onto the EI
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    data = BytesIO()</span>
<span class="gi">+    while True:</span>
<span class="gi">+        chunk = stream.read(BUFFER_SIZE)</span>
<span class="gi">+        if not chunk:</span>
<span class="gi">+            raise PdfReadError(&quot;Unexpected EOF in ASCII85Decode&quot;)</span>
<span class="gi">+        if b&#39;~&gt;&#39; in chunk:</span>
<span class="gi">+            data.write(chunk[:chunk.index(b&#39;~&gt;&#39;)])</span>
<span class="gi">+            stream.seek(stream.tell() - len(chunk) + chunk.index(b&#39;~&gt;&#39;) + 2)</span>
<span class="gi">+            break</span>
<span class="gi">+        data.write(chunk)</span>
<span class="gi">+    </span>
<span class="gi">+    ascii85_data = data.getvalue()</span>
<span class="gi">+    return ascii85_data.decode(&#39;ascii85&#39;)</span>


<span class="w"> </span>def extract_inline_RL(stream: StreamType) -&gt;bytes:
<span class="gu">@@ -27,7 +50,19 @@ def extract_inline_RL(stream: StreamType) -&gt;bytes:</span>
<span class="w"> </span>    Extract RL Stream from Inline Image.
<span class="w"> </span>    the stream will be moved onto the EI
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    data = BytesIO()</span>
<span class="gi">+    while True:</span>
<span class="gi">+        byte = stream.read(1)</span>
<span class="gi">+        if not byte:</span>
<span class="gi">+            raise PdfReadError(&quot;Unexpected EOF in RunLengthDecode&quot;)</span>
<span class="gi">+        if byte == b&#39;\x80&#39;:</span>
<span class="gi">+            break</span>
<span class="gi">+        if ord(byte) &lt; 128:</span>
<span class="gi">+            data.write(stream.read(ord(byte) + 1))</span>
<span class="gi">+        else:</span>
<span class="gi">+            data.write(stream.read(1) * (257 - ord(byte)))</span>
<span class="gi">+    </span>
<span class="gi">+    return data.getvalue()</span>


<span class="w"> </span>def extract_inline_DCT(stream: StreamType) -&gt;bytes:
<span class="gu">@@ -35,7 +70,18 @@ def extract_inline_DCT(stream: StreamType) -&gt;bytes:</span>
<span class="w"> </span>    Extract DCT (JPEG) Stream from Inline Image.
<span class="w"> </span>    the stream will be moved onto the EI
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    data = BytesIO()</span>
<span class="gi">+    while True:</span>
<span class="gi">+        chunk = stream.read(BUFFER_SIZE)</span>
<span class="gi">+        if not chunk:</span>
<span class="gi">+            raise PdfReadError(&quot;Unexpected EOF in DCTDecode&quot;)</span>
<span class="gi">+        data.write(chunk)</span>
<span class="gi">+        if b&#39;\xff\xd9&#39; in chunk:  # JPEG EOI marker</span>
<span class="gi">+            break</span>
<span class="gi">+    </span>
<span class="gi">+    jpeg_data = data.getvalue()</span>
<span class="gi">+    stream.seek(stream.tell() - len(chunk) + chunk.rindex(b&#39;\xff\xd9&#39;) + 2)</span>
<span class="gi">+    return jpeg_data</span>


<span class="w"> </span>def extract_inline_default(stream: StreamType) -&gt;bytes:
<span class="gu">@@ -43,4 +89,20 @@ def extract_inline_default(stream: StreamType) -&gt;bytes:</span>
<span class="w"> </span>    Legacy method
<span class="w"> </span>    used by default
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    data = BytesIO()</span>
<span class="gi">+    while True:</span>
<span class="gi">+        tok = stream.read(1)</span>
<span class="gi">+        if not tok:</span>
<span class="gi">+            raise PdfReadError(&quot;Unexpected EOF in inline image&quot;)</span>
<span class="gi">+        if tok in WHITESPACES:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if tok == b&#39;E&#39;:</span>
<span class="gi">+            tok2 = stream.read(1)</span>
<span class="gi">+            if tok2 == b&#39;I&#39;:</span>
<span class="gi">+                stream.seek(-2, 1)</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                stream.seek(-1, 1)</span>
<span class="gi">+        data.write(tok)</span>
<span class="gi">+    </span>
<span class="gi">+    return data.getvalue()</span>
<span class="gh">diff --git a/pypdf/generic/_outline.py b/pypdf/generic/_outline.py</span>
<span class="gh">index 3c300f6..67c1826 100644</span>
<span class="gd">--- a/pypdf/generic/_outline.py</span>
<span class="gi">+++ b/pypdf/generic/_outline.py</span>
<span class="gu">@@ -1,8 +1,84 @@</span>
<span class="gd">-from typing import Union</span>
<span class="gi">+from typing import Union, Optional, List</span>
<span class="w"> </span>from .._utils import StreamType, deprecate_no_replacement
<span class="gd">-from ._base import NameObject</span>
<span class="gi">+from ._base import NameObject, BooleanObject, ArrayObject, DictionaryObject</span>
<span class="w"> </span>from ._data_structures import Destination


<span class="w"> </span>class OutlineItem(Destination):
<span class="gd">-    pass</span>
<span class="gi">+    def __init__(self, title: str, page: Union[int, Destination], color: Optional[List[float]] = None, </span>
<span class="gi">+                 bold: bool = False, italic: bool = False, fit: Union[str, NameObject] = &quot;/Fit&quot;) -&gt; None:</span>
<span class="gi">+        super().__init__(page, fit)</span>
<span class="gi">+        self.title = title</span>
<span class="gi">+        self.color = color</span>
<span class="gi">+        self.bold = bold</span>
<span class="gi">+        self.italic = italic</span>
<span class="gi">+        self.parent = None</span>
<span class="gi">+        self.prev = None</span>
<span class="gi">+        self.next = None</span>
<span class="gi">+        self.first = None</span>
<span class="gi">+        self.last = None</span>
<span class="gi">+        self.count = 0</span>
<span class="gi">+</span>
<span class="gi">+    def get_object(self) -&gt; DictionaryObject:</span>
<span class="gi">+        obj = DictionaryObject()</span>
<span class="gi">+        obj[NameObject(&quot;/Title&quot;)] = self.title</span>
<span class="gi">+</span>
<span class="gi">+        # Add destination</span>
<span class="gi">+        obj.update(super().get_object())</span>
<span class="gi">+</span>
<span class="gi">+        # Add color if specified</span>
<span class="gi">+        if self.color:</span>
<span class="gi">+            obj[NameObject(&quot;/C&quot;)] = ArrayObject([float(c) for c in self.color])</span>
<span class="gi">+</span>
<span class="gi">+        # Add text format flags</span>
<span class="gi">+        if self.bold or self.italic:</span>
<span class="gi">+            format_flag = 0</span>
<span class="gi">+            if self.bold:</span>
<span class="gi">+                format_flag += 2</span>
<span class="gi">+            if self.italic:</span>
<span class="gi">+                format_flag += 1</span>
<span class="gi">+            obj[NameObject(&quot;/F&quot;)] = format_flag</span>
<span class="gi">+</span>
<span class="gi">+        # Add structural attributes</span>
<span class="gi">+        if self.parent:</span>
<span class="gi">+            obj[NameObject(&quot;/Parent&quot;)] = self.parent</span>
<span class="gi">+        if self.prev:</span>
<span class="gi">+            obj[NameObject(&quot;/Prev&quot;)] = self.prev</span>
<span class="gi">+        if self.next:</span>
<span class="gi">+            obj[NameObject(&quot;/Next&quot;)] = self.next</span>
<span class="gi">+        if self.first:</span>
<span class="gi">+            obj[NameObject(&quot;/First&quot;)] = self.first</span>
<span class="gi">+        if self.last:</span>
<span class="gi">+            obj[NameObject(&quot;/Last&quot;)] = self.last</span>
<span class="gi">+        if self.count:</span>
<span class="gi">+            obj[NameObject(&quot;/Count&quot;)] = self.count</span>
<span class="gi">+</span>
<span class="gi">+        return obj</span>
<span class="gi">+</span>
<span class="gi">+    def add_child(self, child: &#39;OutlineItem&#39;) -&gt; None:</span>
<span class="gi">+        child.parent = self</span>
<span class="gi">+        if self.first is None:</span>
<span class="gi">+            self.first = child</span>
<span class="gi">+            self.last = child</span>
<span class="gi">+        else:</span>
<span class="gi">+            child.prev = self.last</span>
<span class="gi">+            self.last.next = child</span>
<span class="gi">+            self.last = child</span>
<span class="gi">+        self.count += 1</span>
<span class="gi">+</span>
<span class="gi">+    def add_sibling(self, sibling: &#39;OutlineItem&#39;) -&gt; None:</span>
<span class="gi">+        if self.parent:</span>
<span class="gi">+            self.parent.add_child(sibling)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Cannot add sibling to root outline item&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def is_closed(self) -&gt; bool:</span>
<span class="gi">+        return self.count &lt; 0</span>
<span class="gi">+</span>
<span class="gi">+    @is_closed.setter</span>
<span class="gi">+    def is_closed(self, value: bool) -&gt; None:</span>
<span class="gi">+        if value:</span>
<span class="gi">+            self.count = -abs(self.count)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.count = abs(self.count)</span>
<span class="gh">diff --git a/pypdf/generic/_rectangle.py b/pypdf/generic/_rectangle.py</span>
<span class="gh">index 5e885b2..5684dec 100644</span>
<span class="gd">--- a/pypdf/generic/_rectangle.py</span>
<span class="gi">+++ b/pypdf/generic/_rectangle.py</span>
<span class="gu">@@ -30,7 +30,12 @@ class RectangleObject(ArrayObject):</span>
<span class="w"> </span>        Property to read and modify the lower left coordinate of this box
<span class="w"> </span>        in (x,y) form.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (float(self[0]), float(self[1]))</span>
<span class="gi">+</span>
<span class="gi">+    @lower_left.setter</span>
<span class="gi">+    def lower_left(self, value: Tuple[float, float]) -&gt;None:</span>
<span class="gi">+        self[0] = self._ensure_is_number(value[0])</span>
<span class="gi">+        self[1] = self._ensure_is_number(value[1])</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def lower_right(self) -&gt;Tuple[float, float]:
<span class="gu">@@ -38,7 +43,12 @@ class RectangleObject(ArrayObject):</span>
<span class="w"> </span>        Property to read and modify the lower right coordinate of this box
<span class="w"> </span>        in (x,y) form.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (float(self[2]), float(self[1]))</span>
<span class="gi">+</span>
<span class="gi">+    @lower_right.setter</span>
<span class="gi">+    def lower_right(self, value: Tuple[float, float]) -&gt;None:</span>
<span class="gi">+        self[2] = self._ensure_is_number(value[0])</span>
<span class="gi">+        self[1] = self._ensure_is_number(value[1])</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def upper_left(self) -&gt;Tuple[float, float]:
<span class="gu">@@ -46,7 +56,12 @@ class RectangleObject(ArrayObject):</span>
<span class="w"> </span>        Property to read and modify the upper left coordinate of this box
<span class="w"> </span>        in (x,y) form.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (float(self[0]), float(self[3]))</span>
<span class="gi">+</span>
<span class="gi">+    @upper_left.setter</span>
<span class="gi">+    def upper_left(self, value: Tuple[float, float]) -&gt;None:</span>
<span class="gi">+        self[0] = self._ensure_is_number(value[0])</span>
<span class="gi">+        self[3] = self._ensure_is_number(value[1])</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def upper_right(self) -&gt;Tuple[float, float]:
<span class="gu">@@ -54,4 +69,9 @@ class RectangleObject(ArrayObject):</span>
<span class="w"> </span>        Property to read and modify the upper right coordinate of this box
<span class="w"> </span>        in (x,y) form.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (float(self[2]), float(self[3]))</span>
<span class="gi">+</span>
<span class="gi">+    @upper_right.setter</span>
<span class="gi">+    def upper_right(self, value: Tuple[float, float]) -&gt;None:</span>
<span class="gi">+        self[2] = self._ensure_is_number(value[0])</span>
<span class="gi">+        self[3] = self._ensure_is_number(value[1])</span>
<span class="gh">diff --git a/pypdf/generic/_utils.py b/pypdf/generic/_utils.py</span>
<span class="gh">index f259fc9..c619857 100644</span>
<span class="gd">--- a/pypdf/generic/_utils.py</span>
<span class="gi">+++ b/pypdf/generic/_utils.py</span>
<span class="gu">@@ -17,9 +17,34 @@ def create_string_object(string: Union[str, bytes], forced_encoding: Union[</span>
<span class="w"> </span>        forced_encoding: Typically None, or an encoding string

<span class="w"> </span>    Returns:
<span class="gd">-        A ByteStringObject</span>
<span class="gi">+        A ByteStringObject or TextStringObject</span>

<span class="w"> </span>    Raises:
<span class="w"> </span>        TypeError: If string is not of type str or bytes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(string, str):</span>
<span class="gi">+        return TextStringObject(string)</span>
<span class="gi">+    elif isinstance(string, bytes):</span>
<span class="gi">+        if forced_encoding:</span>
<span class="gi">+            if isinstance(forced_encoding, str):</span>
<span class="gi">+                return TextStringObject(string.decode(forced_encoding))</span>
<span class="gi">+            elif isinstance(forced_encoding, list):</span>
<span class="gi">+                for encoding in forced_encoding:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        return TextStringObject(string.decode(encoding))</span>
<span class="gi">+                    except UnicodeDecodeError:</span>
<span class="gi">+                        pass</span>
<span class="gi">+            elif isinstance(forced_encoding, dict):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return TextStringObject(codecs.decode(string, _pdfdoc_encoding))</span>
<span class="gi">+                except UnicodeDecodeError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return TextStringObject(string.decode(&#39;utf-16&#39;))</span>
<span class="gi">+        except UnicodeDecodeError:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return TextStringObject(string.decode(&#39;utf-8&#39;))</span>
<span class="gi">+            except UnicodeDecodeError:</span>
<span class="gi">+                return ByteStringObject(string)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&quot;string must be of type str or bytes&quot;)</span>
<span class="gh">diff --git a/pypdf/generic/_viewerpref.py b/pypdf/generic/_viewerpref.py</span>
<span class="gh">index af352e7..2b590a0 100644</span>
<span class="gd">--- a/pypdf/generic/_viewerpref.py</span>
<span class="gi">+++ b/pypdf/generic/_viewerpref.py</span>
<span class="gu">@@ -73,3 +73,29 @@ class ViewerPreferences(DictionaryObject):</span>
<span class="w"> </span>            self.indirect_reference = obj.indirect_reference
<span class="w"> </span>        except AttributeError:
<span class="w"> </span>            pass
<span class="gi">+</span>
<span class="gi">+    def _get_bool(self, key: str, default: Optional[BooleanObject]) -&gt; Optional[BooleanObject]:</span>
<span class="gi">+        return self.get(key, default)</span>
<span class="gi">+</span>
<span class="gi">+    def _set_bool(self, key: str, value: bool) -&gt; None:</span>
<span class="gi">+        self[key] = BooleanObject(value)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_name(self, key: str, default: Optional[NameObject]) -&gt; Optional[NameObject]:</span>
<span class="gi">+        return self.get(key, default)</span>
<span class="gi">+</span>
<span class="gi">+    def _set_name(self, key: str, allowed_values: List[str], value: str) -&gt; None:</span>
<span class="gi">+        if value not in allowed_values:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid value for {key}. Allowed values are: {allowed_values}&quot;)</span>
<span class="gi">+        self[key] = NameObject(value)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_arr(self, key: str, default: Optional[ArrayObject]) -&gt; Optional[ArrayObject]:</span>
<span class="gi">+        return self.get(key, default)</span>
<span class="gi">+</span>
<span class="gi">+    def _set_arr(self, key: str, value: List[Any]) -&gt; None:</span>
<span class="gi">+        self[key] = ArrayObject(value)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_int(self, key: str, default: Optional[int]) -&gt; Optional[int]:</span>
<span class="gi">+        return self.get(key, default)</span>
<span class="gi">+</span>
<span class="gi">+    def _set_int(self, key: str, value: int) -&gt; None:</span>
<span class="gi">+        self[key] = NumberObject(value)</span>
<span class="gh">diff --git a/pypdf/pagerange.py b/pypdf/pagerange.py</span>
<span class="gh">index 2bc1277..3254af6 100644</span>
<span class="gd">--- a/pypdf/pagerange.py</span>
<span class="gi">+++ b/pypdf/pagerange.py</span>
<span class="gu">@@ -81,11 +81,15 @@ class PageRange:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            True, if the ``input`` is a valid PageRange.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(input, (PageRange, slice)):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(input, str):</span>
<span class="gi">+            return bool(re.match(PAGE_RANGE_RE, input))</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def to_slice(self) -&gt;slice:
<span class="w"> </span>        &quot;&quot;&quot;Return the slice equivalent of this page range.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._slice</span>

<span class="w"> </span>    def __str__(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;A string like &quot;1:2:3&quot;.&quot;&quot;&quot;
<span class="gu">@@ -116,7 +120,7 @@ class PageRange:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            Arguments for range().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._slice.indices(n)</span>

<span class="w"> </span>    def __eq__(self, other: object) -&gt;bool:
<span class="w"> </span>        if not isinstance(other, PageRange):
<span class="gu">@@ -153,7 +157,32 @@ def parse_filename_page_ranges(args: List[Union[str, PageRange, None]]) -&gt;List[</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A list of (filename, page_range) pairs.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    current_filename = None</span>
<span class="gi">+</span>
<span class="gi">+    for arg in args:</span>
<span class="gi">+        if arg is None:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if isinstance(arg, str):</span>
<span class="gi">+            if PageRange.valid(arg):</span>
<span class="gi">+                if current_filename is None:</span>
<span class="gi">+                    raise ValueError(&quot;Page range specified before filename&quot;)</span>
<span class="gi">+                result.append((current_filename, PageRange(arg)))</span>
<span class="gi">+            else:</span>
<span class="gi">+                if current_filename is not None:</span>
<span class="gi">+                    result.append((current_filename, PAGE_RANGE_ALL))</span>
<span class="gi">+                current_filename = arg</span>
<span class="gi">+        elif isinstance(arg, (PageRange, slice)):</span>
<span class="gi">+            if current_filename is None:</span>
<span class="gi">+                raise ValueError(&quot;Page range specified before filename&quot;)</span>
<span class="gi">+            result.append((current_filename, PageRange(arg)))</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(f&quot;Unexpected argument type: {type(arg)}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if current_filename is not None:</span>
<span class="gi">+        result.append((current_filename, PAGE_RANGE_ALL))</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>


<span class="w"> </span>PageRangeSpec = Union[str, PageRange, Tuple[int, int], Tuple[int, int, int],
<span class="gh">diff --git a/pypdf/xmp.py b/pypdf/xmp.py</span>
<span class="gh">index 78c923e..a300605 100644</span>
<span class="gd">--- a/pypdf/xmp.py</span>
<span class="gi">+++ b/pypdf/xmp.py</span>
<span class="gu">@@ -146,4 +146,11 @@ class XmpInformation(PdfObject):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A dictionary of key/value items for custom metadata properties.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &#39;custom_properties&#39; not in self.cache:</span>
<span class="gi">+            self.cache[&#39;custom_properties&#39;] = {}</span>
<span class="gi">+            properties = self.rdf_root.getElementsByTagNameNS(PDFX_NAMESPACE, &#39;property&#39;)</span>
<span class="gi">+            for prop in properties:</span>
<span class="gi">+                key = prop.getAttribute(&#39;pdfx:name&#39;)</span>
<span class="gi">+                value = prop.firstChild.nodeValue if prop.firstChild else None</span>
<span class="gi">+                self.cache[&#39;custom_properties&#39;][key] = value</span>
<span class="gi">+        return self.cache[&#39;custom_properties&#39;]</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>