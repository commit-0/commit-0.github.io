
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin tornado - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-tornado" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin tornado
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-test" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test test
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#autoreload_testpyautoreloadtesttest_reload" class="md-nav__link">
    <span class="md-ellipsis">
      autoreload_test.py::AutoreloadTest::test_reload
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#autoreload_testpyautoreloadtesttest_reload_wrapper_args" class="md-nav__link">
    <span class="md-ellipsis">
      autoreload_test.py::AutoreloadTest::test_reload_wrapper_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#autoreload_testpyautoreloadtesttest_reload_wrapper_preservation" class="md-nav__link">
    <span class="md-ellipsis">
      autoreload_test.py::AutoreloadTest::test_reload_wrapper_preservation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#autoreload_testpyautoreloadtesttest_reload_wrapper_until_success" class="md-nav__link">
    <span class="md-ellipsis">
      autoreload_test.py::AutoreloadTest::test_reload_wrapper_until_success
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#import_testpyimporttesttest_import_aliases" class="md-nav__link">
    <span class="md-ellipsis">
      import_test.py::ImportTest::test_import_aliases
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#import_testpyimporttesttest_import_everything" class="md-nav__link">
    <span class="md-ellipsis">
      import_test.py::ImportTest::test_import_everything
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#import_testpyimporttesttest_lazy_import" class="md-nav__link">
    <span class="md-ellipsis">
      import_test.py::ImportTest::test_lazy_import
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-tornado"><strong>Claude Sonnet 3.5 - Fill-in</strong>: tornado</h1>
<h2 id="pytest-summary-for-test-test">Pytest Summary for test <code>test</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">7</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">7</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">7</td>
</tr>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="autoreload_testpyautoreloadtesttest_reload">autoreload_test.py::AutoreloadTest::test_reload</h3>
<details><summary> <pre>autoreload_test.py::AutoreloadTest::test_reload</pre></summary><pre>
self = <tornado.test.autoreload_test.AutoreloadTest testMethod=test_reload>

        def test_reload(self):
            main = """\
    import sys

    # In module mode, the path is set to the parent directory and we can import testapp.
    try:
        import testapp
    except ImportError:
        print("import testapp failed")
    else:
        print("import testapp succeeded")

    spec = getattr(sys.modules[__name__], '__spec__', None)
    print(f"Starting {__name__=}, __spec__.name={getattr(spec, 'name', None)}")
    exec(open("run_twice_magic.py").read())
    """

            # Create temporary test application
            self.write_files(
                {
                    "testapp": {
                        "__init__.py": "",
                        "__main__.py": main,
                    },
                }
            )

            # The autoreload wrapper should support all the same modes as the python interpreter.
            # The wrapper itself should have no effect on this test so we try all modes with and
            # without it.
            for wrapper in [False, True]:
                with self.subTest(wrapper=wrapper):
                    with self.subTest(mode="module"):
                        if wrapper:
                            base_args = [sys.executable, "-m", "tornado.autoreload"]
                        else:
                            base_args = [sys.executable]
                        # In module mode, the path is set to the parent directory and we can import
                        # testapp. Also, the __spec__.name is set to the fully qualified module name.
>                       out = self.run_subprocess(base_args + ["-m", "testapp"])

tornado/test/autoreload_test.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tornado/test/autoreload_test.py:100: in run_subprocess
    self.assertEqual(p.returncode, 0)
E   AssertionError: 1 != 0
</pre>
</details>
<h3 id="autoreload_testpyautoreloadtesttest_reload_wrapper_args">autoreload_test.py::AutoreloadTest::test_reload_wrapper_args</h3>
<details><summary> <pre>autoreload_test.py::AutoreloadTest::test_reload_wrapper_args</pre></summary><pre>
self = <tornado.test.autoreload_test.AutoreloadTest testMethod=test_reload_wrapper_args>

        def test_reload_wrapper_args(self):
            main = """\
    import os
    import sys

    print(os.path.basename(sys.argv[0]))
    print(f'argv={sys.argv[1:]}')
    exec(open("run_twice_magic.py").read())
    """
            # Create temporary test application
            self.write_files({"main.py": main})

            # Make sure the tornado module under test is available to the test
            # application
>           out = self.run_subprocess(
                [
                    sys.executable,
                    "-m",
                    "tornado.autoreload",
                    "main.py",
                    "arg1",
                    "--arg2",
                    "-m",
                    "arg3",
                ],
            )

tornado/test/autoreload_test.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tornado/test/autoreload_test.py:100: in run_subprocess
    self.assertEqual(p.returncode, 0)
E   AssertionError: 1 != 0
</pre>
</details>
<h3 id="autoreload_testpyautoreloadtesttest_reload_wrapper_preservation">autoreload_test.py::AutoreloadTest::test_reload_wrapper_preservation</h3>
<details><summary> <pre>autoreload_test.py::AutoreloadTest::test_reload_wrapper_preservation</pre></summary><pre>
self = <tornado.test.autoreload_test.AutoreloadTest testMethod=test_reload_wrapper_preservation>

        def test_reload_wrapper_preservation(self):
            # This test verifies that when `python -m tornado.autoreload`
            # is used on an application that also has an internal
            # autoreload, the reload wrapper is preserved on restart.
            main = """\
    import sys

    # This import will fail if path is not set up correctly
    import testapp

    if 'tornado.autoreload' not in sys.modules:
        raise Exception('started without autoreload wrapper')

    print('Starting')
    exec(open("run_twice_magic.py").read())
    """

            self.write_files(
                {
                    "testapp": {
                        "__init__.py": "",
                        "__main__.py": main,
                    },
                }
            )

>           out = self.run_subprocess(
                [sys.executable, "-m", "tornado.autoreload", "-m", "testapp"]
            )

tornado/test/autoreload_test.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tornado/test/autoreload_test.py:100: in run_subprocess
    self.assertEqual(p.returncode, 0)
E   AssertionError: 1 != 0
</pre>
</details>
<h3 id="autoreload_testpyautoreloadtesttest_reload_wrapper_until_success">autoreload_test.py::AutoreloadTest::test_reload_wrapper_until_success</h3>
<details><summary> <pre>autoreload_test.py::AutoreloadTest::test_reload_wrapper_until_success</pre></summary><pre>
self = <tornado.test.autoreload_test.AutoreloadTest testMethod=test_reload_wrapper_until_success>

        def test_reload_wrapper_until_success(self):
            main = """\
    import os
    import sys

    if "TESTAPP_STARTED" in os.environ:
        print("exiting cleanly")
        sys.exit(0)
    else:
        print("reloading")
        exec(open("run_twice_magic.py").read())
    """

            # Create temporary test application
            self.write_files({"main.py": main})

>           out = self.run_subprocess(
                [sys.executable, "-m", "tornado.autoreload", "--until-success", "main.py"]
            )

tornado/test/autoreload_test.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tornado/test/autoreload_test.py:100: in run_subprocess
    self.assertEqual(p.returncode, 0)
E   AssertionError: 1 != 0
</pre>
</details>
<h3 id="import_testpyimporttesttest_import_aliases">import_test.py::ImportTest::test_import_aliases</h3>
<details><summary> <pre>import_test.py::ImportTest::test_import_aliases</pre></summary><pre>
self = <tornado.test.import_test.ImportTest testMethod=test_import_aliases>

    def test_import_aliases(self):
        # Ensure we don't delete formerly-documented aliases accidentally.
        import tornado
        import asyncio

>       self.assertIs(tornado.ioloop.TimeoutError, tornado.util.TimeoutError)

tornado/test/import_test.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tornado/__init__.py:66: in __getattr__
    return importlib.import_module("." + name, __name__)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1050: in _gcd_import
    ???
<frozen importlib._bootstrap>:1027: in _find_and_load
    ???
<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:688: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:883: in exec_module
    ???
<frozen importlib._bootstrap>:241: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """An I/O event loop for non-blocking sockets.

    In Tornado 6.0, `.IOLoop` is a wrapper around the `asyncio` event loop, with a
    slightly different interface. The `.IOLoop` interface is now provided primarily
    for backwards compatibility; new code should generally use the `asyncio` event
    loop interface directly. The `IOLoop.current` class method provides the
    `IOLoop` instance corresponding to the running `asyncio` event loop.

    """
    import asyncio
    import concurrent.futures
    import datetime
    import functools
    import numbers
    import os
    import sys
    import time
    import math
    import random
    import warnings
    from typing import Optional
    from inspect import isawaitable
>   from tornado.concurrent import Future, is_future, chain_future, future_set_exc_info, future_add_done_callback
E     File "/testbed/tornado/concurrent.py", line 36
E       dummy_executor = DummyExecutor()
E   IndentationError: expected an indented block after 'if' statement on line 33

tornado/ioloop.py:23: IndentationError
</pre>
</details>
<h3 id="import_testpyimporttesttest_import_everything">import_test.py::ImportTest::test_import_everything</h3>
<details><summary> <pre>import_test.py::ImportTest::test_import_everything</pre></summary><pre>
self = <tornado.test.import_test.ImportTest testMethod=test_import_everything>

    def test_import_everything(self):
        # Test that all Tornado modules can be imported without side effects,
        # specifically without initializing the default asyncio event loop.
        # Since we can't tell which modules may have already beein imported
        # in our process, do it in a subprocess for a clean slate.
        proc = subprocess.Popen([sys.executable], stdin=subprocess.PIPE)
        proc.communicate(_import_everything)
>       self.assertEqual(proc.returncode, 0)
E       AssertionError: 1 != 0

tornado/test/import_test.py:50: AssertionError
</pre>
</details>
<h3 id="import_testpyimporttesttest_lazy_import">import_test.py::ImportTest::test_lazy_import</h3>
<details><summary> <pre>import_test.py::ImportTest::test_lazy_import</pre></summary><pre>
self = <tornado.test.import_test.ImportTest testMethod=test_lazy_import>

    def test_lazy_import(self):
        # Test that submodules can be referenced lazily after "import tornado"
        proc = subprocess.Popen([sys.executable], stdin=subprocess.PIPE)
        proc.communicate(_import_lazy)
>       self.assertEqual(proc.returncode, 0)
E       AssertionError: 1 != 0

tornado/test/import_test.py:56: AssertionError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/tornado/auth.py b/tornado/auth.py</span>
<span class="gh">index bbf6ea3c..2db942d1 100644</span>
<span class="gd">--- a/tornado/auth.py</span>
<span class="gi">+++ b/tornado/auth.py</span>
<span class="gu">@@ -102,7 +102,40 @@ class OpenIdMixin(object):</span>
<span class="w"> </span>            longer returns an awaitable object. It is now an ordinary
<span class="w"> </span>            synchronous function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        callback_uri = callback_uri or self.request.uri</span>
<span class="gi">+        args = {</span>
<span class="gi">+            &#39;openid.ns&#39;: &#39;http://specs.openid.net/auth/2.0&#39;,</span>
<span class="gi">+            &#39;openid.claimed_id&#39;: &#39;http://specs.openid.net/auth/2.0/identifier_select&#39;,</span>
<span class="gi">+            &#39;openid.identity&#39;: &#39;http://specs.openid.net/auth/2.0/identifier_select&#39;,</span>
<span class="gi">+            &#39;openid.return_to&#39;: callback_uri,</span>
<span class="gi">+            &#39;openid.realm&#39;: self.request.protocol + &#39;://&#39; + self.request.host + &#39;/&#39;,</span>
<span class="gi">+            &#39;openid.mode&#39;: &#39;checkid_setup&#39;,</span>
<span class="gi">+        }</span>
<span class="gi">+        if ax_attrs:</span>
<span class="gi">+            args.update({</span>
<span class="gi">+                &#39;openid.ns.ax&#39;: &#39;http://openid.net/srv/ax/1.0&#39;,</span>
<span class="gi">+                &#39;openid.ax.mode&#39;: &#39;fetch_request&#39;,</span>
<span class="gi">+            })</span>
<span class="gi">+            ax_attrs = set(ax_attrs)</span>
<span class="gi">+            required = []</span>
<span class="gi">+            if &#39;name&#39; in ax_attrs:</span>
<span class="gi">+                ax_attrs -= set([&#39;name&#39;, &#39;firstname&#39;, &#39;fullname&#39;, &#39;lastname&#39;])</span>
<span class="gi">+                required.extend([&#39;firstname&#39;, &#39;fullname&#39;, &#39;lastname&#39;])</span>
<span class="gi">+                args.update({</span>
<span class="gi">+                    &#39;openid.ax.type.firstname&#39;: &#39;http://axschema.org/namePerson/first&#39;,</span>
<span class="gi">+                    &#39;openid.ax.type.fullname&#39;: &#39;http://axschema.org/namePerson&#39;,</span>
<span class="gi">+                    &#39;openid.ax.type.lastname&#39;: &#39;http://axschema.org/namePerson/last&#39;,</span>
<span class="gi">+                })</span>
<span class="gi">+            known_attrs = {</span>
<span class="gi">+                &#39;email&#39;: &#39;http://axschema.org/contact/email&#39;,</span>
<span class="gi">+                &#39;language&#39;: &#39;http://axschema.org/pref/language&#39;,</span>
<span class="gi">+                &#39;username&#39;: &#39;http://axschema.org/namePerson/friendly&#39;,</span>
<span class="gi">+            }</span>
<span class="gi">+            for name in ax_attrs:</span>
<span class="gi">+                args[&#39;openid.ax.type.&#39; + name] = known_attrs[name]</span>
<span class="gi">+                required.append(name)</span>
<span class="gi">+            args[&#39;openid.ax.required&#39;] = &#39;,&#39;.join(required)</span>
<span class="gi">+        self.redirect(self._OPENID_ENDPOINT + &#39;?&#39; + urllib.parse.urlencode(args))</span>

<span class="w"> </span>    async def get_authenticated_user(self, http_client: Optional[httpclient
<span class="w"> </span>        .AsyncHTTPClient]=None) -&gt;Dict[str, Any]:
<span class="gu">@@ -121,7 +154,14 @@ class OpenIdMixin(object):</span>
<span class="w"> </span>            The ``callback`` argument was removed. Use the returned
<span class="w"> </span>            awaitable object instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Verify the OpenID response via direct request to the OP</span>
<span class="gi">+        args = dict((k, v[-1]) for k, v in self.request.arguments.items())</span>
<span class="gi">+        args[&#39;openid.mode&#39;] = &#39;check_authentication&#39;</span>
<span class="gi">+        url = self._OPENID_ENDPOINT</span>
<span class="gi">+        if http_client is None:</span>
<span class="gi">+            http_client = self.get_auth_http_client()</span>
<span class="gi">+        resp = await http_client.fetch(url, method=&#39;POST&#39;, body=urllib.parse.urlencode(args))</span>
<span class="gi">+        return self._on_authentication_verified(resp)</span>

<span class="w"> </span>    def get_auth_http_client(self) -&gt;httpclient.AsyncHTTPClient:
<span class="w"> </span>        &quot;&quot;&quot;Returns the `.AsyncHTTPClient` instance to be used for auth requests.
<span class="gu">@@ -129,7 +169,7 @@ class OpenIdMixin(object):</span>
<span class="w"> </span>        May be overridden by subclasses to use an HTTP client other than
<span class="w"> </span>        the default.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return httpclient.AsyncHTTPClient()</span>


<span class="w"> </span>class OAuthMixin(object):
<span class="gu">@@ -179,7 +219,44 @@ class OAuthMixin(object):</span>
<span class="w"> </span>           awaitable object instead.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if callback_uri and getattr(self, &#39;_OAUTH_NO_CALLBACKS&#39;, False):</span>
<span class="gi">+            raise Exception(&#39;This service does not support callback_uri&#39;)</span>
<span class="gi">+        http_client = http_client or self.get_auth_http_client()</span>
<span class="gi">+        if getattr(self, &#39;_OAUTH_VERSION&#39;, &#39;1.0a&#39;) == &#39;1.0a&#39;:</span>
<span class="gi">+            response = await http_client.fetch(</span>
<span class="gi">+                self._OAUTH_REQUEST_TOKEN_URL,</span>
<span class="gi">+                auth_username=self._OAUTH_CONSUMER_KEY,</span>
<span class="gi">+                auth_password=self._OAUTH_CONSUMER_SECRET)</span>
<span class="gi">+            request_token = parse_qs_bytes(escape.native_str(response.body))</span>
<span class="gi">+            self.set_secure_cookie(&#39;_oauth_request_token&#39;,</span>
<span class="gi">+                                   request_token[&#39;oauth_token&#39;][0] +</span>
<span class="gi">+                                   b&#39;|&#39; + request_token[&#39;oauth_token_secret&#39;][0])</span>
<span class="gi">+        else:</span>
<span class="gi">+            request_token = {}</span>
<span class="gi">+        args = {</span>
<span class="gi">+            &#39;oauth_consumer_key&#39;: self._OAUTH_CONSUMER_KEY,</span>
<span class="gi">+            &#39;oauth_token&#39;: request_token.get(&#39;oauth_token&#39;, [&#39;&#39;])[0],</span>
<span class="gi">+            &#39;oauth_signature_method&#39;: &#39;HMAC-SHA1&#39;,</span>
<span class="gi">+            &#39;oauth_timestamp&#39;: str(int(time.time())),</span>
<span class="gi">+            &#39;oauth_nonce&#39;: uuid.uuid4().hex,</span>
<span class="gi">+            &#39;oauth_version&#39;: &#39;1.0&#39;,</span>
<span class="gi">+        }</span>
<span class="gi">+        if callback_uri:</span>
<span class="gi">+            args[&#39;oauth_callback&#39;] = callback_uri</span>
<span class="gi">+        if extra_params:</span>
<span class="gi">+            args.update(extra_params)</span>
<span class="gi">+        if getattr(self, &#39;_OAUTH_VERSION&#39;, &#39;1.0a&#39;) == &#39;1.0a&#39;:</span>
<span class="gi">+            signature = _oauth10a_signature(</span>
<span class="gi">+                self._OAUTH_CONSUMER_SECRET,</span>
<span class="gi">+                &#39;GET&#39;, self._OAUTH_AUTHORIZE_URL, args,</span>
<span class="gi">+                request_token.get(&#39;oauth_token_secret&#39;, [&#39;&#39;])[0])</span>
<span class="gi">+        else:</span>
<span class="gi">+            signature = _oauth_signature(</span>
<span class="gi">+                self._OAUTH_CONSUMER_SECRET,</span>
<span class="gi">+                &#39;GET&#39;, self._OAUTH_AUTHORIZE_URL, args)</span>
<span class="gi">+        args[&#39;oauth_signature&#39;] = signature</span>
<span class="gi">+        url = self._OAUTH_AUTHORIZE_URL + &#39;?&#39; + urllib.parse.urlencode(args)</span>
<span class="gi">+        self.redirect(url)</span>

<span class="w"> </span>    async def get_authenticated_user(self, http_client: Optional[httpclient
<span class="w"> </span>        .AsyncHTTPClient]=None) -&gt;Dict[str, Any]:
<span class="gu">@@ -198,14 +275,31 @@ class OAuthMixin(object):</span>
<span class="w"> </span>           The ``callback`` argument was removed. Use the returned
<span class="w"> </span>           awaitable object instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        request_key = self.get_argument(&#39;oauth_token&#39;)</span>
<span class="gi">+        oauth_verifier = self.get_argument(&#39;oauth_verifier&#39;, None)</span>
<span class="gi">+        request_cookie = self.get_secure_cookie(&#39;_oauth_request_token&#39;)</span>
<span class="gi">+        if not request_cookie:</span>
<span class="gi">+            raise AuthError(&#39;Missing OAuth request token cookie&#39;)</span>
<span class="gi">+        request_token, request_secret = request_cookie.split(b&#39;|&#39;)</span>
<span class="gi">+        if request_token != request_key:</span>
<span class="gi">+            raise AuthError(&#39;Request token does not match&#39;)</span>
<span class="gi">+        http_client = http_client or self.get_auth_http_client()</span>
<span class="gi">+        access_token = await self._oauth_get_access_token(http_client,</span>
<span class="gi">+                                                          request_token,</span>
<span class="gi">+                                                          request_secret,</span>
<span class="gi">+                                                          oauth_verifier)</span>
<span class="gi">+        user = await self._oauth_get_user(access_token, http_client)</span>
<span class="gi">+        if not user:</span>
<span class="gi">+            raise AuthError(&#39;Error getting user&#39;)</span>
<span class="gi">+        user.update(access_token)</span>
<span class="gi">+        return user</span>

<span class="w"> </span>    def _oauth_consumer_token(self) -&gt;Dict[str, Any]:
<span class="w"> </span>        &quot;&quot;&quot;Subclasses must override this to return their OAuth consumer keys.

<span class="w"> </span>        The return value should be a `dict` with keys ``key`` and ``secret``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    async def _oauth_get_user_future(self, access_token: Dict[str, Any]
<span class="w"> </span>        ) -&gt;Dict[str, Any]:
<span class="gu">@@ -238,7 +332,30 @@ class OAuthMixin(object):</span>
<span class="w"> </span>        parameters should include all POST arguments and query string arguments
<span class="w"> </span>        that will be sent with the request.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        consumer_token = self._oauth_consumer_token()</span>
<span class="gi">+        base_args = dict(</span>
<span class="gi">+            oauth_consumer_key=consumer_token[&#39;key&#39;],</span>
<span class="gi">+            oauth_token=access_token[&#39;key&#39;],</span>
<span class="gi">+            oauth_signature_method=&#39;HMAC-SHA1&#39;,</span>
<span class="gi">+            oauth_timestamp=str(int(time.time())),</span>
<span class="gi">+            oauth_nonce=uuid.uuid4().hex,</span>
<span class="gi">+            oauth_version=&#39;1.0&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+        args = {}</span>
<span class="gi">+        args.update(base_args)</span>
<span class="gi">+        args.update(parameters)</span>
<span class="gi">+        if getattr(self, &#39;_OAUTH_VERSION&#39;, &#39;1.0a&#39;) == &#39;1.0a&#39;:</span>
<span class="gi">+            signature = _oauth10a_signature(</span>
<span class="gi">+                consumer_token[&#39;secret&#39;],</span>
<span class="gi">+                method, url, args,</span>
<span class="gi">+                access_token[&#39;secret&#39;])</span>
<span class="gi">+        else:</span>
<span class="gi">+            signature = _oauth_signature(</span>
<span class="gi">+                consumer_token[&#39;secret&#39;],</span>
<span class="gi">+                method, url, args,</span>
<span class="gi">+                access_token.get(&#39;secret&#39;))</span>
<span class="gi">+        base_args[&#39;oauth_signature&#39;] = signature</span>
<span class="gi">+        return base_args</span>

<span class="w"> </span>    def get_auth_http_client(self) -&gt;httpclient.AsyncHTTPClient:
<span class="w"> </span>        &quot;&quot;&quot;Returns the `.AsyncHTTPClient` instance to be used for auth requests.
<span class="gu">@@ -246,7 +363,7 @@ class OAuthMixin(object):</span>
<span class="w"> </span>        May be overridden by subclasses to use an HTTP client other than
<span class="w"> </span>        the default.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return httpclient.AsyncHTTPClient()</span>


<span class="w"> </span>class OAuth2Mixin(object):
<span class="gu">@@ -282,7 +399,17 @@ class OAuth2Mixin(object):</span>
<span class="w"> </span>           The ``client_secret`` argument (which has never had any effect)
<span class="w"> </span>           is deprecated and will be removed in Tornado 7.0.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        args = {</span>
<span class="gi">+            &#39;redirect_uri&#39;: redirect_uri,</span>
<span class="gi">+            &#39;client_id&#39;: client_id or self.settings[&#39;oauth&#39;][&#39;key&#39;],</span>
<span class="gi">+            &#39;response_type&#39;: response_type,</span>
<span class="gi">+        }</span>
<span class="gi">+        if scope:</span>
<span class="gi">+            args[&#39;scope&#39;] = &#39; &#39;.join(scope)</span>
<span class="gi">+        if extra_params:</span>
<span class="gi">+            args.update(extra_params)</span>
<span class="gi">+        url = self._OAUTH_AUTHORIZE_URL + &#39;?&#39; + urllib.parse.urlencode(args)</span>
<span class="gi">+        self.redirect(url)</span>

<span class="w"> </span>    async def oauth2_request(self, url: str, access_token: Optional[str]=
<span class="w"> </span>        None, post_args: Optional[Dict[str, Any]]=None, **args: Any) -&gt;Any:
<span class="gu">@@ -319,7 +446,19 @@ class OAuth2Mixin(object):</span>

<span class="w"> </span>           The ``callback`` argument was removed. Use the returned awaitable object instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        all_args = {}</span>
<span class="gi">+        if access_token:</span>
<span class="gi">+            all_args[&#39;access_token&#39;] = access_token</span>
<span class="gi">+            all_args.update(args)</span>
<span class="gi">+</span>
<span class="gi">+        if all_args:</span>
<span class="gi">+            url += &#39;?&#39; + urllib.parse.urlencode(all_args)</span>
<span class="gi">+        http = self.get_auth_http_client()</span>
<span class="gi">+        if post_args is not None:</span>
<span class="gi">+            response = await http.fetch(url, method=&#39;POST&#39;, body=urllib.parse.urlencode(post_args))</span>
<span class="gi">+        else:</span>
<span class="gi">+            response = await http.fetch(url)</span>
<span class="gi">+        return escape.json_decode(response.body)</span>

<span class="w"> </span>    def get_auth_http_client(self) -&gt;httpclient.AsyncHTTPClient:
<span class="w"> </span>        &quot;&quot;&quot;Returns the `.AsyncHTTPClient` instance to be used for auth requests.
<span class="gu">@@ -329,7 +468,7 @@ class OAuth2Mixin(object):</span>

<span class="w"> </span>        .. versionadded:: 4.3
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return httpclient.AsyncHTTPClient()</span>


<span class="w"> </span>class TwitterMixin(OAuthMixin):
<span class="gu">@@ -394,7 +533,13 @@ class TwitterMixin(OAuthMixin):</span>
<span class="w"> </span>           The ``callback`` argument was removed. Use the returned
<span class="w"> </span>           awaitable object instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        http = self.get_auth_http_client()</span>
<span class="gi">+        response = await http.fetch(self._OAUTH_REQUEST_TOKEN_URL)</span>
<span class="gi">+        request_token = parse_qs_bytes(escape.native_str(response.body))</span>
<span class="gi">+        authorize_url = self._OAUTH_AUTHENTICATE_URL + &#39;?&#39; + urllib.parse.urlencode({</span>
<span class="gi">+            &#39;oauth_token&#39;: request_token[b&#39;oauth_token&#39;][0],</span>
<span class="gi">+        })</span>
<span class="gi">+        self.redirect(authorize_url)</span>

<span class="w"> </span>    async def twitter_request(self, path: str, access_token: Dict[str, Any],
<span class="w"> </span>        post_args: Optional[Dict[str, Any]]=None, **args: Any) -&gt;Any:
<span class="gu">@@ -439,7 +584,28 @@ class TwitterMixin(OAuthMixin):</span>
<span class="w"> </span>           The ``callback`` argument was removed. Use the returned
<span class="w"> </span>           awaitable object instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = self._TWITTER_BASE_URL + path + &quot;.json&quot;</span>
<span class="gi">+        all_args = {}</span>
<span class="gi">+        all_args.update(args)</span>
<span class="gi">+        all_args.update(post_args or {})</span>
<span class="gi">+        method = &quot;POST&quot; if post_args is not None else &quot;GET&quot;</span>
<span class="gi">+        oauth = self._oauth_request_parameters(</span>
<span class="gi">+            url, access_token, all_args, method=method)</span>
<span class="gi">+        headers = {</span>
<span class="gi">+            &quot;Authorization&quot;: &quot;OAuth &quot; + &quot;,&quot;.join(</span>
<span class="gi">+                &#39;%s=&quot;%s&quot;&#39; % (k, escape.url_escape(v))</span>
<span class="gi">+                for k, v in sorted(oauth.items())</span>
<span class="gi">+            )</span>
<span class="gi">+        }</span>
<span class="gi">+        http = self.get_auth_http_client()</span>
<span class="gi">+        if post_args is not None:</span>
<span class="gi">+            response = await http.fetch(url, method=&quot;POST&quot;, headers=headers,</span>
<span class="gi">+                                        body=urllib.parse.urlencode(all_args))</span>
<span class="gi">+        else:</span>
<span class="gi">+            if all_args:</span>
<span class="gi">+                url += &quot;?&quot; + urllib.parse.urlencode(all_args)</span>
<span class="gi">+            response = await http.fetch(url, headers=headers)</span>
<span class="gi">+        return escape.json_decode(response.body)</span>


<span class="w"> </span>class GoogleOAuth2Mixin(OAuth2Mixin):
<span class="gu">@@ -484,7 +650,7 @@ class GoogleOAuth2Mixin(OAuth2Mixin):</span>
<span class="w"> </span>        If your credentials are stored differently (e.g. in a db) you can
<span class="w"> </span>        override this method for custom provision.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.settings[self._OAUTH_SETTINGS_KEY]</span>

<span class="w"> </span>    async def get_authenticated_user(self, redirect_uri: str, code: str,
<span class="w"> </span>        client_id: Optional[str]=None, client_secret: Optional[str]=None
<span class="gu">@@ -542,7 +708,22 @@ class GoogleOAuth2Mixin(OAuth2Mixin):</span>

<span class="w"> </span>           The ``callback`` argument was removed. Use the returned awaitable object instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        http = self.get_auth_http_client()</span>
<span class="gi">+        body = urllib.parse.urlencode({</span>
<span class="gi">+            &quot;redirect_uri&quot;: redirect_uri,</span>
<span class="gi">+            &quot;code&quot;: code,</span>
<span class="gi">+            &quot;client_id&quot;: client_id or self.get_google_oauth_settings()[&#39;key&#39;],</span>
<span class="gi">+            &quot;client_secret&quot;: client_secret or self.get_google_oauth_settings()[&#39;secret&#39;],</span>
<span class="gi">+            &quot;grant_type&quot;: &quot;authorization_code&quot;,</span>
<span class="gi">+        })</span>
<span class="gi">+</span>
<span class="gi">+        response = await http.fetch(</span>
<span class="gi">+            self._OAUTH_ACCESS_TOKEN_URL,</span>
<span class="gi">+            method=&quot;POST&quot;,</span>
<span class="gi">+            headers={&#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;},</span>
<span class="gi">+            body=body)</span>
<span class="gi">+</span>
<span class="gi">+        return escape.json_decode(response.body)</span>


<span class="w"> </span>class FacebookGraphMixin(OAuth2Mixin):
<span class="gu">@@ -603,7 +784,44 @@ class FacebookGraphMixin(OAuth2Mixin):</span>

<span class="w"> </span>           The ``callback`` argument was removed. Use the returned awaitable object instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        http = self.get_auth_http_client()</span>
<span class="gi">+        args = {</span>
<span class="gi">+            &quot;redirect_uri&quot;: redirect_uri,</span>
<span class="gi">+            &quot;code&quot;: code,</span>
<span class="gi">+            &quot;client_id&quot;: client_id,</span>
<span class="gi">+            &quot;client_secret&quot;: client_secret,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        response = await http.fetch(</span>
<span class="gi">+            self._OAUTH_ACCESS_TOKEN_URL + &quot;?&quot; + urllib.parse.urlencode(args)</span>
<span class="gi">+        )</span>
<span class="gi">+        args = escape.json_decode(response.body)</span>
<span class="gi">+        session = {</span>
<span class="gi">+            &quot;access_token&quot;: args[&quot;access_token&quot;],</span>
<span class="gi">+            &quot;expires_in&quot;: args.get(&quot;expires_in&quot;),</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        user = await self.facebook_request(</span>
<span class="gi">+            path=&quot;/me&quot;,</span>
<span class="gi">+            access_token=session[&quot;access_token&quot;],</span>
<span class="gi">+            appsecret_proof=hmac.new(</span>
<span class="gi">+                key=client_secret.encode(&#39;utf8&#39;),</span>
<span class="gi">+                msg=session[&quot;access_token&quot;].encode(&#39;utf8&#39;),</span>
<span class="gi">+                digestmod=hashlib.sha256</span>
<span class="gi">+            ).hexdigest(),</span>
<span class="gi">+            fields=extra_fields</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if user is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        fieldmap = {}</span>
<span class="gi">+        for field in [&#39;id&#39;, &#39;name&#39;, &#39;first_name&#39;, &#39;last_name&#39;,</span>
<span class="gi">+                      &#39;locale&#39;, &#39;picture&#39;, &#39;link&#39;]:</span>
<span class="gi">+            fieldmap[field] = user.get(field)</span>
<span class="gi">+</span>
<span class="gi">+        fieldmap.update(session)</span>
<span class="gi">+        return fieldmap</span>

<span class="w"> </span>    async def facebook_request(self, path: str, access_token: Optional[str]
<span class="w"> </span>        =None, post_args: Optional[Dict[str, Any]]=None, **args: Any) -&gt;Any:
<span class="gu">@@ -657,7 +875,20 @@ class FacebookGraphMixin(OAuth2Mixin):</span>

<span class="w"> </span>           The ``callback`` argument was removed. Use the returned awaitable object instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = self._FACEBOOK_BASE_URL + path</span>
<span class="gi">+        all_args = {}</span>
<span class="gi">+        if access_token:</span>
<span class="gi">+            all_args[&quot;access_token&quot;] = access_token</span>
<span class="gi">+            all_args.update(args)</span>
<span class="gi">+</span>
<span class="gi">+        if all_args:</span>
<span class="gi">+            url += &quot;?&quot; + urllib.parse.urlencode(all_args)</span>
<span class="gi">+        http = self.get_auth_http_client()</span>
<span class="gi">+        if post_args is not None:</span>
<span class="gi">+            response = await http.fetch(url, method=&quot;POST&quot;, body=urllib.parse.urlencode(post_args))</span>
<span class="gi">+        else:</span>
<span class="gi">+            response = await http.fetch(url)</span>
<span class="gi">+        return escape.json_decode(response.body)</span>


<span class="w"> </span>def _oauth_signature(consumer_token: Dict[str, Any], method: str, url: str,
<span class="gu">@@ -667,7 +898,23 @@ def _oauth_signature(consumer_token: Dict[str, Any], method: str, url: str,</span>

<span class="w"> </span>    See http://oauth.net/core/1.0/#signing_process
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = urllib.parse.urlparse(url)</span>
<span class="gi">+    scheme, netloc, path = parts[:3]</span>
<span class="gi">+    normalized_url = scheme.lower() + &quot;://&quot; + netloc.lower() + path</span>
<span class="gi">+</span>
<span class="gi">+    base_elems = []</span>
<span class="gi">+    base_elems.append(method.upper())</span>
<span class="gi">+    base_elems.append(normalized_url)</span>
<span class="gi">+    base_elems.append(&quot;&amp;&quot;.join(&quot;%s=%s&quot; % (k, _oauth_escape(str(v)))</span>
<span class="gi">+                               for k, v in sorted(parameters.items())))</span>
<span class="gi">+    base_string = &quot;&amp;&quot;.join(_oauth_escape(e) for e in base_elems)</span>
<span class="gi">+</span>
<span class="gi">+    key_elems = [escape.utf8(consumer_token[&quot;secret&quot;])]</span>
<span class="gi">+    key_elems.append(escape.utf8(token[&quot;secret&quot;] if token else &quot;&quot;))</span>
<span class="gi">+    key = b&quot;&amp;&quot;.join(key_elems)</span>
<span class="gi">+</span>
<span class="gi">+    hash = hmac.new(key, escape.utf8(base_string), hashlib.sha1)</span>
<span class="gi">+    return binascii.b2a_base64(hash.digest())[:-1]</span>


<span class="w"> </span>def _oauth10a_signature(consumer_token: Dict[str, Any], method: str, url:
<span class="gu">@@ -677,4 +924,20 @@ def _oauth10a_signature(consumer_token: Dict[str, Any], method: str, url:</span>

<span class="w"> </span>    See http://oauth.net/core/1.0a/#signing_process
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = urllib.parse.urlparse(url)</span>
<span class="gi">+    scheme, netloc, path = parts[:3]</span>
<span class="gi">+    normalized_url = scheme.lower() + &quot;://&quot; + netloc.lower() + path</span>
<span class="gi">+</span>
<span class="gi">+    base_elems = []</span>
<span class="gi">+    base_elems.append(method.upper())</span>
<span class="gi">+    base_elems.append(normalized_url)</span>
<span class="gi">+    base_elems.append(&quot;&amp;&quot;.join(&quot;%s=%s&quot; % (k, _oauth_escape(str(v)))</span>
<span class="gi">+                               for k, v in sorted(parameters.items())))</span>
<span class="gi">+    base_string = &quot;&amp;&quot;.join(_oauth_escape(e) for e in base_elems)</span>
<span class="gi">+</span>
<span class="gi">+    key_elems = [escape.utf8(consumer_token[&quot;secret&quot;])]</span>
<span class="gi">+    key_elems.append(escape.utf8(token[&quot;secret&quot;] if token else &quot;&quot;))</span>
<span class="gi">+    key = b&quot;&amp;&quot;.join(key_elems)</span>
<span class="gi">+</span>
<span class="gi">+    hash = hmac.new(key, escape.utf8(base_string), hashlib.sha1)</span>
<span class="gi">+    return binascii.b2a_base64(hash.digest())[:-1]</span>
<span class="gh">diff --git a/tornado/autoreload.py b/tornado/autoreload.py</span>
<span class="gh">index 05cda05c..2a2ff1d0 100644</span>
<span class="gd">--- a/tornado/autoreload.py</span>
<span class="gi">+++ b/tornado/autoreload.py</span>
<span class="gu">@@ -66,7 +66,16 @@ def start(check_time: int=500) -&gt;None:</span>
<span class="w"> </span>    .. versionchanged:: 5.0
<span class="w"> </span>       The ``io_loop`` argument (deprecated since version 4.1) has been removed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    io_loop = ioloop.IOLoop.current()</span>
<span class="gi">+    if io_loop in _io_loops:</span>
<span class="gi">+        return</span>
<span class="gi">+    _io_loops[io_loop] = True</span>
<span class="gi">+    if len(_io_loops) &gt; 1:</span>
<span class="gi">+        gen_log.warning(&quot;tornado.autoreload started more than once in the same process&quot;)</span>
<span class="gi">+    modify_times = {}</span>
<span class="gi">+    callback = functools.partial(_reload_on_update, modify_times)</span>
<span class="gi">+    scheduler = ioloop.PeriodicCallback(callback, check_time)</span>
<span class="gi">+    scheduler.start()</span>


<span class="w"> </span>def wait() -&gt;None:
<span class="gu">@@ -76,7 +85,8 @@ def wait() -&gt;None:</span>
<span class="w"> </span>    to run the tests again after any source file changes (but see also
<span class="w"> </span>    the command-line interface in `main`)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    io_loop = ioloop.IOLoop.current()</span>
<span class="gi">+    io_loop.start()</span>


<span class="w"> </span>def watch(filename: str) -&gt;None:
<span class="gu">@@ -84,7 +94,7 @@ def watch(filename: str) -&gt;None:</span>

<span class="w"> </span>    All imported modules are watched by default.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _watched_files.add(os.path.abspath(filename))</span>


<span class="w"> </span>def add_reload_hook(fn: Callable[[], None]) -&gt;None:
<span class="gu">@@ -94,7 +104,7 @@ def add_reload_hook(fn: Callable[[], None]) -&gt;None:</span>
<span class="w"> </span>    preferable to set the ``FD_CLOEXEC`` flag (using `fcntl` or
<span class="w"> </span>    `os.set_inheritable`) instead of using a reload hook to close them.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _reload_hooks.append(fn)</span>


<span class="w"> </span>_USAGE = &quot;&quot;&quot;
<span class="gu">@@ -116,7 +126,60 @@ def main() -&gt;None:</span>
<span class="w"> </span>    can catch import-time problems like syntax errors that would otherwise
<span class="w"> </span>    prevent the script from reaching its call to `wait`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _autoreload_is_main, _original_argv, _original_spec</span>
<span class="gi">+    _autoreload_is_main = True</span>
<span class="gi">+    _original_argv = sys.argv</span>
<span class="gi">+    _original_spec = getattr(sys.modules[&#39;__main__&#39;], &#39;__spec__&#39;, None)</span>
<span class="gi">+    </span>
<span class="gi">+    if len(sys.argv) &gt;= 3 and sys.argv[1] == &quot;-m&quot;:</span>
<span class="gi">+        mode = &quot;module&quot;</span>
<span class="gi">+        module = sys.argv[2]</span>
<span class="gi">+        del sys.argv[1:3]</span>
<span class="gi">+    elif len(sys.argv) &gt;= 2:</span>
<span class="gi">+        mode = &quot;script&quot;</span>
<span class="gi">+        script = sys.argv[1]</span>
<span class="gi">+        sys.argv = sys.argv[1:]</span>
<span class="gi">+    else:</span>
<span class="gi">+        print(_USAGE, file=sys.stderr)</span>
<span class="gi">+        sys.exit(1)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        if mode == &quot;module&quot;:</span>
<span class="gi">+            import runpy</span>
<span class="gi">+            runpy.run_module(module, run_name=&quot;__main__&quot;, alter_sys=True)</span>
<span class="gi">+        elif mode == &quot;script&quot;:</span>
<span class="gi">+            with open(script) as f:</span>
<span class="gi">+                global __file__</span>
<span class="gi">+                __file__ = script</span>
<span class="gi">+                # Use globals as our &quot;locals&quot; dictionary so that</span>
<span class="gi">+                # something that tries to import __main__ (e.g. the unittest</span>
<span class="gi">+                # module) will see the right things.</span>
<span class="gi">+                exec(f.read(), globals(), globals())</span>
<span class="gi">+    except SystemExit as e:</span>
<span class="gi">+        gen_log.info(&quot;Script exited with status %s&quot;, e.code)</span>
<span class="gi">+    except Exception as e:</span>
<span class="gi">+        gen_log.warning(&quot;Script exited with uncaught exception&quot;, exc_info=True)</span>
<span class="gi">+        # If an exception occurred at import time, the file with the error</span>
<span class="gi">+        # never made it into sys.modules and so we won&#39;t know to watch it.</span>
<span class="gi">+        # Just to make sure we&#39;ve covered everything, walk the stack trace</span>
<span class="gi">+        # and watch every file.</span>
<span class="gi">+        for (filename, lineno, name, line) in traceback.extract_tb(sys.exc_info()[2]):</span>
<span class="gi">+            watch(filename)</span>
<span class="gi">+        if isinstance(e, SyntaxError):</span>
<span class="gi">+            # SyntaxErrors are special:  their innermost stack frame is fake</span>
<span class="gi">+            # so extract_tb won&#39;t see it and we have to get the filename</span>
<span class="gi">+            # from the exception object.</span>
<span class="gi">+            watch(e.filename)</span>
<span class="gi">+    else:</span>
<span class="gi">+        gen_log.info(&quot;Script exited normally&quot;)</span>
<span class="gi">+    # restore sys.argv so subsequent executions will include autoreload</span>
<span class="gi">+    sys.argv = _original_argv</span>
<span class="gi">+</span>
<span class="gi">+    if mode == &#39;module&#39;:</span>
<span class="gi">+        # runpy did a fake import of the module as __main__, but now it&#39;s</span>
<span class="gi">+        # no longer in sys.modules.  Figure out where it is and watch it.</span>
<span class="gi">+        watch(runpy._get_module_details(module)[0])</span>
<span class="gi">+    wait()</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/tornado/concurrent.py b/tornado/concurrent.py</span>
<span class="gh">index 16b042a9..4b677490 100644</span>
<span class="gd">--- a/tornado/concurrent.py</span>
<span class="gi">+++ b/tornado/concurrent.py</span>
<span class="gu">@@ -76,7 +76,18 @@ def run_on_executor(*args: Any, **kwargs: Any) -&gt;Callable:</span>

<span class="w"> </span>       The ``callback`` argument was removed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def run_on_executor_decorator(func: Callable) -&gt;Callable:</span>
<span class="gi">+        @functools.wraps(func)</span>
<span class="gi">+        async def wrapper(self, *args, **kwargs):</span>
<span class="gi">+            executor = getattr(self, kwargs.pop(&#39;executor&#39;, &#39;executor&#39;))</span>
<span class="gi">+            return await asyncio.get_event_loop().run_in_executor(</span>
<span class="gi">+                executor, functools.partial(func, self, *args, **kwargs))</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+</span>
<span class="gi">+    if len(args) == 1 and callable(args[0]):</span>
<span class="gi">+        return run_on_executor_decorator(args[0])</span>
<span class="gi">+    else:</span>
<span class="gi">+        return run_on_executor_decorator</span>


<span class="w"> </span>_NO_RESULT = object()
<span class="gu">@@ -94,7 +105,18 @@ def chain_future(a: &#39;Future[_T]&#39;, b: &#39;Future[_T]&#39;) -&gt;None:</span>
<span class="w"> </span>       `concurrent.futures.Future`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def copy_result(future):</span>
<span class="gi">+        if b.done():</span>
<span class="gi">+            return</span>
<span class="gi">+        if future.exception() is not None:</span>
<span class="gi">+            b.set_exception(future.exception())</span>
<span class="gi">+        else:</span>
<span class="gi">+            b.set_result(future.result())</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(a, Future):</span>
<span class="gi">+        future_add_done_callback(a, copy_result)</span>
<span class="gi">+    else:</span>
<span class="gi">+        a.add_done_callback(copy_result)</span>


<span class="w"> </span>def future_set_result_unless_cancelled(future:
<span class="gu">@@ -106,7 +128,8 @@ def future_set_result_unless_cancelled(future:</span>

<span class="w"> </span>    .. versionadded:: 5.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not future.cancelled():</span>
<span class="gi">+        future.set_result(value)</span>


<span class="w"> </span>def future_set_exception_unless_cancelled(future:
<span class="gu">@@ -124,7 +147,10 @@ def future_set_exception_unless_cancelled(future:</span>
<span class="w"> </span>    .. versionadded:: 6.0

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if future.cancelled():</span>
<span class="gi">+        app_log.error(&quot;Exception after Future was cancelled&quot;, exc_info=exc)</span>
<span class="gi">+    else:</span>
<span class="gi">+        future.set_exception(exc)</span>


<span class="w"> </span>def future_set_exc_info(future: &#39;Union[futures.Future[_T], Future[_T]]&#39;,
<span class="gu">@@ -143,7 +169,13 @@ def future_set_exc_info(future: &#39;Union[futures.Future[_T], Future[_T]]&#39;,</span>
<span class="w"> </span>       (previously ``asyncio.InvalidStateError`` would be raised)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not future.cancelled():</span>
<span class="gi">+        if hasattr(future, &#39;set_exc_info&#39;):</span>
<span class="gi">+            # Tornado&#39;s Future</span>
<span class="gi">+            future.set_exc_info(exc_info)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # asyncio Future</span>
<span class="gi">+            future.set_exception(exc_info[1])</span>


<span class="w"> </span>def future_add_done_callback(future:
<span class="gu">@@ -159,4 +191,7 @@ def future_add_done_callback(future:</span>

<span class="w"> </span>    .. versionadded:: 5.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if future.done():</span>
<span class="gi">+        callback(future)</span>
<span class="gi">+    else:</span>
<span class="gi">+        future.add_done_callback(callback)</span>
<span class="gh">diff --git a/tornado/curl_httpclient.py b/tornado/curl_httpclient.py</span>
<span class="gh">index 548b9c4d..8e6ea8f4 100644</span>
<span class="gd">--- a/tornado/curl_httpclient.py</span>
<span class="gi">+++ b/tornado/curl_httpclient.py</span>
<span class="gu">@@ -27,33 +27,67 @@ class CurlAsyncHTTPClient(AsyncHTTPClient):</span>
<span class="w"> </span>        &quot;&quot;&quot;Called by libcurl when it wants to change the file descriptors
<span class="w"> </span>        it cares about.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if event == pycurl.POLL_NONE:</span>
<span class="gi">+            self.io_loop.remove_handler(fd)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if event == pycurl.POLL_IN:</span>
<span class="gi">+                self.io_loop.add_handler(fd, self._handle_events, self.io_loop.READ)</span>
<span class="gi">+            elif event == pycurl.POLL_OUT:</span>
<span class="gi">+                self.io_loop.add_handler(fd, self._handle_events, self.io_loop.WRITE)</span>
<span class="gi">+            elif event == pycurl.POLL_INOUT:</span>
<span class="gi">+                self.io_loop.add_handler(fd, self._handle_events, self.io_loop.READ | self.io_loop.WRITE)</span>

<span class="w"> </span>    def _set_timeout(self, msecs: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Called by libcurl to schedule a timeout.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._timeout is not None:</span>
<span class="gi">+            self.io_loop.remove_timeout(self._timeout)</span>
<span class="gi">+        self._timeout = self.io_loop.add_timeout(</span>
<span class="gi">+            self.io_loop.time() + msecs / 1000.0, self._handle_timeout)</span>

<span class="w"> </span>    def _handle_events(self, fd: int, events: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Called by IOLoop when there is activity on one of our
<span class="w"> </span>        file descriptors.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        action = 0</span>
<span class="gi">+        if events &amp; self.io_loop.READ:</span>
<span class="gi">+            action |= pycurl.CSELECT_IN</span>
<span class="gi">+        if events &amp; self.io_loop.WRITE:</span>
<span class="gi">+            action |= pycurl.CSELECT_OUT</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                ret, num_handles = self._multi.socket_action(fd, action)</span>
<span class="gi">+            except pycurl.error as e:</span>
<span class="gi">+                ret = e.args[0]</span>
<span class="gi">+            if ret != pycurl.E_CALL_MULTI_PERFORM:</span>
<span class="gi">+                break</span>
<span class="gi">+        self._finish_pending_requests()</span>

<span class="w"> </span>    def _handle_timeout(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Called by IOLoop when the requested timeout has passed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.exception_logging():</span>
<span class="gi">+            ret, num_handles = self._multi.socket_action(pycurl.SOCKET_TIMEOUT, 0)</span>
<span class="gi">+        self._finish_pending_requests()</span>

<span class="w"> </span>    def _handle_force_timeout(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Called by IOLoop periodically to ask libcurl to process any
<span class="w"> </span>        events it may have forgotten about.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.exception_logging():</span>
<span class="gi">+            ret, num_handles = self._multi.socket_action(pycurl.SOCKET_TIMEOUT, 0)</span>
<span class="gi">+        self._finish_pending_requests()</span>

<span class="w"> </span>    def _finish_pending_requests(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Process any requests that were completed by the last
<span class="w"> </span>        call to multi.socket_action.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while True:</span>
<span class="gi">+            num_q, ok_list, err_list = self._multi.info_read()</span>
<span class="gi">+            for curl in ok_list:</span>
<span class="gi">+                self._finish_curl(curl)</span>
<span class="gi">+            for curl, errnum, errmsg in err_list:</span>
<span class="gi">+                self._finish_curl(curl, errnum, errmsg)</span>
<span class="gi">+            if num_q == 0:</span>
<span class="gi">+                break</span>


<span class="w"> </span>class CurlError(HTTPError):
<span class="gh">diff --git a/tornado/escape.py b/tornado/escape.py</span>
<span class="gh">index 15f61dbe..5de69866 100644</span>
<span class="gd">--- a/tornado/escape.py</span>
<span class="gi">+++ b/tornado/escape.py</span>
<span class="gu">@@ -38,7 +38,9 @@ def xhtml_escape(value: Union[str, bytes]) -&gt;str:</span>
<span class="w"> </span>       except that single quotes are now escaped as ``&amp;#x27;`` instead of
<span class="w"> </span>       ``&amp;#39;`` and performance may be different.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, bytes):</span>
<span class="gi">+        value = value.decode(&#39;utf-8&#39;)</span>
<span class="gi">+    return html.escape(value)</span>


<span class="w"> </span>def xhtml_unescape(value: Union[str, bytes]) -&gt;str:
<span class="gu">@@ -56,7 +58,9 @@ def xhtml_unescape(value: Union[str, bytes]) -&gt;str:</span>
<span class="w"> </span>       Some invalid inputs such as surrogates now raise an error, and numeric
<span class="w"> </span>       references to certain ISO-8859-1 characters are now handled correctly.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, bytes):</span>
<span class="gi">+        value = value.decode(&#39;utf-8&#39;)</span>
<span class="gi">+    return html.unescape(value)</span>


<span class="w"> </span>def json_encode(value: Any) -&gt;str:
<span class="gu">@@ -66,7 +70,7 @@ def json_encode(value: Any) -&gt;str:</span>
<span class="w"> </span>    will never contain the character sequence ``&lt;/`` which can be problematic
<span class="w"> </span>    when JSON is embedded in an HTML ``&lt;script&gt;`` tag.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return json.dumps(value).replace(&quot;&lt;/&quot;, &quot;&lt;\\/&quot;)</span>


<span class="w"> </span>def json_decode(value: Union[str, bytes]) -&gt;Any:
<span class="gu">@@ -74,12 +78,14 @@ def json_decode(value: Union[str, bytes]) -&gt;Any:</span>

<span class="w"> </span>    Supports both `str` and `bytes` inputs. Equvalent to `json.loads`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, bytes):</span>
<span class="gi">+        value = value.decode(&#39;utf-8&#39;)</span>
<span class="gi">+    return json.loads(value)</span>


<span class="w"> </span>def squeeze(value: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Replace all sequences of whitespace chars with a single space.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &#39; &#39;.join(value.split())</span>


<span class="w"> </span>def url_escape(value: Union[str, bytes], plus: bool=True) -&gt;str:
<span class="gu">@@ -97,7 +103,12 @@ def url_escape(value: Union[str, bytes], plus: bool=True) -&gt;str:</span>
<span class="w"> </span>    .. versionadded:: 3.1
<span class="w"> </span>        The ``plus`` argument
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, bytes):</span>
<span class="gi">+        value = value.decode(&#39;utf-8&#39;)</span>
<span class="gi">+    if plus:</span>
<span class="gi">+        return urllib.parse.quote_plus(value)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return urllib.parse.quote(value)</span>


<span class="w"> </span>def url_unescape(value: Union[str, bytes], encoding: Optional[str]=&#39;utf-8&#39;,
<span class="gu">@@ -119,7 +130,17 @@ def url_unescape(value: Union[str, bytes], encoding: Optional[str]=&#39;utf-8&#39;,</span>
<span class="w"> </span>    .. versionadded:: 3.1
<span class="w"> </span>       The ``plus`` argument
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if encoding is None:</span>
<span class="gi">+        if isinstance(value, str):</span>
<span class="gi">+            value = value.encode(&#39;utf-8&#39;)</span>
<span class="gi">+        return urllib.parse.unquote_to_bytes(value)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if isinstance(value, bytes):</span>
<span class="gi">+            value = value.decode(encoding)</span>
<span class="gi">+        if plus:</span>
<span class="gi">+            return urllib.parse.unquote_plus(value, encoding=encoding)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return urllib.parse.unquote(value, encoding=encoding)</span>


<span class="w"> </span>def parse_qs_bytes(qs: Union[str, bytes], keep_blank_values: bool=False,
<span class="gu">@@ -131,7 +152,11 @@ def parse_qs_bytes(qs: Union[str, bytes], keep_blank_values: bool=False,</span>
<span class="w"> </span>    because it&#39;s too painful to keep them as byte strings in
<span class="w"> </span>    python3 and in practice they&#39;re nearly always ascii anyway.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(qs, str):</span>
<span class="gi">+        qs = qs.encode(&#39;latin1&#39;)</span>
<span class="gi">+    result = urllib.parse.parse_qs(qs, keep_blank_values=keep_blank_values,</span>
<span class="gi">+                                   strict_parsing=strict_parsing, encoding=&#39;latin1&#39;)</span>
<span class="gi">+    return {k: [v.encode(&#39;latin1&#39;) for v in vs] for k, vs in result.items()}</span>


<span class="w"> </span>_UTF8_TYPES = bytes, type(None)
<span class="gu">@@ -143,7 +168,9 @@ def utf8(value: Union[None, str, bytes]) -&gt;Optional[bytes]:</span>
<span class="w"> </span>    If the argument is already a byte string or None, it is returned unchanged.
<span class="w"> </span>    Otherwise it must be a unicode string and is encoded as utf8.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value is None or isinstance(value, bytes):</span>
<span class="gi">+        return value</span>
<span class="gi">+    return value.encode(&#39;utf-8&#39;)</span>


<span class="w"> </span>_TO_UNICODE_TYPES = unicode_type, type(None)
<span class="gu">@@ -155,7 +182,9 @@ def to_unicode(value: Union[None, str, bytes]) -&gt;Optional[str]:</span>
<span class="w"> </span>    If the argument is already a unicode string or None, it is returned
<span class="w"> </span>    unchanged.  Otherwise it must be a byte string and is decoded as utf8.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value is None or isinstance(value, str):</span>
<span class="gi">+        return value</span>
<span class="gi">+    return value.decode(&#39;utf-8&#39;)</span>


<span class="w"> </span>_unicode = to_unicode
<span class="gu">@@ -168,7 +197,16 @@ def recursive_unicode(obj: Any) -&gt;Any:</span>

<span class="w"> </span>    Supports lists, tuples, and dictionaries.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(obj, dict):</span>
<span class="gi">+        return {recursive_unicode(key): recursive_unicode(value) for key, value in obj.items()}</span>
<span class="gi">+    elif isinstance(obj, list):</span>
<span class="gi">+        return [recursive_unicode(item) for item in obj]</span>
<span class="gi">+    elif isinstance(obj, tuple):</span>
<span class="gi">+        return tuple(recursive_unicode(item) for item in obj)</span>
<span class="gi">+    elif isinstance(obj, bytes):</span>
<span class="gi">+        return to_unicode(obj)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return obj</span>


<span class="w"> </span>_URL_RE = re.compile(to_unicode(
<span class="gu">@@ -208,4 +246,35 @@ def linkify(text: Union[str, bytes], shorten: bool=False, extra_params:</span>
<span class="w"> </span>      &quot;mailto&quot;])``. It is very unsafe to include protocols such as
<span class="w"> </span>      ``javascript``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(text, bytes):</span>
<span class="gi">+        text = text.decode(&#39;utf-8&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def make_link(m):</span>
<span class="gi">+        url = m.group(1)</span>
<span class="gi">+        proto = m.group(2)</span>
<span class="gi">+        </span>
<span class="gi">+        if require_protocol and not proto:</span>
<span class="gi">+            return url  # not protocol, no linkify</span>
<span class="gi">+</span>
<span class="gi">+        if proto and proto not in permitted_protocols:</span>
<span class="gi">+            return url  # bad protocol, no linkify</span>
<span class="gi">+</span>
<span class="gi">+        href = m.group(1)</span>
<span class="gi">+        if not proto:</span>
<span class="gi">+            href = &#39;http://&#39; + href   # no proto specified, use http</span>
<span class="gi">+</span>
<span class="gi">+        if callable(extra_params):</span>
<span class="gi">+            params = &quot; &quot; + extra_params(href)</span>
<span class="gi">+        else:</span>
<span class="gi">+            params = &quot; &quot; + extra_params</span>
<span class="gi">+</span>
<span class="gi">+        # clip long urls. max_len is just an example value</span>
<span class="gi">+        max_len = 30</span>
<span class="gi">+        if shorten and len(url) &gt; max_len:</span>
<span class="gi">+            before_clip = url[:max_len]</span>
<span class="gi">+            after_clip = url[max_len:]</span>
<span class="gi">+            url = before_clip + &quot;...&quot; + after_clip[-5:]</span>
<span class="gi">+</span>
<span class="gi">+        return f&#39;&lt;a href=&quot;{href}&quot;{params}&gt;{url}&lt;/a&gt;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    return _URL_RE.sub(make_link, text)</span>
<span class="gh">diff --git a/tornado/gen.py b/tornado/gen.py</span>
<span class="gh">index 19f311cf..b2ae8d08 100644</span>
<span class="gd">--- a/tornado/gen.py</span>
<span class="gi">+++ b/tornado/gen.py</span>
<span class="gu">@@ -140,7 +140,19 @@ def coroutine(func: Union[Callable[..., &#39;Generator[Any, Any, _T]&#39;],</span>
<span class="w"> </span>       awaitable object instead.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    @functools.wraps(func)</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        future = Future()</span>
<span class="gi">+        try:</span>
<span class="gi">+            result = func(*args, **kwargs)</span>
<span class="gi">+            if isinstance(result, Generator):</span>
<span class="gi">+                Runner(asyncio.get_event_loop().run_in_executor, result, future, next(result))</span>
<span class="gi">+            else:</span>
<span class="gi">+                future_set_result_unless_cancelled(future, result)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            future_set_exc_info(future, sys.exc_info())</span>
<span class="gi">+        return future</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>def is_coroutine_function(func: Any) -&gt;bool:
<span class="gu">@@ -149,7 +161,8 @@ def is_coroutine_function(func: Any) -&gt;bool:</span>

<span class="w"> </span>    .. versionadded:: 4.5
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (asyncio.iscoroutinefunction(func) or</span>
<span class="gi">+            (hasattr(func, &#39;__wrapped__&#39;) and asyncio.iscoroutinefunction(func.__wrapped__)))</span>


<span class="w"> </span>class Return(Exception):
<span class="gu">@@ -253,7 +266,7 @@ class WaitIterator(object):</span>

<span class="w"> </span>    def done(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Returns True if this iterator has no more results.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self._unfinished) == 0 and len(self._finished) == 0</span>

<span class="w"> </span>    def next(self) -&gt;Future:
<span class="w"> </span>        &quot;&quot;&quot;Returns a `.Future` that will yield the next available result.
<span class="gu">@@ -261,7 +274,14 @@ class WaitIterator(object):</span>
<span class="w"> </span>        Note that this `.Future` will not be the same object as any of
<span class="w"> </span>        the inputs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._finished:</span>
<span class="gi">+            return self._return_result(self._finished.popleft())</span>
<span class="gi">+        elif self._unfinished:</span>
<span class="gi">+            future = Future()</span>
<span class="gi">+            self._running_future = future</span>
<span class="gi">+            return future</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise StopIteration()</span>

<span class="w"> </span>    def _return_result(self, done: Future) -&gt;Future:
<span class="w"> </span>        &quot;&quot;&quot;Called set the returned future&#39;s state that of the future
<span class="gu">@@ -325,7 +345,29 @@ def multi(children: Union[List[_Yieldable], Dict[Any, _Yieldable]],</span>
<span class="w"> </span>       other than ``YieldPoint`` and `.Future`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(children, dict):</span>
<span class="gi">+        keys = list(children.keys())</span>
<span class="gi">+        children_seq = list(children.values())</span>
<span class="gi">+    else:</span>
<span class="gi">+        keys = None</span>
<span class="gi">+        children_seq = children</span>
<span class="gi">+    </span>
<span class="gi">+    children_futures = [convert_yielded(i) for i in children_seq]</span>
<span class="gi">+    future = Future()</span>
<span class="gi">+    </span>
<span class="gi">+    def callback(f):</span>
<span class="gi">+        try:</span>
<span class="gi">+            result_list = f.result()</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            future.set_exception(e)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if keys is not None:</span>
<span class="gi">+                future_set_result_unless_cancelled(future, dict(zip(keys, result_list)))</span>
<span class="gi">+            else:</span>
<span class="gi">+                future_set_result_unless_cancelled(future, result_list)</span>
<span class="gi">+    </span>
<span class="gi">+    future_add_done_callback(asyncio.gather(*children_futures), callback)</span>
<span class="gi">+    return future</span>


<span class="w"> </span>Multi = multi
<span class="gh">diff --git a/tornado/http1connection.py b/tornado/http1connection.py</span>
<span class="gh">index aa35011f..dff16a6e 100644</span>
<span class="gd">--- a/tornado/http1connection.py</span>
<span class="gi">+++ b/tornado/http1connection.py</span>
<span class="gu">@@ -121,7 +121,30 @@ class HTTP1Connection(httputil.HTTPConnection):</span>
<span class="w"> </span>        Returns a `.Future` that resolves to a bool after the full response has
<span class="w"> </span>        been read. The result is true if the stream is still open.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        async def _read_response():</span>
<span class="gi">+            try:</span>
<span class="gi">+                response_start_line = await self.stream.read_until(b&quot;\r\n&quot;)</span>
<span class="gi">+                start_line = httputil.parse_response_start_line(response_start_line)</span>
<span class="gi">+                self._response_start_line = start_line</span>
<span class="gi">+</span>
<span class="gi">+                headers = await self.stream.read_until(b&quot;\r\n\r\n&quot;)</span>
<span class="gi">+                headers = httputil.HTTPHeaders.parse(headers)</span>
<span class="gi">+</span>
<span class="gi">+                await delegate.headers_received(start_line, headers)</span>
<span class="gi">+</span>
<span class="gi">+                if headers.get(&quot;Transfer-Encoding&quot;) == &quot;chunked&quot;:</span>
<span class="gi">+                    await self._read_chunked_body(delegate)</span>
<span class="gi">+                elif &quot;Content-Length&quot; in headers:</span>
<span class="gi">+                    content_length = int(headers[&quot;Content-Length&quot;])</span>
<span class="gi">+                    await self._read_fixed_body(delegate, content_length)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    await self._read_body_until_close(delegate)</span>
<span class="gi">+</span>
<span class="gi">+                return not self.stream.closed()</span>
<span class="gi">+            except iostream.StreamClosedError:</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        return asyncio.ensure_future(_read_response())</span>

<span class="w"> </span>    def _clear_callbacks(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Clears the callback attributes.
<span class="gu">@@ -129,7 +152,10 @@ class HTTP1Connection(httputil.HTTPConnection):</span>
<span class="w"> </span>        This allows the request handler to be garbage collected more
<span class="w"> </span>        quickly in CPython by breaking up reference cycles.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._write_callback = None</span>
<span class="gi">+        self._write_future = None</span>
<span class="gi">+        self._close_callback = None</span>
<span class="gi">+        self._body_future = None</span>

<span class="w"> </span>    def set_close_callback(self, callback: Optional[Callable[[], None]]
<span class="w"> </span>        ) -&gt;None:
<span class="gu">@@ -144,7 +170,7 @@ class HTTP1Connection(httputil.HTTPConnection):</span>
<span class="w"> </span>        after sending its request but before receiving all the
<span class="w"> </span>        response.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._close_callback = callback</span>

<span class="w"> </span>    def detach(self) -&gt;iostream.IOStream:
<span class="w"> </span>        &quot;&quot;&quot;Take control of the underlying stream.
<span class="gu">@@ -154,21 +180,24 @@ class HTTP1Connection(httputil.HTTPConnection):</span>
<span class="w"> </span>        `.HTTPMessageDelegate.headers_received`.  Intended for implementing
<span class="w"> </span>        protocols like websockets that tunnel over an HTTP handshake.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._clear_callbacks()</span>
<span class="gi">+        stream = self.stream</span>
<span class="gi">+        self.stream = None</span>
<span class="gi">+        return stream</span>

<span class="w"> </span>    def set_body_timeout(self, timeout: float) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Sets the body timeout for a single request.

<span class="w"> </span>        Overrides the value from `.HTTP1ConnectionParameters`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._body_timeout = timeout</span>

<span class="w"> </span>    def set_max_body_size(self, max_body_size: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Sets the body size limit for a single request.

<span class="w"> </span>        Overrides the value from `.HTTP1ConnectionParameters`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._max_body_size = max_body_size</span>

<span class="w"> </span>    def write_headers(self, start_line: Union[httputil.RequestStartLine,
<span class="w"> </span>        httputil.ResponseStartLine], headers: httputil.HTTPHeaders, chunk:
<span class="gh">diff --git a/tornado/httpclient.py b/tornado/httpclient.py</span>
<span class="gh">index 6069b0be..1adcc7c3 100644</span>
<span class="gd">--- a/tornado/httpclient.py</span>
<span class="gi">+++ b/tornado/httpclient.py</span>
<span class="gu">@@ -98,7 +98,10 @@ class HTTPClient(object):</span>

<span class="w"> </span>    def close(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Closes the HTTPClient, freeing any resources used.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._closed:</span>
<span class="gi">+            self._io_loop.close()</span>
<span class="gi">+            self._async_client.close()</span>
<span class="gi">+            self._closed = True</span>

<span class="w"> </span>    def fetch(self, request: Union[&#39;HTTPRequest&#39;, str], **kwargs: Any
<span class="w"> </span>        ) -&gt;&#39;HTTPResponse&#39;:
<span class="gu">@@ -111,7 +114,24 @@ class HTTPClient(object):</span>
<span class="w"> </span>        If an error occurs during the fetch, we raise an `HTTPError` unless
<span class="w"> </span>        the ``raise_error`` keyword argument is set to False.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            raise RuntimeError(&quot;HTTP client is closed&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(request, str):</span>
<span class="gi">+            request = HTTPRequest(request, **kwargs)</span>
<span class="gi">+        elif kwargs:</span>
<span class="gi">+            raise ValueError(&quot;kwargs can&#39;t be used if request is an HTTPRequest object&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        def callback(future):</span>
<span class="gi">+            try:</span>
<span class="gi">+                result = future.result()</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                if request.raise_error:</span>
<span class="gi">+                    raise</span>
<span class="gi">+                result = HTTPResponse(request, 599, error=e)</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        return self._io_loop.run_sync(lambda: self._async_client.fetch(request, raise_error=False)).add_done_callback(callback)</span>


<span class="w"> </span>class AsyncHTTPClient(Configurable):
<span class="gu">@@ -182,7 +202,10 @@ class AsyncHTTPClient(Configurable):</span>
<span class="w"> </span>        ``close()``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._instance_cache is not None:</span>
<span class="gi">+            if self._instance_cache.get(self.io_loop) is self:</span>
<span class="gi">+                del self._instance_cache[self.io_loop]</span>
<span class="gi">+        self.io_loop.run_sync(self._close_async)</span>

<span class="w"> </span>    def fetch(self, request: Union[str, &#39;HTTPRequest&#39;], raise_error: bool=
<span class="w"> </span>        True, **kwargs: Any) -&gt;&#39;Future[HTTPResponse]&#39;:
<span class="gu">@@ -214,7 +237,13 @@ class AsyncHTTPClient(Configurable):</span>
<span class="w"> </span>           `HTTPError` raised when a non-200 response code is used,
<span class="w"> </span>           instead of suppressing all errors.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(request, str):</span>
<span class="gi">+            request = HTTPRequest(request, **kwargs)</span>
<span class="gi">+        elif kwargs:</span>
<span class="gi">+            raise ValueError(&quot;kwargs can&#39;t be used if request is an HTTPRequest object&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        future = self.io_loop.run_in_executor(None, self._fetch_impl, request, raise_error)</span>
<span class="gi">+        return future</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def configure(cls, impl: &#39;Union[None, str, Type[Configurable]]&#39;, **
<span class="gu">@@ -512,7 +541,8 @@ class HTTPResponse(object):</span>

<span class="w"> </span>    def rethrow(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;If there was an error on the request, raise an `HTTPError`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.error:</span>
<span class="gi">+            raise self.error</span>

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        args = &#39;,&#39;.join(&#39;%s=%r&#39; % i for i in sorted(self.__dict__.items()))
<span class="gh">diff --git a/tornado/httpserver.py b/tornado/httpserver.py</span>
<span class="gh">index 1a203b99..6cd4c488 100644</span>
<span class="gd">--- a/tornado/httpserver.py</span>
<span class="gi">+++ b/tornado/httpserver.py</span>
<span class="gu">@@ -136,7 +136,35 @@ class HTTPServer(TCPServer, Configurable, httputil.HTTPServerConnectionDelegate</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, *args: Any, **kwargs: Any) -&gt;None:
<span class="gd">-        pass</span>
<span class="gi">+        # Initialize TCPServer</span>
<span class="gi">+        super(HTTPServer, self).__init__()</span>
<span class="gi">+</span>
<span class="gi">+        # Extract HTTP-specific parameters</span>
<span class="gi">+        self.request_callback = args[0] if args else None</span>
<span class="gi">+        self.xheaders = kwargs.pop(&quot;xheaders&quot;, False)</span>
<span class="gi">+        self.protocol = kwargs.pop(&quot;protocol&quot;, None)</span>
<span class="gi">+        self.decompress_request = kwargs.pop(&quot;decompress_request&quot;, False)</span>
<span class="gi">+        self.chunk_size = kwargs.pop(&quot;chunk_size&quot;, 65536)</span>
<span class="gi">+        self.max_header_size = kwargs.pop(&quot;max_header_size&quot;, None)</span>
<span class="gi">+        self.idle_connection_timeout = kwargs.pop(&quot;idle_connection_timeout&quot;, None)</span>
<span class="gi">+        self.body_timeout = kwargs.pop(&quot;body_timeout&quot;, None)</span>
<span class="gi">+        self.max_body_size = kwargs.pop(&quot;max_body_size&quot;, None)</span>
<span class="gi">+        self.trusted_downstream = kwargs.pop(&quot;trusted_downstream&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        # SSL options</span>
<span class="gi">+        self.ssl_options = kwargs.pop(&quot;ssl_options&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        # Connection parameters</span>
<span class="gi">+        self.conn_params = HTTP1ConnectionParameters(</span>
<span class="gi">+            decompress=self.decompress_request,</span>
<span class="gi">+            chunk_size=self.chunk_size,</span>
<span class="gi">+            max_header_size=self.max_header_size,</span>
<span class="gi">+            header_timeout=self.idle_connection_timeout,</span>
<span class="gi">+            max_body_size=self.max_body_size,</span>
<span class="gi">+            body_timeout=self.body_timeout,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        self._connections = set()</span>

<span class="w"> </span>    async def close_all_connections(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Close all open connections and asynchronously wait for them to finish.
<span class="gu">@@ -152,7 +180,13 @@ class HTTPServer(TCPServer, Configurable, httputil.HTTPServerConnectionDelegate</span>
<span class="w"> </span>        Note that this method is a coroutine and must be called with ``await``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while self._connections:</span>
<span class="gi">+            # Make a copy of the set before iterating, as it may be modified</span>
<span class="gi">+            # during iteration</span>
<span class="gi">+            for conn in list(self._connections):</span>
<span class="gi">+                await conn.close()</span>
<span class="gi">+            # Allow the event loop to run and process the closed connections</span>
<span class="gi">+            await asyncio.sleep(0)</span>


<span class="w"> </span>class _CallableAdapter(httputil.HTTPMessageDelegate):
<span class="gu">@@ -201,7 +235,28 @@ class _HTTPRequestContext(object):</span>

<span class="w"> </span>    def _apply_xheaders(self, headers: httputil.HTTPHeaders) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Rewrite the ``remote_ip`` and ``protocol`` fields.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Check for X-Real-Ip or X-Forwarded-For headers</span>
<span class="gi">+        real_ip = headers.get(&quot;X-Real-Ip&quot;)</span>
<span class="gi">+        forwarded_for = headers.get(&quot;X-Forwarded-For&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if real_ip:</span>
<span class="gi">+            self.remote_ip = real_ip</span>
<span class="gi">+        elif forwarded_for:</span>
<span class="gi">+            # If we have trusted downstream servers, skip them</span>
<span class="gi">+            forwarded_ips = [ip.strip() for ip in forwarded_for.split(&#39;,&#39;)]</span>
<span class="gi">+            while forwarded_ips and forwarded_ips[-1] in self.trusted_downstream:</span>
<span class="gi">+                forwarded_ips.pop()</span>
<span class="gi">+            if forwarded_ips:</span>
<span class="gi">+                self.remote_ip = forwarded_ips[-1]</span>
<span class="gi">+</span>
<span class="gi">+        # Check for X-Scheme or X-Forwarded-Proto headers</span>
<span class="gi">+        scheme = headers.get(&quot;X-Scheme&quot;)</span>
<span class="gi">+        proto = headers.get(&quot;X-Forwarded-Proto&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if scheme:</span>
<span class="gi">+            self.protocol = scheme</span>
<span class="gi">+        elif proto:</span>
<span class="gi">+            self.protocol = proto</span>

<span class="w"> </span>    def _unapply_xheaders(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Undo changes from `_apply_xheaders`.
<span class="gu">@@ -209,7 +264,8 @@ class _HTTPRequestContext(object):</span>
<span class="w"> </span>        Xheaders are per-request so they should not leak to the next
<span class="w"> </span>        request on the same connection.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.remote_ip = self._orig_remote_ip</span>
<span class="gi">+        self.protocol = self._orig_protocol</span>


<span class="w"> </span>class _ProxyAdapter(httputil.HTTPMessageDelegate):
<span class="gh">diff --git a/tornado/httputil.py b/tornado/httputil.py</span>
<span class="gh">index 907aef4e..075e595b 100644</span>
<span class="gd">--- a/tornado/httputil.py</span>
<span class="gi">+++ b/tornado/httputil.py</span>
<span class="gu">@@ -36,7 +36,7 @@ def _normalize_header(name: str) -&gt;str:</span>
<span class="w"> </span>    &gt;&gt;&gt; _normalize_header(&quot;coNtent-TYPE&quot;)
<span class="w"> </span>    &#39;Content-Type&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &quot;-&quot;.join(word.capitalize() for word in name.split(&quot;-&quot;))</span>


<span class="w"> </span>class HTTPHeaders(collections.abc.MutableMapping):
<span class="gu">@@ -97,11 +97,18 @@ class HTTPHeaders(collections.abc.MutableMapping):</span>

<span class="w"> </span>    def add(self, name: str, value: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Adds a new value for the given key.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        norm_name = _normalize_header(name)</span>
<span class="gi">+        self._last_key = norm_name</span>
<span class="gi">+        if norm_name in self._dict:</span>
<span class="gi">+            self._dict[norm_name] = self._dict[norm_name] + &#39;,&#39; + value</span>
<span class="gi">+            self._as_list[norm_name].append(value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self[norm_name] = value</span>

<span class="w"> </span>    def get_list(self, name: str) -&gt;List[str]:
<span class="w"> </span>        &quot;&quot;&quot;Returns all values for the given header as a list.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        norm_name = _normalize_header(name)</span>
<span class="gi">+        return self._as_list.get(norm_name, [])</span>

<span class="w"> </span>    def get_all(self) -&gt;Iterable[Tuple[str, str]]:
<span class="w"> </span>        &quot;&quot;&quot;Returns an iterable of all (name, value) pairs.
<span class="gu">@@ -109,7 +116,9 @@ class HTTPHeaders(collections.abc.MutableMapping):</span>
<span class="w"> </span>        If a header has multiple values, multiple pairs will be
<span class="w"> </span>        returned with the same name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name, values in self._as_list.items():</span>
<span class="gi">+            for value in values:</span>
<span class="gi">+                yield (name, value)</span>

<span class="w"> </span>    def parse_line(self, line: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Updates the dictionary with a single header line.
<span class="gu">@@ -119,7 +128,14 @@ class HTTPHeaders(collections.abc.MutableMapping):</span>
<span class="w"> </span>        &gt;&gt;&gt; h.get(&#39;content-type&#39;)
<span class="w"> </span>        &#39;text/html&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if line[0].isspace():</span>
<span class="gi">+            # continuation of a multi-line header</span>
<span class="gi">+            new_part = &#39; &#39; + line.lstrip()</span>
<span class="gi">+            self._dict[self._last_key] += new_part</span>
<span class="gi">+            self._as_list[self._last_key][-1] += new_part</span>
<span class="gi">+        else:</span>
<span class="gi">+            name, value = line.split(&quot;:&quot;, 1)</span>
<span class="gi">+            self.add(name, value.strip())</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def parse(cls, headers: str) -&gt;&#39;HTTPHeaders&#39;:
<span class="gu">@@ -135,7 +151,14 @@ class HTTPHeaders(collections.abc.MutableMapping):</span>
<span class="w"> </span>           mix of `KeyError`, and `ValueError`.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        h = cls()</span>
<span class="gi">+        for line in headers.splitlines():</span>
<span class="gi">+            if line:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    h.parse_line(line)</span>
<span class="gi">+                except ValueError:</span>
<span class="gi">+                    raise HTTPInputError(&quot;Malformed header line: %r&quot; % line)</span>
<span class="gi">+        return h</span>

<span class="w"> </span>    def __setitem__(self, name: str, value: str) -&gt;None:
<span class="w"> </span>        norm_name = _normalize_header(name)
<span class="gu">@@ -293,15 +316,25 @@ class HTTPServerRequest(object):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def cookies(self) -&gt;Dict[str, http.cookies.Morsel]:
<span class="w"> </span>        &quot;&quot;&quot;A dictionary of ``http.cookies.Morsel`` objects.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not hasattr(self, &quot;_cookies&quot;):</span>
<span class="gi">+            self._cookies = http.cookies.SimpleCookie()</span>
<span class="gi">+            if &quot;Cookie&quot; in self.headers:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self._cookies.load(native_str(self.headers[&quot;Cookie&quot;]))</span>
<span class="gi">+                except http.cookies.CookieError:</span>
<span class="gi">+                    self._cookies = {}</span>
<span class="gi">+        return self._cookies</span>

<span class="w"> </span>    def full_url(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Reconstructs the full URL for this request.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &quot;%s://%s%s&quot; % (self.protocol, self.host, self.uri)</span>

<span class="w"> </span>    def request_time(self) -&gt;float:
<span class="w"> </span>        &quot;&quot;&quot;Returns the amount of time it took for this request to execute.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._finish_time is None:</span>
<span class="gi">+            return time.time() - self._start_time</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._finish_time - self._start_time</span>

<span class="w"> </span>    def get_ssl_certificate(self, binary_form: bool=False) -&gt;Union[None,
<span class="w"> </span>        Dict, bytes]:
<span class="gu">@@ -323,7 +356,10 @@ class HTTPServerRequest(object):</span>
<span class="w"> </span>        details.
<span class="w"> </span>        http://docs.python.org/library/ssl.html#sslsocket-objects
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.connection.get_ssl_certificate(binary_form)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        attrs = &#39;protocol&#39;, &#39;host&#39;, &#39;method&#39;, &#39;uri&#39;, &#39;version&#39;, &#39;remote_ip&#39;
<span class="gu">@@ -477,7 +513,22 @@ def url_concat(url: str, args: Union[None, Dict[str, str], List[Tuple[str,</span>
<span class="w"> </span>    &gt;&gt;&gt; url_concat(&quot;http://example.com/foo?a=b&quot;, [(&quot;c&quot;, &quot;d&quot;), (&quot;c&quot;, &quot;d2&quot;)])
<span class="w"> </span>    &#39;http://example.com/foo?a=b&amp;c=d&amp;c=d2&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if args is None:</span>
<span class="gi">+        return url</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(args, dict):</span>
<span class="gi">+        args = list(args.items())</span>
<span class="gi">+    </span>
<span class="gi">+    # Remove None values</span>
<span class="gi">+    args = [(k, v) for k, v in args if v is not None]</span>
<span class="gi">+    </span>
<span class="gi">+    if not args:</span>
<span class="gi">+        return url</span>
<span class="gi">+    </span>
<span class="gi">+    if url[-1] not in (&#39;?&#39;, &#39;&amp;&#39;):</span>
<span class="gi">+        url += &#39;&amp;&#39; if (&#39;?&#39; in url) else &#39;?&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    return url + urlencode(args)</span>


<span class="w"> </span>class HTTPFile(ObjectDict):
<span class="gu">@@ -525,7 +576,23 @@ def _parse_request_range(range_header: str) -&gt;Optional[Tuple[Optional[int],</span>

<span class="w"> </span>    [0]: http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not range_header.startswith(&quot;bytes=&quot;):</span>
<span class="gi">+        return None</span>
<span class="gi">+    ranges = range_header[6:].split(&quot;,&quot;)</span>
<span class="gi">+    if len(ranges) != 1:</span>
<span class="gi">+        return None</span>
<span class="gi">+    start, sep, end = ranges[0].partition(&quot;-&quot;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        if not start:</span>
<span class="gi">+            return (-int(end), None) if end else (None, None)</span>
<span class="gi">+        if not end:</span>
<span class="gi">+            return (int(start), None)</span>
<span class="gi">+        start, end = int(start), int(end)</span>
<span class="gi">+        if start &gt; end:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return (start, end + 1)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return None</span>


<span class="w"> </span>def _get_content_range(start: Optional[int], end: Optional[int], total: int
<span class="gu">@@ -539,7 +606,13 @@ def _get_content_range(start: Optional[int], end: Optional[int], total: int</span>
<span class="w"> </span>    &gt;&gt;&gt; print(_get_content_range(None, None, 4))
<span class="w"> </span>    bytes 0-3/4
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if start is None:</span>
<span class="gi">+        start = 0</span>
<span class="gi">+    if end is None:</span>
<span class="gi">+        end = total</span>
<span class="gi">+    else:</span>
<span class="gi">+        end = min(end, total)</span>
<span class="gi">+    return f&quot;bytes {start}-{end-1}/{total}&quot;</span>


<span class="w"> </span>def parse_body_arguments(content_type: str, body: bytes, arguments: Dict[
<span class="gu">@@ -553,7 +626,26 @@ def parse_body_arguments(content_type: str, body: bytes, arguments: Dict[</span>
<span class="w"> </span>    and ``files`` parameters are dictionaries that will be updated
<span class="w"> </span>    with the parsed contents.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if content_type.startswith(&quot;application/x-www-form-urlencoded&quot;):</span>
<span class="gi">+        try:</span>
<span class="gi">+            uri_arguments = parse_qs_bytes(body, keep_blank_values=True)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            gen_log.warning(&#39;Invalid x-www-form-urlencoded body: %s&#39;, e)</span>
<span class="gi">+            uri_arguments = {}</span>
<span class="gi">+        for name, values in uri_arguments.items():</span>
<span class="gi">+            if name in arguments:</span>
<span class="gi">+                arguments[name].extend(values)</span>
<span class="gi">+            else:</span>
<span class="gi">+                arguments[name] = values</span>
<span class="gi">+    elif content_type.startswith(&quot;multipart/form-data&quot;):</span>
<span class="gi">+        try:</span>
<span class="gi">+            boundary = content_type.split(&quot;boundary=&quot;)[1].encode(&quot;latin1&quot;)</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            gen_log.warning(&quot;Invalid multipart/form-data&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            parse_multipart_form_data(boundary, body, arguments, files)</span>
<span class="gi">+    else:</span>
<span class="gi">+        gen_log.warning(&quot;Unsupported Content-Type: %s&quot;, content_type)</span>


<span class="w"> </span>def parse_multipart_form_data(boundary: bytes, data: bytes, arguments: Dict
<span class="gu">@@ -569,7 +661,36 @@ def parse_multipart_form_data(boundary: bytes, data: bytes, arguments: Dict</span>
<span class="w"> </span>       Now recognizes non-ASCII filenames in RFC 2231/5987
<span class="w"> </span>       (``filename*=``) format.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = data.split(b&quot;--&quot; + boundary)</span>
<span class="gi">+    for part in parts[1:-1]:  # skip preamble and epilogue</span>
<span class="gi">+        eoh = part.find(b&quot;\r\n\r\n&quot;)</span>
<span class="gi">+        if eoh == -1:</span>
<span class="gi">+            gen_log.warning(&quot;multipart/form-data missing headers&quot;)</span>
<span class="gi">+            continue</span>
<span class="gi">+        headers = HTTPHeaders.parse(part[:eoh].decode(&quot;utf-8&quot;))</span>
<span class="gi">+        disp_header = headers.get(&quot;Content-Disposition&quot;, &quot;&quot;)</span>
<span class="gi">+        disposition, disp_params = _parse_header(disp_header)</span>
<span class="gi">+        if disposition != &quot;form-data&quot; or not part.endswith(b&quot;\r\n&quot;):</span>
<span class="gi">+            gen_log.warning(&quot;Invalid multipart/form-data&quot;)</span>
<span class="gi">+            continue</span>
<span class="gi">+        value = part[eoh + 4:-2]</span>
<span class="gi">+        name = disp_params.get(&quot;name&quot;)</span>
<span class="gi">+        if name is None:</span>
<span class="gi">+            gen_log.warning(&quot;multipart/form-data value missing name&quot;)</span>
<span class="gi">+            continue</span>
<span class="gi">+        name = name.decode(&quot;utf-8&quot;)</span>
<span class="gi">+        filename = disp_params.get(&quot;filename&quot;)</span>
<span class="gi">+        if filename is not None:</span>
<span class="gi">+            filename = filename.decode(&quot;utf-8&quot;)</span>
<span class="gi">+        if filename:</span>
<span class="gi">+            file = HTTPFile(</span>
<span class="gi">+                filename=filename,</span>
<span class="gi">+                body=value,</span>
<span class="gi">+                content_type=headers.get(&quot;Content-Type&quot;, &quot;application/unknown&quot;),</span>
<span class="gi">+            )</span>
<span class="gi">+            files.setdefault(name, []).append(file)</span>
<span class="gi">+        else:</span>
<span class="gi">+            arguments.setdefault(name, []).append(value)</span>


<span class="w"> </span>def format_timestamp(ts: Union[int, float, tuple, time.struct_time,
<span class="gu">@@ -584,7 +705,17 @@ def format_timestamp(ts: Union[int, float, tuple, time.struct_time,</span>
<span class="w"> </span>    &gt;&gt;&gt; format_timestamp(1359312200)
<span class="w"> </span>    &#39;Sun, 27 Jan 2013 18:43:20 GMT&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(ts, (int, float)):</span>
<span class="gi">+        time_tuple = time.gmtime(ts)</span>
<span class="gi">+    elif isinstance(ts, (tuple, time.struct_time)):</span>
<span class="gi">+        time_tuple = ts</span>
<span class="gi">+    elif isinstance(ts, datetime.datetime):</span>
<span class="gi">+        if ts.tzinfo is not None:</span>
<span class="gi">+            ts = ts.astimezone(datetime.timezone.utc).replace(tzinfo=None)</span>
<span class="gi">+        time_tuple = ts.utctimetuple()</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&quot;unknown timestamp type: %r&quot; % ts)</span>
<span class="gi">+    return email.utils.formatdate(time.mktime(time_tuple), usegmt=True)</span>


<span class="w"> </span>RequestStartLine = collections.namedtuple(&#39;RequestStartLine&#39;, [&#39;method&#39;,
<span class="gu">@@ -600,7 +731,13 @@ def parse_request_start_line(line: str) -&gt;RequestStartLine:</span>
<span class="w"> </span>    &gt;&gt;&gt; parse_request_start_line(&quot;GET /foo HTTP/1.1&quot;)
<span class="w"> </span>    RequestStartLine(method=&#39;GET&#39;, path=&#39;/foo&#39;, version=&#39;HTTP/1.1&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        method, path, version = line.split(&quot; &quot;)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise HTTPInputError(&quot;Malformed HTTP request line&quot;)</span>
<span class="gi">+    if not _http_version_re.match(version):</span>
<span class="gi">+        raise HTTPInputError(&quot;Malformed HTTP version in HTTP Request-Line&quot;)</span>
<span class="gi">+    return RequestStartLine(method, path, version)</span>


<span class="w"> </span>ResponseStartLine = collections.namedtuple(&#39;ResponseStartLine&#39;, [&#39;version&#39;,
<span class="gu">@@ -616,7 +753,15 @@ def parse_response_start_line(line: str) -&gt;ResponseStartLine:</span>
<span class="w"> </span>    &gt;&gt;&gt; parse_response_start_line(&quot;HTTP/1.1 200 OK&quot;)
<span class="w"> </span>    ResponseStartLine(version=&#39;HTTP/1.1&#39;, code=200, reason=&#39;OK&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = _http_response_line_re.match(line)</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        raise HTTPInputError(&quot;Malformed HTTP response line&quot;)</span>
<span class="gi">+    version, code, reason = match.groups()</span>
<span class="gi">+    try:</span>
<span class="gi">+        code = int(code)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise HTTPInputError(&quot;Malformed HTTP status code&quot;)</span>
<span class="gi">+    return ResponseStartLine(version, code, reason)</span>


<span class="w"> </span>def _parse_header(line: str) -&gt;Tuple[str, Dict[str, str]]:
<span class="gu">@@ -633,7 +778,24 @@ def _parse_header(line: str) -&gt;Tuple[str, Dict[str, str]]:</span>
<span class="w"> </span>    &gt;&gt;&gt; d[&#39;foo&#39;]
<span class="w"> </span>    &#39;b\\\\a&quot;r&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = line.split(&#39;;&#39;)</span>
<span class="gi">+    content_type = parts.pop(0).strip()</span>
<span class="gi">+    params = {}</span>
<span class="gi">+    for part in parts:</span>
<span class="gi">+        if &#39;=&#39; not in part:</span>
<span class="gi">+            continue</span>
<span class="gi">+        key, value = part.split(&#39;=&#39;, 1)</span>
<span class="gi">+        key = key.strip()</span>
<span class="gi">+        value = value.strip()</span>
<span class="gi">+        if value[0] == value[-1] == &#39;&quot;&#39;:</span>
<span class="gi">+            value = value[1:-1]</span>
<span class="gi">+            value = re.sub(r&#39;\\(.)&#39;, r&#39;\1&#39;, value)</span>
<span class="gi">+        elif key.endswith(&#39;*&#39;):</span>
<span class="gi">+            encoding, lang, value = value.split(&quot;&#39;&quot;, 2)</span>
<span class="gi">+            value = unquote(value, encoding=encoding)</span>
<span class="gi">+            key = key[:-1]</span>
<span class="gi">+        params[key] = value</span>
<span class="gi">+    return content_type, params</span>


<span class="w"> </span>def _encode_header(key: str, pdict: Dict[str, str]) -&gt;str:
<span class="gu">@@ -643,7 +805,19 @@ def _encode_header(key: str, pdict: Dict[str, str]) -&gt;str:</span>
<span class="w"> </span>    ...     {&#39;client_max_window_bits&#39;: 15, &#39;client_no_context_takeover&#39;: None})
<span class="w"> </span>    &#39;permessage-deflate; client_max_window_bits=15; client_no_context_takeover&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = [key]</span>
<span class="gi">+    for k, v in pdict.items():</span>
<span class="gi">+        if v is None:</span>
<span class="gi">+            parts.append(k)</span>
<span class="gi">+        elif isinstance(v, int):</span>
<span class="gi">+            parts.append(&quot;%s=%d&quot; % (k, v))</span>
<span class="gi">+        elif isinstance(v, str):</span>
<span class="gi">+            if _cookie_params_re.search(v):</span>
<span class="gi">+                v = &#39;&quot;%s&quot;&#39; % _cookie_quote(v)</span>
<span class="gi">+            parts.append(&quot;%s=%s&quot; % (k, v))</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Unsupported value: %r&quot; % v)</span>
<span class="gi">+    return &quot;; &quot;.join(parts)</span>


<span class="w"> </span>def encode_username_password(username: Union[str, bytes], password: Union[
<span class="gu">@@ -654,7 +828,11 @@ def encode_username_password(username: Union[str, bytes], password: Union[</span>

<span class="w"> </span>    .. versionadded:: 5.1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(username, str):</span>
<span class="gi">+        username = username.encode(&#39;utf-8&#39;)</span>
<span class="gi">+    if isinstance(password, str):</span>
<span class="gi">+        password = password.encode(&#39;utf-8&#39;)</span>
<span class="gi">+    return b&quot;%s:%s&quot; % (username, password)</span>


<span class="w"> </span>_netloc_re = re.compile(&#39;^(.+):(\\d+)$&#39;)
<span class="gu">@@ -667,7 +845,14 @@ def split_host_and_port(netloc: str) -&gt;Tuple[str, Optional[int]]:</span>

<span class="w"> </span>    .. versionadded:: 4.1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = _netloc_re.match(netloc)</span>
<span class="gi">+    if match:</span>
<span class="gi">+        host = match.group(1)</span>
<span class="gi">+        port = int(match.group(2))</span>
<span class="gi">+    else:</span>
<span class="gi">+        host = netloc</span>
<span class="gi">+        port = None</span>
<span class="gi">+    return (host, port)</span>


<span class="w"> </span>def qs_to_qsl(qs: Dict[str, List[AnyStr]]) -&gt;Iterable[Tuple[str, AnyStr]]:
<span class="gu">@@ -675,7 +860,9 @@ def qs_to_qsl(qs: Dict[str, List[AnyStr]]) -&gt;Iterable[Tuple[str, AnyStr]]:</span>

<span class="w"> </span>    .. versionadded:: 5.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for k, v in qs.items():</span>
<span class="gi">+        for x in v:</span>
<span class="gi">+            yield (k, x)</span>


<span class="w"> </span>_OctalPatt = re.compile(&#39;\\\\[0-3][0-7][0-7]&#39;)
<span class="gu">@@ -690,7 +877,30 @@ def _unquote_cookie(s: str) -&gt;str:</span>
<span class="w"> </span>    library (http.cookies._unquote) so we don&#39;t have to depend on
<span class="w"> </span>    non-public interfaces.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(s) &lt; 2:</span>
<span class="gi">+        return s</span>
<span class="gi">+    if s[0] != &#39;&quot;&#39; or s[-1] != &#39;&quot;&#39;:</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    s = s[1:-1]</span>
<span class="gi">+</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    n = len(s)</span>
<span class="gi">+    res = []</span>
<span class="gi">+    while 0 &lt;= i &lt; n:</span>
<span class="gi">+        o = s.find(&#39;\\&#39;, i)</span>
<span class="gi">+        if o &lt; 0:</span>
<span class="gi">+            res.append(s[i:])</span>
<span class="gi">+            break</span>
<span class="gi">+        res.append(s[i:o])</span>
<span class="gi">+        if o &lt; n - 1:</span>
<span class="gi">+            res.append(s[o+1])</span>
<span class="gi">+            i = o + 2</span>
<span class="gi">+        else:</span>
<span class="gi">+            # error condition, char is not escaped</span>
<span class="gi">+            res.append(&#39;\\&#39;)</span>
<span class="gi">+            i = o + 1</span>
<span class="gi">+    return _nulljoin(res)</span>


<span class="w"> </span>def parse_cookie(cookie: str) -&gt;Dict[str, str]:
<span class="gu">@@ -704,4 +914,16 @@ def parse_cookie(cookie: str) -&gt;Dict[str, str]:</span>

<span class="w"> </span>    .. versionadded:: 4.4.2
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cookie_dict = {}</span>
<span class="gi">+    for chunk in cookie.split(&#39;;&#39;):</span>
<span class="gi">+        if &#39;=&#39; in chunk:</span>
<span class="gi">+            key, val = chunk.split(&#39;=&#39;, 1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Assume an empty name per</span>
<span class="gi">+            # https://bugzilla.mozilla.org/show_bug.cgi?id=169091</span>
<span class="gi">+            key, val = &#39;&#39;, chunk</span>
<span class="gi">+        key, val = key.strip(), val.strip()</span>
<span class="gi">+        if key or val:</span>
<span class="gi">+            # unquote using Python&#39;s algorithm.</span>
<span class="gi">+            cookie_dict[key] = _unquote_cookie(val)</span>
<span class="gi">+    return cookie_dict</span>
<span class="gh">diff --git a/tornado/ioloop.py b/tornado/ioloop.py</span>
<span class="gh">index 114f1626..bafcde41 100644</span>
<span class="gd">--- a/tornado/ioloop.py</span>
<span class="gi">+++ b/tornado/ioloop.py</span>
<span class="gu">@@ -18,6 +18,7 @@ import time</span>
<span class="w"> </span>import math
<span class="w"> </span>import random
<span class="w"> </span>import warnings
<span class="gi">+from typing import Optional</span>
<span class="w"> </span>from inspect import isawaitable
<span class="w"> </span>from tornado.concurrent import Future, is_future, chain_future, future_set_exc_info, future_add_done_callback
<span class="w"> </span>from tornado.log import app_log
<span class="gu">@@ -146,7 +147,8 @@ class IOLoop(Configurable):</span>

<span class="w"> </span>        .. deprecated:: 5.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(&quot;IOLoop.instance() is deprecated, use IOLoop.current() instead&quot;, DeprecationWarning)</span>
<span class="gi">+        return IOLoop.current()</span>

<span class="w"> </span>    def install(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Deprecated alias for `make_current()`.
<span class="gu">@@ -160,7 +162,8 @@ class IOLoop(Configurable):</span>

<span class="w"> </span>        .. deprecated:: 5.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(&quot;IOLoop.install() is deprecated, use IOLoop.make_current() instead&quot;, DeprecationWarning)</span>
<span class="gi">+        self.make_current()</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def clear_instance() -&gt;None:
<span class="gu">@@ -176,7 +179,8 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>        .. deprecated:: 5.0

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(&quot;IOLoop.clear_instance() is deprecated, use IOLoop.clear_current() instead&quot;, DeprecationWarning)</span>
<span class="gi">+        IOLoop.clear_current()</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def current(instance: bool=True) -&gt;Optional[&#39;IOLoop&#39;]:
<span class="gu">@@ -203,7 +207,21 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>           It is deprecated to call ``IOLoop.current()`` when no `asyncio`
<span class="w"> </span>           event loop is running.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            loop = asyncio.get_event_loop()</span>
<span class="gi">+        except RuntimeError:</span>
<span class="gi">+            if not instance:</span>
<span class="gi">+                return None</span>
<span class="gi">+            warnings.warn(&quot;IOLoop.current() called with no running event loop&quot;, DeprecationWarning)</span>
<span class="gi">+            loop = asyncio.new_event_loop()</span>
<span class="gi">+            asyncio.set_event_loop(loop)</span>
<span class="gi">+        </span>
<span class="gi">+        try:</span>
<span class="gi">+            return IOLoop._ioloop_for_asyncio[loop]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            if instance:</span>
<span class="gi">+                return IOLoop(loop)</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    def make_current(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Makes this the `IOLoop` for the current thread.
<span class="gu">@@ -225,7 +243,8 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>           Setting and clearing the current event loop through Tornado is
<span class="w"> </span>           deprecated. Use ``asyncio.set_event_loop`` instead if you need this.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(&quot;Setting and clearing the current event loop through Tornado is deprecated. Use asyncio.set_event_loop instead.&quot;, DeprecationWarning)</span>
<span class="gi">+        asyncio.set_event_loop(self.asyncio_loop)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def clear_current() -&gt;None:
<span class="gu">@@ -237,14 +256,19 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>           This method also clears the current `asyncio` event loop.
<span class="w"> </span>        .. deprecated:: 6.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(&quot;IOLoop.clear_current() is deprecated&quot;, DeprecationWarning)</span>
<span class="gi">+        old_loop = asyncio.get_event_loop()</span>
<span class="gi">+        if old_loop in IOLoop._ioloop_for_asyncio:</span>
<span class="gi">+            del IOLoop._ioloop_for_asyncio[old_loop]</span>
<span class="gi">+        asyncio.set_event_loop(None)</span>

<span class="w"> </span>    def _clear_current_hook(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Instance method called when an IOLoop ceases to be current.

<span class="w"> </span>        May be overridden by subclasses as a counterpart to make_current.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.asyncio_loop in IOLoop._ioloop_for_asyncio:</span>
<span class="gi">+            del IOLoop._ioloop_for_asyncio[self.asyncio_loop]</span>

<span class="w"> </span>    def close(self, all_fds: bool=False) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Closes the `IOLoop`, freeing any resources used.
<span class="gh">diff --git a/tornado/iostream.py b/tornado/iostream.py</span>
<span class="gh">index 1f9c2e76..98e83e4f 100644</span>
<span class="gd">--- a/tornado/iostream.py</span>
<span class="gi">+++ b/tornado/iostream.py</span>
<span class="gu">@@ -89,20 +89,53 @@ class _StreamBuffer(object):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Append the given piece of data (should be a buffer-compatible object).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(data) &gt; self._large_buf_threshold:</span>
<span class="gi">+            self._buffers.append(memoryview(data))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._buffers.append(bytes(data))</span>
<span class="gi">+        self._size += len(data)</span>

<span class="w"> </span>    def peek(self, size: int) -&gt;memoryview:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get a view over at most ``size`` bytes (possibly fewer) at the
<span class="w"> </span>        current buffer position.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._buffers:</span>
<span class="gi">+            return memoryview(b&quot;&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        first_buf = self._buffers[0]</span>
<span class="gi">+        if len(first_buf) - self._first_pos &gt;= size:</span>
<span class="gi">+            return memoryview(first_buf)[self._first_pos:self._first_pos + size]</span>
<span class="gi">+        </span>
<span class="gi">+        view = bytearray(size)</span>
<span class="gi">+        pos = 0</span>
<span class="gi">+        for buf in self._buffers:</span>
<span class="gi">+            if pos == size:</span>
<span class="gi">+                break</span>
<span class="gi">+            if pos == 0:</span>
<span class="gi">+                chunk = buf[self._first_pos:]</span>
<span class="gi">+            else:</span>
<span class="gi">+                chunk = buf</span>
<span class="gi">+            if len(chunk) &gt; size - pos:</span>
<span class="gi">+                chunk = chunk[:size - pos]</span>
<span class="gi">+            view[pos:pos + len(chunk)] = chunk</span>
<span class="gi">+            pos += len(chunk)</span>
<span class="gi">+        </span>
<span class="gi">+        return memoryview(view)[:pos]</span>

<span class="w"> </span>    def advance(self, size: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Advance the current buffer position by ``size`` bytes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._size -= size</span>
<span class="gi">+        while size &gt; 0 and self._buffers:</span>
<span class="gi">+            buf = self._buffers[0]</span>
<span class="gi">+            if self._first_pos + size &lt; len(buf):</span>
<span class="gi">+                self._first_pos += size</span>
<span class="gi">+                return</span>
<span class="gi">+            size -= len(buf) - self._first_pos</span>
<span class="gi">+            self._first_pos = 0</span>
<span class="gi">+            del self._buffers[0]</span>


<span class="w"> </span>class BaseIOStream(object):
<span class="gu">@@ -171,7 +204,7 @@ class BaseIOStream(object):</span>

<span class="w"> </span>    def fileno(self) -&gt;Union[int, ioloop._Selectable]:
<span class="w"> </span>        &quot;&quot;&quot;Returns the file descriptor for this stream.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.socket.fileno()</span>

<span class="w"> </span>    def close_fd(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Closes the file underlying this stream.
<span class="gu">@@ -179,14 +212,22 @@ class BaseIOStream(object):</span>
<span class="w"> </span>        ``close_fd`` is called by `BaseIOStream` and should not be called
<span class="w"> </span>        elsewhere; other users should call `close` instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.socket is not None:</span>
<span class="gi">+            self.socket.close()</span>
<span class="gi">+            self.socket = None</span>

<span class="w"> </span>    def write_to_fd(self, data: memoryview) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Attempts to write ``data`` to the underlying file.

<span class="w"> </span>        Returns the number of bytes written.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.socket.send(data)</span>
<span class="gi">+        except (socket.error, IOError, OSError) as e:</span>
<span class="gi">+            if errno_from_exception(e) in _ERRNO_WOULDBLOCK:</span>
<span class="gi">+                return 0</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise</span>

<span class="w"> </span>    def read_from_fd(self, buf: Union[bytearray, memoryview]) -&gt;Optional[int]:
<span class="w"> </span>        &quot;&quot;&quot;Attempts to read from the underlying file.
<span class="gu">@@ -201,7 +242,15 @@ class BaseIOStream(object):</span>
<span class="w"> </span>           Interface redesigned to take a buffer and return a number
<span class="w"> </span>           of bytes instead of a freshly-allocated object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.socket.recv_into(buf)</span>
<span class="gi">+        except (socket.error, IOError, OSError) as e:</span>
<span class="gi">+            if errno_from_exception(e) in _ERRNO_WOULDBLOCK:</span>
<span class="gi">+                return None</span>
<span class="gi">+            elif errno_from_exception(e) in _ERRNO_CONNRESET:</span>
<span class="gi">+                return 0</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise</span>

<span class="w"> </span>    def get_fd_error(self) -&gt;Optional[Exception]:
<span class="w"> </span>        &quot;&quot;&quot;Returns information about any error on the underlying file.
<span class="gu">@@ -211,7 +260,13 @@ class BaseIOStream(object):</span>
<span class="w"> </span>        with additional information, or None if no such information is
<span class="w"> </span>        available.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.socket is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)</span>
<span class="gi">+        if err != 0:</span>
<span class="gi">+            return socket.error(err, os.strerror(err))</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    def read_until_regex(self, regex: bytes, max_bytes: Optional[int]=None
<span class="w"> </span>        ) -&gt;Awaitable[bytes]:
<span class="gh">diff --git a/tornado/locale.py b/tornado/locale.py</span>
<span class="gh">index 201f720a..15b70711 100644</span>
<span class="gd">--- a/tornado/locale.py</span>
<span class="gi">+++ b/tornado/locale.py</span>
<span class="gu">@@ -51,7 +51,13 @@ def get(*locale_codes: str) -&gt;&#39;Locale&#39;:</span>
<span class="w"> </span>    the specified locales. You can change the default locale with
<span class="w"> </span>    `set_default_locale()`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for code in locale_codes:</span>
<span class="gi">+        if code in _translations:</span>
<span class="gi">+            return _translations[code]</span>
<span class="gi">+        parts = code.split(&#39;_&#39;)</span>
<span class="gi">+        if len(parts) &gt; 1 and parts[0] in _translations:</span>
<span class="gi">+            return _translations[parts[0]]</span>
<span class="gi">+    return _translations.get(_default_locale)</span>


<span class="w"> </span>def set_default_locale(code: str) -&gt;None:
<span class="gu">@@ -62,7 +68,8 @@ def set_default_locale(code: str) -&gt;None:</span>
<span class="w"> </span>    the default locale to the destination locale. Consequently, you don&#39;t
<span class="w"> </span>    need to create a translation file for the default locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _default_locale</span>
<span class="gi">+    _default_locale = code</span>


<span class="w"> </span>def load_translations(directory: str, encoding: Optional[str]=None) -&gt;None:
<span class="gu">@@ -100,7 +107,40 @@ def load_translations(directory: str, encoding: Optional[str]=None) -&gt;None:</span>
<span class="w"> </span>       Added ``encoding`` parameter. Added support for BOM-based encoding
<span class="w"> </span>       detection, UTF-16, and UTF-8-with-BOM.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _translations, _supported_locales</span>
<span class="gi">+    for path in glob.glob(os.path.join(directory, &#39;*.csv&#39;)):</span>
<span class="gi">+        locale = os.path.basename(path).split(&#39;.&#39;)[0]</span>
<span class="gi">+        if encoding is None:</span>
<span class="gi">+            # Try to detect the encoding</span>
<span class="gi">+            with open(path, &#39;rb&#39;) as f:</span>
<span class="gi">+                data = f.read()</span>
<span class="gi">+                if data.startswith(codecs.BOM_UTF16):</span>
<span class="gi">+                    encoding = &#39;utf-16&#39;</span>
<span class="gi">+                elif data.startswith(codecs.BOM_UTF8):</span>
<span class="gi">+                    encoding = &#39;utf-8-sig&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    encoding = &#39;utf-8&#39;</span>
<span class="gi">+        </span>
<span class="gi">+        with open(path, &#39;r&#39;, encoding=encoding) as f:</span>
<span class="gi">+            _translations[locale] = {}</span>
<span class="gi">+            for i, row in enumerate(csv.reader(f)):</span>
<span class="gi">+                if len(row) == 2:</span>
<span class="gi">+                    singular, translation = row</span>
<span class="gi">+                    plural = None</span>
<span class="gi">+                elif len(row) == 3:</span>
<span class="gi">+                    singular, translation, plural = row</span>
<span class="gi">+                else:</span>
<span class="gi">+                    gen_log.error(f&quot;Malformed translation in {path}, line {i+1}&quot;)</span>
<span class="gi">+                    continue</span>
<span class="gi">+                </span>
<span class="gi">+                if plural in (&#39;plural&#39;, &#39;singular&#39;):</span>
<span class="gi">+                    if singular not in _translations[locale]:</span>
<span class="gi">+                        _translations[locale][singular] = {}</span>
<span class="gi">+                    _translations[locale][singular][plural] = translation</span>
<span class="gi">+                else:</span>
<span class="gi">+                    _translations[locale][singular] = translation</span>
<span class="gi">+    </span>
<span class="gi">+    _supported_locales = frozenset(_translations.keys())</span>


<span class="w"> </span>def load_gettext_translations(directory: str, domain: str) -&gt;None:
<span class="gu">@@ -124,12 +164,22 @@ def load_gettext_translations(directory: str, domain: str) -&gt;None:</span>

<span class="w"> </span>        msgfmt mydomain.po -o {directory}/pt_BR/LC_MESSAGES/mydomain.mo
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _translations, _supported_locales, _use_gettext</span>
<span class="gi">+    for lang in os.listdir(directory):</span>
<span class="gi">+        if os.path.isdir(os.path.join(directory, lang)):</span>
<span class="gi">+            try:</span>
<span class="gi">+                translation = gettext.translation(domain, directory, languages=[lang])</span>
<span class="gi">+                _translations[lang] = GettextLocale(lang, translation)</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                gen_log.error(f&quot;Cannot load translation for &#39;{lang}&#39;: {str(e)}&quot;)</span>
<span class="gi">+                continue</span>
<span class="gi">+    _supported_locales = frozenset(_translations.keys())</span>
<span class="gi">+    _use_gettext = True</span>


<span class="w"> </span>def get_supported_locales() -&gt;Iterable[str]:
<span class="w"> </span>    &quot;&quot;&quot;Returns a list of all the supported locale codes.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return list(_supported_locales)</span>


<span class="w"> </span>class Locale(object):
<span class="gu">@@ -143,7 +193,7 @@ class Locale(object):</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def get_closest(cls, *locale_codes: str) -&gt;&#39;Locale&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Returns the closest match for the given locale code.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return get(*locale_codes)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def get(cls, code: str) -&gt;&#39;Locale&#39;:
<span class="gu">@@ -151,7 +201,9 @@ class Locale(object):</span>

<span class="w"> </span>        If it is not supported, we raise an exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if code not in _supported_locales:</span>
<span class="gi">+            raise Exception(f&quot;Unsupported locale: {code}&quot;)</span>
<span class="gi">+        return _translations[code]</span>

<span class="w"> </span>    def __init__(self, code: str) -&gt;None:
<span class="w"> </span>        self.code = code
<span class="gu">@@ -177,7 +229,20 @@ class Locale(object):</span>
<span class="w"> </span>        and we return the singular form for the given message when
<span class="w"> </span>        ``count == 1``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if plural_message is not None:</span>
<span class="gi">+            assert count is not None</span>
<span class="gi">+            if _use_gettext:</span>
<span class="gi">+                return self.ngettext(message, plural_message, count)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if count != 1:</span>
<span class="gi">+                    return self.translations.get(message, {}).get(&#39;plural&#39;, plural_message)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return self.translations.get(message, {}).get(&#39;singular&#39;, message)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if _use_gettext:</span>
<span class="gi">+                return self.gettext(message)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return self.translations.get(message, message)</span>

<span class="w"> </span>    def format_date(self, date: Union[int, float, datetime.datetime],
<span class="w"> </span>        gmt_offset: int=0, relative: bool=True, shorter: bool=False,
<span class="gu">@@ -197,16 +262,76 @@ class Locale(object):</span>
<span class="w"> </span>           Aware `datetime.datetime` objects are now supported (naive
<span class="w"> </span>           datetimes are still assumed to be UTC).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(date, (int, float)):</span>
<span class="gi">+            date = datetime.datetime.fromtimestamp(date, datetime.timezone.utc)</span>
<span class="gi">+        elif isinstance(date, datetime.datetime):</span>
<span class="gi">+            if date.tzinfo is None:</span>
<span class="gi">+                date = date.replace(tzinfo=datetime.timezone.utc)</span>
<span class="gi">+        </span>
<span class="gi">+        now = datetime.datetime.now(datetime.timezone.utc)</span>
<span class="gi">+        if date &gt; now:</span>
<span class="gi">+            if relative and (date - now).total_seconds() &lt; 60:</span>
<span class="gi">+                return self.translate(&quot;in a moment&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return self.format_day(date, gmt_offset, dow=True)</span>
<span class="gi">+        </span>
<span class="gi">+        local_date = date.astimezone(datetime.timezone(datetime.timedelta(hours=gmt_offset)))</span>
<span class="gi">+        local_now = now.astimezone(datetime.timezone(datetime.timedelta(hours=gmt_offset)))</span>
<span class="gi">+        </span>
<span class="gi">+        delta = now - date</span>
<span class="gi">+        seconds = delta.total_seconds()</span>
<span class="gi">+        days = delta.days</span>
<span class="gi">+        </span>
<span class="gi">+        if full_format:</span>
<span class="gi">+            return self.format_day(date, gmt_offset, dow=True)</span>
<span class="gi">+        </span>
<span class="gi">+        if relative and days == 0:</span>
<span class="gi">+            if seconds &lt; 50:</span>
<span class="gi">+                return self.translate(&quot;just now&quot;)</span>
<span class="gi">+            if seconds &lt; 90:</span>
<span class="gi">+                return self.translate(&quot;1 minute ago&quot;)</span>
<span class="gi">+            elif seconds &lt; 3600:</span>
<span class="gi">+                minutes = int(seconds / 60)</span>
<span class="gi">+                return self.translate(</span>
<span class="gi">+                    &quot;%(minutes)d minute ago&quot;,</span>
<span class="gi">+                    &quot;%(minutes)d minutes ago&quot;,</span>
<span class="gi">+                    minutes) % {&quot;minutes&quot;: minutes}</span>
<span class="gi">+            elif seconds &lt; 7200:</span>
<span class="gi">+                return self.translate(&quot;1 hour ago&quot;)</span>
<span class="gi">+            elif seconds &lt; 86400:</span>
<span class="gi">+                hours = int(seconds / 3600)</span>
<span class="gi">+                return self.translate(</span>
<span class="gi">+                    &quot;%(hours)d hour ago&quot;,</span>
<span class="gi">+                    &quot;%(hours)d hours ago&quot;,</span>
<span class="gi">+                    hours) % {&quot;hours&quot;: hours}</span>
<span class="gi">+        elif days == 1:</span>
<span class="gi">+            return self.translate(&quot;yesterday&quot;)</span>
<span class="gi">+        elif days &lt; 5:</span>
<span class="gi">+            return self.format_day(date, gmt_offset, dow=True)</span>
<span class="gi">+        elif days &lt; 30:</span>
<span class="gi">+            return self.translate(&quot;%(days)d days ago&quot;) % {&quot;days&quot;: days}</span>
<span class="gi">+        elif days &lt; 365:</span>
<span class="gi">+            months = int(days / 30)</span>
<span class="gi">+            return self.translate(</span>
<span class="gi">+                &quot;%(months)d month ago&quot;,</span>
<span class="gi">+                &quot;%(months)d months ago&quot;,</span>
<span class="gi">+                months) % {&quot;months&quot;: months}</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.format_day(date, gmt_offset, dow=True)</span>

<span class="w"> </span>    def format_day(self, date: datetime.datetime, gmt_offset: int=0, dow:
<span class="gd">-        bool=True) -&gt;bool:</span>
<span class="gi">+        bool=True) -&gt;str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Formats the given date as a day of week.

<span class="w"> </span>        Example: &quot;Monday, January 22&quot;. You can remove the day of week with
<span class="w"> </span>        ``dow=False``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        local_date = date.astimezone(datetime.timezone(datetime.timedelta(hours=gmt_offset)))</span>
<span class="gi">+        if dow:</span>
<span class="gi">+            weekday = self._weekdays[local_date.weekday()]</span>
<span class="gi">+            return f&quot;{weekday}, {self._months[local_date.month - 1]} {local_date.day}&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return f&quot;{self._months[local_date.month - 1]} {local_date.day}&quot;</span>

<span class="w"> </span>    def list(self, parts: Any) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Returns a comma-separated list for the given list of parts.
<span class="gu">@@ -214,11 +339,25 @@ class Locale(object):</span>
<span class="w"> </span>        The format is, e.g., &quot;A, B and C&quot;, &quot;A and B&quot; or just &quot;A&quot; for lists
<span class="w"> </span>        of size 1.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(parts) == 0:</span>
<span class="gi">+            return &quot;&quot;</span>
<span class="gi">+        elif len(parts) == 1:</span>
<span class="gi">+            return parts[0]</span>
<span class="gi">+        elif len(parts) == 2:</span>
<span class="gi">+            return self.translate(&quot;%(first)s and %(second)s&quot;) % {</span>
<span class="gi">+                &quot;first&quot;: parts[0],</span>
<span class="gi">+                &quot;second&quot;: parts[1],</span>
<span class="gi">+            }</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.translate(</span>
<span class="gi">+                &quot;%(commas)s and %(last)s&quot;) % {</span>
<span class="gi">+                &quot;commas&quot;: &quot;, &quot;.join(parts[:-1]),</span>
<span class="gi">+                &quot;last&quot;: parts[-1],</span>
<span class="gi">+            }</span>

<span class="w"> </span>    def friendly_number(self, value: int) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Returns a comma-separated number for the given integer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &quot;{:,}&quot;.format(value)</span>


<span class="w"> </span>class CSVLocale(Locale):
<span class="gu">@@ -260,4 +399,12 @@ class GettextLocale(Locale):</span>

<span class="w"> </span>        .. versionadded:: 4.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if plural_message is not None:</span>
<span class="gi">+            assert count is not None</span>
<span class="gi">+            msgctxt = f&quot;{context}{CONTEXT_SEPARATOR}{message}&quot;</span>
<span class="gi">+            tmsg = self.ngettext(msgctxt, plural_message, count)</span>
<span class="gi">+            return tmsg if tmsg != msgctxt else self.ngettext(message, plural_message, count)</span>
<span class="gi">+        else:</span>
<span class="gi">+            msgctxt = f&quot;{context}{CONTEXT_SEPARATOR}{message}&quot;</span>
<span class="gi">+            tmsg = self.gettext(msgctxt)</span>
<span class="gi">+            return tmsg if tmsg != msgctxt else self.gettext(message)</span>
<span class="gh">diff --git a/tornado/locks.py b/tornado/locks.py</span>
<span class="gh">index bacc3ebe..028ed817 100644</span>
<span class="gd">--- a/tornado/locks.py</span>
<span class="gi">+++ b/tornado/locks.py</span>
<span class="gu">@@ -98,15 +98,35 @@ class Condition(_TimeoutGarbageCollector):</span>
<span class="w"> </span>        Returns a `.Future` that resolves ``True`` if the condition is notified,
<span class="w"> </span>        or ``False`` after a timeout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        future = Future()</span>
<span class="gi">+        self._waiters.append(future)</span>
<span class="gi">+</span>
<span class="gi">+        if timeout:</span>
<span class="gi">+            def on_timeout():</span>
<span class="gi">+                self._waiters.remove(future)</span>
<span class="gi">+                if not future.done():</span>
<span class="gi">+                    future.set_result(False)</span>
<span class="gi">+            io_loop = ioloop.IOLoop.current()</span>
<span class="gi">+            timeout_handle = io_loop.add_timeout(timeout, on_timeout)</span>
<span class="gi">+            future.add_done_callback(lambda _: io_loop.remove_timeout(timeout_handle))</span>
<span class="gi">+</span>
<span class="gi">+        return future</span>

<span class="w"> </span>    def notify(self, n: int=1) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Wake ``n`` waiters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        waiters = []</span>
<span class="gi">+        while n &gt; 0 and self._waiters:</span>
<span class="gi">+            waiter = self._waiters.popleft()</span>
<span class="gi">+            if not waiter.done():</span>
<span class="gi">+                n -= 1</span>
<span class="gi">+                waiters.append(waiter)</span>
<span class="gi">+</span>
<span class="gi">+        for waiter in waiters:</span>
<span class="gi">+            future_set_result_unless_cancelled(waiter, True)</span>

<span class="w"> </span>    def notify_all(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Wake all waiters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.notify(len(self._waiters))</span>


<span class="w"> </span>class Event(object):
<span class="gu">@@ -159,21 +179,25 @@ class Event(object):</span>

<span class="w"> </span>    def is_set(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Return ``True`` if the internal flag is true.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._value</span>

<span class="w"> </span>    def set(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Set the internal flag to ``True``. All waiters are awakened.

<span class="w"> </span>        Calling `.wait` once the flag is set will not block.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._value = True</span>
<span class="gi">+        for waiter in self._waiters:</span>
<span class="gi">+            if not waiter.done():</span>
<span class="gi">+                waiter.set_result(None)</span>
<span class="gi">+        self._waiters.clear()</span>

<span class="w"> </span>    def clear(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Reset the internal flag to ``False``.

<span class="w"> </span>        Calls to `.wait` will block until `.set` is called.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._value = False</span>

<span class="w"> </span>    def wait(self, timeout: Optional[Union[float, datetime.timedelta]]=None
<span class="w"> </span>        ) -&gt;Awaitable[None]:
<span class="gu">@@ -182,7 +206,24 @@ class Event(object):</span>
<span class="w"> </span>        Returns an awaitable, which raises `tornado.util.TimeoutError` after a
<span class="w"> </span>        timeout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value:</span>
<span class="gi">+            future = Future()</span>
<span class="gi">+            future.set_result(None)</span>
<span class="gi">+            return future</span>
<span class="gi">+</span>
<span class="gi">+        waiter = Future()</span>
<span class="gi">+        self._waiters.add(waiter)</span>
<span class="gi">+</span>
<span class="gi">+        if timeout:</span>
<span class="gi">+            def on_timeout():</span>
<span class="gi">+                self._waiters.discard(waiter)</span>
<span class="gi">+                if not waiter.done():</span>
<span class="gi">+                    waiter.set_exception(gen.TimeoutError())</span>
<span class="gi">+            io_loop = ioloop.IOLoop.current()</span>
<span class="gi">+            timeout_handle = io_loop.add_timeout(timeout, on_timeout)</span>
<span class="gi">+            waiter.add_done_callback(lambda _: io_loop.remove_timeout(timeout_handle))</span>
<span class="gi">+</span>
<span class="gi">+        return waiter</span>


<span class="w"> </span>class _ReleasingContextManager(object):
<span class="gu">@@ -198,7 +239,7 @@ class _ReleasingContextManager(object):</span>
<span class="w"> </span>        self._obj = obj

<span class="w"> </span>    def __enter__(self) -&gt;None:
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def __exit__(self, exc_type: &#39;Optional[Type[BaseException]]&#39;, exc_val:
<span class="w"> </span>        Optional[BaseException], exc_tb: Optional[types.TracebackType]) -&gt;None:
<span class="gu">@@ -322,7 +363,12 @@ class Semaphore(_TimeoutGarbageCollector):</span>

<span class="w"> </span>    def release(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Increment the counter and wake one waiter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._value += 1</span>
<span class="gi">+        while self._waiters:</span>
<span class="gi">+            waiter = self._waiters.popleft()</span>
<span class="gi">+            if not waiter.done():</span>
<span class="gi">+                future_set_result_unless_cancelled(waiter, _ReleasingContextManager(self))</span>
<span class="gi">+                break</span>

<span class="w"> </span>    def acquire(self, timeout: Optional[Union[float, datetime.timedelta]]=None
<span class="w"> </span>        ) -&gt;Awaitable[_ReleasingContextManager]:
<span class="gu">@@ -331,7 +377,25 @@ class Semaphore(_TimeoutGarbageCollector):</span>
<span class="w"> </span>        Block if the counter is zero and wait for a `.release`. The awaitable
<span class="w"> </span>        raises `.TimeoutError` after the deadline.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value &gt; 0:</span>
<span class="gi">+            self._value -= 1</span>
<span class="gi">+            future = Future()</span>
<span class="gi">+            future.set_result(_ReleasingContextManager(self))</span>
<span class="gi">+            return future</span>
<span class="gi">+</span>
<span class="gi">+        waiter = Future()</span>
<span class="gi">+        self._waiters.append(waiter)</span>
<span class="gi">+</span>
<span class="gi">+        if timeout:</span>
<span class="gi">+            def on_timeout():</span>
<span class="gi">+                self._waiters.remove(waiter)</span>
<span class="gi">+                if not waiter.done():</span>
<span class="gi">+                    waiter.set_exception(gen.TimeoutError())</span>
<span class="gi">+            io_loop = ioloop.IOLoop.current()</span>
<span class="gi">+            timeout_handle = io_loop.add_timeout(timeout, on_timeout)</span>
<span class="gi">+            waiter.add_done_callback(lambda _: io_loop.remove_timeout(timeout_handle))</span>
<span class="gi">+</span>
<span class="gi">+        return waiter</span>

<span class="w"> </span>    def __enter__(self) -&gt;None:
<span class="w"> </span>        raise RuntimeError(&quot;Use &#39;async with&#39; instead of &#39;with&#39; for Semaphore&quot;)
<span class="gu">@@ -364,7 +428,9 @@ class BoundedSemaphore(Semaphore):</span>

<span class="w"> </span>    def release(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Increment the counter and wake one waiter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value &gt;= self._initial_value:</span>
<span class="gi">+            raise ValueError(&quot;Semaphore released too many times&quot;)</span>
<span class="gi">+        super().release()</span>


<span class="w"> </span>class Lock(object):
<span class="gu">@@ -417,7 +483,7 @@ class Lock(object):</span>
<span class="w"> </span>        Returns an awaitable, which raises `tornado.util.TimeoutError` after a
<span class="w"> </span>        timeout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._block.acquire(timeout)</span>

<span class="w"> </span>    def release(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Unlock.
<span class="gu">@@ -426,7 +492,10 @@ class Lock(object):</span>

<span class="w"> </span>        If not locked, raise a `RuntimeError`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._block.release()</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise RuntimeError(&quot;release unlocked lock&quot;)</span>

<span class="w"> </span>    def __enter__(self) -&gt;None:
<span class="w"> </span>        raise RuntimeError(&#39;Use `async with` instead of `with` for Lock&#39;)
<span class="gh">diff --git a/tornado/log.py b/tornado/log.py</span>
<span class="gh">index 6e3e6e4d..219c9bf2 100644</span>
<span class="gd">--- a/tornado/log.py</span>
<span class="gi">+++ b/tornado/log.py</span>
<span class="gu">@@ -111,7 +111,39 @@ def enable_pretty_logging(options: Any=None, logger: Optional[logging.</span>
<span class="w"> </span>    This is called automatically by `tornado.options.parse_command_line`
<span class="w"> </span>    and `tornado.options.parse_config_file`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if options is None:</span>
<span class="gi">+        from tornado.options import options</span>
<span class="gi">+    if options.logging == &#39;none&#39;:</span>
<span class="gi">+        return</span>
<span class="gi">+    if logger is None:</span>
<span class="gi">+        logger = logging.getLogger()</span>
<span class="gi">+    logger.setLevel(getattr(logging, options.logging.upper()))</span>
<span class="gi">+    if options.log_file_prefix:</span>
<span class="gi">+        rotate_mode = options.log_rotate_mode</span>
<span class="gi">+        if rotate_mode == &#39;size&#39;:</span>
<span class="gi">+            channel = logging.handlers.RotatingFileHandler(</span>
<span class="gi">+                filename=options.log_file_prefix,</span>
<span class="gi">+                maxBytes=options.log_file_max_size,</span>
<span class="gi">+                backupCount=options.log_file_num_backups)</span>
<span class="gi">+        elif rotate_mode == &#39;time&#39;:</span>
<span class="gi">+            channel = logging.handlers.TimedRotatingFileHandler(</span>
<span class="gi">+                filename=options.log_file_prefix,</span>
<span class="gi">+                when=options.log_rotate_when,</span>
<span class="gi">+                interval=options.log_rotate_interval,</span>
<span class="gi">+                backupCount=options.log_file_num_backups)</span>
<span class="gi">+        else:</span>
<span class="gi">+            error_message = &#39;The value of log_rotate_mode option should be &#39; \</span>
<span class="gi">+                            &#39;&quot;size&quot; or &quot;time&quot;, not &quot;%s&quot;&#39; % rotate_mode</span>
<span class="gi">+            raise ValueError(error_message)</span>
<span class="gi">+        channel.setFormatter(LogFormatter(color=False))</span>
<span class="gi">+        logger.addHandler(channel)</span>
<span class="gi">+</span>
<span class="gi">+    if (options.log_to_stderr or</span>
<span class="gi">+            (options.log_to_stderr is None and not logger.handlers)):</span>
<span class="gi">+        # Set up color if we are in a tty and curses is installed</span>
<span class="gi">+        channel = logging.StreamHandler()</span>
<span class="gi">+        channel.setFormatter(LogFormatter())</span>
<span class="gi">+        logger.addHandler(channel)</span>


<span class="w"> </span>def define_logging_options(options: Any=None) -&gt;None:
<span class="gu">@@ -123,4 +155,32 @@ def define_logging_options(options: Any=None) -&gt;None:</span>
<span class="w"> </span>    .. versionadded:: 4.2
<span class="w"> </span>        This function existed in prior versions but was broken and undocumented until 4.2.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if options is None:</span>
<span class="gi">+        # late import to prevent cyclic dependencies</span>
<span class="gi">+        from tornado.options import options</span>
<span class="gi">+    options.define(&quot;logging&quot;, default=&quot;info&quot;,</span>
<span class="gi">+                   help=(&quot;Set the Python log level. If &#39;none&#39;, tornado won&#39;t touch the &quot;</span>
<span class="gi">+                         &quot;logging configuration.&quot;),</span>
<span class="gi">+                   metavar=&quot;debug|info|warning|error|none&quot;)</span>
<span class="gi">+    options.define(&quot;log_to_stderr&quot;, type=bool, default=None,</span>
<span class="gi">+                   help=(&quot;Send log output to stderr (colorized if possible). &quot;</span>
<span class="gi">+                         &quot;By default use stderr if --log_file_prefix is not set and &quot;</span>
<span class="gi">+                         &quot;no other logging is configured.&quot;))</span>
<span class="gi">+    options.define(&quot;log_file_prefix&quot;, type=str, default=None, metavar=&quot;PATH&quot;,</span>
<span class="gi">+                   help=(&quot;Path prefix for log files. &quot;</span>
<span class="gi">+                         &quot;Note that if you are running multiple tornado processes, &quot;</span>
<span class="gi">+                         &quot;log_file_prefix must be different for each of them (e.g. &quot;</span>
<span class="gi">+                         &quot;include the port number)&quot;))</span>
<span class="gi">+    options.define(&quot;log_file_max_size&quot;, type=int, default=100 * 1000 * 1000,</span>
<span class="gi">+                   help=&quot;max size of log files before rollover&quot;)</span>
<span class="gi">+    options.define(&quot;log_file_num_backups&quot;, type=int, default=10,</span>
<span class="gi">+                   help=&quot;number of log files to keep&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    options.define(&quot;log_rotate_when&quot;, type=str, default=&#39;midnight&#39;,</span>
<span class="gi">+                   help=(&quot;specify the type of TimedRotatingFileHandler interval &quot;</span>
<span class="gi">+                         &quot;other options:(&#39;S&#39;, &#39;M&#39;, &#39;H&#39;, &#39;D&#39;, &#39;W0&#39;-&#39;W6&#39;)&quot;))</span>
<span class="gi">+    options.define(&quot;log_rotate_interval&quot;, type=int, default=1,</span>
<span class="gi">+                   help=&quot;The interval value of timed rotating&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    options.define(&quot;log_rotate_mode&quot;, type=str, default=&#39;size&#39;,</span>
<span class="gi">+                   help=&quot;The mode of rotating files(time or size)&quot;)</span>
<span class="gh">diff --git a/tornado/netutil.py b/tornado/netutil.py</span>
<span class="gh">index 5afa2659..157cf785 100644</span>
<span class="gd">--- a/tornado/netutil.py</span>
<span class="gi">+++ b/tornado/netutil.py</span>
<span class="gu">@@ -47,7 +47,40 @@ def bind_sockets(port: int, address: Optional[str]=None, family: socket.</span>
<span class="w"> </span>    in the list. If your platform doesn&#39;t support this option ValueError will
<span class="w"> </span>    be raised.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sockets = []</span>
<span class="gi">+    if address == &quot;&quot;:</span>
<span class="gi">+        address = None</span>
<span class="gi">+    if not socket.has_ipv6 and family == socket.AF_UNSPEC:</span>
<span class="gi">+        family = socket.AF_INET</span>
<span class="gi">+    if flags is None:</span>
<span class="gi">+        flags = socket.AI_PASSIVE</span>
<span class="gi">+    for res in socket.getaddrinfo(address, port, family, socket.SOCK_STREAM,</span>
<span class="gi">+                                  0, flags):</span>
<span class="gi">+        af, socktype, proto, canonname, sockaddr = res</span>
<span class="gi">+        try:</span>
<span class="gi">+            sock = socket.socket(af, socktype, proto)</span>
<span class="gi">+        except socket.error as e:</span>
<span class="gi">+            continue</span>
<span class="gi">+        set_close_exec(sock.fileno())</span>
<span class="gi">+        if os.name != &#39;nt&#39;:</span>
<span class="gi">+            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span>
<span class="gi">+        if reuse_port:</span>
<span class="gi">+            try:</span>
<span class="gi">+                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                raise ValueError(&quot;reuse_port not supported on this platform&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            sock.bind(sockaddr)</span>
<span class="gi">+        except socket.error as e:</span>
<span class="gi">+            sock.close()</span>
<span class="gi">+            if e.errno == errno.EADDRINUSE:</span>
<span class="gi">+                raise</span>
<span class="gi">+            continue</span>
<span class="gi">+        sock.listen(backlog)</span>
<span class="gi">+        sockets.append(sock)</span>
<span class="gi">+    if not sockets:</span>
<span class="gi">+        raise socket.error(&quot;Could not bind to any available socket&quot;)</span>
<span class="gi">+    return sockets</span>


<span class="w"> </span>if hasattr(socket, &#39;AF_UNIX&#39;):
<span class="gu">@@ -63,7 +96,22 @@ if hasattr(socket, &#39;AF_UNIX&#39;):</span>
<span class="w"> </span>        Returns a socket object (not a list of socket objects like
<span class="w"> </span>        `bind_sockets`)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span>
<span class="gi">+        set_close_exec(sock.fileno())</span>
<span class="gi">+        try:</span>
<span class="gi">+            sock.bind(file)</span>
<span class="gi">+        except OSError as e:</span>
<span class="gi">+            if errno_from_exception(e) == errno.EADDRINUSE:</span>
<span class="gi">+                if os.path.exists(file):</span>
<span class="gi">+                    os.unlink(file)</span>
<span class="gi">+                    sock.bind(file)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise</span>
<span class="gi">+        os.chmod(file, mode)</span>
<span class="gi">+        sock.listen(backlog)</span>
<span class="gi">+        return sock</span>


<span class="w"> </span>def add_accept_handler(sock: socket.socket, callback: Callable[[socket.
<span class="gu">@@ -85,7 +133,25 @@ def add_accept_handler(sock: socket.socket, callback: Callable[[socket.</span>
<span class="w"> </span>    .. versionchanged:: 5.0
<span class="w"> </span>       A callable is returned (``None`` was returned before).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    io_loop = IOLoop.current()</span>
<span class="gi">+</span>
<span class="gi">+    def accept_handler(fd: int, events: int) -&gt; None:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                connection, address = sock.accept()</span>
<span class="gi">+            except BlockingIOError:</span>
<span class="gi">+                return</span>
<span class="gi">+            except socket.error as e:</span>
<span class="gi">+                if errno_from_exception(e) in (errno.ECONNABORTED, errno.EMFILE):</span>
<span class="gi">+                    return</span>
<span class="gi">+                raise</span>
<span class="gi">+            callback(connection, address)</span>
<span class="gi">+</span>
<span class="gi">+    def remove_handler() -&gt; None:</span>
<span class="gi">+        io_loop.remove_handler(sock.fileno())</span>
<span class="gi">+</span>
<span class="gi">+    io_loop.add_handler(sock.fileno(), accept_handler, IOLoop.READ)</span>
<span class="gi">+    return remove_handler</span>


<span class="w"> </span>def is_valid_ip(ip: str) -&gt;bool:
<span class="gu">@@ -93,7 +159,15 @@ def is_valid_ip(ip: str) -&gt;bool:</span>

<span class="w"> </span>    Supports IPv4 and IPv6.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        socket.inet_pton(socket.AF_INET, ip)</span>
<span class="gi">+        return True</span>
<span class="gi">+    except socket.error:</span>
<span class="gi">+        try:</span>
<span class="gi">+            socket.inet_pton(socket.AF_INET6, ip)</span>
<span class="gi">+            return True</span>
<span class="gi">+        except socket.error:</span>
<span class="gi">+            return False</span>


<span class="w"> </span>class Resolver(Configurable):
<span class="gh">diff --git a/tornado/options.py b/tornado/options.py</span>
<span class="gh">index 9356e4bd..fe29e473 100644</span>
<span class="gd">--- a/tornado/options.py</span>
<span class="gi">+++ b/tornado/options.py</span>
<span class="gu">@@ -143,14 +143,14 @@ class OptionParser(object):</span>

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ((name, self[name]) for name in self)</span>

<span class="w"> </span>    def groups(self) -&gt;Set[str]:
<span class="w"> </span>        &quot;&quot;&quot;The set of option-groups created by ``define``.

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return set(opt.group_name for opt in self._options.values() if opt.group_name)</span>

<span class="w"> </span>    def group_dict(self, group: str) -&gt;Dict[str, Any]:
<span class="w"> </span>        &quot;&quot;&quot;The names and values of options in a group.
<span class="gu">@@ -169,14 +169,15 @@ class OptionParser(object):</span>

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {name: self[name] for name, opt in self._options.items()</span>
<span class="gi">+                if opt.group_name == group}</span>

<span class="w"> </span>    def as_dict(self) -&gt;Dict[str, Any]:
<span class="w"> </span>        &quot;&quot;&quot;The names and values of all options.

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return dict(self.items())</span>

<span class="w"> </span>    def define(self, name: str, default: Any=None, type: Optional[type]=
<span class="w"> </span>        None, help: Optional[str]=None, metavar: Optional[str]=None,
<span class="gu">@@ -216,7 +217,27 @@ class OptionParser(object):</span>
<span class="w"> </span>        by later flags.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name in self._options:</span>
<span class="gi">+            raise Error(&quot;Option %r already defined in %s&quot; % (</span>
<span class="gi">+                name, self._options[name].file_name))</span>
<span class="gi">+</span>
<span class="gi">+        frame = sys._getframe(0)</span>
<span class="gi">+        options_file = frame.f_code.co_filename</span>
<span class="gi">+</span>
<span class="gi">+        if type is None:</span>
<span class="gi">+            if default is None:</span>
<span class="gi">+                type = str</span>
<span class="gi">+            else:</span>
<span class="gi">+                type = type(default)</span>
<span class="gi">+</span>
<span class="gi">+        if default is not None and not isinstance(default, type):</span>
<span class="gi">+            raise Error(&quot;Default value type should be %s (is %s)&quot; %</span>
<span class="gi">+                        (type, type(default)))</span>
<span class="gi">+</span>
<span class="gi">+        self._options[name] = _Option(name, file_name=options_file,</span>
<span class="gi">+                                      default=default, type=type, help=help,</span>
<span class="gi">+                                      metavar=metavar, multiple=multiple,</span>
<span class="gi">+                                      group_name=group, callback=callback)</span>

<span class="w"> </span>    def parse_command_line(self, args: Optional[List[str]]=None, final:
<span class="w"> </span>        bool=True) -&gt;List[str]:
<span class="gu">@@ -241,7 +262,40 @@ class OptionParser(object):</span>
<span class="w"> </span>        from multiple sources.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if args is None:</span>
<span class="gi">+            args = sys.argv</span>
<span class="gi">+        remaining = []</span>
<span class="gi">+        for i in range(1, len(args)):</span>
<span class="gi">+            arg = args[i]</span>
<span class="gi">+            if arg.startswith(&quot;--&quot;):</span>
<span class="gi">+                if &quot;=&quot; in arg:</span>
<span class="gi">+                    name, value = arg.split(&quot;=&quot;, 1)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    name, value = arg, &quot;true&quot;</span>
<span class="gi">+                name = name[2:]</span>
<span class="gi">+            else:</span>
<span class="gi">+                remaining.append(arg)</span>
<span class="gi">+                continue</span>
<span class="gi">+            name = self._normalize_name(name)</span>
<span class="gi">+            if name in self._options:</span>
<span class="gi">+                option = self._options[name]</span>
<span class="gi">+                if option.multiple:</span>
<span class="gi">+                    if option.type == int:</span>
<span class="gi">+                        values = []</span>
<span class="gi">+                        for part in value.split(&quot;,&quot;):</span>
<span class="gi">+                            if &quot;:&quot; in part:</span>
<span class="gi">+                                low, high = part.split(&quot;:&quot;)</span>
<span class="gi">+                                values.extend(range(int(low), int(high)))</span>
<span class="gi">+                            else:</span>
<span class="gi">+                                values.append(int(part))</span>
<span class="gi">+                        option.set(values)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        option.set(value.split(&quot;,&quot;))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    option.set(value)</span>
<span class="gi">+        if final:</span>
<span class="gi">+            self.run_parse_callbacks()</span>
<span class="gi">+        return remaining</span>

<span class="w"> </span>    def parse_config_file(self, path: str, final: bool=True) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Parses and loads the config file at the given path.
<span class="gu">@@ -289,15 +343,43 @@ class OptionParser(object):</span>
<span class="w"> </span>           Added the ability to set options via strings in config files.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        config = {}</span>
<span class="gi">+        with open(path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+            exec_in(f.read(), config, dict(__file__=path))</span>
<span class="gi">+</span>
<span class="gi">+        for name in config:</span>
<span class="gi">+            if name in self._options:</span>
<span class="gi">+                self._options[name].set(config[name])</span>
<span class="gi">+</span>
<span class="gi">+        if final:</span>
<span class="gi">+            self.run_parse_callbacks()</span>

<span class="w"> </span>    def print_help(self, file: Optional[TextIO]=None) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Prints all the command line options to stderr (or another file).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if file is None:</span>
<span class="gi">+            file = sys.stderr</span>
<span class="gi">+        print(&quot;Usage: %s [OPTIONS]&quot; % sys.argv[0], file=file)</span>
<span class="gi">+        print(&quot;\nOptions:\n&quot;, file=file)</span>
<span class="gi">+        by_group = {}</span>
<span class="gi">+        for option in self._options.values():</span>
<span class="gi">+            by_group.setdefault(option.group_name, []).append(option)</span>
<span class="gi">+</span>
<span class="gi">+        for filename, o in sorted(by_group.items()):</span>
<span class="gi">+            if filename:</span>
<span class="gi">+                print(&quot;\n%s options:\n&quot; % os.path.normpath(filename), file=file)</span>
<span class="gi">+            o.sort(key=lambda option: option.name)</span>
<span class="gi">+            for option in o:</span>
<span class="gi">+                prefix = option.name</span>
<span class="gi">+                if option.metavar:</span>
<span class="gi">+                    prefix += &quot;=&quot; + option.metavar</span>
<span class="gi">+                description = option.help or &quot;&quot;</span>
<span class="gi">+                if option.default is not None and option.default != &#39;&#39;:</span>
<span class="gi">+                    description += &quot; (default %s)&quot; % option.default</span>
<span class="gi">+                print(&quot;  --%-30s %s&quot; % (prefix, description), file=file)</span>

<span class="w"> </span>    def add_parse_callback(self, callback: Callable[[], None]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Adds a parse callback, to be invoked when option parsing is done.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._parse_callbacks.append(callback)</span>

<span class="w"> </span>    def mockable(self) -&gt;&#39;_Mockable&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Returns a wrapper around self that is compatible with
<span class="gu">@@ -314,7 +396,7 @@ class OptionParser(object):</span>
<span class="w"> </span>            with mock.patch.object(options.mockable(), &#39;name&#39;, value):
<span class="w"> </span>                assert options.name == value
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _Mockable(self)</span>


<span class="w"> </span>class _Mockable(object):
<span class="gh">diff --git a/tornado/platform/asyncio.py b/tornado/platform/asyncio.py</span>
<span class="gh">index e67cf2ca..c0d1cd75 100644</span>
<span class="gd">--- a/tornado/platform/asyncio.py</span>
<span class="gi">+++ b/tornado/platform/asyncio.py</span>
<span class="gu">@@ -103,7 +103,7 @@ def to_tornado_future(asyncio_future: asyncio.Future) -&gt;asyncio.Future:</span>
<span class="w"> </span>       Tornado ``Futures`` have been merged with `asyncio.Future`,
<span class="w"> </span>       so this method is now a no-op.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return asyncio_future</span>


<span class="w"> </span>def to_asyncio_future(tornado_future: asyncio.Future) -&gt;asyncio.Future:
<span class="gu">@@ -119,7 +119,7 @@ def to_asyncio_future(tornado_future: asyncio.Future) -&gt;asyncio.Future:</span>
<span class="w"> </span>       Tornado ``Futures`` have been merged with `asyncio.Future`,
<span class="w"> </span>       so this method is now equivalent to `tornado.gen.convert_yielded`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return convert_yielded(tornado_future)</span>


<span class="w"> </span>if sys.platform == &#39;win32&#39; and hasattr(asyncio,
<span class="gh">diff --git a/tornado/platform/twisted.py b/tornado/platform/twisted.py</span>
<span class="gh">index 4546b24f..b8f3ab23 100644</span>
<span class="gd">--- a/tornado/platform/twisted.py</span>
<span class="gi">+++ b/tornado/platform/twisted.py</span>
<span class="gu">@@ -41,6 +41,28 @@ class TwistedResolver(Resolver):</span>
<span class="w"> </span>       thread-based resolver instead.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def __init__(self):</span>
<span class="gi">+        self.resolver = twisted.names.client.createResolver()</span>
<span class="gi">+</span>
<span class="gi">+    def resolve(self, host, port, family=socket.AF_UNSPEC):</span>
<span class="gi">+        future = Future()</span>
<span class="gi">+        if family != socket.AF_UNSPEC and family != socket.AF_INET and family != socket.AF_INET6:</span>
<span class="gi">+            future.set_exception(NotImplementedError(&quot;Unsupported family&quot;))</span>
<span class="gi">+            return future</span>
<span class="gi">+</span>
<span class="gi">+        def callback(result):</span>
<span class="gi">+            if result:</span>
<span class="gi">+                future.set_result([(family, (result[0][1], port))])</span>
<span class="gi">+            else:</span>
<span class="gi">+                future.set_exception(IOError(&quot;Resolution failed&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        def errback(failure):</span>
<span class="gi">+            future.set_exception(failure.value)</span>
<span class="gi">+</span>
<span class="gi">+        d = self.resolver.getHostByName(utf8(host))</span>
<span class="gi">+        d.addCallbacks(callback, errback)</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>

<span class="w"> </span>def install() -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Install ``AsyncioSelectorReactor`` as the default Twisted reactor.
<span class="gu">@@ -61,7 +83,7 @@ def install() -&gt;None:</span>
<span class="w"> </span>       ``asyncio`` reactor instead.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    twisted.internet.asyncioreactor.install()</span>


<span class="w"> </span>if hasattr(gen.convert_yielded, &#39;register&#39;):
<span class="gh">diff --git a/tornado/process.py b/tornado/process.py</span>
<span class="gh">index 3afe7dc4..d03c5bdf 100644</span>
<span class="gd">--- a/tornado/process.py</span>
<span class="gi">+++ b/tornado/process.py</span>
<span class="gu">@@ -22,7 +22,7 @@ CalledProcessError = subprocess.CalledProcessError</span>

<span class="w"> </span>def cpu_count() -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Returns the number of processors on this machine.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return multiprocessing.cpu_count()</span>


<span class="w"> </span>_task_id = None
<span class="gu">@@ -57,7 +57,82 @@ def fork_processes(num_processes: Optional[int], max_restarts: Optional[int</span>

<span class="w"> </span>    Availability: Unix
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _task_id</span>
<span class="gi">+    if max_restarts is None:</span>
<span class="gi">+        max_restarts = 100</span>
<span class="gi">+</span>
<span class="gi">+    if num_processes is None or num_processes &lt;= 0:</span>
<span class="gi">+        num_processes = cpu_count()</span>
<span class="gi">+</span>
<span class="gi">+    if ioloop.IOLoop.initialized():</span>
<span class="gi">+        raise RuntimeError(&quot;Cannot run in multiple processes: IOLoop instance &quot;</span>
<span class="gi">+                           &quot;has already been initialized. You cannot call &quot;</span>
<span class="gi">+                           &quot;IOLoop.instance() before calling fork_processes()&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def start_child(i):</span>
<span class="gi">+        _task_id = i</span>
<span class="gi">+        return i</span>
<span class="gi">+</span>
<span class="gi">+    def exit_callback(pid, status):</span>
<span class="gi">+        if os.WIFSIGNALED(status):</span>
<span class="gi">+            gen_log.warning(&quot;child %d (pid %d) killed by signal %d, restarting&quot;,</span>
<span class="gi">+                            _task_id, pid, os.WTERMSIG(status))</span>
<span class="gi">+        elif os.WEXITSTATUS(status) != 0:</span>
<span class="gi">+            gen_log.warning(&quot;child %d (pid %d) exited with status %d, restarting&quot;,</span>
<span class="gi">+                            _task_id, pid, os.WEXITSTATUS(status))</span>
<span class="gi">+        else:</span>
<span class="gi">+            gen_log.info(&quot;child %d (pid %d) exited normally&quot;, _task_id, pid)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        remaining_restarts = max_restarts - 1</span>
<span class="gi">+        if remaining_restarts &gt; 0:</span>
<span class="gi">+            fork_processes(num_processes, max_restarts=remaining_restarts)</span>
<span class="gi">+        else:</span>
<span class="gi">+            gen_log.error(&quot;child %d (pid %d) exited after too many restarts&quot;,</span>
<span class="gi">+                          _task_id, pid)</span>
<span class="gi">+</span>
<span class="gi">+    if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+        # Windows doesn&#39;t support fork()</span>
<span class="gi">+        raise NotImplementedError(&quot;fork_processes not implemented on Windows&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    children = {}</span>
<span class="gi">+</span>
<span class="gi">+    def handle_child():</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                pid, status = os.waitpid(-1, os.WNOHANG)</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                return</span>
<span class="gi">+            if pid == 0:</span>
<span class="gi">+                return</span>
<span class="gi">+            if pid in children:</span>
<span class="gi">+                exit_callback(pid, status)</span>
<span class="gi">+                del children[pid]</span>
<span class="gi">+</span>
<span class="gi">+    signal.signal(signal.SIGCHLD, lambda sig, frame: handle_child())</span>
<span class="gi">+</span>
<span class="gi">+    for i in range(num_processes):</span>
<span class="gi">+        pid = os.fork()</span>
<span class="gi">+        if pid == 0:</span>
<span class="gi">+            # child process</span>
<span class="gi">+            return start_child(i)</span>
<span class="gi">+        else:</span>
<span class="gi">+            children[pid] = i</span>
<span class="gi">+</span>
<span class="gi">+    while children:</span>
<span class="gi">+        try:</span>
<span class="gi">+            pid, status = os.wait()</span>
<span class="gi">+        except OSError as e:</span>
<span class="gi">+            if e.errno == errno.EINTR:</span>
<span class="gi">+                continue</span>
<span class="gi">+            raise</span>
<span class="gi">+        if pid not in children:</span>
<span class="gi">+            continue</span>
<span class="gi">+        exit_callback(pid, status)</span>
<span class="gi">+        del children[pid]</span>
<span class="gi">+</span>
<span class="gi">+    # All child processes have exited, so exit the parent process</span>
<span class="gi">+    sys.exit(0)</span>


<span class="w"> </span>def task_id() -&gt;Optional[int]:
<span class="gu">@@ -65,7 +140,8 @@ def task_id() -&gt;Optional[int]:</span>

<span class="w"> </span>    Returns None if this process was not created by `fork_processes`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _task_id</span>
<span class="gi">+    return _task_id</span>


<span class="w"> </span>class Subprocess(object):
<span class="gu">@@ -147,7 +223,9 @@ class Subprocess(object):</span>

<span class="w"> </span>        Availability: Unix
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._exit_callback = callback</span>
<span class="gi">+        Subprocess.initialize()</span>
<span class="gi">+        Subprocess._waiting[self.pid] = self</span>

<span class="w"> </span>    def wait_for_exit(self, raise_error: bool=True) -&gt;&#39;Future[int]&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Returns a `.Future` which resolves when the process exits.
<span class="gu">@@ -167,7 +245,15 @@ class Subprocess(object):</span>

<span class="w"> </span>        Availability: Unix
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        future = Future()</span>
<span class="gi">+        self.set_exit_callback(lambda returncode: self._set_wait_for_exit_future(future, returncode, raise_error))</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    def _set_wait_for_exit_future(self, future, returncode, raise_error):</span>
<span class="gi">+        if raise_error and returncode != 0:</span>
<span class="gi">+            future_set_exception_unless_cancelled(future, CalledProcessError(returncode, str(self.pid)))</span>
<span class="gi">+        else:</span>
<span class="gi">+            future_set_result_unless_cancelled(future, returncode)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def initialize(cls) -&gt;None:
<span class="gu">@@ -184,9 +270,18 @@ class Subprocess(object):</span>

<span class="w"> </span>        Availability: Unix
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cls._initialized:</span>
<span class="gi">+            return</span>
<span class="gi">+        cls._initialized = True</span>
<span class="gi">+        io_loop = ioloop.IOLoop.current()</span>
<span class="gi">+        def handle_sigchld(*args):</span>
<span class="gi">+            io_loop.add_callback_from_signal(cls._cleanup)</span>
<span class="gi">+        signal.signal(signal.SIGCHLD, handle_sigchld)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def uninitialize(cls) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Removes the ``SIGCHLD`` handler.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not cls._initialized:</span>
<span class="gi">+            return</span>
<span class="gi">+        cls._initialized = False</span>
<span class="gi">+        signal.signal(signal.SIGCHLD, signal.SIG_DFL)</span>
<span class="gh">diff --git a/tornado/queues.py b/tornado/queues.py</span>
<span class="gh">index fde4734a..8db3aba7 100644</span>
<span class="gd">--- a/tornado/queues.py</span>
<span class="gi">+++ b/tornado/queues.py</span>
<span class="gu">@@ -128,11 +128,11 @@ class Queue(Generic[_T]):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def maxsize(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Number of items allowed in the queue.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._maxsize</span>

<span class="w"> </span>    def qsize(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Number of items in the queue.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self._queue)</span>

<span class="w"> </span>    def put(self, item: _T, timeout: Optional[Union[float, datetime.
<span class="w"> </span>        timedelta]]=None) -&gt;&#39;Future[None]&#39;:
<span class="gu">@@ -146,14 +146,35 @@ class Queue(Generic[_T]):</span>
<span class="w"> </span>        `datetime.timedelta` object for a deadline relative to the
<span class="w"> </span>        current time.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        future = Future()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.put_nowait(item)</span>
<span class="gi">+        except QueueFull:</span>
<span class="gi">+            self._putters.append((item, future))</span>
<span class="gi">+            ioloop.IOLoop.current().add_timeout(timeout, self._put_timeout, future)</span>
<span class="gi">+        else:</span>
<span class="gi">+            future_set_result_unless_cancelled(future, None)</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    def _put_timeout(self, future):</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._putters.remove((future.item, future))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            future.set_exception(gen.TimeoutError())</span>

<span class="w"> </span>    def put_nowait(self, item: _T) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Put an item into the queue without blocking.

<span class="w"> </span>        If no free slot is immediately available, raise `QueueFull`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._maxsize &gt; 0 and len(self._queue) &gt;= self._maxsize:</span>
<span class="gi">+            raise QueueFull()</span>
<span class="gi">+        self._queue.append(item)</span>
<span class="gi">+        self._unfinished_tasks += 1</span>
<span class="gi">+        self._finished.clear()</span>
<span class="gi">+        self._consume()</span>

<span class="w"> </span>    def get(self, timeout: Optional[Union[float, datetime.timedelta]]=None
<span class="w"> </span>        ) -&gt;Awaitable[_T]:
<span class="gu">@@ -177,7 +198,21 @@ class Queue(Generic[_T]):</span>
<span class="w"> </span>           with other timeouts in Tornado).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        future = Future()</span>
<span class="gi">+        try:</span>
<span class="gi">+            future.set_result(self.get_nowait())</span>
<span class="gi">+        except QueueEmpty:</span>
<span class="gi">+            self._getters.append(future)</span>
<span class="gi">+            ioloop.IOLoop.current().add_timeout(timeout, self._get_timeout, future)</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    def _get_timeout(self, future):</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._getters.remove(future)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            future.set_exception(gen.TimeoutError())</span>

<span class="w"> </span>    def get_nowait(self) -&gt;_T:
<span class="w"> </span>        &quot;&quot;&quot;Remove and return an item from the queue without blocking.
<span class="gu">@@ -185,7 +220,11 @@ class Queue(Generic[_T]):</span>
<span class="w"> </span>        Return an item if one is immediately available, else raise
<span class="w"> </span>        `QueueEmpty`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._queue:</span>
<span class="gi">+            raise QueueEmpty()</span>
<span class="gi">+        item = self._queue.popleft()</span>
<span class="gi">+        self._consume()</span>
<span class="gi">+        return item</span>

<span class="w"> </span>    def task_done(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Indicate that a formerly enqueued task is complete.
<span class="gu">@@ -199,7 +238,11 @@ class Queue(Generic[_T]):</span>

<span class="w"> </span>        Raises `ValueError` if called more times than `.put`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._unfinished_tasks &lt;= 0:</span>
<span class="gi">+            raise ValueError(&#39;task_done() called too many times&#39;)</span>
<span class="gi">+        self._unfinished_tasks -= 1</span>
<span class="gi">+        if self._unfinished_tasks == 0:</span>
<span class="gi">+            self._finished.set()</span>

<span class="w"> </span>    def join(self, timeout: Optional[Union[float, datetime.timedelta]]=None
<span class="w"> </span>        ) -&gt;Awaitable[None]:
<span class="gu">@@ -208,7 +251,7 @@ class Queue(Generic[_T]):</span>
<span class="w"> </span>        Returns an awaitable, which raises `tornado.util.TimeoutError` after a
<span class="w"> </span>        timeout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._finished.wait(timeout)</span>

<span class="w"> </span>    def __aiter__(self) -&gt;_QueueIterator[_T]:
<span class="w"> </span>        return _QueueIterator(self)
<span class="gu">@@ -220,6 +263,20 @@ class Queue(Generic[_T]):</span>
<span class="w"> </span>    def __str__(self) -&gt;str:
<span class="w"> </span>        return &#39;&lt;%s %s&gt;&#39; % (type(self).__name__, self._format())

<span class="gi">+    def _consume(self):</span>
<span class="gi">+        while self._putters and self._getters:</span>
<span class="gi">+            item, putter = self._putters.popleft()</span>
<span class="gi">+            getter = self._getters.popleft()</span>
<span class="gi">+            self._queue.append(item)</span>
<span class="gi">+            future_set_result_unless_cancelled(putter, None)</span>
<span class="gi">+            future_set_result_unless_cancelled(getter, self._queue.popleft())</span>
<span class="gi">+</span>
<span class="gi">+    def _init(self):</span>
<span class="gi">+        self._queue = collections.deque()</span>
<span class="gi">+</span>
<span class="gi">+    def _format(self):</span>
<span class="gi">+        return &#39;maxsize=%r&#39; % (self.maxsize,)</span>
<span class="gi">+</span>

<span class="w"> </span>class PriorityQueue(Queue):
<span class="w"> </span>    &quot;&quot;&quot;A `.Queue` that retrieves entries in priority order, lowest first.
<span class="gu">@@ -250,6 +307,9 @@ class PriorityQueue(Queue):</span>
<span class="w"> </span>        (10, &#39;low-priority item&#39;)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def _init(self):</span>
<span class="gi">+        self._queue = []</span>
<span class="gi">+</span>

<span class="w"> </span>class LifoQueue(Queue):
<span class="w"> </span>    &quot;&quot;&quot;A `.Queue` that retrieves the most recently put items first.
<span class="gu">@@ -277,3 +337,9 @@ class LifoQueue(Queue):</span>
<span class="w"> </span>        2
<span class="w"> </span>        3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def _init(self):</span>
<span class="gi">+        self._queue = []</span>
<span class="gi">+</span>
<span class="gi">+    def _get(self):</span>
<span class="gi">+        return self._queue.pop()</span>
<span class="gh">diff --git a/tornado/routing.py b/tornado/routing.py</span>
<span class="gh">index 111cbaaa..ec318117 100644</span>
<span class="gd">--- a/tornado/routing.py</span>
<span class="gi">+++ b/tornado/routing.py</span>
<span class="gu">@@ -264,7 +264,11 @@ class RuleRouter(Router):</span>
<span class="w"> </span>        :arg rules: a list of Rule instances (or tuples of arguments, which are
<span class="w"> </span>            passed to Rule constructor).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for rule in rules:</span>
<span class="gi">+            if isinstance(rule, Rule):</span>
<span class="gi">+                self.rules.append(self.process_rule(rule))</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.rules.append(self.process_rule(Rule(*rule)))</span>

<span class="w"> </span>    def process_rule(self, rule: &#39;Rule&#39;) -&gt;&#39;Rule&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Override this method for additional preprocessing of each rule.
<span class="gu">@@ -272,7 +276,7 @@ class RuleRouter(Router):</span>
<span class="w"> </span>        :arg Rule rule: a rule to be processed.
<span class="w"> </span>        :returns: the same or modified Rule instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return rule</span>

<span class="w"> </span>    def get_target_delegate(self, target: Any, request: httputil.
<span class="w"> </span>        HTTPServerRequest, **target_params: Any) -&gt;Optional[httputil.
<span class="gu">@@ -286,7 +290,13 @@ class RuleRouter(Router):</span>
<span class="w"> </span>        :arg target_params: additional parameters that can be useful
<span class="w"> </span>            for `~.httputil.HTTPMessageDelegate` creation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(target, Router):</span>
<span class="gi">+            return target.find_handler(request, **target_params)</span>
<span class="gi">+        elif isinstance(target, httputil.HTTPServerConnectionDelegate):</span>
<span class="gi">+            return target.start_request(request.server_connection, request.connection)</span>
<span class="gi">+        elif callable(target):</span>
<span class="gi">+            return _CallableAdapter(target, request.connection)</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class ReversibleRuleRouter(ReversibleRouter, RuleRouter):
<span class="gu">@@ -349,16 +359,19 @@ class Matcher(object):</span>
<span class="w"> </span>            An empty dict is a valid (and common) return value to indicate a match
<span class="w"> </span>            when the argument-passing features are not used.
<span class="w"> </span>            ``None`` must be returned to indicate that there is no match.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {}</span>

<span class="w"> </span>    def reverse(self, *args: Any) -&gt;Optional[str]:
<span class="w"> </span>        &quot;&quot;&quot;Reconstructs full url from matcher instance and additional arguments.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class AnyMatches(Matcher):
<span class="w"> </span>    &quot;&quot;&quot;Matches any request.&quot;&quot;&quot;

<span class="gi">+    def match(self, request: httputil.HTTPServerRequest) -&gt;Optional[Dict[str, Any]]:</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>

<span class="w"> </span>class HostMatches(Matcher):
<span class="w"> </span>    &quot;&quot;&quot;Matches requests from hosts specified by ``host_pattern`` regex.&quot;&quot;&quot;
<span class="gu">@@ -371,6 +384,12 @@ class HostMatches(Matcher):</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.host_pattern = host_pattern

<span class="gi">+    def match(self, request: httputil.HTTPServerRequest) -&gt;Optional[Dict[str, Any]]:</span>
<span class="gi">+        host = request.host.lower().split(&#39;:&#39;)[0]</span>
<span class="gi">+        if self.host_pattern.match(host):</span>
<span class="gi">+            return {}</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="w"> </span>class DefaultHostMatches(Matcher):
<span class="w"> </span>    &quot;&quot;&quot;Matches requests from host that is equal to application&#39;s default_host.
<span class="gu">@@ -381,6 +400,14 @@ class DefaultHostMatches(Matcher):</span>
<span class="w"> </span>        self.application = application
<span class="w"> </span>        self.host_pattern = host_pattern

<span class="gi">+    def match(self, request: httputil.HTTPServerRequest) -&gt;Optional[Dict[str, Any]]:</span>
<span class="gi">+        if &quot;X-Real-Ip&quot; in request.headers:</span>
<span class="gi">+            return None</span>
<span class="gi">+        host = request.host.lower().split(&#39;:&#39;)[0]</span>
<span class="gi">+        if self.application.default_host and self.host_pattern.match(host):</span>
<span class="gi">+            return {}</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="w"> </span>class PathMatches(Matcher):
<span class="w"> </span>    &quot;&quot;&quot;Matches requests with paths specified by ``path_pattern`` regex.&quot;&quot;&quot;
<span class="gu">@@ -402,7 +429,21 @@ class PathMatches(Matcher):</span>
<span class="w"> </span>        For example: Given the url pattern /([0-9]{4})/([a-z-]+)/, this method
<span class="w"> </span>        would return (&#39;/%s/%s/&#39;, 2).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pattern = self.regex.pattern</span>
<span class="gi">+        if pattern.startswith(&#39;^&#39;):</span>
<span class="gi">+            pattern = pattern[1:]</span>
<span class="gi">+        if pattern.endswith(&#39;$&#39;):</span>
<span class="gi">+            pattern = pattern[:-1]</span>
<span class="gi">+</span>
<span class="gi">+        if not pattern.startswith(&#39;/&#39;):</span>
<span class="gi">+            pattern = &#39;/&#39; + pattern</span>
<span class="gi">+</span>
<span class="gi">+        group_count = self.regex.groups</span>
<span class="gi">+        if group_count == 0:</span>
<span class="gi">+            return (pattern, None)</span>
<span class="gi">+</span>
<span class="gi">+        reverse_pattern = re.sub(r&#39;\([^)]+\)&#39;, &#39;%s&#39;, pattern)</span>
<span class="gi">+        return (reverse_pattern, group_count)</span>


<span class="w"> </span>class URLSpec(Rule):
<span class="gu">@@ -450,4 +491,6 @@ def _unquote_or_none(s: Optional[str]) -&gt;Optional[bytes]:</span>
<span class="w"> </span>    Note that args are passed as bytes so the handler can decide what
<span class="w"> </span>    encoding to use.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if s is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return url_unescape(utf8(s), encoding=None, plus=False)</span>
<span class="gh">diff --git a/tornado/simple_httpclient.py b/tornado/simple_httpclient.py</span>
<span class="gh">index 5ce89b18..efe9f4fa 100644</span>
<span class="gd">--- a/tornado/simple_httpclient.py</span>
<span class="gi">+++ b/tornado/simple_httpclient.py</span>
<span class="gu">@@ -108,7 +108,12 @@ class SimpleAsyncHTTPClient(AsyncHTTPClient):</span>
<span class="w"> </span>        :arg object key: A simple object to mark the request.
<span class="w"> </span>        :info string key: More detailed timeout information.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        timeout_response = HTTPResponse(</span>
<span class="gi">+            self.request, 599, error=HTTPTimeoutError(&quot;Timeout&quot;),</span>
<span class="gi">+            request_time=self.io_loop.time() - self.start_time</span>
<span class="gi">+        )</span>
<span class="gi">+        self.final_callback(timeout_response)</span>
<span class="gi">+        self.release_callback()</span>


<span class="w"> </span>class _HTTPConnection(httputil.HTTPMessageDelegate):
<span class="gu">@@ -146,7 +151,14 @@ class _HTTPConnection(httputil.HTTPMessageDelegate):</span>

<span class="w"> </span>        :info string key: More detailed timeout information.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        message = &quot;Timeout&quot; if info is None else f&quot;Timeout: {info}&quot;</span>
<span class="gi">+        error = HTTPTimeoutError(message)</span>
<span class="gi">+        self.final_callback(HTTPResponse(</span>
<span class="gi">+            self.request, 599, error=error,</span>
<span class="gi">+            request_time=self.io_loop.time() - self.start_time</span>
<span class="gi">+        ))</span>
<span class="gi">+        if self.release_callback is not None:</span>
<span class="gi">+            self.release_callback()</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/tornado/tcpclient.py b/tornado/tcpclient.py</span>
<span class="gh">index 4e4fcdf6..862e623e 100644</span>
<span class="gd">--- a/tornado/tcpclient.py</span>
<span class="gi">+++ b/tornado/tcpclient.py</span>
<span class="gu">@@ -59,7 +59,10 @@ class _Connector(object):</span>
<span class="w"> </span>        be AF_INET and the other AF_INET6, although non-standard resolvers
<span class="w"> </span>        may return additional families).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        primary_family = addrinfo[0][0]</span>
<span class="gi">+        primary = [(af, addr) for af, addr in addrinfo if af == primary_family]</span>
<span class="gi">+        secondary = [(af, addr) for af, addr in addrinfo if af != primary_family]</span>
<span class="gi">+        return primary, secondary</span>


<span class="w"> </span>class TCPClient(object):
<span class="gu">@@ -107,4 +110,23 @@ class TCPClient(object):</span>
<span class="w"> </span>        .. versionchanged:: 5.0
<span class="w"> </span>           Added the ``timeout`` argument.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        addrinfo = await self.resolver.resolve(host, port, af)</span>
<span class="gi">+        connector = _Connector(addrinfo, self._create_stream)</span>
<span class="gi">+        stream = await gen.with_timeout(timeout or datetime.timedelta(seconds=_INITIAL_CONNECT_TIMEOUT),</span>
<span class="gi">+                                        connector.start())</span>
<span class="gi">+</span>
<span class="gi">+        if ssl_options is not None:</span>
<span class="gi">+            stream = await stream.start_tls(server_hostname=host, ssl_options=ssl_options)</span>
<span class="gi">+</span>
<span class="gi">+        if max_buffer_size is not None:</span>
<span class="gi">+            stream.set_max_buffer_size(max_buffer_size)</span>
<span class="gi">+</span>
<span class="gi">+        return stream</span>
<span class="gi">+</span>
<span class="gi">+    def _create_stream(self, af: socket.AddressFamily, addr: Tuple) -&gt; Tuple[IOStream, Future[IOStream]]:</span>
<span class="gi">+        sock = socket.socket(af)</span>
<span class="gi">+        stream = IOStream(sock)</span>
<span class="gi">+        if self.source_ip is not None:</span>
<span class="gi">+            sock.bind((self.source_ip, self.source_port or 0))</span>
<span class="gi">+        future = stream.connect(addr)</span>
<span class="gi">+        return stream, future</span>
<span class="gh">diff --git a/tornado/tcpserver.py b/tornado/tcpserver.py</span>
<span class="gh">index be5dca18..c5b4f7da 100644</span>
<span class="gd">--- a/tornado/tcpserver.py</span>
<span class="gi">+++ b/tornado/tcpserver.py</span>
<span class="gu">@@ -137,7 +137,9 @@ class TCPServer(object):</span>
<span class="w"> </span>           Added ``family``, ``backlog``, ``flags``, and ``reuse_port``
<span class="w"> </span>           arguments to match `tornado.netutil.bind_sockets`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sockets = bind_sockets(port, address=address, family=family,</span>
<span class="gi">+                               backlog=backlog, flags=flags, reuse_port=reuse_port)</span>
<span class="gi">+        self.add_sockets(sockets)</span>

<span class="w"> </span>    def add_sockets(self, sockets: Iterable[socket.socket]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Makes this server start accepting connections on the given sockets.
<span class="gu">@@ -148,11 +150,15 @@ class TCPServer(object):</span>
<span class="w"> </span>        method and `tornado.process.fork_processes` to provide greater
<span class="w"> </span>        control over the initialization of a multi-process server.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for sock in sockets:</span>
<span class="gi">+            self.add_socket(sock)</span>

<span class="w"> </span>    def add_socket(self, socket: socket.socket) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Singular version of `add_sockets`.  Takes a single socket object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._stopped:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._sockets[socket.fileno()] = socket</span>
<span class="gi">+        add_accept_handler(socket, self._handle_connection)</span>

<span class="w"> </span>    def bind(self, port: int, address: Optional[str]=None, family: socket.
<span class="w"> </span>        AddressFamily=socket.AF_UNSPEC, backlog: int=_DEFAULT_BACKLOG,
<span class="gu">@@ -187,7 +193,12 @@ class TCPServer(object):</span>
<span class="w"> </span>           Use either ``listen()`` or ``add_sockets()`` instead of ``bind()``
<span class="w"> </span>           and ``start()``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sockets = bind_sockets(port, address=address, family=family,</span>
<span class="gi">+                               backlog=backlog, flags=flags, reuse_port=reuse_port)</span>
<span class="gi">+        if self._started:</span>
<span class="gi">+            self.add_sockets(sockets)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._pending_sockets.extend(sockets)</span>

<span class="w"> </span>    def start(self, num_processes: Optional[int]=1, max_restarts: Optional[
<span class="w"> </span>        int]=None) -&gt;None:
<span class="gu">@@ -222,7 +233,13 @@ class TCPServer(object):</span>
<span class="w"> </span>           Use either ``listen()`` or ``add_sockets()`` instead of ``bind()``
<span class="w"> </span>           and ``start()``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert not self._started</span>
<span class="gi">+        self._started = True</span>
<span class="gi">+        if num_processes != 1:</span>
<span class="gi">+            process.fork_processes(num_processes, max_restarts)</span>
<span class="gi">+        sockets = self._pending_sockets</span>
<span class="gi">+        self._pending_sockets = []</span>
<span class="gi">+        self.add_sockets(sockets)</span>

<span class="w"> </span>    def stop(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Stops listening for new connections.
<span class="gu">@@ -230,7 +247,13 @@ class TCPServer(object):</span>
<span class="w"> </span>        Requests currently in progress may still continue after the
<span class="w"> </span>        server is stopped.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._stopped:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._stopped = True</span>
<span class="gi">+        for fd, sock in self._sockets.items():</span>
<span class="gi">+            assert sock.fileno() == fd</span>
<span class="gi">+            self._remove_handler(sock)</span>
<span class="gi">+            sock.close()</span>

<span class="w"> </span>    def handle_stream(self, stream: IOStream, address: tuple) -&gt;Optional[
<span class="w"> </span>        Awaitable[None]]:
<span class="gu">@@ -248,4 +271,4 @@ class TCPServer(object):</span>
<span class="w"> </span>        .. versionchanged:: 4.2
<span class="w"> </span>           Added the option for this method to be a coroutine.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gh">diff --git a/tornado/template.py b/tornado/template.py</span>
<span class="gh">index 1f082087..64f79041 100644</span>
<span class="gd">--- a/tornado/template.py</span>
<span class="gi">+++ b/tornado/template.py</span>
<span class="gu">@@ -217,7 +217,14 @@ def filter_whitespace(mode: str, text: str) -&gt;str:</span>

<span class="w"> </span>    .. versionadded:: 4.3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if mode == &#39;all&#39;:</span>
<span class="gi">+        return text</span>
<span class="gi">+    elif mode == &#39;single&#39;:</span>
<span class="gi">+        return re.sub(r&#39;([^\S\n]+)&#39;, &#39; &#39;, text)</span>
<span class="gi">+    elif mode == &#39;oneline&#39;:</span>
<span class="gi">+        return re.sub(r&#39;\s+&#39;, &#39; &#39;, text)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Invalid whitespace mode: {mode}&quot;)</span>


<span class="w"> </span>class Template(object):
<span class="gu">@@ -288,7 +295,28 @@ class Template(object):</span>

<span class="w"> </span>    def generate(self, **kwargs: Any) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Generate this template with the given arguments.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        namespace = {</span>
<span class="gi">+            &#39;escape&#39;: escape.xhtml_escape,</span>
<span class="gi">+            &#39;xhtml_escape&#39;: escape.xhtml_escape,</span>
<span class="gi">+            &#39;url_escape&#39;: escape.url_escape,</span>
<span class="gi">+            &#39;json_encode&#39;: escape.json_encode,</span>
<span class="gi">+            &#39;squeeze&#39;: escape.squeeze,</span>
<span class="gi">+            &#39;_tt_utf8&#39;: escape.utf8,</span>
<span class="gi">+            &#39;_tt_string_types&#39;: (unicode_type, bytes),</span>
<span class="gi">+            &#39;_tt_modules&#39;: ObjectDict(),</span>
<span class="gi">+            &#39;datetime&#39;: datetime,</span>
<span class="gi">+        }</span>
<span class="gi">+        namespace.update(self.namespace)</span>
<span class="gi">+        namespace.update(kwargs)</span>
<span class="gi">+        exec_in(self.compiled, namespace)</span>
<span class="gi">+        execute = namespace[&#39;_tt_execute&#39;]</span>
<span class="gi">+        try:</span>
<span class="gi">+            result = execute()</span>
<span class="gi">+            return escape.utf8(result)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            formatted_code = _format_code(self.code).rstrip()</span>
<span class="gi">+            app_log.error(&#39;%s code:\n%s&#39;, self.name, formatted_code)</span>
<span class="gi">+            raise</span>


<span class="w"> </span>class BaseLoader(object):
<span class="gu">@@ -324,15 +352,24 @@ class BaseLoader(object):</span>

<span class="w"> </span>    def reset(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Resets the cache of compiled templates.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            self.templates.clear()</span>

<span class="w"> </span>    def resolve_path(self, name: str, parent_path: Optional[str]=None) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Converts a possibly-relative path to absolute (used internally).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if parent_path and not parent_path.startswith(&quot;&lt;&quot;) and not parent_path.startswith(&quot;/&quot;) and not name.startswith(&quot;/&quot;):</span>
<span class="gi">+            current_path = os.path.join(os.path.dirname(parent_path), name)</span>
<span class="gi">+            file_dir = os.path.dirname(os.path.abspath(parent_path))</span>
<span class="gi">+            return os.path.normpath(os.path.join(file_dir, current_path))</span>
<span class="gi">+        return name</span>

<span class="w"> </span>    def load(self, name: str, parent_path: Optional[str]=None) -&gt;Template:
<span class="w"> </span>        &quot;&quot;&quot;Loads a template.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        name = self.resolve_path(name, parent_path=parent_path)</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            if name not in self.templates:</span>
<span class="gi">+                self.templates[name] = self._create_template(name)</span>
<span class="gi">+            return self.templates[name]</span>


<span class="w"> </span>class Loader(BaseLoader):
<span class="gh">diff --git a/tornado/test/autoreload_functionality_test.py b/tornado/test/autoreload_functionality_test.py</span>
new file mode 100644
<span class="gh">index 00000000..a751713a</span>
<span class="gd">--- /dev/null</span>
<span class="gi">+++ b/tornado/test/autoreload_functionality_test.py</span>
<span class="gu">@@ -0,0 +1,34 @@</span>
<span class="gi">+import unittest</span>
<span class="gi">+import os</span>
<span class="gi">+import sys</span>
<span class="gi">+import time</span>
<span class="gi">+from tornado import autoreload</span>
<span class="gi">+from tornado.testing import AsyncTestCase, gen_test</span>
<span class="gi">+</span>
<span class="gi">+class AutoreloadFunctionalityTest(AsyncTestCase):</span>
<span class="gi">+    @gen_test</span>
<span class="gi">+    async def test_watch_file(self):</span>
<span class="gi">+        test_file = &#39;test_autoreload.txt&#39;</span>
<span class="gi">+        with open(test_file, &#39;w&#39;) as f:</span>
<span class="gi">+            f.write(&#39;initial content&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        autoreload.watch(test_file)</span>
<span class="gi">+        </span>
<span class="gi">+        # Simulate file change</span>
<span class="gi">+        time.sleep(1)  # Ensure file modification time is different</span>
<span class="gi">+        with open(test_file, &#39;w&#39;) as f:</span>
<span class="gi">+            f.write(&#39;modified content&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        # Wait for autoreload to detect the change</span>
<span class="gi">+        for _ in range(10):  # Try for up to 5 seconds</span>
<span class="gi">+            if autoreload._reload_attempted:</span>
<span class="gi">+                break</span>
<span class="gi">+            await self.io_loop.run_in_executor(None, time.sleep, 0.5)</span>
<span class="gi">+        </span>
<span class="gi">+        self.assertTrue(autoreload._reload_attempted)</span>
<span class="gi">+        </span>
<span class="gi">+        # Clean up</span>
<span class="gi">+        os.remove(test_file)</span>
<span class="gi">+</span>
<span class="gi">+if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+    unittest.main()</span>
<span class="gh">diff --git a/tornado/test/runtests.py b/tornado/test/runtests.py</span>
<span class="gh">index f35b3725..00bba972 100644</span>
<span class="gd">--- a/tornado/test/runtests.py</span>
<span class="gi">+++ b/tornado/test/runtests.py</span>
<span class="gu">@@ -22,6 +22,7 @@ TEST_MODULES = [</span>
<span class="w"> </span>    &quot;tornado.test.asyncio_test&quot;,
<span class="w"> </span>    &quot;tornado.test.auth_test&quot;,
<span class="w"> </span>    &quot;tornado.test.autoreload_test&quot;,
<span class="gi">+    &quot;tornado.test.autoreload_functionality_test&quot;,</span>
<span class="w"> </span>    &quot;tornado.test.circlerefs_test&quot;,
<span class="w"> </span>    &quot;tornado.test.concurrent_test&quot;,
<span class="w"> </span>    &quot;tornado.test.curl_httpclient_test&quot;,
<span class="gh">diff --git a/tornado/testing.py b/tornado/testing.py</span>
<span class="gh">index 0dea2c63..6a6341c4 100644</span>
<span class="gd">--- a/tornado/testing.py</span>
<span class="gi">+++ b/tornado/testing.py</span>
<span class="gu">@@ -53,7 +53,13 @@ def bind_unused_port(reuse_port: bool=False, address: str=&#39;127.0.0.1&#39;) -&gt;Tuple[</span>
<span class="w"> </span>       Added optional ``address`` argument to
<span class="w"> </span>       override the default &quot;127.0.0.1&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span>
<span class="gi">+    if reuse_port:</span>
<span class="gi">+        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)</span>
<span class="gi">+    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span>
<span class="gi">+    sock.bind((address, 0))</span>
<span class="gi">+    port = sock.getsockname()[1]</span>
<span class="gi">+    return sock, port</span>


<span class="w"> </span>def get_async_test_timeout() -&gt;float:
<span class="gu">@@ -63,7 +69,10 @@ def get_async_test_timeout() -&gt;float:</span>

<span class="w"> </span>    .. versionadded:: 3.1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return float(os.environ.get(&#39;ASYNC_TEST_TIMEOUT&#39;, 5))</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return 5.0</span>


<span class="w"> </span>class AsyncTestCase(unittest.TestCase):
<span class="gu">@@ -137,7 +146,8 @@ class AsyncTestCase(unittest.TestCase):</span>
<span class="w"> </span>        .. deprecated:: 6.3
<span class="w"> </span>           This method will be removed in Tornado 7.0.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(&quot;get_new_ioloop is deprecated, use asyncio instead&quot;, DeprecationWarning)</span>
<span class="gi">+        return IOLoop()</span>

<span class="w"> </span>    def _callTestMethod(self, method: Callable) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Run the given test method, raising an error if it returns non-None.
<span class="gu">@@ -152,7 +162,17 @@ class AsyncTestCase(unittest.TestCase):</span>
<span class="w"> </span>        present in all supported versions of Python (3.8+), and if it goes away in the future that&#39;s
<span class="w"> </span>        OK because we can just remove this override as noted above.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = method()</span>
<span class="gi">+        if result is not None:</span>
<span class="gi">+            if inspect.iscoroutine(result) or isinstance(result, Generator):</span>
<span class="gi">+                raise RuntimeError(</span>
<span class="gi">+                    f&quot;Test method {method.__name__} is asynchronous but not &quot;</span>
<span class="gi">+                    f&quot;decorated with @gen_test or @unittest.IsolatedAsyncioTestCase.asyncTest&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    f&quot;Test method {method.__name__} should return None, not {result!r}&quot;</span>
<span class="gi">+                )</span>

<span class="w"> </span>    def stop(self, _arg: Any=None, **kwargs: Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Stops the `.IOLoop`, causing one pending (or future) call to `wait()`
<span class="gh">diff --git a/tornado/util.py b/tornado/util.py</span>
<span class="gh">index 182c7dcd..258c7639 100644</span>
<span class="gd">--- a/tornado/util.py</span>
<span class="gi">+++ b/tornado/util.py</span>
<span class="gu">@@ -67,12 +67,12 @@ class GzipDecompressor(object):</span>
<span class="w"> </span>        in ``unconsumed_tail``; you must retrieve this value and pass
<span class="w"> </span>        it back to a future call to `decompress` if it is not empty.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.decompressobj.decompress(value, max_length)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def unconsumed_tail(self) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Returns the unconsumed portion left over&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.decompressobj.unconsumed_tail</span>

<span class="w"> </span>    def flush(self) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Return any remaining buffered data not yet returned by decompress.
<span class="gu">@@ -80,7 +80,7 @@ class GzipDecompressor(object):</span>
<span class="w"> </span>        Also checks for errors such as truncated input.
<span class="w"> </span>        No other methods may be called on this object after `flush`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.decompressobj.flush()</span>


<span class="w"> </span>def import_object(name: str) -&gt;Any:
<span class="gu">@@ -101,7 +101,14 @@ def import_object(name: str) -&gt;Any:</span>
<span class="w"> </span>        ...
<span class="w"> </span>    ImportError: No module named missing_module
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;.&#39; not in name:</span>
<span class="gi">+        return __import__(name)</span>
<span class="gi">+    parts = name.split(&#39;.&#39;)</span>
<span class="gi">+    obj = __import__(&#39;.&#39;.join(parts[:-1]), fromlist=[parts[-1]])</span>
<span class="gi">+    try:</span>
<span class="gi">+        return getattr(obj, parts[-1])</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        raise ImportError(&quot;No module named %s&quot; % parts[-1])</span>


<span class="w"> </span>def errno_from_exception(e: BaseException) -&gt;Optional[int]:
<span class="gu">@@ -113,7 +120,12 @@ def errno_from_exception(e: BaseException) -&gt;Optional[int]:</span>
<span class="w"> </span>    abstracts all that behavior to give you a safe way to get the
<span class="w"> </span>    errno.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(e, &#39;errno&#39;):</span>
<span class="gi">+        return e.errno</span>
<span class="gi">+    elif e.args:</span>
<span class="gi">+        return e.args[0] if isinstance(e.args[0], int) else None</span>
<span class="gi">+    else:</span>
<span class="gi">+        return None</span>


<span class="w"> </span>_alphanum = frozenset(
<span class="gu">@@ -130,7 +142,18 @@ def re_unescape(s: str) -&gt;str:</span>

<span class="w"> </span>    .. versionadded:: 4.4
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def replace(match):</span>
<span class="gi">+        group = match.group(1)</span>
<span class="gi">+        if group in _alphanum:</span>
<span class="gi">+            return group</span>
<span class="gi">+        elif group == &#39;\n&#39;:</span>
<span class="gi">+            return &#39;\\n&#39;</span>
<span class="gi">+        elif group == &#39;\r&#39;:</span>
<span class="gi">+            return &#39;\\r&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return group</span>
<span class="gi">+</span>
<span class="gi">+    return _re_unescape_pattern.sub(replace, s)</span>


<span class="w"> </span>class Configurable(object):
<span class="gu">@@ -187,12 +210,12 @@ class Configurable(object):</span>
<span class="w"> </span>        parameter).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def configurable_default(cls):
<span class="w"> </span>        &quot;&quot;&quot;Returns the implementation class to be used if none is configured.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="w"> </span>    initialize = _initialize
<span class="w"> </span>    &quot;&quot;&quot;Initialize a `Configurable` subclass instance.

<span class="gu">@@ -210,12 +233,21 @@ class Configurable(object):</span>
<span class="w"> </span>        to the constructor.  This can be used to set global defaults for
<span class="w"> </span>        some parameters.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        base = cls.configurable_base()</span>
<span class="gi">+        if isinstance(impl, str):</span>
<span class="gi">+            impl = import_object(impl)</span>
<span class="gi">+        if impl is not None and not issubclass(impl, cls):</span>
<span class="gi">+            raise ValueError(&quot;Invalid subclass of %s&quot; % cls)</span>
<span class="gi">+        base.__impl_class = impl</span>
<span class="gi">+        base.__impl_kwargs = kwargs</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def configured_class(cls):
<span class="w"> </span>        &quot;&quot;&quot;Returns the currently configured class.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        base = cls.configurable_base()</span>
<span class="gi">+        if cls.__impl_class is None:</span>
<span class="gi">+            base.__impl_class = cls.configurable_default()</span>
<span class="gi">+        return base.__impl_class</span>


<span class="w"> </span>class ArgReplacer(object):
<span class="gu">@@ -239,7 +271,9 @@ class ArgReplacer(object):</span>

<span class="w"> </span>        Returns ``default`` if the argument is not present.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.arg_pos is not None and len(args) &gt; self.arg_pos:</span>
<span class="gi">+            return args[self.arg_pos]</span>
<span class="gi">+        return kwargs.get(self.name, default)</span>

<span class="w"> </span>    def replace(self, new_value: Any, args: Sequence[Any], kwargs: Dict[str,
<span class="w"> </span>        Any]) -&gt;Tuple[Any, Sequence[Any], Dict[str, Any]]:
<span class="gu">@@ -252,12 +286,25 @@ class ArgReplacer(object):</span>
<span class="w"> </span>        If the named argument was not found, ``new_value`` will be added
<span class="w"> </span>        to ``kwargs`` and None will be returned as ``old_value``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.arg_pos is not None and len(args) &gt; self.arg_pos:</span>
<span class="gi">+            # The arg to replace is passed positionally</span>
<span class="gi">+            old_value = args[self.arg_pos]</span>
<span class="gi">+            args = list(args)</span>
<span class="gi">+            args[self.arg_pos] = new_value</span>
<span class="gi">+        elif self.name in kwargs:</span>
<span class="gi">+            # The arg to replace is passed by keyword</span>
<span class="gi">+            old_value = kwargs[self.name]</span>
<span class="gi">+            kwargs[self.name] = new_value</span>
<span class="gi">+        else:</span>
<span class="gi">+            # The arg to replace is not present; add it to kwargs</span>
<span class="gi">+            old_value = None</span>
<span class="gi">+            kwargs[self.name] = new_value</span>
<span class="gi">+        return old_value, args, kwargs</span>


<span class="w"> </span>def timedelta_to_seconds(td):
<span class="w"> </span>    &quot;&quot;&quot;Equivalent to ``td.total_seconds()`` (introduced in Python 2.7).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return td.total_seconds()</span>


<span class="w"> </span>def _websocket_mask_python(mask: bytes, data: bytes) -&gt;bytes:
<span class="gu">@@ -269,7 +316,11 @@ def _websocket_mask_python(mask: bytes, data: bytes) -&gt;bytes:</span>

<span class="w"> </span>    This pure-python implementation may be replaced by an optimized version when available.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    mask = array.array(&quot;B&quot;, mask)</span>
<span class="gi">+    unmasked = array.array(&quot;B&quot;, data)</span>
<span class="gi">+    for i in range(len(data)):</span>
<span class="gi">+        unmasked[i] ^= mask[i % 4]</span>
<span class="gi">+    return unmasked.tobytes()</span>


<span class="w"> </span>if os.environ.get(&#39;TORNADO_NO_EXTENSION&#39;) or os.environ.get(&#39;TORNADO_EXTENSION&#39;
<span class="gh">diff --git a/tornado/websocket.py b/tornado/websocket.py</span>
<span class="gh">index 8d336cb2..5592c823 100644</span>
<span class="gd">--- a/tornado/websocket.py</span>
<span class="gi">+++ b/tornado/websocket.py</span>
<span class="gu">@@ -175,7 +175,7 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>

<span class="w"> </span>        Set websocket_ping_interval = 0 to disable pings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.application.settings.get(&#39;websocket_ping_interval&#39;, None)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def ping_timeout(self) -&gt;Optional[float]:
<span class="gu">@@ -183,7 +183,7 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>
<span class="w"> </span>        close the websocket connection (VPNs, etc. can fail to cleanly close ws connections).
<span class="w"> </span>        Default is max of 3 pings or 30 seconds.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.application.settings.get(&#39;websocket_ping_timeout&#39;, None)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def max_message_size(self) -&gt;int:
<span class="gu">@@ -194,7 +194,7 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>

<span class="w"> </span>        Default is 10MiB.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.application.settings.get(&#39;websocket_max_message_size&#39;, 10 * 1024 * 1024)</span>

<span class="w"> </span>    def write_message(self, message: Union[bytes, str, Dict[str, Any]],
<span class="w"> </span>        binary: bool=False) -&gt;&#39;Future[None]&#39;:
<span class="gu">@@ -219,7 +219,13 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>
<span class="w"> </span>           Consistently raises `WebSocketClosedError`. Previously could
<span class="w"> </span>           sometimes raise `.StreamClosedError`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ws_connection is None or self.ws_connection.is_closing():</span>
<span class="gi">+            raise WebSocketClosedError()</span>
<span class="gi">+        </span>
<span class="gi">+        if isinstance(message, dict):</span>
<span class="gi">+            message = tornado.escape.json_encode(message)</span>
<span class="gi">+        </span>
<span class="gi">+        return self.ws_connection.write_message(message, binary)</span>

<span class="w"> </span>    def select_subprotocol(self, subprotocols: List[str]) -&gt;Optional[str]:
<span class="w"> </span>        &quot;&quot;&quot;Override to implement subprotocol negotiation.
<span class="gu">@@ -244,7 +250,7 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>
<span class="w"> </span>           an empty string instead of an empty list if no subprotocols
<span class="w"> </span>           were proposed by the client.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def selected_subprotocol(self) -&gt;Optional[str]:
<span class="gu">@@ -275,7 +281,7 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>

<span class="w"> </span>           Added ``compression_level`` and ``mem_level``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def open(self, *args: str, **kwargs: str) -&gt;Optional[Awaitable[None]]:
<span class="w"> </span>        &quot;&quot;&quot;Invoked when a new WebSocket is opened.
<span class="gu">@@ -303,7 +309,7 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>

<span class="w"> </span>           ``on_message`` can be a coroutine.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;on_message must be overridden&quot;)</span>

<span class="w"> </span>    def ping(self, data: Union[str, bytes]=b&#39;&#39;) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Send ping frame to the remote end.
<span class="gu">@@ -321,7 +327,9 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>
<span class="w"> </span>           The data argument is now optional.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ws_connection is None:</span>
<span class="gi">+            raise WebSocketClosedError()</span>
<span class="gi">+        self.ws_connection.write_ping(data)</span>

<span class="w"> </span>    def on_pong(self, data: bytes) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Invoked when the response to a ping frame is received.&quot;&quot;&quot;
<span class="gh">diff --git a/tornado/wsgi.py b/tornado/wsgi.py</span>
<span class="gh">index 227b0d77..b0ed4272 100644</span>
<span class="gd">--- a/tornado/wsgi.py</span>
<span class="gi">+++ b/tornado/wsgi.py</span>
<span class="gu">@@ -108,7 +108,34 @@ class WSGIContainer(object):</span>
<span class="w"> </span>        .. versionchanged:: 6.3
<span class="w"> </span>           No longer a static method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        environ = {</span>
<span class="gi">+            &quot;REQUEST_METHOD&quot;: request.method,</span>
<span class="gi">+            &quot;SCRIPT_NAME&quot;: &quot;&quot;,</span>
<span class="gi">+            &quot;PATH_INFO&quot;: escape.url_unescape(</span>
<span class="gi">+                request.path, encoding=None, plus=False),</span>
<span class="gi">+            &quot;QUERY_STRING&quot;: request.query,</span>
<span class="gi">+            &quot;REMOTE_ADDR&quot;: request.remote_ip,</span>
<span class="gi">+            &quot;SERVER_NAME&quot;: request.host.split(&quot;:&quot;)[0],</span>
<span class="gi">+            &quot;SERVER_PORT&quot;: str(request.port or 80),</span>
<span class="gi">+            &quot;SERVER_PROTOCOL&quot;: request.version,</span>
<span class="gi">+            &quot;wsgi.version&quot;: (1, 0),</span>
<span class="gi">+            &quot;wsgi.url_scheme&quot;: request.protocol,</span>
<span class="gi">+            &quot;wsgi.input&quot;: BytesIO(request.body),</span>
<span class="gi">+            &quot;wsgi.errors&quot;: sys.stderr,</span>
<span class="gi">+            &quot;wsgi.multithread&quot;: True,</span>
<span class="gi">+            &quot;wsgi.multiprocess&quot;: False,</span>
<span class="gi">+            &quot;wsgi.run_once&quot;: False,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;Content-Type&quot; in request.headers:</span>
<span class="gi">+            environ[&quot;CONTENT_TYPE&quot;] = request.headers.pop(&quot;Content-Type&quot;)</span>
<span class="gi">+        if &quot;Content-Length&quot; in request.headers:</span>
<span class="gi">+            environ[&quot;CONTENT_LENGTH&quot;] = request.headers.pop(&quot;Content-Length&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        for key, value in request.headers.items():</span>
<span class="gi">+            environ[&quot;HTTP_&quot; + key.replace(&quot;-&quot;, &quot;_&quot;).upper()] = value</span>
<span class="gi">+</span>
<span class="gi">+        return environ</span>


<span class="w"> </span>HTTPRequest = httputil.HTTPServerRequest
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>