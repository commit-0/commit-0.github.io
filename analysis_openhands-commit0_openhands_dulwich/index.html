
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis openhands commit0 openhands dulwich - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#openhands-dulwich" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis openhands commit0 openhands dulwich
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_archive" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_archive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_fetch_empty_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_fetch_empty_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_fetch_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_fetch_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_fetch_pack_depth" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_fetch_pack_depth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_fetch_pack_no_side_band_64k" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_fetch_pack_no_side_band_64k
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_fetch_pack_zero_sha" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_fetch_pack_zero_sha
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_get_refs" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_get_refs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_incremental_fetch_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_incremental_fetch_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_repeat" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_repeat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_send_new_branch_empty_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_send_new_branch_empty_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_send_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_send_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_send_pack_from_shallow_clone" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_send_pack_from_shallow_clone
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_send_pack_multiple_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_send_pack_multiple_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_send_pack_nothing_to_send" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_send_pack_nothing_to_send
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_send_pack_one_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_send_pack_one_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_send_remove_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_send_remove_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttesttest_send_without_report_status" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTest::test_send_without_report_status
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_archive" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_archive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_fetch_empty_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_fetch_empty_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_fetch_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_fetch_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_fetch_pack_depth" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_fetch_pack_depth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_fetch_pack_no_side_band_64k" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_fetch_pack_no_side_band_64k
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_fetch_pack_zero_sha" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_fetch_pack_zero_sha
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_get_refs" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_get_refs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_incremental_fetch_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_incremental_fetch_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_repeat" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_repeat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_send_new_branch_empty_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_send_new_branch_empty_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_send_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_send_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_send_pack_from_shallow_clone" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_send_pack_from_shallow_clone
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_send_pack_multiple_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_send_pack_multiple_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_send_pack_nothing_to_send" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_send_pack_nothing_to_send
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_send_pack_one_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_send_pack_one_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_send_remove_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_send_remove_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichtcpclienttestgitprotov0test_send_without_report_status" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichTCPClientTestGitProtov0::test_send_without_report_status
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_archive" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_archive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_fetch_empty_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_fetch_empty_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_fetch_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_fetch_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_fetch_pack_depth" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_fetch_pack_depth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_fetch_pack_no_side_band_64k" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_fetch_pack_no_side_band_64k
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_fetch_pack_zero_sha" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_fetch_pack_zero_sha
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_get_refs" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_get_refs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_incremental_fetch_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_incremental_fetch_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_repeat" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_repeat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_send_new_branch_empty_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_send_new_branch_empty_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_send_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_send_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_send_pack_from_shallow_clone" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_send_pack_from_shallow_clone
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_send_pack_multiple_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_send_pack_multiple_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_send_pack_nothing_to_send" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_send_pack_nothing_to_send
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_send_pack_one_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_send_pack_one_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_send_remove_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_send_remove_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttesttest_send_without_report_status" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTest::test_send_without_report_status
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_archive" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_archive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_fetch_empty_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_fetch_empty_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_fetch_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_fetch_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_fetch_pack_depth" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_fetch_pack_depth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_fetch_pack_no_side_band_64k" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_fetch_pack_no_side_band_64k
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_fetch_pack_zero_sha" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_fetch_pack_zero_sha
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_get_refs" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_get_refs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_incremental_fetch_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_incremental_fetch_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_repeat" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_repeat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_send_new_branch_empty_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_new_branch_empty_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_send_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_send_pack_from_shallow_clone" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_pack_from_shallow_clone
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_send_pack_multiple_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_pack_multiple_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_send_pack_nothing_to_send" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_pack_nothing_to_send
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_send_pack_one_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_pack_one_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_send_remove_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_remove_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichmocksshclienttestgitprotov0test_send_without_report_status" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_without_report_status
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_archive" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_archive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_fetch_empty_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_fetch_empty_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_fetch_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_fetch_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_fetch_pack_depth" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_fetch_pack_depth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_fetch_pack_no_side_band_64k" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_fetch_pack_no_side_band_64k
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_fetch_pack_zero_sha" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_fetch_pack_zero_sha
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_get_refs" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_get_refs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_incremental_fetch_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_incremental_fetch_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_repeat" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_repeat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_send_new_branch_empty_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_send_new_branch_empty_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_send_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_send_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_send_pack_from_shallow_clone" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_send_pack_from_shallow_clone
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_send_pack_multiple_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_send_pack_multiple_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_send_pack_nothing_to_send" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_send_pack_nothing_to_send
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_send_pack_one_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_send_pack_one_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_send_remove_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_send_remove_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttesttest_send_without_report_status" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTest::test_send_without_report_status
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_archive" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_archive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_fetch_empty_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_fetch_empty_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_fetch_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_fetch_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_fetch_pack_depth" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_fetch_pack_depth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_fetch_pack_no_side_band_64k" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_fetch_pack_no_side_band_64k
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_fetch_pack_zero_sha" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_fetch_pack_zero_sha
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_get_refs" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_get_refs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_incremental_fetch_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_incremental_fetch_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_repeat" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_repeat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_send_new_branch_empty_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_new_branch_empty_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_send_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_send_pack_from_shallow_clone" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_pack_from_shallow_clone
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_send_pack_multiple_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_pack_multiple_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_send_pack_nothing_to_send" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_pack_nothing_to_send
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_send_pack_one_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_pack_one_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_send_remove_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_remove_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichsubprocessclienttestgitprotov0test_send_without_report_status" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_without_report_status
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_archive" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_archive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_fetch_empty_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_fetch_empty_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_fetch_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_fetch_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_fetch_pack_depth" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_fetch_pack_depth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_fetch_pack_no_side_band_64k" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_fetch_pack_no_side_band_64k
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_fetch_pack_zero_sha" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_fetch_pack_zero_sha
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_get_refs" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_get_refs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_incremental_fetch_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_incremental_fetch_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_repeat" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_repeat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_send_new_branch_empty_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_send_new_branch_empty_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_send_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_send_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_send_pack_from_shallow_clone" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_send_pack_from_shallow_clone
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_send_pack_multiple_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_send_pack_multiple_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_send_pack_nothing_to_send" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_send_pack_nothing_to_send
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_send_pack_one_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_send_pack_one_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_send_remove_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_send_remove_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttesttest_send_without_report_status" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTest::test_send_without_report_status
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_archive" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_archive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_fetch_empty_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_fetch_empty_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_fetch_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_fetch_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_fetch_pack_depth" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_fetch_pack_depth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_fetch_pack_no_side_band_64k" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_fetch_pack_no_side_band_64k
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_fetch_pack_zero_sha" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_fetch_pack_zero_sha
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_get_refs" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_get_refs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_incremental_fetch_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_incremental_fetch_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_repeat" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_repeat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_send_new_branch_empty_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_send_new_branch_empty_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_send_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_send_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_send_pack_from_shallow_clone" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_send_pack_from_shallow_clone
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_send_pack_multiple_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_send_pack_multiple_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_send_pack_nothing_to_send" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_send_pack_nothing_to_send
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_send_pack_one_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_send_pack_one_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_send_remove_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_send_remove_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpydulwichhttpclienttestgitprotov0test_send_without_report_status" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::DulwichHttpClientTestGitProtov0::test_send_without_report_status
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_copy" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_delta_medium_object" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_delta_medium_object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_deltas_work" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_deltas_work
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyobjectstoretestcasetest_all_objects" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::ObjectStoreTestCase::test_all_objects
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyobjectstoretestcasetest_bare" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::ObjectStoreTestCase::test_bare
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyobjectstoretestcasetest_head" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::ObjectStoreTestCase::test_head
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyobjectstoretestcasetest_loose_objects" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::ObjectStoreTestCase::test_loose_objects
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyobjectstoretestcasetest_packed_objects" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::ObjectStoreTestCase::test_packed_objects
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyobjectstoretestcasetest_refs" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::ObjectStoreTestCase::test_refs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyworkingtreetestcasetest_all_objects" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::WorkingTreeTestCase::test_all_objects
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyworkingtreetestcasetest_bare" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::WorkingTreeTestCase::test_bare
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyworkingtreetestcasetest_git_worktree_config" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::WorkingTreeTestCase::test_git_worktree_config
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyworkingtreetestcasetest_git_worktree_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::WorkingTreeTestCase::test_git_worktree_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyworkingtreetestcasetest_head" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::WorkingTreeTestCase::test_head
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyworkingtreetestcasetest_head_equality" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::WorkingTreeTestCase::test_head_equality
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyworkingtreetestcasetest_loose_objects" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::WorkingTreeTestCase::test_loose_objects
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyworkingtreetestcasetest_packed_objects" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::WorkingTreeTestCase::test_packed_objects
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyworkingtreetestcasetest_refs" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::WorkingTreeTestCase::test_refs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyinitnewworkingdirectorytestcasetest_all_objects" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::InitNewWorkingDirectoryTestCase::test_all_objects
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyinitnewworkingdirectorytestcasetest_bare" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::InitNewWorkingDirectoryTestCase::test_bare
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyinitnewworkingdirectorytestcasetest_git_worktree_config" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::InitNewWorkingDirectoryTestCase::test_git_worktree_config
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyinitnewworkingdirectorytestcasetest_git_worktree_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::InitNewWorkingDirectoryTestCase::test_git_worktree_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyinitnewworkingdirectorytestcasetest_head" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::InitNewWorkingDirectoryTestCase::test_head
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyinitnewworkingdirectorytestcasetest_head_equality" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::InitNewWorkingDirectoryTestCase::test_head_equality
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyinitnewworkingdirectorytestcasetest_loose_objects" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::InitNewWorkingDirectoryTestCase::test_loose_objects
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyinitnewworkingdirectorytestcasetest_packed_objects" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::InitNewWorkingDirectoryTestCase::test_packed_objects
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_repositorypyinitnewworkingdirectorytestcasetest_refs" class="md-nav__link">
    <span class="md-ellipsis">
      test_repository.py::InitNewWorkingDirectoryTestCase::test_refs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitservertestcasetest_clone_from_dulwich_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerTestCase::test_clone_from_dulwich_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitservertestcasetest_fetch_from_dulwich" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerTestCase::test_fetch_from_dulwich
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitservertestcasetest_fetch_from_dulwich_issue_88_alternative" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerTestCase::test_fetch_from_dulwich_issue_88_alternative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitservertestcasetest_fetch_from_dulwich_issue_88_standard" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerTestCase::test_fetch_from_dulwich_issue_88_standard
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitservertestcasetest_fetch_from_dulwich_no_op" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerTestCase::test_fetch_from_dulwich_no_op
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitservertestcasetest_fetch_full_depth_into_shallow_clone_from_dulwich" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerTestCase::test_fetch_full_depth_into_shallow_clone_from_dulwich
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitservertestcasetest_fetch_same_depth_into_shallow_clone_from_dulwich" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerTestCase::test_fetch_same_depth_into_shallow_clone_from_dulwich
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitservertestcasetest_lsremote_from_dulwich" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerTestCase::test_lsremote_from_dulwich
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitservertestcasetest_new_shallow_clone_from_dulwich" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerTestCase::test_new_shallow_clone_from_dulwich
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitservertestcasetest_push_to_dulwich" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerTestCase::test_push_to_dulwich
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitservertestcasetest_push_to_dulwich_issue_88_standard" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerTestCase::test_push_to_dulwich_issue_88_standard
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitservertestcasetest_push_to_dulwich_no_op" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerTestCase::test_push_to_dulwich_no_op
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitservertestcasetest_push_to_dulwich_remove_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerTestCase::test_push_to_dulwich_remove_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitservertestcasetest_shallow_clone_from_git_is_identical" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerTestCase::test_shallow_clone_from_git_is_identical
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitserversideband64ktestcasetest_clone_from_dulwich_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerSideBand64kTestCase::test_clone_from_dulwich_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitserversideband64ktestcasetest_fetch_from_dulwich" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerSideBand64kTestCase::test_fetch_from_dulwich
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitserversideband64ktestcasetest_fetch_from_dulwich_issue_88_alternative" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerSideBand64kTestCase::test_fetch_from_dulwich_issue_88_alternative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitserversideband64ktestcasetest_fetch_from_dulwich_issue_88_standard" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerSideBand64kTestCase::test_fetch_from_dulwich_issue_88_standard
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitserversideband64ktestcasetest_fetch_from_dulwich_no_op" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerSideBand64kTestCase::test_fetch_from_dulwich_no_op
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitserversideband64ktestcasetest_fetch_full_depth_into_shallow_clone_from_dulwich" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerSideBand64kTestCase::test_fetch_full_depth_into_shallow_clone_from_dulwich
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitserversideband64ktestcasetest_fetch_same_depth_into_shallow_clone_from_dulwich" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerSideBand64kTestCase::test_fetch_same_depth_into_shallow_clone_from_dulwich
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitserversideband64ktestcasetest_lsremote_from_dulwich" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerSideBand64kTestCase::test_lsremote_from_dulwich
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitserversideband64ktestcasetest_new_shallow_clone_from_dulwich" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerSideBand64kTestCase::test_new_shallow_clone_from_dulwich
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitserversideband64ktestcasetest_push_to_dulwich" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerSideBand64kTestCase::test_push_to_dulwich
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitserversideband64ktestcasetest_push_to_dulwich_issue_88_standard" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerSideBand64kTestCase::test_push_to_dulwich_issue_88_standard
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitserversideband64ktestcasetest_push_to_dulwich_no_op" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerSideBand64kTestCase::test_push_to_dulwich_no_op
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitserversideband64ktestcasetest_push_to_dulwich_remove_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerSideBand64kTestCase::test_push_to_dulwich_remove_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpygitserversideband64ktestcasetest_shallow_clone_from_git_is_identical" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::GitServerSideBand64kTestCase::test_shallow_clone_from_git_is_identical
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_release_robotpygetrecenttagstesttest_get_recent_tags" class="md-nav__link">
    <span class="md-ellipsis">
      test_release_robot.py::GetRecentTagsTest::test_get_recent_tags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftrepotest_init_bare" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftRepo::test_init_bare
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftrepotest_put_named_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftRepo::test_put_named_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftinforefscontainertest_init" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftInfoRefsContainer::test_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftinforefscontainertest_remove_if_equals" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftInfoRefsContainer::test_remove_if_equals
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftinforefscontainertest_set_if_equals" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftInfoRefsContainer::test_set_if_equals
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftconnectortest_create_root" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftConnector::test_create_root
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftconnectortest_create_root_fails" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftConnector::test_create_root_fails
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftconnectortest_del_object" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftConnector::test_del_object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftconnectortest_del_root" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftConnector::test_del_root
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftconnectortest_get_container_objects" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftConnector::test_get_container_objects
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftconnectortest_get_container_objects_fails" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftConnector::test_get_container_objects_fails
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftconnectortest_get_object" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftConnector::test_get_object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftconnectortest_get_object_fails" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftConnector::test_get_object_fails
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftconnectortest_get_object_stat" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftConnector::test_get_object_stat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftconnectortest_get_object_stat_fails" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftConnector::test_get_object_stat_fails
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftconnectortest_init_connector" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftConnector::test_init_connector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftconnectortest_put_object" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftConnector::test_put_object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftconnectortest_put_object_fails" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftConnector::test_put_object_fails
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftconnectortest_root_exists" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftConnector::test_root_exists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swiftpytestswiftconnectortest_root_not_exists" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift.py::TestSwiftConnector::test_root_not_exists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_clone_bare" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_clone_bare
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_clone_then_push_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_clone_then_push_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_init_bare" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_init_bare
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_push_annotated_tag" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_push_annotated_tag
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_push_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_push_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_push_commit" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_push_commit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_push_data_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_push_data_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_push_multiple_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_push_multiple_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_push_remove_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_push_remove_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_archivepyarchiveteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_archive.py::ArchiveTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_archivepyarchiveteststest_gzip_mtime" class="md-nav__link">
    <span class="md-ellipsis">
      test_archive.py::ArchiveTests::test_gzip_mtime
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_archivepyarchiveteststest_prefix" class="md-nav__link">
    <span class="md-ellipsis">
      test_archive.py::ArchiveTests::test_prefix
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_archivepyarchiveteststest_same_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_archive.py::ArchiveTests::test_same_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_archivepyarchiveteststest_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_archive.py::ArchiveTests::test_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_archivepyarchiveteststest_unicode" class="md-nav__link">
    <span class="md-ellipsis">
      test_archive.py::ArchiveTests::test_unicode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_bundlepybundleteststest_roundtrip_bundle" class="md-nav__link">
    <span class="md-ellipsis">
      test_bundle.py::BundleTests::test_roundtrip_bundle
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_closing_bracket_within_section_string" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_closing_bracket_within_section_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_comment_after_section" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_comment_after_section
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_comment_after_variable" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_comment_after_variable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_comment_before_section" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_comment_before_section
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_comment_character_within_section_string" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_comment_character_within_section_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_comment_character_within_value_string" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_comment_character_within_value_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_default_config" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_default_config
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_empty_line_before_section" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_empty_line_before_section
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_eq" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_eq
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_from_file_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_from_file_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_from_file_multiple" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_from_file_multiple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_from_file_section" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_from_file_section
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_from_file_section_case_insensitive_lower" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_from_file_section_case_insensitive_lower
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_from_file_section_case_insensitive_mixed" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_from_file_section_case_insensitive_mixed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_from_file_section_with_open_brackets" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_from_file_section_with_open_brackets
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_from_file_subsection" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_from_file_subsection
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_from_file_subsection_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_from_file_subsection_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_from_file_subsection_not_quoted" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_from_file_subsection_not_quoted
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_from_file_utf8_bom" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_from_file_utf8_bom
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_from_file_value_with_open_quoted" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_from_file_value_with_open_quoted
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_from_file_with_boolean_setting" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_from_file_with_boolean_setting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_from_file_with_interrupted_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_from_file_with_interrupted_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_from_file_with_mixed_quoted" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_from_file_with_mixed_quoted
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_from_file_with_quotes" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_from_file_with_quotes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_quoted" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_quoted
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_quoted_multiline" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_quoted_multiline
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_quoted_newlines_windows" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_quoted_newlines_windows
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_same_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_same_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_set_hash_gets_quoted" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_set_hash_gets_quoted
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_write_preserve_multivar" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_write_preserve_multivar
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_write_to_file_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_write_to_file_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_write_to_file_section" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_write_to_file_section
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigfileteststest_write_to_file_subsection" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigFileTests::test_write_to_file_subsection
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigdictteststest_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigDictTests::test_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigdictteststest_get_boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigDictTests::test_get_boolean
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigdictteststest_get_set" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigDictTests::test_get_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigdictteststest_items" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigDictTests::test_items
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigdictteststest_items_nonexistant" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigDictTests::test_items_nonexistant
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyconfigdictteststest_sections" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ConfigDictTests::test_sections
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyescapevalueteststest_backslash" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::EscapeValueTests::test_backslash
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyescapevalueteststest_newline" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::EscapeValueTests::test_newline
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyformatstringteststest_quoted" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::FormatStringTests::test_quoted
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyparsestringteststest_newline" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ParseStringTests::test_newline
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyparsestringteststest_quote" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ParseStringTests::test_quote
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyparsestringteststest_tab" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ParseStringTests::test_tab
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpysubmodulesteststestmalformedsubmodules" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::SubmodulesTests::testMalformedSubmodules
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpysubmodulesteststestsubmodules" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::SubmodulesTests::testSubmodules
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyapplyinsteadofteststest_apply" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ApplyInsteadOfTests::test_apply
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyapplyinsteadofteststest_apply_multiple" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ApplyInsteadOfTests::test_apply_multiple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpyapplyinsteadofteststest_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::ApplyInsteadOfTests::test_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_credentialspytestcredentialhelpersutilstest_match_partial_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_credentials.py::TestCredentialHelpersUtils::test_match_partial_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_credentialspytestcredentialhelpersutilstest_match_urls" class="md-nav__link">
    <span class="md-ellipsis">
      test_credentials.py::TestCredentialHelpersUtils::test_match_urls
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_credentialspytestcredentialhelpersutilstest_urlmatch_credential_sections" class="md-nav__link">
    <span class="md-ellipsis">
      test_credentials.py::TestCredentialHelpersUtils::test_urlmatch_credential_sections
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_add_delete" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_add_delete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_change_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_change_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_change_type_same" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_change_type_same
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_complex" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_complex
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_for_merge_add_add_same_conflict" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_add_add_same_conflict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_for_merge_add_content_rename_conflict" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_add_content_rename_conflict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_for_merge_add_exact_rename_conflict" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_add_exact_rename_conflict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_for_merge_add_modify_conflict" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_add_modify_conflict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_for_merge_add_no_conflict" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_add_no_conflict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_for_merge_delete_delete_conflict" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_delete_delete_conflict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_for_merge_delete_no_conflict" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_delete_no_conflict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_for_merge_modify_modify_conflict" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_modify_modify_conflict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_for_merge_modify_no_conflict" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_modify_no_conflict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_for_merge_modify_rename_conflict" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_modify_rename_conflict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_for_merge_octopus_delete" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_octopus_delete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_for_merge_octopus_modify_conflict" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_octopus_modify_conflict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_for_merge_octopus_no_conflict" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_octopus_no_conflict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_modify_contents" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_modify_contents
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_modify_mode" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_modify_mode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_name_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_name_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_no_changes" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_no_changes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_prune" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_prune
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_rename_detector" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_rename_detector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepytreechangestesttest_tree_changes_to_tree" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::TreeChangesTest::test_tree_changes_to_tree
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_content_rename_gitlink" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_content_rename_gitlink
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_content_rename_many_to_many" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_content_rename_many_to_many
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_content_rename_many_to_one" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_content_rename_many_to_one
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_content_rename_max_files" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_content_rename_max_files
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_content_rename_one_to_many" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_content_rename_one_to_many
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_content_rename_one_to_one" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_content_rename_one_to_one
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_content_rename_one_to_one_ordering" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_content_rename_one_to_one_ordering
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_content_rename_swap" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_content_rename_swap
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_content_rename_with_more_deletions" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_content_rename_with_more_deletions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_exact_copy_change_mode" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_exact_copy_change_mode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_exact_copy_modify" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_exact_copy_modify
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_exact_rename_and_different_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_exact_rename_and_different_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_exact_rename_many_to_many" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_exact_rename_many_to_many
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_exact_rename_many_to_one" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_exact_rename_many_to_one
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_exact_rename_one_to_many" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_exact_rename_one_to_many
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_exact_rename_one_to_one" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_exact_rename_one_to_one
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_exact_rename_split_different_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_exact_rename_split_different_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_exact_rename_swap" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_exact_rename_swap
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_find_copies_harder_content" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_find_copies_harder_content
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_find_copies_harder_exact" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_find_copies_harder_exact
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_find_copies_harder_with_rewrites" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_find_copies_harder_with_rewrites
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_no_renames" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_no_renames
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_rename_threshold" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_rename_threshold
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_reuse_detector" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_reuse_detector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_rewrite_threshold" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_rewrite_threshold
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_similarity_score" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_similarity_score
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_similarity_score_cache" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_similarity_score_cache
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_tree_entry_sort" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_tree_entry_sort
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_diff_treepyrenamedetectiontesttest_want_unchanged" class="md-nav__link">
    <span class="md-ellipsis">
      test_diff_tree.py::RenameDetectionTest::test_want_unchanged
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fastexportpygitimportprocessorteststest_commit_handler" class="md-nav__link">
    <span class="md-ellipsis">
      test_fastexport.py::GitImportProcessorTests::test_commit_handler
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fastexportpygitimportprocessorteststest_commit_handler_markers" class="md-nav__link">
    <span class="md-ellipsis">
      test_fastexport.py::GitImportProcessorTests::test_commit_handler_markers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fastexportpygitimportprocessorteststest_file_add" class="md-nav__link">
    <span class="md-ellipsis">
      test_fastexport.py::GitImportProcessorTests::test_file_add
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fastexportpygitimportprocessorteststest_file_copy" class="md-nav__link">
    <span class="md-ellipsis">
      test_fastexport.py::GitImportProcessorTests::test_file_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fastexportpygitimportprocessorteststest_file_delete" class="md-nav__link">
    <span class="md-ellipsis">
      test_fastexport.py::GitImportProcessorTests::test_file_delete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fastexportpygitimportprocessorteststest_file_deleteall" class="md-nav__link">
    <span class="md-ellipsis">
      test_fastexport.py::GitImportProcessorTests::test_file_deleteall
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fastexportpygitimportprocessorteststest_file_move" class="md-nav__link">
    <span class="md-ellipsis">
      test_fastexport.py::GitImportProcessorTests::test_file_move
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fastexportpygitimportprocessorteststest_import_stream" class="md-nav__link">
    <span class="md-ellipsis">
      test_fastexport.py::GitImportProcessorTests::test_import_stream
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fastexportpygitimportprocessorteststest_reset_handler" class="md-nav__link">
    <span class="md-ellipsis">
      test_fastexport.py::GitImportProcessorTests::test_reset_handler
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fastexportpygitimportprocessorteststest_reset_handler_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_fastexport.py::GitImportProcessorTests::test_reset_handler_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fastexportpygitimportprocessorteststest_reset_handler_marker" class="md-nav__link">
    <span class="md-ellipsis">
      test_fastexport.py::GitImportProcessorTests::test_reset_handler_marker
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepyfancyrenameteststest_dest_exists" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::FancyRenameTests::test_dest_exists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepyfancyrenameteststest_no_dest_exists" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::FancyRenameTests::test_no_dest_exists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepygitfileteststest_abort" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::GitFileTests::test_abort
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepygitfileteststest_abort_close" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::GitFileTests::test_abort_close
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepygitfileteststest_abort_close_removed" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::GitFileTests::test_abort_close_removed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepygitfileteststest_default_mode" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::GitFileTests::test_default_mode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepygitfileteststest_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::GitFileTests::test_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepygitfileteststest_open_twice" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::GitFileTests::test_open_twice
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepygitfileteststest_readonly" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::GitFileTests::test_readonly
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepygitfileteststest_write" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::GitFileTests::test_write
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftparserteststest_multiple_hybrid" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftParserTests::test_multiple_hybrid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftparserteststest_no_grafts" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftParserTests::test_no_grafts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftparserteststest_no_parents" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftParserTests::test_no_parents
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftparserteststest_parents" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftParserTests::test_parents
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftserializerteststest_multiple_hybrid" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftSerializerTests::test_multiple_hybrid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftserializerteststest_no_grafts" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftSerializerTests::test_no_grafts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftserializerteststest_no_parents" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftSerializerTests::test_no_parents
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftserializerteststest_parents" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftSerializerTests::test_parents
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftsinrepoteststest_existing_parent_graft" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftsInRepoTests::test_existing_parent_graft
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftsinrepoteststest_init_with_empty_info_grafts" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftsInRepoTests::test_init_with_empty_info_grafts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftsinrepoteststest_init_with_info_grafts" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftsInRepoTests::test_init_with_info_grafts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftsinrepoteststest_no_grafts" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftsInRepoTests::test_no_grafts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftsinrepoteststest_no_parents_graft" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftsInRepoTests::test_no_parents_graft
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftsinrepoteststest_object_store_fail_invalid_parents" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftsInRepoTests::test_object_store_fail_invalid_parents
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftsinrepoteststest_remove_graft" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftsInRepoTests::test_remove_graft
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftsinmemoryrepoteststest_existing_parent_graft" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftsInMemoryRepoTests::test_existing_parent_graft
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftsinmemoryrepoteststest_no_grafts" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftsInMemoryRepoTests::test_no_grafts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftsinmemoryrepoteststest_no_parents_graft" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftsInMemoryRepoTests::test_no_parents_graft
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftsinmemoryrepoteststest_object_store_fail_invalid_parents" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftsInMemoryRepoTests::test_object_store_fail_invalid_parents
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graftspygraftsinmemoryrepoteststest_remove_graft" class="md-nav__link">
    <span class="md-ellipsis">
      test_grafts.py::GraftsInMemoryRepoTests::test_remove_graft
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graphpyfindmergebaseteststest_ancestor" class="md-nav__link">
    <span class="md-ellipsis">
      test_graph.py::FindMergeBaseTests::test_ancestor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graphpyfindmergebaseteststest_another_crossover" class="md-nav__link">
    <span class="md-ellipsis">
      test_graph.py::FindMergeBaseTests::test_another_crossover
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graphpyfindmergebaseteststest_direct_parent" class="md-nav__link">
    <span class="md-ellipsis">
      test_graph.py::FindMergeBaseTests::test_direct_parent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graphpyfindmergebaseteststest_multiple_lca" class="md-nav__link">
    <span class="md-ellipsis">
      test_graph.py::FindMergeBaseTests::test_multiple_lca
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graphpyfindmergebaseteststest_no_common_ancestor" class="md-nav__link">
    <span class="md-ellipsis">
      test_graph.py::FindMergeBaseTests::test_no_common_ancestor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graphpyfindmergebaseteststest_octopus" class="md-nav__link">
    <span class="md-ellipsis">
      test_graph.py::FindMergeBaseTests::test_octopus
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graphpyfindmergebaseteststest_three_way_merge_lca" class="md-nav__link">
    <span class="md-ellipsis">
      test_graph.py::FindMergeBaseTests::test_three_way_merge_lca
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graphpycanfastforwardteststest_diverged" class="md-nav__link">
    <span class="md-ellipsis">
      test_graph.py::CanFastForwardTests::test_diverged
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graphpycanfastforwardteststest_ff" class="md-nav__link">
    <span class="md-ellipsis">
      test_graph.py::CanFastForwardTests::test_ff
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_graphpyworklisttesttest_worklist" class="md-nav__link">
    <span class="md-ellipsis">
      test_graph.py::WorkListTest::test_WorkList
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_greenthreadspytestgreenthreadsmissingobjectfindertest_finder" class="md-nav__link">
    <span class="md-ellipsis">
      test_greenthreads.py::TestGreenThreadsMissingObjectFinder::test_finder
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_hookspyshellhookteststest_hook_commit_msg" class="md-nav__link">
    <span class="md-ellipsis">
      test_hooks.py::ShellHookTests::test_hook_commit_msg
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_hookspyshellhookteststest_hook_post_commit" class="md-nav__link">
    <span class="md-ellipsis">
      test_hooks.py::ShellHookTests::test_hook_post_commit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_hookspyshellhookteststest_hook_pre_commit" class="md-nav__link">
    <span class="md-ellipsis">
      test_hooks.py::ShellHookTests::test_hook_pre_commit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ignorepytranslateteststest_translate" class="md-nav__link">
    <span class="md-ellipsis">
      test_ignore.py::TranslateTests::test_translate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ignorepyreadignorepatternstest_read_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_ignore.py::ReadIgnorePatterns::test_read_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ignorepymatchpatternteststest_matches" class="md-nav__link">
    <span class="md-ellipsis">
      test_ignore.py::MatchPatternTests::test_matches
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ignorepyignorefilterteststest_excluded" class="md-nav__link">
    <span class="md-ellipsis">
      test_ignore.py::IgnoreFilterTests::test_excluded
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ignorepyignorefilterteststest_include_exclude_include" class="md-nav__link">
    <span class="md-ellipsis">
      test_ignore.py::IgnoreFilterTests::test_include_exclude_include
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ignorepyignorefilterteststest_included" class="md-nav__link">
    <span class="md-ellipsis">
      test_ignore.py::IgnoreFilterTests::test_included
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ignorepyignorefilterteststest_included_ignorecase" class="md-nav__link">
    <span class="md-ellipsis">
      test_ignore.py::IgnoreFilterTests::test_included_ignorecase
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ignorepyignorefilterteststest_manpage" class="md-nav__link">
    <span class="md-ellipsis">
      test_ignore.py::IgnoreFilterTests::test_manpage
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ignorepyignorefilterteststest_regex_special" class="md-nav__link">
    <span class="md-ellipsis">
      test_ignore.py::IgnoreFilterTests::test_regex_special
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ignorepyignorefilterstackteststest_stack_first" class="md-nav__link">
    <span class="md-ellipsis">
      test_ignore.py::IgnoreFilterStackTests::test_stack_first
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ignorepyignorefiltermanagerteststest_ignored_contents" class="md-nav__link">
    <span class="md-ellipsis">
      test_ignore.py::IgnoreFilterManagerTests::test_ignored_contents
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ignorepyignorefiltermanagerteststest_load_ignore" class="md-nav__link">
    <span class="md-ellipsis">
      test_ignore.py::IgnoreFilterManagerTests::test_load_ignore
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ignorepyignorefiltermanagerteststest_load_ignore_ignorecase" class="md-nav__link">
    <span class="md-ellipsis">
      test_ignore.py::IgnoreFilterManagerTests::test_load_ignore_ignorecase
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ignorepyignorefiltermanagerteststest_nested_gitignores" class="md-nav__link">
    <span class="md-ellipsis">
      test_ignore.py::IgnoreFilterManagerTests::test_nested_gitignores
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpysimpleindextestcasetest_against_empty_tree" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::SimpleIndexTestCase::test_against_empty_tree
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpysimpleindextestcasetest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::SimpleIndexTestCase::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpysimpleindextestcasetest_getitem" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::SimpleIndexTestCase::test_getitem
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpysimpleindextestcasetest_iter" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::SimpleIndexTestCase::test_iter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpysimpleindextestcasetest_iterobjects" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::SimpleIndexTestCase::test_iterobjects
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpysimpleindextestcasetest_len" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::SimpleIndexTestCase::test_len
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpysimpleindexwritertestcasetest_simple_write" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::SimpleIndexWriterTestCase::test_simple_write
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpyreadindexdictteststest_simple_write" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::ReadIndexDictTests::test_simple_write
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpycommittreeteststest_nested" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::CommitTreeTests::test_nested
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpycommittreeteststest_single_blob" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::CommitTreeTests::test_single_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpycleanupmodeteststest_dir" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::CleanupModeTests::test_dir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpycleanupmodeteststest_executable" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::CleanupModeTests::test_executable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpycleanupmodeteststest_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::CleanupModeTests::test_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpycleanupmodeteststest_submodule" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::CleanupModeTests::test_submodule
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpycleanupmodeteststest_symlink" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::CleanupModeTests::test_symlink
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpywritecachetimeteststest_write_float" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::WriteCacheTimeTests::test_write_float
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpywritecachetimeteststest_write_int" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::WriteCacheTimeTests::test_write_int
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpywritecachetimeteststest_write_string" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::WriteCacheTimeTests::test_write_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpywritecachetimeteststest_write_tuple" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::WriteCacheTimeTests::test_write_tuple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpyindexentryfromstatteststest_override_mode" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::IndexEntryFromStatTests::test_override_mode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpyindexentryfromstatteststest_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::IndexEntryFromStatTests::test_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpybuildindexteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::BuildIndexTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpybuildindexteststest_git_dir" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::BuildIndexTests::test_git_dir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpybuildindexteststest_git_submodule" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::BuildIndexTests::test_git_submodule
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpybuildindexteststest_git_submodule_exists" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::BuildIndexTests::test_git_submodule_exists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpybuildindexteststest_no_decode_encode" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::BuildIndexTests::test_no_decode_encode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpybuildindexteststest_nonempty" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::BuildIndexTests::test_nonempty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpybuildindexteststest_norewrite" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::BuildIndexTests::test_norewrite
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpybuildindexteststest_symlink" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::BuildIndexTests::test_symlink
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpygetunstagedchangesteststest_get_unstaged_changes" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::GetUnstagedChangesTests::test_get_unstaged_changes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpygetunstagedchangesteststest_get_unstaged_changes_removed_replaced_by_directory" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::GetUnstagedChangesTests::test_get_unstaged_changes_removed_replaced_by_directory
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpygetunstagedchangesteststest_get_unstaged_changes_removed_replaced_by_link" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::GetUnstagedChangesTests::test_get_unstaged_changes_removed_replaced_by_link
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpygetunstagedchangesteststest_get_unstaged_deleted_changes" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::GetUnstagedChangesTests::test_get_unstaged_deleted_changes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpytestvalidatepathelementtest_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::TestValidatePathElement::test_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpytestvalidatepathelementtest_ntfs" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::TestValidatePathElement::test_ntfs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpytesttreefspathconversiontest_fs_to_tree_path_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::TestTreeFSPathConversion::test_fs_to_tree_path_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpytesttreefspathconversiontest_fs_to_tree_path_str" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::TestTreeFSPathConversion::test_fs_to_tree_path_str
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_indexpytesttreefspathconversiontest_tree_to_fs_path" class="md-nav__link">
    <span class="md-ellipsis">
      test_index.py::TestTreeFSPathConversion::test_tree_to_fs_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lfspylfsteststest_create" class="md-nav__link">
    <span class="md-ellipsis">
      test_lfs.py::LFSTests::test_create
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lfspylfsteststest_missing" class="md-nav__link">
    <span class="md-ellipsis">
      test_lfs.py::LFSTests::test_missing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_line_endingpylineendingconversiontest_convert_crlf_to_lf" class="md-nav__link">
    <span class="md-ellipsis">
      test_line_ending.py::LineEndingConversion::test_convert_crlf_to_lf
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_line_endingpylineendingconversiontest_convert_crlf_to_lf_mixed" class="md-nav__link">
    <span class="md-ellipsis">
      test_line_ending.py::LineEndingConversion::test_convert_crlf_to_lf_mixed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_line_endingpylineendingconversiontest_convert_crlf_to_lf_no_op" class="md-nav__link">
    <span class="md-ellipsis">
      test_line_ending.py::LineEndingConversion::test_convert_crlf_to_lf_no_op
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_line_endingpylineendingconversiontest_convert_lf_to_crlf" class="md-nav__link">
    <span class="md-ellipsis">
      test_line_ending.py::LineEndingConversion::test_convert_lf_to_crlf
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_line_endingpylineendingconversiontest_convert_lf_to_crlf_mixed" class="md-nav__link">
    <span class="md-ellipsis">
      test_line_ending.py::LineEndingConversion::test_convert_lf_to_crlf_mixed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_line_endingpylineendingconversiontest_convert_lf_to_crlf_no_op" class="md-nav__link">
    <span class="md-ellipsis">
      test_line_ending.py::LineEndingConversion::test_convert_lf_to_crlf_no_op
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_line_endingpygetlineendingautocrlffilterstest_get_checkin_filter_autocrlf_input" class="md-nav__link">
    <span class="md-ellipsis">
      test_line_ending.py::GetLineEndingAutocrlfFilters::test_get_checkin_filter_autocrlf_input
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_line_endingpygetlineendingautocrlffilterstest_get_checkin_filter_autocrlf_true" class="md-nav__link">
    <span class="md-ellipsis">
      test_line_ending.py::GetLineEndingAutocrlfFilters::test_get_checkin_filter_autocrlf_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_line_endingpygetlineendingautocrlffilterstest_get_checkout_filter_autocrlf_true" class="md-nav__link">
    <span class="md-ellipsis">
      test_line_ending.py::GetLineEndingAutocrlfFilters::test_get_checkout_filter_autocrlf_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_line_endingpynormalizeblobtestcasetest_normalize_to_crlf" class="md-nav__link">
    <span class="md-ellipsis">
      test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_crlf
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_line_endingpynormalizeblobtestcasetest_normalize_to_crlf_binary" class="md-nav__link">
    <span class="md-ellipsis">
      test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_crlf_binary
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_line_endingpynormalizeblobtestcasetest_normalize_to_crlf_no_op" class="md-nav__link">
    <span class="md-ellipsis">
      test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_crlf_no_op
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_line_endingpynormalizeblobtestcasetest_normalize_to_lf" class="md-nav__link">
    <span class="md-ellipsis">
      test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_lf
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_line_endingpynormalizeblobtestcasetest_normalize_to_lf_binary" class="md-nav__link">
    <span class="md-ellipsis">
      test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_lf_binary
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_line_endingpynormalizeblobtestcasetest_normalize_to_lf_no_op" class="md-nav__link">
    <span class="md-ellipsis">
      test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_lf_no_op
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_add__null_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_add__null_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_after_cleanup_larger_than_max" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_after_cleanup_larger_than_max
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_after_cleanup_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_after_cleanup_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_by_usage" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_by_usage
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_cache_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_cache_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_cleanup" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_cleanup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_cleanup_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_cleanup_2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_cleanup_on_replace" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_cleanup_on_replace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_cleanup_shrinks_to_after_clean_count" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_cleanup_shrinks_to_after_clean_count
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_get" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_get
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_keys" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_keys
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_len" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_len
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_map_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_map_None
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_missing" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_missing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_overflow" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_overflow
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_preserve_last_access_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_preserve_last_access_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_resize_larger" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_resize_larger
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrucachetest_resize_smaller" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUCache::test_resize_smaller
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrusizecachetest_add__null_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUSizeCache::test_add__null_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrusizecachetest_add_tracks_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUSizeCache::test_add_tracks_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrusizecachetest_adding_clears_cache_based_on_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUSizeCache::test_adding_clears_cache_based_on_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrusizecachetest_adding_clears_to_after_cleanup_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUSizeCache::test_adding_clears_to_after_cleanup_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrusizecachetest_basic_init" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUSizeCache::test_basic_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrusizecachetest_cleanup" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUSizeCache::test_cleanup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrusizecachetest_custom_sizes" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUSizeCache::test_custom_sizes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrusizecachetest_keys" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUSizeCache::test_keys
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrusizecachetest_no_add_over_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUSizeCache::test_no_add_over_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrusizecachetest_no_add_over_size_cleanup" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUSizeCache::test_no_add_over_size_cleanup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrusizecachetest_remove_tracks_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUSizeCache::test_remove_tracks_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrusizecachetest_resize_larger" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUSizeCache::test_resize_larger
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lru_cachepytestlrusizecachetest_resize_smaller" class="md-nav__link">
    <span class="md-ellipsis">
      test_lru_cache.py::TestLRUSizeCache::test_resize_smaller
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mailmappyreadmailmapteststest_read" class="md-nav__link">
    <span class="md-ellipsis">
      test_mailmap.py::ReadMailmapTests::test_read
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mailmappymailmapteststest_lookup" class="md-nav__link">
    <span class="md-ellipsis">
      test_mailmap.py::MailmapTests::test_lookup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_missing_obj_finderpymoflinearrepotesttest_1_to_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_missing_obj_finder.py::MOFLinearRepoTest::test_1_to_2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_missing_obj_finderpymoflinearrepotesttest_1_to_3" class="md-nav__link">
    <span class="md-ellipsis">
      test_missing_obj_finder.py::MOFLinearRepoTest::test_1_to_3
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_missing_obj_finderpymoflinearrepotesttest_2_to_3" class="md-nav__link">
    <span class="md-ellipsis">
      test_missing_obj_finder.py::MOFLinearRepoTest::test_2_to_3
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_missing_obj_finderpymoflinearrepotesttest_bogus_haves" class="md-nav__link">
    <span class="md-ellipsis">
      test_missing_obj_finder.py::MOFLinearRepoTest::test_bogus_haves
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_missing_obj_finderpymoflinearrepotesttest_bogus_wants_failure" class="md-nav__link">
    <span class="md-ellipsis">
      test_missing_obj_finder.py::MOFLinearRepoTest::test_bogus_wants_failure
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_missing_obj_finderpymoflinearrepotesttest_no_changes" class="md-nav__link">
    <span class="md-ellipsis">
      test_missing_obj_finder.py::MOFLinearRepoTest::test_no_changes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_missing_obj_finderpymofmergeforkrepotesttest_have1_want6" class="md-nav__link">
    <span class="md-ellipsis">
      test_missing_obj_finder.py::MOFMergeForkRepoTest::test_have1_want6
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_missing_obj_finderpymofmergeforkrepotesttest_have3_want6" class="md-nav__link">
    <span class="md-ellipsis">
      test_missing_obj_finder.py::MOFMergeForkRepoTest::test_have3_want6
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_missing_obj_finderpymofmergeforkrepotesttest_have4_want7" class="md-nav__link">
    <span class="md-ellipsis">
      test_missing_obj_finder.py::MOFMergeForkRepoTest::test_have4_want7
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_missing_obj_finderpymofmergeforkrepotesttest_have5_want7" class="md-nav__link">
    <span class="md-ellipsis">
      test_missing_obj_finder.py::MOFMergeForkRepoTest::test_have5_want7
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_missing_obj_finderpymofmergeforkrepotesttest_have6_want7" class="md-nav__link">
    <span class="md-ellipsis">
      test_missing_obj_finder.py::MOFMergeForkRepoTest::test_have6_want7
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_missing_obj_finderpymoftagstesttest_tagged_blob" class="md-nav__link">
    <span class="md-ellipsis">
      test_missing_obj_finder.py::MOFTagsTest::test_tagged_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_missing_obj_finderpymoftagstesttest_tagged_commit" class="md-nav__link">
    <span class="md-ellipsis">
      test_missing_obj_finder.py::MOFTagsTest::test_tagged_commit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_missing_obj_finderpymoftagstesttest_tagged_tag" class="md-nav__link">
    <span class="md-ellipsis">
      test_missing_obj_finder.py::MOFTagsTest::test_tagged_tag
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_missing_obj_finderpymoftagstesttest_tagged_tagged_blob" class="md-nav__link">
    <span class="md-ellipsis">
      test_missing_obj_finder.py::MOFTagsTest::test_tagged_tagged_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_missing_obj_finderpymoftagstesttest_tagged_tree" class="md-nav__link">
    <span class="md-ellipsis">
      test_missing_obj_finder.py::MOFTagsTest::test_tagged_tree
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepymemoryobjectstoreteststest_add_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::MemoryObjectStoreTests::test_add_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepymemoryobjectstoreteststest_add_pack_emtpy" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::MemoryObjectStoreTests::test_add_pack_emtpy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepymemoryobjectstoreteststest_add_thin_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::MemoryObjectStoreTests::test_add_thin_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepymemoryobjectstoreteststest_add_thin_pack_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::MemoryObjectStoreTests::test_add_thin_pack_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepydiskobjectstoreteststest_add_alternate_path" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::DiskObjectStoreTests::test_add_alternate_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepydiskobjectstoreteststest_add_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::DiskObjectStoreTests::test_add_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepydiskobjectstoreteststest_add_thin_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::DiskObjectStoreTests::test_add_thin_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepydiskobjectstoreteststest_add_thin_pack_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::DiskObjectStoreTests::test_add_thin_pack_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepydiskobjectstoreteststest_alternates" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::DiskObjectStoreTests::test_alternates
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepydiskobjectstoreteststest_corrupted_object_raise_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::DiskObjectStoreTests::test_corrupted_object_raise_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepydiskobjectstoreteststest_file_modes" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::DiskObjectStoreTests::test_file_modes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepydiskobjectstoreteststest_loose_compression_level" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::DiskObjectStoreTests::test_loose_compression_level
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepydiskobjectstoreteststest_pack_dir" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::DiskObjectStoreTests::test_pack_dir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepydiskobjectstoreteststest_read_alternate_paths" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::DiskObjectStoreTests::test_read_alternate_paths
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepydiskobjectstoreteststest_rel_alternative_path" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::DiskObjectStoreTests::test_rel_alternative_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepydiskobjectstoreteststest_store_resilience" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::DiskObjectStoreTests::test_store_resilience
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepydiskobjectstoreteststest_tempfile_in_loose_store" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::DiskObjectStoreTests::test_tempfile_in_loose_store
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepytreelookuppathteststest_lookup_blob" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::TreeLookupPathTests::test_lookup_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepytreelookuppathteststest_lookup_nonexistent" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::TreeLookupPathTests::test_lookup_nonexistent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepytreelookuppathteststest_lookup_not_tree" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::TreeLookupPathTests::test_lookup_not_tree
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepytreelookuppathteststest_lookup_submodule" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::TreeLookupPathTests::test_lookup_submodule
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepytreelookuppathteststest_lookup_tree" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::TreeLookupPathTests::test_lookup_tree
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepyobjectstoregraphwalkerteststest_ack_invalid_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::ObjectStoreGraphWalkerTests::test_ack_invalid_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepyobjectstoregraphwalkerteststest_child_ack_later" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::ObjectStoreGraphWalkerTests::test_child_ack_later
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepyobjectstoregraphwalkerteststest_descends" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::ObjectStoreGraphWalkerTests::test_descends
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepyobjectstoregraphwalkerteststest_only_once" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::ObjectStoreGraphWalkerTests::test_only_once
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepyobjectstoregraphwalkerteststest_parent_present" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::ObjectStoreGraphWalkerTests::test_parent_present
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepycommittreechangesteststest_add_blob" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::CommitTreeChangesTests::test_add_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepycommittreechangesteststest_add_blob_in_dir" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::CommitTreeChangesTests::test_add_blob_in_dir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepycommittreechangesteststest_delete_blob" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::CommitTreeChangesTests::test_delete_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepycommittreechangesteststest_no_changes" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::CommitTreeChangesTests::test_no_changes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_object_storepytestreadpacksfiletest_read_packs" class="md-nav__link">
    <span class="md-ellipsis">
      test_object_store.py::TestReadPacksFile::test_read_packs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_chunks" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_chunks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_create_blob_from_string" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_create_blob_from_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_decompress_simple_blob" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_decompress_simple_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_eq" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_eq
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_hash" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_hash
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_legacy_from_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_legacy_from_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_legacy_from_file_compression_level" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_legacy_from_file_compression_level
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_parse_empty_blob_object" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_parse_empty_blob_object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_parse_legacy_blob" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_parse_legacy_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_read_commit_from_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_read_commit_from_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_read_commit_no_parents" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_read_commit_no_parents
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_read_commit_two_parents" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_read_commit_two_parents
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_read_tag_from_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_read_tag_from_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_read_tree_from_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_read_tree_from_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_read_tree_from_file_parse_count" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_read_tree_from_file_parse_count
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_set_chunks" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_set_chunks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_splitlines" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_splitlines
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyblobreadteststest_stub_sha" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::BlobReadTests::test_stub_sha
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyshafileteststest_deflated_smaller_window_buffer" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::ShaFileTests::test_deflated_smaller_window_buffer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitserializationteststest_deserialize" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitSerializationTests::test_deserialize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitserializationteststest_deserialize_mergetag" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitSerializationTests::test_deserialize_mergetag
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitserializationteststest_deserialize_mergetags" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitSerializationTests::test_deserialize_mergetags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitserializationteststest_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitSerializationTests::test_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitserializationteststest_full_tree" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitSerializationTests::test_full_tree
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitserializationteststest_neg_timezone" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitSerializationTests::test_neg_timezone
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitserializationteststest_raw_length" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitSerializationTests::test_raw_length
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitserializationteststest_serialize_gpgsig" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitSerializationTests::test_serialize_gpgsig
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitserializationteststest_serialize_mergetag" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitSerializationTests::test_serialize_mergetag
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitserializationteststest_serialize_mergetags" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitSerializationTests::test_serialize_mergetags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitserializationteststest_short_timestamp" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitSerializationTests::test_short_timestamp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitserializationteststest_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitSerializationTests::test_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitserializationteststest_timezone" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitSerializationTests::test_timezone
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitparseteststest_check" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitParseTests::test_check
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitparseteststest_check_commit_with_overflow_date" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitParseTests::test_check_commit_with_overflow_date
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitparseteststest_check_commit_with_unparseable_time" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitParseTests::test_check_commit_with_unparseable_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitparseteststest_check_duplicates" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitParseTests::test_check_duplicates
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitparseteststest_check_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitParseTests::test_check_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitparseteststest_custom" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitParseTests::test_custom
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitparseteststest_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitParseTests::test_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitparseteststest_mangled_author_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitParseTests::test_mangled_author_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitparseteststest_parse_gpgsig" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitParseTests::test_parse_gpgsig
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitparseteststest_parse_header_trailing_newline" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitParseTests::test_parse_header_trailing_newline
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycommitparseteststest_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CommitParseTests::test_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytreeteststest_add" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TreeTests::test_add
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytreeteststest_check" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TreeTests::test_check
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytreeteststest_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TreeTests::test_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytreeteststest_tree_items_dir_sort" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TreeTests::test_tree_items_dir_sort
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytreeteststest_tree_iteritems_dir_sort" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TreeTests::test_tree_iteritems_dir_sort
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytreeteststest_tree_update_id" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TreeTests::test_tree_update_id
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytagserializeteststest_serialize_none_message" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TagSerializeTests::test_serialize_none_message
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytagserializeteststest_serialize_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TagSerializeTests::test_serialize_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytagparseteststest_check" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TagParseTests::test_check
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytagparseteststest_check_duplicates" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TagParseTests::test_check_duplicates
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytagparseteststest_check_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TagParseTests::test_check_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytagparseteststest_check_tag_with_overflow_time" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TagParseTests::test_check_tag_with_overflow_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytagparseteststest_check_tag_with_unparseable_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TagParseTests::test_check_tag_with_unparseable_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytagparseteststest_parse" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TagParseTests::test_parse
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytagparseteststest_parse_no_message" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TagParseTests::test_parse_no_message
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytagparseteststest_parse_no_tagger" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TagParseTests::test_parse_no_tagger
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytagparseteststest_tree_copy_after_update" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TagParseTests::test_tree_copy_after_update
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspycheckteststest_check_identity" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::CheckTests::test_check_identity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytimezoneteststest_format_timezone_cet" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TimezoneTests::test_format_timezone_cet
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytimezoneteststest_format_timezone_double_negative" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TimezoneTests::test_format_timezone_double_negative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytimezoneteststest_format_timezone_pdt" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TimezoneTests::test_format_timezone_pdt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytimezoneteststest_format_timezone_pdt_half" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TimezoneTests::test_format_timezone_pdt_half
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytimezoneteststest_generate_timezone_utc" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TimezoneTests::test_generate_timezone_utc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytimezoneteststest_generate_timezone_utc_negative" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TimezoneTests::test_generate_timezone_utc_negative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytimezoneteststest_parse_timezone_cet" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TimezoneTests::test_parse_timezone_cet
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytimezoneteststest_parse_timezone_double_negative" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TimezoneTests::test_parse_timezone_double_negative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytimezoneteststest_parse_timezone_pdt" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TimezoneTests::test_parse_timezone_pdt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytimezoneteststest_parse_timezone_pdt_half" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TimezoneTests::test_parse_timezone_pdt_half
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytimezoneteststest_parse_timezone_utc" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TimezoneTests::test_parse_timezone_utc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspytimezoneteststest_parse_timezone_utc_negative" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::TimezoneTests::test_parse_timezone_utc_negative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyshafilecopyteststest_blob_copy" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::ShaFileCopyTests::test_blob_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyshafilecopyteststest_commit_copy" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::ShaFileCopyTests::test_commit_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyshafilecopyteststest_tag_copy" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::ShaFileCopyTests::test_tag_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyshafilecopyteststest_tree_copy" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::ShaFileCopyTests::test_tree_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyshafileserializeteststest_blob_serialize" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::ShaFileSerializeTests::test_blob_serialize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyshafileserializeteststest_commit_serialize" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::ShaFileSerializeTests::test_commit_serialize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyshafileserializeteststest_tag_serialize" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::ShaFileSerializeTests::test_tag_serialize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyshafileserializeteststest_tag_serialize_time_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::ShaFileSerializeTests::test_tag_serialize_time_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyshafileserializeteststest_tree_serialize" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::ShaFileSerializeTests::test_tree_serialize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspyprettyformattreeentryteststest_format" class="md-nav__link">
    <span class="md-ellipsis">
      test_objects.py::PrettyFormatTreeEntryTests::test_format
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparseobjectteststest_blob_by_sha" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseObjectTests::test_blob_by_sha
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparseobjectteststest_nonexistent" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseObjectTests::test_nonexistent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsecommitrangeteststest_commit_by_sha" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseCommitRangeTests::test_commit_by_sha
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsecommitrangeteststest_nonexistent" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseCommitRangeTests::test_nonexistent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsecommitteststest_commit_by_sha" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseCommitTests::test_commit_by_sha
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsecommitteststest_commit_by_short_sha" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseCommitTests::test_commit_by_short_sha
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsecommitteststest_nonexistent" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseCommitTests::test_nonexistent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparserefteststest_ambiguous_head" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseRefTests::test_ambiguous_head
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparserefteststest_ambiguous_ref" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseRefTests::test_ambiguous_ref
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparserefteststest_ambiguous_ref2" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseRefTests::test_ambiguous_ref2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparserefteststest_ambiguous_remote" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseRefTests::test_ambiguous_remote
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparserefteststest_ambiguous_remote_head" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseRefTests::test_ambiguous_remote_head
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparserefteststest_ambiguous_tag" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseRefTests::test_ambiguous_tag
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparserefteststest_heads_full" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseRefTests::test_heads_full
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparserefteststest_heads_partial" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseRefTests::test_heads_partial
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparserefteststest_nonexistent" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseRefTests::test_nonexistent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparserefteststest_tags_partial" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseRefTests::test_tags_partial
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparserefsteststest_full" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseRefsTests::test_full
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparserefsteststest_head" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseRefsTests::test_head
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparserefsteststest_nonexistent" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseRefsTests::test_nonexistent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsereftupleteststest_default_with_string" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseReftupleTests::test_default_with_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsereftupleteststest_full" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseReftupleTests::test_full
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsereftupleteststest_head" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseReftupleTests::test_head
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsereftupleteststest_no_left_ref" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseReftupleTests::test_no_left_ref
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsereftupleteststest_no_right_ref" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseReftupleTests::test_no_right_ref
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsereftupleteststest_nonexistent" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseReftupleTests::test_nonexistent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsereftuplesteststest_full" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseReftuplesTests::test_full
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsereftuplesteststest_head" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseReftuplesTests::test_head
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsereftuplesteststest_nonexistent" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseReftuplesTests::test_nonexistent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsetreeteststest_from_commit" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseTreeTests::test_from_commit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsetreeteststest_from_ref" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseTreeTests::test_from_ref
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objectspecpyparsetreeteststest_nonexistent" class="md-nav__link">
    <span class="md-ellipsis">
      test_objectspec.py::ParseTreeTests::test_nonexistent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpypackindexteststest_get_stored_checksum" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::PackIndexTests::test_get_stored_checksum
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpypackindexteststest_index_check" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::PackIndexTests::test_index_check
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpypackindexteststest_index_len" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::PackIndexTests::test_index_len
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpypackindexteststest_iter" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::PackIndexTests::test_iter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpypackindexteststest_iterentries" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::PackIndexTests::test_iterentries
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpypackindexteststest_object_offset" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::PackIndexTests::test_object_offset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpypackindexteststest_object_sha1" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::PackIndexTests::test_object_sha1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdeltastest_change" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackDeltas::test_change
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdeltastest_dest_overflow" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackDeltas::test_dest_overflow
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdeltastest_empty_to_big" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackDeltas::test_empty_to_big
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdeltastest_empty_to_huge" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackDeltas::test_empty_to_huge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdeltastest_huge_copy" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackDeltas::test_huge_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdeltastest_nochange" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackDeltas::test_nochange
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdeltastest_nochange_huge" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackDeltas::test_nochange_huge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdeltastest_pypy_issue" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackDeltas::test_pypy_issue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdeltastest_rewrite" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackDeltas::test_rewrite
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdatatest_compute_file_sha" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackData::test_compute_file_sha
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdatatest_compute_file_sha_short_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackData::test_compute_file_sha_short_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdatatest_create_index_v1" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackData::test_create_index_v1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdatatest_create_index_v2" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackData::test_create_index_v2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdatatest_create_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackData::test_create_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdatatest_from_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackData::test_from_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdatatest_index_check" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackData::test_index_check
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdatatest_iter_unpacked" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackData::test_iter_unpacked
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdatatest_iterentries" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackData::test_iterentries
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackdatatest_pack_len" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackData::test_pack_len
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_checksum_mismatch" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_checksum_mismatch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_commit_obj" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_commit_obj
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_contains" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_contains
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_copy_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_get" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_get
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_get_object_at" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_get_object_at
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_iter" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_iter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_iterobjects" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_iterobjects
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_iterobjects_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_iterobjects_2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_iterobjects_subset" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_iterobjects_subset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_keep_message" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_keep_message
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_keep_no_message" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_keep_no_message
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_len" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_len
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_length_mismatch" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_length_mismatch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpacktest_pack_tuples" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPack::test_pack_tuples
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestthinpacktest_get_raw" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestThinPack::test_get_raw
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestthinpacktest_get_unpacked_object" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestThinPack::test_get_unpacked_object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestthinpacktest_iterobjects" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestThinPack::test_iterobjects
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpywritepackteststest_write_pack_header" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::WritePackTests::test_write_pack_header
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpywritepackteststest_write_pack_object" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::WritePackTests::test_write_pack_object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpywritepackteststest_write_pack_object_compression_level" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::WritePackTests::test_write_pack_object_compression_level
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpywritepackteststest_write_pack_object_sha" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::WritePackTests::test_write_pack_object_sha
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestmemoryindexwritingtest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestMemoryIndexWriting::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestmemoryindexwritingtest_large" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestMemoryIndexWriting::test_large
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestmemoryindexwritingtest_single" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestMemoryIndexWriting::test_single
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackindexwritingv1test_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackIndexWritingv1::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackindexwritingv1test_large" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackIndexWritingv1::test_large
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackindexwritingv1test_single" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackIndexWritingv1::test_single
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackindexwritingv2test_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackIndexWritingv2::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackindexwritingv2test_large" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackIndexWritingv2::test_large
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackindexwritingv2test_single" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackIndexWritingv2::test_single
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpyreadzlibteststest_decompress_buffer_size_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::ReadZlibTests::test_decompress_buffer_size_1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpyreadzlibteststest_decompress_buffer_size_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::ReadZlibTests::test_decompress_buffer_size_2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpyreadzlibteststest_decompress_buffer_size_3" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::ReadZlibTests::test_decompress_buffer_size_3
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpyreadzlibteststest_decompress_buffer_size_4" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::ReadZlibTests::test_decompress_buffer_size_4
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpyreadzlibteststest_decompress_include_comp" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::ReadZlibTests::test_decompress_include_comp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpyreadzlibteststest_decompress_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::ReadZlibTests::test_decompress_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpyreadzlibteststest_decompress_truncated" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::ReadZlibTests::test_decompress_truncated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpyreadzlibteststest_simple_decompress" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::ReadZlibTests::test_simple_decompress
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltifyteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltifyTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltifyteststest_simple_delta" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltifyTests::test_simple_delta
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltifyteststest_single" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltifyTests::test_single
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackstreamreadertest_read_objects" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackStreamReader::test_read_objects
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackstreamreadertest_read_objects_buffered" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackStreamReader::test_read_objects_buffered
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackstreamreadertest_read_objects_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackStreamReader::test_read_objects_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpytestpackstreamreadertest_read_objects_emtpy" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::TestPackStreamReader::test_read_objects_emtpy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_bad_ext_ref_non_thin_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_bad_ext_ref_non_thin_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_bad_ext_ref_thin_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_bad_ext_ref_thin_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_branchy_chain" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_branchy_chain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_ext_ref" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_ext_ref
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_ext_ref_chain" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_ext_ref_chain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_ext_ref_chain_degenerate" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_ext_ref_chain_degenerate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_ext_ref_deltified_object_based_on_itself" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_ext_ref_deltified_object_based_on_itself
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_ext_ref_multiple_times" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_ext_ref_multiple_times
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_long_chain" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_long_chain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_mixed_chain" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_mixed_chain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_multiple_ext_refs" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_multiple_ext_refs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_no_deltas" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_no_deltas
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_ofs_and_ref_deltas" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_ofs_and_ref_deltas
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_ofs_deltas" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_ofs_deltas
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_ofs_deltas_chain" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_ofs_deltas_chain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_ref_deltas" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_ref_deltas
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpydeltachainiteratorteststest_ref_deltas_chain" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::DeltaChainIteratorTests::test_ref_deltas_chain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packpyencodecopyoperationteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_pack.py::EncodeCopyOperationTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpywritecommitpatchteststest_simple_bytesio" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::WriteCommitPatchTests::test_simple_bytesio
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpyreadgitampatchtest_extract_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::ReadGitAmPatch::test_extract_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpyreadgitampatchtest_extract_no_version_tail" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::ReadGitAmPatch::test_extract_no_version_tail
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpyreadgitampatchtest_extract_pseudo_from_header" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::ReadGitAmPatch::test_extract_pseudo_from_header
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpyreadgitampatchtest_extract_spaces" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::ReadGitAmPatch::test_extract_spaces
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpyreadgitampatchtest_extract_string" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::ReadGitAmPatch::test_extract_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpydiffteststest_blob_add" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::DiffTests::test_blob_add
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpydiffteststest_blob_diff" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::DiffTests::test_blob_diff
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpydiffteststest_blob_remove" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::DiffTests::test_blob_remove
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpydiffteststest_object_diff_add_bin_blob" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::DiffTests::test_object_diff_add_bin_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpydiffteststest_object_diff_add_blob" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::DiffTests::test_object_diff_add_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpydiffteststest_object_diff_bin_blob" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::DiffTests::test_object_diff_bin_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpydiffteststest_object_diff_bin_blob_force" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::DiffTests::test_object_diff_bin_blob_force
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpydiffteststest_object_diff_blob" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::DiffTests::test_object_diff_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpydiffteststest_object_diff_kind_change" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::DiffTests::test_object_diff_kind_change
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpydiffteststest_object_diff_remove_bin_blob" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::DiffTests::test_object_diff_remove_bin_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpydiffteststest_object_diff_remove_blob" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::DiffTests::test_object_diff_remove_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpydiffteststest_tree_diff" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::DiffTests::test_tree_diff
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpydiffteststest_tree_diff_submodule" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::DiffTests::test_tree_diff_submodule
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpygetsummaryteststest_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::GetSummaryTests::test_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyprotocolteststest_eof" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ProtocolTests::test_eof
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyprotocolteststest_read_cmd" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ProtocolTests::test_read_cmd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyprotocolteststest_read_cmd_noend0" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ProtocolTests::test_read_cmd_noend0
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyprotocolteststest_read_pkt_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ProtocolTests::test_read_pkt_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyprotocolteststest_read_pkt_line_wrong_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ProtocolTests::test_read_pkt_line_wrong_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyprotocolteststest_read_pkt_seq" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ProtocolTests::test_read_pkt_seq
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyprotocolteststest_send_cmd" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ProtocolTests::test_send_cmd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyprotocolteststest_unread_pkt_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ProtocolTests::test_unread_pkt_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyprotocolteststest_write_pkt_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ProtocolTests::test_write_pkt_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyprotocolteststest_write_pkt_line_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ProtocolTests::test_write_pkt_line_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyprotocolteststest_write_sideband" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ProtocolTests::test_write_sideband
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyreceivableprotocolteststest_eof" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ReceivableProtocolTests::test_eof
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyreceivableprotocolteststest_mixed" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ReceivableProtocolTests::test_mixed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyreceivableprotocolteststest_read_cmd" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ReceivableProtocolTests::test_read_cmd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyreceivableprotocolteststest_read_cmd_noend0" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ReceivableProtocolTests::test_read_cmd_noend0
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyreceivableprotocolteststest_read_pkt_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ReceivableProtocolTests::test_read_pkt_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyreceivableprotocolteststest_read_pkt_line_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ReceivableProtocolTests::test_read_pkt_line_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyreceivableprotocolteststest_read_pkt_line_wrong_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ReceivableProtocolTests::test_read_pkt_line_wrong_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyreceivableprotocolteststest_read_pkt_seq" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ReceivableProtocolTests::test_read_pkt_seq
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyreceivableprotocolteststest_read_recv" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ReceivableProtocolTests::test_read_recv
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyreceivableprotocolteststest_recv" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ReceivableProtocolTests::test_recv
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyreceivableprotocolteststest_recv_read" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ReceivableProtocolTests::test_recv_read
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyreceivableprotocolteststest_send_cmd" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ReceivableProtocolTests::test_send_cmd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyreceivableprotocolteststest_unread_pkt_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ReceivableProtocolTests::test_unread_pkt_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyreceivableprotocolteststest_write_pkt_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ReceivableProtocolTests::test_write_pkt_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyreceivableprotocolteststest_write_pkt_line_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ReceivableProtocolTests::test_write_pkt_line_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpyreceivableprotocolteststest_write_sideband" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::ReceivableProtocolTests::test_write_sideband
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpycapabilitiestestcasetest_ack_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::CapabilitiesTestCase::test_ack_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpycapabilitiestestcasetest_caps" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::CapabilitiesTestCase::test_caps
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpycapabilitiestestcasetest_caps_want_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::CapabilitiesTestCase::test_caps_want_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpycapabilitiestestcasetest_plain_want_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::CapabilitiesTestCase::test_plain_want_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpybufferedpktlinewriterteststest_write" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::BufferedPktLineWriterTests::test_write
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpybufferedpktlinewriterteststest_write_across_boundary" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::BufferedPktLineWriterTests::test_write_across_boundary
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpybufferedpktlinewriterteststest_write_multiple" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::BufferedPktLineWriterTests::test_write_multiple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpybufferedpktlinewriterteststest_write_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::BufferedPktLineWriterTests::test_write_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpybufferedpktlinewriterteststest_write_to_boundary" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::BufferedPktLineWriterTests::test_write_to_boundary
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpypktlineparserteststest_multiple_packets" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::PktLineParserTests::test_multiple_packets
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpypktlineparserteststest_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::PktLineParserTests::test_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_protocolpypktlineparserteststest_small_fragments" class="md-nav__link">
    <span class="md-ellipsis">
      test_protocol.py::PktLineParserTests::test_small_fragments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reflogpyrefloglineteststest_format" class="md-nav__link">
    <span class="md-ellipsis">
      test_reflog.py::ReflogLineTests::test_format
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reflogpyrefloglineteststest_parse" class="md-nav__link">
    <span class="md-ellipsis">
      test_reflog.py::ReflogLineTests::test_parse
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reflogpyreflogdropteststest_drop_entry" class="md-nav__link">
    <span class="md-ellipsis">
      test_reflog.py::ReflogDropTests::test_drop_entry
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reflogpyreflogdropteststest_drop_entry_with_rewrite" class="md-nav__link">
    <span class="md-ellipsis">
      test_reflog.py::ReflogDropTests::test_drop_entry_with_rewrite
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reflogpyreflogdropteststest_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_reflog.py::ReflogDropTests::test_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspycheckrefformatteststest_valid" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::CheckRefFormatTests::test_valid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspypackedrefsfileteststest_read_with_peeled" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::PackedRefsFileTests::test_read_with_peeled
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspypackedrefsfileteststest_read_with_peeled_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::PackedRefsFileTests::test_read_with_peeled_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspypackedrefsfileteststest_read_without_peeled" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::PackedRefsFileTests::test_read_without_peeled
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspypackedrefsfileteststest_read_without_peeled_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::PackedRefsFileTests::test_read_without_peeled_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspypackedrefsfileteststest_split_ref_line_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::PackedRefsFileTests::test_split_ref_line_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspypackedrefsfileteststest_write_with_peeled" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::PackedRefsFileTests::test_write_with_peeled
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspypackedrefsfileteststest_write_without_peeled" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::PackedRefsFileTests::test_write_without_peeled
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydictrefscontainerteststest_add_if_new" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DictRefsContainerTests::test_add_if_new
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydictrefscontainerteststest_as_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DictRefsContainerTests::test_as_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydictrefscontainerteststest_check_refname" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DictRefsContainerTests::test_check_refname
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydictrefscontainerteststest_contains" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DictRefsContainerTests::test_contains
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydictrefscontainerteststest_delitem" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DictRefsContainerTests::test_delitem
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydictrefscontainerteststest_get_symrefs" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DictRefsContainerTests::test_get_symrefs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydictrefscontainerteststest_import_refs_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DictRefsContainerTests::test_import_refs_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydictrefscontainerteststest_import_refs_name_prune" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DictRefsContainerTests::test_import_refs_name_prune
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydictrefscontainerteststest_invalid_refname" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DictRefsContainerTests::test_invalid_refname
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydictrefscontainerteststest_iter" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DictRefsContainerTests::test_iter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydictrefscontainerteststest_keys" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DictRefsContainerTests::test_keys
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydictrefscontainerteststest_remove_if_equals" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DictRefsContainerTests::test_remove_if_equals
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydictrefscontainerteststest_set_if_equals" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DictRefsContainerTests::test_set_if_equals
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydictrefscontainerteststest_set_symbolic_ref" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DictRefsContainerTests::test_set_symbolic_ref
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydictrefscontainerteststest_set_symbolic_ref_overwrite" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DictRefsContainerTests::test_set_symbolic_ref_overwrite
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydictrefscontainerteststest_setitem" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DictRefsContainerTests::test_setitem
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_add_if_new" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_add_if_new
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_add_if_new_packed" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_add_if_new_packed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_add_if_new_symbolic" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_add_if_new_symbolic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_add_packed_refs" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_add_packed_refs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_as_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_as_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_check_refname" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_check_refname
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_contains" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_contains
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_cyrillic" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_cyrillic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_delete_refs_container" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_delete_refs_container
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_delitem" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_delitem
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_delitem_symbolic" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_delitem_symbolic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_follow" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_follow
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_get_packed_refs" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_get_packed_refs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_get_peeled_not_packed" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_get_peeled_not_packed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_get_symrefs" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_get_symrefs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_import_refs_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_import_refs_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_import_refs_name_prune" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_import_refs_name_prune
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_iter" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_iter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_keys" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_keys
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_non_ascii" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_non_ascii
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_read_loose_ref" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_read_loose_ref
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_read_ref" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_read_ref
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_remove_if_equals" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_remove_if_equals
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_remove_if_equals_packed" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_remove_if_equals_packed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_remove_if_equals_symref" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_remove_if_equals_symref
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_remove_packed_without_peeled" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_remove_packed_without_peeled
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_remove_parent" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_remove_parent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_set_if_equals" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_set_if_equals
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_set_overwrite_loop" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_set_overwrite_loop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_set_symbolic_ref" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_set_symbolic_ref
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_set_symbolic_ref_overwrite" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_set_symbolic_ref_overwrite
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_setitem" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_setitem
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_setitem_packed" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_setitem_packed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspydiskrefscontainerteststest_setitem_symbolic" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::DiskRefsContainerTests::test_setitem_symbolic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspyinforefscontainerteststest_as_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::InfoRefsContainerTests::test_as_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspyinforefscontainerteststest_contains" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::InfoRefsContainerTests::test_contains
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspyinforefscontainerteststest_get_peeled" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::InfoRefsContainerTests::test_get_peeled
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspyinforefscontainerteststest_invalid_refname" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::InfoRefsContainerTests::test_invalid_refname
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspyinforefscontainerteststest_keys" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::InfoRefsContainerTests::test_keys
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspyparsesymrefvalueteststest_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::ParseSymrefValueTests::test_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_refspyparsesymrefvalueteststest_valid" class="md-nav__link">
    <span class="md-ellipsis">
      test_refs.py::ParseSymrefValueTests::test_valid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyhandlertestcasetest_capability_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::HandlerTestCase::test_capability_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyhandlertestcasetest_has_capability" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::HandlerTestCase::test_has_capability
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyhandlertestcasetest_set_client_capabilities" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::HandlerTestCase::test_set_client_capabilities
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyuploadpackhandlertestcasetest_get_tagged" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::UploadPackHandlerTestCase::test_get_tagged
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyuploadpackhandlertestcasetest_no_progress" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::UploadPackHandlerTestCase::test_no_progress
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyuploadpackhandlertestcasetest_nothing_to_do_but_wants" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::UploadPackHandlerTestCase::test_nothing_to_do_but_wants
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyuploadpackhandlertestcasetest_nothing_to_do_no_wants" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::UploadPackHandlerTestCase::test_nothing_to_do_no_wants
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyuploadpackhandlertestcasetest_progress" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::UploadPackHandlerTestCase::test_progress
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyfindshallowteststest_linear" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::FindShallowTests::test_linear
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyfindshallowteststest_merge" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::FindShallowTests::test_merge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyfindshallowteststest_multiple_independent" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::FindShallowTests::test_multiple_independent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyfindshallowteststest_multiple_overlapping" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::FindShallowTests::test_multiple_overlapping
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyfindshallowteststest_tag" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::FindShallowTests::test_tag
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyreceivepackhandlertestcasetest_apply_pack_del_ref" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::ReceivePackHandlerTestCase::test_apply_pack_del_ref
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyprotocolgraphwalkeremptytestcasetest_empty_repository" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::ProtocolGraphWalkerEmptyTestCase::test_empty_repository
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyprotocolgraphwalkertestcasetest_all_wants_satisfied" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::ProtocolGraphWalkerTestCase::test_all_wants_satisfied
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyprotocolgraphwalkertestcasetest_all_wants_satisfied_have_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::ProtocolGraphWalkerTestCase::test_all_wants_satisfied_have_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyprotocolgraphwalkertestcasetest_all_wants_satisfied_have_root" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::ProtocolGraphWalkerTestCase::test_all_wants_satisfied_have_root
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyprotocolgraphwalkertestcasetest_all_wants_satisfied_no_haves" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::ProtocolGraphWalkerTestCase::test_all_wants_satisfied_no_haves
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyprotocolgraphwalkertestcasetest_determine_wants" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::ProtocolGraphWalkerTestCase::test_determine_wants
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyprotocolgraphwalkertestcasetest_determine_wants_advertisement" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::ProtocolGraphWalkerTestCase::test_determine_wants_advertisement
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyprotocolgraphwalkertestcasetest_handle_shallow_request_no_client_shallows" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::ProtocolGraphWalkerTestCase::test_handle_shallow_request_no_client_shallows
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyprotocolgraphwalkertestcasetest_handle_shallow_request_no_new_shallows" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::ProtocolGraphWalkerTestCase::test_handle_shallow_request_no_new_shallows
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyprotocolgraphwalkertestcasetest_handle_shallow_request_unshallows" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::ProtocolGraphWalkerTestCase::test_handle_shallow_request_unshallows
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyprotocolgraphwalkertestcasetest_split_proto_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::ProtocolGraphWalkerTestCase::test_split_proto_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpysingleackgraphwalkerimpltestcasetest_single_ack" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::SingleAckGraphWalkerImplTestCase::test_single_ack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpysingleackgraphwalkerimpltestcasetest_single_ack_flush" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::SingleAckGraphWalkerImplTestCase::test_single_ack_flush
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpysingleackgraphwalkerimpltestcasetest_single_ack_nak" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::SingleAckGraphWalkerImplTestCase::test_single_ack_nak
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpysingleackgraphwalkerimpltestcasetest_single_ack_nak_flush" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::SingleAckGraphWalkerImplTestCase::test_single_ack_nak_flush
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpymultiackgraphwalkerimpltestcasetest_multi_ack" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::MultiAckGraphWalkerImplTestCase::test_multi_ack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpymultiackgraphwalkerimpltestcasetest_multi_ack_flush" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::MultiAckGraphWalkerImplTestCase::test_multi_ack_flush
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpymultiackgraphwalkerimpltestcasetest_multi_ack_nak" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::MultiAckGraphWalkerImplTestCase::test_multi_ack_nak
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpymultiackgraphwalkerimpltestcasetest_multi_ack_partial" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::MultiAckGraphWalkerImplTestCase::test_multi_ack_partial
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_flush" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_flush
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_flush_end" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_flush_end
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_flush_end_nodone" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_flush_end_nodone
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_nak" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_nak
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_nak_flush" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_nak_flush
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_nak_nodone" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_nak_nodone
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_nodone" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_nodone
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_partial" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_partial
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_stateless" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_stateless
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_stateless_nodone" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_stateless_nodone
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyfilesystembackendteststest_absolute" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::FileSystemBackendTests::test_absolute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyfilesystembackendteststest_bad_repo_path" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::FileSystemBackendTests::test_bad_repo_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyfilesystembackendteststest_child" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::FileSystemBackendTests::test_child
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyfilesystembackendteststest_nonexistant" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::FileSystemBackendTests::test_nonexistant
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpydictbackendteststest_bad_repo_path" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::DictBackendTests::test_bad_repo_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpydictbackendteststest_nonexistant" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::DictBackendTests::test_nonexistant
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyservecommandteststest_receive_pack" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::ServeCommandTests::test_receive_pack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyupdateserverinfoteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::UpdateServerInfoTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_serverpyupdateserverinfoteststest_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_server.py::UpdateServerInfoTests::test_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_stashpystashteststest_obtain" class="md-nav__link">
    <span class="md-ellipsis">
      test_stash.py::StashTests::test_obtain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspybuildcommitgraphtesttest_attrs" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::BuildCommitGraphTest::test_attrs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspybuildcommitgraphtesttest_commit_time" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::BuildCommitGraphTest::test_commit_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspybuildcommitgraphtesttest_linear" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::BuildCommitGraphTest::test_linear
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspybuildcommitgraphtesttest_merge" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::BuildCommitGraphTest::test_merge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspybuildcommitgraphtesttest_missing_parent" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::BuildCommitGraphTest::test_missing_parent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspybuildcommitgraphtesttest_trees" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::BuildCommitGraphTest::test_trees
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_changes_multiple_parents" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_changes_multiple_parents
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_changes_one_parent" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_changes_one_parent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_changes_with_renames" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_changes_with_renames
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_empty_walk" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_empty_walk
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_follow_rename" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_follow_rename
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_follow_rename_remove_path" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_follow_rename_remove_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_linear" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_linear
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_max_entries" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_max_entries
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_merge" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_merge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_merge_of_new_branch_from_old_base" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_merge_of_new_branch_from_old_base
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_merge_of_old_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_merge_of_old_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_missing" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_missing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_out_of_order_children" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_out_of_order_children
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_out_of_order_with_exclude" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_out_of_order_with_exclude
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_path_matches" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_path_matches
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_paths" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_paths
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_paths_max_entries" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_paths_max_entries
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_paths_merge" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_paths_merge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_paths_subtree" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_paths_subtree
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_reverse" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_reverse
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_reverse_after_max_entries" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_reverse_after_max_entries
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_since" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_since
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_since_over_scan" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_since_over_scan
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_since_until" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_since_until
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_tag" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_tag
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_topo_reorder_linear" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_topo_reorder_linear
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_topo_reorder_multiple_children" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_topo_reorder_multiple_children
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_topo_reorder_multiple_parents" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_topo_reorder_multiple_parents
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_until" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_until
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkentrytesttest_all_changes" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkEntryTest::test_all_changes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkentrytesttest_all_with_merge" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkEntryTest::test_all_with_merge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkentrytesttest_filter_changes" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkEntryTest::test_filter_changes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkentrytesttest_filter_with_merge" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkEntryTest::test_filter_with_merge
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_openhands-commit0_openhands">back to OpenHands summary</a></p>
<h1 id="openhands-dulwich"><strong>OpenHands</strong>: dulwich</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">959</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">13</td>
</tr>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">40</td>
</tr>
<tr>
<td style="text-align: left;">error</td>
<td style="text-align: center;">10</td>
</tr>
<tr>
<td style="text-align: left;">xfailed</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">1023</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">1023</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_clientpydulwichtcpclienttesttest_archive">test_client.py::DulwichTCPClientTest::test_archive</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_archive</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_archive>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec217b6050 pid=14 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmprbteumow/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmprbteumow/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttesttest_fetch_empty_pack">test_client.py::DulwichTCPClientTest::test_fetch_empty_pack</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_fetch_empty_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_fetch_empty_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fb52260 pid=19 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpyazjt6pd/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpyazjt6pd/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttesttest_fetch_pack">test_client.py::DulwichTCPClientTest::test_fetch_pack</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_fetch_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_fetch_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd9f610 pid=24 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpatvq2lgm/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpatvq2lgm/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttesttest_fetch_pack_depth">test_client.py::DulwichTCPClientTest::test_fetch_pack_depth</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_fetch_pack_depth</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_fetch_pack_depth>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd6bc40 pid=29 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmphlmwd8l4/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmphlmwd8l4/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttesttest_fetch_pack_no_side_band_64k">test_client.py::DulwichTCPClientTest::test_fetch_pack_no_side_band_64k</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_fetch_pack_no_side_band_64k</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_fetch_pack_no_side_band_64k>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec217c1e10 pid=34 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpuiw9l11b/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpuiw9l11b/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttesttest_fetch_pack_zero_sha">test_client.py::DulwichTCPClientTest::test_fetch_pack_zero_sha</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_fetch_pack_zero_sha</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_fetch_pack_zero_sha>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec209ddb40 pid=39 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpv9nisvlo/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpv9nisvlo/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttesttest_get_refs">test_client.py::DulwichTCPClientTest::test_get_refs</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_get_refs</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_get_refs>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f626140 pid=44 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpecw8zyq_/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpecw8zyq_/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttesttest_incremental_fetch_pack">test_client.py::DulwichTCPClientTest::test_incremental_fetch_pack</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_incremental_fetch_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_incremental_fetch_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fcc98d0 pid=49 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp16phfla5/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp16phfla5/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttesttest_repeat">test_client.py::DulwichTCPClientTest::test_repeat</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_repeat</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_repeat>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fb49e10 pid=54 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpzwdulpao/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpzwdulpao/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttesttest_send_new_branch_empty_pack">test_client.py::DulwichTCPClientTest::test_send_new_branch_empty_pack</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_send_new_branch_empty_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_send_new_branch_empty_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec209d5870 pid=59 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpbkcfc9dk/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpbkcfc9dk/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttesttest_send_pack">test_client.py::DulwichTCPClientTest::test_send_pack</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_send_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_send_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f7bb100 pid=64 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp72etba95/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp72etba95/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttesttest_send_pack_from_shallow_clone">test_client.py::DulwichTCPClientTest::test_send_pack_from_shallow_clone</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_send_pack_from_shallow_clone</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_send_pack_from_shallow_clone>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd5dc00 pid=69 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp74pm3vny/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp74pm3vny/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttesttest_send_pack_multiple_errors">test_client.py::DulwichTCPClientTest::test_send_pack_multiple_errors</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_send_pack_multiple_errors</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_send_pack_multiple_errors>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1faf4940 pid=74 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpj1p47jx6/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpj1p47jx6/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttesttest_send_pack_nothing_to_send">test_client.py::DulwichTCPClientTest::test_send_pack_nothing_to_send</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_send_pack_nothing_to_send</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_send_pack_nothing_to_send>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd6de10 pid=79 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpbndcsq0y/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpbndcsq0y/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttesttest_send_pack_one_error">test_client.py::DulwichTCPClientTest::test_send_pack_one_error</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_send_pack_one_error</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_send_pack_one_error>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f624df0 pid=84 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpq7yvj69u/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpq7yvj69u/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttesttest_send_remove_branch">test_client.py::DulwichTCPClientTest::test_send_remove_branch</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_send_remove_branch</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_send_remove_branch>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9e17b0 pid=89 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp650beprh/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp650beprh/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttesttest_send_without_report_status">test_client.py::DulwichTCPClientTest::test_send_without_report_status</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTest::test_send_without_report_status</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTest testMethod=test_send_without_report_status>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec217c0550 pid=94 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpxid0djlw/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpxid0djlw/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_archive">test_client.py::DulwichTCPClientTestGitProtov0::test_archive</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_archive</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_archive>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd60a30 pid=99 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp230ldxxa/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp230ldxxa/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_fetch_empty_pack">test_client.py::DulwichTCPClientTestGitProtov0::test_fetch_empty_pack</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_fetch_empty_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_fetch_empty_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9f29e0 pid=104 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmptenyvts0/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmptenyvts0/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_fetch_pack">test_client.py::DulwichTCPClientTestGitProtov0::test_fetch_pack</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_fetch_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_fetch_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec209dd720 pid=109 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpuucf000c/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpuucf000c/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_fetch_pack_depth">test_client.py::DulwichTCPClientTestGitProtov0::test_fetch_pack_depth</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_fetch_pack_depth</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_fetch_pack_depth>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd69ff0 pid=114 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpdo2by_im/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpdo2by_im/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_fetch_pack_no_side_band_64k">test_client.py::DulwichTCPClientTestGitProtov0::test_fetch_pack_no_side_band_64k</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_fetch_pack_no_side_band_64k</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_fetch_pack_no_side_band_64k>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec21e58f70 pid=119 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpidq2x2rs/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpidq2x2rs/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_fetch_pack_zero_sha">test_client.py::DulwichTCPClientTestGitProtov0::test_fetch_pack_zero_sha</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_fetch_pack_zero_sha</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_fetch_pack_zero_sha>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9f4880 pid=124 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpd_bmbsos/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpd_bmbsos/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_get_refs">test_client.py::DulwichTCPClientTestGitProtov0::test_get_refs</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_get_refs</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_get_refs>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd9ef80 pid=129 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpt2nzwkyr/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpt2nzwkyr/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_incremental_fetch_pack">test_client.py::DulwichTCPClientTestGitProtov0::test_incremental_fetch_pack</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_incremental_fetch_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_incremental_fetch_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fb51ba0 pid=134 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpy_a7xbgt/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpy_a7xbgt/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_repeat">test_client.py::DulwichTCPClientTestGitProtov0::test_repeat</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_repeat</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_repeat>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fcaeb60 pid=139 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpv3oyi0q2/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpv3oyi0q2/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_send_new_branch_empty_pack">test_client.py::DulwichTCPClientTestGitProtov0::test_send_new_branch_empty_pack</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_send_new_branch_empty_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_send_new_branch_empty_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec209ca200 pid=144 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpballdrbc/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpballdrbc/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_send_pack">test_client.py::DulwichTCPClientTestGitProtov0::test_send_pack</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_send_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_send_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd9ef50 pid=149 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmplwmbbvhk/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmplwmbbvhk/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_send_pack_from_shallow_clone">test_client.py::DulwichTCPClientTestGitProtov0::test_send_pack_from_shallow_clone</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_send_pack_from_shallow_clone</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_send_pack_from_shallow_clone>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f6abd00 pid=154 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmppr64ivsl/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmppr64ivsl/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_send_pack_multiple_errors">test_client.py::DulwichTCPClientTestGitProtov0::test_send_pack_multiple_errors</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_send_pack_multiple_errors</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_send_pack_multiple_errors>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd5ef20 pid=159 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpngk8hyu_/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpngk8hyu_/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_send_pack_nothing_to_send">test_client.py::DulwichTCPClientTestGitProtov0::test_send_pack_nothing_to_send</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_send_pack_nothing_to_send</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_send_pack_nothing_to_send>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd9cdc0 pid=164 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpvf8zhmwk/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpvf8zhmwk/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_send_pack_one_error">test_client.py::DulwichTCPClientTestGitProtov0::test_send_pack_one_error</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_send_pack_one_error</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_send_pack_one_error>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f64f520 pid=169 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpuurucjuf/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpuurucjuf/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_send_remove_branch">test_client.py::DulwichTCPClientTestGitProtov0::test_send_remove_branch</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_send_remove_branch</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_send_remove_branch>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fb50f10 pid=174 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp77f80__k/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp77f80__k/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichtcpclienttestgitprotov0test_send_without_report_status">test_client.py::DulwichTCPClientTestGitProtov0::test_send_without_report_status</h3>
<details><summary> <pre>test_client.py::DulwichTCPClientTestGitProtov0::test_send_without_report_status</pre></summary><pre>
self = <tests.compat.test_client.DulwichTCPClientTestGitProtov0 testMethod=test_send_without_report_status>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f7bbb20 pid=179 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpd52mb8rn/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpd52mb8rn/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_archive">test_client.py::DulwichMockSSHClientTest::test_archive</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_archive</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_archive>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fb57820 pid=184 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmplyspz7f_/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmplyspz7f_/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_fetch_empty_pack">test_client.py::DulwichMockSSHClientTest::test_fetch_empty_pack</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_fetch_empty_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_fetch_empty_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fad5ff0 pid=189 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpbhd5h4p9/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpbhd5h4p9/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_fetch_pack">test_client.py::DulwichMockSSHClientTest::test_fetch_pack</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_fetch_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_fetch_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9e41f0 pid=194 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpyeys9222/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpyeys9222/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_fetch_pack_depth">test_client.py::DulwichMockSSHClientTest::test_fetch_pack_depth</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_fetch_pack_depth</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_fetch_pack_depth>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fb4e950 pid=199 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmppqg3nrjo/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmppqg3nrjo/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_fetch_pack_no_side_band_64k">test_client.py::DulwichMockSSHClientTest::test_fetch_pack_no_side_band_64k</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_fetch_pack_no_side_band_64k</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_fetch_pack_no_side_band_64k>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9f4b80 pid=204 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp3xhoyq6w/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp3xhoyq6w/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_fetch_pack_zero_sha">test_client.py::DulwichMockSSHClientTest::test_fetch_pack_zero_sha</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_fetch_pack_zero_sha</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_fetch_pack_zero_sha>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd9d330 pid=209 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp0nlabddw/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp0nlabddw/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_get_refs">test_client.py::DulwichMockSSHClientTest::test_get_refs</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_get_refs</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_get_refs>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd68640 pid=214 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpiebs6aey/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpiebs6aey/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_incremental_fetch_pack">test_client.py::DulwichMockSSHClientTest::test_incremental_fetch_pack</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_incremental_fetch_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_incremental_fetch_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f7b9180 pid=219 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp8r9vun9p/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp8r9vun9p/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_repeat">test_client.py::DulwichMockSSHClientTest::test_repeat</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_repeat</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_repeat>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fa70820 pid=224 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpomf7ufsm/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpomf7ufsm/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_send_new_branch_empty_pack">test_client.py::DulwichMockSSHClientTest::test_send_new_branch_empty_pack</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_send_new_branch_empty_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_send_new_branch_empty_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1faf6020 pid=229 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpudf6rxtv/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpudf6rxtv/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_send_pack">test_client.py::DulwichMockSSHClientTest::test_send_pack</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_send_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_send_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fccb130 pid=234 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpqt7thxqx/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpqt7thxqx/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_send_pack_from_shallow_clone">test_client.py::DulwichMockSSHClientTest::test_send_pack_from_shallow_clone</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_send_pack_from_shallow_clone</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_send_pack_from_shallow_clone>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd5ebc0 pid=239 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpvjtzrjrk/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpvjtzrjrk/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_send_pack_multiple_errors">test_client.py::DulwichMockSSHClientTest::test_send_pack_multiple_errors</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_send_pack_multiple_errors</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_send_pack_multiple_errors>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9cb6d0 pid=244 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpbjlshxbu/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpbjlshxbu/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_send_pack_nothing_to_send">test_client.py::DulwichMockSSHClientTest::test_send_pack_nothing_to_send</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_send_pack_nothing_to_send</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_send_pack_nothing_to_send>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec209de770 pid=249 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpuedpi5g3/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpuedpi5g3/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_send_pack_one_error">test_client.py::DulwichMockSSHClientTest::test_send_pack_one_error</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_send_pack_one_error</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_send_pack_one_error>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fb50f40 pid=254 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp6eqvbmqr/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp6eqvbmqr/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_send_remove_branch">test_client.py::DulwichMockSSHClientTest::test_send_remove_branch</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_send_remove_branch</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_send_remove_branch>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f64ded0 pid=259 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpgtcala6_/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpgtcala6_/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttesttest_send_without_report_status">test_client.py::DulwichMockSSHClientTest::test_send_without_report_status</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTest::test_send_without_report_status</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTest testMethod=test_send_without_report_status>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f7b8970 pid=264 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp630ska8w/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp630ska8w/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_archive">test_client.py::DulwichMockSSHClientTestGitProtov0::test_archive</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_archive</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_archive>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fa1de70 pid=269 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpj0c5hdih/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpj0c5hdih/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_fetch_empty_pack">test_client.py::DulwichMockSSHClientTestGitProtov0::test_fetch_empty_pack</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_fetch_empty_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_fetch_empty_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f637d00 pid=274 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp4253hd2r/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp4253hd2r/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_fetch_pack">test_client.py::DulwichMockSSHClientTestGitProtov0::test_fetch_pack</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_fetch_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_fetch_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fa71d20 pid=279 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpafqzrdte/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpafqzrdte/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_fetch_pack_depth">test_client.py::DulwichMockSSHClientTestGitProtov0::test_fetch_pack_depth</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_fetch_pack_depth</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_fetch_pack_depth>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fb4efb0 pid=284 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpz_cwu053/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpz_cwu053/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_fetch_pack_no_side_band_64k">test_client.py::DulwichMockSSHClientTestGitProtov0::test_fetch_pack_no_side_band_64k</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_fetch_pack_no_side_band_64k</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_fetch_pack_no_side_band_64k>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd6cf70 pid=289 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp7h531fpo/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp7h531fpo/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_fetch_pack_zero_sha">test_client.py::DulwichMockSSHClientTestGitProtov0::test_fetch_pack_zero_sha</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_fetch_pack_zero_sha</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_fetch_pack_zero_sha>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f699660 pid=294 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpg2eemhe5/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpg2eemhe5/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_get_refs">test_client.py::DulwichMockSSHClientTestGitProtov0::test_get_refs</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_get_refs</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_get_refs>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fcc9b40 pid=299 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpw1s_1rbe/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpw1s_1rbe/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_incremental_fetch_pack">test_client.py::DulwichMockSSHClientTestGitProtov0::test_incremental_fetch_pack</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_incremental_fetch_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_incremental_fetch_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec209dfbe0 pid=304 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmph19r9yvo/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmph19r9yvo/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_repeat">test_client.py::DulwichMockSSHClientTestGitProtov0::test_repeat</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_repeat</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_repeat>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f79c7f0 pid=309 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpkcd1h5v8/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpkcd1h5v8/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_send_new_branch_empty_pack">test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_new_branch_empty_pack</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_new_branch_empty_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_send_new_branch_empty_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9cf8e0 pid=314 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpt6gnffy5/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpt6gnffy5/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_send_pack">test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_pack</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_send_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f69ada0 pid=319 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpawv3pdc5/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpawv3pdc5/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_send_pack_from_shallow_clone">test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_pack_from_shallow_clone</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_pack_from_shallow_clone</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_send_pack_from_shallow_clone>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f64c550 pid=324 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpvbqpe4rr/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpvbqpe4rr/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_send_pack_multiple_errors">test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_pack_multiple_errors</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_pack_multiple_errors</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_send_pack_multiple_errors>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fa1d270 pid=329 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpwm3g9pw8/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpwm3g9pw8/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_send_pack_nothing_to_send">test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_pack_nothing_to_send</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_pack_nothing_to_send</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_send_pack_nothing_to_send>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fca5cc0 pid=334 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpge0rajlf/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpge0rajlf/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_send_pack_one_error">test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_pack_one_error</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_pack_one_error</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_send_pack_one_error>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fad73a0 pid=339 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp9hez_ani/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp9hez_ani/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_send_remove_branch">test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_remove_branch</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_remove_branch</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_send_remove_branch>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fcaef20 pid=344 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpywmrkl_b/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpywmrkl_b/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichmocksshclienttestgitprotov0test_send_without_report_status">test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_without_report_status</h3>
<details><summary> <pre>test_client.py::DulwichMockSSHClientTestGitProtov0::test_send_without_report_status</pre></summary><pre>
self = <tests.compat.test_client.DulwichMockSSHClientTestGitProtov0 testMethod=test_send_without_report_status>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9f1960 pid=349 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp63q0lo1o/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp63q0lo1o/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_archive">test_client.py::DulwichSubprocessClientTest::test_archive</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_archive</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_archive>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f79f820 pid=354 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp_588tmul/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp_588tmul/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_fetch_empty_pack">test_client.py::DulwichSubprocessClientTest::test_fetch_empty_pack</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_fetch_empty_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_fetch_empty_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f625e10 pid=359 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmprc_qxjeu/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmprc_qxjeu/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_fetch_pack">test_client.py::DulwichSubprocessClientTest::test_fetch_pack</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_fetch_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_fetch_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fb55ed0 pid=364 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp5h33p4b8/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp5h33p4b8/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_fetch_pack_depth">test_client.py::DulwichSubprocessClientTest::test_fetch_pack_depth</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_fetch_pack_depth</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_fetch_pack_depth>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9e3dc0 pid=369 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpo962hqfv/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpo962hqfv/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_fetch_pack_no_side_band_64k">test_client.py::DulwichSubprocessClientTest::test_fetch_pack_no_side_band_64k</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_fetch_pack_no_side_band_64k</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_fetch_pack_no_side_band_64k>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd9c940 pid=374 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp9300_7k4/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp9300_7k4/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_fetch_pack_zero_sha">test_client.py::DulwichSubprocessClientTest::test_fetch_pack_zero_sha</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_fetch_pack_zero_sha</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_fetch_pack_zero_sha>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fb578e0 pid=379 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpovdu2527/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpovdu2527/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_get_refs">test_client.py::DulwichSubprocessClientTest::test_get_refs</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_get_refs</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_get_refs>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec20f101c0 pid=384 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpzqbbl8ro/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpzqbbl8ro/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_incremental_fetch_pack">test_client.py::DulwichSubprocessClientTest::test_incremental_fetch_pack</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_incremental_fetch_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_incremental_fetch_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9cebc0 pid=389 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmptzsbn40d/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmptzsbn40d/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_repeat">test_client.py::DulwichSubprocessClientTest::test_repeat</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_repeat</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_repeat>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd6f160 pid=394 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmph85kzp8u/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmph85kzp8u/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_send_new_branch_empty_pack">test_client.py::DulwichSubprocessClientTest::test_send_new_branch_empty_pack</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_send_new_branch_empty_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_send_new_branch_empty_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f6ab1c0 pid=399 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmppohj4ecf/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmppohj4ecf/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_send_pack">test_client.py::DulwichSubprocessClientTest::test_send_pack</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_send_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_send_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fc95e40 pid=404 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpvxazspq1/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpvxazspq1/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_send_pack_from_shallow_clone">test_client.py::DulwichSubprocessClientTest::test_send_pack_from_shallow_clone</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_send_pack_from_shallow_clone</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_send_pack_from_shallow_clone>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f6990c0 pid=409 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpigsodsgl/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpigsodsgl/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_send_pack_multiple_errors">test_client.py::DulwichSubprocessClientTest::test_send_pack_multiple_errors</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_send_pack_multiple_errors</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_send_pack_multiple_errors>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fb4b5e0 pid=414 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpm6kdynbz/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpm6kdynbz/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_send_pack_nothing_to_send">test_client.py::DulwichSubprocessClientTest::test_send_pack_nothing_to_send</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_send_pack_nothing_to_send</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_send_pack_nothing_to_send>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fca63b0 pid=419 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpvw2u6hi5/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpvw2u6hi5/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_send_pack_one_error">test_client.py::DulwichSubprocessClientTest::test_send_pack_one_error</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_send_pack_one_error</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_send_pack_one_error>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fc44d60 pid=424 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpulxu77hs/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpulxu77hs/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_send_remove_branch">test_client.py::DulwichSubprocessClientTest::test_send_remove_branch</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_send_remove_branch</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_send_remove_branch>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd6fa00 pid=429 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpomhfvaov/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpomhfvaov/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttesttest_send_without_report_status">test_client.py::DulwichSubprocessClientTest::test_send_without_report_status</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTest::test_send_without_report_status</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTest testMethod=test_send_without_report_status>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9e1480 pid=434 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpbnh0ns3y/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpbnh0ns3y/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_archive">test_client.py::DulwichSubprocessClientTestGitProtov0::test_archive</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_archive</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_archive>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1faf6200 pid=439 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpja04huoc/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpja04huoc/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_fetch_empty_pack">test_client.py::DulwichSubprocessClientTestGitProtov0::test_fetch_empty_pack</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_fetch_empty_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_fetch_empty_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fc7b880 pid=444 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp9a5vcll4/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp9a5vcll4/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_fetch_pack">test_client.py::DulwichSubprocessClientTestGitProtov0::test_fetch_pack</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_fetch_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_fetch_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9cf8b0 pid=449 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpklkpfvle/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpklkpfvle/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_fetch_pack_depth">test_client.py::DulwichSubprocessClientTestGitProtov0::test_fetch_pack_depth</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_fetch_pack_depth</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_fetch_pack_depth>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f636980 pid=454 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpih2eatw3/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpih2eatw3/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_fetch_pack_no_side_band_64k">test_client.py::DulwichSubprocessClientTestGitProtov0::test_fetch_pack_no_side_band_64k</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_fetch_pack_no_side_band_64k</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_fetch_pack_no_side_band_64k>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fafdb10 pid=459 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp5imkbb5p/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp5imkbb5p/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_fetch_pack_zero_sha">test_client.py::DulwichSubprocessClientTestGitProtov0::test_fetch_pack_zero_sha</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_fetch_pack_zero_sha</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_fetch_pack_zero_sha>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1facfac0 pid=464 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpf9a_9taj/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpf9a_9taj/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_get_refs">test_client.py::DulwichSubprocessClientTestGitProtov0::test_get_refs</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_get_refs</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_get_refs>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9f1150 pid=469 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpt322ohpm/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpt322ohpm/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_incremental_fetch_pack">test_client.py::DulwichSubprocessClientTestGitProtov0::test_incremental_fetch_pack</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_incremental_fetch_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_incremental_fetch_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fca5060 pid=474 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp7tzlaal1/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp7tzlaal1/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_repeat">test_client.py::DulwichSubprocessClientTestGitProtov0::test_repeat</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_repeat</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_repeat>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd9cd00 pid=479 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpyy25132c/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpyy25132c/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_send_new_branch_empty_pack">test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_new_branch_empty_pack</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_new_branch_empty_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_send_new_branch_empty_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fa70700 pid=484 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpl7yjpbg4/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpl7yjpbg4/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_send_pack">test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_pack</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_send_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fcaf160 pid=489 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp48s86obd/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp48s86obd/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_send_pack_from_shallow_clone">test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_pack_from_shallow_clone</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_pack_from_shallow_clone</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_send_pack_from_shallow_clone>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec207fb520 pid=494 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp6t4h1fkq/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp6t4h1fkq/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_send_pack_multiple_errors">test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_pack_multiple_errors</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_pack_multiple_errors</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_send_pack_multiple_errors>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fb562c0 pid=499 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpl09p62sf/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpl09p62sf/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_send_pack_nothing_to_send">test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_pack_nothing_to_send</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_pack_nothing_to_send</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_send_pack_nothing_to_send>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f7bad10 pid=504 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpko4v_n61/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpko4v_n61/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_send_pack_one_error">test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_pack_one_error</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_pack_one_error</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_send_pack_one_error>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec20391c90 pid=509 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpqyqj5gxf/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpqyqj5gxf/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_send_remove_branch">test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_remove_branch</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_remove_branch</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_send_remove_branch>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fc7a470 pid=514 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp5e_1cgil/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp5e_1cgil/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichsubprocessclienttestgitprotov0test_send_without_report_status">test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_without_report_status</h3>
<details><summary> <pre>test_client.py::DulwichSubprocessClientTestGitProtov0::test_send_without_report_status</pre></summary><pre>
self = <tests.compat.test_client.DulwichSubprocessClientTestGitProtov0 testMethod=test_send_without_report_status>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f625fc0 pid=519 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp799sv8jm/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp799sv8jm/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_archive">test_client.py::DulwichHttpClientTest::test_archive</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_archive</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_archive>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fc473a0 pid=524 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpkgs21p2e/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpkgs21p2e/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_fetch_empty_pack">test_client.py::DulwichHttpClientTest::test_fetch_empty_pack</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_fetch_empty_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_fetch_empty_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fc793f0 pid=529 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp1s6a7v50/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp1s6a7v50/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_fetch_pack">test_client.py::DulwichHttpClientTest::test_fetch_pack</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_fetch_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_fetch_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec20f12c50 pid=534 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp0i40sl98/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp0i40sl98/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_fetch_pack_depth">test_client.py::DulwichHttpClientTest::test_fetch_pack_depth</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_fetch_pack_depth</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_fetch_pack_depth>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd5e0b0 pid=539 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp4f9gc7ja/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp4f9gc7ja/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_fetch_pack_no_side_band_64k">test_client.py::DulwichHttpClientTest::test_fetch_pack_no_side_band_64k</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_fetch_pack_no_side_band_64k</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_fetch_pack_no_side_band_64k>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec20391570 pid=544 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp1wqhsecs/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp1wqhsecs/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_fetch_pack_zero_sha">test_client.py::DulwichHttpClientTest::test_fetch_pack_zero_sha</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_fetch_pack_zero_sha</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_fetch_pack_zero_sha>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fcc94e0 pid=549 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp__ogse9a/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp__ogse9a/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_get_refs">test_client.py::DulwichHttpClientTest::test_get_refs</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_get_refs</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_get_refs>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9f7400 pid=554 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp1z9f77n2/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp1z9f77n2/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_incremental_fetch_pack">test_client.py::DulwichHttpClientTest::test_incremental_fetch_pack</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_incremental_fetch_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_incremental_fetch_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fc471f0 pid=559 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpek3grdey/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpek3grdey/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_repeat">test_client.py::DulwichHttpClientTest::test_repeat</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_repeat</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_repeat>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fa1e560 pid=564 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpqq76glzw/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpqq76glzw/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_send_new_branch_empty_pack">test_client.py::DulwichHttpClientTest::test_send_new_branch_empty_pack</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_send_new_branch_empty_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_send_new_branch_empty_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fc77580 pid=569 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpixcczm6t/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpixcczm6t/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_send_pack">test_client.py::DulwichHttpClientTest::test_send_pack</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_send_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_send_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f698130 pid=574 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpt4t8gz1r/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpt4t8gz1r/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_send_pack_from_shallow_clone">test_client.py::DulwichHttpClientTest::test_send_pack_from_shallow_clone</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_send_pack_from_shallow_clone</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_send_pack_from_shallow_clone>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fb518d0 pid=579 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpkjip1s0k/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpkjip1s0k/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_send_pack_multiple_errors">test_client.py::DulwichHttpClientTest::test_send_pack_multiple_errors</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_send_pack_multiple_errors</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_send_pack_multiple_errors>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9e1db0 pid=584 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpyt53jsgv/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpyt53jsgv/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_send_pack_nothing_to_send">test_client.py::DulwichHttpClientTest::test_send_pack_nothing_to_send</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_send_pack_nothing_to_send</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_send_pack_nothing_to_send>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec21e58eb0 pid=589 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpntrjao2h/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpntrjao2h/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_send_pack_one_error">test_client.py::DulwichHttpClientTest::test_send_pack_one_error</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_send_pack_one_error</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_send_pack_one_error>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f6983a0 pid=594 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp8_gp8owh/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp8_gp8owh/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_send_remove_branch">test_client.py::DulwichHttpClientTest::test_send_remove_branch</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_send_remove_branch</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_send_remove_branch>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fc97d30 pid=599 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp2fzx6451/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp2fzx6451/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttesttest_send_without_report_status">test_client.py::DulwichHttpClientTest::test_send_without_report_status</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTest::test_send_without_report_status</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTest testMethod=test_send_without_report_status>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec209cb550 pid=604 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmph14ol6iw/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmph14ol6iw/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_archive">test_client.py::DulwichHttpClientTestGitProtov0::test_archive</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_archive</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_archive>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd683a0 pid=609 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpkrwm9m3b/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpkrwm9m3b/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_fetch_empty_pack">test_client.py::DulwichHttpClientTestGitProtov0::test_fetch_empty_pack</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_fetch_empty_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_fetch_empty_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd6e770 pid=614 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpauiqikn8/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpauiqikn8/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_fetch_pack">test_client.py::DulwichHttpClientTestGitProtov0::test_fetch_pack</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_fetch_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_fetch_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd63d90 pid=619 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpp36dv3u6/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpp36dv3u6/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_fetch_pack_depth">test_client.py::DulwichHttpClientTestGitProtov0::test_fetch_pack_depth</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_fetch_pack_depth</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_fetch_pack_depth>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fad7100 pid=624 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmppxlx139h/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmppxlx139h/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_fetch_pack_no_side_band_64k">test_client.py::DulwichHttpClientTestGitProtov0::test_fetch_pack_no_side_band_64k</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_fetch_pack_no_side_band_64k</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_fetch_pack_no_side_band_64k>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec20390eb0 pid=629 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpnihd07o7/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpnihd07o7/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_fetch_pack_zero_sha">test_client.py::DulwichHttpClientTestGitProtov0::test_fetch_pack_zero_sha</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_fetch_pack_zero_sha</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_fetch_pack_zero_sha>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fc789a0 pid=634 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp14l5oe3w/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp14l5oe3w/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_get_refs">test_client.py::DulwichHttpClientTestGitProtov0::test_get_refs</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_get_refs</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_get_refs>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f624bb0 pid=639 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp9tuborlq/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp9tuborlq/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_incremental_fetch_pack">test_client.py::DulwichHttpClientTestGitProtov0::test_incremental_fetch_pack</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_incremental_fetch_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_incremental_fetch_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9e3520 pid=644 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpxtksxoot/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpxtksxoot/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_repeat">test_client.py::DulwichHttpClientTestGitProtov0::test_repeat</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_repeat</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_repeat>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec20cc9f60 pid=649 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp293as3da/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp293as3da/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_send_new_branch_empty_pack">test_client.py::DulwichHttpClientTestGitProtov0::test_send_new_branch_empty_pack</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_send_new_branch_empty_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_send_new_branch_empty_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fc45390 pid=654 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp_xjw2sfp/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp_xjw2sfp/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_send_pack">test_client.py::DulwichHttpClientTestGitProtov0::test_send_pack</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_send_pack</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_send_pack>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fd5f850 pid=659 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpngsvci0e/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpngsvci0e/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_send_pack_from_shallow_clone">test_client.py::DulwichHttpClientTestGitProtov0::test_send_pack_from_shallow_clone</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_send_pack_from_shallow_clone</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_send_pack_from_shallow_clone>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fc767d0 pid=664 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpkxrt3ojv/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpkxrt3ojv/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_send_pack_multiple_errors">test_client.py::DulwichHttpClientTestGitProtov0::test_send_pack_multiple_errors</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_send_pack_multiple_errors</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_send_pack_multiple_errors>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fb4aaa0 pid=669 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpj0mrqzuk/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpj0mrqzuk/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_send_pack_nothing_to_send">test_client.py::DulwichHttpClientTestGitProtov0::test_send_pack_nothing_to_send</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_send_pack_nothing_to_send</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_send_pack_nothing_to_send>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec209c8e50 pid=674 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp5nxv1gch/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp5nxv1gch/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_send_pack_one_error">test_client.py::DulwichHttpClientTestGitProtov0::test_send_pack_one_error</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_send_pack_one_error</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_send_pack_one_error>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1fc95ea0 pid=679 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpdvgp5u3i/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpdvgp5u3i/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_send_remove_branch">test_client.py::DulwichHttpClientTestGitProtov0::test_send_remove_branch</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_send_remove_branch</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_send_remove_branch>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1faf49d0 pid=684 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmp5zv6fsn1/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmp5zv6fsn1/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_clientpydulwichhttpclienttestgitprotov0test_send_without_report_status">test_client.py::DulwichHttpClientTestGitProtov0::test_send_without_report_status</h3>
<details><summary> <pre>test_client.py::DulwichHttpClientTestGitProtov0::test_send_without_report_status</pre></summary><pre>
self = <tests.compat.test_client.DulwichHttpClientTestGitProtov0 testMethod=test_send_without_report_status>

    def setUp(self):
        CompatTestCase.setUp(self)
>       DulwichClientTestBase.setUp(self)

tests/compat/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_client.py:64: in setUp
    run_git_or_fail(["init", "--quiet", "--bare"], cwd=self.dest)
tests/compat/utils.py:163: in run_git_or_fail
    returncode, stdout, stderr = run_git(
tests/compat/utils.py:154: in run_git
    p = subprocess.Popen(args, env=env, **popen_kwargs)
.venv/lib/python3.10/site-packages/gevent/subprocess.py:808: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen at 0x7eec1f9f20b0 pid=689 returncode=1>
args = ['git', 'init', '--quiet', '--bare'], executable = 'git'
preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/tmp/tmpqlhrnzoi/dest'
env = {'LANG': 'C', 'LC_ALL': 'C', 'PATH': '/testbed/.venv/bin:/root/.cargo/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'}
universal_newlines = None, startupinfo = None, creationflags = 0, shell = False
p2cread = 13, p2cwrite = 14, c2pread = 15, c2pwrite = 16, errread = 17
errwrite = 18, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False, process_group = None

            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds, cwd, env, universal_newlines,
                               startupinfo, creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               restore_signals,
                               gid, gids, uid, umask,
                               start_new_session, process_group):
                """Execute program (POSIX version)"""

                if isinstance(args, (str, bytes)):
                    args = [args]
                elif isinstance(args, PathLike):
                    if shell:
                        raise TypeError('path-like args is not allowed when '
                                        'shell is true')
                    args = [fsencode(args)] # os.PathLike -> [str]
                else:
                    args = list(args)

                if shell:
                    # On Android the default shell is at '/system/bin/sh'.
                    unix_shell = (
                        '/system/bin/sh' if hasattr(sys, 'getandroidapilevel') else '/bin/sh'
                    )
                    args = [unix_shell, "-c"] + args
                    if executable:
                        args[0] = executable

                if executable is None:
                    executable = args[0]

                self._loop.install_sigchld()

                # For transferring possible exec failure from child to parent
                # The first char specifies the exception type: 0 means
                # OSError, 1 means some other error.
                errpipe_read, errpipe_write = self.pipe_cloexec()
                # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
                low_fds_to_close = []
                while errpipe_write < 3:
                    low_fds_to_close.append(errpipe_write)
                    errpipe_write = os.dup(errpipe_write)
                for low_fd in low_fds_to_close:
                    os.close(low_fd)
                try:
                    try:
                        gc_was_enabled = gc.isenabled()
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.  http://bugs.python.org/issue1336
                        gc.disable()
                        try:
                            self.pid = fork_and_watch(self._on_child, self._loop, True, fork)
                        except:
                            if gc_was_enabled:
                                gc.enable()
                            raise
                        if self.pid == 0:
                            # Child

                            # In various places on the child side of things, we catch OSError
                            # and add attributes to it that detail where in the process we failed;
                            # like all exceptions until we have exec'd, this exception is pickled
                            # and sent to the parent to raise in the calling process.
                            # The parent uses this to decide how to treat that exception,
                            # adjusting certain information about it as needed.
                            #
                            # Python 3.11.8 --- yes, a minor patch release --- stopped
                            # letting the 'filename' parameter get set in the resulting
                            # exception for many cases. We're not quite interpreting this
                            # the same way the stdlib is, I'm sure, but this makes the stdlib
                            # tests pass.

                            # XXX: Technically we're doing a lot of stuff here that
                            # may not be safe to do before a exec(), depending on the OS.
                            # CPython 3 goes to great lengths to precompute a lot
                            # of this info before the fork and pass it all to C functions that
                            # try hard not to call things like malloc(). (Of course,
                            # CPython 2 pretty much did what we're doing.)
                            try:
                                # Close parent's pipe ends
                                if p2cwrite != -1:
                                    os.close(p2cwrite)
                                if c2pread != -1:
                                    os.close(c2pread)
                                if errread != -1:
                                    os.close(errread)
                                os.close(errpipe_read)

                                # When duping fds, if there arises a situation
                                # where one of the fds is either 0, 1 or 2, it
                                # is possible that it is overwritten (#12607).
                                if c2pwrite == 0:
                                    c2pwrite = os.dup(c2pwrite)
                                    _set_inheritable(c2pwrite, False)
                                while errwrite in (0, 1):
                                    errwrite = os.dup(errwrite)
                                    _set_inheritable(errwrite, False)

                                # Dup fds for child
                                def _dup2(existing, desired):
                                    # dup2() removes the CLOEXEC flag but
                                    # we must do it ourselves if dup2()
                                    # would be a no-op (issue #10806).
                                    if existing == desired:
                                        self._set_cloexec_flag(existing, False)
                                    elif existing != -1:
                                        os.dup2(existing, desired)
                                    try:
                                        self._remove_nonblock_flag(desired)
                                    except OSError:
                                        # Ignore EBADF, it may not actually be
                                        # open yet.
                                        # Tested beginning in 3.7.0b3 test_subprocess.py
                                        pass
                                _dup2(p2cread, 0)
                                _dup2(c2pwrite, 1)
                                _dup2(errwrite, 2)

                                # Close pipe fds.  Make sure we don't close the
                                # same fd more than once, or standard fds.
                                if not True:
                                    closed = set([None])
                                    for fd in (p2cread, c2pwrite, errwrite):
                                        if fd not in closed and fd > 2:
                                            os.close(fd)
                                            closed.add(fd)

                                # Python 3 (with a working set_inheritable):
                                # We no longer manually close p2cread,
                                # c2pwrite, and errwrite here as
                                # _close_open_fds takes care when it is
                                # not already non-inheritable.

                                if cwd is not None:
                                    try:
                                        os.chdir(cwd)
                                    except OSError as e:
                                        e._failed_chdir = True
                                        raise

                                # Python 3.9
                                if umask >= 0:
                                    os.umask(umask)
                                # XXX: CPython does _Py_RestoreSignals here.
                                # Then setsid() based on ???
                                try:
                                    if gids:
                                        os.setgroups(gids)
                                    if gid:
                                        os.setregid(gid, gid)
                                    if uid:
                                        os.setreuid(uid, uid)
                                    if process_group is not None:
                                        os.setpgid(0, process_group)
                                except OSError as e:
                                    e._failed_chuser = True
                                    raise

                                if preexec_fn:
                                    preexec_fn()

                                # Close all other fds, if asked for. This must be done
                                # after preexec_fn runs.
                                if close_fds:
                                    fds_to_keep = set(pass_fds)
                                    fds_to_keep.add(errpipe_write)
                                    self._close_fds(fds_to_keep, errpipe_write)

                                if restore_signals:
                                    # restore the documented signals back to sig_dfl;
                                    # not all will be defined on every platform
                                    for sig in 'SIGPIPE', 'SIGXFZ', 'SIGXFSZ':
                                        sig = getattr(signal, sig, None)
                                        if sig is not None:
                                            signal.signal(sig, signal.SIG_DFL)

                                if start_new_session:
                                    os.setsid()

                                try:
                                    if env is None:
                                        os.execvp(executable, args)
                                    else:
                                        # Python 3.6 started testing for
                                        # bytes values in the env; it also
                                        # started encoding strs using
                                        # fsencode and using a lower-level
                                        # API that takes a list of keys
                                        # and values. We don't have access
                                        # to that API, so we go the reverse direction.
                                        env = {os.fsdecode(k) if isinstance(k, bytes) else k:
                                               os.fsdecode(v) if isinstance(v, bytes) else v
                                               for k, v in env.items()}
                                        os.execvpe(executable, args, env)
                                except OSError as e:
                                    e._failed_exec = True
                                    raise
                            except:
                                exc_type, exc_value, tb = sys.exc_info()
                                # Save the traceback and attach it to the exception object
                                exc_lines = traceback.format_exception(exc_type,
                                                                       exc_value,
                                                                       tb)
                                exc_value.child_traceback = ''.join(exc_lines)
                                os.write(errpipe_write, pickle.dumps(exc_value))

                            finally:
                                # Make sure that the process exits no matter what.
                                # The return code does not matter much as it won't be
                                # reported to the application
                                os._exit(1)

                        # Parent
                        self._child_created = True
                        if gc_was_enabled:
                            gc.enable()
                    finally:
                        # be sure the FD is closed no matter what
                        os.close(errpipe_write)

                    # self._devnull is not always defined.
                    devnull_fd = getattr(self, '_devnull', None)
                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                        os.close(p2cread)
                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                        os.close(c2pwrite)
                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                        os.close(errwrite)
                    if devnull_fd is not None:
                        os.close(devnull_fd)
                    # Prevent a double close of these fds from __init__ on error.
                    self._closed_child_pipe_fds = True

                    # Wait for exec to fail or succeed; possibly raising exception
                    errpipe_read = FileObject(errpipe_read, 'rb')
                    data = errpipe_read.read()
                finally:
                    try:
                        if hasattr(errpipe_read, 'close'):
                            errpipe_read.close()
                        else:
                            os.close(errpipe_read)
                    except OSError:
                        # Especially on PyPy, we sometimes see the above
                        # `os.close(errpipe_read)` raise an OSError.
                        # It's not entirely clear why, but it happens in
                        # InterprocessSignalTests.test_main sometimes, which must mean
                        # we have some sort of race condition.
                        pass
                    finally:
                        errpipe_read = -1

                if data != b"":
                    self.wait()
                    child_exception = pickle.loads(data)
                    for fd in (p2cwrite, c2pread, errread):
                        if fd is not None and fd != -1:
                            os.close(fd)
                    if isinstance(child_exception, OSError):
                        child_exception.filename = executable
                        if hasattr(child_exception, '_failed_chdir'):
                            child_exception.filename = cwd
                        if getattr(child_exception, '_failed_chuser', False):
                            child_exception.filename = None
>                   raise child_exception
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpqlhrnzoi/dest'

.venv/lib/python3.10/site-packages/gevent/subprocess.py:1838: FileNotFoundError
</pre>
</details>
<h3 id="test_packpytestpacktest_copy">test_pack.py::TestPack::test_copy</h3>
<details><summary> <pre>test_pack.py::TestPack::test_copy</pre></summary><pre>
self = <tests.compat.test_pack.TestPack testMethod=test_copy>

    def test_copy(self):
        with self.get_pack(pack1_sha) as origpack:
>           self.assertSucceeds(origpack.index.check)
E           AttributeError: 'NoneType' object has no attribute 'check'

tests/compat/test_pack.py:62: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.compat.test_pack.TestPack testMethod=test_copy>

    def test_copy(self):
>       with self.get_pack(pack1_sha) as origpack:

tests/compat/test_pack.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'AttributeError'>
exc_val = AttributeError("'NoneType' object has no attribute 'check'")
exc_tb = <traceback object at 0x7eec1f4e7700>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_delta_medium_object">test_pack.py::TestPack::test_delta_medium_object</h3>
<details><summary> <pre>test_pack.py::TestPack::test_delta_medium_object</pre></summary><pre>
self = <tests.compat.test_pack.TestPack testMethod=test_delta_medium_object>

    def test_delta_medium_object(self):
        # This tests an object set that will have a copy operation
        # 2**20 in size.
        with self.get_pack(pack1_sha) as orig_pack:
>           orig_blob = orig_pack[a_sha]

tests/compat/test_pack.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
sha1 = b'6f670c0fb53f9463760b7295fbb814e965fb20c8'

    def __getitem__(self, sha1: bytes) -> ShaFile:
        """Retrieve the specified SHA1."""
>       type, uncomp = self.get_raw(sha1)
E       AttributeError: 'Pack' object has no attribute 'get_raw'. Did you mean: 'get_ref'?

dulwich/pack.py:1188: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.compat.test_pack.TestPack testMethod=test_delta_medium_object>

    def test_delta_medium_object(self):
        # This tests an object set that will have a copy operation
        # 2**20 in size.
>       with self.get_pack(pack1_sha) as orig_pack:

tests/compat/test_pack.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'AttributeError'>
exc_val = AttributeError("'Pack' object has no attribute 'get_raw'")
exc_tb = <traceback object at 0x7eec1f233200>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_deltas_work">test_pack.py::TestPack::test_deltas_work</h3>
<details><summary> <pre>test_pack.py::TestPack::test_deltas_work</pre></summary><pre>
self = <tests.compat.test_pack.TestPack testMethod=test_deltas_work>

    def test_deltas_work(self):
        with self.get_pack(pack1_sha) as orig_pack:
>           orig_blob = orig_pack[a_sha]

tests/compat/test_pack.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
sha1 = b'6f670c0fb53f9463760b7295fbb814e965fb20c8'

    def __getitem__(self, sha1: bytes) -> ShaFile:
        """Retrieve the specified SHA1."""
>       type, uncomp = self.get_raw(sha1)
E       AttributeError: 'Pack' object has no attribute 'get_raw'. Did you mean: 'get_ref'?

dulwich/pack.py:1188: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.compat.test_pack.TestPack testMethod=test_deltas_work>

    def test_deltas_work(self):
>       with self.get_pack(pack1_sha) as orig_pack:

tests/compat/test_pack.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'AttributeError'>
exc_val = AttributeError("'Pack' object has no attribute 'get_raw'")
exc_tb = <traceback object at 0x7eec1f24d2c0>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_repositorypyobjectstoretestcasetest_all_objects">test_repository.py::ObjectStoreTestCase::test_all_objects</h3>
<details><summary> <pre>test_repository.py::ObjectStoreTestCase::test_all_objects</pre></summary><pre>
self = <tests.compat.test_repository.ObjectStoreTestCase testMethod=test_all_objects>

    def setUp(self):
        super().setUp()
>       self._repo = self.import_repo("server_new.export")

tests/compat/test_repository.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpatuv43p1/server_new.export'>
root = '/tmp/tmpatuv43p1/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyobjectstoretestcasetest_bare">test_repository.py::ObjectStoreTestCase::test_bare</h3>
<details><summary> <pre>test_repository.py::ObjectStoreTestCase::test_bare</pre></summary><pre>
self = <tests.compat.test_repository.ObjectStoreTestCase testMethod=test_bare>

    def setUp(self):
        super().setUp()
>       self._repo = self.import_repo("server_new.export")

tests/compat/test_repository.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpiq_w2aa6/server_new.export'>
root = '/tmp/tmpiq_w2aa6/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyobjectstoretestcasetest_head">test_repository.py::ObjectStoreTestCase::test_head</h3>
<details><summary> <pre>test_repository.py::ObjectStoreTestCase::test_head</pre></summary><pre>
self = <tests.compat.test_repository.ObjectStoreTestCase testMethod=test_head>

    def setUp(self):
        super().setUp()
>       self._repo = self.import_repo("server_new.export")

tests/compat/test_repository.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpfvvba5k2/server_new.export'>
root = '/tmp/tmpfvvba5k2/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyobjectstoretestcasetest_loose_objects">test_repository.py::ObjectStoreTestCase::test_loose_objects</h3>
<details><summary> <pre>test_repository.py::ObjectStoreTestCase::test_loose_objects</pre></summary><pre>
self = <tests.compat.test_repository.ObjectStoreTestCase testMethod=test_loose_objects>

    def setUp(self):
        super().setUp()
>       self._repo = self.import_repo("server_new.export")

tests/compat/test_repository.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpatolzfg8/server_new.export'>
root = '/tmp/tmpatolzfg8/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyobjectstoretestcasetest_packed_objects">test_repository.py::ObjectStoreTestCase::test_packed_objects</h3>
<details><summary> <pre>test_repository.py::ObjectStoreTestCase::test_packed_objects</pre></summary><pre>
self = <tests.compat.test_repository.ObjectStoreTestCase testMethod=test_packed_objects>

    def setUp(self):
        super().setUp()
>       self._repo = self.import_repo("server_new.export")

tests/compat/test_repository.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmphhsupavg/server_new.export'>
root = '/tmp/tmphhsupavg/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyobjectstoretestcasetest_refs">test_repository.py::ObjectStoreTestCase::test_refs</h3>
<details><summary> <pre>test_repository.py::ObjectStoreTestCase::test_refs</pre></summary><pre>
self = <tests.compat.test_repository.ObjectStoreTestCase testMethod=test_refs>

    def setUp(self):
        super().setUp()
>       self._repo = self.import_repo("server_new.export")

tests/compat/test_repository.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpulw63vru/server_new.export'>
root = '/tmp/tmpulw63vru/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyworkingtreetestcasetest_all_objects">test_repository.py::WorkingTreeTestCase::test_all_objects</h3>
<details><summary> <pre>test_repository.py::WorkingTreeTestCase::test_all_objects</pre></summary><pre>
self = <tests.compat.test_repository.WorkingTreeTestCase testMethod=test_all_objects>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpr4ltxoes/server_new.export'>
root = '/tmp/tmpr4ltxoes/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyworkingtreetestcasetest_bare">test_repository.py::WorkingTreeTestCase::test_bare</h3>
<details><summary> <pre>test_repository.py::WorkingTreeTestCase::test_bare</pre></summary><pre>
self = <tests.compat.test_repository.WorkingTreeTestCase testMethod=test_bare>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpt0hg8erg/server_new.export'>
root = '/tmp/tmpt0hg8erg/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyworkingtreetestcasetest_git_worktree_config">test_repository.py::WorkingTreeTestCase::test_git_worktree_config</h3>
<details><summary> <pre>test_repository.py::WorkingTreeTestCase::test_git_worktree_config</pre></summary><pre>
self = <tests.compat.test_repository.WorkingTreeTestCase testMethod=test_git_worktree_config>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmprj7q1d67/server_new.export'>
root = '/tmp/tmprj7q1d67/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyworkingtreetestcasetest_git_worktree_list">test_repository.py::WorkingTreeTestCase::test_git_worktree_list</h3>
<details><summary> <pre>test_repository.py::WorkingTreeTestCase::test_git_worktree_list</pre></summary><pre>
self = <tests.compat.test_repository.WorkingTreeTestCase testMethod=test_git_worktree_list>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpwigie8kq/server_new.export'>
root = '/tmp/tmpwigie8kq/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyworkingtreetestcasetest_head">test_repository.py::WorkingTreeTestCase::test_head</h3>
<details><summary> <pre>test_repository.py::WorkingTreeTestCase::test_head</pre></summary><pre>
self = <tests.compat.test_repository.WorkingTreeTestCase testMethod=test_head>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpvy3jbueo/server_new.export'>
root = '/tmp/tmpvy3jbueo/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyworkingtreetestcasetest_head_equality">test_repository.py::WorkingTreeTestCase::test_head_equality</h3>
<details><summary> <pre>test_repository.py::WorkingTreeTestCase::test_head_equality</pre></summary><pre>
self = <tests.compat.test_repository.WorkingTreeTestCase testMethod=test_head_equality>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpul1gc70w/server_new.export'>
root = '/tmp/tmpul1gc70w/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyworkingtreetestcasetest_loose_objects">test_repository.py::WorkingTreeTestCase::test_loose_objects</h3>
<details><summary> <pre>test_repository.py::WorkingTreeTestCase::test_loose_objects</pre></summary><pre>
self = <tests.compat.test_repository.WorkingTreeTestCase testMethod=test_loose_objects>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmp_npaidsc/server_new.export'>
root = '/tmp/tmp_npaidsc/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyworkingtreetestcasetest_packed_objects">test_repository.py::WorkingTreeTestCase::test_packed_objects</h3>
<details><summary> <pre>test_repository.py::WorkingTreeTestCase::test_packed_objects</pre></summary><pre>
self = <tests.compat.test_repository.WorkingTreeTestCase testMethod=test_packed_objects>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmp08pe_5f_/server_new.export'>
root = '/tmp/tmp08pe_5f_/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyworkingtreetestcasetest_refs">test_repository.py::WorkingTreeTestCase::test_refs</h3>
<details><summary> <pre>test_repository.py::WorkingTreeTestCase::test_refs</pre></summary><pre>
self = <tests.compat.test_repository.WorkingTreeTestCase testMethod=test_refs>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpkg40_kbg/server_new.export'>
root = '/tmp/tmpkg40_kbg/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyinitnewworkingdirectorytestcasetest_all_objects">test_repository.py::InitNewWorkingDirectoryTestCase::test_all_objects</h3>
<details><summary> <pre>test_repository.py::InitNewWorkingDirectoryTestCase::test_all_objects</pre></summary><pre>
self = <tests.compat.test_repository.InitNewWorkingDirectoryTestCase testMethod=test_all_objects>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:140: in setUp
    super().setUp()
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpzy1bk5qn/server_new.export'>
root = '/tmp/tmpzy1bk5qn/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyinitnewworkingdirectorytestcasetest_bare">test_repository.py::InitNewWorkingDirectoryTestCase::test_bare</h3>
<details><summary> <pre>test_repository.py::InitNewWorkingDirectoryTestCase::test_bare</pre></summary><pre>
self = <tests.compat.test_repository.InitNewWorkingDirectoryTestCase testMethod=test_bare>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:140: in setUp
    super().setUp()
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpyavn32ob/server_new.export'>
root = '/tmp/tmpyavn32ob/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyinitnewworkingdirectorytestcasetest_git_worktree_config">test_repository.py::InitNewWorkingDirectoryTestCase::test_git_worktree_config</h3>
<details><summary> <pre>test_repository.py::InitNewWorkingDirectoryTestCase::test_git_worktree_config</pre></summary><pre>
self = <tests.compat.test_repository.InitNewWorkingDirectoryTestCase testMethod=test_git_worktree_config>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:140: in setUp
    super().setUp()
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpqdj6ukfd/server_new.export'>
root = '/tmp/tmpqdj6ukfd/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyinitnewworkingdirectorytestcasetest_git_worktree_list">test_repository.py::InitNewWorkingDirectoryTestCase::test_git_worktree_list</h3>
<details><summary> <pre>test_repository.py::InitNewWorkingDirectoryTestCase::test_git_worktree_list</pre></summary><pre>
self = <tests.compat.test_repository.InitNewWorkingDirectoryTestCase testMethod=test_git_worktree_list>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:140: in setUp
    super().setUp()
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpi3q20qsv/server_new.export'>
root = '/tmp/tmpi3q20qsv/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyinitnewworkingdirectorytestcasetest_head">test_repository.py::InitNewWorkingDirectoryTestCase::test_head</h3>
<details><summary> <pre>test_repository.py::InitNewWorkingDirectoryTestCase::test_head</pre></summary><pre>
self = <tests.compat.test_repository.InitNewWorkingDirectoryTestCase testMethod=test_head>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:140: in setUp
    super().setUp()
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpq5k18_i5/server_new.export'>
root = '/tmp/tmpq5k18_i5/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyinitnewworkingdirectorytestcasetest_head_equality">test_repository.py::InitNewWorkingDirectoryTestCase::test_head_equality</h3>
<details><summary> <pre>test_repository.py::InitNewWorkingDirectoryTestCase::test_head_equality</pre></summary><pre>
self = <tests.compat.test_repository.InitNewWorkingDirectoryTestCase testMethod=test_head_equality>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:140: in setUp
    super().setUp()
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpxvrb8flo/server_new.export'>
root = '/tmp/tmpxvrb8flo/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyinitnewworkingdirectorytestcasetest_loose_objects">test_repository.py::InitNewWorkingDirectoryTestCase::test_loose_objects</h3>
<details><summary> <pre>test_repository.py::InitNewWorkingDirectoryTestCase::test_loose_objects</pre></summary><pre>
self = <tests.compat.test_repository.InitNewWorkingDirectoryTestCase testMethod=test_loose_objects>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:140: in setUp
    super().setUp()
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpy5rhh7a7/server_new.export'>
root = '/tmp/tmpy5rhh7a7/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyinitnewworkingdirectorytestcasetest_packed_objects">test_repository.py::InitNewWorkingDirectoryTestCase::test_packed_objects</h3>
<details><summary> <pre>test_repository.py::InitNewWorkingDirectoryTestCase::test_packed_objects</pre></summary><pre>
self = <tests.compat.test_repository.InitNewWorkingDirectoryTestCase testMethod=test_packed_objects>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:140: in setUp
    super().setUp()
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpjzge7px2/server_new.export'>
root = '/tmp/tmpjzge7px2/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_repositorypyinitnewworkingdirectorytestcasetest_refs">test_repository.py::InitNewWorkingDirectoryTestCase::test_refs</h3>
<details><summary> <pre>test_repository.py::InitNewWorkingDirectoryTestCase::test_refs</pre></summary><pre>
self = <tests.compat.test_repository.InitNewWorkingDirectoryTestCase testMethod=test_refs>

    def setUp(self):
>       super().setUp()

tests/compat/test_repository.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_repository.py:140: in setUp
    super().setUp()
tests/compat/test_repository.py:39: in setUp
    self._repo = self.import_repo("server_new.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmp8y_mipr6/server_new.export'>
root = '/tmp/tmp8y_mipr6/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitservertestcasetest_clone_from_dulwich_empty">test_server.py::GitServerTestCase::test_clone_from_dulwich_empty</h3>
<details><summary> <pre>test_server.py::GitServerTestCase::test_clone_from_dulwich_empty</pre></summary><pre>
self = <tests.compat.test_server.GitServerTestCase testMethod=test_clone_from_dulwich_empty>

    def test_clone_from_dulwich_empty(self):
        old_repo_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, old_repo_dir)
        self._old_repo = Repo.init_bare(old_repo_dir)
>       port = self._start_server(self._old_repo)

tests/compat/server_utils.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_server.py:58: in _start_server
    dul_server = TCPGitServer(backend, b"localhost", 0, handlers=self._handlers())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.server.TCPGitServer object at 0x7eec1f9cdc30>
backend = <dulwich.server.DictBackend object at 0x7eec1f9cc400>
listen_addr = b'localhost', port = 0
handlers = {b'git-receive-pack': <class 'tests.compat.server_utils.NoSideBand64kReceivePackHandler'>}

    def __init__(self, backend, listen_addr, port=TCP_GIT_PORT, handlers=None) -> None:
        self.handlers = dict(DEFAULT_HANDLERS)
        if handlers is not None:
            self.handlers.update(handlers)
        self.backend = backend
        logger.info('Listening for TCP connections on %s:%d', listen_addr, port)
>       socketserver.TCPServer.__init__(self, (listen_addr, port), self._make_handler)
E       AttributeError: 'TCPGitServer' object has no attribute '_make_handler'

dulwich/server.py:331: AttributeError
</pre>
</details>
<h3 id="test_serverpygitservertestcasetest_fetch_from_dulwich">test_server.py::GitServerTestCase::test_fetch_from_dulwich</h3>
<details><summary> <pre>test_server.py::GitServerTestCase::test_fetch_from_dulwich</pre></summary><pre>
self = <tests.compat.test_server.GitServerTestCase testMethod=test_fetch_from_dulwich>

    def test_fetch_from_dulwich(self):
>       self.import_repos()

tests/compat/server_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/server_utils.py:78: in import_repos
    self._old_repo = self.import_repo("server_old.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpaw5iwmba/server_old.export'>
root = '/tmp/tmpaw5iwmba/server_old.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitservertestcasetest_fetch_from_dulwich_issue_88_alternative">test_server.py::GitServerTestCase::test_fetch_from_dulwich_issue_88_alternative</h3>
<details><summary> <pre>test_server.py::GitServerTestCase::test_fetch_from_dulwich_issue_88_alternative</pre></summary><pre>
self = <tests.compat.test_server.GitServerTestCase testMethod=test_fetch_from_dulwich_issue_88_alternative>

    def test_fetch_from_dulwich_issue_88_alternative(self):
        # likewise, but the case where the two repos have no common parent
>       self._source_repo = self.import_repo("issue88_expect_ack_nak_other.export")

tests/compat/server_utils.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpbvrc1kjx/issue88_expect_ack_nak_other.export'>
root = '/tmp/tmpbvrc1kjx/issue88_expect_ack_nak_other.export'
object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitservertestcasetest_fetch_from_dulwich_issue_88_standard">test_server.py::GitServerTestCase::test_fetch_from_dulwich_issue_88_standard</h3>
<details><summary> <pre>test_server.py::GitServerTestCase::test_fetch_from_dulwich_issue_88_standard</pre></summary><pre>
self = <tests.compat.test_server.GitServerTestCase testMethod=test_fetch_from_dulwich_issue_88_standard>

    def test_fetch_from_dulwich_issue_88_standard(self):
        # Basically an integration test to see that the ACK/NAK
        # generation works on repos with common head.
>       self._source_repo = self.import_repo("issue88_expect_ack_nak_server.export")

tests/compat/server_utils.py:300: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpa0dtblvc/issue88_expect_ack_nak_server.export'>
root = '/tmp/tmpa0dtblvc/issue88_expect_ack_nak_server.export'
object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitservertestcasetest_fetch_from_dulwich_no_op">test_server.py::GitServerTestCase::test_fetch_from_dulwich_no_op</h3>
<details><summary> <pre>test_server.py::GitServerTestCase::test_fetch_from_dulwich_no_op</pre></summary><pre>
self = <tests.compat.test_server.GitServerTestCase testMethod=test_fetch_from_dulwich_no_op>

    def test_fetch_from_dulwich_no_op(self):
>       self._old_repo = self.import_repo("server_old.export")

tests/compat/server_utils.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpu2qpqaip/server_old.export'>
root = '/tmp/tmpu2qpqaip/server_old.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitservertestcasetest_fetch_full_depth_into_shallow_clone_from_dulwich">test_server.py::GitServerTestCase::test_fetch_full_depth_into_shallow_clone_from_dulwich</h3>
<details><summary> <pre>test_server.py::GitServerTestCase::test_fetch_full_depth_into_shallow_clone_from_dulwich</pre></summary><pre>
self = <tests.compat.test_server.GitServerTestCase testMethod=test_fetch_full_depth_into_shallow_clone_from_dulwich>

    def test_fetch_full_depth_into_shallow_clone_from_dulwich(self):
        require_git_version(self.min_single_branch_version)
>       self._source_repo = self.import_repo("server_new.export")

tests/compat/server_utils.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmptbti5reo/server_new.export'>
root = '/tmp/tmptbti5reo/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitservertestcasetest_fetch_same_depth_into_shallow_clone_from_dulwich">test_server.py::GitServerTestCase::test_fetch_same_depth_into_shallow_clone_from_dulwich</h3>
<details><summary> <pre>test_server.py::GitServerTestCase::test_fetch_same_depth_into_shallow_clone_from_dulwich</pre></summary><pre>
self = <tests.compat.test_server.GitServerTestCase testMethod=test_fetch_same_depth_into_shallow_clone_from_dulwich>

    def test_fetch_same_depth_into_shallow_clone_from_dulwich(self):
        require_git_version(self.min_single_branch_version)
>       self._source_repo = self.import_repo("server_new.export")

tests/compat/server_utils.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpsxsfvzhu/server_new.export'>
root = '/tmp/tmpsxsfvzhu/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitservertestcasetest_lsremote_from_dulwich">test_server.py::GitServerTestCase::test_lsremote_from_dulwich</h3>
<details><summary> <pre>test_server.py::GitServerTestCase::test_lsremote_from_dulwich</pre></summary><pre>
self = <tests.compat.test_server.GitServerTestCase testMethod=test_lsremote_from_dulwich>

    def test_lsremote_from_dulwich(self):
>       self._repo = self.import_repo("server_old.export")

tests/compat/server_utils.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpmtm2pugf/server_old.export'>
root = '/tmp/tmpmtm2pugf/server_old.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitservertestcasetest_new_shallow_clone_from_dulwich">test_server.py::GitServerTestCase::test_new_shallow_clone_from_dulwich</h3>
<details><summary> <pre>test_server.py::GitServerTestCase::test_new_shallow_clone_from_dulwich</pre></summary><pre>
self = <tests.compat.test_server.GitServerTestCase testMethod=test_new_shallow_clone_from_dulwich>

    def test_new_shallow_clone_from_dulwich(self):
        require_git_version(self.min_single_branch_version)
>       self._source_repo = self.import_repo("server_new.export")

tests/compat/server_utils.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmp62jgsfar/server_new.export'>
root = '/tmp/tmp62jgsfar/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitservertestcasetest_push_to_dulwich">test_server.py::GitServerTestCase::test_push_to_dulwich</h3>
<details><summary> <pre>test_server.py::GitServerTestCase::test_push_to_dulwich</pre></summary><pre>
self = <tests.compat.test_server.GitServerTestCase testMethod=test_push_to_dulwich>

    def test_push_to_dulwich(self):
>       self.import_repos()

tests/compat/server_utils.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/server_utils.py:78: in import_repos
    self._old_repo = self.import_repo("server_old.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpplozwia1/server_old.export'>
root = '/tmp/tmpplozwia1/server_old.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitservertestcasetest_push_to_dulwich_issue_88_standard">test_server.py::GitServerTestCase::test_push_to_dulwich_issue_88_standard</h3>
<details><summary> <pre>test_server.py::GitServerTestCase::test_push_to_dulwich_issue_88_standard</pre></summary><pre>
self = <tests.compat.test_server.GitServerTestCase testMethod=test_push_to_dulwich_issue_88_standard>

    def test_push_to_dulwich_issue_88_standard(self):
        # Same thing, but we reverse the role of the server/client
        # and do a push instead.
>       self._source_repo = self.import_repo("issue88_expect_ack_nak_client.export")

tests/compat/server_utils.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmp_e57l5wm/issue88_expect_ack_nak_client.export'>
root = '/tmp/tmp_e57l5wm/issue88_expect_ack_nak_client.export'
object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitservertestcasetest_push_to_dulwich_no_op">test_server.py::GitServerTestCase::test_push_to_dulwich_no_op</h3>
<details><summary> <pre>test_server.py::GitServerTestCase::test_push_to_dulwich_no_op</pre></summary><pre>
self = <tests.compat.test_server.GitServerTestCase testMethod=test_push_to_dulwich_no_op>

    def test_push_to_dulwich_no_op(self):
>       self._old_repo = self.import_repo("server_old.export")

tests/compat/server_utils.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpw0f17hee/server_old.export'>
root = '/tmp/tmpw0f17hee/server_old.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitservertestcasetest_push_to_dulwich_remove_branch">test_server.py::GitServerTestCase::test_push_to_dulwich_remove_branch</h3>
<details><summary> <pre>test_server.py::GitServerTestCase::test_push_to_dulwich_remove_branch</pre></summary><pre>
self = <tests.compat.test_server.GitServerTestCase testMethod=test_push_to_dulwich_remove_branch>

    def test_push_to_dulwich_remove_branch(self):
>       self._old_repo = self.import_repo("server_old.export")

tests/compat/server_utils.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpvz0wogzn/server_old.export'>
root = '/tmp/tmpvz0wogzn/server_old.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitservertestcasetest_shallow_clone_from_git_is_identical">test_server.py::GitServerTestCase::test_shallow_clone_from_git_is_identical</h3>
<details><summary> <pre>test_server.py::GitServerTestCase::test_shallow_clone_from_git_is_identical</pre></summary><pre>
self = <tests.compat.test_server.GitServerTestCase testMethod=test_shallow_clone_from_git_is_identical>

    def test_shallow_clone_from_git_is_identical(self):
        require_git_version(self.min_single_branch_version)
>       self._source_repo = self.import_repo("server_new.export")

tests/compat/server_utils.py:196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpeezbi80_/server_new.export'>
root = '/tmp/tmpeezbi80_/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitserversideband64ktestcasetest_clone_from_dulwich_empty">test_server.py::GitServerSideBand64kTestCase::test_clone_from_dulwich_empty</h3>
<details><summary> <pre>test_server.py::GitServerSideBand64kTestCase::test_clone_from_dulwich_empty</pre></summary><pre>
self = <tests.compat.test_server.GitServerSideBand64kTestCase testMethod=test_clone_from_dulwich_empty>

    def test_clone_from_dulwich_empty(self):
        old_repo_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, old_repo_dir)
        self._old_repo = Repo.init_bare(old_repo_dir)
>       port = self._start_server(self._old_repo)

tests/compat/server_utils.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/test_server.py:58: in _start_server
    dul_server = TCPGitServer(backend, b"localhost", 0, handlers=self._handlers())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.server.TCPGitServer object at 0x7eec1f82dff0>
backend = <dulwich.server.DictBackend object at 0x7eec1f82d8a0>
listen_addr = b'localhost', port = 0, handlers = None

    def __init__(self, backend, listen_addr, port=TCP_GIT_PORT, handlers=None) -> None:
        self.handlers = dict(DEFAULT_HANDLERS)
        if handlers is not None:
            self.handlers.update(handlers)
        self.backend = backend
        logger.info('Listening for TCP connections on %s:%d', listen_addr, port)
>       socketserver.TCPServer.__init__(self, (listen_addr, port), self._make_handler)
E       AttributeError: 'TCPGitServer' object has no attribute '_make_handler'

dulwich/server.py:331: AttributeError
</pre>
</details>
<h3 id="test_serverpygitserversideband64ktestcasetest_fetch_from_dulwich">test_server.py::GitServerSideBand64kTestCase::test_fetch_from_dulwich</h3>
<details><summary> <pre>test_server.py::GitServerSideBand64kTestCase::test_fetch_from_dulwich</pre></summary><pre>
self = <tests.compat.test_server.GitServerSideBand64kTestCase testMethod=test_fetch_from_dulwich>

    def test_fetch_from_dulwich(self):
>       self.import_repos()

tests/compat/server_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/server_utils.py:78: in import_repos
    self._old_repo = self.import_repo("server_old.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmp_yv5hig5/server_old.export'>
root = '/tmp/tmp_yv5hig5/server_old.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitserversideband64ktestcasetest_fetch_from_dulwich_issue_88_alternative">test_server.py::GitServerSideBand64kTestCase::test_fetch_from_dulwich_issue_88_alternative</h3>
<details><summary> <pre>test_server.py::GitServerSideBand64kTestCase::test_fetch_from_dulwich_issue_88_alternative</pre></summary><pre>
self = <tests.compat.test_server.GitServerSideBand64kTestCase testMethod=test_fetch_from_dulwich_issue_88_alternative>

    def test_fetch_from_dulwich_issue_88_alternative(self):
        # likewise, but the case where the two repos have no common parent
>       self._source_repo = self.import_repo("issue88_expect_ack_nak_other.export")

tests/compat/server_utils.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpd1gr3bor/issue88_expect_ack_nak_other.export'>
root = '/tmp/tmpd1gr3bor/issue88_expect_ack_nak_other.export'
object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitserversideband64ktestcasetest_fetch_from_dulwich_issue_88_standard">test_server.py::GitServerSideBand64kTestCase::test_fetch_from_dulwich_issue_88_standard</h3>
<details><summary> <pre>test_server.py::GitServerSideBand64kTestCase::test_fetch_from_dulwich_issue_88_standard</pre></summary><pre>
self = <tests.compat.test_server.GitServerSideBand64kTestCase testMethod=test_fetch_from_dulwich_issue_88_standard>

    def test_fetch_from_dulwich_issue_88_standard(self):
        # Basically an integration test to see that the ACK/NAK
        # generation works on repos with common head.
>       self._source_repo = self.import_repo("issue88_expect_ack_nak_server.export")

tests/compat/server_utils.py:300: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpt7ylsal3/issue88_expect_ack_nak_server.export'>
root = '/tmp/tmpt7ylsal3/issue88_expect_ack_nak_server.export'
object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitserversideband64ktestcasetest_fetch_from_dulwich_no_op">test_server.py::GitServerSideBand64kTestCase::test_fetch_from_dulwich_no_op</h3>
<details><summary> <pre>test_server.py::GitServerSideBand64kTestCase::test_fetch_from_dulwich_no_op</pre></summary><pre>
self = <tests.compat.test_server.GitServerSideBand64kTestCase testMethod=test_fetch_from_dulwich_no_op>

    def test_fetch_from_dulwich_no_op(self):
>       self._old_repo = self.import_repo("server_old.export")

tests/compat/server_utils.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpa94tnxgv/server_old.export'>
root = '/tmp/tmpa94tnxgv/server_old.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitserversideband64ktestcasetest_fetch_full_depth_into_shallow_clone_from_dulwich">test_server.py::GitServerSideBand64kTestCase::test_fetch_full_depth_into_shallow_clone_from_dulwich</h3>
<details><summary> <pre>test_server.py::GitServerSideBand64kTestCase::test_fetch_full_depth_into_shallow_clone_from_dulwich</pre></summary><pre>
self = <tests.compat.test_server.GitServerSideBand64kTestCase testMethod=test_fetch_full_depth_into_shallow_clone_from_dulwich>

    def test_fetch_full_depth_into_shallow_clone_from_dulwich(self):
        require_git_version(self.min_single_branch_version)
>       self._source_repo = self.import_repo("server_new.export")

tests/compat/server_utils.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpzc00s95s/server_new.export'>
root = '/tmp/tmpzc00s95s/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitserversideband64ktestcasetest_fetch_same_depth_into_shallow_clone_from_dulwich">test_server.py::GitServerSideBand64kTestCase::test_fetch_same_depth_into_shallow_clone_from_dulwich</h3>
<details><summary> <pre>test_server.py::GitServerSideBand64kTestCase::test_fetch_same_depth_into_shallow_clone_from_dulwich</pre></summary><pre>
self = <tests.compat.test_server.GitServerSideBand64kTestCase testMethod=test_fetch_same_depth_into_shallow_clone_from_dulwich>

    def test_fetch_same_depth_into_shallow_clone_from_dulwich(self):
        require_git_version(self.min_single_branch_version)
>       self._source_repo = self.import_repo("server_new.export")

tests/compat/server_utils.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmp0juc9m1k/server_new.export'>
root = '/tmp/tmp0juc9m1k/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitserversideband64ktestcasetest_lsremote_from_dulwich">test_server.py::GitServerSideBand64kTestCase::test_lsremote_from_dulwich</h3>
<details><summary> <pre>test_server.py::GitServerSideBand64kTestCase::test_lsremote_from_dulwich</pre></summary><pre>
self = <tests.compat.test_server.GitServerSideBand64kTestCase testMethod=test_lsremote_from_dulwich>

    def test_lsremote_from_dulwich(self):
>       self._repo = self.import_repo("server_old.export")

tests/compat/server_utils.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmp9lzb94d7/server_old.export'>
root = '/tmp/tmp9lzb94d7/server_old.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitserversideband64ktestcasetest_new_shallow_clone_from_dulwich">test_server.py::GitServerSideBand64kTestCase::test_new_shallow_clone_from_dulwich</h3>
<details><summary> <pre>test_server.py::GitServerSideBand64kTestCase::test_new_shallow_clone_from_dulwich</pre></summary><pre>
self = <tests.compat.test_server.GitServerSideBand64kTestCase testMethod=test_new_shallow_clone_from_dulwich>

    def test_new_shallow_clone_from_dulwich(self):
        require_git_version(self.min_single_branch_version)
>       self._source_repo = self.import_repo("server_new.export")

tests/compat/server_utils.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpbnj0uprd/server_new.export'>
root = '/tmp/tmpbnj0uprd/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitserversideband64ktestcasetest_push_to_dulwich">test_server.py::GitServerSideBand64kTestCase::test_push_to_dulwich</h3>
<details><summary> <pre>test_server.py::GitServerSideBand64kTestCase::test_push_to_dulwich</pre></summary><pre>
self = <tests.compat.test_server.GitServerSideBand64kTestCase testMethod=test_push_to_dulwich>

    def test_push_to_dulwich(self):
>       self.import_repos()

tests/compat/server_utils.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/server_utils.py:78: in import_repos
    self._old_repo = self.import_repo("server_old.export")
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmptddisd2l/server_old.export'>
root = '/tmp/tmptddisd2l/server_old.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitserversideband64ktestcasetest_push_to_dulwich_issue_88_standard">test_server.py::GitServerSideBand64kTestCase::test_push_to_dulwich_issue_88_standard</h3>
<details><summary> <pre>test_server.py::GitServerSideBand64kTestCase::test_push_to_dulwich_issue_88_standard</pre></summary><pre>
self = <tests.compat.test_server.GitServerSideBand64kTestCase testMethod=test_push_to_dulwich_issue_88_standard>

    def test_push_to_dulwich_issue_88_standard(self):
        # Same thing, but we reverse the role of the server/client
        # and do a push instead.
>       self._source_repo = self.import_repo("issue88_expect_ack_nak_client.export")

tests/compat/server_utils.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpch4y0jjp/issue88_expect_ack_nak_client.export'>
root = '/tmp/tmpch4y0jjp/issue88_expect_ack_nak_client.export'
object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitserversideband64ktestcasetest_push_to_dulwich_no_op">test_server.py::GitServerSideBand64kTestCase::test_push_to_dulwich_no_op</h3>
<details><summary> <pre>test_server.py::GitServerSideBand64kTestCase::test_push_to_dulwich_no_op</pre></summary><pre>
self = <tests.compat.test_server.GitServerSideBand64kTestCase testMethod=test_push_to_dulwich_no_op>

    def test_push_to_dulwich_no_op(self):
>       self._old_repo = self.import_repo("server_old.export")

tests/compat/server_utils.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpdl40tx4t/server_old.export'>
root = '/tmp/tmpdl40tx4t/server_old.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitserversideband64ktestcasetest_push_to_dulwich_remove_branch">test_server.py::GitServerSideBand64kTestCase::test_push_to_dulwich_remove_branch</h3>
<details><summary> <pre>test_server.py::GitServerSideBand64kTestCase::test_push_to_dulwich_remove_branch</pre></summary><pre>
self = <tests.compat.test_server.GitServerSideBand64kTestCase testMethod=test_push_to_dulwich_remove_branch>

    def test_push_to_dulwich_remove_branch(self):
>       self._old_repo = self.import_repo("server_old.export")

tests/compat/server_utils.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmp65hjoode/server_old.export'>
root = '/tmp/tmp65hjoode/server_old.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_serverpygitserversideband64ktestcasetest_shallow_clone_from_git_is_identical">test_server.py::GitServerSideBand64kTestCase::test_shallow_clone_from_git_is_identical</h3>
<details><summary> <pre>test_server.py::GitServerSideBand64kTestCase::test_shallow_clone_from_git_is_identical</pre></summary><pre>
self = <tests.compat.test_server.GitServerSideBand64kTestCase testMethod=test_shallow_clone_from_git_is_identical>

    def test_shallow_clone_from_git_is_identical(self):
        require_git_version(self.min_single_branch_version)
>       self._source_repo = self.import_repo("server_new.export")

tests/compat/server_utils.py:196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/compat/utils.py:269: in import_repo
    repo = Repo(path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Repo at '/tmp/tmpuyx7_zyt/server_new.export'>
root = '/tmp/tmpuyx7_zyt/server_new.export', object_store = None, bare = True

    def __init__(self, root: str, object_store: Optional[PackBasedObjectStore]=None, bare: Optional[bool]=None) -> None:
        hidden_path = os.path.join(root, CONTROLDIR)
        if bare is None:
            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
                bare = False
            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(os.path.join(root, REFSDIR)):
                bare = True
            else:
                raise NotGitRepository('No git repository was found at {path}'.format(**dict(path=root)))
        self.bare = bare
        if bare is False:
            if os.path.isfile(hidden_path):
                with open(hidden_path) as f:
                    path = read_gitfile(f)
                self._controldir = os.path.join(root, path)
            else:
                self._controldir = hidden_path
        else:
            self._controldir = root
        commondir = self.get_named_file(COMMONDIR)
        if commondir is not None:
            with commondir:
                self._commondir = os.path.join(self.controldir(), os.fsdecode(commondir.read().rstrip(b'\r\n')))
        else:
            self._commondir = self._controldir
        self.path = root
        config = self.get_config()
        try:
>           repository_format_version = config.get('core', 'repositoryformatversion')
E           AttributeError: 'NoneType' object has no attribute 'get'

dulwich/repo.py:589: AttributeError
</pre>
</details>
<h3 id="test_release_robotpygetrecenttagstesttest_get_recent_tags">test_release_robot.py::GetRecentTagsTest::test_get_recent_tags</h3>
<details><summary> <pre>test_release_robot.py::GetRecentTagsTest::test_get_recent_tags</pre></summary><pre>
cls = <class 'tests.contrib.test_release_robot.GetRecentTagsTest'>

    @classmethod
    def setUpClass(cls):
        cls.projdir = tempfile.mkdtemp()  # temporary project directory
        cls.repo = Repo.init(cls.projdir)  # test repo
>       obj_store = cls.repo.object_store  # test repo object store
E       AttributeError: 'NoneType' object has no attribute 'object_store'

tests/contrib/test_release_robot.py:83: AttributeError
</pre>
</details>
<h3 id="test_swiftpytestswiftrepotest_init_bare">test_swift.py::TestSwiftRepo::test_init_bare</h3>
<details><summary> <pre>test_swift.py::TestSwiftRepo::test_init_bare</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftRepo testMethod=test_init_bare>

    def test_init_bare(self):
        fsc = FakeSwiftConnector("fakeroot", conf=self.conf)
        with patch(
            "dulwich.contrib.swift.SwiftConnector",
            new_callable=create_swift_connector,
            store=fsc.store,
        ):
            swift.SwiftRepo.init_bare(fsc, conf=self.conf)
>       self.assertIn("fakeroot/objects/pack", fsc.store)
E       AssertionError: 'fakeroot/objects/pack' not found in {}

tests/contrib/test_swift.py:285: AssertionError
</pre>
</details>
<h3 id="test_swiftpytestswiftrepotest_put_named_file">test_swift.py::TestSwiftRepo::test_put_named_file</h3>
<details><summary> <pre>test_swift.py::TestSwiftRepo::test_put_named_file</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftRepo testMethod=test_put_named_file>

    def test_put_named_file(self):
        store = {"fakerepo/objects/pack": ""}
        with patch(
            "dulwich.contrib.swift.SwiftConnector",
            new_callable=create_swift_connector,
            store=store,
        ):
            repo = swift.SwiftRepo("fakerepo", conf=self.conf)
            desc = b"Fake repo"
            repo._put_named_file("description", desc)
>       self.assertEqual(repo.scon.store["fakerepo/description"], desc)
E       KeyError: 'fakerepo/description'

tests/contrib/test_swift.py:275: KeyError
</pre>
</details>
<h3 id="test_swiftpytestswiftinforefscontainertest_init">test_swift.py::TestSwiftInfoRefsContainer::test_init</h3>
<details><summary> <pre>test_swift.py::TestSwiftInfoRefsContainer::test_init</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftInfoRefsContainer testMethod=test_init>

    def test_init(self):
        """info/refs does not exists."""
        irc = swift.SwiftInfoRefsContainer(self.fsc, self.object_store)
        self.assertEqual(len(irc._refs), 0)
        self.fsc.store = self.store
>       irc = swift.SwiftInfoRefsContainer(self.fsc, self.object_store)

tests/contrib/test_swift.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/contrib/swift.py:304: in __init__
    super().__init__(f)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftInfoRefsContainer object at 0x7eec1face0b0>
f = <_io.BytesIO object at 0x7eec1f169e40>

    def __init__(self, f) -> None:
        self._refs = {}
        self._peeled = {}
        for line in f.readlines():
            sha, name = line.rstrip(b'\n').split(b'\t')
            if name.endswith(PEELED_TAG_SUFFIX):
                name = name[:-3]
                if not check_ref_format(name):
                    raise ValueError(f'invalid ref name {name!r}')
                self._peeled[name] = sha
            else:
                if not check_ref_format(name):
>                   raise ValueError(f'invalid ref name {name!r}')
E                   ValueError: invalid ref name b'refs/heads/master'

dulwich/refs.py:302: ValueError
</pre>
</details>
<h3 id="test_swiftpytestswiftinforefscontainertest_remove_if_equals">test_swift.py::TestSwiftInfoRefsContainer::test_remove_if_equals</h3>
<details><summary> <pre>test_swift.py::TestSwiftInfoRefsContainer::test_remove_if_equals</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftInfoRefsContainer testMethod=test_remove_if_equals>

    def test_remove_if_equals(self):
        self.fsc.store = self.store
>       irc = swift.SwiftInfoRefsContainer(self.fsc, self.object_store)

tests/contrib/test_swift.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/contrib/swift.py:304: in __init__
    super().__init__(f)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftInfoRefsContainer object at 0x7eec1fa1e9e0>
f = <_io.BytesIO object at 0x7eec20822110>

    def __init__(self, f) -> None:
        self._refs = {}
        self._peeled = {}
        for line in f.readlines():
            sha, name = line.rstrip(b'\n').split(b'\t')
            if name.endswith(PEELED_TAG_SUFFIX):
                name = name[:-3]
                if not check_ref_format(name):
                    raise ValueError(f'invalid ref name {name!r}')
                self._peeled[name] = sha
            else:
                if not check_ref_format(name):
>                   raise ValueError(f'invalid ref name {name!r}')
E                   ValueError: invalid ref name b'refs/heads/master'

dulwich/refs.py:302: ValueError
</pre>
</details>
<h3 id="test_swiftpytestswiftinforefscontainertest_set_if_equals">test_swift.py::TestSwiftInfoRefsContainer::test_set_if_equals</h3>
<details><summary> <pre>test_swift.py::TestSwiftInfoRefsContainer::test_set_if_equals</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftInfoRefsContainer testMethod=test_set_if_equals>

    def test_set_if_equals(self):
        self.fsc.store = self.store
>       irc = swift.SwiftInfoRefsContainer(self.fsc, self.object_store)

tests/contrib/test_swift.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/contrib/swift.py:304: in __init__
    super().__init__(f)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftInfoRefsContainer object at 0x7eec1fc75330>
f = <_io.BytesIO object at 0x7eec1f157650>

    def __init__(self, f) -> None:
        self._refs = {}
        self._peeled = {}
        for line in f.readlines():
            sha, name = line.rstrip(b'\n').split(b'\t')
            if name.endswith(PEELED_TAG_SUFFIX):
                name = name[:-3]
                if not check_ref_format(name):
                    raise ValueError(f'invalid ref name {name!r}')
                self._peeled[name] = sha
            else:
                if not check_ref_format(name):
>                   raise ValueError(f'invalid ref name {name!r}')
E                   ValueError: invalid ref name b'refs/heads/master'

dulwich/refs.py:302: ValueError
</pre>
</details>
<h3 id="test_swiftpytestswiftconnectortest_create_root">test_swift.py::TestSwiftConnector::test_create_root</h3>
<details><summary> <pre>test_swift.py::TestSwiftConnector::test_create_root</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftConnector testMethod=test_create_root>

    def setUp(self):
        super().setUp()
        self.conf = swift.load_conf(file=StringIO(config_file % def_config_file))
        with patch("geventhttpclient.HTTPClient.request", fake_auth_request_v1):
>           self.conn = swift.SwiftConnector("fakerepo", conf=self.conf)

tests/contrib/test_swift.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftConnector object at 0x7eec1fc46290>
root = 'fakerepo', conf = None

    def __init__(self, root, conf) -> None:
        """Initialize a SwiftConnector.

        Args:
          root: The swift container that will act as Git bare repository
          conf: A ConfigParser Object
        """
        self.conf = conf
>       self.auth_ver = self.conf.get('swift', 'auth_ver')
E       AttributeError: 'NoneType' object has no attribute 'get'

dulwich/contrib/swift.py:60: AttributeError
</pre>
</details>
<h3 id="test_swiftpytestswiftconnectortest_create_root_fails">test_swift.py::TestSwiftConnector::test_create_root_fails</h3>
<details><summary> <pre>test_swift.py::TestSwiftConnector::test_create_root_fails</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftConnector testMethod=test_create_root_fails>

    def setUp(self):
        super().setUp()
        self.conf = swift.load_conf(file=StringIO(config_file % def_config_file))
        with patch("geventhttpclient.HTTPClient.request", fake_auth_request_v1):
>           self.conn = swift.SwiftConnector("fakerepo", conf=self.conf)

tests/contrib/test_swift.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftConnector object at 0x7eec1fa70250>
root = 'fakerepo', conf = None

    def __init__(self, root, conf) -> None:
        """Initialize a SwiftConnector.

        Args:
          root: The swift container that will act as Git bare repository
          conf: A ConfigParser Object
        """
        self.conf = conf
>       self.auth_ver = self.conf.get('swift', 'auth_ver')
E       AttributeError: 'NoneType' object has no attribute 'get'

dulwich/contrib/swift.py:60: AttributeError
</pre>
</details>
<h3 id="test_swiftpytestswiftconnectortest_del_object">test_swift.py::TestSwiftConnector::test_del_object</h3>
<details><summary> <pre>test_swift.py::TestSwiftConnector::test_del_object</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftConnector testMethod=test_del_object>

    def setUp(self):
        super().setUp()
        self.conf = swift.load_conf(file=StringIO(config_file % def_config_file))
        with patch("geventhttpclient.HTTPClient.request", fake_auth_request_v1):
>           self.conn = swift.SwiftConnector("fakerepo", conf=self.conf)

tests/contrib/test_swift.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftConnector object at 0x7eec1f7b8580>
root = 'fakerepo', conf = None

    def __init__(self, root, conf) -> None:
        """Initialize a SwiftConnector.

        Args:
          root: The swift container that will act as Git bare repository
          conf: A ConfigParser Object
        """
        self.conf = conf
>       self.auth_ver = self.conf.get('swift', 'auth_ver')
E       AttributeError: 'NoneType' object has no attribute 'get'

dulwich/contrib/swift.py:60: AttributeError
</pre>
</details>
<h3 id="test_swiftpytestswiftconnectortest_del_root">test_swift.py::TestSwiftConnector::test_del_root</h3>
<details><summary> <pre>test_swift.py::TestSwiftConnector::test_del_root</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftConnector testMethod=test_del_root>

    def setUp(self):
        super().setUp()
        self.conf = swift.load_conf(file=StringIO(config_file % def_config_file))
        with patch("geventhttpclient.HTTPClient.request", fake_auth_request_v1):
>           self.conn = swift.SwiftConnector("fakerepo", conf=self.conf)

tests/contrib/test_swift.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftConnector object at 0x7eec1f6248e0>
root = 'fakerepo', conf = None

    def __init__(self, root, conf) -> None:
        """Initialize a SwiftConnector.

        Args:
          root: The swift container that will act as Git bare repository
          conf: A ConfigParser Object
        """
        self.conf = conf
>       self.auth_ver = self.conf.get('swift', 'auth_ver')
E       AttributeError: 'NoneType' object has no attribute 'get'

dulwich/contrib/swift.py:60: AttributeError
</pre>
</details>
<h3 id="test_swiftpytestswiftconnectortest_get_container_objects">test_swift.py::TestSwiftConnector::test_get_container_objects</h3>
<details><summary> <pre>test_swift.py::TestSwiftConnector::test_get_container_objects</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftConnector testMethod=test_get_container_objects>

    def setUp(self):
        super().setUp()
        self.conf = swift.load_conf(file=StringIO(config_file % def_config_file))
        with patch("geventhttpclient.HTTPClient.request", fake_auth_request_v1):
>           self.conn = swift.SwiftConnector("fakerepo", conf=self.conf)

tests/contrib/test_swift.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftConnector object at 0x7eec208556c0>
root = 'fakerepo', conf = None

    def __init__(self, root, conf) -> None:
        """Initialize a SwiftConnector.

        Args:
          root: The swift container that will act as Git bare repository
          conf: A ConfigParser Object
        """
        self.conf = conf
>       self.auth_ver = self.conf.get('swift', 'auth_ver')
E       AttributeError: 'NoneType' object has no attribute 'get'

dulwich/contrib/swift.py:60: AttributeError
</pre>
</details>
<h3 id="test_swiftpytestswiftconnectortest_get_container_objects_fails">test_swift.py::TestSwiftConnector::test_get_container_objects_fails</h3>
<details><summary> <pre>test_swift.py::TestSwiftConnector::test_get_container_objects_fails</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftConnector testMethod=test_get_container_objects_fails>

    def setUp(self):
        super().setUp()
        self.conf = swift.load_conf(file=StringIO(config_file % def_config_file))
        with patch("geventhttpclient.HTTPClient.request", fake_auth_request_v1):
>           self.conn = swift.SwiftConnector("fakerepo", conf=self.conf)

tests/contrib/test_swift.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftConnector object at 0x7eec1fb48be0>
root = 'fakerepo', conf = None

    def __init__(self, root, conf) -> None:
        """Initialize a SwiftConnector.

        Args:
          root: The swift container that will act as Git bare repository
          conf: A ConfigParser Object
        """
        self.conf = conf
>       self.auth_ver = self.conf.get('swift', 'auth_ver')
E       AttributeError: 'NoneType' object has no attribute 'get'

dulwich/contrib/swift.py:60: AttributeError
</pre>
</details>
<h3 id="test_swiftpytestswiftconnectortest_get_object">test_swift.py::TestSwiftConnector::test_get_object</h3>
<details><summary> <pre>test_swift.py::TestSwiftConnector::test_get_object</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftConnector testMethod=test_get_object>

    def setUp(self):
        super().setUp()
        self.conf = swift.load_conf(file=StringIO(config_file % def_config_file))
        with patch("geventhttpclient.HTTPClient.request", fake_auth_request_v1):
>           self.conn = swift.SwiftConnector("fakerepo", conf=self.conf)

tests/contrib/test_swift.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftConnector object at 0x7eec1fc74190>
root = 'fakerepo', conf = None

    def __init__(self, root, conf) -> None:
        """Initialize a SwiftConnector.

        Args:
          root: The swift container that will act as Git bare repository
          conf: A ConfigParser Object
        """
        self.conf = conf
>       self.auth_ver = self.conf.get('swift', 'auth_ver')
E       AttributeError: 'NoneType' object has no attribute 'get'

dulwich/contrib/swift.py:60: AttributeError
</pre>
</details>
<h3 id="test_swiftpytestswiftconnectortest_get_object_fails">test_swift.py::TestSwiftConnector::test_get_object_fails</h3>
<details><summary> <pre>test_swift.py::TestSwiftConnector::test_get_object_fails</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftConnector testMethod=test_get_object_fails>

    def setUp(self):
        super().setUp()
        self.conf = swift.load_conf(file=StringIO(config_file % def_config_file))
        with patch("geventhttpclient.HTTPClient.request", fake_auth_request_v1):
>           self.conn = swift.SwiftConnector("fakerepo", conf=self.conf)

tests/contrib/test_swift.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftConnector object at 0x7eec1fa1d630>
root = 'fakerepo', conf = None

    def __init__(self, root, conf) -> None:
        """Initialize a SwiftConnector.

        Args:
          root: The swift container that will act as Git bare repository
          conf: A ConfigParser Object
        """
        self.conf = conf
>       self.auth_ver = self.conf.get('swift', 'auth_ver')
E       AttributeError: 'NoneType' object has no attribute 'get'

dulwich/contrib/swift.py:60: AttributeError
</pre>
</details>
<h3 id="test_swiftpytestswiftconnectortest_get_object_stat">test_swift.py::TestSwiftConnector::test_get_object_stat</h3>
<details><summary> <pre>test_swift.py::TestSwiftConnector::test_get_object_stat</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftConnector testMethod=test_get_object_stat>

    def setUp(self):
        super().setUp()
        self.conf = swift.load_conf(file=StringIO(config_file % def_config_file))
        with patch("geventhttpclient.HTTPClient.request", fake_auth_request_v1):
>           self.conn = swift.SwiftConnector("fakerepo", conf=self.conf)

tests/contrib/test_swift.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftConnector object at 0x7eec21e25d80>
root = 'fakerepo', conf = None

    def __init__(self, root, conf) -> None:
        """Initialize a SwiftConnector.

        Args:
          root: The swift container that will act as Git bare repository
          conf: A ConfigParser Object
        """
        self.conf = conf
>       self.auth_ver = self.conf.get('swift', 'auth_ver')
E       AttributeError: 'NoneType' object has no attribute 'get'

dulwich/contrib/swift.py:60: AttributeError
</pre>
</details>
<h3 id="test_swiftpytestswiftconnectortest_get_object_stat_fails">test_swift.py::TestSwiftConnector::test_get_object_stat_fails</h3>
<details><summary> <pre>test_swift.py::TestSwiftConnector::test_get_object_stat_fails</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftConnector testMethod=test_get_object_stat_fails>

    def setUp(self):
        super().setUp()
        self.conf = swift.load_conf(file=StringIO(config_file % def_config_file))
        with patch("geventhttpclient.HTTPClient.request", fake_auth_request_v1):
>           self.conn = swift.SwiftConnector("fakerepo", conf=self.conf)

tests/contrib/test_swift.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftConnector object at 0x7eec1fc7b430>
root = 'fakerepo', conf = None

    def __init__(self, root, conf) -> None:
        """Initialize a SwiftConnector.

        Args:
          root: The swift container that will act as Git bare repository
          conf: A ConfigParser Object
        """
        self.conf = conf
>       self.auth_ver = self.conf.get('swift', 'auth_ver')
E       AttributeError: 'NoneType' object has no attribute 'get'

dulwich/contrib/swift.py:60: AttributeError
</pre>
</details>
<h3 id="test_swiftpytestswiftconnectortest_init_connector">test_swift.py::TestSwiftConnector::test_init_connector</h3>
<details><summary> <pre>test_swift.py::TestSwiftConnector::test_init_connector</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftConnector testMethod=test_init_connector>

    def setUp(self):
        super().setUp()
        self.conf = swift.load_conf(file=StringIO(config_file % def_config_file))
        with patch("geventhttpclient.HTTPClient.request", fake_auth_request_v1):
>           self.conn = swift.SwiftConnector("fakerepo", conf=self.conf)

tests/contrib/test_swift.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftConnector object at 0x7eec219b3c70>
root = 'fakerepo', conf = None

    def __init__(self, root, conf) -> None:
        """Initialize a SwiftConnector.

        Args:
          root: The swift container that will act as Git bare repository
          conf: A ConfigParser Object
        """
        self.conf = conf
>       self.auth_ver = self.conf.get('swift', 'auth_ver')
E       AttributeError: 'NoneType' object has no attribute 'get'

dulwich/contrib/swift.py:60: AttributeError
</pre>
</details>
<h3 id="test_swiftpytestswiftconnectortest_put_object">test_swift.py::TestSwiftConnector::test_put_object</h3>
<details><summary> <pre>test_swift.py::TestSwiftConnector::test_put_object</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftConnector testMethod=test_put_object>

    def setUp(self):
        super().setUp()
        self.conf = swift.load_conf(file=StringIO(config_file % def_config_file))
        with patch("geventhttpclient.HTTPClient.request", fake_auth_request_v1):
>           self.conn = swift.SwiftConnector("fakerepo", conf=self.conf)

tests/contrib/test_swift.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftConnector object at 0x7eec1f6263e0>
root = 'fakerepo', conf = None

    def __init__(self, root, conf) -> None:
        """Initialize a SwiftConnector.

        Args:
          root: The swift container that will act as Git bare repository
          conf: A ConfigParser Object
        """
        self.conf = conf
>       self.auth_ver = self.conf.get('swift', 'auth_ver')
E       AttributeError: 'NoneType' object has no attribute 'get'

dulwich/contrib/swift.py:60: AttributeError
</pre>
</details>
<h3 id="test_swiftpytestswiftconnectortest_put_object_fails">test_swift.py::TestSwiftConnector::test_put_object_fails</h3>
<details><summary> <pre>test_swift.py::TestSwiftConnector::test_put_object_fails</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftConnector testMethod=test_put_object_fails>

    def setUp(self):
        super().setUp()
        self.conf = swift.load_conf(file=StringIO(config_file % def_config_file))
        with patch("geventhttpclient.HTTPClient.request", fake_auth_request_v1):
>           self.conn = swift.SwiftConnector("fakerepo", conf=self.conf)

tests/contrib/test_swift.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftConnector object at 0x7eec1fb4bdc0>
root = 'fakerepo', conf = None

    def __init__(self, root, conf) -> None:
        """Initialize a SwiftConnector.

        Args:
          root: The swift container that will act as Git bare repository
          conf: A ConfigParser Object
        """
        self.conf = conf
>       self.auth_ver = self.conf.get('swift', 'auth_ver')
E       AttributeError: 'NoneType' object has no attribute 'get'

dulwich/contrib/swift.py:60: AttributeError
</pre>
</details>
<h3 id="test_swiftpytestswiftconnectortest_root_exists">test_swift.py::TestSwiftConnector::test_root_exists</h3>
<details><summary> <pre>test_swift.py::TestSwiftConnector::test_root_exists</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftConnector testMethod=test_root_exists>

    def setUp(self):
        super().setUp()
        self.conf = swift.load_conf(file=StringIO(config_file % def_config_file))
        with patch("geventhttpclient.HTTPClient.request", fake_auth_request_v1):
>           self.conn = swift.SwiftConnector("fakerepo", conf=self.conf)

tests/contrib/test_swift.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftConnector object at 0x7eec1faf45b0>
root = 'fakerepo', conf = None

    def __init__(self, root, conf) -> None:
        """Initialize a SwiftConnector.

        Args:
          root: The swift container that will act as Git bare repository
          conf: A ConfigParser Object
        """
        self.conf = conf
>       self.auth_ver = self.conf.get('swift', 'auth_ver')
E       AttributeError: 'NoneType' object has no attribute 'get'

dulwich/contrib/swift.py:60: AttributeError
</pre>
</details>
<h3 id="test_swiftpytestswiftconnectortest_root_not_exists">test_swift.py::TestSwiftConnector::test_root_not_exists</h3>
<details><summary> <pre>test_swift.py::TestSwiftConnector::test_root_not_exists</pre></summary><pre>
self = <tests.contrib.test_swift.TestSwiftConnector testMethod=test_root_not_exists>

    def setUp(self):
        super().setUp()
        self.conf = swift.load_conf(file=StringIO(config_file % def_config_file))
        with patch("geventhttpclient.HTTPClient.request", fake_auth_request_v1):
>           self.conn = swift.SwiftConnector("fakerepo", conf=self.conf)

tests/contrib/test_swift.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.contrib.swift.SwiftConnector object at 0x7eec1f82de40>
root = 'fakerepo', conf = None

    def __init__(self, root, conf) -> None:
        """Initialize a SwiftConnector.

        Args:
          root: The swift container that will act as Git bare repository
          conf: A ConfigParser Object
        """
        self.conf = conf
>       self.auth_ver = self.conf.get('swift', 'auth_ver')
E       AttributeError: 'NoneType' object has no attribute 'get'

dulwich/contrib/swift.py:60: AttributeError
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_clone_bare">test_swift_smoke.py::SwiftRepoSmokeTest::test_clone_bare</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_clone_bare</pre></summary><pre>
cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
>       cls.th_server.run()

tests/contrib/test_swift_smoke.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/contrib/test_swift_smoke.py:58: in run
    self.server = server.TCPGitServer(self.backend, "localhost", port=self.port)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.server.TCPGitServer object at 0x7eec1f7bb070>
backend = <tests.contrib.test_swift_smoke.SwiftSystemBackend object at 0x7eec1f7b9690>
listen_addr = 'localhost', port = 9148, handlers = None

    def __init__(self, backend, listen_addr, port=TCP_GIT_PORT, handlers=None) -> None:
        self.handlers = dict(DEFAULT_HANDLERS)
        if handlers is not None:
            self.handlers.update(handlers)
        self.backend = backend
        logger.info('Listening for TCP connections on %s:%d', listen_addr, port)
>       socketserver.TCPServer.__init__(self, (listen_addr, port), self._make_handler)
E       AttributeError: 'TCPGitServer' object has no attribute '_make_handler'

dulwich/server.py:331: AttributeError
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_clone_then_push_data">test_swift_smoke.py::SwiftRepoSmokeTest::test_clone_then_push_data</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_clone_then_push_data</pre></summary><pre>
cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
>       cls.th_server.run()

tests/contrib/test_swift_smoke.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/contrib/test_swift_smoke.py:58: in run
    self.server = server.TCPGitServer(self.backend, "localhost", port=self.port)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.server.TCPGitServer object at 0x7eec1f7bb070>
backend = <tests.contrib.test_swift_smoke.SwiftSystemBackend object at 0x7eec1f7b9690>
listen_addr = 'localhost', port = 9148, handlers = None

    def __init__(self, backend, listen_addr, port=TCP_GIT_PORT, handlers=None) -> None:
        self.handlers = dict(DEFAULT_HANDLERS)
        if handlers is not None:
            self.handlers.update(handlers)
        self.backend = backend
        logger.info('Listening for TCP connections on %s:%d', listen_addr, port)
>       socketserver.TCPServer.__init__(self, (listen_addr, port), self._make_handler)
E       AttributeError: 'TCPGitServer' object has no attribute '_make_handler'

dulwich/server.py:331: AttributeError
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_init_bare">test_swift_smoke.py::SwiftRepoSmokeTest::test_init_bare</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_init_bare</pre></summary><pre>
cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
>       cls.th_server.run()

tests/contrib/test_swift_smoke.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/contrib/test_swift_smoke.py:58: in run
    self.server = server.TCPGitServer(self.backend, "localhost", port=self.port)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.server.TCPGitServer object at 0x7eec1f7bb070>
backend = <tests.contrib.test_swift_smoke.SwiftSystemBackend object at 0x7eec1f7b9690>
listen_addr = 'localhost', port = 9148, handlers = None

    def __init__(self, backend, listen_addr, port=TCP_GIT_PORT, handlers=None) -> None:
        self.handlers = dict(DEFAULT_HANDLERS)
        if handlers is not None:
            self.handlers.update(handlers)
        self.backend = backend
        logger.info('Listening for TCP connections on %s:%d', listen_addr, port)
>       socketserver.TCPServer.__init__(self, (listen_addr, port), self._make_handler)
E       AttributeError: 'TCPGitServer' object has no attribute '_make_handler'

dulwich/server.py:331: AttributeError
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_push_annotated_tag">test_swift_smoke.py::SwiftRepoSmokeTest::test_push_annotated_tag</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_push_annotated_tag</pre></summary><pre>
cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
>       cls.th_server.run()

tests/contrib/test_swift_smoke.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/contrib/test_swift_smoke.py:58: in run
    self.server = server.TCPGitServer(self.backend, "localhost", port=self.port)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.server.TCPGitServer object at 0x7eec1f7bb070>
backend = <tests.contrib.test_swift_smoke.SwiftSystemBackend object at 0x7eec1f7b9690>
listen_addr = 'localhost', port = 9148, handlers = None

    def __init__(self, backend, listen_addr, port=TCP_GIT_PORT, handlers=None) -> None:
        self.handlers = dict(DEFAULT_HANDLERS)
        if handlers is not None:
            self.handlers.update(handlers)
        self.backend = backend
        logger.info('Listening for TCP connections on %s:%d', listen_addr, port)
>       socketserver.TCPServer.__init__(self, (listen_addr, port), self._make_handler)
E       AttributeError: 'TCPGitServer' object has no attribute '_make_handler'

dulwich/server.py:331: AttributeError
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_push_branch">test_swift_smoke.py::SwiftRepoSmokeTest::test_push_branch</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_push_branch</pre></summary><pre>
cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
>       cls.th_server.run()

tests/contrib/test_swift_smoke.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/contrib/test_swift_smoke.py:58: in run
    self.server = server.TCPGitServer(self.backend, "localhost", port=self.port)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.server.TCPGitServer object at 0x7eec1f7bb070>
backend = <tests.contrib.test_swift_smoke.SwiftSystemBackend object at 0x7eec1f7b9690>
listen_addr = 'localhost', port = 9148, handlers = None

    def __init__(self, backend, listen_addr, port=TCP_GIT_PORT, handlers=None) -> None:
        self.handlers = dict(DEFAULT_HANDLERS)
        if handlers is not None:
            self.handlers.update(handlers)
        self.backend = backend
        logger.info('Listening for TCP connections on %s:%d', listen_addr, port)
>       socketserver.TCPServer.__init__(self, (listen_addr, port), self._make_handler)
E       AttributeError: 'TCPGitServer' object has no attribute '_make_handler'

dulwich/server.py:331: AttributeError
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_push_commit">test_swift_smoke.py::SwiftRepoSmokeTest::test_push_commit</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_push_commit</pre></summary><pre>
cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
>       cls.th_server.run()

tests/contrib/test_swift_smoke.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/contrib/test_swift_smoke.py:58: in run
    self.server = server.TCPGitServer(self.backend, "localhost", port=self.port)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.server.TCPGitServer object at 0x7eec1f7bb070>
backend = <tests.contrib.test_swift_smoke.SwiftSystemBackend object at 0x7eec1f7b9690>
listen_addr = 'localhost', port = 9148, handlers = None

    def __init__(self, backend, listen_addr, port=TCP_GIT_PORT, handlers=None) -> None:
        self.handlers = dict(DEFAULT_HANDLERS)
        if handlers is not None:
            self.handlers.update(handlers)
        self.backend = backend
        logger.info('Listening for TCP connections on %s:%d', listen_addr, port)
>       socketserver.TCPServer.__init__(self, (listen_addr, port), self._make_handler)
E       AttributeError: 'TCPGitServer' object has no attribute '_make_handler'

dulwich/server.py:331: AttributeError
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_push_data_branch">test_swift_smoke.py::SwiftRepoSmokeTest::test_push_data_branch</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_push_data_branch</pre></summary><pre>
cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
>       cls.th_server.run()

tests/contrib/test_swift_smoke.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/contrib/test_swift_smoke.py:58: in run
    self.server = server.TCPGitServer(self.backend, "localhost", port=self.port)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.server.TCPGitServer object at 0x7eec1f7bb070>
backend = <tests.contrib.test_swift_smoke.SwiftSystemBackend object at 0x7eec1f7b9690>
listen_addr = 'localhost', port = 9148, handlers = None

    def __init__(self, backend, listen_addr, port=TCP_GIT_PORT, handlers=None) -> None:
        self.handlers = dict(DEFAULT_HANDLERS)
        if handlers is not None:
            self.handlers.update(handlers)
        self.backend = backend
        logger.info('Listening for TCP connections on %s:%d', listen_addr, port)
>       socketserver.TCPServer.__init__(self, (listen_addr, port), self._make_handler)
E       AttributeError: 'TCPGitServer' object has no attribute '_make_handler'

dulwich/server.py:331: AttributeError
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_push_multiple_branch">test_swift_smoke.py::SwiftRepoSmokeTest::test_push_multiple_branch</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_push_multiple_branch</pre></summary><pre>
cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
>       cls.th_server.run()

tests/contrib/test_swift_smoke.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/contrib/test_swift_smoke.py:58: in run
    self.server = server.TCPGitServer(self.backend, "localhost", port=self.port)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.server.TCPGitServer object at 0x7eec1f7bb070>
backend = <tests.contrib.test_swift_smoke.SwiftSystemBackend object at 0x7eec1f7b9690>
listen_addr = 'localhost', port = 9148, handlers = None

    def __init__(self, backend, listen_addr, port=TCP_GIT_PORT, handlers=None) -> None:
        self.handlers = dict(DEFAULT_HANDLERS)
        if handlers is not None:
            self.handlers.update(handlers)
        self.backend = backend
        logger.info('Listening for TCP connections on %s:%d', listen_addr, port)
>       socketserver.TCPServer.__init__(self, (listen_addr, port), self._make_handler)
E       AttributeError: 'TCPGitServer' object has no attribute '_make_handler'

dulwich/server.py:331: AttributeError
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_push_remove_branch">test_swift_smoke.py::SwiftRepoSmokeTest::test_push_remove_branch</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_push_remove_branch</pre></summary><pre>
cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
>       cls.th_server.run()

tests/contrib/test_swift_smoke.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/contrib/test_swift_smoke.py:58: in run
    self.server = server.TCPGitServer(self.backend, "localhost", port=self.port)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.server.TCPGitServer object at 0x7eec1f7bb070>
backend = <tests.contrib.test_swift_smoke.SwiftSystemBackend object at 0x7eec1f7b9690>
listen_addr = 'localhost', port = 9148, handlers = None

    def __init__(self, backend, listen_addr, port=TCP_GIT_PORT, handlers=None) -> None:
        self.handlers = dict(DEFAULT_HANDLERS)
        if handlers is not None:
            self.handlers.update(handlers)
        self.backend = backend
        logger.info('Listening for TCP connections on %s:%d', listen_addr, port)
>       socketserver.TCPServer.__init__(self, (listen_addr, port), self._make_handler)
E       AttributeError: 'TCPGitServer' object has no attribute '_make_handler'

dulwich/server.py:331: AttributeError
</pre>
</details>
<h3 id="test_archivepyarchiveteststest_empty">test_archive.py::ArchiveTests::test_empty</h3>
<details><summary> <pre>test_archive.py::ArchiveTests::test_empty</pre></summary><pre>
self = <tests.test_archive.ArchiveTests testMethod=test_empty>

    def test_empty(self):
        store = MemoryObjectStore()
>       c1, c2, c3 = build_commit_graph(store, [[1], [2, 1], [3, 1, 2]])
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_archive.py:44: TypeError
</pre>
</details>
<h3 id="test_archivepyarchiveteststest_gzip_mtime">test_archive.py::ArchiveTests::test_gzip_mtime</h3>
<details><summary> <pre>test_archive.py::ArchiveTests::test_gzip_mtime</pre></summary><pre>
self = <tests.test_archive.ArchiveTests testMethod=test_gzip_mtime>

    def test_gzip_mtime(self):
>       stream = self._get_example_tar_stream(mtime=1234, format="gz")

tests/test_archive.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_archive.ArchiveTests testMethod=test_gzip_mtime>
tar_stream_args = (), tar_stream_kwargs = {'format': 'gz', 'mtime': 1234}
store = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fc46e00>
b1 = None, t1 = <Tree None>

    def _get_example_tar_stream(self, *tar_stream_args, **tar_stream_kwargs):
        store = MemoryObjectStore()
        b1 = Blob.from_string(b"somedata")
        store.add_object(b1)
        t1 = Tree()
>       t1.add(b"somename", 0o100644, b1.id)
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_archive.py:57: AttributeError
</pre>
</details>
<h3 id="test_archivepyarchiveteststest_prefix">test_archive.py::ArchiveTests::test_prefix</h3>
<details><summary> <pre>test_archive.py::ArchiveTests::test_prefix</pre></summary><pre>
self = <tests.test_archive.ArchiveTests testMethod=test_prefix>

    def test_prefix(self):
>       stream = self._get_example_tar_stream(mtime=0, prefix=b"blah")

tests/test_archive.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_archive.ArchiveTests testMethod=test_prefix>
tar_stream_args = (), tar_stream_kwargs = {'mtime': 0, 'prefix': b'blah'}
store = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fad58d0>
b1 = None, t1 = <Tree None>

    def _get_example_tar_stream(self, *tar_stream_args, **tar_stream_kwargs):
        store = MemoryObjectStore()
        b1 = Blob.from_string(b"somedata")
        store.add_object(b1)
        t1 = Tree()
>       t1.add(b"somename", 0o100644, b1.id)
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_archive.py:57: AttributeError
</pre>
</details>
<h3 id="test_archivepyarchiveteststest_same_file">test_archive.py::ArchiveTests::test_same_file</h3>
<details><summary> <pre>test_archive.py::ArchiveTests::test_same_file</pre></summary><pre>
self = <tests.test_archive.ArchiveTests testMethod=test_same_file>

    @skipUnless(patch, "Required mock.patch")
    def test_same_file(self):
        contents = [None, None]
        for format in ["", "gz", "bz2"]:
            for i in [0, 1]:
                with patch("time.time", return_value=i):
>                   stream = self._get_example_tar_stream(mtime=0, format=format)

tests/test_archive.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_archive.ArchiveTests testMethod=test_same_file>
tar_stream_args = (), tar_stream_kwargs = {'format': '', 'mtime': 0}
store = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f6abf40>
b1 = None, t1 = <Tree None>

    def _get_example_tar_stream(self, *tar_stream_args, **tar_stream_kwargs):
        store = MemoryObjectStore()
        b1 = Blob.from_string(b"somedata")
        store.add_object(b1)
        t1 = Tree()
>       t1.add(b"somename", 0o100644, b1.id)
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_archive.py:57: AttributeError
</pre>
</details>
<h3 id="test_archivepyarchiveteststest_simple">test_archive.py::ArchiveTests::test_simple</h3>
<details><summary> <pre>test_archive.py::ArchiveTests::test_simple</pre></summary><pre>
self = <tests.test_archive.ArchiveTests testMethod=test_simple>

    def test_simple(self):
>       stream = self._get_example_tar_stream(mtime=0)

tests/test_archive.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_archive.ArchiveTests testMethod=test_simple>
tar_stream_args = (), tar_stream_kwargs = {'mtime': 0}
store = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fad4490>
b1 = None, t1 = <Tree None>

    def _get_example_tar_stream(self, *tar_stream_args, **tar_stream_kwargs):
        store = MemoryObjectStore()
        b1 = Blob.from_string(b"somedata")
        store.add_object(b1)
        t1 = Tree()
>       t1.add(b"somename", 0o100644, b1.id)
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_archive.py:57: AttributeError
</pre>
</details>
<h3 id="test_archivepyarchiveteststest_unicode">test_archive.py::ArchiveTests::test_unicode</h3>
<details><summary> <pre>test_archive.py::ArchiveTests::test_unicode</pre></summary><pre>
self = <tests.test_archive.ArchiveTests testMethod=test_unicode>

    def test_unicode(self):
        store = MemoryObjectStore()
        b1 = Blob.from_string(b"somedata")
        store.add_object(b1)
        t1 = Tree()
>       t1.add("ő".encode(), 0o100644, b1.id)
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_archive.py:73: AttributeError
</pre>
</details>
<h3 id="test_bundlepybundleteststest_roundtrip_bundle">test_bundle.py::BundleTests::test_roundtrip_bundle</h3>
<details><summary> <pre>test_bundle.py::BundleTests::test_roundtrip_bundle</pre></summary><pre>
self = <tests.test_bundle.BundleTests testMethod=test_roundtrip_bundle>

    def test_roundtrip_bundle(self):
        origbundle = Bundle()
        origbundle.version = 3
        origbundle.capabilities = {"foo": None}
        origbundle.references = {b"refs/heads/master": b"ab" * 20}
        origbundle.prerequisites = [(b"cc" * 20, "comment")]
        b = BytesIO()
        write_pack_objects(b.write, [])
        b.seek(0)
>       origbundle.pack_data = PackData.from_file(b)
E       AttributeError: type object 'PackData' has no attribute 'from_file'

tests/test_bundle.py:43: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_closing_bracket_within_section_string">test_config.py::ConfigFileTests::test_closing_bracket_within_section_string</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_closing_bracket_within_section_string</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_closing_bracket_within_section_string>

    def test_closing_bracket_within_section_string(self):
        cf = self.from_file(b'[branch "foo]bar"] # a comment\nbar= foo\n')
>       self.assertEqual(ConfigFile({(b"branch", b"foo]bar"): {b"bar": b"foo"}}), cf)

tests/test_config.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec207f8fd0>
values = {(b'branch', b'foo]bar'): {b'bar': b'foo'}}, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_comment_after_section">test_config.py::ConfigFileTests::test_comment_after_section</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_comment_after_section</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_comment_after_section>

    def test_comment_after_section(self):
        cf = self.from_file(b"[section] # foo\n")
>       self.assertEqual(ConfigFile({(b"section",): {}}), cf)

tests/test_config.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec1fcc8370>
values = {(b'section',): {}}, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_comment_after_variable">test_config.py::ConfigFileTests::test_comment_after_variable</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_comment_after_variable</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_comment_after_variable>

    def test_comment_after_variable(self):
        cf = self.from_file(b"[section]\nbar= foo # a comment\n")
>       self.assertEqual(ConfigFile({(b"section",): {b"bar": b"foo"}}), cf)

tests/test_config.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec1f6a9a50>
values = {(b'section',): {b'bar': b'foo'}}, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_comment_before_section">test_config.py::ConfigFileTests::test_comment_before_section</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_comment_before_section</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_comment_before_section>

    def test_comment_before_section(self):
        cf = self.from_file(b"# foo\n[section]\n")
>       self.assertEqual(ConfigFile({(b"section",): {}}), cf)

tests/test_config.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec1fca7520>
values = {(b'section',): {}}, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_comment_character_within_section_string">test_config.py::ConfigFileTests::test_comment_character_within_section_string</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_comment_character_within_section_string</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_comment_character_within_section_string>

    def test_comment_character_within_section_string(self):
        cf = self.from_file(b'[branch "foo#bar"] # a comment\nbar= foo\n')
>       self.assertEqual(ConfigFile({(b"branch", b"foo#bar"): {b"bar": b"foo"}}), cf)

tests/test_config.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec219b3340>
values = {(b'branch', b'foo#bar'): {b'bar': b'foo'}}, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_comment_character_within_value_string">test_config.py::ConfigFileTests::test_comment_character_within_value_string</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_comment_character_within_value_string</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_comment_character_within_value_string>

    def test_comment_character_within_value_string(self):
        cf = self.from_file(b'[section]\nbar= "foo#bar"\n')
>       self.assertEqual(ConfigFile({(b"section",): {b"bar": b"foo#bar"}}), cf)

tests/test_config.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec208f4f70>
values = {(b'section',): {b'bar': b'foo#bar'}}, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_default_config">test_config.py::ConfigFileTests::test_default_config</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_default_config</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_default_config>

        def test_default_config(self):
            cf = self.from_file(
                b"""[core]
    \trepositoryformatversion = 0
    \tfilemode = true
    \tbare = false
    \tlogallrefupdates = true
    """
            )
            self.assertEqual(
>               ConfigFile(
                    {
                        (b"core",): {
                            b"repositoryformatversion": b"0",
                            b"filemode": b"true",
                            b"bare": b"false",
                            b"logallrefupdates": b"true",
                        }
                    }
                ),
                cf,
            )

tests/test_config.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec1f7bb880>
values = {(b'core',): {b'bare': b'false', b'filemode': b'true', b'logallrefupdates': b'true', b'repositoryformatversion': b'0'}}
encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_empty">test_config.py::ConfigFileTests::test_empty</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_empty</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_empty>

    def test_empty(self):
>       ConfigFile()

tests/test_config.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec1fc97b20>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_empty_line_before_section">test_config.py::ConfigFileTests::test_empty_line_before_section</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_empty_line_before_section</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_empty_line_before_section>

    def test_empty_line_before_section(self):
        cf = self.from_file(b"\n[section]\n")
>       self.assertEqual(ConfigFile({(b"section",): {}}), cf)

tests/test_config.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec1fcac9a0>
values = {(b'section',): {}}, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_eq">test_config.py::ConfigFileTests::test_eq</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_eq</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_eq>

    def test_eq(self):
>       self.assertEqual(ConfigFile(), ConfigFile())

tests/test_config.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec1f9f3a00>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_from_file_empty">test_config.py::ConfigFileTests::test_from_file_empty</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_from_file_empty</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_from_file_empty>

    def test_from_file_empty(self):
        cf = self.from_file(b"")
>       self.assertEqual(ConfigFile(), cf)

tests/test_config.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec1fb4a530>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_from_file_multiple">test_config.py::ConfigFileTests::test_from_file_multiple</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_from_file_multiple</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_from_file_multiple>

    def test_from_file_multiple(self):
        cf = self.from_file(b"[core]\nfoo = bar\nfoo = blah\n")
>       self.assertEqual([b"bar", b"blah"], list(cf.get_multivar((b"core",), b"foo")))
E       AttributeError: 'NoneType' object has no attribute 'get_multivar'

tests/test_config.py:117: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_from_file_section">test_config.py::ConfigFileTests::test_from_file_section</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_from_file_section</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_from_file_section>

    def test_from_file_section(self):
        cf = self.from_file(b"[core]\nfoo = bar\n")
>       self.assertEqual(b"bar", cf.get((b"core",), b"foo"))
E       AttributeError: 'NoneType' object has no attribute 'get'

tests/test_config.py:112: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_from_file_section_case_insensitive_lower">test_config.py::ConfigFileTests::test_from_file_section_case_insensitive_lower</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_from_file_section_case_insensitive_lower</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_from_file_section_case_insensitive_lower>

    def test_from_file_section_case_insensitive_lower(self):
        cf = self.from_file(b"[cOre]\nfOo = bar\n")
>       self.assertEqual(b"bar", cf.get((b"core",), b"foo"))
E       AttributeError: 'NoneType' object has no attribute 'get'

tests/test_config.py:127: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_from_file_section_case_insensitive_mixed">test_config.py::ConfigFileTests::test_from_file_section_case_insensitive_mixed</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_from_file_section_case_insensitive_mixed</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_from_file_section_case_insensitive_mixed>

    def test_from_file_section_case_insensitive_mixed(self):
        cf = self.from_file(b"[cOre]\nfOo = bar\n")
>       self.assertEqual(b"bar", cf.get((b"core",), b"fOo"))
E       AttributeError: 'NoneType' object has no attribute 'get'

tests/test_config.py:132: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_from_file_section_with_open_brackets">test_config.py::ConfigFileTests::test_from_file_section_with_open_brackets</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_from_file_section_with_open_brackets</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_from_file_section_with_open_brackets>

    def test_from_file_section_with_open_brackets(self):
>       self.assertRaises(ValueError, self.from_file, b"[core\nfoo = bar\n")
E       AssertionError: ValueError not raised by from_file

tests/test_config.py:140: AssertionError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_from_file_subsection">test_config.py::ConfigFileTests::test_from_file_subsection</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_from_file_subsection</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_from_file_subsection>

    def test_from_file_subsection(self):
        cf = self.from_file(b'[branch "foo"]\nfoo = bar\n')
>       self.assertEqual(b"bar", cf.get((b"branch", b"foo"), b"foo"))
E       AttributeError: 'NoneType' object has no attribute 'get'

tests/test_config.py:159: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_from_file_subsection_invalid">test_config.py::ConfigFileTests::test_from_file_subsection_invalid</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_from_file_subsection_invalid</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_from_file_subsection_invalid>

    def test_from_file_subsection_invalid(self):
>       self.assertRaises(ValueError, self.from_file, b'[branch "foo]\nfoo = bar\n')
E       AssertionError: ValueError not raised by from_file

tests/test_config.py:162: AssertionError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_from_file_subsection_not_quoted">test_config.py::ConfigFileTests::test_from_file_subsection_not_quoted</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_from_file_subsection_not_quoted</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_from_file_subsection_not_quoted>

    def test_from_file_subsection_not_quoted(self):
        cf = self.from_file(b"[branch.foo]\nfoo = bar\n")
>       self.assertEqual(b"bar", cf.get((b"branch", b"foo"), b"foo"))
E       AttributeError: 'NoneType' object has no attribute 'get'

tests/test_config.py:166: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_from_file_utf8_bom">test_config.py::ConfigFileTests::test_from_file_utf8_bom</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_from_file_utf8_bom</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_from_file_utf8_bom>

    def test_from_file_utf8_bom(self):
        text = "[core]\nfoo = b\u00e4r\n".encode("utf-8-sig")
        cf = self.from_file(text)
>       self.assertEqual(b"b\xc3\xa4r", cf.get((b"core",), b"foo"))
E       AttributeError: 'NoneType' object has no attribute 'get'

tests/test_config.py:123: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_from_file_value_with_open_quoted">test_config.py::ConfigFileTests::test_from_file_value_with_open_quoted</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_from_file_value_with_open_quoted</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_from_file_value_with_open_quoted>

    def test_from_file_value_with_open_quoted(self):
>       self.assertRaises(ValueError, self.from_file, b'[core]\nfoo = "bar\n')
E       AssertionError: ValueError not raised by from_file

tests/test_config.py:143: AssertionError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_from_file_with_boolean_setting">test_config.py::ConfigFileTests::test_from_file_with_boolean_setting</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_from_file_with_boolean_setting</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_from_file_with_boolean_setting>

    def test_from_file_with_boolean_setting(self):
        cf = self.from_file(b"[core]\n" b"foo\n")
>       self.assertEqual(b"true", cf.get((b"core",), b"foo"))
E       AttributeError: 'NoneType' object has no attribute 'get'

tests/test_config.py:155: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_from_file_with_interrupted_line">test_config.py::ConfigFileTests::test_from_file_with_interrupted_line</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_from_file_with_interrupted_line</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_from_file_with_interrupted_line>

    def test_from_file_with_interrupted_line(self):
        cf = self.from_file(b"[core]\n" b"foo = bar\\\n" b" la\n")
>       self.assertEqual(b"barla", cf.get((b"core",), b"foo"))
E       AttributeError: 'NoneType' object has no attribute 'get'

tests/test_config.py:151: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_from_file_with_mixed_quoted">test_config.py::ConfigFileTests::test_from_file_with_mixed_quoted</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_from_file_with_mixed_quoted</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_from_file_with_mixed_quoted>

    def test_from_file_with_mixed_quoted(self):
        cf = self.from_file(b'[core]\nfoo = "bar"la\n')
>       self.assertEqual(b"barla", cf.get((b"core",), b"foo"))
E       AttributeError: 'NoneType' object has no attribute 'get'

tests/test_config.py:137: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_from_file_with_quotes">test_config.py::ConfigFileTests::test_from_file_with_quotes</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_from_file_with_quotes</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_from_file_with_quotes>

    def test_from_file_with_quotes(self):
        cf = self.from_file(b"[core]\n" b'foo = " bar"\n')
>       self.assertEqual(b" bar", cf.get((b"core",), b"foo"))
E       AttributeError: 'NoneType' object has no attribute 'get'

tests/test_config.py:147: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_quoted">test_config.py::ConfigFileTests::test_quoted</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_quoted</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_quoted>

        def test_quoted(self):
            cf = self.from_file(
                b"""[gui]
    \tfontdiff = -family \\\"Ubuntu Mono\\\" -size 11 -overstrike 0
    """
            )
            self.assertEqual(
>               ConfigFile(
                    {
                        (b"gui",): {
                            b"fontdiff": b'-family "Ubuntu Mono" -size 11 -overstrike 0',
                        }
                    }
                ),
                cf,
            )

tests/test_config.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec1fb48ac0>
values = {(b'gui',): {b'fontdiff': b'-family "Ubuntu Mono" -size 11 -overstrike 0'}}
encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_quoted_multiline">test_config.py::ConfigFileTests::test_quoted_multiline</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_quoted_multiline</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_quoted_multiline>

        def test_quoted_multiline(self):
            cf = self.from_file(
                b"""[alias]
    who = \"!who() {\\
      git log --no-merges --pretty=format:'%an - %ae' $@ | uniq -c | sort -rn;\\
    };\\
    who\"
    """
            )
            self.assertEqual(
>               ConfigFile(
                    {
                        (b"alias",): {
                            b"who": (
                                b"!who() {git log --no-merges --pretty=format:'%an - "
                                b"%ae' $@ | uniq -c | sort -rn;};who"
                            )
                        }
                    }
                ),
                cf,
            )

tests/test_config.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec1f9d8640>
values = {(b'alias',): {b'who': b"!who() {git log --no-merges --pretty=format:'%an - %ae' $@ | uniq -c | sort -rn;};who"}}
encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_quoted_newlines_windows">test_config.py::ConfigFileTests::test_quoted_newlines_windows</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_quoted_newlines_windows</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_quoted_newlines_windows>

    def test_quoted_newlines_windows(self):
        cf = self.from_file(
            b"[alias]\r\n"
            b"c = '!f() { \\\r\n"
            b' printf \'[git commit -m \\"%s\\"]\\n\' \\"$*\\" && \\\r\n'
            b' git commit -m \\"$*\\"; \\\r\n'
            b" }; f'\r\n"
        )
>       self.assertEqual(list(cf.sections()), [(b"alias",)])
E       AttributeError: 'NoneType' object has no attribute 'sections'

tests/test_config.py:206: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_same_line">test_config.py::ConfigFileTests::test_same_line</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_same_line</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_same_line>

    def test_same_line(self):
        cf = self.from_file(b"[branch.foo] foo = bar\n")
>       self.assertEqual(b"bar", cf.get((b"branch", b"foo"), b"foo"))
E       AttributeError: 'NoneType' object has no attribute 'get'

tests/test_config.py:196: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_set_hash_gets_quoted">test_config.py::ConfigFileTests::test_set_hash_gets_quoted</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_set_hash_gets_quoted</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_set_hash_gets_quoted>

    def test_set_hash_gets_quoted(self):
>       c = ConfigFile()

tests/test_config.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec1fafca60>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_write_preserve_multivar">test_config.py::ConfigFileTests::test_write_preserve_multivar</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_write_preserve_multivar</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_write_preserve_multivar>

    def test_write_preserve_multivar(self):
        cf = self.from_file(b"[core]\nfoo = bar\nfoo = blah\n")
        f = BytesIO()
>       cf.write_to_file(f)
E       AttributeError: 'NoneType' object has no attribute 'write_to_file'

tests/test_config.py:171: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_write_to_file_empty">test_config.py::ConfigFileTests::test_write_to_file_empty</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_write_to_file_empty</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_write_to_file_empty>

    def test_write_to_file_empty(self):
>       c = ConfigFile()

tests/test_config.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec1f9f6a70>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_write_to_file_section">test_config.py::ConfigFileTests::test_write_to_file_section</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_write_to_file_section</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_write_to_file_section>

    def test_write_to_file_section(self):
>       c = ConfigFile()

tests/test_config.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec1f669090>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigfileteststest_write_to_file_subsection">test_config.py::ConfigFileTests::test_write_to_file_subsection</h3>
<details><summary> <pre>test_config.py::ConfigFileTests::test_write_to_file_subsection</pre></summary><pre>
self = <tests.test_config.ConfigFileTests testMethod=test_write_to_file_subsection>

    def test_write_to_file_subsection(self):
>       c = ConfigFile()

tests/test_config.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/config.py:251: in __init__
    super().__init__(values=values, encoding=encoding)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigFile' object has no attribute '_values'") raised in repr()] ConfigFile object at 0x7eec1fb57160>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigdictteststest_dict">test_config.py::ConfigDictTests::test_dict</h3>
<details><summary> <pre>test_config.py::ConfigDictTests::test_dict</pre></summary><pre>
self = <tests.test_config.ConfigDictTests testMethod=test_dict>

    def test_dict(self):
>       cd = ConfigDict()

tests/test_config.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigDict' object has no attribute '_values'") raised in repr()] ConfigDict object at 0x7eec1fcaf6d0>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigdictteststest_get_boolean">test_config.py::ConfigDictTests::test_get_boolean</h3>
<details><summary> <pre>test_config.py::ConfigDictTests::test_get_boolean</pre></summary><pre>
self = <tests.test_config.ConfigDictTests testMethod=test_get_boolean>

    def test_get_boolean(self):
>       cd = ConfigDict()

tests/test_config.py:270: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigDict' object has no attribute '_values'") raised in repr()] ConfigDict object at 0x7eec1fb4a830>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigdictteststest_get_set">test_config.py::ConfigDictTests::test_get_set</h3>
<details><summary> <pre>test_config.py::ConfigDictTests::test_get_set</pre></summary><pre>
self = <tests.test_config.ConfigDictTests testMethod=test_get_set>

    def test_get_set(self):
>       cd = ConfigDict()

tests/test_config.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigDict' object has no attribute '_values'") raised in repr()] ConfigDict object at 0x7eec1f82cee0>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigdictteststest_items">test_config.py::ConfigDictTests::test_items</h3>
<details><summary> <pre>test_config.py::ConfigDictTests::test_items</pre></summary><pre>
self = <tests.test_config.ConfigDictTests testMethod=test_items>

    def test_items(self):
>       cd = ConfigDict()

tests/test_config.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigDict' object has no attribute '_values'") raised in repr()] ConfigDict object at 0x7eec1f9f6800>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigdictteststest_items_nonexistant">test_config.py::ConfigDictTests::test_items_nonexistant</h3>
<details><summary> <pre>test_config.py::ConfigDictTests::test_items_nonexistant</pre></summary><pre>
self = <tests.test_config.ConfigDictTests testMethod=test_items_nonexistant>

    def test_items_nonexistant(self):
>       cd = ConfigDict()

tests/test_config.py:297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigDict' object has no attribute '_values'") raised in repr()] ConfigDict object at 0x7eec1f9e6500>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyconfigdictteststest_sections">test_config.py::ConfigDictTests::test_sections</h3>
<details><summary> <pre>test_config.py::ConfigDictTests::test_sections</pre></summary><pre>
self = <tests.test_config.ConfigDictTests testMethod=test_sections>

    def test_sections(self):
>       cd = ConfigDict()

tests/test_config.py:303: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigDict' object has no attribute '_values'") raised in repr()] ConfigDict object at 0x7eec1faf6500>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyescapevalueteststest_backslash">test_config.py::EscapeValueTests::test_backslash</h3>
<details><summary> <pre>test_config.py::EscapeValueTests::test_backslash</pre></summary><pre>
self = <tests.test_config.EscapeValueTests testMethod=test_backslash>

    def test_backslash(self):
>       self.assertEqual(b"foo\\\\", _escape_value(b"foo\\"))
E       AssertionError: b'foo\\\\' != b'foo\\'

tests/test_config.py:357: AssertionError
</pre>
</details>
<h3 id="test_configpyescapevalueteststest_newline">test_config.py::EscapeValueTests::test_newline</h3>
<details><summary> <pre>test_config.py::EscapeValueTests::test_newline</pre></summary><pre>
self = <tests.test_config.EscapeValueTests testMethod=test_newline>

    def test_newline(self):
>       self.assertEqual(b"foo\\n", _escape_value(b"foo\n"))
E       AssertionError: b'foo\\n' != b'foo\n'

tests/test_config.py:360: AssertionError
</pre>
</details>
<h3 id="test_configpyformatstringteststest_quoted">test_config.py::FormatStringTests::test_quoted</h3>
<details><summary> <pre>test_config.py::FormatStringTests::test_quoted</pre></summary><pre>
self = <tests.test_config.FormatStringTests testMethod=test_quoted>

    def test_quoted(self):
>       self.assertEqual(b'" foo"', _format_string(b" foo"))
E       AssertionError: b'" foo"' != b' foo'

tests/test_config.py:365: AssertionError
</pre>
</details>
<h3 id="test_configpyparsestringteststest_newline">test_config.py::ParseStringTests::test_newline</h3>
<details><summary> <pre>test_config.py::ParseStringTests::test_newline</pre></summary><pre>
self = <tests.test_config.ParseStringTests testMethod=test_newline>

    def test_newline(self):
>       self.assertEqual(b"\nbar\t", _parse_string(b"\\nbar\\t\t"))
E       AssertionError: b'\nbar\t' != b'\\nbar\\t\t'

tests/test_config.py:389: AssertionError
</pre>
</details>
<h3 id="test_configpyparsestringteststest_quote">test_config.py::ParseStringTests::test_quote</h3>
<details><summary> <pre>test_config.py::ParseStringTests::test_quote</pre></summary><pre>
self = <tests.test_config.ParseStringTests testMethod=test_quote>

    def test_quote(self):
>       self.assertEqual(b'"foo"', _parse_string(b'\\"foo\\"'))
E       AssertionError: b'"foo"' != b'\\"foo\\"'

tests/test_config.py:392: AssertionError
</pre>
</details>
<h3 id="test_configpyparsestringteststest_tab">test_config.py::ParseStringTests::test_tab</h3>
<details><summary> <pre>test_config.py::ParseStringTests::test_tab</pre></summary><pre>
self = <tests.test_config.ParseStringTests testMethod=test_tab>

    def test_tab(self):
>       self.assertEqual(b"\tbar\t", _parse_string(b"\\tbar\\t"))
E       AssertionError: b'\tbar\t' != b'\\tbar\\t'

tests/test_config.py:386: AssertionError
</pre>
</details>
<h3 id="test_configpysubmodulesteststestmalformedsubmodules">test_config.py::SubmodulesTests::testMalformedSubmodules</h3>
<details><summary> <pre>test_config.py::SubmodulesTests::testMalformedSubmodules</pre></summary><pre>
self = <tests.test_config.SubmodulesTests testMethod=testMalformedSubmodules>

        def testMalformedSubmodules(self):
            cf = ConfigFile.from_file(
                BytesIO(
                    b"""\
    [submodule "core/lib"]
    \tpath = core/lib
    \turl = https://github.com/phhusson/QuasselC.git

    [submodule "dulwich"]
    \turl = https://github.com/jelmer/dulwich
    """
                )
            )
>           got = list(parse_submodules(cf))
E           TypeError: 'NoneType' object is not iterable

tests/test_config.py:455: TypeError
</pre>
</details>
<h3 id="test_configpysubmodulesteststestsubmodules">test_config.py::SubmodulesTests::testSubmodules</h3>
<details><summary> <pre>test_config.py::SubmodulesTests::testSubmodules</pre></summary><pre>
self = <tests.test_config.SubmodulesTests testMethod=testSubmodules>

        def testSubmodules(self):
            cf = ConfigFile.from_file(
                BytesIO(
                    b"""\
    [submodule "core/lib"]
    \tpath = core/lib
    \turl = https://github.com/phhusson/QuasselC.git
    """
                )
            )
>           got = list(parse_submodules(cf))
E           TypeError: 'NoneType' object is not iterable

tests/test_config.py:430: TypeError
</pre>
</details>
<h3 id="test_configpyapplyinsteadofteststest_apply">test_config.py::ApplyInsteadOfTests::test_apply</h3>
<details><summary> <pre>test_config.py::ApplyInsteadOfTests::test_apply</pre></summary><pre>
self = <tests.test_config.ApplyInsteadOfTests testMethod=test_apply>

    def test_apply(self):
>       config = ConfigDict()

tests/test_config.py:476: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigDict' object has no attribute '_values'") raised in repr()] ConfigDict object at 0x7eec1fc44760>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyapplyinsteadofteststest_apply_multiple">test_config.py::ApplyInsteadOfTests::test_apply_multiple</h3>
<details><summary> <pre>test_config.py::ApplyInsteadOfTests::test_apply_multiple</pre></summary><pre>
self = <tests.test_config.ApplyInsteadOfTests testMethod=test_apply_multiple>

    def test_apply_multiple(self):
>       config = ConfigDict()

tests/test_config.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigDict' object has no attribute '_values'") raised in repr()] ConfigDict object at 0x7eec1fa1e230>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_configpyapplyinsteadofteststest_none">test_config.py::ApplyInsteadOfTests::test_none</h3>
<details><summary> <pre>test_config.py::ApplyInsteadOfTests::test_none</pre></summary><pre>
self = <tests.test_config.ApplyInsteadOfTests testMethod=test_none>

    def test_none(self):
>       config = ConfigDict()

tests/test_config.py:470: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigDict' object has no attribute '_values'") raised in repr()] ConfigDict object at 0x7eec208567a0>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_credentialspytestcredentialhelpersutilstest_match_partial_url">test_credentials.py::TestCredentialHelpersUtils::test_match_partial_url</h3>
<details><summary> <pre>test_credentials.py::TestCredentialHelpersUtils::test_match_partial_url</pre></summary><pre>
self = <tests.test_credentials.TestCredentialHelpersUtils testMethod=test_match_partial_url>

    def test_match_partial_url(self):
        url = urlparse("https://github.com/jelmer/dulwich/")
>       self.assertTrue(match_partial_url(url, "github.com"))
E       AssertionError: False is not true

tests/test_credentials.py:49: AssertionError
</pre>
</details>
<h3 id="test_credentialspytestcredentialhelpersutilstest_match_urls">test_credentials.py::TestCredentialHelpersUtils::test_match_urls</h3>
<details><summary> <pre>test_credentials.py::TestCredentialHelpersUtils::test_match_urls</pre></summary><pre>
self = <tests.test_credentials.TestCredentialHelpersUtils testMethod=test_match_urls>

    def test_match_urls(self):
        url = urlparse("https://github.com/jelmer/dulwich/")
        url_1 = urlparse("https://github.com/jelmer/dulwich")
        url_2 = urlparse("https://github.com/jelmer")
        url_3 = urlparse("https://github.com")
>       self.assertTrue(match_urls(url, url_1))

tests/test_credentials.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/credentials.py:19: in match_urls
    parsed1 = urlparse(url1)
/usr/lib/python3.10/urllib/parse.py:399: in urlparse
    url, scheme, _coerce_result = _coerce_args(url, scheme)
/usr/lib/python3.10/urllib/parse.py:136: in _coerce_args
    return _decode_args(args) + (_encode_result,)
/usr/lib/python3.10/urllib/parse.py:120: in _decode_args
    return tuple(x.decode(encoding, errors) if x else '' for x in args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

.0 = <tuple_iterator object at 0x7eec1f9cd510>

>   return tuple(x.decode(encoding, errors) if x else '' for x in args)
E   AttributeError: 'ParseResult' object has no attribute 'decode'. Did you mean: 'encode'?

/usr/lib/python3.10/urllib/parse.py:120: AttributeError
</pre>
</details>
<h3 id="test_credentialspytestcredentialhelpersutilstest_urlmatch_credential_sections">test_credentials.py::TestCredentialHelpersUtils::test_urlmatch_credential_sections</h3>
<details><summary> <pre>test_credentials.py::TestCredentialHelpersUtils::test_urlmatch_credential_sections</pre></summary><pre>
self = <tests.test_credentials.TestCredentialHelpersUtils testMethod=test_urlmatch_credential_sections>

    def test_urlmatch_credential_sections(self):
>       config = ConfigDict()

tests/test_credentials.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ConfigDict' object has no attribute '_values'") raised in repr()] ConfigDict object at 0x7eec1fcca3e0>
values = None, encoding = 'utf-8'

    def __init__(self, values: Union[MutableMapping[Section, MutableMapping[Name, Value]], None]=None, encoding: Union[str, None]=None) -> None:
        """Create a new ConfigDict."""
        if encoding is None:
            encoding = sys.getdefaultencoding()
        self.encoding = encoding
>       self._values = CaseInsensitiveOrderedMultiDict.make(values)
E       AttributeError: type object 'CaseInsensitiveOrderedMultiDict' has no attribute 'make'

dulwich/config.py:135: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_add_delete">test_diff_tree.py::TreeChangesTest::test_tree_changes_add_delete</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_add_delete</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_add_delete>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f9f37f0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_change_type">test_diff_tree.py::TreeChangesTest::test_tree_changes_change_type</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_change_type</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_change_type>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fae4ca0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_change_type_same">test_diff_tree.py::TreeChangesTest::test_tree_changes_change_type_same</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_change_type_same</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_change_type_same>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f9f3df0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_complex">test_diff_tree.py::TreeChangesTest::test_tree_changes_complex</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_complex</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_complex>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fae5f60>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_empty">test_diff_tree.py::TreeChangesTest::test_tree_changes_empty</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_empty</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_empty>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f9f3610>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_for_merge_add_add_same_conflict">test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_add_add_same_conflict</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_add_add_same_conflict</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_for_merge_add_add_same_conflict>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fae6830>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_for_merge_add_content_rename_conflict">test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_add_content_rename_conflict</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_add_content_rename_conflict</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_for_merge_add_content_rename_conflict>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f66b2e0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_for_merge_add_exact_rename_conflict">test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_add_exact_rename_conflict</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_add_exact_rename_conflict</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_for_merge_add_exact_rename_conflict>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f9f4880>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_for_merge_add_modify_conflict">test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_add_modify_conflict</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_add_modify_conflict</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_for_merge_add_modify_conflict>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fb4c760>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_for_merge_add_no_conflict">test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_add_no_conflict</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_add_no_conflict</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_for_merge_add_no_conflict>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec207fb3a0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_for_merge_delete_delete_conflict">test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_delete_delete_conflict</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_delete_delete_conflict</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_for_merge_delete_delete_conflict>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f6249d0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_for_merge_delete_no_conflict">test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_delete_no_conflict</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_delete_no_conflict</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_for_merge_delete_no_conflict>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fcc8970>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_for_merge_modify_modify_conflict">test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_modify_modify_conflict</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_modify_modify_conflict</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_for_merge_modify_modify_conflict>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f624d30>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_for_merge_modify_no_conflict">test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_modify_no_conflict</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_modify_no_conflict</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_for_merge_modify_no_conflict>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec203a0d30>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_for_merge_modify_rename_conflict">test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_modify_rename_conflict</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_modify_rename_conflict</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_for_merge_modify_rename_conflict>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fafda50>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_for_merge_octopus_delete">test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_octopus_delete</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_octopus_delete</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_for_merge_octopus_delete>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fcc8d00>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_for_merge_octopus_modify_conflict">test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_octopus_modify_conflict</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_octopus_modify_conflict</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_for_merge_octopus_modify_conflict>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fafc700>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_for_merge_octopus_no_conflict">test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_octopus_no_conflict</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_for_merge_octopus_no_conflict</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_for_merge_octopus_no_conflict>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f82d870>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_modify_contents">test_diff_tree.py::TreeChangesTest::test_tree_changes_modify_contents</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_modify_contents</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_modify_contents>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fb500a0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_modify_mode">test_diff_tree.py::TreeChangesTest::test_tree_changes_modify_mode</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_modify_mode</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_modify_mode>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f82d480>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_name_order">test_diff_tree.py::TreeChangesTest::test_tree_changes_name_order</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_name_order</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_name_order>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f9f0040>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_no_changes">test_diff_tree.py::TreeChangesTest::test_tree_changes_no_changes</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_no_changes</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_no_changes>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec203a1b40>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_prune">test_diff_tree.py::TreeChangesTest::test_tree_changes_prune</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_prune</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_prune>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f9e7e80>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_rename_detector">test_diff_tree.py::TreeChangesTest::test_tree_changes_rename_detector</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_rename_detector</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_rename_detector>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec20966740>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepytreechangestesttest_tree_changes_to_tree">test_diff_tree.py::TreeChangesTest::test_tree_changes_to_tree</h3>
<details><summary> <pre>test_diff_tree.py::TreeChangesTest::test_tree_changes_to_tree</pre></summary><pre>
self = <tests.test_diff_tree.TreeChangesTest testMethod=test_tree_changes_to_tree>

    def setUp(self):
>       super().setUp()

tests/test_diff_tree.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:55: in setUp
    self.empty_tree = self.commit_tree([])
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f82d2a0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_content_rename_gitlink">test_diff_tree.py::RenameDetectionTest::test_content_rename_gitlink</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_content_rename_gitlink</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_content_rename_gitlink>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1facc880>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_content_rename_many_to_many">test_diff_tree.py::RenameDetectionTest::test_content_rename_many_to_many</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_content_rename_many_to_many</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_content_rename_many_to_many>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fcac430>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_content_rename_many_to_one">test_diff_tree.py::RenameDetectionTest::test_content_rename_many_to_one</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_content_rename_many_to_one</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_content_rename_many_to_one>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1facd420>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_content_rename_max_files">test_diff_tree.py::RenameDetectionTest::test_content_rename_max_files</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_content_rename_max_files</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_content_rename_max_files>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f9f4460>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_content_rename_one_to_many">test_diff_tree.py::RenameDetectionTest::test_content_rename_one_to_many</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_content_rename_one_to_many</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_content_rename_one_to_many>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fcc8b80>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_content_rename_one_to_one">test_diff_tree.py::RenameDetectionTest::test_content_rename_one_to_one</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_content_rename_one_to_one</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_content_rename_one_to_one>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fc44790>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_content_rename_one_to_one_ordering">test_diff_tree.py::RenameDetectionTest::test_content_rename_one_to_one_ordering</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_content_rename_one_to_one_ordering</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_content_rename_one_to_one_ordering>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fd6a2c0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_content_rename_swap">test_diff_tree.py::RenameDetectionTest::test_content_rename_swap</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_content_rename_swap</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_content_rename_swap>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fae72b0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_content_rename_with_more_deletions">test_diff_tree.py::RenameDetectionTest::test_content_rename_with_more_deletions</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_content_rename_with_more_deletions</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_content_rename_with_more_deletions>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fca4d30>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_exact_copy_change_mode">test_diff_tree.py::RenameDetectionTest::test_exact_copy_change_mode</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_exact_copy_change_mode</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_exact_copy_change_mode>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fae7910>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_exact_copy_modify">test_diff_tree.py::RenameDetectionTest::test_exact_copy_modify</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_exact_copy_modify</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_exact_copy_modify>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f6ab850>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_exact_rename_and_different_type">test_diff_tree.py::RenameDetectionTest::test_exact_rename_and_different_type</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_exact_rename_and_different_type</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_exact_rename_and_different_type>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fcaf730>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_exact_rename_many_to_many">test_diff_tree.py::RenameDetectionTest::test_exact_rename_many_to_many</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_exact_rename_many_to_many</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_exact_rename_many_to_many>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f6ab610>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_exact_rename_many_to_one">test_diff_tree.py::RenameDetectionTest::test_exact_rename_many_to_one</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_exact_rename_many_to_one</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_exact_rename_many_to_one>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fcae050>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_exact_rename_one_to_many">test_diff_tree.py::RenameDetectionTest::test_exact_rename_one_to_many</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_exact_rename_one_to_many</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_exact_rename_one_to_many>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f9d9de0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_exact_rename_one_to_one">test_diff_tree.py::RenameDetectionTest::test_exact_rename_one_to_one</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_exact_rename_one_to_one</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_exact_rename_one_to_one>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fcae170>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_exact_rename_split_different_type">test_diff_tree.py::RenameDetectionTest::test_exact_rename_split_different_type</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_exact_rename_split_different_type</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_exact_rename_split_different_type>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f9d8fa0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_exact_rename_swap">test_diff_tree.py::RenameDetectionTest::test_exact_rename_swap</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_exact_rename_swap</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_exact_rename_swap>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fcaf6d0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_find_copies_harder_content">test_diff_tree.py::RenameDetectionTest::test_find_copies_harder_content</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_find_copies_harder_content</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_find_copies_harder_content>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec207f8fd0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_find_copies_harder_exact">test_diff_tree.py::RenameDetectionTest::test_find_copies_harder_exact</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_find_copies_harder_exact</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_find_copies_harder_exact>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f9cba00>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_find_copies_harder_with_rewrites">test_diff_tree.py::RenameDetectionTest::test_find_copies_harder_with_rewrites</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_find_copies_harder_with_rewrites</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_find_copies_harder_with_rewrites>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f6247f0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_no_renames">test_diff_tree.py::RenameDetectionTest::test_no_renames</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_no_renames</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_no_renames>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fae41c0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_rename_threshold">test_diff_tree.py::RenameDetectionTest::test_rename_threshold</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_rename_threshold</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_rename_threshold>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fb48ac0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_reuse_detector">test_diff_tree.py::RenameDetectionTest::test_reuse_detector</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_reuse_detector</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_reuse_detector>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1ef061a0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_rewrite_threshold">test_diff_tree.py::RenameDetectionTest::test_rewrite_threshold</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_rewrite_threshold</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_rewrite_threshold>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fd690f0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_similarity_score">test_diff_tree.py::RenameDetectionTest::test_similarity_score</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_similarity_score</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_similarity_score>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1faf5ab0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_similarity_score_cache">test_diff_tree.py::RenameDetectionTest::test_similarity_score_cache</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_similarity_score_cache</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_similarity_score_cache>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1fcac6d0>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_tree_entry_sort">test_diff_tree.py::RenameDetectionTest::test_tree_entry_sort</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_tree_entry_sort</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_tree_entry_sort>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f7ba290>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_diff_treepyrenamedetectiontesttest_want_unchanged">test_diff_tree.py::RenameDetectionTest::test_want_unchanged</h3>
<details><summary> <pre>test_diff_tree.py::RenameDetectionTest::test_want_unchanged</pre></summary><pre>
self = <tests.test_diff_tree.RenameDetectionTest testMethod=test_want_unchanged>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
>       self.empty_tree = self.commit_tree([])

tests/test_diff_tree.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_diff_tree.py:71: in commit_tree
    return self.store[commit_tree(self.store, commit_blobs)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.object_store.MemoryObjectStore object at 0x7eec1f9f2590>
name = None

    def __getitem__(self, name: ObjectID):
>       return self._data[self._to_hexsha(name)].copy()
E       AttributeError: 'MemoryObjectStore' object has no attribute '_to_hexsha'

dulwich/object_store.py:405: AttributeError
</pre>
</details>
<h3 id="test_fastexportpygitimportprocessorteststest_commit_handler">test_fastexport.py::GitImportProcessorTests::test_commit_handler</h3>
<details><summary> <pre>test_fastexport.py::GitImportProcessorTests::test_commit_handler</pre></summary><pre>
self = <tests.test_fastexport.GitImportProcessorTests testMethod=test_commit_handler>

    def setUp(self):
        super().setUp()
>       self.repo = MemoryRepo()

tests/test_fastexport.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1f9c9de0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_fastexportpygitimportprocessorteststest_commit_handler_markers">test_fastexport.py::GitImportProcessorTests::test_commit_handler_markers</h3>
<details><summary> <pre>test_fastexport.py::GitImportProcessorTests::test_commit_handler_markers</pre></summary><pre>
self = <tests.test_fastexport.GitImportProcessorTests testMethod=test_commit_handler_markers>

    def setUp(self):
        super().setUp()
>       self.repo = MemoryRepo()

tests/test_fastexport.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1faf6200>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_fastexportpygitimportprocessorteststest_file_add">test_fastexport.py::GitImportProcessorTests::test_file_add</h3>
<details><summary> <pre>test_fastexport.py::GitImportProcessorTests::test_file_add</pre></summary><pre>
self = <tests.test_fastexport.GitImportProcessorTests testMethod=test_file_add>

    def setUp(self):
        super().setUp()
>       self.repo = MemoryRepo()

tests/test_fastexport.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1ef41cc0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_fastexportpygitimportprocessorteststest_file_copy">test_fastexport.py::GitImportProcessorTests::test_file_copy</h3>
<details><summary> <pre>test_fastexport.py::GitImportProcessorTests::test_file_copy</pre></summary><pre>
self = <tests.test_fastexport.GitImportProcessorTests testMethod=test_file_copy>

    def setUp(self):
        super().setUp()
>       self.repo = MemoryRepo()

tests/test_fastexport.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1fd618d0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_fastexportpygitimportprocessorteststest_file_delete">test_fastexport.py::GitImportProcessorTests::test_file_delete</h3>
<details><summary> <pre>test_fastexport.py::GitImportProcessorTests::test_file_delete</pre></summary><pre>
self = <tests.test_fastexport.GitImportProcessorTests testMethod=test_file_delete>

    def setUp(self):
        super().setUp()
>       self.repo = MemoryRepo()

tests/test_fastexport.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1fae7640>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_fastexportpygitimportprocessorteststest_file_deleteall">test_fastexport.py::GitImportProcessorTests::test_file_deleteall</h3>
<details><summary> <pre>test_fastexport.py::GitImportProcessorTests::test_file_deleteall</pre></summary><pre>
self = <tests.test_fastexport.GitImportProcessorTests testMethod=test_file_deleteall>

    def setUp(self):
        super().setUp()
>       self.repo = MemoryRepo()

tests/test_fastexport.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1f9d83a0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_fastexportpygitimportprocessorteststest_file_move">test_fastexport.py::GitImportProcessorTests::test_file_move</h3>
<details><summary> <pre>test_fastexport.py::GitImportProcessorTests::test_file_move</pre></summary><pre>
self = <tests.test_fastexport.GitImportProcessorTests testMethod=test_file_move>

    def setUp(self):
        super().setUp()
>       self.repo = MemoryRepo()

tests/test_fastexport.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1f637550>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_fastexportpygitimportprocessorteststest_import_stream">test_fastexport.py::GitImportProcessorTests::test_import_stream</h3>
<details><summary> <pre>test_fastexport.py::GitImportProcessorTests::test_import_stream</pre></summary><pre>
self = <tests.test_fastexport.GitImportProcessorTests testMethod=test_import_stream>

    def setUp(self):
        super().setUp()
>       self.repo = MemoryRepo()

tests/test_fastexport.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1ef214b0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_fastexportpygitimportprocessorteststest_reset_handler">test_fastexport.py::GitImportProcessorTests::test_reset_handler</h3>
<details><summary> <pre>test_fastexport.py::GitImportProcessorTests::test_reset_handler</pre></summary><pre>
self = <tests.test_fastexport.GitImportProcessorTests testMethod=test_reset_handler>

    def setUp(self):
        super().setUp()
>       self.repo = MemoryRepo()

tests/test_fastexport.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1ee3f700>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_fastexportpygitimportprocessorteststest_reset_handler_default">test_fastexport.py::GitImportProcessorTests::test_reset_handler_default</h3>
<details><summary> <pre>test_fastexport.py::GitImportProcessorTests::test_reset_handler_default</pre></summary><pre>
self = <tests.test_fastexport.GitImportProcessorTests testMethod=test_reset_handler_default>

    def setUp(self):
        super().setUp()
>       self.repo = MemoryRepo()

tests/test_fastexport.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1fca4e80>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_fastexportpygitimportprocessorteststest_reset_handler_marker">test_fastexport.py::GitImportProcessorTests::test_reset_handler_marker</h3>
<details><summary> <pre>test_fastexport.py::GitImportProcessorTests::test_reset_handler_marker</pre></summary><pre>
self = <tests.test_fastexport.GitImportProcessorTests testMethod=test_reset_handler_marker>

    def setUp(self):
        super().setUp()
>       self.repo = MemoryRepo()

tests/test_fastexport.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1facf7f0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_filepyfancyrenameteststest_dest_exists">test_file.py::FancyRenameTests::test_dest_exists</h3>
<details><summary> <pre>test_file.py::FancyRenameTests::test_dest_exists</pre></summary><pre>
self = <tests.test_file.FancyRenameTests testMethod=test_dest_exists>

    def test_dest_exists(self):
        self.create(self.bar, b"bar contents")
        _fancy_rename(self.foo, self.bar)
>       self.assertFalse(os.path.exists(self.foo))
E       AssertionError: True is not false

tests/test_file.py:64: AssertionError
</pre>
</details>
<h3 id="test_filepyfancyrenameteststest_no_dest_exists">test_file.py::FancyRenameTests::test_no_dest_exists</h3>
<details><summary> <pre>test_file.py::FancyRenameTests::test_no_dest_exists</pre></summary><pre>
self = <tests.test_file.FancyRenameTests testMethod=test_no_dest_exists>

    def test_no_dest_exists(self):
        self.assertFalse(os.path.exists(self.bar))
        _fancy_rename(self.foo, self.bar)
>       self.assertFalse(os.path.exists(self.foo))
E       AssertionError: True is not false

tests/test_file.py:55: AssertionError
</pre>
</details>
<h3 id="test_filepygitfileteststest_abort">test_file.py::GitFileTests::test_abort</h3>
<details><summary> <pre>test_file.py::GitFileTests::test_abort</pre></summary><pre>
self = <tests.test_file.GitFileTests testMethod=test_abort>

    def test_abort(self):
        foo = self.path("foo")
        foo_lock = f"{foo}.lock"

        orig_f = open(foo, "rb")
        self.assertEqual(orig_f.read(), b"foo contents")
        orig_f.close()

        f = GitFile(foo, "wb")
>       f.write(b"new contents")
E       AttributeError: 'NoneType' object has no attribute 'write'

tests/test_file.py:177: AttributeError
</pre>
</details>
<h3 id="test_filepygitfileteststest_abort_close">test_file.py::GitFileTests::test_abort_close</h3>
<details><summary> <pre>test_file.py::GitFileTests::test_abort_close</pre></summary><pre>
self = <tests.test_file.GitFileTests testMethod=test_abort_close>

    def test_abort_close(self):
        foo = self.path("foo")
        f = GitFile(foo, "wb")
>       f.abort()
E       AttributeError: 'NoneType' object has no attribute 'abort'

tests/test_file.py:189: AttributeError
</pre>
</details>
<h3 id="test_filepygitfileteststest_abort_close_removed">test_file.py::GitFileTests::test_abort_close_removed</h3>
<details><summary> <pre>test_file.py::GitFileTests::test_abort_close_removed</pre></summary><pre>
self = <tests.test_file.GitFileTests testMethod=test_abort_close_removed>

    def test_abort_close_removed(self):
        foo = self.path("foo")
        f = GitFile(foo, "wb")

>       f._file.close()
E       AttributeError: 'NoneType' object has no attribute '_file'

tests/test_file.py:206: AttributeError
</pre>
</details>
<h3 id="test_filepygitfileteststest_default_mode">test_file.py::GitFileTests::test_default_mode</h3>
<details><summary> <pre>test_file.py::GitFileTests::test_default_mode</pre></summary><pre>
self = <tests.test_file.GitFileTests testMethod=test_default_mode>

    def test_default_mode(self):
        f = GitFile(self.path("foo"))
>       self.assertEqual(b"foo contents", f.read())
E       AttributeError: 'NoneType' object has no attribute 'read'

tests/test_file.py:122: AttributeError
</pre>
</details>
<h3 id="test_filepygitfileteststest_invalid">test_file.py::GitFileTests::test_invalid</h3>
<details><summary> <pre>test_file.py::GitFileTests::test_invalid</pre></summary><pre>
self = <tests.test_file.GitFileTests testMethod=test_invalid>

    def test_invalid(self):
        foo = self.path("foo")
>       self.assertRaises(IOError, GitFile, foo, mode="r")
E       AssertionError: OSError not raised by GitFile

tests/test_file.py:105: AssertionError
</pre>
</details>
<h3 id="test_filepygitfileteststest_open_twice">test_file.py::GitFileTests::test_open_twice</h3>
<details><summary> <pre>test_file.py::GitFileTests::test_open_twice</pre></summary><pre>
self = <tests.test_file.GitFileTests testMethod=test_open_twice>

    def test_open_twice(self):
        foo = self.path("foo")
        f1 = GitFile(foo, "wb")
>       f1.write(b"new")
E       AttributeError: 'NoneType' object has no attribute 'write'

tests/test_file.py:152: AttributeError
</pre>
</details>
<h3 id="test_filepygitfileteststest_readonly">test_file.py::GitFileTests::test_readonly</h3>
<details><summary> <pre>test_file.py::GitFileTests::test_readonly</pre></summary><pre>
self = <tests.test_file.GitFileTests testMethod=test_readonly>

    def test_readonly(self):
        f = GitFile(self.path("foo"), "rb")
>       self.assertIsInstance(f, io.IOBase)
E       AssertionError: None is not an instance of <class 'io.IOBase'>

tests/test_file.py:113: AssertionError
</pre>
</details>
<h3 id="test_filepygitfileteststest_write">test_file.py::GitFileTests::test_write</h3>
<details><summary> <pre>test_file.py::GitFileTests::test_write</pre></summary><pre>
self = <tests.test_file.GitFileTests testMethod=test_write>

    def test_write(self):
        foo = self.path("foo")
        foo_lock = f"{foo}.lock"

        orig_f = open(foo, "rb")
        self.assertEqual(orig_f.read(), b"foo contents")
        orig_f.close()

        self.assertFalse(os.path.exists(foo_lock))
        f = GitFile(foo, "wb")
>       self.assertFalse(f.closed)
E       AttributeError: 'NoneType' object has no attribute 'closed'

tests/test_file.py:135: AttributeError
</pre>
</details>
<h3 id="test_graftspygraftparserteststest_multiple_hybrid">test_grafts.py::GraftParserTests::test_multiple_hybrid</h3>
<details><summary> <pre>test_grafts.py::GraftParserTests::test_multiple_hybrid</pre></summary><pre>
self = <tests.test_grafts.GraftParserTests testMethod=test_multiple_hybrid>

    def test_multiple_hybrid(self):
>       self.assertParse(
            {
                makesha(0): [],
                makesha(1): [makesha(2)],
                makesha(3): [makesha(4), makesha(5)],
            },
            [
                makesha(0),
                b" ".join([makesha(1), makesha(2)]),
                b" ".join([makesha(3), makesha(4), makesha(5)]),
            ],
        )

tests/test_grafts.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_grafts.py:39: in assertParse
    self.assertEqual(expected, parse_graftpoints(iter(graftpoints)))
E   AssertionError: {b'00000000000000000000000000000000000000[232 chars]55']} != None
</pre>
</details>
<h3 id="test_graftspygraftparserteststest_no_grafts">test_grafts.py::GraftParserTests::test_no_grafts</h3>
<details><summary> <pre>test_grafts.py::GraftParserTests::test_no_grafts</pre></summary><pre>
self = <tests.test_grafts.GraftParserTests testMethod=test_no_grafts>

    def test_no_grafts(self):
>       self.assertParse({}, [])

tests/test_grafts.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_grafts.py:39: in assertParse
    self.assertEqual(expected, parse_graftpoints(iter(graftpoints)))
E   AssertionError: {} != None
</pre>
</details>
<h3 id="test_graftspygraftparserteststest_no_parents">test_grafts.py::GraftParserTests::test_no_parents</h3>
<details><summary> <pre>test_grafts.py::GraftParserTests::test_no_parents</pre></summary><pre>
self = <tests.test_grafts.GraftParserTests testMethod=test_no_parents>

    def test_no_parents(self):
>       self.assertParse({makesha(0): []}, [makesha(0)])

tests/test_grafts.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_grafts.py:39: in assertParse
    self.assertEqual(expected, parse_graftpoints(iter(graftpoints)))
E   AssertionError: {b'0000000000000000000000000000000000000000': []} != None
</pre>
</details>
<h3 id="test_graftspygraftparserteststest_parents">test_grafts.py::GraftParserTests::test_parents</h3>
<details><summary> <pre>test_grafts.py::GraftParserTests::test_parents</pre></summary><pre>
self = <tests.test_grafts.GraftParserTests testMethod=test_parents>

    def test_parents(self):
>       self.assertParse(
            {makesha(0): [makesha(1), makesha(2)]},
            [b" ".join([makesha(0), makesha(1), makesha(2)])],
        )

tests/test_grafts.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_grafts.py:39: in assertParse
    self.assertEqual(expected, parse_graftpoints(iter(graftpoints)))
E   AssertionError: {b'00000000000000000000000000000000000000[91 chars]22']} != None
</pre>
</details>
<h3 id="test_graftspygraftserializerteststest_multiple_hybrid">test_grafts.py::GraftSerializerTests::test_multiple_hybrid</h3>
<details><summary> <pre>test_grafts.py::GraftSerializerTests::test_multiple_hybrid</pre></summary><pre>
self = <tests.test_grafts.GraftSerializerTests testMethod=test_multiple_hybrid>

    def test_multiple_hybrid(self):
>       self.assertSerialize(
            b"\n".join(
                [
                    makesha(0),
                    b" ".join([makesha(1), makesha(2)]),
                    b" ".join([makesha(3), makesha(4), makesha(5)]),
                ]
            ),
            {
                makesha(0): [],
                makesha(1): [makesha(2)],
                makesha(3): [makesha(4), makesha(5)],
            },
        )

tests/test_grafts.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_grafts.GraftSerializerTests testMethod=test_multiple_hybrid>
expected = b'0000000000000000000000000000000000000000\n1111111111111111111111111111111111111111 222222222222222222222222222222222...333333333333333333333333333333333333 4444444444444444444444444444444444444444 5555555555555555555555555555555555555555'
graftpoints = {b'0000000000000000000000000000000000000000': [], b'1111111111111111111111111111111111111111': [b'22222222222222222222...3333333333333333333333333': [b'4444444444444444444444444444444444444444', b'5555555555555555555555555555555555555555']}

    def assertSerialize(self, expected, graftpoints):
>       self.assertEqual(sorted(expected), sorted(serialize_graftpoints(graftpoints)))
E       TypeError: 'NoneType' object is not iterable

tests/test_grafts.py:70: TypeError
</pre>
</details>
<h3 id="test_graftspygraftserializerteststest_no_grafts">test_grafts.py::GraftSerializerTests::test_no_grafts</h3>
<details><summary> <pre>test_grafts.py::GraftSerializerTests::test_no_grafts</pre></summary><pre>
self = <tests.test_grafts.GraftSerializerTests testMethod=test_no_grafts>

    def test_no_grafts(self):
>       self.assertSerialize(b"", {})

tests/test_grafts.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_grafts.GraftSerializerTests testMethod=test_no_grafts>
expected = b'', graftpoints = {}

    def assertSerialize(self, expected, graftpoints):
>       self.assertEqual(sorted(expected), sorted(serialize_graftpoints(graftpoints)))
E       TypeError: 'NoneType' object is not iterable

tests/test_grafts.py:70: TypeError
</pre>
</details>
<h3 id="test_graftspygraftserializerteststest_no_parents">test_grafts.py::GraftSerializerTests::test_no_parents</h3>
<details><summary> <pre>test_grafts.py::GraftSerializerTests::test_no_parents</pre></summary><pre>
self = <tests.test_grafts.GraftSerializerTests testMethod=test_no_parents>

    def test_no_parents(self):
>       self.assertSerialize(makesha(0), {makesha(0): []})

tests/test_grafts.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_grafts.GraftSerializerTests testMethod=test_no_parents>
expected = b'0000000000000000000000000000000000000000'
graftpoints = {b'0000000000000000000000000000000000000000': []}

    def assertSerialize(self, expected, graftpoints):
>       self.assertEqual(sorted(expected), sorted(serialize_graftpoints(graftpoints)))
E       TypeError: 'NoneType' object is not iterable

tests/test_grafts.py:70: TypeError
</pre>
</details>
<h3 id="test_graftspygraftserializerteststest_parents">test_grafts.py::GraftSerializerTests::test_parents</h3>
<details><summary> <pre>test_grafts.py::GraftSerializerTests::test_parents</pre></summary><pre>
self = <tests.test_grafts.GraftSerializerTests testMethod=test_parents>

    def test_parents(self):
>       self.assertSerialize(
            b" ".join([makesha(0), makesha(1), makesha(2)]),
            {makesha(0): [makesha(1), makesha(2)]},
        )

tests/test_grafts.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_grafts.GraftSerializerTests testMethod=test_parents>
expected = b'0000000000000000000000000000000000000000 1111111111111111111111111111111111111111 2222222222222222222222222222222222222222'
graftpoints = {b'0000000000000000000000000000000000000000': [b'1111111111111111111111111111111111111111', b'2222222222222222222222222222222222222222']}

    def assertSerialize(self, expected, graftpoints):
>       self.assertEqual(sorted(expected), sorted(serialize_graftpoints(graftpoints)))
E       TypeError: 'NoneType' object is not iterable

tests/test_grafts.py:70: TypeError
</pre>
</details>
<h3 id="test_graftspygraftsinrepoteststest_existing_parent_graft">test_grafts.py::GraftsInRepoTests::test_existing_parent_graft</h3>
<details><summary> <pre>test_grafts.py::GraftsInRepoTests::test_existing_parent_graft</pre></summary><pre>
self = <tests.test_grafts.GraftsInRepoTests testMethod=test_existing_parent_graft>

    def setUp(self):
        super().setUp()
        self._repo_dir = os.path.join(tempfile.mkdtemp())
        r = self._repo = Repo.init(self._repo_dir)
        self.addCleanup(shutil.rmtree, self._repo_dir)

        self._shas = []

        commit_kwargs = {
            "committer": b"Test Committer <test@nodomain.com>",
            "author": b"Test Author <test@nodomain.com>",
            "commit_timestamp": 12395,
            "commit_timezone": 0,
            "author_timestamp": 12395,
            "author_timezone": 0,
        }

>       self._shas.append(r.do_commit(b"empty commit", **commit_kwargs))
E       AttributeError: 'NoneType' object has no attribute 'do_commit'

tests/test_grafts.py:161: AttributeError
</pre>
</details>
<h3 id="test_graftspygraftsinrepoteststest_init_with_empty_info_grafts">test_grafts.py::GraftsInRepoTests::test_init_with_empty_info_grafts</h3>
<details><summary> <pre>test_grafts.py::GraftsInRepoTests::test_init_with_empty_info_grafts</pre></summary><pre>
self = <tests.test_grafts.GraftsInRepoTests testMethod=test_init_with_empty_info_grafts>

    def setUp(self):
        super().setUp()
        self._repo_dir = os.path.join(tempfile.mkdtemp())
        r = self._repo = Repo.init(self._repo_dir)
        self.addCleanup(shutil.rmtree, self._repo_dir)

        self._shas = []

        commit_kwargs = {
            "committer": b"Test Committer <test@nodomain.com>",
            "author": b"Test Author <test@nodomain.com>",
            "commit_timestamp": 12395,
            "commit_timezone": 0,
            "author_timestamp": 12395,
            "author_timezone": 0,
        }

>       self._shas.append(r.do_commit(b"empty commit", **commit_kwargs))
E       AttributeError: 'NoneType' object has no attribute 'do_commit'

tests/test_grafts.py:161: AttributeError
</pre>
</details>
<h3 id="test_graftspygraftsinrepoteststest_init_with_info_grafts">test_grafts.py::GraftsInRepoTests::test_init_with_info_grafts</h3>
<details><summary> <pre>test_grafts.py::GraftsInRepoTests::test_init_with_info_grafts</pre></summary><pre>
self = <tests.test_grafts.GraftsInRepoTests testMethod=test_init_with_info_grafts>

    def setUp(self):
        super().setUp()
        self._repo_dir = os.path.join(tempfile.mkdtemp())
        r = self._repo = Repo.init(self._repo_dir)
        self.addCleanup(shutil.rmtree, self._repo_dir)

        self._shas = []

        commit_kwargs = {
            "committer": b"Test Committer <test@nodomain.com>",
            "author": b"Test Author <test@nodomain.com>",
            "commit_timestamp": 12395,
            "commit_timezone": 0,
            "author_timestamp": 12395,
            "author_timezone": 0,
        }

>       self._shas.append(r.do_commit(b"empty commit", **commit_kwargs))
E       AttributeError: 'NoneType' object has no attribute 'do_commit'

tests/test_grafts.py:161: AttributeError
</pre>
</details>
<h3 id="test_graftspygraftsinrepoteststest_no_grafts">test_grafts.py::GraftsInRepoTests::test_no_grafts</h3>
<details><summary> <pre>test_grafts.py::GraftsInRepoTests::test_no_grafts</pre></summary><pre>
self = <tests.test_grafts.GraftsInRepoTests testMethod=test_no_grafts>

    def setUp(self):
        super().setUp()
        self._repo_dir = os.path.join(tempfile.mkdtemp())
        r = self._repo = Repo.init(self._repo_dir)
        self.addCleanup(shutil.rmtree, self._repo_dir)

        self._shas = []

        commit_kwargs = {
            "committer": b"Test Committer <test@nodomain.com>",
            "author": b"Test Author <test@nodomain.com>",
            "commit_timestamp": 12395,
            "commit_timezone": 0,
            "author_timestamp": 12395,
            "author_timezone": 0,
        }

>       self._shas.append(r.do_commit(b"empty commit", **commit_kwargs))
E       AttributeError: 'NoneType' object has no attribute 'do_commit'

tests/test_grafts.py:161: AttributeError
</pre>
</details>
<h3 id="test_graftspygraftsinrepoteststest_no_parents_graft">test_grafts.py::GraftsInRepoTests::test_no_parents_graft</h3>
<details><summary> <pre>test_grafts.py::GraftsInRepoTests::test_no_parents_graft</pre></summary><pre>
self = <tests.test_grafts.GraftsInRepoTests testMethod=test_no_parents_graft>

    def setUp(self):
        super().setUp()
        self._repo_dir = os.path.join(tempfile.mkdtemp())
        r = self._repo = Repo.init(self._repo_dir)
        self.addCleanup(shutil.rmtree, self._repo_dir)

        self._shas = []

        commit_kwargs = {
            "committer": b"Test Committer <test@nodomain.com>",
            "author": b"Test Author <test@nodomain.com>",
            "commit_timestamp": 12395,
            "commit_timezone": 0,
            "author_timestamp": 12395,
            "author_timezone": 0,
        }

>       self._shas.append(r.do_commit(b"empty commit", **commit_kwargs))
E       AttributeError: 'NoneType' object has no attribute 'do_commit'

tests/test_grafts.py:161: AttributeError
</pre>
</details>
<h3 id="test_graftspygraftsinrepoteststest_object_store_fail_invalid_parents">test_grafts.py::GraftsInRepoTests::test_object_store_fail_invalid_parents</h3>
<details><summary> <pre>test_grafts.py::GraftsInRepoTests::test_object_store_fail_invalid_parents</pre></summary><pre>
self = <tests.test_grafts.GraftsInRepoTests testMethod=test_object_store_fail_invalid_parents>

    def setUp(self):
        super().setUp()
        self._repo_dir = os.path.join(tempfile.mkdtemp())
        r = self._repo = Repo.init(self._repo_dir)
        self.addCleanup(shutil.rmtree, self._repo_dir)

        self._shas = []

        commit_kwargs = {
            "committer": b"Test Committer <test@nodomain.com>",
            "author": b"Test Author <test@nodomain.com>",
            "commit_timestamp": 12395,
            "commit_timezone": 0,
            "author_timestamp": 12395,
            "author_timezone": 0,
        }

>       self._shas.append(r.do_commit(b"empty commit", **commit_kwargs))
E       AttributeError: 'NoneType' object has no attribute 'do_commit'

tests/test_grafts.py:161: AttributeError
</pre>
</details>
<h3 id="test_graftspygraftsinrepoteststest_remove_graft">test_grafts.py::GraftsInRepoTests::test_remove_graft</h3>
<details><summary> <pre>test_grafts.py::GraftsInRepoTests::test_remove_graft</pre></summary><pre>
self = <tests.test_grafts.GraftsInRepoTests testMethod=test_remove_graft>

    def setUp(self):
        super().setUp()
        self._repo_dir = os.path.join(tempfile.mkdtemp())
        r = self._repo = Repo.init(self._repo_dir)
        self.addCleanup(shutil.rmtree, self._repo_dir)

        self._shas = []

        commit_kwargs = {
            "committer": b"Test Committer <test@nodomain.com>",
            "author": b"Test Author <test@nodomain.com>",
            "commit_timestamp": 12395,
            "commit_timezone": 0,
            "author_timestamp": 12395,
            "author_timezone": 0,
        }

>       self._shas.append(r.do_commit(b"empty commit", **commit_kwargs))
E       AttributeError: 'NoneType' object has no attribute 'do_commit'

tests/test_grafts.py:161: AttributeError
</pre>
</details>
<h3 id="test_graftspygraftsinmemoryrepoteststest_existing_parent_graft">test_grafts.py::GraftsInMemoryRepoTests::test_existing_parent_graft</h3>
<details><summary> <pre>test_grafts.py::GraftsInMemoryRepoTests::test_existing_parent_graft</pre></summary><pre>
self = <tests.test_grafts.GraftsInMemoryRepoTests testMethod=test_existing_parent_graft>

    def setUp(self):
        super().setUp()
>       r = self._repo = MemoryRepo()

tests/test_grafts.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1fca66b0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_graftspygraftsinmemoryrepoteststest_no_grafts">test_grafts.py::GraftsInMemoryRepoTests::test_no_grafts</h3>
<details><summary> <pre>test_grafts.py::GraftsInMemoryRepoTests::test_no_grafts</pre></summary><pre>
self = <tests.test_grafts.GraftsInMemoryRepoTests testMethod=test_no_grafts>

    def setUp(self):
        super().setUp()
>       r = self._repo = MemoryRepo()

tests/test_grafts.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1ee3eaa0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_graftspygraftsinmemoryrepoteststest_no_parents_graft">test_grafts.py::GraftsInMemoryRepoTests::test_no_parents_graft</h3>
<details><summary> <pre>test_grafts.py::GraftsInMemoryRepoTests::test_no_parents_graft</pre></summary><pre>
self = <tests.test_grafts.GraftsInMemoryRepoTests testMethod=test_no_parents_graft>

    def setUp(self):
        super().setUp()
>       r = self._repo = MemoryRepo()

tests/test_grafts.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1fb50790>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_graftspygraftsinmemoryrepoteststest_object_store_fail_invalid_parents">test_grafts.py::GraftsInMemoryRepoTests::test_object_store_fail_invalid_parents</h3>
<details><summary> <pre>test_grafts.py::GraftsInMemoryRepoTests::test_object_store_fail_invalid_parents</pre></summary><pre>
self = <tests.test_grafts.GraftsInMemoryRepoTests testMethod=test_object_store_fail_invalid_parents>

    def setUp(self):
        super().setUp()
>       r = self._repo = MemoryRepo()

tests/test_grafts.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1fb48310>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_graftspygraftsinmemoryrepoteststest_remove_graft">test_grafts.py::GraftsInMemoryRepoTests::test_remove_graft</h3>
<details><summary> <pre>test_grafts.py::GraftsInMemoryRepoTests::test_remove_graft</pre></summary><pre>
self = <tests.test_grafts.GraftsInMemoryRepoTests testMethod=test_remove_graft>

    def setUp(self):
        super().setUp()
>       r = self._repo = MemoryRepo()

tests/test_grafts.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1f79faf0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_graphpyfindmergebaseteststest_ancestor">test_graph.py::FindMergeBaseTests::test_ancestor</h3>
<details><summary> <pre>test_graph.py::FindMergeBaseTests::test_ancestor</pre></summary><pre>
self = <tests.test_graph.FindMergeBaseTests testMethod=test_ancestor>

    def test_ancestor(self):
        # ancestor
        graph = {
            "G": ["D", "F"],
            "F": ["E"],
            "D": ["C"],
            "C": ["B"],
            "E": ["B"],
            "B": ["A"],
            "A": [],
        }
>       self.assertEqual(self.run_test(graph, ["D", "C"]), {"C"})

tests/test_graph.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dag = {'A': [], 'B': ['A'], 'C': ['B'], 'D': ['C'], ...}, inputs = ['D', 'C']

    @staticmethod
    def run_test(dag, inputs):
        def lookup_parents(commit_id):
            return dag[commit_id]

        def lookup_stamp(commit_id):
            # any constant timestamp value here will work to force
            # this test to test the same behaviour as done previously
            return 100

        c1 = inputs[0]
        c2s = inputs[1:]
>       return set(_find_lcas(lookup_parents, c1, c2s, lookup_stamp))
E       TypeError: _find_lcas() takes 2 positional arguments but 4 were given

tests/test_graph.py:42: TypeError
</pre>
</details>
<h3 id="test_graphpyfindmergebaseteststest_another_crossover">test_graph.py::FindMergeBaseTests::test_another_crossover</h3>
<details><summary> <pre>test_graph.py::FindMergeBaseTests::test_another_crossover</pre></summary><pre>
self = <tests.test_graph.FindMergeBaseTests testMethod=test_another_crossover>

    def test_another_crossover(self):
        # Another cross over
        graph = {
            "G": ["D", "F"],
            "F": ["E", "C"],
            "D": ["C", "E"],
            "C": ["B"],
            "E": ["B"],
            "B": ["A"],
            "A": [],
        }
>       self.assertEqual(self.run_test(graph, ["D", "F"]), {"E", "C"})

tests/test_graph.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dag = {'A': [], 'B': ['A'], 'C': ['B'], 'D': ['C', 'E'], ...}
inputs = ['D', 'F']

    @staticmethod
    def run_test(dag, inputs):
        def lookup_parents(commit_id):
            return dag[commit_id]

        def lookup_stamp(commit_id):
            # any constant timestamp value here will work to force
            # this test to test the same behaviour as done previously
            return 100

        c1 = inputs[0]
        c2s = inputs[1:]
>       return set(_find_lcas(lookup_parents, c1, c2s, lookup_stamp))
E       TypeError: _find_lcas() takes 2 positional arguments but 4 were given

tests/test_graph.py:42: TypeError
</pre>
</details>
<h3 id="test_graphpyfindmergebaseteststest_direct_parent">test_graph.py::FindMergeBaseTests::test_direct_parent</h3>
<details><summary> <pre>test_graph.py::FindMergeBaseTests::test_direct_parent</pre></summary><pre>
self = <tests.test_graph.FindMergeBaseTests testMethod=test_direct_parent>

    def test_direct_parent(self):
        # parent
        graph = {
            "G": ["D", "F"],
            "F": ["E"],
            "D": ["C"],
            "C": ["B"],
            "E": ["B"],
            "B": ["A"],
            "A": [],
        }
>       self.assertEqual(self.run_test(graph, ["G", "D"]), {"D"})

tests/test_graph.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dag = {'A': [], 'B': ['A'], 'C': ['B'], 'D': ['C'], ...}, inputs = ['G', 'D']

    @staticmethod
    def run_test(dag, inputs):
        def lookup_parents(commit_id):
            return dag[commit_id]

        def lookup_stamp(commit_id):
            # any constant timestamp value here will work to force
            # this test to test the same behaviour as done previously
            return 100

        c1 = inputs[0]
        c2s = inputs[1:]
>       return set(_find_lcas(lookup_parents, c1, c2s, lookup_stamp))
E       TypeError: _find_lcas() takes 2 positional arguments but 4 were given

tests/test_graph.py:42: TypeError
</pre>
</details>
<h3 id="test_graphpyfindmergebaseteststest_multiple_lca">test_graph.py::FindMergeBaseTests::test_multiple_lca</h3>
<details><summary> <pre>test_graph.py::FindMergeBaseTests::test_multiple_lca</pre></summary><pre>
self = <tests.test_graph.FindMergeBaseTests testMethod=test_multiple_lca>

    def test_multiple_lca(self):
        # two lowest common ancestors
        graph = {
            "5": ["1", "2"],
            "4": ["3", "1"],
            "3": ["2"],
            "2": ["0"],
            "1": [],
            "0": [],
        }
>       self.assertEqual(self.run_test(graph, ["4", "5"]), {"1", "2"})

tests/test_graph.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dag = {'0': [], '1': [], '2': ['0'], '3': ['2'], ...}, inputs = ['4', '5']

    @staticmethod
    def run_test(dag, inputs):
        def lookup_parents(commit_id):
            return dag[commit_id]

        def lookup_stamp(commit_id):
            # any constant timestamp value here will work to force
            # this test to test the same behaviour as done previously
            return 100

        c1 = inputs[0]
        c2s = inputs[1:]
>       return set(_find_lcas(lookup_parents, c1, c2s, lookup_stamp))
E       TypeError: _find_lcas() takes 2 positional arguments but 4 were given

tests/test_graph.py:42: TypeError
</pre>
</details>
<h3 id="test_graphpyfindmergebaseteststest_no_common_ancestor">test_graph.py::FindMergeBaseTests::test_no_common_ancestor</h3>
<details><summary> <pre>test_graph.py::FindMergeBaseTests::test_no_common_ancestor</pre></summary><pre>
self = <tests.test_graph.FindMergeBaseTests testMethod=test_no_common_ancestor>

    def test_no_common_ancestor(self):
        # no common ancestor
        graph = {
            "4": ["2"],
            "3": ["1"],
            "2": [],
            "1": ["0"],
            "0": [],
        }
>       self.assertEqual(self.run_test(graph, ["4", "3"]), set())

tests/test_graph.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dag = {'0': [], '1': ['0'], '2': [], '3': ['1'], ...}, inputs = ['4', '3']

    @staticmethod
    def run_test(dag, inputs):
        def lookup_parents(commit_id):
            return dag[commit_id]

        def lookup_stamp(commit_id):
            # any constant timestamp value here will work to force
            # this test to test the same behaviour as done previously
            return 100

        c1 = inputs[0]
        c2s = inputs[1:]
>       return set(_find_lcas(lookup_parents, c1, c2s, lookup_stamp))
E       TypeError: _find_lcas() takes 2 positional arguments but 4 were given

tests/test_graph.py:42: TypeError
</pre>
</details>
<h3 id="test_graphpyfindmergebaseteststest_octopus">test_graph.py::FindMergeBaseTests::test_octopus</h3>
<details><summary> <pre>test_graph.py::FindMergeBaseTests::test_octopus</pre></summary><pre>
self = <tests.test_graph.FindMergeBaseTests testMethod=test_octopus>

    def test_octopus(self):
        # octopus algorithm test
        # test straight from git docs of A, B, and C
        # but this time use octopus to find lcas of A, B, and C simultaneously
        graph = {
            "C": ["C1"],
            "C1": ["C2"],
            "C2": ["C3"],
            "C3": ["C4"],
            "C4": ["2"],
            "B": ["B1"],
            "B1": ["B2"],
            "B2": ["B3"],
            "B3": ["1"],
            "A": ["A1"],
            "A1": ["A2"],
            "A2": ["A3"],
            "A3": ["1"],
            "1": ["2"],
            "2": [],
        }

        def lookup_parents(cid):
            return graph[cid]

        def lookup_stamp(commit_id):
            # any constant timestamp value here will work to force
            # this test to test the same behaviour as done previously
            return 100

        lcas = ["A"]
        others = ["B", "C"]
        for cmt in others:
            next_lcas = []
            for ca in lcas:
>               res = _find_lcas(lookup_parents, cmt, [ca], lookup_stamp)
E               TypeError: _find_lcas() takes 2 positional arguments but 4 were given

tests/test_graph.py:164: TypeError
</pre>
</details>
<h3 id="test_graphpyfindmergebaseteststest_three_way_merge_lca">test_graph.py::FindMergeBaseTests::test_three_way_merge_lca</h3>
<details><summary> <pre>test_graph.py::FindMergeBaseTests::test_three_way_merge_lca</pre></summary><pre>
self = <tests.test_graph.FindMergeBaseTests testMethod=test_three_way_merge_lca>

    def test_three_way_merge_lca(self):
        # three way merge commit straight from git docs
        graph = {
            "C": ["C1"],
            "C1": ["C2"],
            "C2": ["C3"],
            "C3": ["C4"],
            "C4": ["2"],
            "B": ["B1"],
            "B1": ["B2"],
            "B2": ["B3"],
            "B3": ["1"],
            "A": ["A1"],
            "A1": ["A2"],
            "A2": ["A3"],
            "A3": ["1"],
            "1": ["2"],
            "2": [],
        }
        # assumes a theoretical merge M exists that merges B and C first
        # which actually means find the first LCA from either of B OR C with A
>       self.assertEqual(self.run_test(graph, ["A", "B", "C"]), {"1"})

tests/test_graph.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dag = {'1': ['2'], '2': [], 'A': ['A1'], 'A1': ['A2'], ...}
inputs = ['A', 'B', 'C']

    @staticmethod
    def run_test(dag, inputs):
        def lookup_parents(commit_id):
            return dag[commit_id]

        def lookup_stamp(commit_id):
            # any constant timestamp value here will work to force
            # this test to test the same behaviour as done previously
            return 100

        c1 = inputs[0]
        c2s = inputs[1:]
>       return set(_find_lcas(lookup_parents, c1, c2s, lookup_stamp))
E       TypeError: _find_lcas() takes 2 positional arguments but 4 were given

tests/test_graph.py:42: TypeError
</pre>
</details>
<h3 id="test_graphpycanfastforwardteststest_diverged">test_graph.py::CanFastForwardTests::test_diverged</h3>
<details><summary> <pre>test_graph.py::CanFastForwardTests::test_diverged</pre></summary><pre>
self = <tests.test_graph.CanFastForwardTests testMethod=test_diverged>

    def test_diverged(self):
>       r = MemoryRepo()

tests/test_graph.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1facc850>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_graphpycanfastforwardteststest_ff">test_graph.py::CanFastForwardTests::test_ff</h3>
<details><summary> <pre>test_graph.py::CanFastForwardTests::test_ff</pre></summary><pre>
self = <tests.test_graph.CanFastForwardTests testMethod=test_ff>

    def test_ff(self):
>       r = MemoryRepo()

tests/test_graph.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1fd630a0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_graphpyworklisttesttest_worklist">test_graph.py::WorkListTest::test_WorkList</h3>
<details><summary> <pre>test_graph.py::WorkListTest::test_WorkList</pre></summary><pre>
self = <tests.test_graph.WorkListTest testMethod=test_WorkList>

    def test_WorkList(self):
        # tuples of (timestamp, value) are stored in a Priority MaxQueue
        # repeated use of get should return them in maxheap timestamp
        # order: largest time value (most recent in time) first then earlier/older
        wlst = WorkList()
>       wlst.add((100, "Test Value 1"))
E       AttributeError: 'WorkList' object has no attribute 'add'

tests/test_graph.py:201: AttributeError
</pre>
</details>
<h3 id="test_greenthreadspytestgreenthreadsmissingobjectfindertest_finder">test_greenthreads.py::TestGreenThreadsMissingObjectFinder::test_finder</h3>
<details><summary> <pre>test_greenthreads.py::TestGreenThreadsMissingObjectFinder::test_finder</pre></summary><pre>
self = <tests.test_greenthreads.TestGreenThreadsMissingObjectFinder testMethod=test_finder>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
        self.cmt_amount = 10
>       self.objs = init_store(self.store, self.cmt_amount)

tests/test_greenthreads.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_greenthreads.py:60: in init_store
    objs = create_commit(marker=("%d" % i).encode("ascii"))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

marker = b'0'

    def create_commit(marker=None):
        blob = Blob.from_string(b"The blob content " + marker)
        tree = Tree()
>       tree.add(b"thefile " + marker, 0o100644, blob.id)
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_greenthreads.py:46: AttributeError
</pre>
</details>
<h3 id="test_hookspyshellhookteststest_hook_commit_msg">test_hooks.py::ShellHookTests::test_hook_commit_msg</h3>
<details><summary> <pre>test_hooks.py::ShellHookTests::test_hook_commit_msg</pre></summary><pre>
self = <tests.test_hooks.ShellHookTests testMethod=test_hook_commit_msg>

        def test_hook_commit_msg(self):
            repo_dir = os.path.join(tempfile.mkdtemp())
            os.mkdir(os.path.join(repo_dir, "hooks"))
            self.addCleanup(shutil.rmtree, repo_dir)

            commit_msg_fail = """#!/bin/sh
    exit 1
    """

            commit_msg_success = """#!/bin/sh
    exit 0
    """

            commit_msg_cwd = (
                """#!/bin/sh
    if [ "$(pwd)" = '"""
                + repo_dir
                + "' ]; then exit 0; else exit 1; fi\n"
            )

            commit_msg = os.path.join(repo_dir, "hooks", "commit-msg")
            hook = CommitMsgShellHook(repo_dir)

            with open(commit_msg, "w") as f:
                f.write(commit_msg_fail)
            os.chmod(commit_msg, stat.S_IREAD | stat.S_IWRITE | stat.S_IEXEC)

>           self.assertRaises(errors.HookError, hook.execute, b"failed commit")
E           AssertionError: HookError not raised by execute

tests/test_hooks.py:119: AssertionError
</pre>
</details>
<h3 id="test_hookspyshellhookteststest_hook_post_commit">test_hooks.py::ShellHookTests::test_hook_post_commit</h3>
<details><summary> <pre>test_hooks.py::ShellHookTests::test_hook_post_commit</pre></summary><pre>
self = <tests.test_hooks.ShellHookTests testMethod=test_hook_post_commit>

        def test_hook_post_commit(self):
            (fd, path) = tempfile.mkstemp()
            os.close(fd)

            repo_dir = os.path.join(tempfile.mkdtemp())
            os.mkdir(os.path.join(repo_dir, "hooks"))
            self.addCleanup(shutil.rmtree, repo_dir)

            post_commit_success = (
                """#!/bin/sh
    rm """
                + path
                + "\n"
            )

            post_commit_fail = """#!/bin/sh
    exit 1
    """

            post_commit_cwd = (
                """#!/bin/sh
    if [ "$(pwd)" = '"""
                + repo_dir
                + "' ]; then exit 0; else exit 1; fi\n"
            )

            post_commit = os.path.join(repo_dir, "hooks", "post-commit")
            hook = PostCommitShellHook(repo_dir)

            with open(post_commit, "w") as f:
                f.write(post_commit_fail)
            os.chmod(post_commit, stat.S_IREAD | stat.S_IWRITE | stat.S_IEXEC)

>           self.assertRaises(errors.HookError, hook.execute)
E           AssertionError: HookError not raised by execute

tests/test_hooks.py:169: AssertionError
</pre>
</details>
<h3 id="test_hookspyshellhookteststest_hook_pre_commit">test_hooks.py::ShellHookTests::test_hook_pre_commit</h3>
<details><summary> <pre>test_hooks.py::ShellHookTests::test_hook_pre_commit</pre></summary><pre>
self = <tests.test_hooks.ShellHookTests testMethod=test_hook_pre_commit>

        def test_hook_pre_commit(self):
            repo_dir = os.path.join(tempfile.mkdtemp())
            os.mkdir(os.path.join(repo_dir, "hooks"))
            self.addCleanup(shutil.rmtree, repo_dir)

            pre_commit_fail = """#!/bin/sh
    exit 1
    """

            pre_commit_success = """#!/bin/sh
    exit 0
    """
            pre_commit_cwd = (
                """#!/bin/sh
    if [ "$(pwd)" != '"""
                + repo_dir
                + """' ]; then
        echo "Expected path '"""
                + repo_dir
                + """', got '$(pwd)'"
        exit 1
    fi

    exit 0
    """
            )

            pre_commit = os.path.join(repo_dir, "hooks", "pre-commit")
            hook = PreCommitShellHook(repo_dir, repo_dir)

            with open(pre_commit, "w") as f:
                f.write(pre_commit_fail)
            os.chmod(pre_commit, stat.S_IREAD | stat.S_IWRITE | stat.S_IEXEC)

>           self.assertRaises(errors.HookError, hook.execute)
E           AssertionError: HookError not raised by execute

tests/test_hooks.py:75: AssertionError
</pre>
</details>
<h3 id="test_ignorepytranslateteststest_translate">test_ignore.py::TranslateTests::test_translate</h3>
<details><summary> <pre>test_ignore.py::TranslateTests::test_translate</pre></summary><pre>
self = <tests.test_ignore.TranslateTests testMethod=test_translate>

    def test_translate(self):
        for pattern, regex in TRANSLATE_TESTS:
            if re.escape(b"/") == b"/":
                # Slash is no longer escaped in Python3.7, so undo the escaping
                # in the expected return value..
                regex = regex.replace(b"\\/", b"/")
>           self.assertEqual(
                regex,
                translate(pattern),
                f"orig pattern: {pattern!r}, regex: {translate(pattern)!r}, expected: {regex!r}",
            )
E           AssertionError: b'(?ms)(.*/)?[^/]*\\.c/?\\Z' != None : orig pattern: b'*.c', regex: None, expected: b'(?ms)(.*/)?[^/]*\\.c/?\\Z'

tests/test_ignore.py:98: AssertionError
</pre>
</details>
<h3 id="test_ignorepyreadignorepatternstest_read_file">test_ignore.py::ReadIgnorePatterns::test_read_file</h3>
<details><summary> <pre>test_ignore.py::ReadIgnorePatterns::test_read_file</pre></summary><pre>
self = <tests.test_ignore.ReadIgnorePatterns testMethod=test_read_file>

        def test_read_file(self):
            f = BytesIO(
                b"""
    # a comment
    \x20\x20
    # and an empty line:

    \\#not a comment
    !negative
    with trailing whitespace
    with escaped trailing whitespace\\
    """
            )
            self.assertEqual(
>               list(read_ignore_patterns(f)),
                [
                    b"\\#not a comment",
                    b"!negative",
                    b"with trailing whitespace",
                    b"with escaped trailing whitespace ",
                ],
            )
E           TypeError: 'NoneType' object is not iterable

tests/test_ignore.py:120: TypeError
</pre>
</details>
<h3 id="test_ignorepymatchpatternteststest_matches">test_ignore.py::MatchPatternTests::test_matches</h3>
<details><summary> <pre>test_ignore.py::MatchPatternTests::test_matches</pre></summary><pre>
self = <tests.test_ignore.MatchPatternTests testMethod=test_matches>

    def test_matches(self):
        for path, pattern in POSITIVE_MATCH_TESTS:
>           self.assertTrue(
                match_pattern(path, pattern),
                f"path: {path!r}, pattern: {pattern!r}",
            )
E           AssertionError: None is not true : path: b'foo.c', pattern: b'*.c'

tests/test_ignore.py:133: AssertionError
</pre>
</details>
<h3 id="test_ignorepyignorefilterteststest_excluded">test_ignore.py::IgnoreFilterTests::test_excluded</h3>
<details><summary> <pre>test_ignore.py::IgnoreFilterTests::test_excluded</pre></summary><pre>
self = <tests.test_ignore.IgnoreFilterTests testMethod=test_excluded>

    def test_excluded(self):
        filter = IgnoreFilter([b"a.c", b"b.c", b"!c.c"])
        self.assertFalse(filter.is_ignored(b"c.c"))
        self.assertIs(None, filter.is_ignored(b"d.c"))
>       self.assertEqual([Pattern(b"!c.c")], list(filter.find_matching(b"c.c")))

tests/test_ignore.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dulwich/ignore.py:60: in __init__
    self._re = re.compile(translate(pattern), flags)
/usr/lib/python3.10/re.py:251: in compile
    return _compile(pattern, flags)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

pattern = None, flags = 0

    def _compile(pattern, flags):
        # internal: compile pattern
        if isinstance(flags, RegexFlag):
            flags = flags.value
        try:
            return _cache[type(pattern), pattern, flags]
        except KeyError:
            pass
        if isinstance(pattern, Pattern):
            if flags:
                raise ValueError(
                    "cannot process flags argument with a compiled pattern")
            return pattern
        if not sre_compile.isstring(pattern):
>           raise TypeError("first argument must be string or compiled pattern")
E           TypeError: first argument must be string or compiled pattern

/usr/lib/python3.10/re.py:302: TypeError
</pre>
</details>
<h3 id="test_ignorepyignorefilterteststest_include_exclude_include">test_ignore.py::IgnoreFilterTests::test_include_exclude_include</h3>
<details><summary> <pre>test_ignore.py::IgnoreFilterTests::test_include_exclude_include</pre></summary><pre>
self = <tests.test_ignore.IgnoreFilterTests testMethod=test_include_exclude_include>

    def test_include_exclude_include(self):
        filter = IgnoreFilter([b"a.c", b"!a.c", b"a.c"])
>       self.assertTrue(filter.is_ignored(b"a.c"))
E       AssertionError: None is not true

tests/test_ignore.py:172: AssertionError
</pre>
</details>
<h3 id="test_ignorepyignorefilterteststest_included">test_ignore.py::IgnoreFilterTests::test_included</h3>
<details><summary> <pre>test_ignore.py::IgnoreFilterTests::test_included</pre></summary><pre>
self = <tests.test_ignore.IgnoreFilterTests testMethod=test_included>

    def test_included(self):
        filter = IgnoreFilter([b"a.c", b"b.c"])
>       self.assertTrue(filter.is_ignored(b"a.c"))
E       AssertionError: None is not true

tests/test_ignore.py:149: AssertionError
</pre>
</details>
<h3 id="test_ignorepyignorefilterteststest_included_ignorecase">test_ignore.py::IgnoreFilterTests::test_included_ignorecase</h3>
<details><summary> <pre>test_ignore.py::IgnoreFilterTests::test_included_ignorecase</pre></summary><pre>
self = <tests.test_ignore.IgnoreFilterTests testMethod=test_included_ignorecase>

    def test_included_ignorecase(self):
        filter = IgnoreFilter([b"a.c", b"b.c"], ignorecase=False)
>       self.assertTrue(filter.is_ignored(b"a.c"))
E       AssertionError: None is not true

tests/test_ignore.py:156: AssertionError
</pre>
</details>
<h3 id="test_ignorepyignorefilterteststest_manpage">test_ignore.py::IgnoreFilterTests::test_manpage</h3>
<details><summary> <pre>test_ignore.py::IgnoreFilterTests::test_manpage</pre></summary><pre>
self = <tests.test_ignore.IgnoreFilterTests testMethod=test_manpage>

    def test_manpage(self):
        # A specific example from the gitignore manpage
        filter = IgnoreFilter([b"/*", b"!/foo", b"/foo/*", b"!/foo/bar"])
>       self.assertTrue(filter.is_ignored(b"a.c"))
E       AssertionError: None is not true

tests/test_ignore.py:181: AssertionError
</pre>
</details>
<h3 id="test_ignorepyignorefilterteststest_regex_special">test_ignore.py::IgnoreFilterTests::test_regex_special</h3>
<details><summary> <pre>test_ignore.py::IgnoreFilterTests::test_regex_special</pre></summary><pre>
self = <tests.test_ignore.IgnoreFilterTests testMethod=test_regex_special>

    def test_regex_special(self):
        # See https://github.com/dulwich/dulwich/issues/930#issuecomment-1026166429
        filter = IgnoreFilter([b"/foo\\[bar\\]", b"/foo"])
>       self.assertTrue(filter.is_ignored("foo"))
E       AssertionError: None is not true

tests/test_ignore.py:191: AssertionError
</pre>
</details>
<h3 id="test_ignorepyignorefilterstackteststest_stack_first">test_ignore.py::IgnoreFilterStackTests::test_stack_first</h3>
<details><summary> <pre>test_ignore.py::IgnoreFilterStackTests::test_stack_first</pre></summary><pre>
self = <tests.test_ignore.IgnoreFilterStackTests testMethod=test_stack_first>

    def test_stack_first(self):
        filter1 = IgnoreFilter([b"[a].c", b"[b].c", b"![d].c"])
        filter2 = IgnoreFilter([b"[a].c", b"![b],c", b"[c].c", b"[d].c"])
        stack = IgnoreFilterStack([filter1, filter2])
>       self.assertIs(True, stack.is_ignored(b"a.c"))
E       AssertionError: True is not None

tests/test_ignore.py:200: AssertionError
</pre>
</details>
<h3 id="test_ignorepyignorefiltermanagerteststest_ignored_contents">test_ignore.py::IgnoreFilterManagerTests::test_ignored_contents</h3>
<details><summary> <pre>test_ignore.py::IgnoreFilterManagerTests::test_ignored_contents</pre></summary><pre>
self = <tests.test_ignore.IgnoreFilterManagerTests testMethod=test_ignored_contents>

    def test_ignored_contents(self):
        tmp_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, tmp_dir)
        repo = Repo.init(tmp_dir)
>       with open(os.path.join(repo.path, ".gitignore"), "wb") as f:
E       AttributeError: 'NoneType' object has no attribute 'path'

tests/test_ignore.py:272: AttributeError
</pre>
</details>
<h3 id="test_ignorepyignorefiltermanagerteststest_load_ignore">test_ignore.py::IgnoreFilterManagerTests::test_load_ignore</h3>
<details><summary> <pre>test_ignore.py::IgnoreFilterManagerTests::test_load_ignore</pre></summary><pre>
self = <tests.test_ignore.IgnoreFilterManagerTests testMethod=test_load_ignore>

    def test_load_ignore(self):
        tmp_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, tmp_dir)
        repo = Repo.init(tmp_dir)
>       with open(os.path.join(repo.path, ".gitignore"), "wb") as f:
E       AttributeError: 'NoneType' object has no attribute 'path'

tests/test_ignore.py:212: AttributeError
</pre>
</details>
<h3 id="test_ignorepyignorefiltermanagerteststest_load_ignore_ignorecase">test_ignore.py::IgnoreFilterManagerTests::test_load_ignore_ignorecase</h3>
<details><summary> <pre>test_ignore.py::IgnoreFilterManagerTests::test_load_ignore_ignorecase</pre></summary><pre>
self = <tests.test_ignore.IgnoreFilterManagerTests testMethod=test_load_ignore_ignorecase>

    def test_load_ignore_ignorecase(self):
        tmp_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, tmp_dir)
        repo = Repo.init(tmp_dir)
>       config = repo.get_config()
E       AttributeError: 'NoneType' object has no attribute 'get_config'

tests/test_ignore.py:258: AttributeError
</pre>
</details>
<h3 id="test_ignorepyignorefiltermanagerteststest_nested_gitignores">test_ignore.py::IgnoreFilterManagerTests::test_nested_gitignores</h3>
<details><summary> <pre>test_ignore.py::IgnoreFilterManagerTests::test_nested_gitignores</pre></summary><pre>
self = <tests.test_ignore.IgnoreFilterManagerTests testMethod=test_nested_gitignores>

    def test_nested_gitignores(self):
        tmp_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, tmp_dir)
        repo = Repo.init(tmp_dir)

>       with open(os.path.join(repo.path, ".gitignore"), "wb") as f:
E       AttributeError: 'NoneType' object has no attribute 'path'

tests/test_ignore.py:240: AttributeError
</pre>
</details>
<h3 id="test_indexpysimpleindextestcasetest_against_empty_tree">test_index.py::SimpleIndexTestCase::test_against_empty_tree</h3>
<details><summary> <pre>test_index.py::SimpleIndexTestCase::test_against_empty_tree</pre></summary><pre>
self = <tests.test_index.SimpleIndexTestCase testMethod=test_against_empty_tree>

    def test_against_empty_tree(self):
        i = self.get_simple_index("index")
>       changes = list(i.changes_from_tree(MemoryObjectStore(), None))
E       TypeError: 'NoneType' object is not iterable

tests/test_index.py:115: TypeError
</pre>
</details>
<h3 id="test_indexpysimpleindextestcasetest_empty">test_index.py::SimpleIndexTestCase::test_empty</h3>
<details><summary> <pre>test_index.py::SimpleIndexTestCase::test_empty</pre></summary><pre>
self = <tests.test_index.SimpleIndexTestCase testMethod=test_empty>

    def test_empty(self):
        i = self.get_simple_index("notanindex")
>       self.assertEqual(0, len(i))

tests/test_index.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Index('/testbed/tests/../testdata/indexes/notanindex')

    def __len__(self) -> int:
        """Number of entries in this index file."""
>       return len(self._byname)
E       AttributeError: 'Index' object has no attribute '_byname'

dulwich/index.py:198: AttributeError
</pre>
</details>
<h3 id="test_indexpysimpleindextestcasetest_getitem">test_index.py::SimpleIndexTestCase::test_getitem</h3>
<details><summary> <pre>test_index.py::SimpleIndexTestCase::test_getitem</pre></summary><pre>
self = <tests.test_index.SimpleIndexTestCase testMethod=test_getitem>

    def test_getitem(self):
        self.assertEqual(
            IndexEntry(
                (1230680220, 0),
                (1230680220, 0),
                2050,
                3761020,
                33188,
                1000,
                1000,
                0,
                b"e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            ),
>           self.get_simple_index("index")[b"bla"],
        )

tests/test_index.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Index('/testbed/tests/../testdata/indexes/index'), key = b'bla'

    def __getitem__(self, key: bytes) -> Union[IndexEntry, ConflictedIndexEntry]:
        """Retrieve entry by relative path and stage.

        Returns: Either a IndexEntry or a ConflictedIndexEntry
        Raises KeyError: if the entry does not exist
        """
>       return self._byname[key]
E       AttributeError: 'Index' object has no attribute '_byname'

dulwich/index.py:206: AttributeError
</pre>
</details>
<h3 id="test_indexpysimpleindextestcasetest_iter">test_index.py::SimpleIndexTestCase::test_iter</h3>
<details><summary> <pre>test_index.py::SimpleIndexTestCase::test_iter</pre></summary><pre>
self = <tests.test_index.SimpleIndexTestCase testMethod=test_iter>

    def test_iter(self):
>       self.assertEqual([b"bla"], list(self.get_simple_index("index")))

tests/test_index.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Index('/testbed/tests/../testdata/indexes/index')

    def __iter__(self) -> Iterator[bytes]:
        """Iterate over the paths and stages in this index."""
>       return iter(self._byname)
E       AttributeError: 'Index' object has no attribute '_byname'

dulwich/index.py:210: AttributeError
</pre>
</details>
<h3 id="test_indexpysimpleindextestcasetest_iterobjects">test_index.py::SimpleIndexTestCase::test_iterobjects</h3>
<details><summary> <pre>test_index.py::SimpleIndexTestCase::test_iterobjects</pre></summary><pre>
self = <tests.test_index.SimpleIndexTestCase testMethod=test_iterobjects>

    def test_iterobjects(self):
        self.assertEqual(
            [(b"bla", b"e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", 33188)],
>           list(self.get_simple_index("index").iterobjects()),
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_index.py:89: TypeError
</pre>
</details>
<h3 id="test_indexpysimpleindextestcasetest_len">test_index.py::SimpleIndexTestCase::test_len</h3>
<details><summary> <pre>test_index.py::SimpleIndexTestCase::test_len</pre></summary><pre>
self = <tests.test_index.SimpleIndexTestCase testMethod=test_len>

    def test_len(self):
>       self.assertEqual(1, len(self.get_simple_index("index")))

tests/test_index.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Index('/testbed/tests/../testdata/indexes/index')

    def __len__(self) -> int:
        """Number of entries in this index file."""
>       return len(self._byname)
E       AttributeError: 'Index' object has no attribute '_byname'

dulwich/index.py:198: AttributeError
</pre>
</details>
<h3 id="test_indexpysimpleindexwritertestcasetest_simple_write">test_index.py::SimpleIndexWriterTestCase::test_simple_write</h3>
<details><summary> <pre>test_index.py::SimpleIndexWriterTestCase::test_simple_write</pre></summary><pre>
self = <tests.test_index.SimpleIndexWriterTestCase testMethod=test_simple_write>

    def test_simple_write(self):
        entries = [
            (
                SerializedIndexEntry(
                    b"barbla",
                    (1230680220, 0),
                    (1230680220, 0),
                    2050,
                    3761020,
                    33188,
                    1000,
                    1000,
                    0,
                    b"e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
                    0,
                    0,
                )
            )
        ]
        filename = os.path.join(self.tempdir, "test-simple-write-index")
        with open(filename, "wb+") as x:
            write_index(x, entries)

        with open(filename, "rb") as x:
>           self.assertEqual(entries, list(read_index(x)))
E           TypeError: 'NoneType' object is not iterable

tests/test_index.py:155: TypeError
</pre>
</details>
<h3 id="test_indexpyreadindexdictteststest_simple_write">test_index.py::ReadIndexDictTests::test_simple_write</h3>
<details><summary> <pre>test_index.py::ReadIndexDictTests::test_simple_write</pre></summary><pre>
self = <tests.test_index.ReadIndexDictTests testMethod=test_simple_write>

    def test_simple_write(self):
        entries = {
            b"barbla": IndexEntry(
                (1230680220, 0),
                (1230680220, 0),
                2050,
                3761020,
                33188,
                1000,
                1000,
                0,
                b"e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            )
        }
        filename = os.path.join(self.tempdir, "test-simple-write-index")
        with open(filename, "wb+") as x:
            write_index_dict(x, entries)

        with open(filename, "rb") as x:
>           self.assertEqual(entries, read_index_dict(x))
E           AssertionError: {b'barbla': IndexEntry(ctime=(1230680220,[135 chars]91')} != None

tests/test_index.py:186: AssertionError
</pre>
</details>
<h3 id="test_indexpycommittreeteststest_nested">test_index.py::CommitTreeTests::test_nested</h3>
<details><summary> <pre>test_index.py::CommitTreeTests::test_nested</pre></summary><pre>
self = <tests.test_index.CommitTreeTests testMethod=test_nested>

    def test_nested(self):
        blob = Blob()
        blob.data = b"foo"
        self.store.add_object(blob)
        blobs = [(b"bla/bar", blob.id, stat.S_IFREG)]
        rootid = commit_tree(self.store, blobs)
>       self.assertEqual(rootid, b"d92b959b216ad0d044671981196781b3258fa537")
E       AssertionError: None != b'd92b959b216ad0d044671981196781b3258fa537'

tests/test_index.py:210: AssertionError
</pre>
</details>
<h3 id="test_indexpycommittreeteststest_single_blob">test_index.py::CommitTreeTests::test_single_blob</h3>
<details><summary> <pre>test_index.py::CommitTreeTests::test_single_blob</pre></summary><pre>
self = <tests.test_index.CommitTreeTests testMethod=test_single_blob>

    def test_single_blob(self):
        blob = Blob()
        blob.data = b"foo"
        self.store.add_object(blob)
        blobs = [(b"bla", blob.id, stat.S_IFREG)]
        rootid = commit_tree(self.store, blobs)
>       self.assertEqual(rootid, b"1a1e80437220f9312e855c37ac4398b68e5c1d50")
E       AssertionError: None != b'1a1e80437220f9312e855c37ac4398b68e5c1d50'

tests/test_index.py:200: AssertionError
</pre>
</details>
<h3 id="test_indexpycleanupmodeteststest_dir">test_index.py::CleanupModeTests::test_dir</h3>
<details><summary> <pre>test_index.py::CleanupModeTests::test_dir</pre></summary><pre>
self = <tests.test_index.CleanupModeTests testMethod=test_dir>

    def test_dir(self):
>       self.assertModeEqual(0o040000, cleanup_mode(0o40531))

tests/test_index.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_index.CleanupModeTests testMethod=test_dir>, expected = 16384
got = None

    def assertModeEqual(self, expected, got):
>       self.assertEqual(expected, got, f"{expected:o} != {got:o}")
E       TypeError: unsupported format string passed to NoneType.__format__

tests/test_index.py:220: TypeError
</pre>
</details>
<h3 id="test_indexpycleanupmodeteststest_executable">test_index.py::CleanupModeTests::test_executable</h3>
<details><summary> <pre>test_index.py::CleanupModeTests::test_executable</pre></summary><pre>
self = <tests.test_index.CleanupModeTests testMethod=test_executable>

    def test_executable(self):
>       self.assertModeEqual(0o100755, cleanup_mode(0o100711))

tests/test_index.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_index.CleanupModeTests testMethod=test_executable>
expected = 33261, got = None

    def assertModeEqual(self, expected, got):
>       self.assertEqual(expected, got, f"{expected:o} != {got:o}")
E       TypeError: unsupported format string passed to NoneType.__format__

tests/test_index.py:220: TypeError
</pre>
</details>
<h3 id="test_indexpycleanupmodeteststest_file">test_index.py::CleanupModeTests::test_file</h3>
<details><summary> <pre>test_index.py::CleanupModeTests::test_file</pre></summary><pre>
self = <tests.test_index.CleanupModeTests testMethod=test_file>

    def test_file(self):
>       self.assertModeEqual(0o100644, cleanup_mode(0o100000))

tests/test_index.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_index.CleanupModeTests testMethod=test_file>
expected = 33188, got = None

    def assertModeEqual(self, expected, got):
>       self.assertEqual(expected, got, f"{expected:o} != {got:o}")
E       TypeError: unsupported format string passed to NoneType.__format__

tests/test_index.py:220: TypeError
</pre>
</details>
<h3 id="test_indexpycleanupmodeteststest_submodule">test_index.py::CleanupModeTests::test_submodule</h3>
<details><summary> <pre>test_index.py::CleanupModeTests::test_submodule</pre></summary><pre>
self = <tests.test_index.CleanupModeTests testMethod=test_submodule>

    def test_submodule(self):
>       self.assertModeEqual(0o160000, cleanup_mode(0o160744))

tests/test_index.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_index.CleanupModeTests testMethod=test_submodule>
expected = 57344, got = None

    def assertModeEqual(self, expected, got):
>       self.assertEqual(expected, got, f"{expected:o} != {got:o}")
E       TypeError: unsupported format string passed to NoneType.__format__

tests/test_index.py:220: TypeError
</pre>
</details>
<h3 id="test_indexpycleanupmodeteststest_symlink">test_index.py::CleanupModeTests::test_symlink</h3>
<details><summary> <pre>test_index.py::CleanupModeTests::test_symlink</pre></summary><pre>
self = <tests.test_index.CleanupModeTests testMethod=test_symlink>

    def test_symlink(self):
>       self.assertModeEqual(0o120000, cleanup_mode(0o120711))

tests/test_index.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_index.CleanupModeTests testMethod=test_symlink>
expected = 40960, got = None

    def assertModeEqual(self, expected, got):
>       self.assertEqual(expected, got, f"{expected:o} != {got:o}")
E       TypeError: unsupported format string passed to NoneType.__format__

tests/test_index.py:220: TypeError
</pre>
</details>
<h3 id="test_indexpywritecachetimeteststest_write_float">test_index.py::WriteCacheTimeTests::test_write_float</h3>
<details><summary> <pre>test_index.py::WriteCacheTimeTests::test_write_float</pre></summary><pre>
self = <tests.test_index.WriteCacheTimeTests testMethod=test_write_float>

    def test_write_float(self):
        f = BytesIO()
        write_cache_time(f, 434343.000000021)
>       self.assertEqual(struct.pack(">LL", 434343, 21), f.getvalue())
E       AssertionError: b'\x00\x06\xa0\xa7\x00\x00\x00\x15' != b''

tests/test_index.py:257: AssertionError
</pre>
</details>
<h3 id="test_indexpywritecachetimeteststest_write_int">test_index.py::WriteCacheTimeTests::test_write_int</h3>
<details><summary> <pre>test_index.py::WriteCacheTimeTests::test_write_int</pre></summary><pre>
self = <tests.test_index.WriteCacheTimeTests testMethod=test_write_int>

    def test_write_int(self):
        f = BytesIO()
        write_cache_time(f, 434343)
>       self.assertEqual(struct.pack(">LL", 434343, 0), f.getvalue())
E       AssertionError: b'\x00\x06\xa0\xa7\x00\x00\x00\x00' != b''

tests/test_index.py:247: AssertionError
</pre>
</details>
<h3 id="test_indexpywritecachetimeteststest_write_string">test_index.py::WriteCacheTimeTests::test_write_string</h3>
<details><summary> <pre>test_index.py::WriteCacheTimeTests::test_write_string</pre></summary><pre>
self = <tests.test_index.WriteCacheTimeTests testMethod=test_write_string>

    def test_write_string(self):
        f = BytesIO()
>       self.assertRaises(TypeError, write_cache_time, f, "foo")
E       AssertionError: TypeError not raised by write_cache_time

tests/test_index.py:242: AssertionError
</pre>
</details>
<h3 id="test_indexpywritecachetimeteststest_write_tuple">test_index.py::WriteCacheTimeTests::test_write_tuple</h3>
<details><summary> <pre>test_index.py::WriteCacheTimeTests::test_write_tuple</pre></summary><pre>
self = <tests.test_index.WriteCacheTimeTests testMethod=test_write_tuple>

    def test_write_tuple(self):
        f = BytesIO()
        write_cache_time(f, (434343, 21))
>       self.assertEqual(struct.pack(">LL", 434343, 21), f.getvalue())
E       AssertionError: b'\x00\x06\xa0\xa7\x00\x00\x00\x15' != b''

tests/test_index.py:252: AssertionError
</pre>
</details>
<h3 id="test_indexpyindexentryfromstatteststest_override_mode">test_index.py::IndexEntryFromStatTests::test_override_mode</h3>
<details><summary> <pre>test_index.py::IndexEntryFromStatTests::test_override_mode</pre></summary><pre>
self = <tests.test_index.IndexEntryFromStatTests testMethod=test_override_mode>

    def test_override_mode(self):
        st = os.stat_result(
            (
                stat.S_IFREG + 0o644,
                131078,
                64769,
                154,
                1000,
                1000,
                12288,
                1323629595,
                1324180496,
                1324180496,
            )
        )
        entry = index_entry_from_stat(st, b"22" * 20, mode=stat.S_IFREG + 0o755)
>       self.assertEqual(
            entry,
            IndexEntry(
                1324180496,
                1324180496,
                64769,
                131078,
                33261,
                1000,
                1000,
                12288,
                b"2222222222222222222222222222222222222222",
            ),
        )
E       AssertionError: None != IndexEntry(ctime=1324180496, mtime=132418[116 chars]222')

tests/test_index.py:308: AssertionError
</pre>
</details>
<h3 id="test_indexpyindexentryfromstatteststest_simple">test_index.py::IndexEntryFromStatTests::test_simple</h3>
<details><summary> <pre>test_index.py::IndexEntryFromStatTests::test_simple</pre></summary><pre>
self = <tests.test_index.IndexEntryFromStatTests testMethod=test_simple>

    def test_simple(self):
        st = os.stat_result(
            (
                16877,
                131078,
                64769,
                154,
                1000,
                1000,
                12288,
                1323629595,
                1324180496,
                1324180496,
            )
        )
        entry = index_entry_from_stat(st, b"22" * 20)
>       self.assertEqual(
            entry,
            IndexEntry(
                1324180496,
                1324180496,
                64769,
                131078,
                16384,
                1000,
                1000,
                12288,
                b"2222222222222222222222222222222222222222",
            ),
        )
E       AssertionError: None != IndexEntry(ctime=1324180496, mtime=132418[116 chars]222')

tests/test_index.py:277: AssertionError
</pre>
</details>
<h3 id="test_indexpybuildindexteststest_empty">test_index.py::BuildIndexTests::test_empty</h3>
<details><summary> <pre>test_index.py::BuildIndexTests::test_empty</pre></summary><pre>
self = <tests.test_index.BuildIndexTests testMethod=test_empty>

    def test_empty(self):
        repo_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, repo_dir)
>       with Repo.init(repo_dir) as repo:
E       AttributeError: __enter__

tests/test_index.py:340: AttributeError
</pre>
</details>
<h3 id="test_indexpybuildindexteststest_git_dir">test_index.py::BuildIndexTests::test_git_dir</h3>
<details><summary> <pre>test_index.py::BuildIndexTests::test_git_dir</pre></summary><pre>
self = <tests.test_index.BuildIndexTests testMethod=test_git_dir>

    def test_git_dir(self):
        repo_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, repo_dir)
>       with Repo.init(repo_dir) as repo:
E       AttributeError: __enter__

tests/test_index.py:358: AttributeError
</pre>
</details>
<h3 id="test_indexpybuildindexteststest_git_submodule">test_index.py::BuildIndexTests::test_git_submodule</h3>
<details><summary> <pre>test_index.py::BuildIndexTests::test_git_submodule</pre></summary><pre>
self = <tests.test_index.BuildIndexTests testMethod=test_git_submodule>

    def test_git_submodule(self):
        repo_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, repo_dir)
>       with Repo.init(repo_dir) as repo:
E       AttributeError: __enter__

tests/test_index.py:563: AttributeError
</pre>
</details>
<h3 id="test_indexpybuildindexteststest_git_submodule_exists">test_index.py::BuildIndexTests::test_git_submodule_exists</h3>
<details><summary> <pre>test_index.py::BuildIndexTests::test_git_submodule_exists</pre></summary><pre>
self = <tests.test_index.BuildIndexTests testMethod=test_git_submodule_exists>

    def test_git_submodule_exists(self):
        repo_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, repo_dir)
>       with Repo.init(repo_dir) as repo:
E       AttributeError: __enter__

tests/test_index.py:603: AttributeError
</pre>
</details>
<h3 id="test_indexpybuildindexteststest_no_decode_encode">test_index.py::BuildIndexTests::test_no_decode_encode</h3>
<details><summary> <pre>test_index.py::BuildIndexTests::test_no_decode_encode</pre></summary><pre>
self = <tests.test_index.BuildIndexTests testMethod=test_no_decode_encode>

    def test_no_decode_encode(self):
        repo_dir = tempfile.mkdtemp()
        repo_dir_bytes = os.fsencode(repo_dir)
        self.addCleanup(shutil.rmtree, repo_dir)
>       with Repo.init(repo_dir) as repo:
E       AttributeError: __enter__

tests/test_index.py:522: AttributeError
</pre>
</details>
<h3 id="test_indexpybuildindexteststest_nonempty">test_index.py::BuildIndexTests::test_nonempty</h3>
<details><summary> <pre>test_index.py::BuildIndexTests::test_nonempty</pre></summary><pre>
self = <tests.test_index.BuildIndexTests testMethod=test_nonempty>

    def test_nonempty(self):
        repo_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, repo_dir)
>       with Repo.init(repo_dir) as repo:
E       AttributeError: __enter__

tests/test_index.py:392: AttributeError
</pre>
</details>
<h3 id="test_indexpybuildindexteststest_norewrite">test_index.py::BuildIndexTests::test_norewrite</h3>
<details><summary> <pre>test_index.py::BuildIndexTests::test_norewrite</pre></summary><pre>
self = <tests.test_index.BuildIndexTests testMethod=test_norewrite>

    @skipIf(not getattr(os, "sync", None), "Requires sync support")
    def test_norewrite(self):
        repo_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, repo_dir)
>       with Repo.init(repo_dir) as repo:
E       AttributeError: __enter__

tests/test_index.py:447: AttributeError
</pre>
</details>
<h3 id="test_indexpybuildindexteststest_symlink">test_index.py::BuildIndexTests::test_symlink</h3>
<details><summary> <pre>test_index.py::BuildIndexTests::test_symlink</pre></summary><pre>
self = <tests.test_index.BuildIndexTests testMethod=test_symlink>

    @skipIf(not can_symlink(), "Requires symlink support")
    def test_symlink(self):
        repo_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, repo_dir)
>       with Repo.init(repo_dir) as repo:
E       AttributeError: __enter__

tests/test_index.py:489: AttributeError
</pre>
</details>
<h3 id="test_indexpygetunstagedchangesteststest_get_unstaged_changes">test_index.py::GetUnstagedChangesTests::test_get_unstaged_changes</h3>
<details><summary> <pre>test_index.py::GetUnstagedChangesTests::test_get_unstaged_changes</pre></summary><pre>
self = <tests.test_index.GetUnstagedChangesTests testMethod=test_get_unstaged_changes>

    def test_get_unstaged_changes(self):
        """Unit test for get_unstaged_changes."""
        repo_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, repo_dir)
>       with Repo.init(repo_dir) as repo:
E       AttributeError: __enter__

tests/test_index.py:647: AttributeError
</pre>
</details>
<h3 id="test_indexpygetunstagedchangesteststest_get_unstaged_changes_removed_replaced_by_directory">test_index.py::GetUnstagedChangesTests::test_get_unstaged_changes_removed_replaced_by_directory</h3>
<details><summary> <pre>test_index.py::GetUnstagedChangesTests::test_get_unstaged_changes_removed_replaced_by_directory</pre></summary><pre>
self = <tests.test_index.GetUnstagedChangesTests testMethod=test_get_unstaged_changes_removed_replaced_by_directory>

    def test_get_unstaged_changes_removed_replaced_by_directory(self):
        """Unit test for get_unstaged_changes."""
        repo_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, repo_dir)
>       with Repo.init(repo_dir) as repo:
E       AttributeError: __enter__

tests/test_index.py:701: AttributeError
</pre>
</details>
<h3 id="test_indexpygetunstagedchangesteststest_get_unstaged_changes_removed_replaced_by_link">test_index.py::GetUnstagedChangesTests::test_get_unstaged_changes_removed_replaced_by_link</h3>
<details><summary> <pre>test_index.py::GetUnstagedChangesTests::test_get_unstaged_changes_removed_replaced_by_link</pre></summary><pre>
self = <tests.test_index.GetUnstagedChangesTests testMethod=test_get_unstaged_changes_removed_replaced_by_link>

    @skipIf(not can_symlink(), "Requires symlink support")
    def test_get_unstaged_changes_removed_replaced_by_link(self):
        """Unit test for get_unstaged_changes."""
        repo_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, repo_dir)
>       with Repo.init(repo_dir) as repo:
E       AttributeError: __enter__

tests/test_index.py:726: AttributeError
</pre>
</details>
<h3 id="test_indexpygetunstagedchangesteststest_get_unstaged_deleted_changes">test_index.py::GetUnstagedChangesTests::test_get_unstaged_deleted_changes</h3>
<details><summary> <pre>test_index.py::GetUnstagedChangesTests::test_get_unstaged_deleted_changes</pre></summary><pre>
self = <tests.test_index.GetUnstagedChangesTests testMethod=test_get_unstaged_deleted_changes>

    def test_get_unstaged_deleted_changes(self):
        """Unit test for get_unstaged_changes."""
        repo_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, repo_dir)
>       with Repo.init(repo_dir) as repo:
E       AttributeError: __enter__

tests/test_index.py:678: AttributeError
</pre>
</details>
<h3 id="test_indexpytestvalidatepathelementtest_default">test_index.py::TestValidatePathElement::test_default</h3>
<details><summary> <pre>test_index.py::TestValidatePathElement::test_default</pre></summary><pre>
self = <tests.test_index.TestValidatePathElement testMethod=test_default>

    def test_default(self):
        self.assertTrue(validate_path_element_default(b"bla"))
        self.assertTrue(validate_path_element_default(b".bla"))
        self.assertFalse(validate_path_element_default(b".git"))
>       self.assertFalse(validate_path_element_default(b".giT"))
E       AssertionError: True is not false

tests/test_index.py:752: AssertionError
</pre>
</details>
<h3 id="test_indexpytestvalidatepathelementtest_ntfs">test_index.py::TestValidatePathElement::test_ntfs</h3>
<details><summary> <pre>test_index.py::TestValidatePathElement::test_ntfs</pre></summary><pre>
self = <tests.test_index.TestValidatePathElement testMethod=test_ntfs>

    def test_ntfs(self):
        self.assertTrue(validate_path_element_ntfs(b"bla"))
        self.assertTrue(validate_path_element_ntfs(b".bla"))
        self.assertFalse(validate_path_element_ntfs(b".git"))
>       self.assertFalse(validate_path_element_ntfs(b".giT"))
E       AssertionError: True is not false

tests/test_index.py:760: AssertionError
</pre>
</details>
<h3 id="test_indexpytesttreefspathconversiontest_fs_to_tree_path_bytes">test_index.py::TestTreeFSPathConversion::test_fs_to_tree_path_bytes</h3>
<details><summary> <pre>test_index.py::TestTreeFSPathConversion::test_fs_to_tree_path_bytes</pre></summary><pre>
self = <tests.test_index.TestTreeFSPathConversion testMethod=test_fs_to_tree_path_bytes>

    def test_fs_to_tree_path_bytes(self):
        fs_path = os.path.join(os.fsencode(os.path.join("délwíçh", "foo")))
        tree_path = _fs_to_tree_path(fs_path)
>       self.assertEqual(tree_path, "délwíçh/foo".encode())
E       AssertionError: None != b'd\xc3\xa9lw\xc3\xad\xc3\xa7h/foo'

tests/test_index.py:782: AssertionError
</pre>
</details>
<h3 id="test_indexpytesttreefspathconversiontest_fs_to_tree_path_str">test_index.py::TestTreeFSPathConversion::test_fs_to_tree_path_str</h3>
<details><summary> <pre>test_index.py::TestTreeFSPathConversion::test_fs_to_tree_path_str</pre></summary><pre>
self = <tests.test_index.TestTreeFSPathConversion testMethod=test_fs_to_tree_path_str>

    def test_fs_to_tree_path_str(self):
        fs_path = os.path.join(os.path.join("délwíçh", "foo"))
        tree_path = _fs_to_tree_path(fs_path)
>       self.assertEqual(tree_path, "délwíçh/foo".encode())
E       AssertionError: None != b'd\xc3\xa9lw\xc3\xad\xc3\xa7h/foo'

tests/test_index.py:777: AssertionError
</pre>
</details>
<h3 id="test_indexpytesttreefspathconversiontest_tree_to_fs_path">test_index.py::TestTreeFSPathConversion::test_tree_to_fs_path</h3>
<details><summary> <pre>test_index.py::TestTreeFSPathConversion::test_tree_to_fs_path</pre></summary><pre>
self = <tests.test_index.TestTreeFSPathConversion testMethod=test_tree_to_fs_path>

    def test_tree_to_fs_path(self):
        tree_path = "délwíçh/foo".encode()
        fs_path = _tree_to_fs_path(b"/prefix/path", tree_path)
>       self.assertEqual(
            fs_path,
            os.fsencode(os.path.join("/prefix/path", "délwíçh", "foo")),
        )
E       AssertionError: None != b'/prefix/path/d\xc3\xa9lw\xc3\xad\xc3\xa7h/foo'

tests/test_index.py:769: AssertionError
</pre>
</details>
<h3 id="test_lfspylfsteststest_create">test_lfs.py::LFSTests::test_create</h3>
<details><summary> <pre>test_lfs.py::LFSTests::test_create</pre></summary><pre>
self = <tests.test_lfs.LFSTests testMethod=test_create>

    def setUp(self):
        super().setUp()
        self.test_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.test_dir)
>       self.lfs = LFSStore.create(self.test_dir)
E       AttributeError: type object 'LFSStore' has no attribute 'create'

tests/test_lfs.py:36: AttributeError
</pre>
</details>
<h3 id="test_lfspylfsteststest_missing">test_lfs.py::LFSTests::test_missing</h3>
<details><summary> <pre>test_lfs.py::LFSTests::test_missing</pre></summary><pre>
self = <tests.test_lfs.LFSTests testMethod=test_missing>

    def setUp(self):
        super().setUp()
        self.test_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.test_dir)
>       self.lfs = LFSStore.create(self.test_dir)
E       AttributeError: type object 'LFSStore' has no attribute 'create'

tests/test_lfs.py:36: AttributeError
</pre>
</details>
<h3 id="test_line_endingpylineendingconversiontest_convert_crlf_to_lf">test_line_ending.py::LineEndingConversion::test_convert_crlf_to_lf</h3>
<details><summary> <pre>test_line_ending.py::LineEndingConversion::test_convert_crlf_to_lf</pre></summary><pre>
self = <tests.test_line_ending.LineEndingConversion testMethod=test_convert_crlf_to_lf>

    def test_convert_crlf_to_lf(self):
>       self.assertEqual(convert_crlf_to_lf(b"line1\r\nline2"), b"line1\nline2")
E       AssertionError: None != b'line1\nline2'

tests/test_line_ending.py:42: AssertionError
</pre>
</details>
<h3 id="test_line_endingpylineendingconversiontest_convert_crlf_to_lf_mixed">test_line_ending.py::LineEndingConversion::test_convert_crlf_to_lf_mixed</h3>
<details><summary> <pre>test_line_ending.py::LineEndingConversion::test_convert_crlf_to_lf_mixed</pre></summary><pre>
self = <tests.test_line_ending.LineEndingConversion testMethod=test_convert_crlf_to_lf_mixed>

    def test_convert_crlf_to_lf_mixed(self):
>       self.assertEqual(convert_crlf_to_lf(b"line1\r\n\nline2"), b"line1\n\nline2")
E       AssertionError: None != b'line1\n\nline2'

tests/test_line_ending.py:45: AssertionError
</pre>
</details>
<h3 id="test_line_endingpylineendingconversiontest_convert_crlf_to_lf_no_op">test_line_ending.py::LineEndingConversion::test_convert_crlf_to_lf_no_op</h3>
<details><summary> <pre>test_line_ending.py::LineEndingConversion::test_convert_crlf_to_lf_no_op</pre></summary><pre>
self = <tests.test_line_ending.LineEndingConversion testMethod=test_convert_crlf_to_lf_no_op>

    def test_convert_crlf_to_lf_no_op(self):
>       self.assertEqual(convert_crlf_to_lf(b"foobar"), b"foobar")
E       AssertionError: None != b'foobar'

tests/test_line_ending.py:39: AssertionError
</pre>
</details>
<h3 id="test_line_endingpylineendingconversiontest_convert_lf_to_crlf">test_line_ending.py::LineEndingConversion::test_convert_lf_to_crlf</h3>
<details><summary> <pre>test_line_ending.py::LineEndingConversion::test_convert_lf_to_crlf</pre></summary><pre>
self = <tests.test_line_ending.LineEndingConversion testMethod=test_convert_lf_to_crlf>

    def test_convert_lf_to_crlf(self):
>       self.assertEqual(convert_lf_to_crlf(b"line1\nline2"), b"line1\r\nline2")
E       AssertionError: None != b'line1\r\nline2'

tests/test_line_ending.py:51: AssertionError
</pre>
</details>
<h3 id="test_line_endingpylineendingconversiontest_convert_lf_to_crlf_mixed">test_line_ending.py::LineEndingConversion::test_convert_lf_to_crlf_mixed</h3>
<details><summary> <pre>test_line_ending.py::LineEndingConversion::test_convert_lf_to_crlf_mixed</pre></summary><pre>
self = <tests.test_line_ending.LineEndingConversion testMethod=test_convert_lf_to_crlf_mixed>

    def test_convert_lf_to_crlf_mixed(self):
>       self.assertEqual(convert_lf_to_crlf(b"line1\r\n\nline2"), b"line1\r\n\r\nline2")
E       AssertionError: None != b'line1\r\n\r\nline2'

tests/test_line_ending.py:54: AssertionError
</pre>
</details>
<h3 id="test_line_endingpylineendingconversiontest_convert_lf_to_crlf_no_op">test_line_ending.py::LineEndingConversion::test_convert_lf_to_crlf_no_op</h3>
<details><summary> <pre>test_line_ending.py::LineEndingConversion::test_convert_lf_to_crlf_no_op</pre></summary><pre>
self = <tests.test_line_ending.LineEndingConversion testMethod=test_convert_lf_to_crlf_no_op>

    def test_convert_lf_to_crlf_no_op(self):
>       self.assertEqual(convert_lf_to_crlf(b"foobar"), b"foobar")
E       AssertionError: None != b'foobar'

tests/test_line_ending.py:48: AssertionError
</pre>
</details>
<h3 id="test_line_endingpygetlineendingautocrlffilterstest_get_checkin_filter_autocrlf_input">test_line_ending.py::GetLineEndingAutocrlfFilters::test_get_checkin_filter_autocrlf_input</h3>
<details><summary> <pre>test_line_ending.py::GetLineEndingAutocrlfFilters::test_get_checkin_filter_autocrlf_input</pre></summary><pre>
self = <tests.test_line_ending.GetLineEndingAutocrlfFilters testMethod=test_get_checkin_filter_autocrlf_input>

    def test_get_checkin_filter_autocrlf_input(self):
        checkin_filter = get_checkin_filter_autocrlf(b"input")

>       self.assertEqual(checkin_filter, convert_crlf_to_lf)
E       AssertionError: None != <function convert_crlf_to_lf at 0x7eec209ebd90>

tests/test_line_ending.py:71: AssertionError
</pre>
</details>
<h3 id="test_line_endingpygetlineendingautocrlffilterstest_get_checkin_filter_autocrlf_true">test_line_ending.py::GetLineEndingAutocrlfFilters::test_get_checkin_filter_autocrlf_true</h3>
<details><summary> <pre>test_line_ending.py::GetLineEndingAutocrlfFilters::test_get_checkin_filter_autocrlf_true</pre></summary><pre>
self = <tests.test_line_ending.GetLineEndingAutocrlfFilters testMethod=test_get_checkin_filter_autocrlf_true>

    def test_get_checkin_filter_autocrlf_true(self):
        checkin_filter = get_checkin_filter_autocrlf(b"true")

>       self.assertEqual(checkin_filter, convert_crlf_to_lf)
E       AssertionError: None != <function convert_crlf_to_lf at 0x7eec209ebd90>

tests/test_line_ending.py:66: AssertionError
</pre>
</details>
<h3 id="test_line_endingpygetlineendingautocrlffilterstest_get_checkout_filter_autocrlf_true">test_line_ending.py::GetLineEndingAutocrlfFilters::test_get_checkout_filter_autocrlf_true</h3>
<details><summary> <pre>test_line_ending.py::GetLineEndingAutocrlfFilters::test_get_checkout_filter_autocrlf_true</pre></summary><pre>
self = <tests.test_line_ending.GetLineEndingAutocrlfFilters testMethod=test_get_checkout_filter_autocrlf_true>

    def test_get_checkout_filter_autocrlf_true(self):
        checkout_filter = get_checkout_filter_autocrlf(b"true")

>       self.assertEqual(checkout_filter, convert_lf_to_crlf)
E       AssertionError: None != <function convert_lf_to_crlf at 0x7eec20a37d90>

tests/test_line_ending.py:81: AssertionError
</pre>
</details>
<h3 id="test_line_endingpynormalizeblobtestcasetest_normalize_to_crlf">test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_crlf</h3>
<details><summary> <pre>test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_crlf</pre></summary><pre>
self = <tests.test_line_ending.NormalizeBlobTestCase testMethod=test_normalize_to_crlf>

    def test_normalize_to_crlf(self):
        base_content = b"line1\nline2"
        base_sha = "f8be7bb828880727816015d21abcbc37d033f233"

        base_blob = Blob()
        base_blob.set_raw_string(base_content)

>       self.assertEqual(base_blob.as_raw_chunks(), [base_content])
E       AssertionError: None != [b'line1\nline2']

tests/test_line_ending.py:168: AssertionError
</pre>
</details>
<h3 id="test_line_endingpynormalizeblobtestcasetest_normalize_to_crlf_binary">test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_crlf_binary</h3>
<details><summary> <pre>test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_crlf_binary</pre></summary><pre>
self = <tests.test_line_ending.NormalizeBlobTestCase testMethod=test_normalize_to_crlf_binary>

    def test_normalize_to_crlf_binary(self):
        base_content = b"line1\r\nline2\0"
        base_sha = "b44504193b765f7cd79673812de8afb55b372ab2"

        base_blob = Blob()
        base_blob.set_raw_string(base_content)

>       self.assertEqual(base_blob.as_raw_chunks(), [base_content])
E       AssertionError: None != [b'line1\r\nline2\x00']

tests/test_line_ending.py:188: AssertionError
</pre>
</details>
<h3 id="test_line_endingpynormalizeblobtestcasetest_normalize_to_crlf_no_op">test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_crlf_no_op</h3>
<details><summary> <pre>test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_crlf_no_op</pre></summary><pre>
self = <tests.test_line_ending.NormalizeBlobTestCase testMethod=test_normalize_to_crlf_no_op>

    def test_normalize_to_crlf_no_op(self):
        base_content = b"line1\r\nline2"
        base_sha = "3a1bd7a52799fe5cf6411f1d35f4c10bacb1db96"

        base_blob = Blob()
        base_blob.set_raw_string(base_content)

>       self.assertEqual(base_blob.as_raw_chunks(), [base_content])
E       AssertionError: None != [b'line1\r\nline2']

tests/test_line_ending.py:151: AssertionError
</pre>
</details>
<h3 id="test_line_endingpynormalizeblobtestcasetest_normalize_to_lf">test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_lf</h3>
<details><summary> <pre>test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_lf</pre></summary><pre>
self = <tests.test_line_ending.NormalizeBlobTestCase testMethod=test_normalize_to_lf>

    def test_normalize_to_lf(self):
        base_content = b"line1\r\nline2"
        base_sha = "3a1bd7a52799fe5cf6411f1d35f4c10bacb1db96"

        base_blob = Blob()
        base_blob.set_raw_string(base_content)

>       self.assertEqual(base_blob.as_raw_chunks(), [base_content])
E       AssertionError: None != [b'line1\r\nline2']

tests/test_line_ending.py:114: AssertionError
</pre>
</details>
<h3 id="test_line_endingpynormalizeblobtestcasetest_normalize_to_lf_binary">test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_lf_binary</h3>
<details><summary> <pre>test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_lf_binary</pre></summary><pre>
self = <tests.test_line_ending.NormalizeBlobTestCase testMethod=test_normalize_to_lf_binary>

    def test_normalize_to_lf_binary(self):
        base_content = b"line1\r\nline2\0"
        base_sha = "b44504193b765f7cd79673812de8afb55b372ab2"

        base_blob = Blob()
        base_blob.set_raw_string(base_content)

>       self.assertEqual(base_blob.as_raw_chunks(), [base_content])
E       AssertionError: None != [b'line1\r\nline2\x00']

tests/test_line_ending.py:134: AssertionError
</pre>
</details>
<h3 id="test_line_endingpynormalizeblobtestcasetest_normalize_to_lf_no_op">test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_lf_no_op</h3>
<details><summary> <pre>test_line_ending.py::NormalizeBlobTestCase::test_normalize_to_lf_no_op</pre></summary><pre>
self = <tests.test_line_ending.NormalizeBlobTestCase testMethod=test_normalize_to_lf_no_op>

    def test_normalize_to_lf_no_op(self):
        base_content = b"line1\nline2"
        base_sha = "f8be7bb828880727816015d21abcbc37d033f233"

        base_blob = Blob()
        base_blob.set_raw_string(base_content)

>       self.assertEqual(base_blob.as_raw_chunks(), [base_content])
E       AssertionError: None != [b'line1\nline2']

tests/test_line_ending.py:97: AssertionError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_add__null_key">test_lru_cache.py::TestLRUCache::test_add__null_key</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_add__null_key</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_add__null_key>

    def test_add__null_key(self):
>       cache = lru_cache.LRUCache(max_cache=10)

tests/test_lru_cache.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1fd63fd0>, max_cache = 10
after_cleanup_count = None

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_after_cleanup_larger_than_max">test_lru_cache.py::TestLRUCache::test_after_cleanup_larger_than_max</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_after_cleanup_larger_than_max</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_after_cleanup_larger_than_max>

    def test_after_cleanup_larger_than_max(self):
>       cache = lru_cache.LRUCache(max_cache=5, after_cleanup_count=10)

tests/test_lru_cache.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1f9e0d00>, max_cache = 5
after_cleanup_count = 10

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_after_cleanup_none">test_lru_cache.py::TestLRUCache::test_after_cleanup_none</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_after_cleanup_none</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_after_cleanup_none>

    def test_after_cleanup_none(self):
>       cache = lru_cache.LRUCache(max_cache=5, after_cleanup_count=None)

tests/test_lru_cache.py:190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1fb52620>, max_cache = 5
after_cleanup_count = None

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_by_usage">test_lru_cache.py::TestLRUCache::test_by_usage</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_by_usage</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_by_usage>

    def test_by_usage(self):
        """Accessing entries bumps them up in priority."""
>       cache = lru_cache.LRUCache(max_cache=2)

tests/test_lru_cache.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec20856170>, max_cache = 2
after_cleanup_count = None

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_cache_size">test_lru_cache.py::TestLRUCache::test_cache_size</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_cache_size</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_cache_size>

    def test_cache_size(self):
>       cache = lru_cache.LRUCache(max_cache=10)

tests/test_lru_cache.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1f9cba00>, max_cache = 10
after_cleanup_count = None

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_cleanup">test_lru_cache.py::TestLRUCache::test_cleanup</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_cleanup</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_cleanup>

    def test_cleanup(self):
        """Test that we can use a cleanup function."""
        cleanup_called = []

        def cleanup_func(key, val):
            cleanup_called.append((key, val))

>       cache = lru_cache.LRUCache(max_cache=2, after_cleanup_count=2)

tests/test_lru_cache.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1fd5c040>, max_cache = 2
after_cleanup_count = 2

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_cleanup_2">test_lru_cache.py::TestLRUCache::test_cleanup_2</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_cleanup_2</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_cleanup_2>

    def test_cleanup_2(self):
>       cache = lru_cache.LRUCache(max_cache=5, after_cleanup_count=2)

tests/test_lru_cache.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1fafc700>, max_cache = 5
after_cleanup_count = 2

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_cleanup_on_replace">test_lru_cache.py::TestLRUCache::test_cleanup_on_replace</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_cleanup_on_replace</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_cleanup_on_replace>

    def test_cleanup_on_replace(self):
        """Replacing an object should cleanup the old value."""
        cleanup_called = []

        def cleanup_func(key, val):
            cleanup_called.append((key, val))

>       cache = lru_cache.LRUCache(max_cache=2)

tests/test_lru_cache.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1f9e4910>, max_cache = 2
after_cleanup_count = None

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_cleanup_shrinks_to_after_clean_count">test_lru_cache.py::TestLRUCache::test_cleanup_shrinks_to_after_clean_count</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_cleanup_shrinks_to_after_clean_count</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_cleanup_shrinks_to_after_clean_count>

    def test_cleanup_shrinks_to_after_clean_count(self):
>       cache = lru_cache.LRUCache(max_cache=5, after_cleanup_count=3)

tests/test_lru_cache.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1fb4d2a0>, max_cache = 5
after_cleanup_count = 3

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_get">test_lru_cache.py::TestLRUCache::test_get</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_get</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_get>

    def test_get(self):
>       cache = lru_cache.LRUCache(max_cache=5)

tests/test_lru_cache.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1f698d30>, max_cache = 5
after_cleanup_count = None

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_keys">test_lru_cache.py::TestLRUCache::test_keys</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_keys</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_keys>

    def test_keys(self):
>       cache = lru_cache.LRUCache(max_cache=5, after_cleanup_count=5)

tests/test_lru_cache.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1f6a83d0>, max_cache = 5
after_cleanup_count = 5

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_len">test_lru_cache.py::TestLRUCache::test_len</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_len</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_len>

    def test_len(self):
>       cache = lru_cache.LRUCache(max_cache=10, after_cleanup_count=10)

tests/test_lru_cache.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1fb53ac0>, max_cache = 10
after_cleanup_count = 10

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_map_none">test_lru_cache.py::TestLRUCache::test_map_None</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_map_None</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_map_None>

    def test_map_None(self):
        # Make sure that we can properly map None as a key.
>       cache = lru_cache.LRUCache(max_cache=10)

tests/test_lru_cache.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1f634fd0>, max_cache = 10
after_cleanup_count = None

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_missing">test_lru_cache.py::TestLRUCache::test_missing</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_missing</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_missing>

    def test_missing(self):
>       cache = lru_cache.LRUCache(max_cache=10)

tests/test_lru_cache.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1fafd2a0>, max_cache = 10
after_cleanup_count = None

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_overflow">test_lru_cache.py::TestLRUCache::test_overflow</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_overflow</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_overflow>

    def test_overflow(self):
        """Adding extra entries will pop out old ones."""
>       cache = lru_cache.LRUCache(max_cache=1, after_cleanup_count=1)

tests/test_lru_cache.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1f66a4d0>, max_cache = 1
after_cleanup_count = 1

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_preserve_last_access_order">test_lru_cache.py::TestLRUCache::test_preserve_last_access_order</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_preserve_last_access_order</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_preserve_last_access_order>

    def test_preserve_last_access_order(self):
>       cache = lru_cache.LRUCache(max_cache=5)

tests/test_lru_cache.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1f0f4eb0>, max_cache = 5
after_cleanup_count = None

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_resize_larger">test_lru_cache.py::TestLRUCache::test_resize_larger</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_resize_larger</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_resize_larger>

    def test_resize_larger(self):
>       cache = lru_cache.LRUCache(max_cache=5, after_cleanup_count=4)

tests/test_lru_cache.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1fb4e260>, max_cache = 5
after_cleanup_count = 4

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrucachetest_resize_smaller">test_lru_cache.py::TestLRUCache::test_resize_smaller</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUCache::test_resize_smaller</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUCache testMethod=test_resize_smaller>

    def test_resize_smaller(self):
>       cache = lru_cache.LRUCache(max_cache=5, after_cleanup_count=4)

tests/test_lru_cache.py:254: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUCache object at 0x7eec1fb57280>, max_cache = 5
after_cleanup_count = 4

    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[int]=None) -> None:
        self._cache: Dict[K, _LRUNode[K, V]] = {}
        self._most_recently_used = None
        self._least_recently_used = None
>       self._update_max_cache(max_cache, after_cleanup_count)
E       AttributeError: 'LRUCache' object has no attribute '_update_max_cache'

dulwich/lru_cache.py:38: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrusizecachetest_add__null_key">test_lru_cache.py::TestLRUSizeCache::test_add__null_key</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUSizeCache::test_add__null_key</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUSizeCache testMethod=test_add__null_key>

    def test_add__null_key(self):
>       cache = lru_cache.LRUSizeCache()

tests/test_lru_cache.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUSizeCache object at 0x7eec1fcaefe0>
max_size = 1048576, after_cleanup_size = None, compute_size = None

    def __init__(self, max_size: int=1024 * 1024, after_cleanup_size: Optional[int]=None, compute_size: Optional[Callable[[V], int]]=None) -> None:
        """Create a new LRUSizeCache.

        Args:
          max_size: The max number of bytes to store before we start
            clearing out entries.
          after_cleanup_size: After cleaning up, shrink everything to this
            size.
          compute_size: A function to compute the size of the values. We
            use a function here, so that you can pass 'len' if you are just
            using simple strings, or a more complex function if you are using
            something like a list of strings, or even a custom object.
            The function should take the form "compute_size(value) => integer".
            If not supplied, it defaults to 'len()'
        """
        self._value_size = 0
        if compute_size is None:
            self._compute_size = len
        else:
            self._compute_size = compute_size
>       self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)
E       AttributeError: 'LRUSizeCache' object has no attribute '_update_max_size'

dulwich/lru_cache.py:168: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrusizecachetest_add_tracks_size">test_lru_cache.py::TestLRUSizeCache::test_add_tracks_size</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUSizeCache::test_add_tracks_size</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUSizeCache testMethod=test_add_tracks_size>

    def test_add_tracks_size(self):
>       cache = lru_cache.LRUSizeCache()

tests/test_lru_cache.py:305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUSizeCache object at 0x7eec1f9f14b0>
max_size = 1048576, after_cleanup_size = None, compute_size = None

    def __init__(self, max_size: int=1024 * 1024, after_cleanup_size: Optional[int]=None, compute_size: Optional[Callable[[V], int]]=None) -> None:
        """Create a new LRUSizeCache.

        Args:
          max_size: The max number of bytes to store before we start
            clearing out entries.
          after_cleanup_size: After cleaning up, shrink everything to this
            size.
          compute_size: A function to compute the size of the values. We
            use a function here, so that you can pass 'len' if you are just
            using simple strings, or a more complex function if you are using
            something like a list of strings, or even a custom object.
            The function should take the form "compute_size(value) => integer".
            If not supplied, it defaults to 'len()'
        """
        self._value_size = 0
        if compute_size is None:
            self._compute_size = len
        else:
            self._compute_size = compute_size
>       self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)
E       AttributeError: 'LRUSizeCache' object has no attribute '_update_max_size'

dulwich/lru_cache.py:168: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrusizecachetest_adding_clears_cache_based_on_size">test_lru_cache.py::TestLRUSizeCache::test_adding_clears_cache_based_on_size</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUSizeCache::test_adding_clears_cache_based_on_size</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUSizeCache testMethod=test_adding_clears_cache_based_on_size>

    def test_adding_clears_cache_based_on_size(self):
        """The cache is cleared in LRU order until small enough."""
>       cache = lru_cache.LRUSizeCache(max_size=20)

tests/test_lru_cache.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUSizeCache object at 0x7eec1f9e2050>, max_size = 20
after_cleanup_size = None, compute_size = None

    def __init__(self, max_size: int=1024 * 1024, after_cleanup_size: Optional[int]=None, compute_size: Optional[Callable[[V], int]]=None) -> None:
        """Create a new LRUSizeCache.

        Args:
          max_size: The max number of bytes to store before we start
            clearing out entries.
          after_cleanup_size: After cleaning up, shrink everything to this
            size.
          compute_size: A function to compute the size of the values. We
            use a function here, so that you can pass 'len' if you are just
            using simple strings, or a more complex function if you are using
            something like a list of strings, or even a custom object.
            The function should take the form "compute_size(value) => integer".
            If not supplied, it defaults to 'len()'
        """
        self._value_size = 0
        if compute_size is None:
            self._compute_size = len
        else:
            self._compute_size = compute_size
>       self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)
E       AttributeError: 'LRUSizeCache' object has no attribute '_update_max_size'

dulwich/lru_cache.py:168: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrusizecachetest_adding_clears_to_after_cleanup_size">test_lru_cache.py::TestLRUSizeCache::test_adding_clears_to_after_cleanup_size</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUSizeCache::test_adding_clears_to_after_cleanup_size</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUSizeCache testMethod=test_adding_clears_to_after_cleanup_size>

    def test_adding_clears_to_after_cleanup_size(self):
>       cache = lru_cache.LRUSizeCache(max_size=20, after_cleanup_size=10)

tests/test_lru_cache.py:371: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUSizeCache object at 0x7eec1ef22530>, max_size = 20
after_cleanup_size = 10, compute_size = None

    def __init__(self, max_size: int=1024 * 1024, after_cleanup_size: Optional[int]=None, compute_size: Optional[Callable[[V], int]]=None) -> None:
        """Create a new LRUSizeCache.

        Args:
          max_size: The max number of bytes to store before we start
            clearing out entries.
          after_cleanup_size: After cleaning up, shrink everything to this
            size.
          compute_size: A function to compute the size of the values. We
            use a function here, so that you can pass 'len' if you are just
            using simple strings, or a more complex function if you are using
            something like a list of strings, or even a custom object.
            The function should take the form "compute_size(value) => integer".
            If not supplied, it defaults to 'len()'
        """
        self._value_size = 0
        if compute_size is None:
            self._compute_size = len
        else:
            self._compute_size = compute_size
>       self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)
E       AttributeError: 'LRUSizeCache' object has no attribute '_update_max_size'

dulwich/lru_cache.py:168: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrusizecachetest_basic_init">test_lru_cache.py::TestLRUSizeCache::test_basic_init</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUSizeCache::test_basic_init</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUSizeCache testMethod=test_basic_init>

    def test_basic_init(self):
>       cache = lru_cache.LRUSizeCache()

tests/test_lru_cache.py:295: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUSizeCache object at 0x7eec1f7ba7d0>
max_size = 1048576, after_cleanup_size = None, compute_size = None

    def __init__(self, max_size: int=1024 * 1024, after_cleanup_size: Optional[int]=None, compute_size: Optional[Callable[[V], int]]=None) -> None:
        """Create a new LRUSizeCache.

        Args:
          max_size: The max number of bytes to store before we start
            clearing out entries.
          after_cleanup_size: After cleaning up, shrink everything to this
            size.
          compute_size: A function to compute the size of the values. We
            use a function here, so that you can pass 'len' if you are just
            using simple strings, or a more complex function if you are using
            something like a list of strings, or even a custom object.
            The function should take the form "compute_size(value) => integer".
            If not supplied, it defaults to 'len()'
        """
        self._value_size = 0
        if compute_size is None:
            self._compute_size = len
        else:
            self._compute_size = compute_size
>       self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)
E       AttributeError: 'LRUSizeCache' object has no attribute '_update_max_size'

dulwich/lru_cache.py:168: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrusizecachetest_cleanup">test_lru_cache.py::TestLRUSizeCache::test_cleanup</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUSizeCache::test_cleanup</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUSizeCache testMethod=test_cleanup>

    def test_cleanup(self):
>       cache = lru_cache.LRUSizeCache(max_size=20, after_cleanup_size=10)

tests/test_lru_cache.py:401: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUSizeCache object at 0x7eec1f9cbc40>, max_size = 20
after_cleanup_size = 10, compute_size = None

    def __init__(self, max_size: int=1024 * 1024, after_cleanup_size: Optional[int]=None, compute_size: Optional[Callable[[V], int]]=None) -> None:
        """Create a new LRUSizeCache.

        Args:
          max_size: The max number of bytes to store before we start
            clearing out entries.
          after_cleanup_size: After cleaning up, shrink everything to this
            size.
          compute_size: A function to compute the size of the values. We
            use a function here, so that you can pass 'len' if you are just
            using simple strings, or a more complex function if you are using
            something like a list of strings, or even a custom object.
            The function should take the form "compute_size(value) => integer".
            If not supplied, it defaults to 'len()'
        """
        self._value_size = 0
        if compute_size is None:
            self._compute_size = len
        else:
            self._compute_size = compute_size
>       self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)
E       AttributeError: 'LRUSizeCache' object has no attribute '_update_max_size'

dulwich/lru_cache.py:168: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrusizecachetest_custom_sizes">test_lru_cache.py::TestLRUSizeCache::test_custom_sizes</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUSizeCache::test_custom_sizes</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUSizeCache testMethod=test_custom_sizes>

    def test_custom_sizes(self):
        def size_of_list(lst):
            return sum(len(x) for x in lst)

>       cache = lru_cache.LRUSizeCache(
            max_size=20, after_cleanup_size=10, compute_size=size_of_list
        )

tests/test_lru_cache.py:386: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUSizeCache object at 0x7eec1f9e3070>, max_size = 20
after_cleanup_size = 10
compute_size = <function TestLRUSizeCache.test_custom_sizes.<locals>.size_of_list at 0x7eec1ee88040>

    def __init__(self, max_size: int=1024 * 1024, after_cleanup_size: Optional[int]=None, compute_size: Optional[Callable[[V], int]]=None) -> None:
        """Create a new LRUSizeCache.

        Args:
          max_size: The max number of bytes to store before we start
            clearing out entries.
          after_cleanup_size: After cleaning up, shrink everything to this
            size.
          compute_size: A function to compute the size of the values. We
            use a function here, so that you can pass 'len' if you are just
            using simple strings, or a more complex function if you are using
            something like a list of strings, or even a custom object.
            The function should take the form "compute_size(value) => integer".
            If not supplied, it defaults to 'len()'
        """
        self._value_size = 0
        if compute_size is None:
            self._compute_size = len
        else:
            self._compute_size = compute_size
>       self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)
E       AttributeError: 'LRUSizeCache' object has no attribute '_update_max_size'

dulwich/lru_cache.py:168: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrusizecachetest_keys">test_lru_cache.py::TestLRUSizeCache::test_keys</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUSizeCache::test_keys</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUSizeCache testMethod=test_keys>

    def test_keys(self):
>       cache = lru_cache.LRUSizeCache(max_size=10)

tests/test_lru_cache.py:414: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUSizeCache object at 0x7eec1fa71f60>, max_size = 10
after_cleanup_size = None, compute_size = None

    def __init__(self, max_size: int=1024 * 1024, after_cleanup_size: Optional[int]=None, compute_size: Optional[Callable[[V], int]]=None) -> None:
        """Create a new LRUSizeCache.

        Args:
          max_size: The max number of bytes to store before we start
            clearing out entries.
          after_cleanup_size: After cleaning up, shrink everything to this
            size.
          compute_size: A function to compute the size of the values. We
            use a function here, so that you can pass 'len' if you are just
            using simple strings, or a more complex function if you are using
            something like a list of strings, or even a custom object.
            The function should take the form "compute_size(value) => integer".
            If not supplied, it defaults to 'len()'
        """
        self._value_size = 0
        if compute_size is None:
            self._compute_size = len
        else:
            self._compute_size = compute_size
>       self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)
E       AttributeError: 'LRUSizeCache' object has no attribute '_update_max_size'

dulwich/lru_cache.py:168: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrusizecachetest_no_add_over_size">test_lru_cache.py::TestLRUSizeCache::test_no_add_over_size</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUSizeCache::test_no_add_over_size</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUSizeCache testMethod=test_no_add_over_size>

    def test_no_add_over_size(self):
        """Adding a large value may not be cached at all."""
>       cache = lru_cache.LRUSizeCache(max_size=10, after_cleanup_size=5)

tests/test_lru_cache.py:321: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUSizeCache object at 0x7eec1f9f14b0>, max_size = 10
after_cleanup_size = 5, compute_size = None

    def __init__(self, max_size: int=1024 * 1024, after_cleanup_size: Optional[int]=None, compute_size: Optional[Callable[[V], int]]=None) -> None:
        """Create a new LRUSizeCache.

        Args:
          max_size: The max number of bytes to store before we start
            clearing out entries.
          after_cleanup_size: After cleaning up, shrink everything to this
            size.
          compute_size: A function to compute the size of the values. We
            use a function here, so that you can pass 'len' if you are just
            using simple strings, or a more complex function if you are using
            something like a list of strings, or even a custom object.
            The function should take the form "compute_size(value) => integer".
            If not supplied, it defaults to 'len()'
        """
        self._value_size = 0
        if compute_size is None:
            self._compute_size = len
        else:
            self._compute_size = compute_size
>       self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)
E       AttributeError: 'LRUSizeCache' object has no attribute '_update_max_size'

dulwich/lru_cache.py:168: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrusizecachetest_no_add_over_size_cleanup">test_lru_cache.py::TestLRUSizeCache::test_no_add_over_size_cleanup</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUSizeCache::test_no_add_over_size_cleanup</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUSizeCache testMethod=test_no_add_over_size_cleanup>

    def test_no_add_over_size_cleanup(self):
        """If a large value is not cached, we will call cleanup right away."""
        cleanup_calls = []

        def cleanup(key, value):
            cleanup_calls.append((key, value))

>       cache = lru_cache.LRUSizeCache(max_size=10, after_cleanup_size=5)

tests/test_lru_cache.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUSizeCache object at 0x7eec1f9e23b0>, max_size = 10
after_cleanup_size = 5, compute_size = None

    def __init__(self, max_size: int=1024 * 1024, after_cleanup_size: Optional[int]=None, compute_size: Optional[Callable[[V], int]]=None) -> None:
        """Create a new LRUSizeCache.

        Args:
          max_size: The max number of bytes to store before we start
            clearing out entries.
          after_cleanup_size: After cleaning up, shrink everything to this
            size.
          compute_size: A function to compute the size of the values. We
            use a function here, so that you can pass 'len' if you are just
            using simple strings, or a more complex function if you are using
            something like a list of strings, or even a custom object.
            The function should take the form "compute_size(value) => integer".
            If not supplied, it defaults to 'len()'
        """
        self._value_size = 0
        if compute_size is None:
            self._compute_size = len
        else:
            self._compute_size = compute_size
>       self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)
E       AttributeError: 'LRUSizeCache' object has no attribute '_update_max_size'

dulwich/lru_cache.py:168: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrusizecachetest_remove_tracks_size">test_lru_cache.py::TestLRUSizeCache::test_remove_tracks_size</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUSizeCache::test_remove_tracks_size</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUSizeCache testMethod=test_remove_tracks_size>

    def test_remove_tracks_size(self):
>       cache = lru_cache.LRUSizeCache()

tests/test_lru_cache.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUSizeCache object at 0x7eec1f9ca680>
max_size = 1048576, after_cleanup_size = None, compute_size = None

    def __init__(self, max_size: int=1024 * 1024, after_cleanup_size: Optional[int]=None, compute_size: Optional[Callable[[V], int]]=None) -> None:
        """Create a new LRUSizeCache.

        Args:
          max_size: The max number of bytes to store before we start
            clearing out entries.
          after_cleanup_size: After cleaning up, shrink everything to this
            size.
          compute_size: A function to compute the size of the values. We
            use a function here, so that you can pass 'len' if you are just
            using simple strings, or a more complex function if you are using
            something like a list of strings, or even a custom object.
            The function should take the form "compute_size(value) => integer".
            If not supplied, it defaults to 'len()'
        """
        self._value_size = 0
        if compute_size is None:
            self._compute_size = len
        else:
            self._compute_size = compute_size
>       self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)
E       AttributeError: 'LRUSizeCache' object has no attribute '_update_max_size'

dulwich/lru_cache.py:168: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrusizecachetest_resize_larger">test_lru_cache.py::TestLRUSizeCache::test_resize_larger</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUSizeCache::test_resize_larger</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUSizeCache testMethod=test_resize_larger>

    def test_resize_larger(self):
>       cache = lru_cache.LRUSizeCache(max_size=10, after_cleanup_size=9)

tests/test_lru_cache.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUSizeCache object at 0x7eec1f6aa890>, max_size = 10
after_cleanup_size = 9, compute_size = None

    def __init__(self, max_size: int=1024 * 1024, after_cleanup_size: Optional[int]=None, compute_size: Optional[Callable[[V], int]]=None) -> None:
        """Create a new LRUSizeCache.

        Args:
          max_size: The max number of bytes to store before we start
            clearing out entries.
          after_cleanup_size: After cleaning up, shrink everything to this
            size.
          compute_size: A function to compute the size of the values. We
            use a function here, so that you can pass 'len' if you are just
            using simple strings, or a more complex function if you are using
            something like a list of strings, or even a custom object.
            The function should take the form "compute_size(value) => integer".
            If not supplied, it defaults to 'len()'
        """
        self._value_size = 0
        if compute_size is None:
            self._compute_size = len
        else:
            self._compute_size = compute_size
>       self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)
E       AttributeError: 'LRUSizeCache' object has no attribute '_update_max_size'

dulwich/lru_cache.py:168: AttributeError
</pre>
</details>
<h3 id="test_lru_cachepytestlrusizecachetest_resize_smaller">test_lru_cache.py::TestLRUSizeCache::test_resize_smaller</h3>
<details><summary> <pre>test_lru_cache.py::TestLRUSizeCache::test_resize_smaller</pre></summary><pre>
self = <tests.test_lru_cache.TestLRUSizeCache testMethod=test_resize_smaller>

    def test_resize_smaller(self):
>       cache = lru_cache.LRUSizeCache(max_size=10, after_cleanup_size=9)

tests/test_lru_cache.py:422: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.lru_cache.LRUSizeCache object at 0x7eec1fd7d420>, max_size = 10
after_cleanup_size = 9, compute_size = None

    def __init__(self, max_size: int=1024 * 1024, after_cleanup_size: Optional[int]=None, compute_size: Optional[Callable[[V], int]]=None) -> None:
        """Create a new LRUSizeCache.

        Args:
          max_size: The max number of bytes to store before we start
            clearing out entries.
          after_cleanup_size: After cleaning up, shrink everything to this
            size.
          compute_size: A function to compute the size of the values. We
            use a function here, so that you can pass 'len' if you are just
            using simple strings, or a more complex function if you are using
            something like a list of strings, or even a custom object.
            The function should take the form "compute_size(value) => integer".
            If not supplied, it defaults to 'len()'
        """
        self._value_size = 0
        if compute_size is None:
            self._compute_size = len
        else:
            self._compute_size = compute_size
>       self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)
E       AttributeError: 'LRUSizeCache' object has no attribute '_update_max_size'

dulwich/lru_cache.py:168: AttributeError
</pre>
</details>
<h3 id="test_mailmappyreadmailmapteststest_read">test_mailmap.py::ReadMailmapTests::test_read</h3>
<details><summary> <pre>test_mailmap.py::ReadMailmapTests::test_read</pre></summary><pre>
self = <tests.test_mailmap.ReadMailmapTests testMethod=test_read>

        def test_read(self):
            b = BytesIO(
                b"""\
    Jane Doe         <jane@desktop.(none)>
    Joe R. Developer <joe@example.com>
    # A comment
    <cto@company.xx>                       <cto@coompany.xx> # Comment
    Some Dude <some@dude.xx>         nick1 <bugs@company.xx>
    Other Author <other@author.xx>   nick2 <bugs@company.xx>
    Other Author <other@author.xx>         <nick2@company.xx>
    Santa Claus <santa.claus@northpole.xx> <me@company.xx>
    """
            )
            self.assertEqual(
                [
                    ((b"Jane Doe", b"jane@desktop.(none)"), None),
                    ((b"Joe R. Developer", b"joe@example.com"), None),
                    ((None, b"cto@company.xx"), (None, b"cto@coompany.xx")),
                    (
                        (b"Some Dude", b"some@dude.xx"),
                        (b"nick1", b"bugs@company.xx"),
                    ),
                    (
                        (b"Other Author", b"other@author.xx"),
                        (b"nick2", b"bugs@company.xx"),
                    ),
                    (
                        (b"Other Author", b"other@author.xx"),
                        (None, b"nick2@company.xx"),
                    ),
                    (
                        (b"Santa Claus", b"santa.claus@northpole.xx"),
                        (None, b"me@company.xx"),
                    ),
                ],
>               list(read_mailmap(b)),
            )
E           TypeError: 'NoneType' object is not iterable

tests/test_mailmap.py:65: TypeError
</pre>
</details>
<h3 id="test_mailmappymailmapteststest_lookup">test_mailmap.py::MailmapTests::test_lookup</h3>
<details><summary> <pre>test_mailmap.py::MailmapTests::test_lookup</pre></summary><pre>
self = <tests.test_mailmap.MailmapTests testMethod=test_lookup>

    def test_lookup(self):
        m = Mailmap()
        m.add_entry((b"Jane Doe", b"jane@desktop.(none)"), (None, None))
        m.add_entry((b"Joe R. Developer", b"joe@example.com"), None)
        m.add_entry((None, b"cto@company.xx"), (None, b"cto@coompany.xx"))
        m.add_entry((b"Some Dude", b"some@dude.xx"), (b"nick1", b"bugs@company.xx"))
        m.add_entry(
            (b"Other Author", b"other@author.xx"),
            (b"nick2", b"bugs@company.xx"),
        )
        m.add_entry((b"Other Author", b"other@author.xx"), (None, b"nick2@company.xx"))
        m.add_entry(
            (b"Santa Claus", b"santa.claus@northpole.xx"),
            (None, b"me@company.xx"),
        )
>       self.assertEqual(
            b"Jane Doe <jane@desktop.(none)>",
            m.lookup(b"Jane Doe <jane@desktop.(none)>"),
        )
E       AssertionError: b'Jane Doe <jane@desktop.(none)>' != None

tests/test_mailmap.py:85: AssertionError
</pre>
</details>
<h3 id="test_missing_obj_finderpymoflinearrepotesttest_1_to_2">test_missing_obj_finder.py::MOFLinearRepoTest::test_1_to_2</h3>
<details><summary> <pre>test_missing_obj_finder.py::MOFLinearRepoTest::test_1_to_2</pre></summary><pre>
self = <tests.test_missing_obj_finder.MOFLinearRepoTest testMethod=test_1_to_2>

    def setUp(self):
        super().setUp()
        # present in 1, removed in 3
        f1_1 = make_object(Blob, data=b"f1")
        # present in all revisions, changed in 2 and 3
        f2_1 = make_object(Blob, data=b"f2")
        f2_2 = make_object(Blob, data=b"f2-changed")
        f2_3 = make_object(Blob, data=b"f2-changed-again")
        # added in 2, left unmodified in 3
        f3_2 = make_object(Blob, data=b"f3")

        commit_spec = [[1], [2, 1], [3, 2]]
        trees = {
            1: [(b"f1", f1_1), (b"f2", f2_1)],
            2: [(b"f1", f1_1), (b"f2", f2_2), (b"f3", f3_2)],
            3: [(b"f2", f2_3), (b"f3", f3_2)],
        }
        # commit 1: f1 and f2
        # commit 2: f3 added, f2 changed. Missing shall report commit id and a
        # tree referenced by commit
        # commit 3: f1 removed, f2 changed. Commit sha and root tree sha shall
        # be reported as modified
        self.commits = build_commit_graph(self.store, commit_spec, trees)
>       self.missing_1_2 = [self.cmt(2).id, self.cmt(2).tree, f2_2.id, f3_2.id]

tests/test_missing_obj_finder.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_missing_obj_finder.MOFLinearRepoTest testMethod=test_1_to_2>
n = 2

    def cmt(self, n):
>       return self.commits[n - 1]
E       TypeError: 'NoneType' object is not subscriptable

tests/test_missing_obj_finder.py:35: TypeError
</pre>
</details>
<h3 id="test_missing_obj_finderpymoflinearrepotesttest_1_to_3">test_missing_obj_finder.py::MOFLinearRepoTest::test_1_to_3</h3>
<details><summary> <pre>test_missing_obj_finder.py::MOFLinearRepoTest::test_1_to_3</pre></summary><pre>
self = <tests.test_missing_obj_finder.MOFLinearRepoTest testMethod=test_1_to_3>

    def setUp(self):
        super().setUp()
        # present in 1, removed in 3
        f1_1 = make_object(Blob, data=b"f1")
        # present in all revisions, changed in 2 and 3
        f2_1 = make_object(Blob, data=b"f2")
        f2_2 = make_object(Blob, data=b"f2-changed")
        f2_3 = make_object(Blob, data=b"f2-changed-again")
        # added in 2, left unmodified in 3
        f3_2 = make_object(Blob, data=b"f3")

        commit_spec = [[1], [2, 1], [3, 2]]
        trees = {
            1: [(b"f1", f1_1), (b"f2", f2_1)],
            2: [(b"f1", f1_1), (b"f2", f2_2), (b"f3", f3_2)],
            3: [(b"f2", f2_3), (b"f3", f3_2)],
        }
        # commit 1: f1 and f2
        # commit 2: f3 added, f2 changed. Missing shall report commit id and a
        # tree referenced by commit
        # commit 3: f1 removed, f2 changed. Commit sha and root tree sha shall
        # be reported as modified
        self.commits = build_commit_graph(self.store, commit_spec, trees)
>       self.missing_1_2 = [self.cmt(2).id, self.cmt(2).tree, f2_2.id, f3_2.id]

tests/test_missing_obj_finder.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_missing_obj_finder.MOFLinearRepoTest testMethod=test_1_to_3>
n = 2

    def cmt(self, n):
>       return self.commits[n - 1]
E       TypeError: 'NoneType' object is not subscriptable

tests/test_missing_obj_finder.py:35: TypeError
</pre>
</details>
<h3 id="test_missing_obj_finderpymoflinearrepotesttest_2_to_3">test_missing_obj_finder.py::MOFLinearRepoTest::test_2_to_3</h3>
<details><summary> <pre>test_missing_obj_finder.py::MOFLinearRepoTest::test_2_to_3</pre></summary><pre>
self = <tests.test_missing_obj_finder.MOFLinearRepoTest testMethod=test_2_to_3>

    def setUp(self):
        super().setUp()
        # present in 1, removed in 3
        f1_1 = make_object(Blob, data=b"f1")
        # present in all revisions, changed in 2 and 3
        f2_1 = make_object(Blob, data=b"f2")
        f2_2 = make_object(Blob, data=b"f2-changed")
        f2_3 = make_object(Blob, data=b"f2-changed-again")
        # added in 2, left unmodified in 3
        f3_2 = make_object(Blob, data=b"f3")

        commit_spec = [[1], [2, 1], [3, 2]]
        trees = {
            1: [(b"f1", f1_1), (b"f2", f2_1)],
            2: [(b"f1", f1_1), (b"f2", f2_2), (b"f3", f3_2)],
            3: [(b"f2", f2_3), (b"f3", f3_2)],
        }
        # commit 1: f1 and f2
        # commit 2: f3 added, f2 changed. Missing shall report commit id and a
        # tree referenced by commit
        # commit 3: f1 removed, f2 changed. Commit sha and root tree sha shall
        # be reported as modified
        self.commits = build_commit_graph(self.store, commit_spec, trees)
>       self.missing_1_2 = [self.cmt(2).id, self.cmt(2).tree, f2_2.id, f3_2.id]

tests/test_missing_obj_finder.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_missing_obj_finder.MOFLinearRepoTest testMethod=test_2_to_3>
n = 2

    def cmt(self, n):
>       return self.commits[n - 1]
E       TypeError: 'NoneType' object is not subscriptable

tests/test_missing_obj_finder.py:35: TypeError
</pre>
</details>
<h3 id="test_missing_obj_finderpymoflinearrepotesttest_bogus_haves">test_missing_obj_finder.py::MOFLinearRepoTest::test_bogus_haves</h3>
<details><summary> <pre>test_missing_obj_finder.py::MOFLinearRepoTest::test_bogus_haves</pre></summary><pre>
self = <tests.test_missing_obj_finder.MOFLinearRepoTest testMethod=test_bogus_haves>

    def setUp(self):
        super().setUp()
        # present in 1, removed in 3
        f1_1 = make_object(Blob, data=b"f1")
        # present in all revisions, changed in 2 and 3
        f2_1 = make_object(Blob, data=b"f2")
        f2_2 = make_object(Blob, data=b"f2-changed")
        f2_3 = make_object(Blob, data=b"f2-changed-again")
        # added in 2, left unmodified in 3
        f3_2 = make_object(Blob, data=b"f3")

        commit_spec = [[1], [2, 1], [3, 2]]
        trees = {
            1: [(b"f1", f1_1), (b"f2", f2_1)],
            2: [(b"f1", f1_1), (b"f2", f2_2), (b"f3", f3_2)],
            3: [(b"f2", f2_3), (b"f3", f3_2)],
        }
        # commit 1: f1 and f2
        # commit 2: f3 added, f2 changed. Missing shall report commit id and a
        # tree referenced by commit
        # commit 3: f1 removed, f2 changed. Commit sha and root tree sha shall
        # be reported as modified
        self.commits = build_commit_graph(self.store, commit_spec, trees)
>       self.missing_1_2 = [self.cmt(2).id, self.cmt(2).tree, f2_2.id, f3_2.id]

tests/test_missing_obj_finder.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_missing_obj_finder.MOFLinearRepoTest testMethod=test_bogus_haves>
n = 2

    def cmt(self, n):
>       return self.commits[n - 1]
E       TypeError: 'NoneType' object is not subscriptable

tests/test_missing_obj_finder.py:35: TypeError
</pre>
</details>
<h3 id="test_missing_obj_finderpymoflinearrepotesttest_bogus_wants_failure">test_missing_obj_finder.py::MOFLinearRepoTest::test_bogus_wants_failure</h3>
<details><summary> <pre>test_missing_obj_finder.py::MOFLinearRepoTest::test_bogus_wants_failure</pre></summary><pre>
self = <tests.test_missing_obj_finder.MOFLinearRepoTest testMethod=test_bogus_wants_failure>

    def setUp(self):
        super().setUp()
        # present in 1, removed in 3
        f1_1 = make_object(Blob, data=b"f1")
        # present in all revisions, changed in 2 and 3
        f2_1 = make_object(Blob, data=b"f2")
        f2_2 = make_object(Blob, data=b"f2-changed")
        f2_3 = make_object(Blob, data=b"f2-changed-again")
        # added in 2, left unmodified in 3
        f3_2 = make_object(Blob, data=b"f3")

        commit_spec = [[1], [2, 1], [3, 2]]
        trees = {
            1: [(b"f1", f1_1), (b"f2", f2_1)],
            2: [(b"f1", f1_1), (b"f2", f2_2), (b"f3", f3_2)],
            3: [(b"f2", f2_3), (b"f3", f3_2)],
        }
        # commit 1: f1 and f2
        # commit 2: f3 added, f2 changed. Missing shall report commit id and a
        # tree referenced by commit
        # commit 3: f1 removed, f2 changed. Commit sha and root tree sha shall
        # be reported as modified
        self.commits = build_commit_graph(self.store, commit_spec, trees)
>       self.missing_1_2 = [self.cmt(2).id, self.cmt(2).tree, f2_2.id, f3_2.id]

tests/test_missing_obj_finder.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_missing_obj_finder.MOFLinearRepoTest testMethod=test_bogus_wants_failure>
n = 2

    def cmt(self, n):
>       return self.commits[n - 1]
E       TypeError: 'NoneType' object is not subscriptable

tests/test_missing_obj_finder.py:35: TypeError
</pre>
</details>
<h3 id="test_missing_obj_finderpymoflinearrepotesttest_no_changes">test_missing_obj_finder.py::MOFLinearRepoTest::test_no_changes</h3>
<details><summary> <pre>test_missing_obj_finder.py::MOFLinearRepoTest::test_no_changes</pre></summary><pre>
self = <tests.test_missing_obj_finder.MOFLinearRepoTest testMethod=test_no_changes>

    def setUp(self):
        super().setUp()
        # present in 1, removed in 3
        f1_1 = make_object(Blob, data=b"f1")
        # present in all revisions, changed in 2 and 3
        f2_1 = make_object(Blob, data=b"f2")
        f2_2 = make_object(Blob, data=b"f2-changed")
        f2_3 = make_object(Blob, data=b"f2-changed-again")
        # added in 2, left unmodified in 3
        f3_2 = make_object(Blob, data=b"f3")

        commit_spec = [[1], [2, 1], [3, 2]]
        trees = {
            1: [(b"f1", f1_1), (b"f2", f2_1)],
            2: [(b"f1", f1_1), (b"f2", f2_2), (b"f3", f3_2)],
            3: [(b"f2", f2_3), (b"f3", f3_2)],
        }
        # commit 1: f1 and f2
        # commit 2: f3 added, f2 changed. Missing shall report commit id and a
        # tree referenced by commit
        # commit 3: f1 removed, f2 changed. Commit sha and root tree sha shall
        # be reported as modified
        self.commits = build_commit_graph(self.store, commit_spec, trees)
>       self.missing_1_2 = [self.cmt(2).id, self.cmt(2).tree, f2_2.id, f3_2.id]

tests/test_missing_obj_finder.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_missing_obj_finder.MOFLinearRepoTest testMethod=test_no_changes>
n = 2

    def cmt(self, n):
>       return self.commits[n - 1]
E       TypeError: 'NoneType' object is not subscriptable

tests/test_missing_obj_finder.py:35: TypeError
</pre>
</details>
<h3 id="test_missing_obj_finderpymofmergeforkrepotesttest_have1_want6">test_missing_obj_finder.py::MOFMergeForkRepoTest::test_have1_want6</h3>
<details><summary> <pre>test_missing_obj_finder.py::MOFMergeForkRepoTest::test_have1_want6</pre></summary><pre>
self = <tests.test_missing_obj_finder.MOFMergeForkRepoTest testMethod=test_have1_want6>

    def setUp(self):
        super().setUp()
        f1_1 = make_object(Blob, data=b"f1")
        f1_2 = make_object(Blob, data=b"f1-2")
        f1_4 = make_object(Blob, data=b"f1-4")
        f1_7 = make_object(Blob, data=b"f1-2")  # same data as in rev 2
        f2_1 = make_object(Blob, data=b"f2")
        f2_3 = make_object(Blob, data=b"f2-3")
        f3_3 = make_object(Blob, data=b"f3")
        f3_5 = make_object(Blob, data=b"f3-5")
        commit_spec = [[1], [2, 1], [3, 2], [4, 2], [5, 3], [6, 3, 4], [7, 6]]
        trees = {
            1: [(b"f1", f1_1), (b"f2", f2_1)],
            2: [(b"f1", f1_2), (b"f2", f2_1)],  # f1 changed
            # f3 added, f2 changed
            3: [(b"f1", f1_2), (b"f2", f2_3), (b"f3", f3_3)],
            4: [(b"f1", f1_4), (b"f2", f2_1)],  # f1 changed
            5: [(b"f1", f1_2), (b"f3", f3_5)],  # f2 removed, f3 changed
            # merged 3 and 4
            6: [(b"f1", f1_4), (b"f2", f2_3), (b"f3", f3_3)],
            # f1 changed to match rev2. f3 removed
            7: [(b"f1", f1_7), (b"f2", f2_3)],
        }
        self.commits = build_commit_graph(self.store, commit_spec, trees)

>       self.f1_2_id = f1_2.id
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_missing_obj_finder.py:148: AttributeError
</pre>
</details>
<h3 id="test_missing_obj_finderpymofmergeforkrepotesttest_have3_want6">test_missing_obj_finder.py::MOFMergeForkRepoTest::test_have3_want6</h3>
<details><summary> <pre>test_missing_obj_finder.py::MOFMergeForkRepoTest::test_have3_want6</pre></summary><pre>
self = <tests.test_missing_obj_finder.MOFMergeForkRepoTest testMethod=test_have3_want6>

    def setUp(self):
        super().setUp()
        f1_1 = make_object(Blob, data=b"f1")
        f1_2 = make_object(Blob, data=b"f1-2")
        f1_4 = make_object(Blob, data=b"f1-4")
        f1_7 = make_object(Blob, data=b"f1-2")  # same data as in rev 2
        f2_1 = make_object(Blob, data=b"f2")
        f2_3 = make_object(Blob, data=b"f2-3")
        f3_3 = make_object(Blob, data=b"f3")
        f3_5 = make_object(Blob, data=b"f3-5")
        commit_spec = [[1], [2, 1], [3, 2], [4, 2], [5, 3], [6, 3, 4], [7, 6]]
        trees = {
            1: [(b"f1", f1_1), (b"f2", f2_1)],
            2: [(b"f1", f1_2), (b"f2", f2_1)],  # f1 changed
            # f3 added, f2 changed
            3: [(b"f1", f1_2), (b"f2", f2_3), (b"f3", f3_3)],
            4: [(b"f1", f1_4), (b"f2", f2_1)],  # f1 changed
            5: [(b"f1", f1_2), (b"f3", f3_5)],  # f2 removed, f3 changed
            # merged 3 and 4
            6: [(b"f1", f1_4), (b"f2", f2_3), (b"f3", f3_3)],
            # f1 changed to match rev2. f3 removed
            7: [(b"f1", f1_7), (b"f2", f2_3)],
        }
        self.commits = build_commit_graph(self.store, commit_spec, trees)

>       self.f1_2_id = f1_2.id
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_missing_obj_finder.py:148: AttributeError
</pre>
</details>
<h3 id="test_missing_obj_finderpymofmergeforkrepotesttest_have4_want7">test_missing_obj_finder.py::MOFMergeForkRepoTest::test_have4_want7</h3>
<details><summary> <pre>test_missing_obj_finder.py::MOFMergeForkRepoTest::test_have4_want7</pre></summary><pre>
self = <tests.test_missing_obj_finder.MOFMergeForkRepoTest testMethod=test_have4_want7>

    def setUp(self):
        super().setUp()
        f1_1 = make_object(Blob, data=b"f1")
        f1_2 = make_object(Blob, data=b"f1-2")
        f1_4 = make_object(Blob, data=b"f1-4")
        f1_7 = make_object(Blob, data=b"f1-2")  # same data as in rev 2
        f2_1 = make_object(Blob, data=b"f2")
        f2_3 = make_object(Blob, data=b"f2-3")
        f3_3 = make_object(Blob, data=b"f3")
        f3_5 = make_object(Blob, data=b"f3-5")
        commit_spec = [[1], [2, 1], [3, 2], [4, 2], [5, 3], [6, 3, 4], [7, 6]]
        trees = {
            1: [(b"f1", f1_1), (b"f2", f2_1)],
            2: [(b"f1", f1_2), (b"f2", f2_1)],  # f1 changed
            # f3 added, f2 changed
            3: [(b"f1", f1_2), (b"f2", f2_3), (b"f3", f3_3)],
            4: [(b"f1", f1_4), (b"f2", f2_1)],  # f1 changed
            5: [(b"f1", f1_2), (b"f3", f3_5)],  # f2 removed, f3 changed
            # merged 3 and 4
            6: [(b"f1", f1_4), (b"f2", f2_3), (b"f3", f3_3)],
            # f1 changed to match rev2. f3 removed
            7: [(b"f1", f1_7), (b"f2", f2_3)],
        }
        self.commits = build_commit_graph(self.store, commit_spec, trees)

>       self.f1_2_id = f1_2.id
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_missing_obj_finder.py:148: AttributeError
</pre>
</details>
<h3 id="test_missing_obj_finderpymofmergeforkrepotesttest_have5_want7">test_missing_obj_finder.py::MOFMergeForkRepoTest::test_have5_want7</h3>
<details><summary> <pre>test_missing_obj_finder.py::MOFMergeForkRepoTest::test_have5_want7</pre></summary><pre>
self = <tests.test_missing_obj_finder.MOFMergeForkRepoTest testMethod=test_have5_want7>

    def setUp(self):
        super().setUp()
        f1_1 = make_object(Blob, data=b"f1")
        f1_2 = make_object(Blob, data=b"f1-2")
        f1_4 = make_object(Blob, data=b"f1-4")
        f1_7 = make_object(Blob, data=b"f1-2")  # same data as in rev 2
        f2_1 = make_object(Blob, data=b"f2")
        f2_3 = make_object(Blob, data=b"f2-3")
        f3_3 = make_object(Blob, data=b"f3")
        f3_5 = make_object(Blob, data=b"f3-5")
        commit_spec = [[1], [2, 1], [3, 2], [4, 2], [5, 3], [6, 3, 4], [7, 6]]
        trees = {
            1: [(b"f1", f1_1), (b"f2", f2_1)],
            2: [(b"f1", f1_2), (b"f2", f2_1)],  # f1 changed
            # f3 added, f2 changed
            3: [(b"f1", f1_2), (b"f2", f2_3), (b"f3", f3_3)],
            4: [(b"f1", f1_4), (b"f2", f2_1)],  # f1 changed
            5: [(b"f1", f1_2), (b"f3", f3_5)],  # f2 removed, f3 changed
            # merged 3 and 4
            6: [(b"f1", f1_4), (b"f2", f2_3), (b"f3", f3_3)],
            # f1 changed to match rev2. f3 removed
            7: [(b"f1", f1_7), (b"f2", f2_3)],
        }
        self.commits = build_commit_graph(self.store, commit_spec, trees)

>       self.f1_2_id = f1_2.id
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_missing_obj_finder.py:148: AttributeError
</pre>
</details>
<h3 id="test_missing_obj_finderpymofmergeforkrepotesttest_have6_want7">test_missing_obj_finder.py::MOFMergeForkRepoTest::test_have6_want7</h3>
<details><summary> <pre>test_missing_obj_finder.py::MOFMergeForkRepoTest::test_have6_want7</pre></summary><pre>
self = <tests.test_missing_obj_finder.MOFMergeForkRepoTest testMethod=test_have6_want7>

    def setUp(self):
        super().setUp()
        f1_1 = make_object(Blob, data=b"f1")
        f1_2 = make_object(Blob, data=b"f1-2")
        f1_4 = make_object(Blob, data=b"f1-4")
        f1_7 = make_object(Blob, data=b"f1-2")  # same data as in rev 2
        f2_1 = make_object(Blob, data=b"f2")
        f2_3 = make_object(Blob, data=b"f2-3")
        f3_3 = make_object(Blob, data=b"f3")
        f3_5 = make_object(Blob, data=b"f3-5")
        commit_spec = [[1], [2, 1], [3, 2], [4, 2], [5, 3], [6, 3, 4], [7, 6]]
        trees = {
            1: [(b"f1", f1_1), (b"f2", f2_1)],
            2: [(b"f1", f1_2), (b"f2", f2_1)],  # f1 changed
            # f3 added, f2 changed
            3: [(b"f1", f1_2), (b"f2", f2_3), (b"f3", f3_3)],
            4: [(b"f1", f1_4), (b"f2", f2_1)],  # f1 changed
            5: [(b"f1", f1_2), (b"f3", f3_5)],  # f2 removed, f3 changed
            # merged 3 and 4
            6: [(b"f1", f1_4), (b"f2", f2_3), (b"f3", f3_3)],
            # f1 changed to match rev2. f3 removed
            7: [(b"f1", f1_7), (b"f2", f2_3)],
        }
        self.commits = build_commit_graph(self.store, commit_spec, trees)

>       self.f1_2_id = f1_2.id
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_missing_obj_finder.py:148: AttributeError
</pre>
</details>
<h3 id="test_missing_obj_finderpymoftagstesttest_tagged_blob">test_missing_obj_finder.py::MOFTagsTest::test_tagged_blob</h3>
<details><summary> <pre>test_missing_obj_finder.py::MOFTagsTest::test_tagged_blob</pre></summary><pre>
self = <tests.test_missing_obj_finder.MOFTagsTest testMethod=test_tagged_blob>

    def setUp(self):
        super().setUp()
        f1_1 = make_object(Blob, data=b"f1")
        commit_spec = [[1]]
        trees = {1: [(b"f1", f1_1)]}
        self.commits = build_commit_graph(self.store, commit_spec, trees)

>       self._normal_tag = make_tag(self.cmt(1))

tests/test_missing_obj_finder.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_missing_obj_finder.MOFTagsTest testMethod=test_tagged_blob>
n = 1

    def cmt(self, n):
>       return self.commits[n - 1]
E       TypeError: 'NoneType' object is not subscriptable

tests/test_missing_obj_finder.py:35: TypeError
</pre>
</details>
<h3 id="test_missing_obj_finderpymoftagstesttest_tagged_commit">test_missing_obj_finder.py::MOFTagsTest::test_tagged_commit</h3>
<details><summary> <pre>test_missing_obj_finder.py::MOFTagsTest::test_tagged_commit</pre></summary><pre>
self = <tests.test_missing_obj_finder.MOFTagsTest testMethod=test_tagged_commit>

    def setUp(self):
        super().setUp()
        f1_1 = make_object(Blob, data=b"f1")
        commit_spec = [[1]]
        trees = {1: [(b"f1", f1_1)]}
        self.commits = build_commit_graph(self.store, commit_spec, trees)

>       self._normal_tag = make_tag(self.cmt(1))

tests/test_missing_obj_finder.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_missing_obj_finder.MOFTagsTest testMethod=test_tagged_commit>
n = 1

    def cmt(self, n):
>       return self.commits[n - 1]
E       TypeError: 'NoneType' object is not subscriptable

tests/test_missing_obj_finder.py:35: TypeError
</pre>
</details>
<h3 id="test_missing_obj_finderpymoftagstesttest_tagged_tag">test_missing_obj_finder.py::MOFTagsTest::test_tagged_tag</h3>
<details><summary> <pre>test_missing_obj_finder.py::MOFTagsTest::test_tagged_tag</pre></summary><pre>
self = <tests.test_missing_obj_finder.MOFTagsTest testMethod=test_tagged_tag>

    def setUp(self):
        super().setUp()
        f1_1 = make_object(Blob, data=b"f1")
        commit_spec = [[1]]
        trees = {1: [(b"f1", f1_1)]}
        self.commits = build_commit_graph(self.store, commit_spec, trees)

>       self._normal_tag = make_tag(self.cmt(1))

tests/test_missing_obj_finder.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_missing_obj_finder.MOFTagsTest testMethod=test_tagged_tag>
n = 1

    def cmt(self, n):
>       return self.commits[n - 1]
E       TypeError: 'NoneType' object is not subscriptable

tests/test_missing_obj_finder.py:35: TypeError
</pre>
</details>
<h3 id="test_missing_obj_finderpymoftagstesttest_tagged_tagged_blob">test_missing_obj_finder.py::MOFTagsTest::test_tagged_tagged_blob</h3>
<details><summary> <pre>test_missing_obj_finder.py::MOFTagsTest::test_tagged_tagged_blob</pre></summary><pre>
self = <tests.test_missing_obj_finder.MOFTagsTest testMethod=test_tagged_tagged_blob>

    def setUp(self):
        super().setUp()
        f1_1 = make_object(Blob, data=b"f1")
        commit_spec = [[1]]
        trees = {1: [(b"f1", f1_1)]}
        self.commits = build_commit_graph(self.store, commit_spec, trees)

>       self._normal_tag = make_tag(self.cmt(1))

tests/test_missing_obj_finder.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_missing_obj_finder.MOFTagsTest testMethod=test_tagged_tagged_blob>
n = 1

    def cmt(self, n):
>       return self.commits[n - 1]
E       TypeError: 'NoneType' object is not subscriptable

tests/test_missing_obj_finder.py:35: TypeError
</pre>
</details>
<h3 id="test_missing_obj_finderpymoftagstesttest_tagged_tree">test_missing_obj_finder.py::MOFTagsTest::test_tagged_tree</h3>
<details><summary> <pre>test_missing_obj_finder.py::MOFTagsTest::test_tagged_tree</pre></summary><pre>
self = <tests.test_missing_obj_finder.MOFTagsTest testMethod=test_tagged_tree>

    def setUp(self):
        super().setUp()
        f1_1 = make_object(Blob, data=b"f1")
        commit_spec = [[1]]
        trees = {1: [(b"f1", f1_1)]}
        self.commits = build_commit_graph(self.store, commit_spec, trees)

>       self._normal_tag = make_tag(self.cmt(1))

tests/test_missing_obj_finder.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_missing_obj_finder.MOFTagsTest testMethod=test_tagged_tree>
n = 1

    def cmt(self, n):
>       return self.commits[n - 1]
E       TypeError: 'NoneType' object is not subscriptable

tests/test_missing_obj_finder.py:35: TypeError
</pre>
</details>
<h3 id="test_object_storepymemoryobjectstoreteststest_add_pack">test_object_store.py::MemoryObjectStoreTests::test_add_pack</h3>
<details><summary> <pre>test_object_store.py::MemoryObjectStoreTests::test_add_pack</pre></summary><pre>
self = <tests.test_object_store.MemoryObjectStoreTests testMethod=test_add_pack>

    def test_add_pack(self):
        o = MemoryObjectStore()
>       f, commit, abort = o.add_pack()
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_object_store.py:74: TypeError
</pre>
</details>
<h3 id="test_object_storepymemoryobjectstoreteststest_add_pack_emtpy">test_object_store.py::MemoryObjectStoreTests::test_add_pack_emtpy</h3>
<details><summary> <pre>test_object_store.py::MemoryObjectStoreTests::test_add_pack_emtpy</pre></summary><pre>
self = <tests.test_object_store.MemoryObjectStoreTests testMethod=test_add_pack_emtpy>

    def test_add_pack_emtpy(self):
        o = MemoryObjectStore()
>       f, commit, abort = o.add_pack()
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_object_store.py:86: TypeError
</pre>
</details>
<h3 id="test_object_storepymemoryobjectstoreteststest_add_thin_pack">test_object_store.py::MemoryObjectStoreTests::test_add_thin_pack</h3>
<details><summary> <pre>test_object_store.py::MemoryObjectStoreTests::test_add_thin_pack</pre></summary><pre>
self = <tests.test_object_store.MemoryObjectStoreTests testMethod=test_add_thin_pack>

    def test_add_thin_pack(self):
        o = MemoryObjectStore()
        blob = make_object(Blob, data=b"yummy data")
        o.add_object(blob)

        f = BytesIO()
        entries = build_pack(
            f,
            [
>               (REF_DELTA, (blob.id, b"more yummy data")),
            ],
            store=o,
        )
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_object_store.py:98: AttributeError
</pre>
</details>
<h3 id="test_object_storepymemoryobjectstoreteststest_add_thin_pack_empty">test_object_store.py::MemoryObjectStoreTests::test_add_thin_pack_empty</h3>
<details><summary> <pre>test_object_store.py::MemoryObjectStoreTests::test_add_thin_pack_empty</pre></summary><pre>
self = <tests.test_object_store.MemoryObjectStoreTests testMethod=test_add_thin_pack_empty>

    def test_add_thin_pack_empty(self):
        o = MemoryObjectStore()

        f = BytesIO()
        entries = build_pack(f, [], store=o)
>       self.assertEqual([], entries)
E       AssertionError: [] != None

tests/test_object_store.py:113: AssertionError
</pre>
</details>
<h3 id="test_object_storepydiskobjectstoreteststest_add_alternate_path">test_object_store.py::DiskObjectStoreTests::test_add_alternate_path</h3>
<details><summary> <pre>test_object_store.py::DiskObjectStoreTests::test_add_alternate_path</pre></summary><pre>
self = <tests.test_object_store.DiskObjectStoreTests testMethod=test_add_alternate_path>

    def setUp(self):
        TestCase.setUp(self)
        self.store_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.store_dir)
>       self.store = DiskObjectStore.init(self.store_dir)
E       AttributeError: type object 'DiskObjectStore' has no attribute 'init'

tests/test_object_store.py:122: AttributeError
</pre>
</details>
<h3 id="test_object_storepydiskobjectstoreteststest_add_pack">test_object_store.py::DiskObjectStoreTests::test_add_pack</h3>
<details><summary> <pre>test_object_store.py::DiskObjectStoreTests::test_add_pack</pre></summary><pre>
self = <tests.test_object_store.DiskObjectStoreTests testMethod=test_add_pack>

    def setUp(self):
        TestCase.setUp(self)
        self.store_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.store_dir)
>       self.store = DiskObjectStore.init(self.store_dir)
E       AttributeError: type object 'DiskObjectStore' has no attribute 'init'

tests/test_object_store.py:122: AttributeError
</pre>
</details>
<h3 id="test_object_storepydiskobjectstoreteststest_add_thin_pack">test_object_store.py::DiskObjectStoreTests::test_add_thin_pack</h3>
<details><summary> <pre>test_object_store.py::DiskObjectStoreTests::test_add_thin_pack</pre></summary><pre>
self = <tests.test_object_store.DiskObjectStoreTests testMethod=test_add_thin_pack>

    def setUp(self):
        TestCase.setUp(self)
        self.store_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.store_dir)
>       self.store = DiskObjectStore.init(self.store_dir)
E       AttributeError: type object 'DiskObjectStore' has no attribute 'init'

tests/test_object_store.py:122: AttributeError
</pre>
</details>
<h3 id="test_object_storepydiskobjectstoreteststest_add_thin_pack_empty">test_object_store.py::DiskObjectStoreTests::test_add_thin_pack_empty</h3>
<details><summary> <pre>test_object_store.py::DiskObjectStoreTests::test_add_thin_pack_empty</pre></summary><pre>
self = <tests.test_object_store.DiskObjectStoreTests testMethod=test_add_thin_pack_empty>

    def setUp(self):
        TestCase.setUp(self)
        self.store_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.store_dir)
>       self.store = DiskObjectStore.init(self.store_dir)
E       AttributeError: type object 'DiskObjectStore' has no attribute 'init'

tests/test_object_store.py:122: AttributeError
</pre>
</details>
<h3 id="test_object_storepydiskobjectstoreteststest_alternates">test_object_store.py::DiskObjectStoreTests::test_alternates</h3>
<details><summary> <pre>test_object_store.py::DiskObjectStoreTests::test_alternates</pre></summary><pre>
self = <tests.test_object_store.DiskObjectStoreTests testMethod=test_alternates>

    def setUp(self):
        TestCase.setUp(self)
        self.store_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.store_dir)
>       self.store = DiskObjectStore.init(self.store_dir)
E       AttributeError: type object 'DiskObjectStore' has no attribute 'init'

tests/test_object_store.py:122: AttributeError
</pre>
</details>
<h3 id="test_object_storepydiskobjectstoreteststest_corrupted_object_raise_exception">test_object_store.py::DiskObjectStoreTests::test_corrupted_object_raise_exception</h3>
<details><summary> <pre>test_object_store.py::DiskObjectStoreTests::test_corrupted_object_raise_exception</pre></summary><pre>
self = <tests.test_object_store.DiskObjectStoreTests testMethod=test_corrupted_object_raise_exception>

    def setUp(self):
        TestCase.setUp(self)
        self.store_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.store_dir)
>       self.store = DiskObjectStore.init(self.store_dir)
E       AttributeError: type object 'DiskObjectStore' has no attribute 'init'

tests/test_object_store.py:122: AttributeError
</pre>
</details>
<h3 id="test_object_storepydiskobjectstoreteststest_file_modes">test_object_store.py::DiskObjectStoreTests::test_file_modes</h3>
<details><summary> <pre>test_object_store.py::DiskObjectStoreTests::test_file_modes</pre></summary><pre>
self = <tests.test_object_store.DiskObjectStoreTests testMethod=test_file_modes>

    def setUp(self):
        TestCase.setUp(self)
        self.store_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.store_dir)
>       self.store = DiskObjectStore.init(self.store_dir)
E       AttributeError: type object 'DiskObjectStore' has no attribute 'init'

tests/test_object_store.py:122: AttributeError
</pre>
</details>
<h3 id="test_object_storepydiskobjectstoreteststest_loose_compression_level">test_object_store.py::DiskObjectStoreTests::test_loose_compression_level</h3>
<details><summary> <pre>test_object_store.py::DiskObjectStoreTests::test_loose_compression_level</pre></summary><pre>
self = <tests.test_object_store.DiskObjectStoreTests testMethod=test_loose_compression_level>

    def setUp(self):
        TestCase.setUp(self)
        self.store_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.store_dir)
>       self.store = DiskObjectStore.init(self.store_dir)
E       AttributeError: type object 'DiskObjectStore' has no attribute 'init'

tests/test_object_store.py:122: AttributeError
</pre>
</details>
<h3 id="test_object_storepydiskobjectstoreteststest_pack_dir">test_object_store.py::DiskObjectStoreTests::test_pack_dir</h3>
<details><summary> <pre>test_object_store.py::DiskObjectStoreTests::test_pack_dir</pre></summary><pre>
self = <tests.test_object_store.DiskObjectStoreTests testMethod=test_pack_dir>

    def setUp(self):
        TestCase.setUp(self)
        self.store_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.store_dir)
>       self.store = DiskObjectStore.init(self.store_dir)
E       AttributeError: type object 'DiskObjectStore' has no attribute 'init'

tests/test_object_store.py:122: AttributeError
</pre>
</details>
<h3 id="test_object_storepydiskobjectstoreteststest_read_alternate_paths">test_object_store.py::DiskObjectStoreTests::test_read_alternate_paths</h3>
<details><summary> <pre>test_object_store.py::DiskObjectStoreTests::test_read_alternate_paths</pre></summary><pre>
self = <tests.test_object_store.DiskObjectStoreTests testMethod=test_read_alternate_paths>

    def setUp(self):
        TestCase.setUp(self)
        self.store_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.store_dir)
>       self.store = DiskObjectStore.init(self.store_dir)
E       AttributeError: type object 'DiskObjectStore' has no attribute 'init'

tests/test_object_store.py:122: AttributeError
</pre>
</details>
<h3 id="test_object_storepydiskobjectstoreteststest_rel_alternative_path">test_object_store.py::DiskObjectStoreTests::test_rel_alternative_path</h3>
<details><summary> <pre>test_object_store.py::DiskObjectStoreTests::test_rel_alternative_path</pre></summary><pre>
self = <tests.test_object_store.DiskObjectStoreTests testMethod=test_rel_alternative_path>

    def setUp(self):
        TestCase.setUp(self)
        self.store_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.store_dir)
>       self.store = DiskObjectStore.init(self.store_dir)
E       AttributeError: type object 'DiskObjectStore' has no attribute 'init'

tests/test_object_store.py:122: AttributeError
</pre>
</details>
<h3 id="test_object_storepydiskobjectstoreteststest_store_resilience">test_object_store.py::DiskObjectStoreTests::test_store_resilience</h3>
<details><summary> <pre>test_object_store.py::DiskObjectStoreTests::test_store_resilience</pre></summary><pre>
self = <tests.test_object_store.DiskObjectStoreTests testMethod=test_store_resilience>

    def setUp(self):
        TestCase.setUp(self)
        self.store_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.store_dir)
>       self.store = DiskObjectStore.init(self.store_dir)
E       AttributeError: type object 'DiskObjectStore' has no attribute 'init'

tests/test_object_store.py:122: AttributeError
</pre>
</details>
<h3 id="test_object_storepydiskobjectstoreteststest_tempfile_in_loose_store">test_object_store.py::DiskObjectStoreTests::test_tempfile_in_loose_store</h3>
<details><summary> <pre>test_object_store.py::DiskObjectStoreTests::test_tempfile_in_loose_store</pre></summary><pre>
self = <tests.test_object_store.DiskObjectStoreTests testMethod=test_tempfile_in_loose_store>

    def setUp(self):
        TestCase.setUp(self)
        self.store_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.store_dir)
>       self.store = DiskObjectStore.init(self.store_dir)
E       AttributeError: type object 'DiskObjectStore' has no attribute 'init'

tests/test_object_store.py:122: AttributeError
</pre>
</details>
<h3 id="test_object_storepytreelookuppathteststest_lookup_blob">test_object_store.py::TreeLookupPathTests::test_lookup_blob</h3>
<details><summary> <pre>test_object_store.py::TreeLookupPathTests::test_lookup_blob</pre></summary><pre>
self = <tests.test_object_store.TreeLookupPathTests testMethod=test_lookup_blob>

    def setUp(self):
        TestCase.setUp(self)
        self.store = MemoryObjectStore()
        blob_a = make_object(Blob, data=b"a")
        blob_b = make_object(Blob, data=b"b")
        blob_c = make_object(Blob, data=b"c")
        for blob in [blob_a, blob_b, blob_c]:
            self.store.add_object(blob)

        blobs = [
>           (b"a", blob_a.id, 0o100644),
            (b"ad/b", blob_b.id, 0o100644),
            (b"ad/bd/c", blob_c.id, 0o100755),
            (b"ad/c", blob_c.id, 0o100644),
            (b"c", blob_c.id, 0o100644),
            (b"d", blob_c.id, S_IFGITLINK),
        ]
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_object_store.py:306: AttributeError
</pre>
</details>
<h3 id="test_object_storepytreelookuppathteststest_lookup_nonexistent">test_object_store.py::TreeLookupPathTests::test_lookup_nonexistent</h3>
<details><summary> <pre>test_object_store.py::TreeLookupPathTests::test_lookup_nonexistent</pre></summary><pre>
self = <tests.test_object_store.TreeLookupPathTests testMethod=test_lookup_nonexistent>

    def setUp(self):
        TestCase.setUp(self)
        self.store = MemoryObjectStore()
        blob_a = make_object(Blob, data=b"a")
        blob_b = make_object(Blob, data=b"b")
        blob_c = make_object(Blob, data=b"c")
        for blob in [blob_a, blob_b, blob_c]:
            self.store.add_object(blob)

        blobs = [
>           (b"a", blob_a.id, 0o100644),
            (b"ad/b", blob_b.id, 0o100644),
            (b"ad/bd/c", blob_c.id, 0o100755),
            (b"ad/c", blob_c.id, 0o100644),
            (b"c", blob_c.id, 0o100644),
            (b"d", blob_c.id, S_IFGITLINK),
        ]
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_object_store.py:306: AttributeError
</pre>
</details>
<h3 id="test_object_storepytreelookuppathteststest_lookup_not_tree">test_object_store.py::TreeLookupPathTests::test_lookup_not_tree</h3>
<details><summary> <pre>test_object_store.py::TreeLookupPathTests::test_lookup_not_tree</pre></summary><pre>
self = <tests.test_object_store.TreeLookupPathTests testMethod=test_lookup_not_tree>

    def setUp(self):
        TestCase.setUp(self)
        self.store = MemoryObjectStore()
        blob_a = make_object(Blob, data=b"a")
        blob_b = make_object(Blob, data=b"b")
        blob_c = make_object(Blob, data=b"c")
        for blob in [blob_a, blob_b, blob_c]:
            self.store.add_object(blob)

        blobs = [
>           (b"a", blob_a.id, 0o100644),
            (b"ad/b", blob_b.id, 0o100644),
            (b"ad/bd/c", blob_c.id, 0o100755),
            (b"ad/c", blob_c.id, 0o100644),
            (b"c", blob_c.id, 0o100644),
            (b"d", blob_c.id, S_IFGITLINK),
        ]
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_object_store.py:306: AttributeError
</pre>
</details>
<h3 id="test_object_storepytreelookuppathteststest_lookup_submodule">test_object_store.py::TreeLookupPathTests::test_lookup_submodule</h3>
<details><summary> <pre>test_object_store.py::TreeLookupPathTests::test_lookup_submodule</pre></summary><pre>
self = <tests.test_object_store.TreeLookupPathTests testMethod=test_lookup_submodule>

    def setUp(self):
        TestCase.setUp(self)
        self.store = MemoryObjectStore()
        blob_a = make_object(Blob, data=b"a")
        blob_b = make_object(Blob, data=b"b")
        blob_c = make_object(Blob, data=b"c")
        for blob in [blob_a, blob_b, blob_c]:
            self.store.add_object(blob)

        blobs = [
>           (b"a", blob_a.id, 0o100644),
            (b"ad/b", blob_b.id, 0o100644),
            (b"ad/bd/c", blob_c.id, 0o100755),
            (b"ad/c", blob_c.id, 0o100644),
            (b"c", blob_c.id, 0o100644),
            (b"d", blob_c.id, S_IFGITLINK),
        ]
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_object_store.py:306: AttributeError
</pre>
</details>
<h3 id="test_object_storepytreelookuppathteststest_lookup_tree">test_object_store.py::TreeLookupPathTests::test_lookup_tree</h3>
<details><summary> <pre>test_object_store.py::TreeLookupPathTests::test_lookup_tree</pre></summary><pre>
self = <tests.test_object_store.TreeLookupPathTests testMethod=test_lookup_tree>

    def setUp(self):
        TestCase.setUp(self)
        self.store = MemoryObjectStore()
        blob_a = make_object(Blob, data=b"a")
        blob_b = make_object(Blob, data=b"b")
        blob_c = make_object(Blob, data=b"c")
        for blob in [blob_a, blob_b, blob_c]:
            self.store.add_object(blob)

        blobs = [
>           (b"a", blob_a.id, 0o100644),
            (b"ad/b", blob_b.id, 0o100644),
            (b"ad/bd/c", blob_c.id, 0o100755),
            (b"ad/c", blob_c.id, 0o100644),
            (b"c", blob_c.id, 0o100644),
            (b"d", blob_c.id, S_IFGITLINK),
        ]
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_object_store.py:306: AttributeError
</pre>
</details>
<h3 id="test_object_storepyobjectstoregraphwalkerteststest_ack_invalid_value">test_object_store.py::ObjectStoreGraphWalkerTests::test_ack_invalid_value</h3>
<details><summary> <pre>test_object_store.py::ObjectStoreGraphWalkerTests::test_ack_invalid_value</pre></summary><pre>
self = <tests.test_object_store.ObjectStoreGraphWalkerTests testMethod=test_ack_invalid_value>

    def test_ack_invalid_value(self):
        gw = self.get_walker([], {})
>       self.assertRaises(ValueError, gw.ack, "tooshort")
E       AssertionError: ValueError not raised by ack

tests/test_object_store.py:366: AssertionError
</pre>
</details>
<h3 id="test_object_storepyobjectstoregraphwalkerteststest_child_ack_later">test_object_store.py::ObjectStoreGraphWalkerTests::test_child_ack_later</h3>
<details><summary> <pre>test_object_store.py::ObjectStoreGraphWalkerTests::test_child_ack_later</pre></summary><pre>
self = <tests.test_object_store.ObjectStoreGraphWalkerTests testMethod=test_child_ack_later>

    def test_child_ack_later(self):
        gw = self.get_walker([b"a"], {b"a": [b"b"], b"b": [b"c"], b"c": []})
>       self.assertEqual(b"a" * 40, next(gw))
E       AssertionError: b'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' != None

tests/test_object_store.py:392: AssertionError
</pre>
</details>
<h3 id="test_object_storepyobjectstoregraphwalkerteststest_descends">test_object_store.py::ObjectStoreGraphWalkerTests::test_descends</h3>
<details><summary> <pre>test_object_store.py::ObjectStoreGraphWalkerTests::test_descends</pre></summary><pre>
self = <tests.test_object_store.ObjectStoreGraphWalkerTests testMethod=test_descends>

    def test_descends(self):
        gw = self.get_walker([b"a"], {b"a": [b"b"], b"b": []})
>       self.assertEqual(b"a" * 40, next(gw))
E       AssertionError: b'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' != None

tests/test_object_store.py:376: AssertionError
</pre>
</details>
<h3 id="test_object_storepyobjectstoregraphwalkerteststest_only_once">test_object_store.py::ObjectStoreGraphWalkerTests::test_only_once</h3>
<details><summary> <pre>test_object_store.py::ObjectStoreGraphWalkerTests::test_only_once</pre></summary><pre>
self = <tests.test_object_store.ObjectStoreGraphWalkerTests testMethod=test_only_once>

    def test_only_once(self):
        # a  b
        # |  |
        # c  d
        # \ /
        #  e
        gw = self.get_walker(
            [b"a", b"b"],
            {
                b"a": [b"c"],
                b"b": [b"d"],
                b"c": [b"e"],
                b"d": [b"e"],
                b"e": [],
            },
        )
        walk = []
        acked = False
        walk.append(next(gw))
        walk.append(next(gw))
        # A branch (a, c) or (b, d) may be done after 2 steps or 3 depending on
        # the order walked: 3-step walks include (a, b, c) and (b, a, d), etc.
        if walk == [b"a" * 40, b"c" * 40] or walk == [b"b" * 40, b"d" * 40]:
            gw.ack(walk[0])
            acked = True

        walk.append(next(gw))
        if not acked and walk[2] == b"c" * 40:
            gw.ack(b"a" * 40)
        elif not acked and walk[2] == b"d" * 40:
            gw.ack(b"b" * 40)
        walk.append(next(gw))
        self.assertIs(None, next(gw))

>       self.assertEqual([b"a" * 40, b"b" * 40, b"c" * 40, b"d" * 40], sorted(walk))
E       TypeError: '<' not supported between instances of 'NoneType' and 'NoneType'

tests/test_object_store.py:431: TypeError
</pre>
</details>
<h3 id="test_object_storepyobjectstoregraphwalkerteststest_parent_present">test_object_store.py::ObjectStoreGraphWalkerTests::test_parent_present</h3>
<details><summary> <pre>test_object_store.py::ObjectStoreGraphWalkerTests::test_parent_present</pre></summary><pre>
self = <tests.test_object_store.ObjectStoreGraphWalkerTests testMethod=test_parent_present>

    def test_parent_present(self):
        gw = self.get_walker([b"a"], {b"a": [b"b"], b"b": []})
>       self.assertEqual(b"a" * 40, next(gw))
E       AssertionError: b'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' != None

tests/test_object_store.py:386: AssertionError
</pre>
</details>
<h3 id="test_object_storepycommittreechangesteststest_add_blob">test_object_store.py::CommitTreeChangesTests::test_add_blob</h3>
<details><summary> <pre>test_object_store.py::CommitTreeChangesTests::test_add_blob</pre></summary><pre>
self = <tests.test_object_store.CommitTreeChangesTests testMethod=test_add_blob>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
        self.blob_a = make_object(Blob, data=b"a")
        self.blob_b = make_object(Blob, data=b"b")
        self.blob_c = make_object(Blob, data=b"c")
        for blob in [self.blob_a, self.blob_b, self.blob_c]:
            self.store.add_object(blob)

        blobs = [
>           (b"a", self.blob_a.id, 0o100644),
            (b"ad/b", self.blob_b.id, 0o100644),
            (b"ad/bd/c", self.blob_c.id, 0o100755),
            (b"ad/c", self.blob_c.id, 0o100644),
            (b"c", self.blob_c.id, 0o100644),
        ]
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_object_store.py:447: AttributeError
</pre>
</details>
<h3 id="test_object_storepycommittreechangesteststest_add_blob_in_dir">test_object_store.py::CommitTreeChangesTests::test_add_blob_in_dir</h3>
<details><summary> <pre>test_object_store.py::CommitTreeChangesTests::test_add_blob_in_dir</pre></summary><pre>
self = <tests.test_object_store.CommitTreeChangesTests testMethod=test_add_blob_in_dir>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
        self.blob_a = make_object(Blob, data=b"a")
        self.blob_b = make_object(Blob, data=b"b")
        self.blob_c = make_object(Blob, data=b"c")
        for blob in [self.blob_a, self.blob_b, self.blob_c]:
            self.store.add_object(blob)

        blobs = [
>           (b"a", self.blob_a.id, 0o100644),
            (b"ad/b", self.blob_b.id, 0o100644),
            (b"ad/bd/c", self.blob_c.id, 0o100755),
            (b"ad/c", self.blob_c.id, 0o100644),
            (b"c", self.blob_c.id, 0o100644),
        ]
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_object_store.py:447: AttributeError
</pre>
</details>
<h3 id="test_object_storepycommittreechangesteststest_delete_blob">test_object_store.py::CommitTreeChangesTests::test_delete_blob</h3>
<details><summary> <pre>test_object_store.py::CommitTreeChangesTests::test_delete_blob</pre></summary><pre>
self = <tests.test_object_store.CommitTreeChangesTests testMethod=test_delete_blob>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
        self.blob_a = make_object(Blob, data=b"a")
        self.blob_b = make_object(Blob, data=b"b")
        self.blob_c = make_object(Blob, data=b"c")
        for blob in [self.blob_a, self.blob_b, self.blob_c]:
            self.store.add_object(blob)

        blobs = [
>           (b"a", self.blob_a.id, 0o100644),
            (b"ad/b", self.blob_b.id, 0o100644),
            (b"ad/bd/c", self.blob_c.id, 0o100755),
            (b"ad/c", self.blob_c.id, 0o100644),
            (b"c", self.blob_c.id, 0o100644),
        ]
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_object_store.py:447: AttributeError
</pre>
</details>
<h3 id="test_object_storepycommittreechangesteststest_no_changes">test_object_store.py::CommitTreeChangesTests::test_no_changes</h3>
<details><summary> <pre>test_object_store.py::CommitTreeChangesTests::test_no_changes</pre></summary><pre>
self = <tests.test_object_store.CommitTreeChangesTests testMethod=test_no_changes>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
        self.blob_a = make_object(Blob, data=b"a")
        self.blob_b = make_object(Blob, data=b"b")
        self.blob_c = make_object(Blob, data=b"c")
        for blob in [self.blob_a, self.blob_b, self.blob_c]:
            self.store.add_object(blob)

        blobs = [
>           (b"a", self.blob_a.id, 0o100644),
            (b"ad/b", self.blob_b.id, 0o100644),
            (b"ad/bd/c", self.blob_c.id, 0o100755),
            (b"ad/c", self.blob_c.id, 0o100644),
            (b"c", self.blob_c.id, 0o100644),
        ]
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_object_store.py:447: AttributeError
</pre>
</details>
<h3 id="test_object_storepytestreadpacksfiletest_read_packs">test_object_store.py::TestReadPacksFile::test_read_packs</h3>
<details><summary> <pre>test_object_store.py::TestReadPacksFile::test_read_packs</pre></summary><pre>
self = <tests.test_object_store.TestReadPacksFile testMethod=test_read_packs>

        def test_read_packs(self):
            self.assertEqual(
                ["pack-1.pack"],
>               list(
                    read_packs_file(
                        BytesIO(
                            b"""P pack-1.pack
    """
                        )
                    )
                ),
            )
E           TypeError: 'NoneType' object is not iterable

tests/test_object_store.py:525: TypeError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_chunks">test_objects.py::BlobReadTests::test_chunks</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_chunks</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_chunks>

    def test_chunks(self):
        string = b"test 5\n"
        b = Blob.from_string(string)
>       self.assertEqual([string], b.chunked)
E       AttributeError: 'NoneType' object has no attribute 'chunked'

tests/test_objects.py:136: AttributeError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_create_blob_from_string">test_objects.py::BlobReadTests::test_create_blob_from_string</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_create_blob_from_string</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_create_blob_from_string>

    def test_create_blob_from_string(self):
        string = b"test 2\n"
        b = Blob.from_string(string)
>       self.assertEqual(b.data, string)
E       AttributeError: 'NoneType' object has no attribute 'data'

tests/test_objects.py:118: AttributeError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_decompress_simple_blob">test_objects.py::BlobReadTests::test_decompress_simple_blob</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_decompress_simple_blob</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_decompress_simple_blob>

    def test_decompress_simple_blob(self):
>       b = self.get_blob(a_sha)

tests/test_objects.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:88: in get_blob
    return self.get_sha_file(Blob, "blobs", sha)
tests/test_objects.py:84: in get_sha_file
    return cls.from_path(hex_to_filename(dir, sha))
dulwich/objects.py:55: in hex_to_filename
    dir = os.path.join(path, hex[:2])
/usr/lib/python3.10/posixpath.py:90: in join
    genericpath._check_arg_types('join', a, *p)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

funcname = 'join', args = ('/testbed/tests/../testdata/blobs', b'6f')
hasstr = True, hasbytes = True, s = b'6f'

    def _check_arg_types(funcname, *args):
        hasstr = hasbytes = False
        for s in args:
            if isinstance(s, str):
                hasstr = True
            elif isinstance(s, bytes):
                hasbytes = True
            else:
                raise TypeError(f'{funcname}() argument must be str, bytes, or '
                                f'os.PathLike object, not {s.__class__.__name__!r}') from None
        if hasstr and hasbytes:
>           raise TypeError("Can't mix strings and bytes in path components") from None
E           TypeError: Can't mix strings and bytes in path components

/usr/lib/python3.10/genericpath.py:155: TypeError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_eq">test_objects.py::BlobReadTests::test_eq</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_eq</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_eq>

    def test_eq(self):
>       blob1 = self.get_blob(a_sha)

tests/test_objects.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:88: in get_blob
    return self.get_sha_file(Blob, "blobs", sha)
tests/test_objects.py:84: in get_sha_file
    return cls.from_path(hex_to_filename(dir, sha))
dulwich/objects.py:55: in hex_to_filename
    dir = os.path.join(path, hex[:2])
/usr/lib/python3.10/posixpath.py:90: in join
    genericpath._check_arg_types('join', a, *p)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

funcname = 'join', args = ('/testbed/tests/../testdata/blobs', b'6f')
hasstr = True, hasbytes = True, s = b'6f'

    def _check_arg_types(funcname, *args):
        hasstr = hasbytes = False
        for s in args:
            if isinstance(s, str):
                hasstr = True
            elif isinstance(s, bytes):
                hasbytes = True
            else:
                raise TypeError(f'{funcname}() argument must be str, bytes, or '
                                f'os.PathLike object, not {s.__class__.__name__!r}') from None
        if hasstr and hasbytes:
>           raise TypeError("Can't mix strings and bytes in path components") from None
E           TypeError: Can't mix strings and bytes in path components

/usr/lib/python3.10/genericpath.py:155: TypeError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_hash">test_objects.py::BlobReadTests::test_hash</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_hash</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_hash>

    def test_hash(self):
>       b = self.get_blob(a_sha)

tests/test_objects.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:88: in get_blob
    return self.get_sha_file(Blob, "blobs", sha)
tests/test_objects.py:84: in get_sha_file
    return cls.from_path(hex_to_filename(dir, sha))
dulwich/objects.py:55: in hex_to_filename
    dir = os.path.join(path, hex[:2])
/usr/lib/python3.10/posixpath.py:90: in join
    genericpath._check_arg_types('join', a, *p)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

funcname = 'join', args = ('/testbed/tests/../testdata/blobs', b'6f')
hasstr = True, hasbytes = True, s = b'6f'

    def _check_arg_types(funcname, *args):
        hasstr = hasbytes = False
        for s in args:
            if isinstance(s, str):
                hasstr = True
            elif isinstance(s, bytes):
                hasbytes = True
            else:
                raise TypeError(f'{funcname}() argument must be str, bytes, or '
                                f'os.PathLike object, not {s.__class__.__name__!r}') from None
        if hasstr and hasbytes:
>           raise TypeError("Can't mix strings and bytes in path components") from None
E           TypeError: Can't mix strings and bytes in path components

/usr/lib/python3.10/genericpath.py:155: TypeError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_legacy_from_file">test_objects.py::BlobReadTests::test_legacy_from_file</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_legacy_from_file</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_legacy_from_file>

    def test_legacy_from_file(self):
        b1 = Blob.from_string(b"foo")
>       b_raw = b1.as_legacy_object()
E       AttributeError: 'NoneType' object has no attribute 'as_legacy_object'

tests/test_objects.py:123: AttributeError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_legacy_from_file_compression_level">test_objects.py::BlobReadTests::test_legacy_from_file_compression_level</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_legacy_from_file_compression_level</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_legacy_from_file_compression_level>

    def test_legacy_from_file_compression_level(self):
        b1 = Blob.from_string(b"foo")
>       b_raw = b1.as_legacy_object(compression_level=6)
E       AttributeError: 'NoneType' object has no attribute 'as_legacy_object'

tests/test_objects.py:129: AttributeError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_parse_empty_blob_object">test_objects.py::BlobReadTests::test_parse_empty_blob_object</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_parse_empty_blob_object</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_parse_empty_blob_object>

    def test_parse_empty_blob_object(self):
        sha = b"e69de29bb2d1d6434b8b29ae775ad8c2e48c5391"
>       b = self.get_blob(sha)

tests/test_objects.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:88: in get_blob
    return self.get_sha_file(Blob, "blobs", sha)
tests/test_objects.py:84: in get_sha_file
    return cls.from_path(hex_to_filename(dir, sha))
dulwich/objects.py:55: in hex_to_filename
    dir = os.path.join(path, hex[:2])
/usr/lib/python3.10/posixpath.py:90: in join
    genericpath._check_arg_types('join', a, *p)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

funcname = 'join', args = ('/testbed/tests/../testdata/blobs', b'e6')
hasstr = True, hasbytes = True, s = b'e6'

    def _check_arg_types(funcname, *args):
        hasstr = hasbytes = False
        for s in args:
            if isinstance(s, str):
                hasstr = True
            elif isinstance(s, bytes):
                hasbytes = True
            else:
                raise TypeError(f'{funcname}() argument must be str, bytes, or '
                                f'os.PathLike object, not {s.__class__.__name__!r}') from None
        if hasstr and hasbytes:
>           raise TypeError("Can't mix strings and bytes in path components") from None
E           TypeError: Can't mix strings and bytes in path components

/usr/lib/python3.10/genericpath.py:155: TypeError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_parse_legacy_blob">test_objects.py::BlobReadTests::test_parse_legacy_blob</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_parse_legacy_blob</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_parse_legacy_blob>

    def test_parse_legacy_blob(self):
        string = b"test 3\n"
>       b = self.get_blob(c_sha)

tests/test_objects.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:88: in get_blob
    return self.get_sha_file(Blob, "blobs", sha)
tests/test_objects.py:84: in get_sha_file
    return cls.from_path(hex_to_filename(dir, sha))
dulwich/objects.py:55: in hex_to_filename
    dir = os.path.join(path, hex[:2])
/usr/lib/python3.10/posixpath.py:90: in join
    genericpath._check_arg_types('join', a, *p)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

funcname = 'join', args = ('/testbed/tests/../testdata/blobs', b'95')
hasstr = True, hasbytes = True, s = b'95'

    def _check_arg_types(funcname, *args):
        hasstr = hasbytes = False
        for s in args:
            if isinstance(s, str):
                hasstr = True
            elif isinstance(s, bytes):
                hasbytes = True
            else:
                raise TypeError(f'{funcname}() argument must be str, bytes, or '
                                f'os.PathLike object, not {s.__class__.__name__!r}') from None
        if hasstr and hasbytes:
>           raise TypeError("Can't mix strings and bytes in path components") from None
E           TypeError: Can't mix strings and bytes in path components

/usr/lib/python3.10/genericpath.py:155: TypeError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_read_commit_from_file">test_objects.py::BlobReadTests::test_read_commit_from_file</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_read_commit_from_file</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_read_commit_from_file>

    def test_read_commit_from_file(self):
        sha = b"60dacdc733de308bb77bb76ce0fb0f9b44c9769e"
>       c = self.commit(sha)

tests/test_objects.py:220: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:97: in commit
    return self.get_sha_file(Commit, "commits", sha)
tests/test_objects.py:84: in get_sha_file
    return cls.from_path(hex_to_filename(dir, sha))
dulwich/objects.py:55: in hex_to_filename
    dir = os.path.join(path, hex[:2])
/usr/lib/python3.10/posixpath.py:90: in join
    genericpath._check_arg_types('join', a, *p)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

funcname = 'join', args = ('/testbed/tests/../testdata/commits', b'60')
hasstr = True, hasbytes = True, s = b'60'

    def _check_arg_types(funcname, *args):
        hasstr = hasbytes = False
        for s in args:
            if isinstance(s, str):
                hasstr = True
            elif isinstance(s, bytes):
                hasbytes = True
            else:
                raise TypeError(f'{funcname}() argument must be str, bytes, or '
                                f'os.PathLike object, not {s.__class__.__name__!r}') from None
        if hasstr and hasbytes:
>           raise TypeError("Can't mix strings and bytes in path components") from None
E           TypeError: Can't mix strings and bytes in path components

/usr/lib/python3.10/genericpath.py:155: TypeError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_read_commit_no_parents">test_objects.py::BlobReadTests::test_read_commit_no_parents</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_read_commit_no_parents</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_read_commit_no_parents>

    def test_read_commit_no_parents(self):
        sha = b"0d89f20333fbb1d2f3a94da77f4981373d8f4310"
>       c = self.commit(sha)

tests/test_objects.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:97: in commit
    return self.get_sha_file(Commit, "commits", sha)
tests/test_objects.py:84: in get_sha_file
    return cls.from_path(hex_to_filename(dir, sha))
dulwich/objects.py:55: in hex_to_filename
    dir = os.path.join(path, hex[:2])
/usr/lib/python3.10/posixpath.py:90: in join
    genericpath._check_arg_types('join', a, *p)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

funcname = 'join', args = ('/testbed/tests/../testdata/commits', b'0d')
hasstr = True, hasbytes = True, s = b'0d'

    def _check_arg_types(funcname, *args):
        hasstr = hasbytes = False
        for s in args:
            if isinstance(s, str):
                hasstr = True
            elif isinstance(s, bytes):
                hasbytes = True
            else:
                raise TypeError(f'{funcname}() argument must be str, bytes, or '
                                f'os.PathLike object, not {s.__class__.__name__!r}') from None
        if hasstr and hasbytes:
>           raise TypeError("Can't mix strings and bytes in path components") from None
E           TypeError: Can't mix strings and bytes in path components

/usr/lib/python3.10/genericpath.py:155: TypeError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_read_commit_two_parents">test_objects.py::BlobReadTests::test_read_commit_two_parents</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_read_commit_two_parents</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_read_commit_two_parents>

    def test_read_commit_two_parents(self):
        sha = b"5dac377bdded4c9aeb8dff595f0faeebcc8498cc"
>       c = self.commit(sha)

tests/test_objects.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:97: in commit
    return self.get_sha_file(Commit, "commits", sha)
tests/test_objects.py:84: in get_sha_file
    return cls.from_path(hex_to_filename(dir, sha))
dulwich/objects.py:55: in hex_to_filename
    dir = os.path.join(path, hex[:2])
/usr/lib/python3.10/posixpath.py:90: in join
    genericpath._check_arg_types('join', a, *p)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

funcname = 'join', args = ('/testbed/tests/../testdata/commits', b'5d')
hasstr = True, hasbytes = True, s = b'5d'

    def _check_arg_types(funcname, *args):
        hasstr = hasbytes = False
        for s in args:
            if isinstance(s, str):
                hasstr = True
            elif isinstance(s, bytes):
                hasbytes = True
            else:
                raise TypeError(f'{funcname}() argument must be str, bytes, or '
                                f'os.PathLike object, not {s.__class__.__name__!r}') from None
        if hasstr and hasbytes:
>           raise TypeError("Can't mix strings and bytes in path components") from None
E           TypeError: Can't mix strings and bytes in path components

/usr/lib/python3.10/genericpath.py:155: TypeError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_read_tag_from_file">test_objects.py::BlobReadTests::test_read_tag_from_file</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_read_tag_from_file</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_read_tag_from_file>

    def test_read_tag_from_file(self):
>       t = self.get_tag(tag_sha)

tests/test_objects.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:94: in get_tag
    return self.get_sha_file(Tag, "tags", sha)
tests/test_objects.py:84: in get_sha_file
    return cls.from_path(hex_to_filename(dir, sha))
dulwich/objects.py:55: in hex_to_filename
    dir = os.path.join(path, hex[:2])
/usr/lib/python3.10/posixpath.py:90: in join
    genericpath._check_arg_types('join', a, *p)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

funcname = 'join', args = ('/testbed/tests/../testdata/tags', b'71')
hasstr = True, hasbytes = True, s = b'71'

    def _check_arg_types(funcname, *args):
        hasstr = hasbytes = False
        for s in args:
            if isinstance(s, str):
                hasstr = True
            elif isinstance(s, bytes):
                hasbytes = True
            else:
                raise TypeError(f'{funcname}() argument must be str, bytes, or '
                                f'os.PathLike object, not {s.__class__.__name__!r}') from None
        if hasstr and hasbytes:
>           raise TypeError("Can't mix strings and bytes in path components") from None
E           TypeError: Can't mix strings and bytes in path components

/usr/lib/python3.10/genericpath.py:155: TypeError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_read_tree_from_file">test_objects.py::BlobReadTests::test_read_tree_from_file</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_read_tree_from_file</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_read_tree_from_file>

    def test_read_tree_from_file(self):
>       t = self.get_tree(tree_sha)

tests/test_objects.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:91: in get_tree
    return self.get_sha_file(Tree, "trees", sha)
tests/test_objects.py:84: in get_sha_file
    return cls.from_path(hex_to_filename(dir, sha))
dulwich/objects.py:55: in hex_to_filename
    dir = os.path.join(path, hex[:2])
/usr/lib/python3.10/posixpath.py:90: in join
    genericpath._check_arg_types('join', a, *p)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

funcname = 'join', args = ('/testbed/tests/../testdata/trees', b'70')
hasstr = True, hasbytes = True, s = b'70'

    def _check_arg_types(funcname, *args):
        hasstr = hasbytes = False
        for s in args:
            if isinstance(s, str):
                hasstr = True
            elif isinstance(s, bytes):
                hasbytes = True
            else:
                raise TypeError(f'{funcname}() argument must be str, bytes, or '
                                f'os.PathLike object, not {s.__class__.__name__!r}') from None
        if hasstr and hasbytes:
>           raise TypeError("Can't mix strings and bytes in path components") from None
E           TypeError: Can't mix strings and bytes in path components

/usr/lib/python3.10/genericpath.py:155: TypeError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_read_tree_from_file_parse_count">test_objects.py::BlobReadTests::test_read_tree_from_file_parse_count</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_read_tree_from_file_parse_count</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_read_tree_from_file_parse_count>

    def test_read_tree_from_file_parse_count(self):
        old_deserialize = Tree._deserialize

        def reset_deserialize():
            Tree._deserialize = old_deserialize

        self.addCleanup(reset_deserialize)
        self.deserialize_count = 0

        def counting_deserialize(*args, **kwargs):
            self.deserialize_count += 1
            return old_deserialize(*args, **kwargs)

        Tree._deserialize = counting_deserialize
>       t = self.get_tree(tree_sha)

tests/test_objects.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:91: in get_tree
    return self.get_sha_file(Tree, "trees", sha)
tests/test_objects.py:84: in get_sha_file
    return cls.from_path(hex_to_filename(dir, sha))
dulwich/objects.py:55: in hex_to_filename
    dir = os.path.join(path, hex[:2])
/usr/lib/python3.10/posixpath.py:90: in join
    genericpath._check_arg_types('join', a, *p)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

funcname = 'join', args = ('/testbed/tests/../testdata/trees', b'70')
hasstr = True, hasbytes = True, s = b'70'

    def _check_arg_types(funcname, *args):
        hasstr = hasbytes = False
        for s in args:
            if isinstance(s, str):
                hasstr = True
            elif isinstance(s, bytes):
                hasbytes = True
            else:
                raise TypeError(f'{funcname}() argument must be str, bytes, or '
                                f'os.PathLike object, not {s.__class__.__name__!r}') from None
        if hasstr and hasbytes:
>           raise TypeError("Can't mix strings and bytes in path components") from None
E           TypeError: Can't mix strings and bytes in path components

/usr/lib/python3.10/genericpath.py:155: TypeError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_set_chunks">test_objects.py::BlobReadTests::test_set_chunks</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_set_chunks</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_set_chunks>

    def test_set_chunks(self):
        b = Blob()
        b.chunked = [b"te", b"st", b" 5\n"]
        self.assertEqual(b"test 5\n", b.data)
        b.chunked = [b"te", b"st", b" 6\n"]
>       self.assertEqual(b"test 6\n", b.as_raw_string())
E       AssertionError: b'test 6\n' != None

tests/test_objects.py:159: AssertionError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_splitlines">test_objects.py::BlobReadTests::test_splitlines</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_splitlines</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_splitlines>

    def test_splitlines(self):
        for case in [
            [],
            [b"foo\nbar\n"],
            [b"bl\na", b"blie"],
            [b"bl\na", b"blie", b"bloe\n"],
            [b"", b"bl\na", b"blie", b"bloe\n"],
            [b"", b"", b"", b"bla\n"],
            [b"", b"", b"", b"bla\n", b""],
            [b"bl", b"", b"a\naaa"],
            [b"a\naaa", b"a"],
        ]:
            b = Blob()
            b.chunked = case
>           self.assertEqual(b.data.splitlines(True), b.splitlines())
E           AssertionError: Lists differ: [] != [b'']
E           
E           Second list contains 1 additional elements.
E           First extra element 0:
E           b''
E           
E           - []
E           + [b'']

tests/test_objects.py:152: AssertionError
</pre>
</details>
<h3 id="test_objectspyblobreadteststest_stub_sha">test_objects.py::BlobReadTests::test_stub_sha</h3>
<details><summary> <pre>test_objects.py::BlobReadTests::test_stub_sha</pre></summary><pre>
self = <tests.test_objects.BlobReadTests testMethod=test_stub_sha>

    def test_stub_sha(self):
        sha = b"5" * 40
        c = make_commit(id=sha, message=b"foo")
>       self.assertIsInstance(c, Commit)
E       AssertionError: None is not an instance of <class 'dulwich.objects.Commit'>

tests/test_objects.py:263: AssertionError
</pre>
</details>
<h3 id="test_objectspyshafileteststest_deflated_smaller_window_buffer">test_objects.py::ShaFileTests::test_deflated_smaller_window_buffer</h3>
<details><summary> <pre>test_objects.py::ShaFileTests::test_deflated_smaller_window_buffer</pre></summary><pre>
self = <tests.test_objects.ShaFileTests testMethod=test_deflated_smaller_window_buffer>

    def test_deflated_smaller_window_buffer(self):
        # zlib on some systems uses smaller buffers,
        # resulting in a different header.
        # See https://github.com/libgit2/libgit2/pull/464
        sf = ShaFile.from_file(BytesIO(small_buffer_zlib_object))
>       self.assertEqual(sf.type_name, b"tag")
E       AttributeError: 'NoneType' object has no attribute 'type_name'

tests/test_objects.py:304: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitserializationteststest_deserialize">test_objects.py::CommitSerializationTests::test_deserialize</h3>
<details><summary> <pre>test_objects.py::CommitSerializationTests::test_deserialize</pre></summary><pre>
self = <tests.test_objects.CommitSerializationTests testMethod=test_deserialize>

    def test_deserialize(self):
        c = self.make_commit()
        d = Commit()
>       d._deserialize(c.as_raw_chunks())
E       AttributeError: 'Commit' object has no attribute '_deserialize'

tests/test_objects.py:378: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitserializationteststest_deserialize_mergetag">test_objects.py::CommitSerializationTests::test_deserialize_mergetag</h3>
<details><summary> <pre>test_objects.py::CommitSerializationTests::test_deserialize_mergetag</pre></summary><pre>
self = <tests.test_objects.CommitSerializationTests testMethod=test_deserialize_mergetag>

    def test_deserialize_mergetag(self):
        tag = make_object(
            Tag,
            object=(Commit, b"a38d6181ff27824c79fc7df825164a212eff6a3f"),
            object_type_name=b"commit",
            name=b"v2.6.22-rc7",
            tag_time=1183319674,
            tag_timezone=0,
            tagger=b"Linus Torvalds <torvalds@woody.linux-foundation.org>",
            message=default_message,
        )
        commit = self.make_commit(mergetag=[tag])

        d = Commit()
>       d._deserialize(commit.as_raw_chunks())
E       AttributeError: 'Commit' object has no attribute '_deserialize'

tests/test_objects.py:535: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitserializationteststest_deserialize_mergetags">test_objects.py::CommitSerializationTests::test_deserialize_mergetags</h3>
<details><summary> <pre>test_objects.py::CommitSerializationTests::test_deserialize_mergetags</pre></summary><pre>
self = <tests.test_objects.CommitSerializationTests testMethod=test_deserialize_mergetags>

    def test_deserialize_mergetags(self):
        tag = make_object(
            Tag,
            object=(Commit, b"a38d6181ff27824c79fc7df825164a212eff6a3f"),
            object_type_name=b"commit",
            name=b"v2.6.22-rc7",
            tag_time=1183319674,
            tag_timezone=0,
            tagger=b"Linus Torvalds <torvalds@woody.linux-foundation.org>",
            message=default_message,
        )
        commit = self.make_commit(mergetag=[tag, tag])

        d = Commit()
>       d._deserialize(commit.as_raw_chunks())
E       AttributeError: 'Commit' object has no attribute '_deserialize'

tests/test_objects.py:552: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitserializationteststest_encoding">test_objects.py::CommitSerializationTests::test_encoding</h3>
<details><summary> <pre>test_objects.py::CommitSerializationTests::test_encoding</pre></summary><pre>
self = <tests.test_objects.CommitSerializationTests testMethod=test_encoding>

    def test_encoding(self):
        c = self.make_commit(encoding=b"iso8859-1")
>       self.assertIn(b"encoding iso8859-1\n", c.as_raw_string())
E       AttributeError: 'NoneType' object has no attribute 'as_raw_string'

tests/test_objects.py:329: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitserializationteststest_full_tree">test_objects.py::CommitSerializationTests::test_full_tree</h3>
<details><summary> <pre>test_objects.py::CommitSerializationTests::test_full_tree</pre></summary><pre>
self = <tests.test_objects.CommitSerializationTests testMethod=test_full_tree>

    def test_full_tree(self):
        c = self.make_commit(commit_time=30)
        t = Tree()
        t.add(b"data-x", 0o644, Blob().id)
>       c.tree = t
E       AttributeError: 'NoneType' object has no attribute 'tree'

tests/test_objects.py:341: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitserializationteststest_neg_timezone">test_objects.py::CommitSerializationTests::test_neg_timezone</h3>
<details><summary> <pre>test_objects.py::CommitSerializationTests::test_neg_timezone</pre></summary><pre>
self = <tests.test_objects.CommitSerializationTests testMethod=test_neg_timezone>

    def test_neg_timezone(self):
        c = self.make_commit(commit_timezone=(-1 * 3600))
>       self.assertIn(b" -0100\n", c.as_raw_string())
E       AttributeError: 'NoneType' object has no attribute 'as_raw_string'

tests/test_objects.py:373: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitserializationteststest_raw_length">test_objects.py::CommitSerializationTests::test_raw_length</h3>
<details><summary> <pre>test_objects.py::CommitSerializationTests::test_raw_length</pre></summary><pre>
self = <tests.test_objects.CommitSerializationTests testMethod=test_raw_length>

    def test_raw_length(self):
        c = self.make_commit()
>       self.assertEqual(len(c.as_raw_string()), c.raw_length())
E       AttributeError: 'NoneType' object has no attribute 'as_raw_string'

tests/test_objects.py:349: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitserializationteststest_serialize_gpgsig">test_objects.py::CommitSerializationTests::test_serialize_gpgsig</h3>
<details><summary> <pre>test_objects.py::CommitSerializationTests::test_serialize_gpgsig</pre></summary><pre>
self = <tests.test_objects.CommitSerializationTests testMethod=test_serialize_gpgsig>

        def test_serialize_gpgsig(self):
            commit = self.make_commit(
                gpgsig=b"""-----BEGIN PGP SIGNATURE-----
    Version: GnuPG v1

    iQIcBAABCgAGBQJULCdfAAoJEACAbyvXKaRXuKwP/RyP9PA49uAvu8tQVCC/uBa8
    vi975+xvO14R8Pp8k2nps7lSxCdtCd+xVT1VRHs0wNhOZo2YCVoU1HATkPejqSeV
    NScTHcxnk4/+bxyfk14xvJkNp7FlQ3npmBkA+lbV0Ubr33rvtIE5jiJPyz+SgWAg
    xdBG2TojV0squj00GoH/euK6aX7GgZtwdtpTv44haCQdSuPGDcI4TORqR6YSqvy3
    GPE+3ZqXPFFb+KILtimkxitdwB7CpwmNse2vE3rONSwTvi8nq3ZoQYNY73CQGkUy
    qoFU0pDtw87U3niFin1ZccDgH0bB6624sLViqrjcbYJeg815Htsu4rmzVaZADEVC
    XhIO4MThebusdk0AcNGjgpf3HRHk0DPMDDlIjm+Oao0cqovvF6VyYmcb0C+RmhJj
    dodLXMNmbqErwTk3zEkW0yZvNIYXH7m9SokPCZa4eeIM7be62X6h1mbt0/IU6Th+
    v18fS0iTMP/Viug5und+05C/v04kgDo0CPphAbXwWMnkE4B6Tl9sdyUYXtvQsL7x
    0+WP1gL27ANqNZiI07Kz/BhbBAQI/+2TFT7oGr0AnFPQ5jHp+3GpUf6OKuT1wT3H
    ND189UFuRuubxb42vZhpcXRbqJVWnbECTKVUPsGZqat3enQUB63uM4i6/RdONDZA
    fDeF1m4qYs+cUXKNUZ03
    =X6RT
    -----END PGP SIGNATURE-----"""
            )
            self.maxDiff = None
            self.assertEqual(
                b"""\
    tree d80c186a03f423a81b39df39dc87fd269736ca86
    parent ab64bbdcc51b170d21588e5c5d391ee5c0c96dfd
    parent 4cffe90e0a41ad3f5190079d7c8f036bde29cbe6
    author James Westby <jw+debian@jameswestby.net> 1174773719 +0000
    committer James Westby <jw+debian@jameswestby.net> 1174773719 +0000
    gpgsig -----BEGIN PGP SIGNATURE-----
     Version: GnuPG v1

     iQIcBAABCgAGBQJULCdfAAoJEACAbyvXKaRXuKwP/RyP9PA49uAvu8tQVCC/uBa8
     vi975+xvO14R8Pp8k2nps7lSxCdtCd+xVT1VRHs0wNhOZo2YCVoU1HATkPejqSeV
     NScTHcxnk4/+bxyfk14xvJkNp7FlQ3npmBkA+lbV0Ubr33rvtIE5jiJPyz+SgWAg
     xdBG2TojV0squj00GoH/euK6aX7GgZtwdtpTv44haCQdSuPGDcI4TORqR6YSqvy3
     GPE+3ZqXPFFb+KILtimkxitdwB7CpwmNse2vE3rONSwTvi8nq3ZoQYNY73CQGkUy
     qoFU0pDtw87U3niFin1ZccDgH0bB6624sLViqrjcbYJeg815Htsu4rmzVaZADEVC
     XhIO4MThebusdk0AcNGjgpf3HRHk0DPMDDlIjm+Oao0cqovvF6VyYmcb0C+RmhJj
     dodLXMNmbqErwTk3zEkW0yZvNIYXH7m9SokPCZa4eeIM7be62X6h1mbt0/IU6Th+
     v18fS0iTMP/Viug5und+05C/v04kgDo0CPphAbXwWMnkE4B6Tl9sdyUYXtvQsL7x
     0+WP1gL27ANqNZiI07Kz/BhbBAQI/+2TFT7oGr0AnFPQ5jHp+3GpUf6OKuT1wT3H
     ND189UFuRuubxb42vZhpcXRbqJVWnbECTKVUPsGZqat3enQUB63uM4i6/RdONDZA
     fDeF1m4qYs+cUXKNUZ03
     =X6RT
     -----END PGP SIGNATURE-----

    Merge ../b
    """,
>               commit.as_raw_string(),
            )
E           AttributeError: 'NoneType' object has no attribute 'as_raw_string'

tests/test_objects.py:429: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitserializationteststest_serialize_mergetag">test_objects.py::CommitSerializationTests::test_serialize_mergetag</h3>
<details><summary> <pre>test_objects.py::CommitSerializationTests::test_serialize_mergetag</pre></summary><pre>
self = <tests.test_objects.CommitSerializationTests testMethod=test_serialize_mergetag>

        def test_serialize_mergetag(self):
            tag = make_object(
                Tag,
                object=(Commit, b"a38d6181ff27824c79fc7df825164a212eff6a3f"),
                object_type_name=b"commit",
                name=b"v2.6.22-rc7",
                tag_time=1183319674,
                tag_timezone=0,
                tagger=b"Linus Torvalds <torvalds@woody.linux-foundation.org>",
                message=default_message,
            )
            commit = self.make_commit(mergetag=[tag])

            self.assertEqual(
                b"""tree d80c186a03f423a81b39df39dc87fd269736ca86
    parent ab64bbdcc51b170d21588e5c5d391ee5c0c96dfd
    parent 4cffe90e0a41ad3f5190079d7c8f036bde29cbe6
    author James Westby <jw+debian@jameswestby.net> 1174773719 +0000
    committer James Westby <jw+debian@jameswestby.net> 1174773719 +0000
    mergetag object a38d6181ff27824c79fc7df825164a212eff6a3f
     type commit
     tag v2.6.22-rc7
     tagger Linus Torvalds <torvalds@woody.linux-foundation.org> 1183319674 +0000

     Linux 2.6.22-rc7
     -----BEGIN PGP SIGNATURE-----
     Version: GnuPG v1.4.7 (GNU/Linux)

     iD8DBQBGiAaAF3YsRnbiHLsRAitMAKCiLboJkQECM/jpYsY3WPfvUgLXkACgg3ql
     OK2XeQOiEeXtT76rV4t2WR4=
     =ivrA
     -----END PGP SIGNATURE-----

    Merge ../b
    """,
>               commit.as_raw_string(),
            )
E           AttributeError: 'NoneType' object has no attribute 'as_raw_string'

tests/test_objects.py:467: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitserializationteststest_serialize_mergetags">test_objects.py::CommitSerializationTests::test_serialize_mergetags</h3>
<details><summary> <pre>test_objects.py::CommitSerializationTests::test_serialize_mergetags</pre></summary><pre>
self = <tests.test_objects.CommitSerializationTests testMethod=test_serialize_mergetags>

        def test_serialize_mergetags(self):
            tag = make_object(
                Tag,
                object=(Commit, b"a38d6181ff27824c79fc7df825164a212eff6a3f"),
                object_type_name=b"commit",
                name=b"v2.6.22-rc7",
                tag_time=1183319674,
                tag_timezone=0,
                tagger=b"Linus Torvalds <torvalds@woody.linux-foundation.org>",
                message=default_message,
            )
            commit = self.make_commit(mergetag=[tag, tag])

            self.assertEqual(
                b"""tree d80c186a03f423a81b39df39dc87fd269736ca86
    parent ab64bbdcc51b170d21588e5c5d391ee5c0c96dfd
    parent 4cffe90e0a41ad3f5190079d7c8f036bde29cbe6
    author James Westby <jw+debian@jameswestby.net> 1174773719 +0000
    committer James Westby <jw+debian@jameswestby.net> 1174773719 +0000
    mergetag object a38d6181ff27824c79fc7df825164a212eff6a3f
     type commit
     tag v2.6.22-rc7
     tagger Linus Torvalds <torvalds@woody.linux-foundation.org> 1183319674 +0000

     Linux 2.6.22-rc7
     -----BEGIN PGP SIGNATURE-----
     Version: GnuPG v1.4.7 (GNU/Linux)

     iD8DBQBGiAaAF3YsRnbiHLsRAitMAKCiLboJkQECM/jpYsY3WPfvUgLXkACgg3ql
     OK2XeQOiEeXtT76rV4t2WR4=
     =ivrA
     -----END PGP SIGNATURE-----
    mergetag object a38d6181ff27824c79fc7df825164a212eff6a3f
     type commit
     tag v2.6.22-rc7
     tagger Linus Torvalds <torvalds@woody.linux-foundation.org> 1183319674 +0000

     Linux 2.6.22-rc7
     -----BEGIN PGP SIGNATURE-----
     Version: GnuPG v1.4.7 (GNU/Linux)

     iD8DBQBGiAaAF3YsRnbiHLsRAitMAKCiLboJkQECM/jpYsY3WPfvUgLXkACgg3ql
     OK2XeQOiEeXtT76rV4t2WR4=
     =ivrA
     -----END PGP SIGNATURE-----

    Merge ../b
    """,
>               commit.as_raw_string(),
            )
E           AttributeError: 'NoneType' object has no attribute 'as_raw_string'

tests/test_objects.py:518: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitserializationteststest_short_timestamp">test_objects.py::CommitSerializationTests::test_short_timestamp</h3>
<details><summary> <pre>test_objects.py::CommitSerializationTests::test_short_timestamp</pre></summary><pre>
self = <tests.test_objects.CommitSerializationTests testMethod=test_short_timestamp>

    def test_short_timestamp(self):
        c = self.make_commit(commit_time=30)
        c1 = Commit()
>       c1.set_raw_string(c.as_raw_string())
E       AttributeError: 'NoneType' object has no attribute 'as_raw_string'

tests/test_objects.py:334: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitserializationteststest_simple">test_objects.py::CommitSerializationTests::test_simple</h3>
<details><summary> <pre>test_objects.py::CommitSerializationTests::test_simple</pre></summary><pre>
self = <tests.test_objects.CommitSerializationTests testMethod=test_simple>

    def test_simple(self):
        c = self.make_commit()
>       self.assertEqual(c.id, b"5dac377bdded4c9aeb8dff595f0faeebcc8498cc")
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_objects.py:353: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitserializationteststest_timezone">test_objects.py::CommitSerializationTests::test_timezone</h3>
<details><summary> <pre>test_objects.py::CommitSerializationTests::test_timezone</pre></summary><pre>
self = <tests.test_objects.CommitSerializationTests testMethod=test_timezone>

    def test_timezone(self):
        c = self.make_commit(commit_timezone=(5 * 60))
>       self.assertIn(b" +0005\n", c.as_raw_string())
E       AttributeError: 'NoneType' object has no attribute 'as_raw_string'

tests/test_objects.py:369: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitparseteststest_check">test_objects.py::CommitParseTests::test_check</h3>
<details><summary> <pre>test_objects.py::CommitParseTests::test_check</pre></summary><pre>
self = <tests.test_objects.CommitParseTests testMethod=test_check>

    def test_check(self):
        self.assertCheckSucceeds(Commit, self.make_commit_text())
        self.assertCheckSucceeds(Commit, self.make_commit_text(parents=None))
        self.assertCheckSucceeds(Commit, self.make_commit_text(encoding=b"UTF-8"))

>       self.assertCheckFails(Commit, self.make_commit_text(tree=b"xxx"))

tests/test_objects.py:632: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:276: in assertCheckFails
    self.assertRaises(ObjectFormatException, do_check)
E   AssertionError: ObjectFormatException not raised by do_check
</pre>
</details>
<h3 id="test_objectspycommitparseteststest_check_commit_with_overflow_date">test_objects.py::CommitParseTests::test_check_commit_with_overflow_date</h3>
<details><summary> <pre>test_objects.py::CommitParseTests::test_check_commit_with_overflow_date</pre></summary><pre>
self = <tests.test_objects.CommitParseTests testMethod=test_check_commit_with_overflow_date>

    def test_check_commit_with_overflow_date(self):
        """Date with overflow should raise an ObjectFormatException when checked."""
        identity_with_wrong_time = (
            b"Igor Sysoev <igor@sysoev.ru> 18446743887488505614 +42707004"
        )
        commit0 = Commit.from_string(
            self.make_commit_text(
                author=identity_with_wrong_time, committer=default_committer
            )
        )
        commit1 = Commit.from_string(
            self.make_commit_text(
                author=default_committer, committer=identity_with_wrong_time
            )
        )

        # Those fails when triggering the check() method
        for commit in [commit0, commit1]:
            with self.assertRaises(ObjectFormatException):
>               commit.check()
E               AttributeError: 'NoneType' object has no attribute 'check'

tests/test_objects.py:706: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitparseteststest_check_commit_with_unparseable_time">test_objects.py::CommitParseTests::test_check_commit_with_unparseable_time</h3>
<details><summary> <pre>test_objects.py::CommitParseTests::test_check_commit_with_unparseable_time</pre></summary><pre>
self = <tests.test_objects.CommitParseTests testMethod=test_check_commit_with_unparseable_time>

    def test_check_commit_with_unparseable_time(self):
        identity_with_wrong_time = (
            b"Igor Sysoev <igor@sysoev.ru> 18446743887488505614+42707004"
        )

        # Those fail at reading time
>       self.assertCheckFails(
            Commit,
            self.make_commit_text(
                author=default_committer, committer=identity_with_wrong_time
            ),
        )

tests/test_objects.py:674: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:276: in assertCheckFails
    self.assertRaises(ObjectFormatException, do_check)
E   AssertionError: ObjectFormatException not raised by do_check
</pre>
</details>
<h3 id="test_objectspycommitparseteststest_check_duplicates">test_objects.py::CommitParseTests::test_check_duplicates</h3>
<details><summary> <pre>test_objects.py::CommitParseTests::test_check_duplicates</pre></summary><pre>
self = <tests.test_objects.CommitParseTests testMethod=test_check_duplicates>

    def test_check_duplicates(self):
        # duplicate each of the header fields
        for i in range(5):
            lines = self.make_commit_lines(parents=[a_sha], encoding=b"UTF-8")
            lines.insert(i, lines[i])
            text = b"\n".join(lines)
            if lines[i].startswith(b"parent"):
                # duplicate parents are ok for now
                self.assertCheckSucceeds(Commit, text)
            else:
>               self.assertCheckFails(Commit, text)

tests/test_objects.py:653: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:276: in assertCheckFails
    self.assertRaises(ObjectFormatException, do_check)
E   AssertionError: ObjectFormatException not raised by do_check
</pre>
</details>
<h3 id="test_objectspycommitparseteststest_check_order">test_objects.py::CommitParseTests::test_check_order</h3>
<details><summary> <pre>test_objects.py::CommitParseTests::test_check_order</pre></summary><pre>
self = <tests.test_objects.CommitParseTests testMethod=test_check_order>

    def test_check_order(self):
        lines = self.make_commit_lines(parents=[a_sha], encoding=b"UTF-8")
        headers = lines[:5]
        rest = lines[5:]
        # of all possible permutations, ensure only the original succeeds
        for perm in permutations(headers):
            perm = list(perm)
            text = b"\n".join(perm + rest)
            if perm == headers:
                self.assertCheckSucceeds(Commit, text)
            else:
>               self.assertCheckFails(Commit, text)

tests/test_objects.py:666: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:276: in assertCheckFails
    self.assertRaises(ObjectFormatException, do_check)
E   AssertionError: ObjectFormatException not raised by do_check
</pre>
</details>
<h3 id="test_objectspycommitparseteststest_custom">test_objects.py::CommitParseTests::test_custom</h3>
<details><summary> <pre>test_objects.py::CommitParseTests::test_custom</pre></summary><pre>
self = <tests.test_objects.CommitParseTests testMethod=test_custom>

    def test_custom(self):
        c = Commit.from_string(self.make_commit_text(extra={b"extra-field": b"data"}))
>       self.assertEqual([(b"extra-field", b"data")], c._extra)
E       AttributeError: 'NoneType' object has no attribute '_extra'

tests/test_objects.py:621: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitparseteststest_encoding">test_objects.py::CommitParseTests::test_encoding</h3>
<details><summary> <pre>test_objects.py::CommitParseTests::test_encoding</pre></summary><pre>
self = <tests.test_objects.CommitParseTests testMethod=test_encoding>

    def test_encoding(self):
        c = Commit.from_string(self.make_commit_text(encoding=b"UTF-8"))
>       self.assertEqual(b"UTF-8", c.encoding)
E       AttributeError: 'NoneType' object has no attribute 'encoding'

tests/test_objects.py:625: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitparseteststest_mangled_author_line">test_objects.py::CommitParseTests::test_mangled_author_line</h3>
<details><summary> <pre>test_objects.py::CommitParseTests::test_mangled_author_line</pre></summary><pre>
self = <tests.test_objects.CommitParseTests testMethod=test_mangled_author_line>

    def test_mangled_author_line(self):
        """Mangled author line should successfully parse."""
        author_line = (
            b'Karl MacMillan <kmacmill@redhat.com> <"Karl MacMillan '
            b'<kmacmill@redhat.com>"> 1197475547 -0500'
        )
        expected_identity = (
            b'Karl MacMillan <kmacmill@redhat.com> <"Karl MacMillan '
            b'<kmacmill@redhat.com>">'
        )
        commit = Commit.from_string(self.make_commit_text(author=author_line))

        # The commit parses properly
>       self.assertEqual(commit.author, expected_identity)
E       AttributeError: 'NoneType' object has no attribute 'author'

tests/test_objects.py:721: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitparseteststest_parse_gpgsig">test_objects.py::CommitParseTests::test_parse_gpgsig</h3>
<details><summary> <pre>test_objects.py::CommitParseTests::test_parse_gpgsig</pre></summary><pre>
self = <tests.test_objects.CommitParseTests testMethod=test_parse_gpgsig>

        def test_parse_gpgsig(self):
            c = Commit.from_string(
                b"""tree aaff74984cccd156a469afa7d9ab10e4777beb24
    author Jelmer Vernooij <jelmer@samba.org> 1412179807 +0200
    committer Jelmer Vernooij <jelmer@samba.org> 1412179807 +0200
    gpgsig -----BEGIN PGP SIGNATURE-----
     Version: GnuPG v1

     iQIcBAABCgAGBQJULCdfAAoJEACAbyvXKaRXuKwP/RyP9PA49uAvu8tQVCC/uBa8
     vi975+xvO14R8Pp8k2nps7lSxCdtCd+xVT1VRHs0wNhOZo2YCVoU1HATkPejqSeV
     NScTHcxnk4/+bxyfk14xvJkNp7FlQ3npmBkA+lbV0Ubr33rvtIE5jiJPyz+SgWAg
     xdBG2TojV0squj00GoH/euK6aX7GgZtwdtpTv44haCQdSuPGDcI4TORqR6YSqvy3
     GPE+3ZqXPFFb+KILtimkxitdwB7CpwmNse2vE3rONSwTvi8nq3ZoQYNY73CQGkUy
     qoFU0pDtw87U3niFin1ZccDgH0bB6624sLViqrjcbYJeg815Htsu4rmzVaZADEVC
     XhIO4MThebusdk0AcNGjgpf3HRHk0DPMDDlIjm+Oao0cqovvF6VyYmcb0C+RmhJj
     dodLXMNmbqErwTk3zEkW0yZvNIYXH7m9SokPCZa4eeIM7be62X6h1mbt0/IU6Th+
     v18fS0iTMP/Viug5und+05C/v04kgDo0CPphAbXwWMnkE4B6Tl9sdyUYXtvQsL7x
     0+WP1gL27ANqNZiI07Kz/BhbBAQI/+2TFT7oGr0AnFPQ5jHp+3GpUf6OKuT1wT3H
     ND189UFuRuubxb42vZhpcXRbqJVWnbECTKVUPsGZqat3enQUB63uM4i6/RdONDZA
     fDeF1m4qYs+cUXKNUZ03
     =X6RT
     -----END PGP SIGNATURE-----

    foo
    """
            )
>           self.assertEqual(b"foo\n", c.message)
E           AttributeError: 'NoneType' object has no attribute 'message'

tests/test_objects.py:753: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitparseteststest_parse_header_trailing_newline">test_objects.py::CommitParseTests::test_parse_header_trailing_newline</h3>
<details><summary> <pre>test_objects.py::CommitParseTests::test_parse_header_trailing_newline</pre></summary><pre>
self = <tests.test_objects.CommitParseTests testMethod=test_parse_header_trailing_newline>

        def test_parse_header_trailing_newline(self):
            c = Commit.from_string(
                b"""\
    tree a7d6277f78d3ecd0230a1a5df6db00b1d9c521ac
    parent c09b6dec7a73760fbdb478383a3c926b18db8bbe
    author Neil Matatall <oreoshake@github.com> 1461964057 -1000
    committer Neil Matatall <oreoshake@github.com> 1461964057 -1000
    gpgsig -----BEGIN PGP SIGNATURE-----

     wsBcBAABCAAQBQJXI80ZCRA6pcNDcVZ70gAAarcIABs72xRX3FWeox349nh6ucJK
     CtwmBTusez2Zwmq895fQEbZK7jpaGO5TRO4OvjFxlRo0E08UFx3pxZHSpj6bsFeL
     hHsDXnCaotphLkbgKKRdGZo7tDqM84wuEDlh4MwNe7qlFC7bYLDyysc81ZX5lpMm
     2MFF1TvjLAzSvkT7H1LPkuR3hSvfCYhikbPOUNnKOo0sYjeJeAJ/JdAVQ4mdJIM0
     gl3REp9+A+qBEpNQI7z94Pg5Bc5xenwuDh3SJgHvJV6zBWupWcdB3fAkVd4TPnEZ
     nHxksHfeNln9RKseIDcy4b2ATjhDNIJZARHNfr6oy4u3XPW4svRqtBsLoMiIeuI=
     =ms6q
     -----END PGP SIGNATURE-----


    3.3.0 version bump and docs
    """
            )
>           self.assertEqual([], c._extra)
E           AttributeError: 'NoneType' object has no attribute '_extra'

tests/test_objects.py:798: AttributeError
</pre>
</details>
<h3 id="test_objectspycommitparseteststest_simple">test_objects.py::CommitParseTests::test_simple</h3>
<details><summary> <pre>test_objects.py::CommitParseTests::test_simple</pre></summary><pre>
self = <tests.test_objects.CommitParseTests testMethod=test_simple>

    def test_simple(self):
        c = Commit.from_string(self.make_commit_text())
>       self.assertEqual(b"Merge ../b\n", c.message)
E       AttributeError: 'NoneType' object has no attribute 'message'

tests/test_objects.py:597: AttributeError
</pre>
</details>
<h3 id="test_objectspytreeteststest_add">test_objects.py::TreeTests::test_add</h3>
<details><summary> <pre>test_objects.py::TreeTests::test_add</pre></summary><pre>
self = <tests.test_objects.TreeTests testMethod=test_add>

    def test_add(self):
        myhexsha = b"d80c186a03f423a81b39df39dc87fd269736ca86"
        x = Tree()
        x.add(b"myname", 0o100755, myhexsha)
>       self.assertEqual(x[b"myname"], (0o100755, myhexsha))

tests/test_objects.py:833: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Tree None>, name = b'myname'

    def __getitem__(self, name):
>       return self._entries[name]
E       KeyError: b'myname'

dulwich/objects.py:571: KeyError
</pre>
</details>
<h3 id="test_objectspytreeteststest_check">test_objects.py::TreeTests::test_check</h3>
<details><summary> <pre>test_objects.py::TreeTests::test_check</pre></summary><pre>
self = <tests.test_objects.TreeTests testMethod=test_check>

    def test_check(self):
        t = Tree
        sha = hex_to_sha(a_sha)

        # filenames
        self.assertCheckSucceeds(t, b"100644 .a\0" + sha)
>       self.assertCheckFails(t, b"100644 \0" + sha)

tests/test_objects.py:946: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:276: in assertCheckFails
    self.assertRaises(ObjectFormatException, do_check)
E   AssertionError: ObjectFormatException not raised by do_check
</pre>
</details>
<h3 id="test_objectspytreeteststest_simple">test_objects.py::TreeTests::test_simple</h3>
<details><summary> <pre>test_objects.py::TreeTests::test_simple</pre></summary><pre>
self = <tests.test_objects.TreeTests testMethod=test_simple>

    def test_simple(self):
        myhexsha = b"d80c186a03f423a81b39df39dc87fd269736ca86"
        x = Tree()
        x[b"myname"] = (0o100755, myhexsha)
>       self.assertEqual(b"100755 myname\0" + hex_to_sha(myhexsha), x.as_raw_string())
E       AssertionError: b'100755 myname\x00\xd8\x0c\x18j\x03\xf4#[36 chars]\x86' != None

tests/test_objects.py:840: AssertionError
</pre>
</details>
<h3 id="test_objectspytreeteststest_tree_items_dir_sort">test_objects.py::TreeTests::test_tree_items_dir_sort</h3>
<details><summary> <pre>test_objects.py::TreeTests::test_tree_items_dir_sort</pre></summary><pre>
self = <tests.test_objects.TreeTests testMethod=test_tree_items_dir_sort>

    def test_tree_items_dir_sort(self):
        x = Tree()
        for name, item in _TREE_ITEMS.items():
            x[name] = item
>       self.assertEqual(_SORTED_TREE_ITEMS, x.items())
E       AssertionError: [TreeEntry(path=b'a.c', mode=33261, sha=b[207 chars]86')] != None

tests/test_objects.py:860: AssertionError
</pre>
</details>
<h3 id="test_objectspytreeteststest_tree_iteritems_dir_sort">test_objects.py::TreeTests::test_tree_iteritems_dir_sort</h3>
<details><summary> <pre>test_objects.py::TreeTests::test_tree_iteritems_dir_sort</pre></summary><pre>
self = <tests.test_objects.TreeTests testMethod=test_tree_iteritems_dir_sort>

    def test_tree_iteritems_dir_sort(self):
        x = Tree()
        for name, item in _TREE_ITEMS.items():
            x[name] = item
>       self.assertEqual(_SORTED_TREE_ITEMS, x.items())
E       AssertionError: [TreeEntry(path=b'a.c', mode=33261, sha=b[207 chars]86')] != None

tests/test_objects.py:854: AssertionError
</pre>
</details>
<h3 id="test_objectspytreeteststest_tree_update_id">test_objects.py::TreeTests::test_tree_update_id</h3>
<details><summary> <pre>test_objects.py::TreeTests::test_tree_update_id</pre></summary><pre>
self = <tests.test_objects.TreeTests testMethod=test_tree_update_id>

    def test_tree_update_id(self):
        x = Tree()
        x[b"a.c"] = (0o100755, b"d80c186a03f423a81b39df39dc87fd269736ca86")
>       self.assertEqual(b"0c5c6bc2c081accfbc250331b19e43b904ab9cdd", x.id)
E       AssertionError: b'0c5c6bc2c081accfbc250331b19e43b904ab9cdd' != None

tests/test_objects.py:846: AssertionError
</pre>
</details>
<h3 id="test_objectspytagserializeteststest_serialize_none_message">test_objects.py::TagSerializeTests::test_serialize_none_message</h3>
<details><summary> <pre>test_objects.py::TagSerializeTests::test_serialize_none_message</pre></summary><pre>
self = <tests.test_objects.TagSerializeTests testMethod=test_serialize_none_message>

    def test_serialize_none_message(self):
        x = make_object(
            Tag,
            tagger=b"Jelmer Vernooij <jelmer@samba.org>",
            name=b"0.1",
            message=None,
            object=(Blob, b"d80c186a03f423a81b39df39dc87fd269736ca86"),
            tag_time=423423423,
            tag_timezone=0,
        )
        self.assertEqual(
            (
                b"object d80c186a03f423a81b39df39dc87fd269736ca86\n"
                b"type blob\n"
                b"tag 0.1\n"
                b"tagger Jelmer Vernooij <jelmer@samba.org> "
                b"423423423 +0000\n"
            ),
>           x.as_raw_string(),
        )
E       AttributeError: 'NoneType' object has no attribute 'as_raw_string'

tests/test_objects.py:1022: AttributeError
</pre>
</details>
<h3 id="test_objectspytagserializeteststest_serialize_simple">test_objects.py::TagSerializeTests::test_serialize_simple</h3>
<details><summary> <pre>test_objects.py::TagSerializeTests::test_serialize_simple</pre></summary><pre>
self = <tests.test_objects.TagSerializeTests testMethod=test_serialize_simple>

    def test_serialize_simple(self):
        x = make_object(
            Tag,
            tagger=b"Jelmer Vernooij <jelmer@samba.org>",
            name=b"0.1",
            message=b"Tag 0.1",
            object=(Blob, b"d80c186a03f423a81b39df39dc87fd269736ca86"),
            tag_time=423423423,
            tag_timezone=0,
        )
        self.assertEqual(
            (
                b"object d80c186a03f423a81b39df39dc87fd269736ca86\n"
                b"type blob\n"
                b"tag 0.1\n"
                b"tagger Jelmer Vernooij <jelmer@samba.org> "
                b"423423423 +0000\n"
                b"\n"
                b"Tag 0.1"
            ),
>           x.as_raw_string(),
        )
E       AttributeError: 'NoneType' object has no attribute 'as_raw_string'

tests/test_objects.py:1001: AttributeError
</pre>
</details>
<h3 id="test_objectspytagparseteststest_check">test_objects.py::TagParseTests::test_check</h3>
<details><summary> <pre>test_objects.py::TagParseTests::test_check</pre></summary><pre>
self = <tests.test_objects.TagParseTests testMethod=test_check>

    def test_check(self):
        self.assertCheckSucceeds(Tag, self.make_tag_text())
>       self.assertCheckFails(Tag, self.make_tag_text(object_sha=None))

tests/test_objects.py:1105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:276: in assertCheckFails
    self.assertRaises(ObjectFormatException, do_check)
E   AssertionError: ObjectFormatException not raised by do_check
</pre>
</details>
<h3 id="test_objectspytagparseteststest_check_duplicates">test_objects.py::TagParseTests::test_check_duplicates</h3>
<details><summary> <pre>test_objects.py::TagParseTests::test_check_duplicates</pre></summary><pre>
self = <tests.test_objects.TagParseTests testMethod=test_check_duplicates>

    def test_check_duplicates(self):
        # duplicate each of the header fields
        for i in range(4):
            lines = self.make_tag_lines()
            lines.insert(i, lines[i])
>           self.assertCheckFails(Tag, b"\n".join(lines))

tests/test_objects.py:1150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:276: in assertCheckFails
    self.assertRaises(ObjectFormatException, do_check)
E   AssertionError: ObjectFormatException not raised by do_check
</pre>
</details>
<h3 id="test_objectspytagparseteststest_check_order">test_objects.py::TagParseTests::test_check_order</h3>
<details><summary> <pre>test_objects.py::TagParseTests::test_check_order</pre></summary><pre>
self = <tests.test_objects.TagParseTests testMethod=test_check_order>

    def test_check_order(self):
        lines = self.make_tag_lines()
        headers = lines[:4]
        rest = lines[4:]
        # of all possible permutations, ensure only the original succeeds
        for perm in permutations(headers):
            perm = list(perm)
            text = b"\n".join(perm + rest)
            if perm == headers:
                self.assertCheckSucceeds(Tag, text)
            else:
>               self.assertCheckFails(Tag, text)

tests/test_objects.py:1163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:276: in assertCheckFails
    self.assertRaises(ObjectFormatException, do_check)
E   AssertionError: ObjectFormatException not raised by do_check
</pre>
</details>
<h3 id="test_objectspytagparseteststest_check_tag_with_overflow_time">test_objects.py::TagParseTests::test_check_tag_with_overflow_time</h3>
<details><summary> <pre>test_objects.py::TagParseTests::test_check_tag_with_overflow_time</pre></summary><pre>
self = <tests.test_objects.TagParseTests testMethod=test_check_tag_with_overflow_time>

    def test_check_tag_with_overflow_time(self):
        """Date with overflow should raise an ObjectFormatException when checked."""
        author = f"Some Dude <some@dude.org> {MAX_TIME + 1} +0000"
        tag = Tag.from_string(self.make_tag_text(tagger=(author.encode())))
        with self.assertRaises(ObjectFormatException):
>           tag.check()
E           AttributeError: 'NoneType' object has no attribute 'check'

tests/test_objects.py:1143: AttributeError
</pre>
</details>
<h3 id="test_objectspytagparseteststest_check_tag_with_unparseable_field">test_objects.py::TagParseTests::test_check_tag_with_unparseable_field</h3>
<details><summary> <pre>test_objects.py::TagParseTests::test_check_tag_with_unparseable_field</pre></summary><pre>
self = <tests.test_objects.TagParseTests testMethod=test_check_tag_with_unparseable_field>

    def test_check_tag_with_unparseable_field(self):
>       self.assertCheckFails(
            Tag,
            self.make_tag_text(
                tagger=(
                    b"Linus Torvalds <torvalds@woody.linux-foundation.org> "
                    b"423423+0000"
                )
            ),
        )

tests/test_objects.py:1128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_objects.py:276: in assertCheckFails
    self.assertRaises(ObjectFormatException, do_check)
E   AssertionError: ObjectFormatException not raised by do_check
</pre>
</details>
<h3 id="test_objectspytagparseteststest_parse">test_objects.py::TagParseTests::test_parse</h3>
<details><summary> <pre>test_objects.py::TagParseTests::test_parse</pre></summary><pre>
self = <tests.test_objects.TagParseTests testMethod=test_parse>

    def test_parse(self):
        x = Tag()
        x.set_raw_string(self.make_tag_text())
>       self.assertEqual(
            b"Linus Torvalds <torvalds@woody.linux-foundation.org>", x.tagger
        )
E       AssertionError: b'Linus Torvalds <torvalds@woody.linux-foundation.org>' != None

tests/test_objects.py:1069: AssertionError
</pre>
</details>
<h3 id="test_objectspytagparseteststest_parse_no_message">test_objects.py::TagParseTests::test_parse_no_message</h3>
<details><summary> <pre>test_objects.py::TagParseTests::test_parse_no_message</pre></summary><pre>
self = <tests.test_objects.TagParseTests testMethod=test_parse_no_message>

    def test_parse_no_message(self):
        x = Tag()
        x.set_raw_string(self.make_tag_text(message=None))
>       self.assertEqual(None, x.message)

tests/test_objects.py:1092: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = <Tag None>

    def get(obj):
>       return getattr(obj, '_' + name)
E       AttributeError: 'Tag' object has no attribute '_message'. Did you mean: 'message'?

dulwich/objects.py:77: AttributeError
</pre>
</details>
<h3 id="test_objectspytagparseteststest_parse_no_tagger">test_objects.py::TagParseTests::test_parse_no_tagger</h3>
<details><summary> <pre>test_objects.py::TagParseTests::test_parse_no_tagger</pre></summary><pre>
self = <tests.test_objects.TagParseTests testMethod=test_parse_no_tagger>

    def test_parse_no_tagger(self):
        x = Tag()
        x.set_raw_string(self.make_tag_text(tagger=None))
        self.assertEqual(None, x.tagger)
>       self.assertEqual(b"v2.6.22-rc7", x.name)

tests/test_objects.py:1086: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = <Tag None>

    def get(obj):
>       return getattr(obj, '_' + name)
E       AttributeError: 'Tag' object has no attribute '_name'. Did you mean: 'name'?

dulwich/objects.py:77: AttributeError
</pre>
</details>
<h3 id="test_objectspytagparseteststest_tree_copy_after_update">test_objects.py::TagParseTests::test_tree_copy_after_update</h3>
<details><summary> <pre>test_objects.py::TagParseTests::test_tree_copy_after_update</pre></summary><pre>
self = <tests.test_objects.TagParseTests testMethod=test_tree_copy_after_update>

    def test_tree_copy_after_update(self):
        """Check Tree.id is correctly updated when the tree is copied after updated."""
        shas = []
        tree = Tree()
        shas.append(tree.id)
        tree.add(b"data", 0o644, Blob().id)
        copied = tree.copy()
        shas.append(tree.id)
>       shas.append(copied.id)
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_objects.py:1173: AttributeError
</pre>
</details>
<h3 id="test_objectspycheckteststest_check_identity">test_objects.py::CheckTests::test_check_identity</h3>
<details><summary> <pre>test_objects.py::CheckTests::test_check_identity</pre></summary><pre>
self = <tests.test_objects.CheckTests testMethod=test_check_identity>

    def test_check_identity(self):
        check_identity(
            b"Dave Borowitz <dborowitz@google.com>",
            "failed to check good identity",
        )
        check_identity(b" <dborowitz@google.com>", "failed to check good identity")
        self.assertRaises(
            ObjectFormatException,
            check_identity,
            b"<dborowitz@google.com>",
            "no space before email",
        )
        self.assertRaises(
            ObjectFormatException, check_identity, b"Dave Borowitz", "no email"
        )
        self.assertRaises(
            ObjectFormatException,
            check_identity,
            b"Dave Borowitz <dborowitz",
            "incomplete email",
        )
        self.assertRaises(
            ObjectFormatException,
            check_identity,
            b"dborowitz@google.com>",
            "incomplete email",
        )
>       self.assertRaises(
            ObjectFormatException,
            check_identity,
            b"Dave Borowitz <<dborowitz@google.com>",
            "typo",
        )
E       AssertionError: ObjectFormatException not raised by check_identity

tests/test_objects.py:1222: AssertionError
</pre>
</details>
<h3 id="test_objectspytimezoneteststest_format_timezone_cet">test_objects.py::TimezoneTests::test_format_timezone_cet</h3>
<details><summary> <pre>test_objects.py::TimezoneTests::test_format_timezone_cet</pre></summary><pre>
self = <tests.test_objects.TimezoneTests testMethod=test_format_timezone_cet>

    def test_format_timezone_cet(self):
>       self.assertEqual(b"+0100", format_timezone(60 * 60))
E       AssertionError: b'+0100' != None

tests/test_objects.py:1289: AssertionError
</pre>
</details>
<h3 id="test_objectspytimezoneteststest_format_timezone_double_negative">test_objects.py::TimezoneTests::test_format_timezone_double_negative</h3>
<details><summary> <pre>test_objects.py::TimezoneTests::test_format_timezone_double_negative</pre></summary><pre>
self = <tests.test_objects.TimezoneTests testMethod=test_format_timezone_double_negative>

    def test_format_timezone_double_negative(self):
>       self.assertEqual(b"--700", format_timezone(int((7 * 60) * 60), True))
E       AssertionError: b'--700' != None

tests/test_objects.py:1301: AssertionError
</pre>
</details>
<h3 id="test_objectspytimezoneteststest_format_timezone_pdt">test_objects.py::TimezoneTests::test_format_timezone_pdt</h3>
<details><summary> <pre>test_objects.py::TimezoneTests::test_format_timezone_pdt</pre></summary><pre>
self = <tests.test_objects.TimezoneTests testMethod=test_format_timezone_pdt>

    def test_format_timezone_pdt(self):
>       self.assertEqual(b"-0400", format_timezone(-4 * 60 * 60))
E       AssertionError: b'-0400' != None

tests/test_objects.py:1292: AssertionError
</pre>
</details>
<h3 id="test_objectspytimezoneteststest_format_timezone_pdt_half">test_objects.py::TimezoneTests::test_format_timezone_pdt_half</h3>
<details><summary> <pre>test_objects.py::TimezoneTests::test_format_timezone_pdt_half</pre></summary><pre>
self = <tests.test_objects.TimezoneTests testMethod=test_format_timezone_pdt_half>

    def test_format_timezone_pdt_half(self):
>       self.assertEqual(b"-0440", format_timezone(int(((-4 * 60) - 40) * 60)))
E       AssertionError: b'-0440' != None

tests/test_objects.py:1298: AssertionError
</pre>
</details>
<h3 id="test_objectspytimezoneteststest_generate_timezone_utc">test_objects.py::TimezoneTests::test_generate_timezone_utc</h3>
<details><summary> <pre>test_objects.py::TimezoneTests::test_generate_timezone_utc</pre></summary><pre>
self = <tests.test_objects.TimezoneTests testMethod=test_generate_timezone_utc>

    def test_generate_timezone_utc(self):
>       self.assertEqual(b"+0000", format_timezone(0))
E       AssertionError: b'+0000' != None

tests/test_objects.py:1280: AssertionError
</pre>
</details>
<h3 id="test_objectspytimezoneteststest_generate_timezone_utc_negative">test_objects.py::TimezoneTests::test_generate_timezone_utc_negative</h3>
<details><summary> <pre>test_objects.py::TimezoneTests::test_generate_timezone_utc_negative</pre></summary><pre>
self = <tests.test_objects.TimezoneTests testMethod=test_generate_timezone_utc_negative>

    def test_generate_timezone_utc_negative(self):
>       self.assertEqual(b"-0000", format_timezone(0, True))
E       AssertionError: b'-0000' != None

tests/test_objects.py:1283: AssertionError
</pre>
</details>
<h3 id="test_objectspytimezoneteststest_parse_timezone_cet">test_objects.py::TimezoneTests::test_parse_timezone_cet</h3>
<details><summary> <pre>test_objects.py::TimezoneTests::test_parse_timezone_cet</pre></summary><pre>
self = <tests.test_objects.TimezoneTests testMethod=test_parse_timezone_cet>

    def test_parse_timezone_cet(self):
>       self.assertEqual((60 * 60, False), parse_timezone(b"+0100"))
E       AssertionError: (3600, False) != None

tests/test_objects.py:1286: AssertionError
</pre>
</details>
<h3 id="test_objectspytimezoneteststest_parse_timezone_double_negative">test_objects.py::TimezoneTests::test_parse_timezone_double_negative</h3>
<details><summary> <pre>test_objects.py::TimezoneTests::test_parse_timezone_double_negative</pre></summary><pre>
self = <tests.test_objects.TimezoneTests testMethod=test_parse_timezone_double_negative>

    def test_parse_timezone_double_negative(self):
>       self.assertEqual((int((7 * 60) * 60), False), parse_timezone(b"+700"))
E       AssertionError: (25200, False) != None

tests/test_objects.py:1307: AssertionError
</pre>
</details>
<h3 id="test_objectspytimezoneteststest_parse_timezone_pdt">test_objects.py::TimezoneTests::test_parse_timezone_pdt</h3>
<details><summary> <pre>test_objects.py::TimezoneTests::test_parse_timezone_pdt</pre></summary><pre>
self = <tests.test_objects.TimezoneTests testMethod=test_parse_timezone_pdt>

    def test_parse_timezone_pdt(self):
>       self.assertEqual((-4 * 60 * 60, False), parse_timezone(b"-0400"))
E       AssertionError: (-14400, False) != None

tests/test_objects.py:1295: AssertionError
</pre>
</details>
<h3 id="test_objectspytimezoneteststest_parse_timezone_pdt_half">test_objects.py::TimezoneTests::test_parse_timezone_pdt_half</h3>
<details><summary> <pre>test_objects.py::TimezoneTests::test_parse_timezone_pdt_half</pre></summary><pre>
self = <tests.test_objects.TimezoneTests testMethod=test_parse_timezone_pdt_half>

    def test_parse_timezone_pdt_half(self):
>       self.assertEqual((((-4 * 60) - 40) * 60, False), parse_timezone(b"-0440"))
E       AssertionError: (-16800, False) != None

tests/test_objects.py:1304: AssertionError
</pre>
</details>
<h3 id="test_objectspytimezoneteststest_parse_timezone_utc">test_objects.py::TimezoneTests::test_parse_timezone_utc</h3>
<details><summary> <pre>test_objects.py::TimezoneTests::test_parse_timezone_utc</pre></summary><pre>
self = <tests.test_objects.TimezoneTests testMethod=test_parse_timezone_utc>

    def test_parse_timezone_utc(self):
>       self.assertEqual((0, False), parse_timezone(b"+0000"))
E       AssertionError: (0, False) != None

tests/test_objects.py:1274: AssertionError
</pre>
</details>
<h3 id="test_objectspytimezoneteststest_parse_timezone_utc_negative">test_objects.py::TimezoneTests::test_parse_timezone_utc_negative</h3>
<details><summary> <pre>test_objects.py::TimezoneTests::test_parse_timezone_utc_negative</pre></summary><pre>
self = <tests.test_objects.TimezoneTests testMethod=test_parse_timezone_utc_negative>

    def test_parse_timezone_utc_negative(self):
>       self.assertEqual((0, True), parse_timezone(b"-0000"))
E       AssertionError: (0, True) != None

tests/test_objects.py:1277: AssertionError
</pre>
</details>
<h3 id="test_objectspyshafilecopyteststest_blob_copy">test_objects.py::ShaFileCopyTests::test_blob_copy</h3>
<details><summary> <pre>test_objects.py::ShaFileCopyTests::test_blob_copy</pre></summary><pre>
self = <tests.test_objects.ShaFileCopyTests testMethod=test_blob_copy>

    def test_blob_copy(self):
        blob = make_object(Blob, data=b"i am a blob")
>       self.assert_copy(blob)

tests/test_objects.py:1340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_objects.ShaFileCopyTests testMethod=test_blob_copy>
orig = None

    def assert_copy(self, orig):
>       oclass = object_class(orig.type_num)
E       AttributeError: 'NoneType' object has no attribute 'type_num'

tests/test_objects.py:1313: AttributeError
</pre>
</details>
<h3 id="test_objectspyshafilecopyteststest_commit_copy">test_objects.py::ShaFileCopyTests::test_commit_copy</h3>
<details><summary> <pre>test_objects.py::ShaFileCopyTests::test_commit_copy</pre></summary><pre>
self = <tests.test_objects.ShaFileCopyTests testMethod=test_commit_copy>

    def test_commit_copy(self):
        attrs = {
            "tree": b"d80c186a03f423a81b39df39dc87fd269736ca86",
            "parents": [
                b"ab64bbdcc51b170d21588e5c5d391ee5c0c96dfd",
                b"4cffe90e0a41ad3f5190079d7c8f036bde29cbe6",
            ],
            "author": b"James Westby <jw+debian@jameswestby.net>",
            "committer": b"James Westby <jw+debian@jameswestby.net>",
            "commit_time": 1174773719,
            "author_time": 1174773719,
            "commit_timezone": 0,
            "author_timezone": 0,
            "message": b"Merge ../b\n",
        }
        commit = make_commit(**attrs)
>       self.assert_copy(commit)

tests/test_objects.py:1336: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_objects.ShaFileCopyTests testMethod=test_commit_copy>
orig = None

    def assert_copy(self, orig):
>       oclass = object_class(orig.type_num)
E       AttributeError: 'NoneType' object has no attribute 'type_num'

tests/test_objects.py:1313: AttributeError
</pre>
</details>
<h3 id="test_objectspyshafilecopyteststest_tag_copy">test_objects.py::ShaFileCopyTests::test_tag_copy</h3>
<details><summary> <pre>test_objects.py::ShaFileCopyTests::test_tag_copy</pre></summary><pre>
self = <tests.test_objects.ShaFileCopyTests testMethod=test_tag_copy>

    def test_tag_copy(self):
        tag = make_object(
            Tag,
            name=b"tag",
            message=b"",
            tagger=b"Tagger <test@example.com>",
            tag_time=12345,
            tag_timezone=0,
            object=(Commit, b"0" * 40),
        )
>       self.assert_copy(tag)

tests/test_objects.py:1358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_objects.ShaFileCopyTests testMethod=test_tag_copy>
orig = None

    def assert_copy(self, orig):
>       oclass = object_class(orig.type_num)
E       AttributeError: 'NoneType' object has no attribute 'type_num'

tests/test_objects.py:1313: AttributeError
</pre>
</details>
<h3 id="test_objectspyshafilecopyteststest_tree_copy">test_objects.py::ShaFileCopyTests::test_tree_copy</h3>
<details><summary> <pre>test_objects.py::ShaFileCopyTests::test_tree_copy</pre></summary><pre>
self = <tests.test_objects.ShaFileCopyTests testMethod=test_tree_copy>

    def test_tree_copy(self):
        blob = make_object(Blob, data=b"i am a blob")
        tree = Tree()
>       tree[b"blob"] = (stat.S_IFREG, blob.id)
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_objects.py:1345: AttributeError
</pre>
</details>
<h3 id="test_objectspyshafileserializeteststest_blob_serialize">test_objects.py::ShaFileSerializeTests::test_blob_serialize</h3>
<details><summary> <pre>test_objects.py::ShaFileSerializeTests::test_blob_serialize</pre></summary><pre>
self = <tests.test_objects.ShaFileSerializeTests testMethod=test_blob_serialize>

    def test_blob_serialize(self):
        blob = make_object(Blob, data=b"i am a blob")

>       with self.assert_serialization_on_change(
            blob, needs_serialization_after_change=False
        ):

tests/test_objects.py:1404: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_objects.ShaFileSerializeTests testMethod=test_blob_serialize>
obj = None, needs_serialization_after_change = False

    @contextmanager
    def assert_serialization_on_change(
        self, obj, needs_serialization_after_change=True
    ):
>       old_id = obj.id
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_objects.py:1368: AttributeError
</pre>
</details>
<h3 id="test_objectspyshafileserializeteststest_commit_serialize">test_objects.py::ShaFileSerializeTests::test_commit_serialize</h3>
<details><summary> <pre>test_objects.py::ShaFileSerializeTests::test_commit_serialize</pre></summary><pre>
self = <tests.test_objects.ShaFileSerializeTests testMethod=test_commit_serialize>

    def test_commit_serialize(self):
        attrs = {
            "tree": b"d80c186a03f423a81b39df39dc87fd269736ca86",
            "parents": [
                b"ab64bbdcc51b170d21588e5c5d391ee5c0c96dfd",
                b"4cffe90e0a41ad3f5190079d7c8f036bde29cbe6",
            ],
            "author": b"James Westby <jw+debian@jameswestby.net>",
            "committer": b"James Westby <jw+debian@jameswestby.net>",
            "commit_time": 1174773719,
            "author_time": 1174773719,
            "commit_timezone": 0,
            "author_timezone": 0,
            "message": b"Merge ../b\n",
        }
        commit = make_commit(**attrs)

>       with self.assert_serialization_on_change(commit):

tests/test_objects.py:1398: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_objects.ShaFileSerializeTests testMethod=test_commit_serialize>
obj = None, needs_serialization_after_change = True

    @contextmanager
    def assert_serialization_on_change(
        self, obj, needs_serialization_after_change=True
    ):
>       old_id = obj.id
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_objects.py:1368: AttributeError
</pre>
</details>
<h3 id="test_objectspyshafileserializeteststest_tag_serialize">test_objects.py::ShaFileSerializeTests::test_tag_serialize</h3>
<details><summary> <pre>test_objects.py::ShaFileSerializeTests::test_tag_serialize</pre></summary><pre>
self = <tests.test_objects.ShaFileSerializeTests testMethod=test_tag_serialize>

    def test_tag_serialize(self):
        tag = make_object(
            Tag,
            name=b"tag",
            message=b"",
            tagger=b"Tagger <test@example.com>",
            tag_time=12345,
            tag_timezone=0,
            object=(Commit, b"0" * 40),
        )

>       with self.assert_serialization_on_change(tag):

tests/test_objects.py:1428: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_objects.ShaFileSerializeTests testMethod=test_tag_serialize>
obj = None, needs_serialization_after_change = True

    @contextmanager
    def assert_serialization_on_change(
        self, obj, needs_serialization_after_change=True
    ):
>       old_id = obj.id
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_objects.py:1368: AttributeError
</pre>
</details>
<h3 id="test_objectspyshafileserializeteststest_tag_serialize_time_error">test_objects.py::ShaFileSerializeTests::test_tag_serialize_time_error</h3>
<details><summary> <pre>test_objects.py::ShaFileSerializeTests::test_tag_serialize_time_error</pre></summary><pre>
self = <tests.test_objects.ShaFileSerializeTests testMethod=test_tag_serialize_time_error>

    def test_tag_serialize_time_error(self):
        with self.assertRaises(ObjectFormatException):
            tag = make_object(
                Tag,
                name=b"tag",
                message=b"some message",
                tagger=b"Tagger <test@example.com> 1174773719+0000",
                object=(Commit, b"0" * 40),
            )
>           tag._deserialize(tag._serialize())
E           AttributeError: 'NoneType' object has no attribute '_deserialize'

tests/test_objects.py:1440: AttributeError
</pre>
</details>
<h3 id="test_objectspyshafileserializeteststest_tree_serialize">test_objects.py::ShaFileSerializeTests::test_tree_serialize</h3>
<details><summary> <pre>test_objects.py::ShaFileSerializeTests::test_tree_serialize</pre></summary><pre>
self = <tests.test_objects.ShaFileSerializeTests testMethod=test_tree_serialize>

    def test_tree_serialize(self):
        blob = make_object(Blob, data=b"i am a blob")
        tree = Tree()
>       tree[b"blob"] = (stat.S_IFREG, blob.id)
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_objects.py:1412: AttributeError
</pre>
</details>
<h3 id="test_objectspyprettyformattreeentryteststest_format">test_objects.py::PrettyFormatTreeEntryTests::test_format</h3>
<details><summary> <pre>test_objects.py::PrettyFormatTreeEntryTests::test_format</pre></summary><pre>
self = <tests.test_objects.PrettyFormatTreeEntryTests testMethod=test_format>

    def test_format(self):
>       self.assertEqual(
            "40000 tree 40820c38cfb182ce6c8b261555410d8382a5918b\tfoo\n",
            pretty_format_tree_entry(
                b"foo", 0o40000, b"40820c38cfb182ce6c8b261555410d8382a5918b"
            ),
        )
E       AssertionError: '40000 tree 40820c38cfb182ce6c8b261555410d8382a5918b\tfoo\n' != None

tests/test_objects.py:1445: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparseobjectteststest_blob_by_sha">test_objectspec.py::ParseObjectTests::test_blob_by_sha</h3>
<details><summary> <pre>test_objectspec.py::ParseObjectTests::test_blob_by_sha</pre></summary><pre>
self = <tests.test_objectspec.ParseObjectTests testMethod=test_blob_by_sha>

    def test_blob_by_sha(self):
>       r = MemoryRepo()

tests/test_objectspec.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1f6357e0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_objectspecpyparseobjectteststest_nonexistent">test_objectspec.py::ParseObjectTests::test_nonexistent</h3>
<details><summary> <pre>test_objectspec.py::ParseObjectTests::test_nonexistent</pre></summary><pre>
self = <tests.test_objectspec.ParseObjectTests testMethod=test_nonexistent>

    def test_nonexistent(self):
>       r = MemoryRepo()

tests/test_objectspec.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1eb44c70>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_objectspecpyparsecommitrangeteststest_commit_by_sha">test_objectspec.py::ParseCommitRangeTests::test_commit_by_sha</h3>
<details><summary> <pre>test_objectspec.py::ParseCommitRangeTests::test_commit_by_sha</pre></summary><pre>
self = <tests.test_objectspec.ParseCommitRangeTests testMethod=test_commit_by_sha>

    def test_commit_by_sha(self):
>       r = MemoryRepo()

tests/test_objectspec.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1eefb190>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_objectspecpyparsecommitrangeteststest_nonexistent">test_objectspec.py::ParseCommitRangeTests::test_nonexistent</h3>
<details><summary> <pre>test_objectspec.py::ParseCommitRangeTests::test_nonexistent</pre></summary><pre>
self = <tests.test_objectspec.ParseCommitRangeTests testMethod=test_nonexistent>

    def test_nonexistent(self):
>       r = MemoryRepo()

tests/test_objectspec.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1eb437f0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_objectspecpyparsecommitteststest_commit_by_sha">test_objectspec.py::ParseCommitTests::test_commit_by_sha</h3>
<details><summary> <pre>test_objectspec.py::ParseCommitTests::test_commit_by_sha</pre></summary><pre>
self = <tests.test_objectspec.ParseCommitTests testMethod=test_commit_by_sha>

    def test_commit_by_sha(self):
>       r = MemoryRepo()

tests/test_objectspec.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1ec060e0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_objectspecpyparsecommitteststest_commit_by_short_sha">test_objectspec.py::ParseCommitTests::test_commit_by_short_sha</h3>
<details><summary> <pre>test_objectspec.py::ParseCommitTests::test_commit_by_short_sha</pre></summary><pre>
self = <tests.test_objectspec.ParseCommitTests testMethod=test_commit_by_short_sha>

    def test_commit_by_short_sha(self):
>       r = MemoryRepo()

tests/test_objectspec.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1ed5b310>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_objectspecpyparsecommitteststest_nonexistent">test_objectspec.py::ParseCommitTests::test_nonexistent</h3>
<details><summary> <pre>test_objectspec.py::ParseCommitTests::test_nonexistent</pre></summary><pre>
self = <tests.test_objectspec.ParseCommitTests testMethod=test_nonexistent>

    def test_nonexistent(self):
>       r = MemoryRepo()

tests/test_objectspec.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1ebcb0a0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_objectspecpyparserefteststest_ambiguous_head">test_objectspec.py::ParseRefTests::test_ambiguous_head</h3>
<details><summary> <pre>test_objectspec.py::ParseRefTests::test_ambiguous_head</pre></summary><pre>
self = <tests.test_objectspec.ParseRefTests testMethod=test_ambiguous_head>

    def test_ambiguous_head(self):
        r = {
            b"refs/heads/ambig4": "bla",
            b"refs/remotes/ambig4": "bla",
            b"refs/remotes/ambig4/HEAD": "bla",
        }
>       self.assertEqual(b"refs/heads/ambig4", parse_ref(r, b"ambig4"))
E       AssertionError: b'refs/heads/ambig4' != None

tests/test_objectspec.py:128: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparserefteststest_ambiguous_ref">test_objectspec.py::ParseRefTests::test_ambiguous_ref</h3>
<details><summary> <pre>test_objectspec.py::ParseRefTests::test_ambiguous_ref</pre></summary><pre>
self = <tests.test_objectspec.ParseRefTests testMethod=test_ambiguous_ref>

    def test_ambiguous_ref(self):
        r = {
            b"ambig1": "bla",
            b"refs/ambig1": "bla",
            b"refs/tags/ambig1": "bla",
            b"refs/heads/ambig1": "bla",
            b"refs/remotes/ambig1": "bla",
            b"refs/remotes/ambig1/HEAD": "bla",
        }
>       self.assertEqual(b"ambig1", parse_ref(r, b"ambig1"))
E       AssertionError: b'ambig1' != None

tests/test_objectspec.py:101: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparserefteststest_ambiguous_ref2">test_objectspec.py::ParseRefTests::test_ambiguous_ref2</h3>
<details><summary> <pre>test_objectspec.py::ParseRefTests::test_ambiguous_ref2</pre></summary><pre>
self = <tests.test_objectspec.ParseRefTests testMethod=test_ambiguous_ref2>

    def test_ambiguous_ref2(self):
        r = {
            b"refs/ambig2": "bla",
            b"refs/tags/ambig2": "bla",
            b"refs/heads/ambig2": "bla",
            b"refs/remotes/ambig2": "bla",
            b"refs/remotes/ambig2/HEAD": "bla",
        }
>       self.assertEqual(b"refs/ambig2", parse_ref(r, b"ambig2"))
E       AssertionError: b'refs/ambig2' != None

tests/test_objectspec.py:111: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparserefteststest_ambiguous_remote">test_objectspec.py::ParseRefTests::test_ambiguous_remote</h3>
<details><summary> <pre>test_objectspec.py::ParseRefTests::test_ambiguous_remote</pre></summary><pre>
self = <tests.test_objectspec.ParseRefTests testMethod=test_ambiguous_remote>

    def test_ambiguous_remote(self):
        r = {b"refs/remotes/ambig5": "bla", b"refs/remotes/ambig5/HEAD": "bla"}
>       self.assertEqual(b"refs/remotes/ambig5", parse_ref(r, b"ambig5"))
E       AssertionError: b'refs/remotes/ambig5' != None

tests/test_objectspec.py:132: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparserefteststest_ambiguous_remote_head">test_objectspec.py::ParseRefTests::test_ambiguous_remote_head</h3>
<details><summary> <pre>test_objectspec.py::ParseRefTests::test_ambiguous_remote_head</pre></summary><pre>
self = <tests.test_objectspec.ParseRefTests testMethod=test_ambiguous_remote_head>

    def test_ambiguous_remote_head(self):
        r = {b"refs/remotes/ambig6/HEAD": "bla"}
>       self.assertEqual(b"refs/remotes/ambig6/HEAD", parse_ref(r, b"ambig6"))
E       AssertionError: b'refs/remotes/ambig6/HEAD' != None

tests/test_objectspec.py:136: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparserefteststest_ambiguous_tag">test_objectspec.py::ParseRefTests::test_ambiguous_tag</h3>
<details><summary> <pre>test_objectspec.py::ParseRefTests::test_ambiguous_tag</pre></summary><pre>
self = <tests.test_objectspec.ParseRefTests testMethod=test_ambiguous_tag>

    def test_ambiguous_tag(self):
        r = {
            b"refs/tags/ambig3": "bla",
            b"refs/heads/ambig3": "bla",
            b"refs/remotes/ambig3": "bla",
            b"refs/remotes/ambig3/HEAD": "bla",
        }
>       self.assertEqual(b"refs/tags/ambig3", parse_ref(r, b"ambig3"))
E       AssertionError: b'refs/tags/ambig3' != None

tests/test_objectspec.py:120: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparserefteststest_heads_full">test_objectspec.py::ParseRefTests::test_heads_full</h3>
<details><summary> <pre>test_objectspec.py::ParseRefTests::test_heads_full</pre></summary><pre>
self = <tests.test_objectspec.ParseRefTests testMethod=test_heads_full>

    def test_heads_full(self):
        r = {b"refs/heads/foo": "bla"}
>       self.assertEqual(b"refs/heads/foo", parse_ref(r, b"refs/heads/foo"))
E       AssertionError: b'refs/heads/foo' != None

tests/test_objectspec.py:140: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparserefteststest_heads_partial">test_objectspec.py::ParseRefTests::test_heads_partial</h3>
<details><summary> <pre>test_objectspec.py::ParseRefTests::test_heads_partial</pre></summary><pre>
self = <tests.test_objectspec.ParseRefTests testMethod=test_heads_partial>

    def test_heads_partial(self):
        r = {b"refs/heads/foo": "bla"}
>       self.assertEqual(b"refs/heads/foo", parse_ref(r, b"heads/foo"))
E       AssertionError: b'refs/heads/foo' != None

tests/test_objectspec.py:144: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparserefteststest_nonexistent">test_objectspec.py::ParseRefTests::test_nonexistent</h3>
<details><summary> <pre>test_objectspec.py::ParseRefTests::test_nonexistent</pre></summary><pre>
self = <tests.test_objectspec.ParseRefTests testMethod=test_nonexistent>

    def test_nonexistent(self):
        r = {}
>       self.assertRaises(KeyError, parse_ref, r, b"thisdoesnotexist")
E       AssertionError: KeyError not raised by parse_ref

tests/test_objectspec.py:90: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparserefteststest_tags_partial">test_objectspec.py::ParseRefTests::test_tags_partial</h3>
<details><summary> <pre>test_objectspec.py::ParseRefTests::test_tags_partial</pre></summary><pre>
self = <tests.test_objectspec.ParseRefTests testMethod=test_tags_partial>

    def test_tags_partial(self):
        r = {b"refs/tags/foo": "bla"}
>       self.assertEqual(b"refs/tags/foo", parse_ref(r, b"tags/foo"))
E       AssertionError: b'refs/tags/foo' != None

tests/test_objectspec.py:148: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparserefsteststest_full">test_objectspec.py::ParseRefsTests::test_full</h3>
<details><summary> <pre>test_objectspec.py::ParseRefsTests::test_full</pre></summary><pre>
self = <tests.test_objectspec.ParseRefsTests testMethod=test_full>

    def test_full(self):
        r = {b"refs/heads/foo": "bla"}
>       self.assertEqual([b"refs/heads/foo"], parse_refs(r, b"refs/heads/foo"))
E       AssertionError: [b'refs/heads/foo'] != None

tests/test_objectspec.py:162: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparserefsteststest_head">test_objectspec.py::ParseRefsTests::test_head</h3>
<details><summary> <pre>test_objectspec.py::ParseRefsTests::test_head</pre></summary><pre>
self = <tests.test_objectspec.ParseRefsTests testMethod=test_head>

    def test_head(self):
        r = {b"refs/heads/foo": "bla"}
>       self.assertEqual([b"refs/heads/foo"], parse_refs(r, [b"foo"]))
E       AssertionError: [b'refs/heads/foo'] != None

tests/test_objectspec.py:158: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparserefsteststest_nonexistent">test_objectspec.py::ParseRefsTests::test_nonexistent</h3>
<details><summary> <pre>test_objectspec.py::ParseRefsTests::test_nonexistent</pre></summary><pre>
self = <tests.test_objectspec.ParseRefsTests testMethod=test_nonexistent>

    def test_nonexistent(self):
        r = {}
>       self.assertRaises(KeyError, parse_refs, r, [b"thisdoesnotexist"])
E       AssertionError: KeyError not raised by parse_refs

tests/test_objectspec.py:154: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparsereftupleteststest_default_with_string">test_objectspec.py::ParseReftupleTests::test_default_with_string</h3>
<details><summary> <pre>test_objectspec.py::ParseReftupleTests::test_default_with_string</pre></summary><pre>
self = <tests.test_objectspec.ParseReftupleTests testMethod=test_default_with_string>

    def test_default_with_string(self):
        r = {b"refs/heads/foo": "bla"}
>       self.assertEqual(
            (b"refs/heads/foo", b"refs/heads/foo", False),
            parse_reftuple(r, r, "foo"),
        )
E       AssertionError: (b'refs/heads/foo', b'refs/heads/foo', False) != None

tests/test_objectspec.py:212: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparsereftupleteststest_full">test_objectspec.py::ParseReftupleTests::test_full</h3>
<details><summary> <pre>test_objectspec.py::ParseReftupleTests::test_full</pre></summary><pre>
self = <tests.test_objectspec.ParseReftupleTests testMethod=test_full>

    def test_full(self):
        r = {b"refs/heads/foo": "bla"}
>       self.assertEqual(
            (b"refs/heads/foo", b"refs/heads/foo", False),
            parse_reftuple(r, r, b"refs/heads/foo"),
        )
E       AssertionError: (b'refs/heads/foo', b'refs/heads/foo', False) != None

tests/test_objectspec.py:191: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparsereftupleteststest_head">test_objectspec.py::ParseReftupleTests::test_head</h3>
<details><summary> <pre>test_objectspec.py::ParseReftupleTests::test_head</pre></summary><pre>
self = <tests.test_objectspec.ParseReftupleTests testMethod=test_head>

    def test_head(self):
        r = {b"refs/heads/foo": "bla"}
>       self.assertEqual(
            (b"refs/heads/foo", b"refs/heads/foo", False),
            parse_reftuple(r, r, b"foo"),
        )
E       AssertionError: (b'refs/heads/foo', b'refs/heads/foo', False) != None

tests/test_objectspec.py:172: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparsereftupleteststest_no_left_ref">test_objectspec.py::ParseReftupleTests::test_no_left_ref</h3>
<details><summary> <pre>test_objectspec.py::ParseReftupleTests::test_no_left_ref</pre></summary><pre>
self = <tests.test_objectspec.ParseReftupleTests testMethod=test_no_left_ref>

    def test_no_left_ref(self):
        r = {b"refs/heads/foo": "bla"}
>       self.assertEqual(
            (None, b"refs/heads/foo", False),
            parse_reftuple(r, r, b":refs/heads/foo"),
        )
E       AssertionError: (None, b'refs/heads/foo', False) != None

tests/test_objectspec.py:198: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparsereftupleteststest_no_right_ref">test_objectspec.py::ParseReftupleTests::test_no_right_ref</h3>
<details><summary> <pre>test_objectspec.py::ParseReftupleTests::test_no_right_ref</pre></summary><pre>
self = <tests.test_objectspec.ParseReftupleTests testMethod=test_no_right_ref>

    def test_no_right_ref(self):
        r = {b"refs/heads/foo": "bla"}
>       self.assertEqual(
            (b"refs/heads/foo", None, False),
            parse_reftuple(r, r, b"refs/heads/foo:"),
        )
E       AssertionError: (b'refs/heads/foo', None, False) != None

tests/test_objectspec.py:205: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparsereftupleteststest_nonexistent">test_objectspec.py::ParseReftupleTests::test_nonexistent</h3>
<details><summary> <pre>test_objectspec.py::ParseReftupleTests::test_nonexistent</pre></summary><pre>
self = <tests.test_objectspec.ParseReftupleTests testMethod=test_nonexistent>

    def test_nonexistent(self):
        r = {}
>       self.assertRaises(KeyError, parse_reftuple, r, r, b"thisdoesnotexist")
E       AssertionError: KeyError not raised by parse_reftuple

tests/test_objectspec.py:168: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparsereftuplesteststest_full">test_objectspec.py::ParseReftuplesTests::test_full</h3>
<details><summary> <pre>test_objectspec.py::ParseReftuplesTests::test_full</pre></summary><pre>
self = <tests.test_objectspec.ParseReftuplesTests testMethod=test_full>

    def test_full(self):
        r = {b"refs/heads/foo": "bla"}
>       self.assertEqual(
            [(b"refs/heads/foo", b"refs/heads/foo", False)],
            parse_reftuples(r, r, b"refs/heads/foo"),
        )
E       AssertionError: [(b'refs/heads/foo', b'refs/heads/foo', False)] != None

tests/test_objectspec.py:232: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparsereftuplesteststest_head">test_objectspec.py::ParseReftuplesTests::test_head</h3>
<details><summary> <pre>test_objectspec.py::ParseReftuplesTests::test_head</pre></summary><pre>
self = <tests.test_objectspec.ParseReftuplesTests testMethod=test_head>

    def test_head(self):
        r = {b"refs/heads/foo": "bla"}
>       self.assertEqual(
            [(b"refs/heads/foo", b"refs/heads/foo", False)],
            parse_reftuples(r, r, [b"foo"]),
        )
E       AssertionError: [(b'refs/heads/foo', b'refs/heads/foo', False)] != None

tests/test_objectspec.py:225: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparsereftuplesteststest_nonexistent">test_objectspec.py::ParseReftuplesTests::test_nonexistent</h3>
<details><summary> <pre>test_objectspec.py::ParseReftuplesTests::test_nonexistent</pre></summary><pre>
self = <tests.test_objectspec.ParseReftuplesTests testMethod=test_nonexistent>

    def test_nonexistent(self):
        r = {}
>       self.assertRaises(KeyError, parse_reftuples, r, r, [b"thisdoesnotexist"])
E       AssertionError: KeyError not raised by parse_reftuples

tests/test_objectspec.py:221: AssertionError
</pre>
</details>
<h3 id="test_objectspecpyparsetreeteststest_from_commit">test_objectspec.py::ParseTreeTests::test_from_commit</h3>
<details><summary> <pre>test_objectspec.py::ParseTreeTests::test_from_commit</pre></summary><pre>
self = <tests.test_objectspec.ParseTreeTests testMethod=test_from_commit>

    def test_from_commit(self):
>       r = MemoryRepo()

tests/test_objectspec.py:251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1f9cd9f0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_objectspecpyparsetreeteststest_from_ref">test_objectspec.py::ParseTreeTests::test_from_ref</h3>
<details><summary> <pre>test_objectspec.py::ParseTreeTests::test_from_ref</pre></summary><pre>
self = <tests.test_objectspec.ParseTreeTests testMethod=test_from_ref>

    def test_from_ref(self):
>       r = MemoryRepo()

tests/test_objectspec.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1efd1de0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_objectspecpyparsetreeteststest_nonexistent">test_objectspec.py::ParseTreeTests::test_nonexistent</h3>
<details><summary> <pre>test_objectspec.py::ParseTreeTests::test_nonexistent</pre></summary><pre>
self = <tests.test_objectspec.ParseTreeTests testMethod=test_nonexistent>

    def test_nonexistent(self):
>       r = MemoryRepo()

tests/test_objectspec.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1eca1180>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_packpypackindexteststest_get_stored_checksum">test_pack.py::PackIndexTests::test_get_stored_checksum</h3>
<details><summary> <pre>test_pack.py::PackIndexTests::test_get_stored_checksum</pre></summary><pre>
self = <tests.test_pack.PackIndexTests testMethod=test_get_stored_checksum>

    def test_get_stored_checksum(self):
        p = self.get_pack_index(pack1_sha)
        self.assertEqual(
            b"f2848e2ad16f329ae1c92e3b95e91888daa5bd01",
>           sha_to_hex(p.get_stored_checksum()),
        )
E       AttributeError: 'NoneType' object has no attribute 'get_stored_checksum'

tests/test_pack.py:135: AttributeError
</pre>
</details>
<h3 id="test_packpypackindexteststest_index_check">test_pack.py::PackIndexTests::test_index_check</h3>
<details><summary> <pre>test_pack.py::PackIndexTests::test_index_check</pre></summary><pre>
self = <tests.test_pack.PackIndexTests testMethod=test_index_check>

    def test_index_check(self):
        p = self.get_pack_index(pack1_sha)
>       self.assertSucceeds(p.check)
E       AttributeError: 'NoneType' object has no attribute 'check'

tests/test_pack.py:144: AttributeError
</pre>
</details>
<h3 id="test_packpypackindexteststest_index_len">test_pack.py::PackIndexTests::test_index_len</h3>
<details><summary> <pre>test_pack.py::PackIndexTests::test_index_len</pre></summary><pre>
self = <tests.test_pack.PackIndexTests testMethod=test_index_len>

    def test_index_len(self):
        p = self.get_pack_index(pack1_sha)
>       self.assertEqual(3, len(p))
E       TypeError: object of type 'NoneType' has no len()

tests/test_pack.py:129: TypeError
</pre>
</details>
<h3 id="test_packpypackindexteststest_iter">test_pack.py::PackIndexTests::test_iter</h3>
<details><summary> <pre>test_pack.py::PackIndexTests::test_iter</pre></summary><pre>
self = <tests.test_pack.PackIndexTests testMethod=test_iter>

    def test_iter(self):
        p = self.get_pack_index(pack1_sha)
>       self.assertEqual({tree_sha, commit_sha, a_sha}, set(p))
E       TypeError: 'NoneType' object is not iterable

tests/test_pack.py:160: TypeError
</pre>
</details>
<h3 id="test_packpypackindexteststest_iterentries">test_pack.py::PackIndexTests::test_iterentries</h3>
<details><summary> <pre>test_pack.py::PackIndexTests::test_iterentries</pre></summary><pre>
self = <tests.test_pack.PackIndexTests testMethod=test_iterentries>

    def test_iterentries(self):
        p = self.get_pack_index(pack1_sha)
>       entries = [(sha_to_hex(s), o, c) for s, o, c in p.iterentries()]
E       AttributeError: 'NoneType' object has no attribute 'iterentries'

tests/test_pack.py:148: AttributeError
</pre>
</details>
<h3 id="test_packpypackindexteststest_object_offset">test_pack.py::PackIndexTests::test_object_offset</h3>
<details><summary> <pre>test_pack.py::PackIndexTests::test_object_offset</pre></summary><pre>
self = <tests.test_pack.PackIndexTests testMethod=test_object_offset>

    def test_object_offset(self):
        """Tests that the correct object offset is returned from the index."""
        p = self.get_pack_index(pack1_sha)
>       self.assertRaises(KeyError, p.object_offset, pack1_sha)
E       AttributeError: 'NoneType' object has no attribute 'object_offset'

tests/test_pack.py:114: AttributeError
</pre>
</details>
<h3 id="test_packpypackindexteststest_object_sha1">test_pack.py::PackIndexTests::test_object_sha1</h3>
<details><summary> <pre>test_pack.py::PackIndexTests::test_object_sha1</pre></summary><pre>
self = <tests.test_pack.PackIndexTests testMethod=test_object_sha1>

    def test_object_sha1(self):
        """Tests that the correct object offset is returned from the index."""
        p = self.get_pack_index(pack1_sha)
>       self.assertRaises(KeyError, p.object_sha1, 876)
E       AttributeError: 'NoneType' object has no attribute 'object_sha1'

tests/test_pack.py:122: AttributeError
</pre>
</details>
<h3 id="test_packpytestpackdeltastest_change">test_pack.py::TestPackDeltas::test_change</h3>
<details><summary> <pre>test_pack.py::TestPackDeltas::test_change</pre></summary><pre>
self = <tests.test_pack.TestPackDeltas testMethod=test_change>

    def test_change(self):
>       self._test_roundtrip(self.test_string1, self.test_string2)

tests/test_pack.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pack.TestPackDeltas testMethod=test_change>
base = b'The answer was flailing in the wind'
target = b'The answer was falling down the pipe'

    def _test_roundtrip(self, base, target):
        self.assertEqual(
>           target, b"".join(apply_delta(base, list(create_delta(base, target))))
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_pack.py:174: TypeError
</pre>
</details>
<h3 id="test_packpytestpackdeltastest_dest_overflow">test_pack.py::TestPackDeltas::test_dest_overflow</h3>
<details><summary> <pre>test_pack.py::TestPackDeltas::test_dest_overflow</pre></summary><pre>
self = <tests.test_pack.TestPackDeltas testMethod=test_dest_overflow>

    def test_dest_overflow(self):
>       self.assertRaises(
            ApplyDeltaError,
            apply_delta,
            b"a" * 0x10000,
            b"\x80\x80\x04\x80\x80\x04\x80" + b"a" * 0x10000,
        )
E       AssertionError: ApplyDeltaError not raised by apply_delta

tests/test_pack.py:202: AssertionError
</pre>
</details>
<h3 id="test_packpytestpackdeltastest_empty_to_big">test_pack.py::TestPackDeltas::test_empty_to_big</h3>
<details><summary> <pre>test_pack.py::TestPackDeltas::test_empty_to_big</pre></summary><pre>
self = <tests.test_pack.TestPackDeltas testMethod=test_empty_to_big>

    def test_empty_to_big(self):
>       self._test_roundtrip(self.test_string_empty, self.test_string_big)

tests/test_pack.py:190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pack.TestPackDeltas testMethod=test_empty_to_big>, base = b''
target = b'ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ...ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ'

    def _test_roundtrip(self, base, target):
        self.assertEqual(
>           target, b"".join(apply_delta(base, list(create_delta(base, target))))
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_pack.py:174: TypeError
</pre>
</details>
<h3 id="test_packpytestpackdeltastest_empty_to_huge">test_pack.py::TestPackDeltas::test_empty_to_huge</h3>
<details><summary> <pre>test_pack.py::TestPackDeltas::test_empty_to_huge</pre></summary><pre>
self = <tests.test_pack.TestPackDeltas testMethod=test_empty_to_huge>

    def test_empty_to_huge(self):
>       self._test_roundtrip(self.test_string_empty, self.test_string_huge)

tests/test_pack.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pack.TestPackDeltas testMethod=test_empty_to_huge>
base = b''
target = b'ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ...ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ'

    def _test_roundtrip(self, base, target):
        self.assertEqual(
>           target, b"".join(apply_delta(base, list(create_delta(base, target))))
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_pack.py:174: TypeError
</pre>
</details>
<h3 id="test_packpytestpackdeltastest_huge_copy">test_pack.py::TestPackDeltas::test_huge_copy</h3>
<details><summary> <pre>test_pack.py::TestPackDeltas::test_huge_copy</pre></summary><pre>
self = <tests.test_pack.TestPackDeltas testMethod=test_huge_copy>

    def test_huge_copy(self):
>       self._test_roundtrip(
            self.test_string_huge + self.test_string1,
            self.test_string_huge + self.test_string2,
        )

tests/test_pack.py:196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pack.TestPackDeltas testMethod=test_huge_copy>
base = b'ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ...ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZThe answer was flailing in the wind'
target = b'ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ...ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZThe answer was falling down the pipe'

    def _test_roundtrip(self, base, target):
        self.assertEqual(
>           target, b"".join(apply_delta(base, list(create_delta(base, target))))
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_pack.py:174: TypeError
</pre>
</details>
<h3 id="test_packpytestpackdeltastest_nochange">test_pack.py::TestPackDeltas::test_nochange</h3>
<details><summary> <pre>test_pack.py::TestPackDeltas::test_nochange</pre></summary><pre>
self = <tests.test_pack.TestPackDeltas testMethod=test_nochange>

    def test_nochange(self):
>       self._test_roundtrip(self.test_string1, self.test_string1)

tests/test_pack.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pack.TestPackDeltas testMethod=test_nochange>
base = b'The answer was flailing in the wind'
target = b'The answer was flailing in the wind'

    def _test_roundtrip(self, base, target):
        self.assertEqual(
>           target, b"".join(apply_delta(base, list(create_delta(base, target))))
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_pack.py:174: TypeError
</pre>
</details>
<h3 id="test_packpytestpackdeltastest_nochange_huge">test_pack.py::TestPackDeltas::test_nochange_huge</h3>
<details><summary> <pre>test_pack.py::TestPackDeltas::test_nochange_huge</pre></summary><pre>
self = <tests.test_pack.TestPackDeltas testMethod=test_nochange_huge>

    def test_nochange_huge(self):
>       self._test_roundtrip(self.test_string_huge, self.test_string_huge)

tests/test_pack.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pack.TestPackDeltas testMethod=test_nochange_huge>
base = b'ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ...ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ'
target = b'ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ...ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ'

    def _test_roundtrip(self, base, target):
        self.assertEqual(
>           target, b"".join(apply_delta(base, list(create_delta(base, target))))
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_pack.py:174: TypeError
</pre>
</details>
<h3 id="test_packpytestpackdeltastest_pypy_issue">test_pack.py::TestPackDeltas::test_pypy_issue</h3>
<details><summary> <pre>test_pack.py::TestPackDeltas::test_pypy_issue</pre></summary><pre>
self = <tests.test_pack.TestPackDeltas testMethod=test_pypy_issue>

    def test_pypy_issue(self):
        # Test for https://github.com/jelmer/dulwich/issues/509 /
        # https://bitbucket.org/pypy/pypy/issues/2499/cpyext-pystring_asstring-doesnt-work
        chunks = [
            b"tree 03207ccf58880a748188836155ceed72f03d65d6\n"
            b"parent 408fbab530fd4abe49249a636a10f10f44d07a21\n"
            b"author Victor Stinner <victor.stinner@gmail.com> "
            b"1421355207 +0100\n"
            b"committer Victor Stinner <victor.stinner@gmail.com> "
            b"1421355207 +0100\n"
            b"\n"
            b"Backout changeset 3a06020af8cf\n"
            b"\nStreamWriter: close() now clears the reference to the "
            b"transport\n"
            b"\nStreamWriter now raises an exception if it is closed: "
            b"write(), writelines(),\n"
            b"write_eof(), can_write_eof(), get_extra_info(), drain().\n"
        ]
        delta = [
            b"\xcd\x03\xad\x03]tree ff3c181a393d5a7270cddc01ea863818a8621ca8\n"
            b"parent 20a103cc90135494162e819f98d0edfc1f1fba6b\x91]7\x0510738"
            b"\x91\x99@\x0b10738 +0100\x93\x04\x01\xc9"
        ]
        res = apply_delta(chunks, delta)
        expected = [
            b"tree ff3c181a393d5a7270cddc01ea863818a8621ca8\n"
            b"parent 20a103cc90135494162e819f98d0edfc1f1fba6b",
            b"\nauthor Victor Stinner <victor.stinner@gmail.com> 14213",
            b"10738",
            b" +0100\ncommitter Victor Stinner <victor.stinner@gmail.com> " b"14213",
            b"10738 +0100",
            b"\n\nStreamWriter: close() now clears the reference to the "
            b"transport\n\n"
            b"StreamWriter now raises an exception if it is closed: "
            b"write(), writelines(),\n"
            b"write_eof(), can_write_eof(), get_extra_info(), drain().\n",
        ]
>       self.assertEqual(b"".join(expected), b"".join(res))
E       TypeError: can only join an iterable

tests/test_pack.py:249: TypeError
</pre>
</details>
<h3 id="test_packpytestpackdeltastest_rewrite">test_pack.py::TestPackDeltas::test_rewrite</h3>
<details><summary> <pre>test_pack.py::TestPackDeltas::test_rewrite</pre></summary><pre>
self = <tests.test_pack.TestPackDeltas testMethod=test_rewrite>

    def test_rewrite(self):
>       self._test_roundtrip(self.test_string1, self.test_string3)

tests/test_pack.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pack.TestPackDeltas testMethod=test_rewrite>
base = b'The answer was flailing in the wind', target = b'zzzzz'

    def _test_roundtrip(self, base, target):
        self.assertEqual(
>           target, b"".join(apply_delta(base, list(create_delta(base, target))))
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_pack.py:174: TypeError
</pre>
</details>
<h3 id="test_packpytestpackdatatest_compute_file_sha">test_pack.py::TestPackData::test_compute_file_sha</h3>
<details><summary> <pre>test_pack.py::TestPackData::test_compute_file_sha</pre></summary><pre>
self = <tests.test_pack.TestPackData testMethod=test_compute_file_sha>

    def test_compute_file_sha(self):
        f = BytesIO(b"abcd1234wxyz")
        self.assertEqual(
>           sha1(b"abcd1234wxyz").hexdigest(), compute_file_sha(f).hexdigest()
        )
E       AttributeError: 'NoneType' object has no attribute 'hexdigest'

tests/test_pack.py:356: AttributeError
</pre>
</details>
<h3 id="test_packpytestpackdatatest_compute_file_sha_short_file">test_pack.py::TestPackData::test_compute_file_sha_short_file</h3>
<details><summary> <pre>test_pack.py::TestPackData::test_compute_file_sha_short_file</pre></summary><pre>
self = <tests.test_pack.TestPackData testMethod=test_compute_file_sha_short_file>

    def test_compute_file_sha_short_file(self):
        f = BytesIO(b"abcd1234wxyz")
>       self.assertRaises(AssertionError, compute_file_sha, f, end_ofs=-20)
E       AssertionError: AssertionError not raised by compute_file_sha

tests/test_pack.py:377: AssertionError
</pre>
</details>
<h3 id="test_packpytestpackdatatest_create_index_v1">test_pack.py::TestPackData::test_create_index_v1</h3>
<details><summary> <pre>test_pack.py::TestPackData::test_create_index_v1</pre></summary><pre>
self = <tests.test_pack.TestPackData testMethod=test_create_index_v1>

    def test_create_index_v1(self):
>       with self.get_pack_data(pack1_sha) as p:

tests/test_pack.py:336: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:94: in get_pack_data
    return PackData(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1f9e61a0>
filename = '/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481.pack'
file = None, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       AttributeError: 'NoneType' object has no attribute 'read'

dulwich/pack.py:751: AttributeError
</pre>
</details>
<h3 id="test_packpytestpackdatatest_create_index_v2">test_pack.py::TestPackData::test_create_index_v2</h3>
<details><summary> <pre>test_pack.py::TestPackData::test_create_index_v2</pre></summary><pre>
self = <tests.test_pack.TestPackData testMethod=test_create_index_v2>

    def test_create_index_v2(self):
>       with self.get_pack_data(pack1_sha) as p:

tests/test_pack.py:345: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:94: in get_pack_data
    return PackData(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1f7b9210>
filename = '/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481.pack'
file = None, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       AttributeError: 'NoneType' object has no attribute 'read'

dulwich/pack.py:751: AttributeError
</pre>
</details>
<h3 id="test_packpytestpackdatatest_create_pack">test_pack.py::TestPackData::test_create_pack</h3>
<details><summary> <pre>test_pack.py::TestPackData::test_create_pack</pre></summary><pre>
self = <tests.test_pack.TestPackData testMethod=test_create_pack>

    def test_create_pack(self):
>       self.get_pack_data(pack1_sha).close()

tests/test_pack.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:94: in get_pack_data
    return PackData(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1ef20b80>
filename = '/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481.pack'
file = None, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       AttributeError: 'NoneType' object has no attribute 'read'

dulwich/pack.py:751: AttributeError
</pre>
</details>
<h3 id="test_packpytestpackdatatest_from_file">test_pack.py::TestPackData::test_from_file</h3>
<details><summary> <pre>test_pack.py::TestPackData::test_from_file</pre></summary><pre>
self = <tests.test_pack.TestPackData testMethod=test_from_file>

    def test_from_file(self):
        path = os.path.join(
            self.datadir, "pack-{}.pack".format(pack1_sha.decode("ascii"))
        )
        with open(path, "rb") as f:
>           PackData.from_file(f, os.path.getsize(path))
E           AttributeError: type object 'PackData' has no attribute 'from_file'

tests/test_pack.py:263: AttributeError
</pre>
</details>
<h3 id="test_packpytestpackdatatest_index_check">test_pack.py::TestPackData::test_index_check</h3>
<details><summary> <pre>test_pack.py::TestPackData::test_index_check</pre></summary><pre>
self = <tests.test_pack.TestPackData testMethod=test_index_check>

    def test_index_check(self):
>       with self.get_pack_data(pack1_sha) as p:

tests/test_pack.py:270: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:94: in get_pack_data
    return PackData(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1ed5afe0>
filename = '/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481.pack'
file = None, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       AttributeError: 'NoneType' object has no attribute 'read'

dulwich/pack.py:751: AttributeError
</pre>
</details>
<h3 id="test_packpytestpackdatatest_iter_unpacked">test_pack.py::TestPackData::test_iter_unpacked</h3>
<details><summary> <pre>test_pack.py::TestPackData::test_iter_unpacked</pre></summary><pre>
self = <tests.test_pack.TestPackData testMethod=test_iter_unpacked>

    def test_iter_unpacked(self):
>       with self.get_pack_data(pack1_sha) as p:

tests/test_pack.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:94: in get_pack_data
    return PackData(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1eef94e0>
filename = '/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481.pack'
file = None, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       AttributeError: 'NoneType' object has no attribute 'read'

dulwich/pack.py:751: AttributeError
</pre>
</details>
<h3 id="test_packpytestpackdatatest_iterentries">test_pack.py::TestPackData::test_iterentries</h3>
<details><summary> <pre>test_pack.py::TestPackData::test_iterentries</pre></summary><pre>
self = <tests.test_pack.TestPackData testMethod=test_iterentries>

    def test_iterentries(self):
>       with self.get_pack_data(pack1_sha) as p:

tests/test_pack.py:312: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:94: in get_pack_data
    return PackData(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1f9ce590>
filename = '/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481.pack'
file = None, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       AttributeError: 'NoneType' object has no attribute 'read'

dulwich/pack.py:751: AttributeError
</pre>
</details>
<h3 id="test_packpytestpackdatatest_pack_len">test_pack.py::TestPackData::test_pack_len</h3>
<details><summary> <pre>test_pack.py::TestPackData::test_pack_len</pre></summary><pre>
self = <tests.test_pack.TestPackData testMethod=test_pack_len>

    def test_pack_len(self):
>       with self.get_pack_data(pack1_sha) as p:

tests/test_pack.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:94: in get_pack_data
    return PackData(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1ec98b80>
filename = '/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481.pack'
file = None, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       AttributeError: 'NoneType' object has no attribute 'read'

dulwich/pack.py:751: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_checksum_mismatch">test_pack.py::TestPack::test_checksum_mismatch</h3>
<details><summary> <pre>test_pack.py::TestPack::test_checksum_mismatch</pre></summary><pre>
self = <tests.test_pack.TestPack testMethod=test_checksum_mismatch>

    def test_checksum_mismatch(self):
>       with self.get_pack_data(pack1_sha) as data:

tests/test_pack.py:508: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:94: in get_pack_data
    return PackData(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1ef069e0>
filename = '/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481.pack'
file = None, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       AttributeError: 'NoneType' object has no attribute 'read'

dulwich/pack.py:751: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_commit_obj">test_pack.py::TestPack::test_commit_obj</h3>
<details><summary> <pre>test_pack.py::TestPack::test_commit_obj</pre></summary><pre>
self = <tests.test_pack.TestPack testMethod=test_commit_obj>

    def test_commit_obj(self):
        with self.get_pack(pack1_sha) as p:
>           commit = p[commit_sha]

tests/test_pack.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
sha1 = b'f18faa16531ac570a3fdc8c7ca16682548dafd12'

    def __getitem__(self, sha1: bytes) -> ShaFile:
        """Retrieve the specified SHA1."""
>       type, uncomp = self.get_raw(sha1)
E       AttributeError: 'Pack' object has no attribute 'get_raw'. Did you mean: 'get_ref'?

dulwich/pack.py:1188: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_pack.TestPack testMethod=test_commit_obj>

    def test_commit_obj(self):
>       with self.get_pack(pack1_sha) as p:

tests/test_pack.py:448: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'AttributeError'>
exc_val = AttributeError("'Pack' object has no attribute 'get_raw'")
exc_tb = <traceback object at 0x7eec1fb6c040>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_contains">test_pack.py::TestPack::test_contains</h3>
<details><summary> <pre>test_pack.py::TestPack::test_contains</pre></summary><pre>
self = <tests.test_pack.TestPack testMethod=test_contains>

    def test_contains(self):
        with self.get_pack(pack1_sha) as p:
>           self.assertIn(tree_sha, p)

tests/test_pack.py:391: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
sha1 = b'b2a2766a2879c209ab1176e7e778b81ae422eeaa'

    def __contains__(self, sha1: bytes) -> bool:
        """Check whether this pack contains a particular SHA1."""
        try:
>           self.index.object_offset(sha1)
E           AttributeError: 'NoneType' object has no attribute 'object_offset'

dulwich/pack.py:1181: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_pack.TestPack testMethod=test_contains>

    def test_contains(self):
>       with self.get_pack(pack1_sha) as p:

tests/test_pack.py:390: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'AttributeError'>
exc_val = AttributeError("'NoneType' object has no attribute 'object_offset'")
exc_tb = <traceback object at 0x7eec1ecd7300>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_copy_1">test_pack.py::TestPack::test_copy</h3>
<details><summary> <pre>test_pack.py::TestPack::test_copy</pre></summary><pre>
self = <tests.test_pack.TestPack testMethod=test_copy>

    def test_copy(self):
        with self.get_pack(pack1_sha) as origpack:
>           self.assertSucceeds(origpack.index.check)
E           AttributeError: 'NoneType' object has no attribute 'check'

tests/test_pack.py:429: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_pack.TestPack testMethod=test_copy>

    def test_copy(self):
>       with self.get_pack(pack1_sha) as origpack:

tests/test_pack.py:428: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'AttributeError'>
exc_val = AttributeError("'NoneType' object has no attribute 'check'")
exc_tb = <traceback object at 0x7eec1ebe93c0>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_get">test_pack.py::TestPack::test_get</h3>
<details><summary> <pre>test_pack.py::TestPack::test_get</pre></summary><pre>
self = <tests.test_pack.TestPack testMethod=test_get>

    def test_get(self):
        with self.get_pack(pack1_sha) as p:
>           self.assertEqual(type(p[tree_sha]), Tree)

tests/test_pack.py:395: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
sha1 = b'b2a2766a2879c209ab1176e7e778b81ae422eeaa'

    def __getitem__(self, sha1: bytes) -> ShaFile:
        """Retrieve the specified SHA1."""
>       type, uncomp = self.get_raw(sha1)
E       AttributeError: 'Pack' object has no attribute 'get_raw'. Did you mean: 'get_ref'?

dulwich/pack.py:1188: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_pack.TestPack testMethod=test_get>

    def test_get(self):
>       with self.get_pack(pack1_sha) as p:

tests/test_pack.py:394: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'AttributeError'>
exc_val = AttributeError("'Pack' object has no attribute 'get_raw'")
exc_tb = <traceback object at 0x7eec1fd4f940>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_get_object_at">test_pack.py::TestPack::test_get_object_at</h3>
<details><summary> <pre>test_pack.py::TestPack::test_get_object_at</pre></summary><pre>
self = <tests.test_pack.TestPack testMethod=test_get_object_at>

    def test_get_object_at(self):
        """Tests random access for non-delta objects."""
        with self.get_pack(pack1_sha) as p:
>           obj = p[a_sha]

tests/test_pack.py:417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
sha1 = b'6f670c0fb53f9463760b7295fbb814e965fb20c8'

    def __getitem__(self, sha1: bytes) -> ShaFile:
        """Retrieve the specified SHA1."""
>       type, uncomp = self.get_raw(sha1)
E       AttributeError: 'Pack' object has no attribute 'get_raw'. Did you mean: 'get_ref'?

dulwich/pack.py:1188: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_pack.TestPack testMethod=test_get_object_at>

    def test_get_object_at(self):
        """Tests random access for non-delta objects."""
>       with self.get_pack(pack1_sha) as p:

tests/test_pack.py:416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'AttributeError'>
exc_val = AttributeError("'Pack' object has no attribute 'get_raw'")
exc_tb = <traceback object at 0x7eec1ed4f100>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_iter">test_pack.py::TestPack::test_iter</h3>
<details><summary> <pre>test_pack.py::TestPack::test_iter</pre></summary><pre>
self = <tests.test_pack.TestPack testMethod=test_iter>

    def test_iter(self):
        with self.get_pack(pack1_sha) as p:
>           self.assertEqual({tree_sha, commit_sha, a_sha}, set(p))

tests/test_pack.py:399: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')

    def __iter__(self):
        """Iterate over all the sha1s of the objects in this pack."""
>       return iter(self.index)
E       TypeError: 'NoneType' object is not iterable

dulwich/pack.py:1164: TypeError

During handling of the above exception, another exception occurred:

self = <tests.test_pack.TestPack testMethod=test_iter>

    def test_iter(self):
>       with self.get_pack(pack1_sha) as p:

tests/test_pack.py:398: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'TypeError'>
exc_val = TypeError("'NoneType' object is not iterable")
exc_tb = <traceback object at 0x7eec1eb8dd80>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_iterobjects">test_pack.py::TestPack::test_iterobjects</h3>
<details><summary> <pre>test_pack.py::TestPack::test_iterobjects</pre></summary><pre>
self = <tests.test_pack.TestPack testMethod=test_iterobjects>

    def test_iterobjects(self):
        with self.get_pack(pack1_sha) as p:
>           expected = {p[s] for s in [commit_sha, tree_sha, a_sha]}

tests/test_pack.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:403: in <setcomp>
    expected = {p[s] for s in [commit_sha, tree_sha, a_sha]}
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
sha1 = b'f18faa16531ac570a3fdc8c7ca16682548dafd12'

    def __getitem__(self, sha1: bytes) -> ShaFile:
        """Retrieve the specified SHA1."""
>       type, uncomp = self.get_raw(sha1)
E       AttributeError: 'Pack' object has no attribute 'get_raw'. Did you mean: 'get_ref'?

dulwich/pack.py:1188: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_pack.TestPack testMethod=test_iterobjects>

    def test_iterobjects(self):
>       with self.get_pack(pack1_sha) as p:

tests/test_pack.py:402: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'AttributeError'>
exc_val = AttributeError("'Pack' object has no attribute 'get_raw'")
exc_tb = <traceback object at 0x7eec1ea7aa80>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_iterobjects_2">test_pack.py::TestPack::test_iterobjects_2</h3>
<details><summary> <pre>test_pack.py::TestPack::test_iterobjects_2</pre></summary><pre>
self = <tests.test_pack.TestPack testMethod=test_iterobjects_2>

    def test_iterobjects_2(self):
        with self.get_pack(pack1_sha) as p:
>           objs = {o.id: o for o in p.iterobjects()}
E           TypeError: 'NoneType' object is not iterable

tests/test_pack.py:521: TypeError

During handling of the above exception, another exception occurred:

self = <tests.test_pack.TestPack testMethod=test_iterobjects_2>

    def test_iterobjects_2(self):
>       with self.get_pack(pack1_sha) as p:

tests/test_pack.py:520: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'TypeError'>
exc_val = TypeError("'NoneType' object is not iterable")
exc_tb = <traceback object at 0x7eec1efc8140>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_iterobjects_subset">test_pack.py::TestPack::test_iterobjects_subset</h3>
<details><summary> <pre>test_pack.py::TestPack::test_iterobjects_subset</pre></summary><pre>
self = <tests.test_pack.TestPack testMethod=test_iterobjects_subset>

    def test_iterobjects_subset(self):
        with self.get_pack(pack1_sha) as p:
>           objs = {o.id: o for o in p.iterobjects_subset([commit_sha])}
E           AttributeError: 'Pack' object has no attribute 'iterobjects_subset'

tests/test_pack.py:530: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_pack.TestPack testMethod=test_iterobjects_subset>

    def test_iterobjects_subset(self):
>       with self.get_pack(pack1_sha) as p:

tests/test_pack.py:529: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'AttributeError'>
exc_val = AttributeError("'Pack' object has no attribute 'iterobjects_subset'")
exc_tb = <traceback object at 0x7eec1ed9a300>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_keep_message">test_pack.py::TestPack::test_keep_message</h3>
<details><summary> <pre>test_pack.py::TestPack::test_keep_message</pre></summary><pre>
self = <tests.test_pack.TestPack testMethod=test_keep_message>

    def test_keep_message(self):
        with self.get_pack(pack1_sha) as p:
>           p = self._copy_pack(p)

tests/test_pack.py:474: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pack.TestPack testMethod=test_keep_message>
origpack = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')

    def _copy_pack(self, origpack):
        basename = os.path.join(self.tempdir, "somepack")
>       write_pack(basename, origpack.pack_tuples())
E       AttributeError: 'Pack' object has no attribute 'pack_tuples'

tests/test_pack.py:455: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_pack.TestPack testMethod=test_keep_message>

    def test_keep_message(self):
>       with self.get_pack(pack1_sha) as p:

tests/test_pack.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'AttributeError'>
exc_val = AttributeError("'Pack' object has no attribute 'pack_tuples'")
exc_tb = <traceback object at 0x7eec1ec6f140>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_keep_no_message">test_pack.py::TestPack::test_keep_no_message</h3>
<details><summary> <pre>test_pack.py::TestPack::test_keep_no_message</pre></summary><pre>
self = <tests.test_pack.TestPack testMethod=test_keep_no_message>

    def test_keep_no_message(self):
        with self.get_pack(pack1_sha) as p:
>           p = self._copy_pack(p)

tests/test_pack.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pack.TestPack testMethod=test_keep_no_message>
origpack = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')

    def _copy_pack(self, origpack):
        basename = os.path.join(self.tempdir, "somepack")
>       write_pack(basename, origpack.pack_tuples())
E       AttributeError: 'Pack' object has no attribute 'pack_tuples'

tests/test_pack.py:455: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_pack.TestPack testMethod=test_keep_no_message>

    def test_keep_no_message(self):
>       with self.get_pack(pack1_sha) as p:

tests/test_pack.py:459: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'AttributeError'>
exc_val = AttributeError("'Pack' object has no attribute 'pack_tuples'")
exc_tb = <traceback object at 0x7eec1ec8ddc0>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_len">test_pack.py::TestPack::test_len</h3>
<details><summary> <pre>test_pack.py::TestPack::test_len</pre></summary><pre>
self = <tests.test_pack.TestPack testMethod=test_len>

    def test_len(self):
        with self.get_pack(pack1_sha) as p:
>           self.assertEqual(3, len(p))

tests/test_pack.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')

    def __len__(self) -> int:
        """Number of entries in this pack."""
>       return len(self.index)
E       TypeError: object of type 'NoneType' has no len()

dulwich/pack.py:1157: TypeError

During handling of the above exception, another exception occurred:

self = <tests.test_pack.TestPack testMethod=test_len>

    def test_len(self):
>       with self.get_pack(pack1_sha) as p:

tests/test_pack.py:386: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'TypeError'>
exc_val = TypeError("object of type 'NoneType' has no len()")
exc_tb = <traceback object at 0x7eec1ebb5e40>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_length_mismatch">test_pack.py::TestPack::test_length_mismatch</h3>
<details><summary> <pre>test_pack.py::TestPack::test_length_mismatch</pre></summary><pre>
self = <tests.test_pack.TestPack testMethod=test_length_mismatch>

    def test_length_mismatch(self):
>       with self.get_pack_data(pack1_sha) as data:

tests/test_pack.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:94: in get_pack_data
    return PackData(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1ed581c0>
filename = '/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481.pack'
file = None, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       AttributeError: 'NoneType' object has no attribute 'read'

dulwich/pack.py:751: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_name">test_pack.py::TestPack::test_name</h3>
<details><summary> <pre>test_pack.py::TestPack::test_name</pre></summary><pre>
self = <tests.test_pack.TestPack testMethod=test_name>

    def test_name(self):
        with self.get_pack(pack1_sha) as p:
>           self.assertEqual(pack1_sha, p.name())
E           AssertionError: b'bc63ddad95e7321ee734ea11a7a62d314e0d7481' != None

tests/test_pack.py:490: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_pack.TestPack testMethod=test_name>

    def test_name(self):
>       with self.get_pack(pack1_sha) as p:

tests/test_pack.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'AssertionError'>
exc_val = AssertionError("b'bc63ddad95e7321ee734ea11a7a62d314e0d7481' != None")
exc_tb = <traceback object at 0x7eec1ec2ed40>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_packpytestpacktest_pack_tuples">test_pack.py::TestPack::test_pack_tuples</h3>
<details><summary> <pre>test_pack.py::TestPack::test_pack_tuples</pre></summary><pre>
self = <tests.test_pack.TestPack testMethod=test_pack_tuples>

    def test_pack_tuples(self):
        with self.get_pack(pack1_sha) as p:
>           tuples = p.pack_tuples()
E           AttributeError: 'Pack' object has no attribute 'pack_tuples'

tests/test_pack.py:408: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_pack.TestPack testMethod=test_pack_tuples>

    def test_pack_tuples(self):
>       with self.get_pack(pack1_sha) as p:

tests/test_pack.py:407: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Pack('/testbed/testdata/packs/pack-bc63ddad95e7321ee734ea11a7a62d314e0d7481')
exc_type = <class 'AttributeError'>
exc_val = AttributeError("'Pack' object has no attribute 'pack_tuples'")
exc_tb = <traceback object at 0x7eec1eb0b600>

    def __exit__(self, exc_type, exc_val, exc_tb):
>       self.close()
E       AttributeError: 'Pack' object has no attribute 'close'

dulwich/pack.py:1150: AttributeError
</pre>
</details>
<h3 id="test_packpytestthinpacktest_get_raw">test_pack.py::TestThinPack::test_get_raw</h3>
<details><summary> <pre>test_pack.py::TestThinPack::test_get_raw</pre></summary><pre>
self = <tests.test_pack.TestThinPack testMethod=test_get_raw>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
        self.blobs = {}
        for blob in (b"foo", b"bar", b"foo1234", b"bar2468"):
            self.blobs[blob] = make_object(Blob, data=blob)
        self.store.add_object(self.blobs[b"foo"])
        self.store.add_object(self.blobs[b"bar"])

        # Build a thin pack. 'foo' is as an external reference, 'bar' an
        # internal reference.
        self.pack_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.pack_dir)
        self.pack_prefix = os.path.join(self.pack_dir, "pack")

        with open(self.pack_prefix + ".pack", "wb") as f:
            build_pack(
                f,
                [
>                   (REF_DELTA, (self.blobs[b"foo"].id, b"foo1234")),
                    (Blob.type_num, b"bar"),
                    (REF_DELTA, (self.blobs[b"bar"].id, b"bar2468")),
                ],
                store=self.store,
            )
E           AttributeError: 'NoneType' object has no attribute 'id'

tests/test_pack.py:555: AttributeError
</pre>
</details>
<h3 id="test_packpytestthinpacktest_get_unpacked_object">test_pack.py::TestThinPack::test_get_unpacked_object</h3>
<details><summary> <pre>test_pack.py::TestThinPack::test_get_unpacked_object</pre></summary><pre>
self = <tests.test_pack.TestThinPack testMethod=test_get_unpacked_object>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
        self.blobs = {}
        for blob in (b"foo", b"bar", b"foo1234", b"bar2468"):
            self.blobs[blob] = make_object(Blob, data=blob)
        self.store.add_object(self.blobs[b"foo"])
        self.store.add_object(self.blobs[b"bar"])

        # Build a thin pack. 'foo' is as an external reference, 'bar' an
        # internal reference.
        self.pack_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.pack_dir)
        self.pack_prefix = os.path.join(self.pack_dir, "pack")

        with open(self.pack_prefix + ".pack", "wb") as f:
            build_pack(
                f,
                [
>                   (REF_DELTA, (self.blobs[b"foo"].id, b"foo1234")),
                    (Blob.type_num, b"bar"),
                    (REF_DELTA, (self.blobs[b"bar"].id, b"bar2468")),
                ],
                store=self.store,
            )
E           AttributeError: 'NoneType' object has no attribute 'id'

tests/test_pack.py:555: AttributeError
</pre>
</details>
<h3 id="test_packpytestthinpacktest_iterobjects">test_pack.py::TestThinPack::test_iterobjects</h3>
<details><summary> <pre>test_pack.py::TestThinPack::test_iterobjects</pre></summary><pre>
self = <tests.test_pack.TestThinPack testMethod=test_iterobjects>

    def setUp(self):
        super().setUp()
        self.store = MemoryObjectStore()
        self.blobs = {}
        for blob in (b"foo", b"bar", b"foo1234", b"bar2468"):
            self.blobs[blob] = make_object(Blob, data=blob)
        self.store.add_object(self.blobs[b"foo"])
        self.store.add_object(self.blobs[b"bar"])

        # Build a thin pack. 'foo' is as an external reference, 'bar' an
        # internal reference.
        self.pack_dir = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, self.pack_dir)
        self.pack_prefix = os.path.join(self.pack_dir, "pack")

        with open(self.pack_prefix + ".pack", "wb") as f:
            build_pack(
                f,
                [
>                   (REF_DELTA, (self.blobs[b"foo"].id, b"foo1234")),
                    (Blob.type_num, b"bar"),
                    (REF_DELTA, (self.blobs[b"bar"].id, b"bar2468")),
                ],
                store=self.store,
            )
E           AttributeError: 'NoneType' object has no attribute 'id'

tests/test_pack.py:555: AttributeError
</pre>
</details>
<h3 id="test_packpywritepackteststest_write_pack_header">test_pack.py::WritePackTests::test_write_pack_header</h3>
<details><summary> <pre>test_pack.py::WritePackTests::test_write_pack_header</pre></summary><pre>
self = <tests.test_pack.WritePackTests testMethod=test_write_pack_header>

    def test_write_pack_header(self):
        f = BytesIO()
        write_pack_header(f.write, 42)
>       self.assertEqual(b"PACK\x00\x00\x00\x02\x00\x00\x00*", f.getvalue())
E       AssertionError: b'PACK\x00\x00\x00\x02\x00\x00\x00*' != b''

tests/test_pack.py:627: AssertionError
</pre>
</details>
<h3 id="test_packpywritepackteststest_write_pack_object">test_pack.py::WritePackTests::test_write_pack_object</h3>
<details><summary> <pre>test_pack.py::WritePackTests::test_write_pack_object</pre></summary><pre>
self = <tests.test_pack.WritePackTests testMethod=test_write_pack_object>

    def test_write_pack_object(self):
        f = BytesIO()
        f.write(b"header")
        offset = f.tell()
        crc32 = write_pack_object(f.write, Blob.type_num, b"blob")
>       self.assertEqual(crc32, zlib.crc32(f.getvalue()[6:]) & 0xFFFFFFFF)
E       AssertionError: None != 0

tests/test_pack.py:634: AssertionError
</pre>
</details>
<h3 id="test_packpywritepackteststest_write_pack_object_compression_level">test_pack.py::WritePackTests::test_write_pack_object_compression_level</h3>
<details><summary> <pre>test_pack.py::WritePackTests::test_write_pack_object_compression_level</pre></summary><pre>
self = <tests.test_pack.WritePackTests testMethod=test_write_pack_object_compression_level>

    def test_write_pack_object_compression_level(self):
        f = BytesIO()
        f.write(b"header")
        offset = f.tell()
        sha_a = sha1(b"foo")
        sha_b = sha_a.copy()
        write_pack_object(
            f.write, Blob.type_num, b"blob", sha=sha_a, compression_level=6
        )
>       self.assertNotEqual(sha_a.digest(), sha_b.digest())
E       AssertionError: b'\x0b\xee\xc7\xb5\xea?\x0f\xdb\xc9]\r\xd4\x7f<[\xc2u\xda\x8a3' == b'\x0b\xee\xc7\xb5\xea?\x0f\xdb\xc9]\r\xd4\x7f<[\xc2u\xda\x8a3'

tests/test_pack.py:665: AssertionError
</pre>
</details>
<h3 id="test_packpywritepackteststest_write_pack_object_sha">test_pack.py::WritePackTests::test_write_pack_object_sha</h3>
<details><summary> <pre>test_pack.py::WritePackTests::test_write_pack_object_sha</pre></summary><pre>
self = <tests.test_pack.WritePackTests testMethod=test_write_pack_object_sha>

    def test_write_pack_object_sha(self):
        f = BytesIO()
        f.write(b"header")
        offset = f.tell()
        sha_a = sha1(b"foo")
        sha_b = sha_a.copy()
        write_pack_object(f.write, Blob.type_num, b"blob", sha=sha_a)
>       self.assertNotEqual(sha_a.digest(), sha_b.digest())
E       AssertionError: b'\x0b\xee\xc7\xb5\xea?\x0f\xdb\xc9]\r\xd4\x7f<[\xc2u\xda\x8a3' == b'\x0b\xee\xc7\xb5\xea?\x0f\xdb\xc9]\r\xd4\x7f<[\xc2u\xda\x8a3'

tests/test_pack.py:652: AssertionError
</pre>
</details>
<h3 id="test_packpytestmemoryindexwritingtest_empty">test_pack.py::TestMemoryIndexWriting::test_empty</h3>
<details><summary> <pre>test_pack.py::TestMemoryIndexWriting::test_empty</pre></summary><pre>
self = <tests.test_pack.TestMemoryIndexWriting testMethod=test_empty>

    def test_empty(self):
        idx = self.index("empty.idx", [], pack_checksum)
>       self.assertEqual(idx.get_pack_checksum(), pack_checksum)
E       AssertionError: None != b'r\x19\x80\xe8f\xaf\x9a_\x93\xadgAD\xe1E\x9b\x8b\xa3\xe7\xb7'

tests/test_pack.py:685: AssertionError
</pre>
</details>
<h3 id="test_packpytestmemoryindexwritingtest_large">test_pack.py::TestMemoryIndexWriting::test_large</h3>
<details><summary> <pre>test_pack.py::TestMemoryIndexWriting::test_large</pre></summary><pre>
self = <tests.test_pack.TestMemoryIndexWriting testMethod=test_large>

    def test_large(self):
        entry1_sha = hex_to_sha("4e6388232ec39792661e2e75db8fb117fc869ce6")
        entry2_sha = hex_to_sha("e98f071751bd77f59967bfa671cd2caebdccc9a2")
        entries = [
            (entry1_sha, 0xF2972D0830529B87, 24),
            (entry2_sha, (~0xF2972D0830529B87) & (2**64 - 1), 92),
        ]
        if not self._supports_large:
            self.assertRaises(
                TypeError, self.index, "single.idx", entries, pack_checksum
            )
            return
        idx = self.index("single.idx", entries, pack_checksum)
>       self.assertEqual(idx.get_pack_checksum(), pack_checksum)
E       AssertionError: None != b'r\x19\x80\xe8f\xaf\x9a_\x93\xadgAD\xe1E\x9b\x8b\xa3\xe7\xb7'

tests/test_pack.py:701: AssertionError
</pre>
</details>
<h3 id="test_packpytestmemoryindexwritingtest_single">test_pack.py::TestMemoryIndexWriting::test_single</h3>
<details><summary> <pre>test_pack.py::TestMemoryIndexWriting::test_single</pre></summary><pre>
self = <tests.test_pack.TestMemoryIndexWriting testMethod=test_single>

    def test_single(self):
        entry_sha = hex_to_sha("6f670c0fb53f9463760b7295fbb814e965fb20c8")
        my_entries = [(entry_sha, 178, 42)]
        idx = self.index("single.idx", my_entries, pack_checksum)
>       self.assertEqual(idx.get_pack_checksum(), pack_checksum)
E       AssertionError: None != b'r\x19\x80\xe8f\xaf\x9a_\x93\xadgAD\xe1E\x9b\x8b\xa3\xe7\xb7'

tests/test_pack.py:719: AssertionError
</pre>
</details>
<h3 id="test_packpytestpackindexwritingv1test_empty">test_pack.py::TestPackIndexWritingv1::test_empty</h3>
<details><summary> <pre>test_pack.py::TestPackIndexWritingv1::test_empty</pre></summary><pre>
self = <tests.test_pack.TestPackIndexWritingv1 testMethod=test_empty>

    def test_empty(self):
>       idx = self.index("empty.idx", [], pack_checksum)

tests/test_pack.py:684: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:743: in index
    self.writeIndex(path, entries, pack_checksum)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pack.TestPackIndexWritingv1 testMethod=test_empty>
filename = '/tmp/tmpcif8veg5/empty.idx', entries = []
pack_checksum = b'r\x19\x80\xe8f\xaf\x9a_\x93\xadgAD\xe1E\x9b\x8b\xa3\xe7\xb7'

    def writeIndex(self, filename, entries, pack_checksum):
        # FIXME: Write to BytesIO instead rather than hitting disk ?
>       with GitFile(filename, "wb") as f:
E       AttributeError: __enter__

tests/test_pack.py:751: AttributeError
</pre>
</details>
<h3 id="test_packpytestpackindexwritingv1test_large">test_pack.py::TestPackIndexWritingv1::test_large</h3>
<details><summary> <pre>test_pack.py::TestPackIndexWritingv1::test_large</pre></summary><pre>
self = <tests.test_pack.TestPackIndexWritingv1 testMethod=test_large>

    def test_large(self):
        entry1_sha = hex_to_sha("4e6388232ec39792661e2e75db8fb117fc869ce6")
        entry2_sha = hex_to_sha("e98f071751bd77f59967bfa671cd2caebdccc9a2")
        entries = [
            (entry1_sha, 0xF2972D0830529B87, 24),
            (entry2_sha, (~0xF2972D0830529B87) & (2**64 - 1), 92),
        ]
        if not self._supports_large:
>           self.assertRaises(
                TypeError, self.index, "single.idx", entries, pack_checksum
            )

tests/test_pack.py:696: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:743: in index
    self.writeIndex(path, entries, pack_checksum)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def writeIndex(self, filename, entries, pack_checksum):
        # FIXME: Write to BytesIO instead rather than hitting disk ?
>       with GitFile(filename, "wb") as f:
E       AttributeError: __enter__

tests/test_pack.py:751: AttributeError
</pre>
</details>
<h3 id="test_packpytestpackindexwritingv1test_single">test_pack.py::TestPackIndexWritingv1::test_single</h3>
<details><summary> <pre>test_pack.py::TestPackIndexWritingv1::test_single</pre></summary><pre>
self = <tests.test_pack.TestPackIndexWritingv1 testMethod=test_single>

    def test_single(self):
        entry_sha = hex_to_sha("6f670c0fb53f9463760b7295fbb814e965fb20c8")
        my_entries = [(entry_sha, 178, 42)]
>       idx = self.index("single.idx", my_entries, pack_checksum)

tests/test_pack.py:718: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:743: in index
    self.writeIndex(path, entries, pack_checksum)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pack.TestPackIndexWritingv1 testMethod=test_single>
filename = '/tmp/tmpyni9s21q/single.idx'
entries = [(b'og\x0c\x0f\xb5?\x94cv\x0br\x95\xfb\xb8\x14\xe9e\xfb \xc8', 178, 42)]
pack_checksum = b'r\x19\x80\xe8f\xaf\x9a_\x93\xadgAD\xe1E\x9b\x8b\xa3\xe7\xb7'

    def writeIndex(self, filename, entries, pack_checksum):
        # FIXME: Write to BytesIO instead rather than hitting disk ?
>       with GitFile(filename, "wb") as f:
E       AttributeError: __enter__

tests/test_pack.py:751: AttributeError
</pre>
</details>
<h3 id="test_packpytestpackindexwritingv2test_empty">test_pack.py::TestPackIndexWritingv2::test_empty</h3>
<details><summary> <pre>test_pack.py::TestPackIndexWritingv2::test_empty</pre></summary><pre>
self = <tests.test_pack.TestPackIndexWritingv2 testMethod=test_empty>

    def test_empty(self):
>       idx = self.index("empty.idx", [], pack_checksum)

tests/test_pack.py:684: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:743: in index
    self.writeIndex(path, entries, pack_checksum)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pack.TestPackIndexWritingv2 testMethod=test_empty>
filename = '/tmp/tmpotdabuwy/empty.idx', entries = []
pack_checksum = b'r\x19\x80\xe8f\xaf\x9a_\x93\xadgAD\xe1E\x9b\x8b\xa3\xe7\xb7'

    def writeIndex(self, filename, entries, pack_checksum):
        # FIXME: Write to BytesIO instead rather than hitting disk ?
>       with GitFile(filename, "wb") as f:
E       AttributeError: __enter__

tests/test_pack.py:751: AttributeError
</pre>
</details>
<h3 id="test_packpytestpackindexwritingv2test_large">test_pack.py::TestPackIndexWritingv2::test_large</h3>
<details><summary> <pre>test_pack.py::TestPackIndexWritingv2::test_large</pre></summary><pre>
self = <tests.test_pack.TestPackIndexWritingv2 testMethod=test_large>

    def test_large(self):
        entry1_sha = hex_to_sha("4e6388232ec39792661e2e75db8fb117fc869ce6")
        entry2_sha = hex_to_sha("e98f071751bd77f59967bfa671cd2caebdccc9a2")
        entries = [
            (entry1_sha, 0xF2972D0830529B87, 24),
            (entry2_sha, (~0xF2972D0830529B87) & (2**64 - 1), 92),
        ]
        if not self._supports_large:
            self.assertRaises(
                TypeError, self.index, "single.idx", entries, pack_checksum
            )
            return
>       idx = self.index("single.idx", entries, pack_checksum)

tests/test_pack.py:700: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:743: in index
    self.writeIndex(path, entries, pack_checksum)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pack.TestPackIndexWritingv2 testMethod=test_large>
filename = '/tmp/tmpknxyyt3q/single.idx'
entries = [(b'Nc\x88#.\xc3\x97\x92f\x1e.u\xdb\x8f\xb1\x17\xfc\x86\x9c\xe6', 17480489991855577991, 24), (b'\xe9\x8f\x07\x17Q\xbdw\xf5\x99g\xbf\xa6q\xcd,\xae\xbd\xcc\xc9\xa2', 966254081853973624, 92)]
pack_checksum = b'r\x19\x80\xe8f\xaf\x9a_\x93\xadgAD\xe1E\x9b\x8b\xa3\xe7\xb7'

    def writeIndex(self, filename, entries, pack_checksum):
        # FIXME: Write to BytesIO instead rather than hitting disk ?
>       with GitFile(filename, "wb") as f:
E       AttributeError: __enter__

tests/test_pack.py:751: AttributeError
</pre>
</details>
<h3 id="test_packpytestpackindexwritingv2test_single">test_pack.py::TestPackIndexWritingv2::test_single</h3>
<details><summary> <pre>test_pack.py::TestPackIndexWritingv2::test_single</pre></summary><pre>
self = <tests.test_pack.TestPackIndexWritingv2 testMethod=test_single>

    def test_single(self):
        entry_sha = hex_to_sha("6f670c0fb53f9463760b7295fbb814e965fb20c8")
        my_entries = [(entry_sha, 178, 42)]
>       idx = self.index("single.idx", my_entries, pack_checksum)

tests/test_pack.py:718: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:743: in index
    self.writeIndex(path, entries, pack_checksum)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pack.TestPackIndexWritingv2 testMethod=test_single>
filename = '/tmp/tmps8952rdl/single.idx'
entries = [(b'og\x0c\x0f\xb5?\x94cv\x0br\x95\xfb\xb8\x14\xe9e\xfb \xc8', 178, 42)]
pack_checksum = b'r\x19\x80\xe8f\xaf\x9a_\x93\xadgAD\xe1E\x9b\x8b\xa3\xe7\xb7'

    def writeIndex(self, filename, entries, pack_checksum):
        # FIXME: Write to BytesIO instead rather than hitting disk ?
>       with GitFile(filename, "wb") as f:
E       AttributeError: __enter__

tests/test_pack.py:751: AttributeError
</pre>
</details>
<h3 id="test_packpyreadzlibteststest_decompress_buffer_size_1">test_pack.py::ReadZlibTests::test_decompress_buffer_size_1</h3>
<details><summary> <pre>test_pack.py::ReadZlibTests::test_decompress_buffer_size_1</pre></summary><pre>
self = <tests.test_pack.ReadZlibTests testMethod=test_decompress_buffer_size_1>

    def test_decompress_buffer_size_1(self):
>       self._do_decompress_test(1)

tests/test_pack.py:861: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:850: in _do_decompress_test
    self.assertEqual(zlib.crc32(self.comp), self.unpacked.crc32)
E   AssertionError: 583396265 != 3609230709
</pre>
</details>
<h3 id="test_packpyreadzlibteststest_decompress_buffer_size_2">test_pack.py::ReadZlibTests::test_decompress_buffer_size_2</h3>
<details><summary> <pre>test_pack.py::ReadZlibTests::test_decompress_buffer_size_2</pre></summary><pre>
self = <tests.test_pack.ReadZlibTests testMethod=test_decompress_buffer_size_2>

    def test_decompress_buffer_size_2(self):
>       self._do_decompress_test(2)

tests/test_pack.py:864: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:850: in _do_decompress_test
    self.assertEqual(zlib.crc32(self.comp), self.unpacked.crc32)
E   AssertionError: 583396265 != 3479363476
</pre>
</details>
<h3 id="test_packpyreadzlibteststest_decompress_buffer_size_3">test_pack.py::ReadZlibTests::test_decompress_buffer_size_3</h3>
<details><summary> <pre>test_pack.py::ReadZlibTests::test_decompress_buffer_size_3</pre></summary><pre>
self = <tests.test_pack.ReadZlibTests testMethod=test_decompress_buffer_size_3>

    def test_decompress_buffer_size_3(self):
>       self._do_decompress_test(3)

tests/test_pack.py:867: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:850: in _do_decompress_test
    self.assertEqual(zlib.crc32(self.comp), self.unpacked.crc32)
E   AssertionError: 583396265 != 3204038867
</pre>
</details>
<h3 id="test_packpyreadzlibteststest_decompress_buffer_size_4">test_pack.py::ReadZlibTests::test_decompress_buffer_size_4</h3>
<details><summary> <pre>test_pack.py::ReadZlibTests::test_decompress_buffer_size_4</pre></summary><pre>
self = <tests.test_pack.ReadZlibTests testMethod=test_decompress_buffer_size_4>

    def test_decompress_buffer_size_4(self):
>       self._do_decompress_test(4)

tests/test_pack.py:870: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:850: in _do_decompress_test
    self.assertEqual(zlib.crc32(self.comp), self.unpacked.crc32)
E   AssertionError: 583396265 != 3242514680
</pre>
</details>
<h3 id="test_packpyreadzlibteststest_decompress_include_comp">test_pack.py::ReadZlibTests::test_decompress_include_comp</h3>
<details><summary> <pre>test_pack.py::ReadZlibTests::test_decompress_include_comp</pre></summary><pre>
self = <tests.test_pack.ReadZlibTests testMethod=test_decompress_include_comp>

    def test_decompress_include_comp(self):
>       self._do_decompress_test(4096, include_comp=True)

tests/test_pack.py:873: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:850: in _do_decompress_test
    self.assertEqual(zlib.crc32(self.comp), self.unpacked.crc32)
E   AssertionError: 583396265 != 1633924910
</pre>
</details>
<h3 id="test_packpyreadzlibteststest_decompress_size">test_pack.py::ReadZlibTests::test_decompress_size</h3>
<details><summary> <pre>test_pack.py::ReadZlibTests::test_decompress_size</pre></summary><pre>
self = <tests.test_pack.ReadZlibTests testMethod=test_decompress_size>

    def test_decompress_size(self):
        good_decomp_len = len(self.decomp)
        self.unpacked.decomp_len = -1
>       self.assertRaises(ValueError, read_zlib_chunks, self.read, self.unpacked)
E       AssertionError: ValueError not raised by read_zlib_chunks

tests/test_pack.py:818: AssertionError
</pre>
</details>
<h3 id="test_packpyreadzlibteststest_decompress_truncated">test_pack.py::ReadZlibTests::test_decompress_truncated</h3>
<details><summary> <pre>test_pack.py::ReadZlibTests::test_decompress_truncated</pre></summary><pre>
self = <tests.test_pack.ReadZlibTests testMethod=test_decompress_truncated>

    def test_decompress_truncated(self):
        read = BytesIO(self.comp[:10]).read
>       self.assertRaises(zlib.error, read_zlib_chunks, read, self.unpacked)

tests/test_pack.py:826: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def read_zlib_chunks(read_some: Callable[[int], bytes], unpacked: UnpackedObject, include_comp: bool=False, buffer_size: int=_ZLIB_BUFSIZE) -> bytes:
        """Read zlib data from a buffer.

        This function requires that the buffer have additional data following the
        compressed data, which is guaranteed to be the case for git pack files.

        Args:
          read_some: Read function that returns at least one byte, but may
            return less than the requested size.
          unpacked: An UnpackedObject to write result data to. If its crc32
            attr is not None, the CRC32 of the compressed bytes will be computed
            using this starting CRC32.
            After this function, will have the following attrs set:
            * comp_chunks    (if include_comp is True)
            * decomp_chunks
            * decomp_len
            * crc32
          include_comp: If True, include compressed data in the result.
          buffer_size: Size of the read buffer.
        Returns: Leftover unused data from the decompression.

        Raises:
          zlib.error: if a decompression error occurred.
        """
        if include_comp:
            comp_chunks = []
            unpacked.comp_chunks = comp_chunks
        else:
            comp_chunks = None
        decomp_chunks = unpacked.decomp_chunks
        decomp_len = 0
        crc32 = unpacked.crc32

        # Start streaming the data to zlib
        d = zlib.decompressobj()
        while True:
            add_data = read_some(buffer_size)
            if not add_data:
                break
            if comp_chunks is not None:
                comp_chunks.append(add_data)
            if crc32 is not None:
                crc32 = zlib.crc32(add_data, crc32)
            decomp = d.decompress(add_data)
            decomp_len += len(decomp)
            decomp_chunks.append(decomp)
            if d.unused_data:
                leftover = d.unused_data
                if comp_chunks is not None:
                    comp_chunks[-1] = add_data[:-len(leftover)]
                if crc32 is not None:
                    crc32 = zlib.crc32(add_data[:-len(leftover)], crc32)
                break
        else:
            leftover = b''
        unpacked.decomp_len = decomp_len
        unpacked.crc32 = crc32
>       return leftover
E       UnboundLocalError: local variable 'leftover' referenced before assignment

dulwich/pack.py:281: UnboundLocalError
</pre>
</details>
<h3 id="test_packpyreadzlibteststest_simple_decompress">test_pack.py::ReadZlibTests::test_simple_decompress</h3>
<details><summary> <pre>test_pack.py::ReadZlibTests::test_simple_decompress</pre></summary><pre>
self = <tests.test_pack.ReadZlibTests testMethod=test_simple_decompress>

    def test_simple_decompress(self):
>       self._do_decompress_test(4096)

tests/test_pack.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:850: in _do_decompress_test
    self.assertEqual(zlib.crc32(self.comp), self.unpacked.crc32)
E   AssertionError: 583396265 != 1633924910
</pre>
</details>
<h3 id="test_packpydeltifyteststest_empty">test_pack.py::DeltifyTests::test_empty</h3>
<details><summary> <pre>test_pack.py::DeltifyTests::test_empty</pre></summary><pre>
self = <tests.test_pack.DeltifyTests testMethod=test_empty>

    def test_empty(self):
>       self.assertEqual([], list(deltify_pack_objects([])))
E       TypeError: 'NoneType' object is not iterable

tests/test_pack.py:879: TypeError
</pre>
</details>
<h3 id="test_packpydeltifyteststest_simple_delta">test_pack.py::DeltifyTests::test_simple_delta</h3>
<details><summary> <pre>test_pack.py::DeltifyTests::test_simple_delta</pre></summary><pre>
self = <tests.test_pack.DeltifyTests testMethod=test_simple_delta>

    def test_simple_delta(self):
        b1 = Blob.from_string(b"a" * 101)
        b2 = Blob.from_string(b"a" * 100)
>       delta = list(create_delta(b1.as_raw_chunks(), b2.as_raw_chunks()))
E       AttributeError: 'NoneType' object has no attribute 'as_raw_chunks'

tests/test_pack.py:898: AttributeError
</pre>
</details>
<h3 id="test_packpydeltifyteststest_single">test_pack.py::DeltifyTests::test_single</h3>
<details><summary> <pre>test_pack.py::DeltifyTests::test_single</pre></summary><pre>
self = <tests.test_pack.DeltifyTests testMethod=test_single>

    def test_single(self):
        b = Blob.from_string(b"foo")
        self.assertEqual(
            [
                UnpackedObject(
>                   b.type_num,
                    sha=b.sha().digest(),
                    delta_base=None,
                    decomp_chunks=b.as_raw_chunks(),
                )
            ],
            list(deltify_pack_objects([(b, b"")])),
        )
E       AttributeError: 'NoneType' object has no attribute 'type_num'

tests/test_pack.py:886: AttributeError
</pre>
</details>
<h3 id="test_packpytestpackstreamreadertest_read_objects">test_pack.py::TestPackStreamReader::test_read_objects</h3>
<details><summary> <pre>test_pack.py::TestPackStreamReader::test_read_objects</pre></summary><pre>
self = <tests.test_pack.TestPackStreamReader testMethod=test_read_objects>

    def test_read_objects(self):
        f = BytesIO()
        entries = build_pack(
            f,
            [
                (Blob.type_num, b"blob"),
                (OFS_DELTA, (0, b"blob1")),
            ],
        )
        reader = PackStreamReader(f.read)
>       objects = list(reader.read_objects(compute_crc32=True))
E       TypeError: 'NoneType' object is not iterable

tests/test_pack.py:935: TypeError
</pre>
</details>
<h3 id="test_packpytestpackstreamreadertest_read_objects_buffered">test_pack.py::TestPackStreamReader::test_read_objects_buffered</h3>
<details><summary> <pre>test_pack.py::TestPackStreamReader::test_read_objects_buffered</pre></summary><pre>
self = <tests.test_pack.TestPackStreamReader testMethod=test_read_objects_buffered>

    def test_read_objects_buffered(self):
        f = BytesIO()
        build_pack(
            f,
            [
                (Blob.type_num, b"blob"),
                (OFS_DELTA, (0, b"blob1")),
            ],
        )
        reader = PackStreamReader(f.read, zlib_bufsize=4)
>       self.assertEqual(2, len(list(reader.read_objects())))
E       TypeError: 'NoneType' object is not iterable

tests/test_pack.py:968: TypeError
</pre>
</details>
<h3 id="test_packpytestpackstreamreadertest_read_objects_empty">test_pack.py::TestPackStreamReader::test_read_objects_empty</h3>
<details><summary> <pre>test_pack.py::TestPackStreamReader::test_read_objects_empty</pre></summary><pre>
self = <tests.test_pack.TestPackStreamReader testMethod=test_read_objects_empty>

    def test_read_objects_empty(self):
        reader = PackStreamReader(BytesIO().read)
>       self.assertRaises(AssertionError, list, reader.read_objects())
E       TypeError: 'NoneType' object is not iterable

tests/test_pack.py:972: TypeError
</pre>
</details>
<h3 id="test_packpytestpackstreamreadertest_read_objects_emtpy">test_pack.py::TestPackStreamReader::test_read_objects_emtpy</h3>
<details><summary> <pre>test_pack.py::TestPackStreamReader::test_read_objects_emtpy</pre></summary><pre>
self = <tests.test_pack.TestPackStreamReader testMethod=test_read_objects_emtpy>

    def test_read_objects_emtpy(self):
        f = BytesIO()
        build_pack(f, [])
        reader = PackStreamReader(f.read)
>       self.assertEqual(0, len(list(reader.read_objects())))
E       TypeError: 'NoneType' object is not iterable

tests/test_pack.py:923: TypeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_bad_ext_ref_non_thin_pack">test_pack.py::DeltaChainIteratorTests::test_bad_ext_ref_non_thin_pack</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_bad_ext_ref_non_thin_pack</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_bad_ext_ref_non_thin_pack>

    def test_bad_ext_ref_non_thin_pack(self):
        (blob,) = self.store_blobs([b"blob"])
        f = BytesIO()
>       build_pack(f, [(REF_DELTA, (blob.id, b"blob1"))], store=self.store)
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_pack.py:1257: AttributeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_bad_ext_ref_thin_pack">test_pack.py::DeltaChainIteratorTests::test_bad_ext_ref_thin_pack</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_bad_ext_ref_thin_pack</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_bad_ext_ref_thin_pack>

    def test_bad_ext_ref_thin_pack(self):
        b1, b2, b3 = self.store_blobs([b"foo", b"bar", b"baz"])
        f = BytesIO()
        build_pack(
            f,
            [
                (REF_DELTA, (1, b"foo99")),
>               (REF_DELTA, (b1.id, b"foo1")),
                (REF_DELTA, (b2.id, b"bar2")),
                (REF_DELTA, (b3.id, b"baz3")),
            ],
            store=self.store,
        )
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_pack.py:1272: AttributeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_branchy_chain">test_pack.py::DeltaChainIteratorTests::test_branchy_chain</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_branchy_chain</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_branchy_chain>

    def test_branchy_chain(self):
        n = 100
        objects_spec = [(Blob.type_num, b"blob")]
        for i in range(n):
            objects_spec.append((OFS_DELTA, (0, b"blob" + str(i).encode("ascii"))))
        f = BytesIO()
        entries = build_pack(f, objects_spec)
        # Delta resolution changed to DFS
        indices = [0, *list(range(100, 0, -1))]
>       self.assertEntriesMatch(indices, entries, self.make_pack_iter(f))

tests/test_pack.py:1179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:1027: in make_pack_iter
    data = PackData("test.pack", file=f)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec207e1d50>, filename = 'test.pack'
file = <_io.BytesIO object at 0x7eec1eb877e0>, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       TypeError: cannot unpack non-iterable NoneType object

dulwich/pack.py:751: TypeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_ext_ref">test_pack.py::DeltaChainIteratorTests::test_ext_ref</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_ext_ref</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_ext_ref>

    def test_ext_ref(self):
        (blob,) = self.store_blobs([b"blob"])
        f = BytesIO()
>       entries = build_pack(f, [(REF_DELTA, (blob.id, b"blob1"))], store=self.store)
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_pack.py:1184: AttributeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_ext_ref_chain">test_pack.py::DeltaChainIteratorTests::test_ext_ref_chain</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_ext_ref_chain</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_ext_ref_chain>

    def test_ext_ref_chain(self):
        (blob,) = self.store_blobs([b"blob"])
        f = BytesIO()
        entries = build_pack(
            f,
            [
                (REF_DELTA, (1, b"blob2")),
>               (REF_DELTA, (blob.id, b"blob1")),
            ],
            store=self.store,
        )
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_pack.py:1196: AttributeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_ext_ref_chain_degenerate">test_pack.py::DeltaChainIteratorTests::test_ext_ref_chain_degenerate</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_ext_ref_chain_degenerate</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_ext_ref_chain_degenerate>

    def test_ext_ref_chain_degenerate(self):
        # Test a degenerate case where the sender is sending a REF_DELTA
        # object that expands to an object already in the repository.
        (blob,) = self.store_blobs([b"blob"])
        (blob2,) = self.store_blobs([b"blob2"])
>       assert blob.id < blob2.id
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_pack.py:1209: AttributeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_ext_ref_deltified_object_based_on_itself">test_pack.py::DeltaChainIteratorTests::test_ext_ref_deltified_object_based_on_itself</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_ext_ref_deltified_object_based_on_itself</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_ext_ref_deltified_object_based_on_itself>

    def test_ext_ref_deltified_object_based_on_itself(self):
        b1_content = b"foo"
        (b1,) = self.store_blobs([b1_content])
        f = BytesIO()
        build_pack(
            f,
            [
                # b1's content refers to bl1's object ID as delta base
>               (REF_DELTA, (b1.id, b1_content)),
            ],
            store=self.store,
        )
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_pack.py:1295: AttributeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_ext_ref_multiple_times">test_pack.py::DeltaChainIteratorTests::test_ext_ref_multiple_times</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_ext_ref_multiple_times</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_ext_ref_multiple_times>

    def test_ext_ref_multiple_times(self):
        (blob,) = self.store_blobs([b"blob"])
        f = BytesIO()
        entries = build_pack(
            f,
            [
>               (REF_DELTA, (blob.id, b"blob1")),
                (REF_DELTA, (blob.id, b"blob2")),
            ],
            store=self.store,
        )
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_pack.py:1230: AttributeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_long_chain">test_pack.py::DeltaChainIteratorTests::test_long_chain</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_long_chain</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_long_chain>

    def test_long_chain(self):
        n = 100
        objects_spec = [(Blob.type_num, b"blob")]
        for i in range(n):
            objects_spec.append((OFS_DELTA, (i, b"blob" + str(i).encode("ascii"))))
        f = BytesIO()
        entries = build_pack(f, objects_spec)
>       self.assertEntriesMatch(range(n + 1), entries, self.make_pack_iter(f))

tests/test_pack.py:1168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:1027: in make_pack_iter
    data = PackData("test.pack", file=f)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1ebbc5b0>, filename = 'test.pack'
file = <_io.BytesIO object at 0x7eec1ec27650>, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       TypeError: cannot unpack non-iterable NoneType object

dulwich/pack.py:751: TypeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_mixed_chain">test_pack.py::DeltaChainIteratorTests::test_mixed_chain</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_mixed_chain</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_mixed_chain>

    def test_mixed_chain(self):
        f = BytesIO()
        entries = build_pack(
            f,
            [
                (Blob.type_num, b"blob"),
                (REF_DELTA, (2, b"blob2")),
                (OFS_DELTA, (0, b"blob1")),
                (OFS_DELTA, (1, b"blob3")),
                (OFS_DELTA, (0, b"bob")),
            ],
        )
        # Delta resolution changed to DFS
>       self.assertEntriesMatch([0, 4, 2, 1, 3], entries, self.make_pack_iter(f))

tests/test_pack.py:1159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:1027: in make_pack_iter
    data = PackData("test.pack", file=f)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1eadb370>, filename = 'test.pack'
file = <_io.BytesIO object at 0x7eec20221cb0>, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       TypeError: cannot unpack non-iterable NoneType object

dulwich/pack.py:751: TypeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_multiple_ext_refs">test_pack.py::DeltaChainIteratorTests::test_multiple_ext_refs</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_multiple_ext_refs</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_multiple_ext_refs>

    def test_multiple_ext_refs(self):
        b1, b2 = self.store_blobs([b"foo", b"bar"])
        f = BytesIO()
        entries = build_pack(
            f,
            [
>               (REF_DELTA, (b1.id, b"foo1")),
                (REF_DELTA, (b2.id, b"bar2")),
            ],
            store=self.store,
        )
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_pack.py:1245: AttributeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_no_deltas">test_pack.py::DeltaChainIteratorTests::test_no_deltas</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_no_deltas</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_no_deltas>

    def test_no_deltas(self):
        f = BytesIO()
        entries = build_pack(
            f,
            [
                (Commit.type_num, b"commit"),
                (Blob.type_num, b"blob"),
                (Tree.type_num, b"tree"),
            ],
        )
>       self.assertEntriesMatch([0, 1, 2], entries, self.make_pack_iter(f))

tests/test_pack.py:1056: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:1027: in make_pack_iter
    data = PackData("test.pack", file=f)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1fdae770>, filename = 'test.pack'
file = <_io.BytesIO object at 0x7eec1fdcbd80>, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       TypeError: cannot unpack non-iterable NoneType object

dulwich/pack.py:751: TypeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_ofs_and_ref_deltas">test_pack.py::DeltaChainIteratorTests::test_ofs_and_ref_deltas</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_ofs_and_ref_deltas</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_ofs_and_ref_deltas>

    def test_ofs_and_ref_deltas(self):
        # Deltas pending on this offset are popped before deltas depending on
        # this ref.
        f = BytesIO()
        entries = build_pack(
            f,
            [
                (REF_DELTA, (1, b"blob1")),
                (Blob.type_num, (b"blob")),
                (OFS_DELTA, (1, b"blob2")),
            ],
        )

        # Delta resolution changed to DFS
>       self.assertEntriesMatch([1, 0, 2], entries, self.make_pack_iter(f))

tests/test_pack.py:1144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:1027: in make_pack_iter
    data = PackData("test.pack", file=f)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1fca47c0>, filename = 'test.pack'
file = <_io.BytesIO object at 0x7eec1ec24d60>, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       TypeError: cannot unpack non-iterable NoneType object

dulwich/pack.py:751: TypeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_ofs_deltas">test_pack.py::DeltaChainIteratorTests::test_ofs_deltas</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_ofs_deltas</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_ofs_deltas>

    def test_ofs_deltas(self):
        f = BytesIO()
        entries = build_pack(
            f,
            [
                (Blob.type_num, b"blob"),
                (OFS_DELTA, (0, b"blob1")),
                (OFS_DELTA, (0, b"blob2")),
            ],
        )
        # Delta resolution changed to DFS
>       self.assertEntriesMatch([0, 2, 1], entries, self.make_pack_iter(f))

tests/test_pack.py:1085: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:1027: in make_pack_iter
    data = PackData("test.pack", file=f)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1eb441f0>, filename = 'test.pack'
file = <_io.BytesIO object at 0x7eec1fb28810>, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       TypeError: cannot unpack non-iterable NoneType object

dulwich/pack.py:751: TypeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_ofs_deltas_chain">test_pack.py::DeltaChainIteratorTests::test_ofs_deltas_chain</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_ofs_deltas_chain</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_ofs_deltas_chain>

    def test_ofs_deltas_chain(self):
        f = BytesIO()
        entries = build_pack(
            f,
            [
                (Blob.type_num, b"blob"),
                (OFS_DELTA, (0, b"blob1")),
                (OFS_DELTA, (1, b"blob2")),
            ],
        )
>       self.assertEntriesMatch([0, 1, 2], entries, self.make_pack_iter(f))

tests/test_pack.py:1103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:1027: in make_pack_iter
    data = PackData("test.pack", file=f)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1ed75c60>, filename = 'test.pack'
file = <_io.BytesIO object at 0x7eec1ec80f40>, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       TypeError: cannot unpack non-iterable NoneType object

dulwich/pack.py:751: TypeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_ref_deltas">test_pack.py::DeltaChainIteratorTests::test_ref_deltas</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_ref_deltas</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_ref_deltas>

    def test_ref_deltas(self):
        f = BytesIO()
        entries = build_pack(
            f,
            [
                (REF_DELTA, (1, b"blob1")),
                (Blob.type_num, (b"blob")),
                (REF_DELTA, (1, b"blob2")),
            ],
        )
        # Delta resolution changed to DFS
>       self.assertEntriesMatch([1, 2, 0], entries, self.make_pack_iter(f))

tests/test_pack.py:1116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:1027: in make_pack_iter
    data = PackData("test.pack", file=f)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1ebcbdc0>, filename = 'test.pack'
file = <_io.BytesIO object at 0x7eec20915710>, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       TypeError: cannot unpack non-iterable NoneType object

dulwich/pack.py:751: TypeError
</pre>
</details>
<h3 id="test_packpydeltachainiteratorteststest_ref_deltas_chain">test_pack.py::DeltaChainIteratorTests::test_ref_deltas_chain</h3>
<details><summary> <pre>test_pack.py::DeltaChainIteratorTests::test_ref_deltas_chain</pre></summary><pre>
self = <tests.test_pack.DeltaChainIteratorTests testMethod=test_ref_deltas_chain>

    def test_ref_deltas_chain(self):
        f = BytesIO()
        entries = build_pack(
            f,
            [
                (REF_DELTA, (2, b"blob1")),
                (Blob.type_num, (b"blob")),
                (REF_DELTA, (1, b"blob2")),
            ],
        )
>       self.assertEntriesMatch([1, 2, 0], entries, self.make_pack_iter(f))

tests/test_pack.py:1128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_pack.py:1027: in make_pack_iter
    data = PackData("test.pack", file=f)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.pack.PackData object at 0x7eec1ef20070>, filename = 'test.pack'
file = <_io.BytesIO object at 0x7eec1fb280e0>, size = None

    def __init__(self, filename, file=None, size=None) -> None:
        """Create a PackData object representing the pack in the given filename.

        The file must exist and stay readable until the object is disposed of.
        It must also stay the same size. It will be mapped whenever needed.

        Currently there is a restriction on the size of the pack as the python
        mmap implementation is flawed.
        """
        self._filename = filename
        self._size = size
        self._header_size = 12
        if file is None:
            self._file = GitFile(self._filename, 'rb')
        else:
            self._file = file
>       version, self._num_objects = read_pack_header(self._file.read)
E       TypeError: cannot unpack non-iterable NoneType object

dulwich/pack.py:751: TypeError
</pre>
</details>
<h3 id="test_packpyencodecopyoperationteststest_basic">test_pack.py::EncodeCopyOperationTests::test_basic</h3>
<details><summary> <pre>test_pack.py::EncodeCopyOperationTests::test_basic</pre></summary><pre>
self = <tests.test_pack.EncodeCopyOperationTests testMethod=test_basic>

    def test_basic(self):
        self.assertEqual(b"\x80", _encode_copy_operation(0, 0))
>       self.assertEqual(b"\x91\x01\x0a", _encode_copy_operation(1, 10))
E       AssertionError: b'\x91\x01\n' != b'\xa1'

tests/test_pack.py:1328: AssertionError
</pre>
</details>
<h3 id="test_patchpywritecommitpatchteststest_simple_bytesio">test_patch.py::WriteCommitPatchTests::test_simple_bytesio</h3>
<details><summary> <pre>test_patch.py::WriteCommitPatchTests::test_simple_bytesio</pre></summary><pre>
self = <tests.test_patch.WriteCommitPatchTests testMethod=test_simple_bytesio>

    def test_simple_bytesio(self):
        f = BytesIO()
        c = Commit()
        c.committer = c.author = b"Jelmer <jelmer@samba.org>"
        c.commit_time = c.author_time = 1271350201
        c.commit_timezone = c.author_timezone = 0
        c.message = b"This is the first line\nAnd this is the second line.\n"
        c.tree = Tree().id
        write_commit_patch(f, c, b"CONTENTS", (1, 1), version="custom")
        f.seek(0)
        lines = f.readlines()
        self.assertTrue(
>           lines[0].startswith(b"From 0b0d34d1b5b596c928adc9a727a4b9e03d025298")
        )
E       IndexError: list index out of range

tests/test_patch.py:52: IndexError
</pre>
</details>
<h3 id="test_patchpyreadgitampatchtest_extract_bytes">test_patch.py::ReadGitAmPatch::test_extract_bytes</h3>
<details><summary> <pre>test_patch.py::ReadGitAmPatch::test_extract_bytes</pre></summary><pre>
self = <tests.test_patch.ReadGitAmPatch testMethod=test_extract_bytes>

        def test_extract_bytes(self):
            text = b"""\
    From ff643aae102d8870cac88e8f007e70f58f3a7363 Mon Sep 17 00:00:00 2001
    From: Jelmer Vernooij <jelmer@samba.org>
    Date: Thu, 15 Apr 2010 15:40:28 +0200
    Subject: [PATCH 1/2] Remove executable bit from prey.ico (triggers a warning).

    ---
     pixmaps/prey.ico |  Bin 9662 -> 9662 bytes
     1 files changed, 0 insertions(+), 0 deletions(-)
     mode change 100755 => 100644 pixmaps/prey.ico

    --
    1.7.0.4
    """
>           c, diff, version = git_am_patch_split(BytesIO(text))
E           TypeError: cannot unpack non-iterable NoneType object

tests/test_patch.py:120: TypeError
</pre>
</details>
<h3 id="test_patchpyreadgitampatchtest_extract_no_version_tail">test_patch.py::ReadGitAmPatch::test_extract_no_version_tail</h3>
<details><summary> <pre>test_patch.py::ReadGitAmPatch::test_extract_no_version_tail</pre></summary><pre>
self = <tests.test_patch.ReadGitAmPatch testMethod=test_extract_no_version_tail>

        def test_extract_no_version_tail(self):
            text = b"""\
    From ff643aae102d8870cac88e8f007e70f58f3a7363 Mon Sep 17 00:00:00 2001
    From: Jelmer Vernooij <jelmer@samba.org>
    Date: Thu, 15 Apr 2010 15:40:28 +0200
    Subject:  [Dulwich-users] [PATCH] Added unit tests for
     dulwich.object_store.tree_lookup_path.

    From: Jelmer Vernooij <jelmer@debian.org>

    ---
     pixmaps/prey.ico |  Bin 9662 -> 9662 bytes
     1 files changed, 0 insertions(+), 0 deletions(-)
     mode change 100755 => 100644 pixmaps/prey.ico

    """
>           c, diff, version = git_am_patch_split(BytesIO(text), "utf-8")
E           TypeError: cannot unpack non-iterable NoneType object

tests/test_patch.py:216: TypeError
</pre>
</details>
<h3 id="test_patchpyreadgitampatchtest_extract_pseudo_from_header">test_patch.py::ReadGitAmPatch::test_extract_pseudo_from_header</h3>
<details><summary> <pre>test_patch.py::ReadGitAmPatch::test_extract_pseudo_from_header</pre></summary><pre>
self = <tests.test_patch.ReadGitAmPatch testMethod=test_extract_pseudo_from_header>

        def test_extract_pseudo_from_header(self):
            text = b"""From ff643aae102d8870cac88e8f007e70f58f3a7363 Mon Sep 17 00:00:00 2001
    From: Jelmer Vernooij <jelmer@samba.org>
    Date: Thu, 15 Apr 2010 15:40:28 +0200
    Subject:  [Dulwich-users] [PATCH] Added unit tests for
     dulwich.object_store.tree_lookup_path.

    From: Jelmer Vernooij <jelmer@debian.org>

    * dulwich/tests/test_object_store.py
      (TreeLookupPathTests): This test case contains a few tests that ensure the
       tree_lookup_path function works as expected.
    ---
     pixmaps/prey.ico |  Bin 9662 -> 9662 bytes
     1 files changed, 0 insertions(+), 0 deletions(-)
     mode change 100755 => 100644 pixmaps/prey.ico

    --
    1.7.0.4
    """
>           c, diff, version = git_am_patch_split(BytesIO(text), "utf-8")
E           TypeError: cannot unpack non-iterable NoneType object

tests/test_patch.py:187: TypeError
</pre>
</details>
<h3 id="test_patchpyreadgitampatchtest_extract_spaces">test_patch.py::ReadGitAmPatch::test_extract_spaces</h3>
<details><summary> <pre>test_patch.py::ReadGitAmPatch::test_extract_spaces</pre></summary><pre>
self = <tests.test_patch.ReadGitAmPatch testMethod=test_extract_spaces>

        def test_extract_spaces(self):
            text = b"""From ff643aae102d8870cac88e8f007e70f58f3a7363 Mon Sep 17 00:00:00 2001
    From: Jelmer Vernooij <jelmer@samba.org>
    Date: Thu, 15 Apr 2010 15:40:28 +0200
    Subject:  [Dulwich-users] [PATCH] Added unit tests for
     dulwich.object_store.tree_lookup_path.

    * dulwich/tests/test_object_store.py
      (TreeLookupPathTests): This test case contains a few tests that ensure the
       tree_lookup_path function works as expected.
    ---
     pixmaps/prey.ico |  Bin 9662 -> 9662 bytes
     1 files changed, 0 insertions(+), 0 deletions(-)
     mode change 100755 => 100644 pixmaps/prey.ico

    --
    1.7.0.4
    """
>           c, diff, version = git_am_patch_split(BytesIO(text), "utf-8")
E           TypeError: cannot unpack non-iterable NoneType object

tests/test_patch.py:155: TypeError
</pre>
</details>
<h3 id="test_patchpyreadgitampatchtest_extract_string">test_patch.py::ReadGitAmPatch::test_extract_string</h3>
<details><summary> <pre>test_patch.py::ReadGitAmPatch::test_extract_string</pre></summary><pre>
self = <tests.test_patch.ReadGitAmPatch testMethod=test_extract_string>

        def test_extract_string(self):
            text = b"""\
    From ff643aae102d8870cac88e8f007e70f58f3a7363 Mon Sep 17 00:00:00 2001
    From: Jelmer Vernooij <jelmer@samba.org>
    Date: Thu, 15 Apr 2010 15:40:28 +0200
    Subject: [PATCH 1/2] Remove executable bit from prey.ico (triggers a warning).

    ---
     pixmaps/prey.ico |  Bin 9662 -> 9662 bytes
     1 files changed, 0 insertions(+), 0 deletions(-)
     mode change 100755 => 100644 pixmaps/prey.ico

    --
    1.7.0.4
    """
>           c, diff, version = git_am_patch_split(StringIO(text.decode("utf-8")), "utf-8")
E           TypeError: cannot unpack non-iterable NoneType object

tests/test_patch.py:88: TypeError
</pre>
</details>
<h3 id="test_patchpydiffteststest_blob_add">test_patch.py::DiffTests::test_blob_add</h3>
<details><summary> <pre>test_patch.py::DiffTests::test_blob_add</pre></summary><pre>
self = <tests.test_patch.DiffTests testMethod=test_blob_add>

    def test_blob_add(self):
        f = BytesIO()
        write_blob_diff(
            f,
            (None, None, None),
            (b"bar.txt", 0o644, Blob.from_string(b"new\nsame\n")),
        )
>       self.assertEqual(
            [
                b"diff --git a/bar.txt b/bar.txt",
                b"new file mode 644",
                b"index 0000000..a116b51",
                b"--- /dev/null",
                b"+++ b/bar.txt",
                b"@@ -0,0 +1,2 @@",
                b"+new",
                b"+same",
            ],
            f.getvalue().splitlines(),
        )
E       AssertionError: Lists differ: [b'diff --git a/bar.txt b/bar.txt', b'new [112 chars]ame'] != []
E       
E       First list contains 8 additional elements.
E       First extra element 0:
E       b'diff --git a/bar.txt b/bar.txt'
E       
E       + []
E       - [b'diff --git a/bar.txt b/bar.txt',
E       -  b'new file mode 644',
E       -  b'index 0000000..a116b51',
E       -  b'--- /dev/null',
E       -  b'+++ b/bar.txt',
E       -  b'@@ -0,0 +1,2 @@',
E       -  b'+new',
E       -  b'+same']

tests/test_patch.py:293: AssertionError
</pre>
</details>
<h3 id="test_patchpydiffteststest_blob_diff">test_patch.py::DiffTests::test_blob_diff</h3>
<details><summary> <pre>test_patch.py::DiffTests::test_blob_diff</pre></summary><pre>
self = <tests.test_patch.DiffTests testMethod=test_blob_diff>

    def test_blob_diff(self):
        f = BytesIO()
        write_blob_diff(
            f,
            (b"foo.txt", 0o644, Blob.from_string(b"old\nsame\n")),
            (b"bar.txt", 0o644, Blob.from_string(b"new\nsame\n")),
        )
>       self.assertEqual(
            [
                b"diff --git a/foo.txt b/bar.txt",
                b"index 3b0f961..a116b51 644",
                b"--- a/foo.txt",
                b"+++ b/bar.txt",
                b"@@ -1,2 +1,2 @@",
                b"-old",
                b"+new",
                b" same",
            ],
            f.getvalue().splitlines(),
        )
E       AssertionError: Lists differ: [b'diff --git a/foo.txt b/bar.txt', b'inde[103 chars]ame'] != []
E       
E       First list contains 8 additional elements.
E       First extra element 0:
E       b'diff --git a/foo.txt b/bar.txt'
E       
E       + []
E       - [b'diff --git a/foo.txt b/bar.txt',
E       -  b'index 3b0f961..a116b51 644',
E       -  b'--- a/foo.txt',
E       -  b'+++ b/bar.txt',
E       -  b'@@ -1,2 +1,2 @@',
E       -  b'-old',
E       -  b'+new',
E       -  b' same']

tests/test_patch.py:272: AssertionError
</pre>
</details>
<h3 id="test_patchpydiffteststest_blob_remove">test_patch.py::DiffTests::test_blob_remove</h3>
<details><summary> <pre>test_patch.py::DiffTests::test_blob_remove</pre></summary><pre>
self = <tests.test_patch.DiffTests testMethod=test_blob_remove>

    def test_blob_remove(self):
        f = BytesIO()
        write_blob_diff(
            f,
            (b"bar.txt", 0o644, Blob.from_string(b"new\nsame\n")),
            (None, None, None),
        )
>       self.assertEqual(
            [
                b"diff --git a/bar.txt b/bar.txt",
                b"deleted file mode 644",
                b"index a116b51..0000000",
                b"--- a/bar.txt",
                b"+++ /dev/null",
                b"@@ -1,2 +0,0 @@",
                b"-new",
                b"-same",
            ],
            f.getvalue().splitlines(),
        )
E       AssertionError: Lists differ: [b'diff --git a/bar.txt b/bar.txt', b'dele[116 chars]ame'] != []
E       
E       First list contains 8 additional elements.
E       First extra element 0:
E       b'diff --git a/bar.txt b/bar.txt'
E       
E       + []
E       - [b'diff --git a/bar.txt b/bar.txt',
E       -  b'deleted file mode 644',
E       -  b'index a116b51..0000000',
E       -  b'--- a/bar.txt',
E       -  b'+++ /dev/null',
E       -  b'@@ -1,2 +0,0 @@',
E       -  b'-new',
E       -  b'-same']

tests/test_patch.py:314: AssertionError
</pre>
</details>
<h3 id="test_patchpydiffteststest_object_diff_add_bin_blob">test_patch.py::DiffTests::test_object_diff_add_bin_blob</h3>
<details><summary> <pre>test_patch.py::DiffTests::test_object_diff_add_bin_blob</pre></summary><pre>
self = <tests.test_patch.DiffTests testMethod=test_object_diff_add_bin_blob>

    def test_object_diff_add_bin_blob(self):
        f = BytesIO()
        b2 = Blob.from_string(
            b"\x89\x50\x4e\x47\x0d\x0a\x1a\x0a"
            b"\x00\x00\x00\x0d\x49\x48\x44\x52"
            b"\x00\x00\x01\xd5\x00\x00\x00\x9f"
            b"\x08\x03\x00\x00\x00\x98\xd3\xb3"
        )
        store = MemoryObjectStore()
        store.add_object(b2)
>       write_object_diff(f, store, (None, None, None), (b"bar.png", 0o644, b2.id))
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_patch.py:563: AttributeError
</pre>
</details>
<h3 id="test_patchpydiffteststest_object_diff_add_blob">test_patch.py::DiffTests::test_object_diff_add_blob</h3>
<details><summary> <pre>test_patch.py::DiffTests::test_object_diff_add_blob</pre></summary><pre>
self = <tests.test_patch.DiffTests testMethod=test_object_diff_add_blob>

    def test_object_diff_add_blob(self):
        f = BytesIO()
        store = MemoryObjectStore()
        b2 = Blob.from_string(b"new\nsame\n")
        store.add_object(b2)
>       write_object_diff(f, store, (None, None, None), (b"bar.txt", 0o644, b2.id))
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_patch.py:445: AttributeError
</pre>
</details>
<h3 id="test_patchpydiffteststest_object_diff_bin_blob">test_patch.py::DiffTests::test_object_diff_bin_blob</h3>
<details><summary> <pre>test_patch.py::DiffTests::test_object_diff_bin_blob</pre></summary><pre>
self = <tests.test_patch.DiffTests testMethod=test_object_diff_bin_blob>

    def test_object_diff_bin_blob(self):
        f = BytesIO()
        # Prepare two slightly different PNG headers
        b1 = Blob.from_string(
            b"\x89\x50\x4e\x47\x0d\x0a\x1a\x0a"
            b"\x00\x00\x00\x0d\x49\x48\x44\x52"
            b"\x00\x00\x01\xd5\x00\x00\x00\x9f"
            b"\x08\x04\x00\x00\x00\x05\x04\x8b"
        )
        b2 = Blob.from_string(
            b"\x89\x50\x4e\x47\x0d\x0a\x1a\x0a"
            b"\x00\x00\x00\x0d\x49\x48\x44\x52"
            b"\x00\x00\x01\xd5\x00\x00\x00\x9f"
            b"\x08\x03\x00\x00\x00\x98\xd3\xb3"
        )
        store = MemoryObjectStore()
        store.add_objects([(b1, None), (b2, None)])
        write_object_diff(
>           f, store, (b"foo.png", 0o644, b1.id), (b"bar.png", 0o644, b2.id)
        )
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_patch.py:542: AttributeError
</pre>
</details>
<h3 id="test_patchpydiffteststest_object_diff_bin_blob_force">test_patch.py::DiffTests::test_object_diff_bin_blob_force</h3>
<details><summary> <pre>test_patch.py::DiffTests::test_object_diff_bin_blob_force</pre></summary><pre>
self = <tests.test_patch.DiffTests testMethod=test_object_diff_bin_blob_force>

    def test_object_diff_bin_blob_force(self):
        f = BytesIO()
        # Prepare two slightly different PNG headers
        b1 = Blob.from_string(
            b"\x89\x50\x4e\x47\x0d\x0a\x1a\x0a"
            b"\x00\x00\x00\x0d\x49\x48\x44\x52"
            b"\x00\x00\x01\xd5\x00\x00\x00\x9f"
            b"\x08\x04\x00\x00\x00\x05\x04\x8b"
        )
        b2 = Blob.from_string(
            b"\x89\x50\x4e\x47\x0d\x0a\x1a\x0a"
            b"\x00\x00\x00\x0d\x49\x48\x44\x52"
            b"\x00\x00\x01\xd5\x00\x00\x00\x9f"
            b"\x08\x03\x00\x00\x00\x98\xd3\xb3"
        )
        store = MemoryObjectStore()
        store.add_objects([(b1, None), (b2, None)])
        write_object_diff(
            f,
            store,
>           (b"foo.png", 0o644, b1.id),
            (b"bar.png", 0o644, b2.id),
            diff_binary=True,
        )
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_patch.py:500: AttributeError
</pre>
</details>
<h3 id="test_patchpydiffteststest_object_diff_blob">test_patch.py::DiffTests::test_object_diff_blob</h3>
<details><summary> <pre>test_patch.py::DiffTests::test_object_diff_blob</pre></summary><pre>
self = <tests.test_patch.DiffTests testMethod=test_object_diff_blob>

    def test_object_diff_blob(self):
        f = BytesIO()
        b1 = Blob.from_string(b"old\nsame\n")
        b2 = Blob.from_string(b"new\nsame\n")
        store = MemoryObjectStore()
        store.add_objects([(b1, None), (b2, None)])
        write_object_diff(
>           f, store, (b"foo.txt", 0o644, b1.id), (b"bar.txt", 0o644, b2.id)
        )
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_patch.py:424: AttributeError
</pre>
</details>
<h3 id="test_patchpydiffteststest_object_diff_kind_change">test_patch.py::DiffTests::test_object_diff_kind_change</h3>
<details><summary> <pre>test_patch.py::DiffTests::test_object_diff_kind_change</pre></summary><pre>
self = <tests.test_patch.DiffTests testMethod=test_object_diff_kind_change>

    def test_object_diff_kind_change(self):
        f = BytesIO()
        b1 = Blob.from_string(b"new\nsame\n")
        store = MemoryObjectStore()
        store.add_object(b1)
        write_object_diff(
            f,
            store,
>           (b"bar.txt", 0o644, b1.id),
            (
                b"bar.txt",
                0o160000,
                b"06d0bdd9e2e20377b3180e4986b14c8549b393e4",
            ),
        )
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_patch.py:603: AttributeError
</pre>
</details>
<h3 id="test_patchpydiffteststest_object_diff_remove_bin_blob">test_patch.py::DiffTests::test_object_diff_remove_bin_blob</h3>
<details><summary> <pre>test_patch.py::DiffTests::test_object_diff_remove_bin_blob</pre></summary><pre>
self = <tests.test_patch.DiffTests testMethod=test_object_diff_remove_bin_blob>

    def test_object_diff_remove_bin_blob(self):
        f = BytesIO()
        b1 = Blob.from_string(
            b"\x89\x50\x4e\x47\x0d\x0a\x1a\x0a"
            b"\x00\x00\x00\x0d\x49\x48\x44\x52"
            b"\x00\x00\x01\xd5\x00\x00\x00\x9f"
            b"\x08\x04\x00\x00\x00\x05\x04\x8b"
        )
        store = MemoryObjectStore()
        store.add_object(b1)
>       write_object_diff(f, store, (b"foo.png", 0o644, b1.id), (None, None, None))
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_patch.py:584: AttributeError
</pre>
</details>
<h3 id="test_patchpydiffteststest_object_diff_remove_blob">test_patch.py::DiffTests::test_object_diff_remove_blob</h3>
<details><summary> <pre>test_patch.py::DiffTests::test_object_diff_remove_blob</pre></summary><pre>
self = <tests.test_patch.DiffTests testMethod=test_object_diff_remove_blob>

    def test_object_diff_remove_blob(self):
        f = BytesIO()
        b1 = Blob.from_string(b"new\nsame\n")
        store = MemoryObjectStore()
        store.add_object(b1)
>       write_object_diff(f, store, (b"bar.txt", 0o644, b1.id), (None, None, None))
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_patch.py:465: AttributeError
</pre>
</details>
<h3 id="test_patchpydiffteststest_tree_diff">test_patch.py::DiffTests::test_tree_diff</h3>
<details><summary> <pre>test_patch.py::DiffTests::test_tree_diff</pre></summary><pre>
self = <tests.test_patch.DiffTests testMethod=test_tree_diff>

    def test_tree_diff(self):
        f = BytesIO()
        store = MemoryObjectStore()
        added = Blob.from_string(b"add\n")
        removed = Blob.from_string(b"removed\n")
        changed1 = Blob.from_string(b"unchanged\nremoved\n")
        changed2 = Blob.from_string(b"unchanged\nadded\n")
        unchanged = Blob.from_string(b"unchanged\n")
        tree1 = Tree()
>       tree1.add(b"removed.txt", 0o644, removed.id)
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_patch.py:337: AttributeError
</pre>
</details>
<h3 id="test_patchpydiffteststest_tree_diff_submodule">test_patch.py::DiffTests::test_tree_diff_submodule</h3>
<details><summary> <pre>test_patch.py::DiffTests::test_tree_diff_submodule</pre></summary><pre>
self = <tests.test_patch.DiffTests testMethod=test_tree_diff_submodule>

    def test_tree_diff_submodule(self):
        f = BytesIO()
        store = MemoryObjectStore()
        tree1 = Tree()
        tree1.add(
            b"asubmodule",
            S_IFGITLINK,
            b"06d0bdd9e2e20377b3180e4986b14c8549b393e4",
        )
        tree2 = Tree()
        tree2.add(
            b"asubmodule",
            S_IFGITLINK,
            b"cc975646af69f279396d4d5e1379ac6af80ee637",
        )
        store.add_objects([(o, None) for o in [tree1, tree2]])
        write_tree_diff(f, store, tree1.id, tree2.id)
>       self.assertEqual(
            [
                b"diff --git a/asubmodule b/asubmodule",
                b"index 06d0bdd..cc97564 160000",
                b"--- a/asubmodule",
                b"+++ b/asubmodule",
                b"@@ -1 +1 @@",
                b"-Subproject commit 06d0bdd9e2e20377b3180e4986b14c8549b393e4",
                b"+Subproject commit cc975646af69f279396d4d5e1379ac6af80ee637",
            ],
            f.getvalue().splitlines(),
        )
E       AssertionError: Lists differ: [b'diff --git a/asubmodule b/asubmodule', [214 chars]637'] != []
E       
E       First list contains 7 additional elements.
E       First extra element 0:
E       b'diff --git a/asubmodule b/asubmodule'
E       
E       + []
E       - [b'diff --git a/asubmodule b/asubmodule',
E       -  b'index 06d0bdd..cc97564 160000',
E       -  b'--- a/asubmodule',
E       -  b'+++ b/asubmodule',
E       -  b'@@ -1 +1 @@',
E       -  b'-Subproject commit 06d0bdd9e2e20377b3180e4986b14c8549b393e4',
E       -  b'+Subproject commit cc975646af69f279396d4d5e1379ac6af80ee637']

tests/test_patch.py:404: AssertionError
</pre>
</details>
<h3 id="test_patchpygetsummaryteststest_simple">test_patch.py::GetSummaryTests::test_simple</h3>
<details><summary> <pre>test_patch.py::GetSummaryTests::test_simple</pre></summary><pre>
self = <tests.test_patch.GetSummaryTests testMethod=test_simple>

    def test_simple(self):
        c = Commit()
        c.committer = c.author = b"Jelmer <jelmer@samba.org>"
        c.commit_time = c.author_time = 1271350201
        c.commit_timezone = c.author_timezone = 0
        c.message = b"This is the first line\nAnd this is the second line.\n"
        c.tree = Tree().id
>       self.assertEqual("This-is-the-first-line", get_summary(c))
E       AssertionError: 'This-is-the-first-line' != None

tests/test_patch.py:635: AssertionError
</pre>
</details>
<h3 id="test_protocolpyprotocolteststest_eof">test_protocol.py::ProtocolTests::test_eof</h3>
<details><summary> <pre>test_protocol.py::ProtocolTests::test_eof</pre></summary><pre>
self = <tests.test_protocol.ProtocolTests testMethod=test_eof>

    def test_eof(self):
        self.rin.write(b"0000")
        self.rin.seek(0)
        self.assertFalse(self.proto.eof())
        self.assertEqual(None, self.proto.read_pkt_line())
>       self.assertTrue(self.proto.eof())
E       AssertionError: None is not true

tests/test_protocol.py:62: AssertionError
</pre>
</details>
<h3 id="test_protocolpyprotocolteststest_read_cmd">test_protocol.py::ProtocolTests::test_read_cmd</h3>
<details><summary> <pre>test_protocol.py::ProtocolTests::test_read_cmd</pre></summary><pre>
self = <tests.test_protocol.ProtocolTests testMethod=test_read_cmd>

    def test_read_cmd(self):
        self.rin.write(b"0012cmd arg1\x00arg2\x00")
        self.rin.seek(0)
>       self.assertEqual((b"cmd", [b"arg1", b"arg2"]), self.proto.read_cmd())
E       AssertionError: (b'cmd', [b'arg1', b'arg2']) != None

tests/test_protocol.py:101: AssertionError
</pre>
</details>
<h3 id="test_protocolpyprotocolteststest_read_cmd_noend0">test_protocol.py::ProtocolTests::test_read_cmd_noend0</h3>
<details><summary> <pre>test_protocol.py::ProtocolTests::test_read_cmd_noend0</pre></summary><pre>
self = <tests.test_protocol.ProtocolTests testMethod=test_read_cmd_noend0>

    def test_read_cmd_noend0(self):
        self.rin.write(b"0011cmd arg1\x00arg2")
        self.rin.seek(0)
>       self.assertRaises(AssertionError, self.proto.read_cmd)
E       AssertionError: AssertionError not raised by read_cmd

tests/test_protocol.py:106: AssertionError
</pre>
</details>
<h3 id="test_protocolpyprotocolteststest_read_pkt_line">test_protocol.py::ProtocolTests::test_read_pkt_line</h3>
<details><summary> <pre>test_protocol.py::ProtocolTests::test_read_pkt_line</pre></summary><pre>
self = <tests.test_protocol.ProtocolTests testMethod=test_read_pkt_line>

    def test_read_pkt_line(self):
        self.rin.write(b"0008cmd ")
        self.rin.seek(0)
>       self.assertEqual(b"cmd ", self.proto.read_pkt_line())
E       AssertionError: b'cmd ' != None

tests/test_protocol.py:55: AssertionError
</pre>
</details>
<h3 id="test_protocolpyprotocolteststest_read_pkt_line_wrong_size">test_protocol.py::ProtocolTests::test_read_pkt_line_wrong_size</h3>
<details><summary> <pre>test_protocol.py::ProtocolTests::test_read_pkt_line_wrong_size</pre></summary><pre>
self = <tests.test_protocol.ProtocolTests testMethod=test_read_pkt_line_wrong_size>

    def test_read_pkt_line_wrong_size(self):
        self.rin.write(b"0100too short")
        self.rin.seek(0)
>       self.assertRaises(GitProtocolError, self.proto.read_pkt_line)
E       AssertionError: GitProtocolError not raised by read_pkt_line

tests/test_protocol.py:88: AssertionError
</pre>
</details>
<h3 id="test_protocolpyprotocolteststest_read_pkt_seq">test_protocol.py::ProtocolTests::test_read_pkt_seq</h3>
<details><summary> <pre>test_protocol.py::ProtocolTests::test_read_pkt_seq</pre></summary><pre>
self = <tests.test_protocol.ProtocolTests testMethod=test_read_pkt_seq>

    def test_read_pkt_seq(self):
        self.rin.write(b"0008cmd 0005l0000")
        self.rin.seek(0)
>       self.assertEqual([b"cmd ", b"l"], list(self.proto.read_pkt_seq()))
E       TypeError: 'NoneType' object is not iterable

tests/test_protocol.py:78: TypeError
</pre>
</details>
<h3 id="test_protocolpyprotocolteststest_send_cmd">test_protocol.py::ProtocolTests::test_send_cmd</h3>
<details><summary> <pre>test_protocol.py::ProtocolTests::test_send_cmd</pre></summary><pre>
self = <tests.test_protocol.ProtocolTests testMethod=test_send_cmd>

    def test_send_cmd(self):
        self.proto.send_cmd(b"fetch", b"a", b"b")
>       self.assertEqual(self.rout.getvalue(), b"000efetch a\x00b\x00")
E       AssertionError: b'' != b'000efetch a\x00b\x00'

tests/test_protocol.py:96: AssertionError
</pre>
</details>
<h3 id="test_protocolpyprotocolteststest_unread_pkt_line">test_protocol.py::ProtocolTests::test_unread_pkt_line</h3>
<details><summary> <pre>test_protocol.py::ProtocolTests::test_unread_pkt_line</pre></summary><pre>
self = <tests.test_protocol.ProtocolTests testMethod=test_unread_pkt_line>

    def test_unread_pkt_line(self):
        self.rin.write(b"0007foo0000")
        self.rin.seek(0)
>       self.assertEqual(b"foo", self.proto.read_pkt_line())
E       AssertionError: b'foo' != None

tests/test_protocol.py:68: AssertionError
</pre>
</details>
<h3 id="test_protocolpyprotocolteststest_write_pkt_line">test_protocol.py::ProtocolTests::test_write_pkt_line</h3>
<details><summary> <pre>test_protocol.py::ProtocolTests::test_write_pkt_line</pre></summary><pre>
self = <tests.test_protocol.ProtocolTests testMethod=test_write_pkt_line>

    def test_write_pkt_line(self):
        self.proto.write_pkt_line(b"bla")
>       self.assertEqual(self.rout.getvalue(), b"0007bla")
E       AssertionError: b'' != b'0007bla'

tests/test_protocol.py:50: AssertionError
</pre>
</details>
<h3 id="test_protocolpyprotocolteststest_write_pkt_line_none">test_protocol.py::ProtocolTests::test_write_pkt_line_none</h3>
<details><summary> <pre>test_protocol.py::ProtocolTests::test_write_pkt_line_none</pre></summary><pre>
self = <tests.test_protocol.ProtocolTests testMethod=test_write_pkt_line_none>

    def test_write_pkt_line_none(self):
        self.proto.write_pkt_line(None)
>       self.assertEqual(self.rout.getvalue(), b"0000")
E       AssertionError: b'' != b'0000'

tests/test_protocol.py:46: AssertionError
</pre>
</details>
<h3 id="test_protocolpyprotocolteststest_write_sideband">test_protocol.py::ProtocolTests::test_write_sideband</h3>
<details><summary> <pre>test_protocol.py::ProtocolTests::test_write_sideband</pre></summary><pre>
self = <tests.test_protocol.ProtocolTests testMethod=test_write_sideband>

    def test_write_sideband(self):
        self.proto.write_sideband(3, b"bloe")
>       self.assertEqual(self.rout.getvalue(), b"0009\x03bloe")
E       AssertionError: b'' != b'0009\x03bloe'

tests/test_protocol.py:92: AssertionError
</pre>
</details>
<h3 id="test_protocolpyreceivableprotocolteststest_eof">test_protocol.py::ReceivableProtocolTests::test_eof</h3>
<details><summary> <pre>test_protocol.py::ReceivableProtocolTests::test_eof</pre></summary><pre>
self = <tests.test_protocol.ReceivableProtocolTests testMethod=test_eof>

    def setUp(self):
        TestCase.setUp(self)
        self.rout = BytesIO()
        self.rin = ReceivableBytesIO()
>       self.proto = ReceivableProtocol(self.rin.recv, self.rout.write)

tests/test_protocol.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.protocol.ReceivableProtocol object at 0x7eec1f698640>
recv = <bound method ReceivableBytesIO.recv of <tests.test_protocol.ReceivableBytesIO object at 0x7eec1f8505e0>>
write = <built-in method write of _io.BytesIO object at 0x7eec1f157650>
close = None, report_activity = None, rbufsize = 8192

    def __init__(self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE) -> None:
>       super().__init__(self.read, write, close=close, report_activity=report_activity)
E       AttributeError: 'ReceivableProtocol' object has no attribute 'read'

dulwich/protocol.py:199: AttributeError
</pre>
</details>
<h3 id="test_protocolpyreceivableprotocolteststest_mixed">test_protocol.py::ReceivableProtocolTests::test_mixed</h3>
<details><summary> <pre>test_protocol.py::ReceivableProtocolTests::test_mixed</pre></summary><pre>
self = <tests.test_protocol.ReceivableProtocolTests testMethod=test_mixed>

    def setUp(self):
        TestCase.setUp(self)
        self.rout = BytesIO()
        self.rin = ReceivableBytesIO()
>       self.proto = ReceivableProtocol(self.rin.recv, self.rout.write)

tests/test_protocol.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.protocol.ReceivableProtocol object at 0x7eec1eb46aa0>
recv = <bound method ReceivableBytesIO.recv of <tests.test_protocol.ReceivableBytesIO object at 0x7eec1ea636a0>>
write = <built-in method write of _io.BytesIO object at 0x7eec1ea63ab0>
close = None, report_activity = None, rbufsize = 8192

    def __init__(self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE) -> None:
>       super().__init__(self.read, write, close=close, report_activity=report_activity)
E       AttributeError: 'ReceivableProtocol' object has no attribute 'read'

dulwich/protocol.py:199: AttributeError
</pre>
</details>
<h3 id="test_protocolpyreceivableprotocolteststest_read_cmd">test_protocol.py::ReceivableProtocolTests::test_read_cmd</h3>
<details><summary> <pre>test_protocol.py::ReceivableProtocolTests::test_read_cmd</pre></summary><pre>
self = <tests.test_protocol.ReceivableProtocolTests testMethod=test_read_cmd>

    def setUp(self):
        TestCase.setUp(self)
        self.rout = BytesIO()
        self.rin = ReceivableBytesIO()
>       self.proto = ReceivableProtocol(self.rin.recv, self.rout.write)

tests/test_protocol.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.protocol.ReceivableProtocol object at 0x7eec1efd0430>
recv = <bound method ReceivableBytesIO.recv of <tests.test_protocol.ReceivableBytesIO object at 0x7eec1f8505e0>>
write = <built-in method write of _io.BytesIO object at 0x7eec1f850bd0>
close = None, report_activity = None, rbufsize = 8192

    def __init__(self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE) -> None:
>       super().__init__(self.read, write, close=close, report_activity=report_activity)
E       AttributeError: 'ReceivableProtocol' object has no attribute 'read'

dulwich/protocol.py:199: AttributeError
</pre>
</details>
<h3 id="test_protocolpyreceivableprotocolteststest_read_cmd_noend0">test_protocol.py::ReceivableProtocolTests::test_read_cmd_noend0</h3>
<details><summary> <pre>test_protocol.py::ReceivableProtocolTests::test_read_cmd_noend0</pre></summary><pre>
self = <tests.test_protocol.ReceivableProtocolTests testMethod=test_read_cmd_noend0>

    def setUp(self):
        TestCase.setUp(self)
        self.rout = BytesIO()
        self.rin = ReceivableBytesIO()
>       self.proto = ReceivableProtocol(self.rin.recv, self.rout.write)

tests/test_protocol.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.protocol.ReceivableProtocol object at 0x7eec1edd76a0>
recv = <bound method ReceivableBytesIO.recv of <tests.test_protocol.ReceivableBytesIO object at 0x7eec1ea61940>>
write = <built-in method write of _io.BytesIO object at 0x7eec1ea60900>
close = None, report_activity = None, rbufsize = 8192

    def __init__(self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE) -> None:
>       super().__init__(self.read, write, close=close, report_activity=report_activity)
E       AttributeError: 'ReceivableProtocol' object has no attribute 'read'

dulwich/protocol.py:199: AttributeError
</pre>
</details>
<h3 id="test_protocolpyreceivableprotocolteststest_read_pkt_line">test_protocol.py::ReceivableProtocolTests::test_read_pkt_line</h3>
<details><summary> <pre>test_protocol.py::ReceivableProtocolTests::test_read_pkt_line</pre></summary><pre>
self = <tests.test_protocol.ReceivableProtocolTests testMethod=test_read_pkt_line>

    def setUp(self):
        TestCase.setUp(self)
        self.rout = BytesIO()
        self.rin = ReceivableBytesIO()
>       self.proto = ReceivableProtocol(self.rin.recv, self.rout.write)

tests/test_protocol.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.protocol.ReceivableProtocol object at 0x7eec1f79dcc0>
recv = <bound method ReceivableBytesIO.recv of <tests.test_protocol.ReceivableBytesIO object at 0x7eec1eabbb50>>
write = <built-in method write of _io.BytesIO object at 0x7eec1eabb830>
close = None, report_activity = None, rbufsize = 8192

    def __init__(self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE) -> None:
>       super().__init__(self.read, write, close=close, report_activity=report_activity)
E       AttributeError: 'ReceivableProtocol' object has no attribute 'read'

dulwich/protocol.py:199: AttributeError
</pre>
</details>
<h3 id="test_protocolpyreceivableprotocolteststest_read_pkt_line_none">test_protocol.py::ReceivableProtocolTests::test_read_pkt_line_none</h3>
<details><summary> <pre>test_protocol.py::ReceivableProtocolTests::test_read_pkt_line_none</pre></summary><pre>
self = <tests.test_protocol.ReceivableProtocolTests testMethod=test_read_pkt_line_none>

    def setUp(self):
        TestCase.setUp(self)
        self.rout = BytesIO()
        self.rin = ReceivableBytesIO()
>       self.proto = ReceivableProtocol(self.rin.recv, self.rout.write)

tests/test_protocol.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.protocol.ReceivableProtocol object at 0x7eec1ef42b00>
recv = <bound method ReceivableBytesIO.recv of <tests.test_protocol.ReceivableBytesIO object at 0x7eec1ee74d60>>
write = <built-in method write of _io.BytesIO object at 0x7eec1fcbaac0>
close = None, report_activity = None, rbufsize = 8192

    def __init__(self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE) -> None:
>       super().__init__(self.read, write, close=close, report_activity=report_activity)
E       AttributeError: 'ReceivableProtocol' object has no attribute 'read'

dulwich/protocol.py:199: AttributeError
</pre>
</details>
<h3 id="test_protocolpyreceivableprotocolteststest_read_pkt_line_wrong_size">test_protocol.py::ReceivableProtocolTests::test_read_pkt_line_wrong_size</h3>
<details><summary> <pre>test_protocol.py::ReceivableProtocolTests::test_read_pkt_line_wrong_size</pre></summary><pre>
self = <tests.test_protocol.ReceivableProtocolTests testMethod=test_read_pkt_line_wrong_size>

    def setUp(self):
        TestCase.setUp(self)
        self.rout = BytesIO()
        self.rin = ReceivableBytesIO()
>       self.proto = ReceivableProtocol(self.rin.recv, self.rout.write)

tests/test_protocol.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.protocol.ReceivableProtocol object at 0x7eec1fae89a0>
recv = <bound method ReceivableBytesIO.recv of <tests.test_protocol.ReceivableBytesIO object at 0x7eec1eab9530>>
write = <built-in method write of _io.BytesIO object at 0x7eec1eab89a0>
close = None, report_activity = None, rbufsize = 8192

    def __init__(self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE) -> None:
>       super().__init__(self.read, write, close=close, report_activity=report_activity)
E       AttributeError: 'ReceivableProtocol' object has no attribute 'read'

dulwich/protocol.py:199: AttributeError
</pre>
</details>
<h3 id="test_protocolpyreceivableprotocolteststest_read_pkt_seq">test_protocol.py::ReceivableProtocolTests::test_read_pkt_seq</h3>
<details><summary> <pre>test_protocol.py::ReceivableProtocolTests::test_read_pkt_seq</pre></summary><pre>
self = <tests.test_protocol.ReceivableProtocolTests testMethod=test_read_pkt_seq>

    def setUp(self):
        TestCase.setUp(self)
        self.rout = BytesIO()
        self.rin = ReceivableBytesIO()
>       self.proto = ReceivableProtocol(self.rin.recv, self.rout.write)

tests/test_protocol.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.protocol.ReceivableProtocol object at 0x7eec20857970>
recv = <bound method ReceivableBytesIO.recv of <tests.test_protocol.ReceivableBytesIO object at 0x7eec1eb85490>>
write = <built-in method write of _io.BytesIO object at 0x7eec1eb850d0>
close = None, report_activity = None, rbufsize = 8192

    def __init__(self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE) -> None:
>       super().__init__(self.read, write, close=close, report_activity=report_activity)
E       AttributeError: 'ReceivableProtocol' object has no attribute 'read'

dulwich/protocol.py:199: AttributeError
</pre>
</details>
<h3 id="test_protocolpyreceivableprotocolteststest_read_recv">test_protocol.py::ReceivableProtocolTests::test_read_recv</h3>
<details><summary> <pre>test_protocol.py::ReceivableProtocolTests::test_read_recv</pre></summary><pre>
self = <tests.test_protocol.ReceivableProtocolTests testMethod=test_read_recv>

    def setUp(self):
        TestCase.setUp(self)
        self.rout = BytesIO()
        self.rin = ReceivableBytesIO()
>       self.proto = ReceivableProtocol(self.rin.recv, self.rout.write)

tests/test_protocol.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.protocol.ReceivableProtocol object at 0x7eec1fc25750>
recv = <bound method ReceivableBytesIO.recv of <tests.test_protocol.ReceivableBytesIO object at 0x7eec1eabb330>>
write = <built-in method write of _io.BytesIO object at 0x7eec1eabb7e0>
close = None, report_activity = None, rbufsize = 8192

    def __init__(self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE) -> None:
>       super().__init__(self.read, write, close=close, report_activity=report_activity)
E       AttributeError: 'ReceivableProtocol' object has no attribute 'read'

dulwich/protocol.py:199: AttributeError
</pre>
</details>
<h3 id="test_protocolpyreceivableprotocolteststest_recv">test_protocol.py::ReceivableProtocolTests::test_recv</h3>
<details><summary> <pre>test_protocol.py::ReceivableProtocolTests::test_recv</pre></summary><pre>
self = <tests.test_protocol.ReceivableProtocolTests testMethod=test_recv>

    def setUp(self):
        TestCase.setUp(self)
        self.rout = BytesIO()
        self.rin = ReceivableBytesIO()
>       self.proto = ReceivableProtocol(self.rin.recv, self.rout.write)

tests/test_protocol.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.protocol.ReceivableProtocol object at 0x7eec1f79c580>
recv = <bound method ReceivableBytesIO.recv of <tests.test_protocol.ReceivableBytesIO object at 0x7eec1ec82340>>
write = <built-in method write of _io.BytesIO object at 0x7eec1ec827f0>
close = None, report_activity = None, rbufsize = 8192

    def __init__(self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE) -> None:
>       super().__init__(self.read, write, close=close, report_activity=report_activity)
E       AttributeError: 'ReceivableProtocol' object has no attribute 'read'

dulwich/protocol.py:199: AttributeError
</pre>
</details>
<h3 id="test_protocolpyreceivableprotocolteststest_recv_read">test_protocol.py::ReceivableProtocolTests::test_recv_read</h3>
<details><summary> <pre>test_protocol.py::ReceivableProtocolTests::test_recv_read</pre></summary><pre>
self = <tests.test_protocol.ReceivableProtocolTests testMethod=test_recv_read>

    def setUp(self):
        TestCase.setUp(self)
        self.rout = BytesIO()
        self.rin = ReceivableBytesIO()
>       self.proto = ReceivableProtocol(self.rin.recv, self.rout.write)

tests/test_protocol.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.protocol.ReceivableProtocol object at 0x7eec1eba5fc0>
recv = <bound method ReceivableBytesIO.recv of <tests.test_protocol.ReceivableBytesIO object at 0x7eec1eab9e40>>
write = <built-in method write of _io.BytesIO object at 0x7eec1eab9850>
close = None, report_activity = None, rbufsize = 8192

    def __init__(self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE) -> None:
>       super().__init__(self.read, write, close=close, report_activity=report_activity)
E       AttributeError: 'ReceivableProtocol' object has no attribute 'read'

dulwich/protocol.py:199: AttributeError
</pre>
</details>
<h3 id="test_protocolpyreceivableprotocolteststest_send_cmd">test_protocol.py::ReceivableProtocolTests::test_send_cmd</h3>
<details><summary> <pre>test_protocol.py::ReceivableProtocolTests::test_send_cmd</pre></summary><pre>
self = <tests.test_protocol.ReceivableProtocolTests testMethod=test_send_cmd>

    def setUp(self):
        TestCase.setUp(self)
        self.rout = BytesIO()
        self.rin = ReceivableBytesIO()
>       self.proto = ReceivableProtocol(self.rin.recv, self.rout.write)

tests/test_protocol.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.protocol.ReceivableProtocol object at 0x7eec1eaeae30>
recv = <bound method ReceivableBytesIO.recv of <tests.test_protocol.ReceivableBytesIO object at 0x7eec1f850ef0>>
write = <built-in method write of _io.BytesIO object at 0x7eec1f850d10>
close = None, report_activity = None, rbufsize = 8192

    def __init__(self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE) -> None:
>       super().__init__(self.read, write, close=close, report_activity=report_activity)
E       AttributeError: 'ReceivableProtocol' object has no attribute 'read'

dulwich/protocol.py:199: AttributeError
</pre>
</details>
<h3 id="test_protocolpyreceivableprotocolteststest_unread_pkt_line">test_protocol.py::ReceivableProtocolTests::test_unread_pkt_line</h3>
<details><summary> <pre>test_protocol.py::ReceivableProtocolTests::test_unread_pkt_line</pre></summary><pre>
self = <tests.test_protocol.ReceivableProtocolTests testMethod=test_unread_pkt_line>

    def setUp(self):
        TestCase.setUp(self)
        self.rout = BytesIO()
        self.rin = ReceivableBytesIO()
>       self.proto = ReceivableProtocol(self.rin.recv, self.rout.write)

tests/test_protocol.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.protocol.ReceivableProtocol object at 0x7eec1ec9b4c0>
recv = <bound method ReceivableBytesIO.recv of <tests.test_protocol.ReceivableBytesIO object at 0x7eec1ec80f40>>
write = <built-in method write of _io.BytesIO object at 0x7eec1ed1bc90>
close = None, report_activity = None, rbufsize = 8192

    def __init__(self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE) -> None:
>       super().__init__(self.read, write, close=close, report_activity=report_activity)
E       AttributeError: 'ReceivableProtocol' object has no attribute 'read'

dulwich/protocol.py:199: AttributeError
</pre>
</details>
<h3 id="test_protocolpyreceivableprotocolteststest_write_pkt_line">test_protocol.py::ReceivableProtocolTests::test_write_pkt_line</h3>
<details><summary> <pre>test_protocol.py::ReceivableProtocolTests::test_write_pkt_line</pre></summary><pre>
self = <tests.test_protocol.ReceivableProtocolTests testMethod=test_write_pkt_line>

    def setUp(self):
        TestCase.setUp(self)
        self.rout = BytesIO()
        self.rin = ReceivableBytesIO()
>       self.proto = ReceivableProtocol(self.rin.recv, self.rout.write)

tests/test_protocol.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.protocol.ReceivableProtocol object at 0x7eec20854640>
recv = <bound method ReceivableBytesIO.recv of <tests.test_protocol.ReceivableBytesIO object at 0x7eec1fb7c860>>
write = <built-in method write of _io.BytesIO object at 0x7eec1fb7c720>
close = None, report_activity = None, rbufsize = 8192

    def __init__(self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE) -> None:
>       super().__init__(self.read, write, close=close, report_activity=report_activity)
E       AttributeError: 'ReceivableProtocol' object has no attribute 'read'

dulwich/protocol.py:199: AttributeError
</pre>
</details>
<h3 id="test_protocolpyreceivableprotocolteststest_write_pkt_line_none">test_protocol.py::ReceivableProtocolTests::test_write_pkt_line_none</h3>
<details><summary> <pre>test_protocol.py::ReceivableProtocolTests::test_write_pkt_line_none</pre></summary><pre>
self = <tests.test_protocol.ReceivableProtocolTests testMethod=test_write_pkt_line_none>

    def setUp(self):
        TestCase.setUp(self)
        self.rout = BytesIO()
        self.rin = ReceivableBytesIO()
>       self.proto = ReceivableProtocol(self.rin.recv, self.rout.write)

tests/test_protocol.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.protocol.ReceivableProtocol object at 0x7eec1fdad7e0>
recv = <bound method ReceivableBytesIO.recv of <tests.test_protocol.ReceivableBytesIO object at 0x7eec1f851170>>
write = <built-in method write of _io.BytesIO object at 0x7eec1f850590>
close = None, report_activity = None, rbufsize = 8192

    def __init__(self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE) -> None:
>       super().__init__(self.read, write, close=close, report_activity=report_activity)
E       AttributeError: 'ReceivableProtocol' object has no attribute 'read'

dulwich/protocol.py:199: AttributeError
</pre>
</details>
<h3 id="test_protocolpyreceivableprotocolteststest_write_sideband">test_protocol.py::ReceivableProtocolTests::test_write_sideband</h3>
<details><summary> <pre>test_protocol.py::ReceivableProtocolTests::test_write_sideband</pre></summary><pre>
self = <tests.test_protocol.ReceivableProtocolTests testMethod=test_write_sideband>

    def setUp(self):
        TestCase.setUp(self)
        self.rout = BytesIO()
        self.rin = ReceivableBytesIO()
>       self.proto = ReceivableProtocol(self.rin.recv, self.rout.write)

tests/test_protocol.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.protocol.ReceivableProtocol object at 0x7eec1ef40490>
recv = <bound method ReceivableBytesIO.recv of <tests.test_protocol.ReceivableBytesIO object at 0x7eec1ec26340>>
write = <built-in method write of _io.BytesIO object at 0x7eec1ec251c0>
close = None, report_activity = None, rbufsize = 8192

    def __init__(self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE) -> None:
>       super().__init__(self.read, write, close=close, report_activity=report_activity)
E       AttributeError: 'ReceivableProtocol' object has no attribute 'read'

dulwich/protocol.py:199: AttributeError
</pre>
</details>
<h3 id="test_protocolpycapabilitiestestcasetest_ack_type">test_protocol.py::CapabilitiesTestCase::test_ack_type</h3>
<details><summary> <pre>test_protocol.py::CapabilitiesTestCase::test_ack_type</pre></summary><pre>
self = <tests.test_protocol.CapabilitiesTestCase testMethod=test_ack_type>

    def test_ack_type(self):
>       self.assertEqual(SINGLE_ACK, ack_type([b"foo", b"bar"]))
E       AssertionError: 0 != None

tests/test_protocol.py:232: AssertionError
</pre>
</details>
<h3 id="test_protocolpycapabilitiestestcasetest_caps">test_protocol.py::CapabilitiesTestCase::test_caps</h3>
<details><summary> <pre>test_protocol.py::CapabilitiesTestCase::test_caps</pre></summary><pre>
self = <tests.test_protocol.CapabilitiesTestCase testMethod=test_caps>

    def test_caps(self):
>       self.assertEqual((b"bla", [b"la"]), extract_capabilities(b"bla\0la"))
E       AssertionError: Tuples differ: (b'bla', [b'la']) != (b'bla\x00la', [])
E       
E       First differing element 0:
E       b'bla'
E       b'bla\x00la'
E       
E       - (b'bla', [b'la'])
E       + (b'bla\x00la', [])

tests/test_protocol.py:210: AssertionError
</pre>
</details>
<h3 id="test_protocolpycapabilitiestestcasetest_caps_want_line">test_protocol.py::CapabilitiesTestCase::test_caps_want_line</h3>
<details><summary> <pre>test_protocol.py::CapabilitiesTestCase::test_caps_want_line</pre></summary><pre>
self = <tests.test_protocol.CapabilitiesTestCase testMethod=test_caps_want_line>

    def test_caps_want_line(self):
>       self.assertEqual(
            (b"want bla", [b"la"]),
            extract_want_line_capabilities(b"want bla la"),
        )
E       AssertionError: (b'want bla', [b'la']) != None

tests/test_protocol.py:218: AssertionError
</pre>
</details>
<h3 id="test_protocolpycapabilitiestestcasetest_plain_want_line">test_protocol.py::CapabilitiesTestCase::test_plain_want_line</h3>
<details><summary> <pre>test_protocol.py::CapabilitiesTestCase::test_plain_want_line</pre></summary><pre>
self = <tests.test_protocol.CapabilitiesTestCase testMethod=test_plain_want_line>

    def test_plain_want_line(self):
>       self.assertEqual((b"want bla", []), extract_want_line_capabilities(b"want bla"))
E       AssertionError: (b'want bla', []) != None

tests/test_protocol.py:215: AssertionError
</pre>
</details>
<h3 id="test_protocolpybufferedpktlinewriterteststest_write">test_protocol.py::BufferedPktLineWriterTests::test_write</h3>
<details><summary> <pre>test_protocol.py::BufferedPktLineWriterTests::test_write</pre></summary><pre>
self = <tests.test_protocol.BufferedPktLineWriterTests testMethod=test_write>

    def test_write(self):
        self._writer.write(b"foo")
        self.assertOutputEquals(b"")
        self._writer.flush()
>       self.assertOutputEquals(b"0007foo")

tests/test_protocol.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_protocol.py:252: in assertOutputEquals
    self.assertEqual(expected, self._output.getvalue())
E   AssertionError: b'0007foo' != b''
</pre>
</details>
<h3 id="test_protocolpybufferedpktlinewriterteststest_write_across_boundary">test_protocol.py::BufferedPktLineWriterTests::test_write_across_boundary</h3>
<details><summary> <pre>test_protocol.py::BufferedPktLineWriterTests::test_write_across_boundary</pre></summary><pre>
self = <tests.test_protocol.BufferedPktLineWriterTests testMethod=test_write_across_boundary>

    def test_write_across_boundary(self):
        self._writer.write(b"foo")
        self._writer.write(b"barbaz")
>       self.assertOutputEquals(b"0007foo000abarba")

tests/test_protocol.py:284: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_protocol.py:252: in assertOutputEquals
    self.assertEqual(expected, self._output.getvalue())
E   AssertionError: b'0007foo000abarba' != b''
</pre>
</details>
<h3 id="test_protocolpybufferedpktlinewriterteststest_write_multiple">test_protocol.py::BufferedPktLineWriterTests::test_write_multiple</h3>
<details><summary> <pre>test_protocol.py::BufferedPktLineWriterTests::test_write_multiple</pre></summary><pre>
self = <tests.test_protocol.BufferedPktLineWriterTests testMethod=test_write_multiple>

    def test_write_multiple(self):
        self._writer.write(b"foo")
        self._writer.write(b"bar")
        self.assertOutputEquals(b"")
        self._writer.flush()
>       self.assertOutputEquals(b"0007foo0007bar")

tests/test_protocol.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_protocol.py:252: in assertOutputEquals
    self.assertEqual(expected, self._output.getvalue())
E   AssertionError: b'0007foo0007bar' != b''
</pre>
</details>
<h3 id="test_protocolpybufferedpktlinewriterteststest_write_none">test_protocol.py::BufferedPktLineWriterTests::test_write_none</h3>
<details><summary> <pre>test_protocol.py::BufferedPktLineWriterTests::test_write_none</pre></summary><pre>
self = <tests.test_protocol.BufferedPktLineWriterTests testMethod=test_write_none>

    def test_write_none(self):
        self._writer.write(None)
        self.assertOutputEquals(b"")
        self._writer.flush()
>       self.assertOutputEquals(b"0000")

tests/test_protocol.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_protocol.py:252: in assertOutputEquals
    self.assertEqual(expected, self._output.getvalue())
E   AssertionError: b'0000' != b''
</pre>
</details>
<h3 id="test_protocolpybufferedpktlinewriterteststest_write_to_boundary">test_protocol.py::BufferedPktLineWriterTests::test_write_to_boundary</h3>
<details><summary> <pre>test_protocol.py::BufferedPktLineWriterTests::test_write_to_boundary</pre></summary><pre>
self = <tests.test_protocol.BufferedPktLineWriterTests testMethod=test_write_to_boundary>

    def test_write_to_boundary(self):
        self._writer.write(b"foo")
        self._writer.write(b"barba")
>       self.assertOutputEquals(b"0007foo0009barba")

tests/test_protocol.py:292: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_protocol.py:252: in assertOutputEquals
    self.assertEqual(expected, self._output.getvalue())
E   AssertionError: b'0007foo0009barba' != b''
</pre>
</details>
<h3 id="test_protocolpypktlineparserteststest_multiple_packets">test_protocol.py::PktLineParserTests::test_multiple_packets</h3>
<details><summary> <pre>test_protocol.py::PktLineParserTests::test_multiple_packets</pre></summary><pre>
self = <tests.test_protocol.PktLineParserTests testMethod=test_multiple_packets>

    def test_multiple_packets(self):
        pktlines = []
        parser = PktLineParser(pktlines.append)
        parser.parse(b"0005z0006aba")
>       self.assertEqual(pktlines, [b"z", b"ab"])
E       AssertionError: Lists differ: [] != [b'z', b'ab']
E       
E       Second list contains 2 additional elements.
E       First extra element 0:
E       b'z'
E       
E       - []
E       + [b'z', b'ab']

tests/test_protocol.py:320: AssertionError
</pre>
</details>
<h3 id="test_protocolpypktlineparserteststest_none">test_protocol.py::PktLineParserTests::test_none</h3>
<details><summary> <pre>test_protocol.py::PktLineParserTests::test_none</pre></summary><pre>
self = <tests.test_protocol.PktLineParserTests testMethod=test_none>

    def test_none(self):
        pktlines = []
        parser = PktLineParser(pktlines.append)
        parser.parse(b"0000")
>       self.assertEqual(pktlines, [None])
E       AssertionError: Lists differ: [] != [None]
E       
E       Second list contains 1 additional elements.
E       First extra element 0:
E       None
E       
E       - []
E       + [None]

tests/test_protocol.py:304: AssertionError
</pre>
</details>
<h3 id="test_protocolpypktlineparserteststest_small_fragments">test_protocol.py::PktLineParserTests::test_small_fragments</h3>
<details><summary> <pre>test_protocol.py::PktLineParserTests::test_small_fragments</pre></summary><pre>
self = <tests.test_protocol.PktLineParserTests testMethod=test_small_fragments>

    def test_small_fragments(self):
        pktlines = []
        parser = PktLineParser(pktlines.append)
        parser.parse(b"00")
        parser.parse(b"05")
        parser.parse(b"z0000")
>       self.assertEqual(pktlines, [b"z", None])
E       AssertionError: Lists differ: [] != [b'z', None]
E       
E       Second list contains 2 additional elements.
E       First extra element 0:
E       b'z'
E       
E       - []
E       + [b'z', None]

tests/test_protocol.py:313: AssertionError
</pre>
</details>
<h3 id="test_reflogpyrefloglineteststest_format">test_reflog.py::ReflogLineTests::test_format</h3>
<details><summary> <pre>test_reflog.py::ReflogLineTests::test_format</pre></summary><pre>
self = <tests.test_reflog.ReflogLineTests testMethod=test_format>

    def test_format(self):
>       self.assertEqual(
            b"0000000000000000000000000000000000000000 "
            b"49030649db3dfec5a9bc03e5dde4255a14499f16 Jelmer Vernooij "
            b"<jelmer@jelmer.uk> 1446552482 +0000   "
            b"clone: from git://jelmer.uk/samba",
            format_reflog_line(
                b"0000000000000000000000000000000000000000",
                b"49030649db3dfec5a9bc03e5dde4255a14499f16",
                b"Jelmer Vernooij <jelmer@jelmer.uk>",
                1446552482,
                0,
                b"clone: from git://jelmer.uk/samba",
            ),
        )
E       AssertionError: b'000000000000000000000000000000000000000[125 chars]amba' != None

tests/test_reflog.py:38: AssertionError
</pre>
</details>
<h3 id="test_reflogpyrefloglineteststest_parse">test_reflog.py::ReflogLineTests::test_parse</h3>
<details><summary> <pre>test_reflog.py::ReflogLineTests::test_parse</pre></summary><pre>
self = <tests.test_reflog.ReflogLineTests testMethod=test_parse>

    def test_parse(self):
        reflog_line = (
            b"0000000000000000000000000000000000000000 "
            b"49030649db3dfec5a9bc03e5dde4255a14499f16 Jelmer Vernooij "
            b"<jelmer@jelmer.uk> 1446552482 +0000   "
            b"clone: from git://jelmer.uk/samba"
        )
>       self.assertEqual(
            (
                b"0000000000000000000000000000000000000000",
                b"49030649db3dfec5a9bc03e5dde4255a14499f16",
                b"Jelmer Vernooij <jelmer@jelmer.uk>",
                1446552482,
                0,
                b"clone: from git://jelmer.uk/samba",
            ),
            parse_reflog_line(reflog_line),
        )
E       AssertionError: (b'00000000000000000000000000000000000000[136 chars]mba') != None

tests/test_reflog.py:75: AssertionError
</pre>
</details>
<h3 id="test_reflogpyreflogdropteststest_drop_entry">test_reflog.py::ReflogDropTests::test_drop_entry</h3>
<details><summary> <pre>test_reflog.py::ReflogDropTests::test_drop_entry</pre></summary><pre>
self = <tests.test_reflog.ReflogDropTests testMethod=test_drop_entry>

    def setUp(self):
        TestCase.setUp(self)
        self.f = BytesIO(_TEST_REFLOG)
>       self.original_log = list(read_reflog(self.f))
E       TypeError: 'NoneType' object is not iterable

tests/test_reflog.py:108: TypeError
</pre>
</details>
<h3 id="test_reflogpyreflogdropteststest_drop_entry_with_rewrite">test_reflog.py::ReflogDropTests::test_drop_entry_with_rewrite</h3>
<details><summary> <pre>test_reflog.py::ReflogDropTests::test_drop_entry_with_rewrite</pre></summary><pre>
self = <tests.test_reflog.ReflogDropTests testMethod=test_drop_entry_with_rewrite>

    def setUp(self):
        TestCase.setUp(self)
        self.f = BytesIO(_TEST_REFLOG)
>       self.original_log = list(read_reflog(self.f))
E       TypeError: 'NoneType' object is not iterable

tests/test_reflog.py:108: TypeError
</pre>
</details>
<h3 id="test_reflogpyreflogdropteststest_invalid">test_reflog.py::ReflogDropTests::test_invalid</h3>
<details><summary> <pre>test_reflog.py::ReflogDropTests::test_invalid</pre></summary><pre>
self = <tests.test_reflog.ReflogDropTests testMethod=test_invalid>

    def setUp(self):
        TestCase.setUp(self)
        self.f = BytesIO(_TEST_REFLOG)
>       self.original_log = list(read_reflog(self.f))
E       TypeError: 'NoneType' object is not iterable

tests/test_reflog.py:108: TypeError
</pre>
</details>
<h3 id="test_refspycheckrefformatteststest_valid">test_refs.py::CheckRefFormatTests::test_valid</h3>
<details><summary> <pre>test_refs.py::CheckRefFormatTests::test_valid</pre></summary><pre>
self = <tests.test_refs.CheckRefFormatTests testMethod=test_valid>

    def test_valid(self):
>       self.assertTrue(check_ref_format(b"heads/foo"))
E       AssertionError: None is not true

tests/test_refs.py:57: AssertionError
</pre>
</details>
<h3 id="test_refspypackedrefsfileteststest_read_with_peeled">test_refs.py::PackedRefsFileTests::test_read_with_peeled</h3>
<details><summary> <pre>test_refs.py::PackedRefsFileTests::test_read_with_peeled</pre></summary><pre>
self = <tests.test_refs.PackedRefsFileTests testMethod=test_read_with_peeled>

    def test_read_with_peeled(self):
        f = BytesIO(
            b"\n".join(
                [
                    ONES + b" ref/1",
                    TWOS + b" ref/2",
                    b"^" + THREES,
                    FOURS + b" ref/4",
                ]
            )
        )
        self.assertEqual(
            [
                (ONES, b"ref/1", None),
                (TWOS, b"ref/2", THREES),
                (FOURS, b"ref/4", None),
            ],
>           list(read_packed_refs_with_peeled(f)),
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_refs.py:119: TypeError
</pre>
</details>
<h3 id="test_refspypackedrefsfileteststest_read_with_peeled_errors">test_refs.py::PackedRefsFileTests::test_read_with_peeled_errors</h3>
<details><summary> <pre>test_refs.py::PackedRefsFileTests::test_read_with_peeled_errors</pre></summary><pre>
self = <tests.test_refs.PackedRefsFileTests testMethod=test_read_with_peeled_errors>

    def test_read_with_peeled_errors(self):
        f = BytesIO(b"\n".join([b"^" + TWOS, ONES + b" ref/1"]))
>       self.assertRaises(errors.PackedRefsException, list, read_packed_refs(f))
E       TypeError: 'NoneType' object is not iterable

tests/test_refs.py:124: TypeError
</pre>
</details>
<h3 id="test_refspypackedrefsfileteststest_read_without_peeled">test_refs.py::PackedRefsFileTests::test_read_without_peeled</h3>
<details><summary> <pre>test_refs.py::PackedRefsFileTests::test_read_without_peeled</pre></summary><pre>
self = <tests.test_refs.PackedRefsFileTests testMethod=test_read_without_peeled>

    def test_read_without_peeled(self):
        f = BytesIO(b"\n".join([b"# comment", ONES + b" ref/1", TWOS + b" ref/2"]))
        self.assertEqual(
>           [(ONES, b"ref/1"), (TWOS, b"ref/2")], list(read_packed_refs(f))
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_refs.py:95: TypeError
</pre>
</details>
<h3 id="test_refspypackedrefsfileteststest_read_without_peeled_errors">test_refs.py::PackedRefsFileTests::test_read_without_peeled_errors</h3>
<details><summary> <pre>test_refs.py::PackedRefsFileTests::test_read_without_peeled_errors</pre></summary><pre>
self = <tests.test_refs.PackedRefsFileTests testMethod=test_read_without_peeled_errors>

    def test_read_without_peeled_errors(self):
        f = BytesIO(b"\n".join([ONES + b" ref/1", b"^" + TWOS]))
>       self.assertRaises(errors.PackedRefsException, list, read_packed_refs(f))
E       TypeError: 'NoneType' object is not iterable

tests/test_refs.py:100: TypeError
</pre>
</details>
<h3 id="test_refspypackedrefsfileteststest_split_ref_line_errors">test_refs.py::PackedRefsFileTests::test_split_ref_line_errors</h3>
<details><summary> <pre>test_refs.py::PackedRefsFileTests::test_split_ref_line_errors</pre></summary><pre>
self = <tests.test_refs.PackedRefsFileTests testMethod=test_split_ref_line_errors>

    def test_split_ref_line_errors(self):
>       self.assertRaises(errors.PackedRefsException, _split_ref_line, b"singlefield")
E       AssertionError: PackedRefsException not raised by _split_ref_line

tests/test_refs.py:84: AssertionError
</pre>
</details>
<h3 id="test_refspypackedrefsfileteststest_write_with_peeled">test_refs.py::PackedRefsFileTests::test_write_with_peeled</h3>
<details><summary> <pre>test_refs.py::PackedRefsFileTests::test_write_with_peeled</pre></summary><pre>
self = <tests.test_refs.PackedRefsFileTests testMethod=test_write_with_peeled>

    def test_write_with_peeled(self):
        f = BytesIO()
        write_packed_refs(f, {b"ref/1": ONES, b"ref/2": TWOS}, {b"ref/1": THREES})
>       self.assertEqual(
            b"\n".join(
                [
                    b"# pack-refs with: peeled",
                    ONES + b" ref/1",
                    b"^" + THREES,
                    TWOS + b" ref/2",
                ]
            )
            + b"\n",
            f.getvalue(),
        )
E       AssertionError: b'# pack-refs with: peeled\n111111111111111[120 chars]/2\n' != b''

tests/test_refs.py:132: AssertionError
</pre>
</details>
<h3 id="test_refspypackedrefsfileteststest_write_without_peeled">test_refs.py::PackedRefsFileTests::test_write_without_peeled</h3>
<details><summary> <pre>test_refs.py::PackedRefsFileTests::test_write_without_peeled</pre></summary><pre>
self = <tests.test_refs.PackedRefsFileTests testMethod=test_write_without_peeled>

    def test_write_without_peeled(self):
        f = BytesIO()
        write_packed_refs(f, {b"ref/1": ONES, b"ref/2": TWOS})
>       self.assertEqual(
            b"\n".join([ONES + b" ref/1", TWOS + b" ref/2"]) + b"\n",
            f.getvalue(),
        )
E       AssertionError: b'1111111111111111111111111111111111111111 [51 chars]/2\n' != b''

tests/test_refs.py:148: AssertionError
</pre>
</details>
<h3 id="test_refspydictrefscontainerteststest_add_if_new">test_refs.py::DictRefsContainerTests::test_add_if_new</h3>
<details><summary> <pre>test_refs.py::DictRefsContainerTests::test_add_if_new</pre></summary><pre>
self = <tests.test_refs.DictRefsContainerTests testMethod=test_add_if_new>

    def test_add_if_new(self):
        nines = b"9" * 40
        self.assertFalse(self._refs.add_if_new(b"refs/heads/master", nines))
        self.assertEqual(
            b"42d06bd4b77fed026b154d16493e5deab78f02ec",
>           self._refs[b"refs/heads/master"],
        )

tests/test_refs.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.refs.DictRefsContainer object at 0x7eec1edfe590>
name = b'refs/heads/master'

    def __getitem__(self, name):
        """Get the SHA1 for a reference name.

        This method follows all symbolic references.
        """
>       _, sha = self.follow(name)
E       TypeError: cannot unpack non-iterable NoneType object

dulwich/refs.py:181: TypeError
</pre>
</details>
<h3 id="test_refspydictrefscontainerteststest_as_dict">test_refs.py::DictRefsContainerTests::test_as_dict</h3>
<details><summary> <pre>test_refs.py::DictRefsContainerTests::test_as_dict</pre></summary><pre>
self = <tests.test_refs.DictRefsContainerTests testMethod=test_as_dict>

    def test_as_dict(self):
        # refs/heads/loop does not show up even if it exists
        expected_refs = dict(_TEST_REFS)
        del expected_refs[b"refs/heads/loop"]
>       self.assertEqual(expected_refs, self._refs.as_dict())
E       AssertionError: {b'HEAD': b'42d06bd4b77fed026b154d16493e5[369 chars]6a8'} != None

tests/test_refs.py:191: AssertionError
</pre>
</details>
<h3 id="test_refspydictrefscontainerteststest_check_refname">test_refs.py::DictRefsContainerTests::test_check_refname</h3>
<details><summary> <pre>test_refs.py::DictRefsContainerTests::test_check_refname</pre></summary><pre>
self = <tests.test_refs.DictRefsContainerTests testMethod=test_check_refname>

    def test_check_refname(self):
        self._refs._check_refname(b"HEAD")
        self._refs._check_refname(b"refs/stash")
        self._refs._check_refname(b"refs/heads/foo")

>       self.assertRaises(errors.RefFormatError, self._refs._check_refname, b"refs")
E       AssertionError: RefFormatError not raised by _check_refname

tests/test_refs.py:287: AssertionError
</pre>
</details>
<h3 id="test_refspydictrefscontainerteststest_contains">test_refs.py::DictRefsContainerTests::test_contains</h3>
<details><summary> <pre>test_refs.py::DictRefsContainerTests::test_contains</pre></summary><pre>
self = <tests.test_refs.DictRefsContainerTests testMethod=test_contains>

    def test_contains(self):
>       self.assertIn(b"refs/heads/master", self._refs)
E       AssertionError: b'refs/heads/master' not found in <dulwich.refs.DictRefsContainer object at 0x7eec1eae9660>

tests/test_refs.py:293: AssertionError
</pre>
</details>
<h3 id="test_refspydictrefscontainerteststest_delitem">test_refs.py::DictRefsContainerTests::test_delitem</h3>
<details><summary> <pre>test_refs.py::DictRefsContainerTests::test_delitem</pre></summary><pre>
self = <tests.test_refs.DictRefsContainerTests testMethod=test_delitem>

    def test_delitem(self):
        self.assertEqual(
            b"42d06bd4b77fed026b154d16493e5deab78f02ec",
>           self._refs[b"refs/heads/master"],
        )

tests/test_refs.py:299: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.refs.DictRefsContainer object at 0x7eec1f69a500>
name = b'refs/heads/master'

    def __getitem__(self, name):
        """Get the SHA1 for a reference name.

        This method follows all symbolic references.
        """
>       _, sha = self.follow(name)
E       TypeError: cannot unpack non-iterable NoneType object

dulwich/refs.py:181: TypeError
</pre>
</details>
<h3 id="test_refspydictrefscontainerteststest_get_symrefs">test_refs.py::DictRefsContainerTests::test_get_symrefs</h3>
<details><summary> <pre>test_refs.py::DictRefsContainerTests::test_get_symrefs</pre></summary><pre>
self = <tests.test_refs.DictRefsContainerTests testMethod=test_get_symrefs>

    def test_get_symrefs(self):
        self._refs.set_symbolic_ref(b"refs/heads/src", b"refs/heads/dst")
        symrefs = self._refs.get_symrefs()
>       if b"HEAD" in symrefs:
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_refs.py:196: TypeError
</pre>
</details>
<h3 id="test_refspydictrefscontainerteststest_import_refs_name">test_refs.py::DictRefsContainerTests::test_import_refs_name</h3>
<details><summary> <pre>test_refs.py::DictRefsContainerTests::test_import_refs_name</pre></summary><pre>
self = <tests.test_refs.DictRefsContainerTests testMethod=test_import_refs_name>

    def test_import_refs_name(self):
        self._refs[b"refs/remotes/origin/other"] = (
            b"48d01bd4b77fed026b154d16493e5deab78f02ec"
        )
>       self._refs.import_refs(
            b"refs/remotes/origin",
            {b"master": b"42d06bd4b77fed026b154d16493e5deab78f02ec"},
        )
E       AttributeError: 'DictRefsContainer' object has no attribute 'import_refs'

tests/test_refs.py:322: AttributeError
</pre>
</details>
<h3 id="test_refspydictrefscontainerteststest_import_refs_name_prune">test_refs.py::DictRefsContainerTests::test_import_refs_name_prune</h3>
<details><summary> <pre>test_refs.py::DictRefsContainerTests::test_import_refs_name_prune</pre></summary><pre>
self = <tests.test_refs.DictRefsContainerTests testMethod=test_import_refs_name_prune>

    def test_import_refs_name_prune(self):
        self._refs[b"refs/remotes/origin/other"] = (
            b"48d01bd4b77fed026b154d16493e5deab78f02ec"
        )
>       self._refs.import_refs(
            b"refs/remotes/origin",
            {b"master": b"42d06bd4b77fed026b154d16493e5deab78f02ec"},
            prune=True,
        )
E       AttributeError: 'DictRefsContainer' object has no attribute 'import_refs'

tests/test_refs.py:339: AttributeError
</pre>
</details>
<h3 id="test_refspydictrefscontainerteststest_invalid_refname">test_refs.py::DictRefsContainerTests::test_invalid_refname</h3>
<details><summary> <pre>test_refs.py::DictRefsContainerTests::test_invalid_refname</pre></summary><pre>
self = <tests.test_refs.DictRefsContainerTests testMethod=test_invalid_refname>

    def test_invalid_refname(self):
        # FIXME: Move this test into RefsContainerTests, but requires
        # some way of injecting invalid refs.
        self._refs._refs[b"refs/stash"] = b"00" * 20
        expected_refs = dict(_TEST_REFS)
        del expected_refs[b"refs/heads/loop"]
        expected_refs[b"refs/stash"] = b"00" * 20
>       self.assertEqual(expected_refs, self._refs.as_dict())
E       AssertionError: {b'HEAD': b'42d06bd4b77fed026b154d16493e5[429 chars]000'} != None

tests/test_refs.py:363: AssertionError
</pre>
</details>
<h3 id="test_refspydictrefscontainerteststest_iter">test_refs.py::DictRefsContainerTests::test_iter</h3>
<details><summary> <pre>test_refs.py::DictRefsContainerTests::test_iter</pre></summary><pre>
self = <tests.test_refs.DictRefsContainerTests testMethod=test_iter>

    def test_iter(self):
>       actual_keys = set(self._refs.keys())
E       TypeError: 'NoneType' object is not iterable

tests/test_refs.py:183: TypeError
</pre>
</details>
<h3 id="test_refspydictrefscontainerteststest_keys">test_refs.py::DictRefsContainerTests::test_keys</h3>
<details><summary> <pre>test_refs.py::DictRefsContainerTests::test_keys</pre></summary><pre>
self = <tests.test_refs.DictRefsContainerTests testMethod=test_keys>

    def test_keys(self):
>       actual_keys = set(self._refs.keys())
E       TypeError: 'NoneType' object is not iterable

tests/test_refs.py:168: TypeError
</pre>
</details>
<h3 id="test_refspydictrefscontainerteststest_remove_if_equals">test_refs.py::DictRefsContainerTests::test_remove_if_equals</h3>
<details><summary> <pre>test_refs.py::DictRefsContainerTests::test_remove_if_equals</pre></summary><pre>
self = <tests.test_refs.DictRefsContainerTests testMethod=test_remove_if_equals>

    def test_remove_if_equals(self):
        self.assertFalse(self._refs.remove_if_equals(b"HEAD", b"c0ffee"))
        self.assertEqual(
>           b"42d06bd4b77fed026b154d16493e5deab78f02ec", self._refs[b"HEAD"]
        )

tests/test_refs.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.refs.DictRefsContainer object at 0x7eec1ec3dcf0>, name = b'HEAD'

    def __getitem__(self, name):
        """Get the SHA1 for a reference name.

        This method follows all symbolic references.
        """
>       _, sha = self.follow(name)
E       TypeError: cannot unpack non-iterable NoneType object

dulwich/refs.py:181: TypeError
</pre>
</details>
<h3 id="test_refspydictrefscontainerteststest_set_if_equals">test_refs.py::DictRefsContainerTests::test_set_if_equals</h3>
<details><summary> <pre>test_refs.py::DictRefsContainerTests::test_set_if_equals</pre></summary><pre>
self = <tests.test_refs.DictRefsContainerTests testMethod=test_set_if_equals>

    def test_set_if_equals(self):
        nines = b"9" * 40
        self.assertFalse(self._refs.set_if_equals(b"HEAD", b"c0ffee", nines))
        self.assertEqual(
>           b"42d06bd4b77fed026b154d16493e5deab78f02ec", self._refs[b"HEAD"]
        )

tests/test_refs.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.refs.DictRefsContainer object at 0x7eec1eb96da0>, name = b'HEAD'

    def __getitem__(self, name):
        """Get the SHA1 for a reference name.

        This method follows all symbolic references.
        """
>       _, sha = self.follow(name)
E       TypeError: cannot unpack non-iterable NoneType object

dulwich/refs.py:181: TypeError
</pre>
</details>
<h3 id="test_refspydictrefscontainerteststest_set_symbolic_ref">test_refs.py::DictRefsContainerTests::test_set_symbolic_ref</h3>
<details><summary> <pre>test_refs.py::DictRefsContainerTests::test_set_symbolic_ref</pre></summary><pre>
self = <tests.test_refs.DictRefsContainerTests testMethod=test_set_symbolic_ref>

    def test_set_symbolic_ref(self):
        self._refs.set_symbolic_ref(b"refs/heads/symbolic", b"refs/heads/master")
>       self.assertEqual(
            b"ref: refs/heads/master",
            self._refs.read_loose_ref(b"refs/heads/symbolic"),
        )
E       AssertionError: b'ref: refs/heads/master' != None

tests/test_refs.py:258: AssertionError
</pre>
</details>
<h3 id="test_refspydictrefscontainerteststest_set_symbolic_ref_overwrite">test_refs.py::DictRefsContainerTests::test_set_symbolic_ref_overwrite</h3>
<details><summary> <pre>test_refs.py::DictRefsContainerTests::test_set_symbolic_ref_overwrite</pre></summary><pre>
self = <tests.test_refs.DictRefsContainerTests testMethod=test_set_symbolic_ref_overwrite>

    def test_set_symbolic_ref_overwrite(self):
        nines = b"9" * 40
        self.assertNotIn(b"refs/heads/symbolic", self._refs)
        self._refs[b"refs/heads/symbolic"] = nines
>       self.assertEqual(nines, self._refs.read_loose_ref(b"refs/heads/symbolic"))
E       AssertionError: b'9999999999999999999999999999999999999999' != None

tests/test_refs.py:271: AssertionError
</pre>
</details>
<h3 id="test_refspydictrefscontainerteststest_setitem">test_refs.py::DictRefsContainerTests::test_setitem</h3>
<details><summary> <pre>test_refs.py::DictRefsContainerTests::test_setitem</pre></summary><pre>
self = <tests.test_refs.DictRefsContainerTests testMethod=test_setitem>

    def test_setitem(self):
        self._refs[b"refs/some/ref"] = b"42d06bd4b77fed026b154d16493e5deab78f02ec"
        self.assertEqual(
            b"42d06bd4b77fed026b154d16493e5deab78f02ec",
>           self._refs[b"refs/some/ref"],
        )

tests/test_refs.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.refs.DictRefsContainer object at 0x7eec1ef43a00>
name = b'refs/some/ref'

    def __getitem__(self, name):
        """Get the SHA1 for a reference name.

        This method follows all symbolic references.
        """
>       _, sha = self.follow(name)
E       TypeError: cannot unpack non-iterable NoneType object

dulwich/refs.py:181: TypeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_add_if_new">test_refs.py::DiskRefsContainerTests::test_add_if_new</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_add_if_new</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_add_if_new>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_add_if_new_packed">test_refs.py::DiskRefsContainerTests::test_add_if_new_packed</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_add_if_new_packed</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_add_if_new_packed>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_add_if_new_symbolic">test_refs.py::DiskRefsContainerTests::test_add_if_new_symbolic</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_add_if_new_symbolic</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_add_if_new_symbolic>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_add_packed_refs">test_refs.py::DiskRefsContainerTests::test_add_packed_refs</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_add_packed_refs</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_add_packed_refs>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_as_dict">test_refs.py::DiskRefsContainerTests::test_as_dict</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_as_dict</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_as_dict>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_check_refname">test_refs.py::DiskRefsContainerTests::test_check_refname</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_check_refname</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_check_refname>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_contains">test_refs.py::DiskRefsContainerTests::test_contains</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_contains</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_contains>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_cyrillic">test_refs.py::DiskRefsContainerTests::test_cyrillic</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_cyrillic</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_cyrillic>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_delete_refs_container">test_refs.py::DiskRefsContainerTests::test_delete_refs_container</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_delete_refs_container</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_delete_refs_container>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_delitem">test_refs.py::DiskRefsContainerTests::test_delitem</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_delitem</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_delitem>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_delitem_symbolic">test_refs.py::DiskRefsContainerTests::test_delitem_symbolic</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_delitem_symbolic</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_delitem_symbolic>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_follow">test_refs.py::DiskRefsContainerTests::test_follow</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_follow</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_follow>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_get_packed_refs">test_refs.py::DiskRefsContainerTests::test_get_packed_refs</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_get_packed_refs</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_get_packed_refs>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_get_peeled_not_packed">test_refs.py::DiskRefsContainerTests::test_get_peeled_not_packed</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_get_peeled_not_packed</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_get_peeled_not_packed>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_get_symrefs">test_refs.py::DiskRefsContainerTests::test_get_symrefs</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_get_symrefs</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_get_symrefs>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_import_refs_name">test_refs.py::DiskRefsContainerTests::test_import_refs_name</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_import_refs_name</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_import_refs_name>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_import_refs_name_prune">test_refs.py::DiskRefsContainerTests::test_import_refs_name_prune</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_import_refs_name_prune</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_import_refs_name_prune>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_iter">test_refs.py::DiskRefsContainerTests::test_iter</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_iter</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_iter>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_keys">test_refs.py::DiskRefsContainerTests::test_keys</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_keys</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_keys>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_non_ascii">test_refs.py::DiskRefsContainerTests::test_non_ascii</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_non_ascii</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_non_ascii>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_read_loose_ref">test_refs.py::DiskRefsContainerTests::test_read_loose_ref</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_read_loose_ref</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_read_loose_ref>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_read_ref">test_refs.py::DiskRefsContainerTests::test_read_ref</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_read_ref</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_read_ref>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_remove_if_equals">test_refs.py::DiskRefsContainerTests::test_remove_if_equals</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_remove_if_equals</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_remove_if_equals>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_remove_if_equals_packed">test_refs.py::DiskRefsContainerTests::test_remove_if_equals_packed</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_remove_if_equals_packed</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_remove_if_equals_packed>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_remove_if_equals_symref">test_refs.py::DiskRefsContainerTests::test_remove_if_equals_symref</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_remove_if_equals_symref</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_remove_if_equals_symref>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_remove_packed_without_peeled">test_refs.py::DiskRefsContainerTests::test_remove_packed_without_peeled</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_remove_packed_without_peeled</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_remove_packed_without_peeled>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_remove_parent">test_refs.py::DiskRefsContainerTests::test_remove_parent</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_remove_parent</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_remove_parent>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_set_if_equals">test_refs.py::DiskRefsContainerTests::test_set_if_equals</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_set_if_equals</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_set_if_equals>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_set_overwrite_loop">test_refs.py::DiskRefsContainerTests::test_set_overwrite_loop</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_set_overwrite_loop</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_set_overwrite_loop>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_set_symbolic_ref">test_refs.py::DiskRefsContainerTests::test_set_symbolic_ref</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_set_symbolic_ref</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_set_symbolic_ref>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_set_symbolic_ref_overwrite">test_refs.py::DiskRefsContainerTests::test_set_symbolic_ref_overwrite</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_set_symbolic_ref_overwrite</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_set_symbolic_ref_overwrite>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_setitem">test_refs.py::DiskRefsContainerTests::test_setitem</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_setitem</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_setitem>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_setitem_packed">test_refs.py::DiskRefsContainerTests::test_setitem_packed</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_setitem_packed</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_setitem_packed>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspydiskrefscontainerteststest_setitem_symbolic">test_refs.py::DiskRefsContainerTests::test_setitem_symbolic</h3>
<details><summary> <pre>test_refs.py::DiskRefsContainerTests::test_setitem_symbolic</pre></summary><pre>
self = <tests.test_refs.DiskRefsContainerTests testMethod=test_setitem_symbolic>

    def setUp(self):
        TestCase.setUp(self)
        self._repo = open_repo("refs.git")
        self.addCleanup(tear_down_repo, self._repo)
>       self._refs = self._repo.refs
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_refs.py:371: AttributeError
</pre>
</details>
<h3 id="test_refspyinforefscontainerteststest_as_dict">test_refs.py::InfoRefsContainerTests::test_as_dict</h3>
<details><summary> <pre>test_refs.py::InfoRefsContainerTests::test_as_dict</pre></summary><pre>
self = <tests.test_refs.InfoRefsContainerTests testMethod=test_as_dict>

    def test_as_dict(self):
>       refs = InfoRefsContainer(BytesIO(_TEST_REFS_SERIALIZED))

tests/test_refs.py:769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.refs.InfoRefsContainer object at 0x7eec1eb40c10>
f = <_io.BytesIO object at 0x7eec1f828130>

    def __init__(self, f) -> None:
        self._refs = {}
        self._peeled = {}
        for line in f.readlines():
            sha, name = line.rstrip(b'\n').split(b'\t')
            if name.endswith(PEELED_TAG_SUFFIX):
                name = name[:-3]
                if not check_ref_format(name):
                    raise ValueError(f'invalid ref name {name!r}')
                self._peeled[name] = sha
            else:
                if not check_ref_format(name):
>                   raise ValueError(f'invalid ref name {name!r}')
E                   ValueError: invalid ref name b'refs/heads/40-char-ref-aaaaaaaaaaaaaaaaaa'

dulwich/refs.py:302: ValueError
</pre>
</details>
<h3 id="test_refspyinforefscontainerteststest_contains">test_refs.py::InfoRefsContainerTests::test_contains</h3>
<details><summary> <pre>test_refs.py::InfoRefsContainerTests::test_contains</pre></summary><pre>
self = <tests.test_refs.InfoRefsContainerTests testMethod=test_contains>

    def test_contains(self):
>       refs = InfoRefsContainer(BytesIO(_TEST_REFS_SERIALIZED))

tests/test_refs.py:777: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.refs.InfoRefsContainer object at 0x7eec1f79f310>
f = <_io.BytesIO object at 0x7eec1e9efba0>

    def __init__(self, f) -> None:
        self._refs = {}
        self._peeled = {}
        for line in f.readlines():
            sha, name = line.rstrip(b'\n').split(b'\t')
            if name.endswith(PEELED_TAG_SUFFIX):
                name = name[:-3]
                if not check_ref_format(name):
                    raise ValueError(f'invalid ref name {name!r}')
                self._peeled[name] = sha
            else:
                if not check_ref_format(name):
>                   raise ValueError(f'invalid ref name {name!r}')
E                   ValueError: invalid ref name b'refs/heads/40-char-ref-aaaaaaaaaaaaaaaaaa'

dulwich/refs.py:302: ValueError
</pre>
</details>
<h3 id="test_refspyinforefscontainerteststest_get_peeled">test_refs.py::InfoRefsContainerTests::test_get_peeled</h3>
<details><summary> <pre>test_refs.py::InfoRefsContainerTests::test_get_peeled</pre></summary><pre>
self = <tests.test_refs.InfoRefsContainerTests testMethod=test_get_peeled>

    def test_get_peeled(self):
>       refs = InfoRefsContainer(BytesIO(_TEST_REFS_SERIALIZED))

tests/test_refs.py:782: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.refs.InfoRefsContainer object at 0x7eec1ebbe680>
f = <_io.BytesIO object at 0x7eec1eae30b0>

    def __init__(self, f) -> None:
        self._refs = {}
        self._peeled = {}
        for line in f.readlines():
            sha, name = line.rstrip(b'\n').split(b'\t')
            if name.endswith(PEELED_TAG_SUFFIX):
                name = name[:-3]
                if not check_ref_format(name):
                    raise ValueError(f'invalid ref name {name!r}')
                self._peeled[name] = sha
            else:
                if not check_ref_format(name):
>                   raise ValueError(f'invalid ref name {name!r}')
E                   ValueError: invalid ref name b'refs/heads/40-char-ref-aaaaaaaaaaaaaaaaaa'

dulwich/refs.py:302: ValueError
</pre>
</details>
<h3 id="test_refspyinforefscontainerteststest_invalid_refname">test_refs.py::InfoRefsContainerTests::test_invalid_refname</h3>
<details><summary> <pre>test_refs.py::InfoRefsContainerTests::test_invalid_refname</pre></summary><pre>
self = <tests.test_refs.InfoRefsContainerTests testMethod=test_invalid_refname>

    def test_invalid_refname(self):
        text = _TEST_REFS_SERIALIZED + b"00" * 20 + b"\trefs/stash\n"
>       refs = InfoRefsContainer(BytesIO(text))

tests/test_refs.py:744: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.refs.InfoRefsContainer object at 0x7eec1fae9c60>
f = <_io.BytesIO object at 0x7eec1e9ec8b0>

    def __init__(self, f) -> None:
        self._refs = {}
        self._peeled = {}
        for line in f.readlines():
            sha, name = line.rstrip(b'\n').split(b'\t')
            if name.endswith(PEELED_TAG_SUFFIX):
                name = name[:-3]
                if not check_ref_format(name):
                    raise ValueError(f'invalid ref name {name!r}')
                self._peeled[name] = sha
            else:
                if not check_ref_format(name):
>                   raise ValueError(f'invalid ref name {name!r}')
E                   ValueError: invalid ref name b'refs/heads/40-char-ref-aaaaaaaaaaaaaaaaaa'

dulwich/refs.py:302: ValueError
</pre>
</details>
<h3 id="test_refspyinforefscontainerteststest_keys">test_refs.py::InfoRefsContainerTests::test_keys</h3>
<details><summary> <pre>test_refs.py::InfoRefsContainerTests::test_keys</pre></summary><pre>
self = <tests.test_refs.InfoRefsContainerTests testMethod=test_keys>

    def test_keys(self):
>       refs = InfoRefsContainer(BytesIO(_TEST_REFS_SERIALIZED))

tests/test_refs.py:752: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.refs.InfoRefsContainer object at 0x7eec1efd0610>
f = <_io.BytesIO object at 0x7eec1eae3f10>

    def __init__(self, f) -> None:
        self._refs = {}
        self._peeled = {}
        for line in f.readlines():
            sha, name = line.rstrip(b'\n').split(b'\t')
            if name.endswith(PEELED_TAG_SUFFIX):
                name = name[:-3]
                if not check_ref_format(name):
                    raise ValueError(f'invalid ref name {name!r}')
                self._peeled[name] = sha
            else:
                if not check_ref_format(name):
>                   raise ValueError(f'invalid ref name {name!r}')
E                   ValueError: invalid ref name b'refs/heads/40-char-ref-aaaaaaaaaaaaaaaaaa'

dulwich/refs.py:302: ValueError
</pre>
</details>
<h3 id="test_refspyparsesymrefvalueteststest_invalid">test_refs.py::ParseSymrefValueTests::test_invalid</h3>
<details><summary> <pre>test_refs.py::ParseSymrefValueTests::test_invalid</pre></summary><pre>
self = <tests.test_refs.ParseSymrefValueTests testMethod=test_invalid>

    def test_invalid(self):
>       self.assertRaises(ValueError, parse_symref_value, b"foobar")
E       AssertionError: ValueError not raised by parse_symref_value

tests/test_refs.py:795: AssertionError
</pre>
</details>
<h3 id="test_refspyparsesymrefvalueteststest_valid">test_refs.py::ParseSymrefValueTests::test_valid</h3>
<details><summary> <pre>test_refs.py::ParseSymrefValueTests::test_valid</pre></summary><pre>
self = <tests.test_refs.ParseSymrefValueTests testMethod=test_valid>

    def test_valid(self):
>       self.assertEqual(b"refs/heads/foo", parse_symref_value(b"ref: refs/heads/foo"))
E       AssertionError: b'refs/heads/foo' != None

tests/test_refs.py:792: AssertionError
</pre>
</details>
<h3 id="test_serverpyhandlertestcasetest_capability_line">test_server.py::HandlerTestCase::test_capability_line</h3>
<details><summary> <pre>test_server.py::HandlerTestCase::test_capability_line</pre></summary><pre>
self = <tests.test_server.HandlerTestCase testMethod=test_capability_line>

    def test_capability_line(self):
>       self.assertEqual(
            b" cap1 cap2 cap3",
            format_capability_line([b"cap1", b"cap2", b"cap3"]),
        )
E       AssertionError: b' cap1 cap2 cap3' != [b'cap1', b'cap2', b'cap3']

tests/test_server.py:123: AssertionError
</pre>
</details>
<h3 id="test_serverpyhandlertestcasetest_has_capability">test_server.py::HandlerTestCase::test_has_capability</h3>
<details><summary> <pre>test_server.py::HandlerTestCase::test_has_capability</pre></summary><pre>
self = <tests.test_server.HandlerTestCase testMethod=test_has_capability>

    def test_has_capability(self):
>       self.assertRaises(GitProtocolError, self._handler.has_capability, b"cap")
E       AttributeError: 'TestGenericPackHandler' object has no attribute 'has_capability'

tests/test_server.py:147: AttributeError
</pre>
</details>
<h3 id="test_serverpyhandlertestcasetest_set_client_capabilities">test_server.py::HandlerTestCase::test_set_client_capabilities</h3>
<details><summary> <pre>test_server.py::HandlerTestCase::test_set_client_capabilities</pre></summary><pre>
self = <tests.test_server.HandlerTestCase testMethod=test_set_client_capabilities>

    def test_set_client_capabilities(self):
>       set_caps = self._handler.set_client_capabilities
E       AttributeError: 'TestGenericPackHandler' object has no attribute 'set_client_capabilities'. Did you mean: '_client_capabilities'?

tests/test_server.py:129: AttributeError
</pre>
</details>
<h3 id="test_serverpyuploadpackhandlertestcasetest_get_tagged">test_server.py::UploadPackHandlerTestCase::test_get_tagged</h3>
<details><summary> <pre>test_server.py::UploadPackHandlerTestCase::test_get_tagged</pre></summary><pre>
self = <tests.test_server.UploadPackHandlerTestCase testMethod=test_get_tagged>

    def test_get_tagged(self):
        refs = {
            b"refs/tags/tag1": ONE,
            b"refs/tags/tag2": TWO,
            b"refs/heads/master": FOUR,  # not a tag, no peeled value
        }
        # repo needs to peel this object
>       self._repo.object_store.add_object(make_commit(id=FOUR))
E       AttributeError: 'NoneType' object has no attribute 'object_store'

tests/test_server.py:191: AttributeError
</pre>
</details>
<h3 id="test_serverpyuploadpackhandlertestcasetest_no_progress">test_server.py::UploadPackHandlerTestCase::test_no_progress</h3>
<details><summary> <pre>test_server.py::UploadPackHandlerTestCase::test_no_progress</pre></summary><pre>
self = <tests.test_server.UploadPackHandlerTestCase testMethod=test_no_progress>

    def test_no_progress(self):
>       caps = [*list(self._handler.required_capabilities()), b"no-progress"]
E       TypeError: 'NoneType' object is not iterable

tests/test_server.py:178: TypeError
</pre>
</details>
<h3 id="test_serverpyuploadpackhandlertestcasetest_nothing_to_do_but_wants">test_server.py::UploadPackHandlerTestCase::test_nothing_to_do_but_wants</h3>
<details><summary> <pre>test_server.py::UploadPackHandlerTestCase::test_nothing_to_do_but_wants</pre></summary><pre>
self = <tests.test_server.UploadPackHandlerTestCase testMethod=test_nothing_to_do_but_wants>

    def test_nothing_to_do_but_wants(self):
        # Just the fact that the client claims to want an object is enough
        # for sending a pack. Even if there turns out to be nothing.
        refs = {b"refs/tags/tag1": ONE}
        tree = Tree()
>       self._repo.object_store.add_object(tree)
E       AttributeError: 'NoneType' object has no attribute 'object_store'

tests/test_server.py:218: AttributeError
</pre>
</details>
<h3 id="test_serverpyuploadpackhandlertestcasetest_nothing_to_do_no_wants">test_server.py::UploadPackHandlerTestCase::test_nothing_to_do_no_wants</h3>
<details><summary> <pre>test_server.py::UploadPackHandlerTestCase::test_nothing_to_do_no_wants</pre></summary><pre>
self = <tests.test_server.UploadPackHandlerTestCase testMethod=test_nothing_to_do_no_wants>

    def test_nothing_to_do_no_wants(self):
        # Don't send a pack if the client didn't ask for anything.
        refs = {b"refs/tags/tag1": ONE}
        tree = Tree()
>       self._repo.object_store.add_object(tree)
E       AttributeError: 'NoneType' object has no attribute 'object_store'

tests/test_server.py:239: AttributeError
</pre>
</details>
<h3 id="test_serverpyuploadpackhandlertestcasetest_progress">test_server.py::UploadPackHandlerTestCase::test_progress</h3>
<details><summary> <pre>test_server.py::UploadPackHandlerTestCase::test_progress</pre></summary><pre>
self = <tests.test_server.UploadPackHandlerTestCase testMethod=test_progress>

    def test_progress(self):
        caps = self._handler.required_capabilities()
>       self._handler.set_client_capabilities(caps)
E       AttributeError: 'UploadPackHandler' object has no attribute 'set_client_capabilities'. Did you mean: '_client_capabilities'?

tests/test_server.py:169: AttributeError
</pre>
</details>
<h3 id="test_serverpyfindshallowteststest_linear">test_server.py::FindShallowTests::test_linear</h3>
<details><summary> <pre>test_server.py::FindShallowTests::test_linear</pre></summary><pre>
self = <tests.test_server.FindShallowTests testMethod=test_linear>

    def test_linear(self):
>       c1, c2, c3 = self.make_linear_commits(3)

tests/test_server.py:272: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.FindShallowTests testMethod=test_linear>, n = 3
message = b''

    def make_linear_commits(self, n, message=b""):
        commits = []
        parents = []
        for _ in range(n):
            commits.append(self.make_commit(parents=parents, message=message))
>           parents = [commits[-1].id]
E           AttributeError: 'NoneType' object has no attribute 'id'

tests/test_server.py:265: AttributeError
</pre>
</details>
<h3 id="test_serverpyfindshallowteststest_merge">test_server.py::FindShallowTests::test_merge</h3>
<details><summary> <pre>test_server.py::FindShallowTests::test_merge</pre></summary><pre>
self = <tests.test_server.FindShallowTests testMethod=test_merge>

    def test_merge(self):
        c1 = self.make_commit()
        c2 = self.make_commit()
>       c3 = self.make_commit(parents=[c1.id, c2.id])
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_server.py:317: AttributeError
</pre>
</details>
<h3 id="test_serverpyfindshallowteststest_multiple_independent">test_server.py::FindShallowTests::test_multiple_independent</h3>
<details><summary> <pre>test_server.py::FindShallowTests::test_multiple_independent</pre></summary><pre>
self = <tests.test_server.FindShallowTests testMethod=test_multiple_independent>

    def test_multiple_independent(self):
>       a = self.make_linear_commits(2, message=b"a")

tests/test_server.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.FindShallowTests testMethod=test_multiple_independent>
n = 2, message = b'a'

    def make_linear_commits(self, n, message=b""):
        commits = []
        parents = []
        for _ in range(n):
            commits.append(self.make_commit(parents=parents, message=message))
>           parents = [commits[-1].id]
E           AttributeError: 'NoneType' object has no attribute 'id'

tests/test_server.py:265: AttributeError
</pre>
</details>
<h3 id="test_serverpyfindshallowteststest_multiple_overlapping">test_server.py::FindShallowTests::test_multiple_overlapping</h3>
<details><summary> <pre>test_server.py::FindShallowTests::test_multiple_overlapping</pre></summary><pre>
self = <tests.test_server.FindShallowTests testMethod=test_multiple_overlapping>

    def test_multiple_overlapping(self):
        # Create the following commit tree:
        # 1--2
        #  \
        #   3--4
>       c1, c2 = self.make_linear_commits(2)

tests/test_server.py:304: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.FindShallowTests testMethod=test_multiple_overlapping>
n = 2, message = b''

    def make_linear_commits(self, n, message=b""):
        commits = []
        parents = []
        for _ in range(n):
            commits.append(self.make_commit(parents=parents, message=message))
>           parents = [commits[-1].id]
E           AttributeError: 'NoneType' object has no attribute 'id'

tests/test_server.py:265: AttributeError
</pre>
</details>
<h3 id="test_serverpyfindshallowteststest_tag">test_server.py::FindShallowTests::test_tag</h3>
<details><summary> <pre>test_server.py::FindShallowTests::test_tag</pre></summary><pre>
self = <tests.test_server.FindShallowTests testMethod=test_tag>

    def test_tag(self):
>       c1, c2 = self.make_linear_commits(2)

tests/test_server.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.FindShallowTests testMethod=test_tag>, n = 2
message = b''

    def make_linear_commits(self, n, message=b""):
        commits = []
        parents = []
        for _ in range(n):
            commits.append(self.make_commit(parents=parents, message=message))
>           parents = [commits[-1].id]
E           AttributeError: 'NoneType' object has no attribute 'id'

tests/test_server.py:265: AttributeError
</pre>
</details>
<h3 id="test_serverpyreceivepackhandlertestcasetest_apply_pack_del_ref">test_server.py::ReceivePackHandlerTestCase::test_apply_pack_del_ref</h3>
<details><summary> <pre>test_server.py::ReceivePackHandlerTestCase::test_apply_pack_del_ref</pre></summary><pre>
self = <tests.test_server.ReceivePackHandlerTestCase testMethod=test_apply_pack_del_ref>

    def test_apply_pack_del_ref(self):
        refs = {b"refs/heads/master": TWO, b"refs/heads/fake-branch": ONE}
>       self._repo.refs._update(refs)
E       AttributeError: 'NoneType' object has no attribute 'refs'

tests/test_server.py:352: AttributeError
</pre>
</details>
<h3 id="test_serverpyprotocolgraphwalkeremptytestcasetest_empty_repository">test_server.py::ProtocolGraphWalkerEmptyTestCase::test_empty_repository</h3>
<details><summary> <pre>test_server.py::ProtocolGraphWalkerEmptyTestCase::test_empty_repository</pre></summary><pre>
self = <tests.test_server.ProtocolGraphWalkerEmptyTestCase testMethod=test_empty_repository>

    def setUp(self):
        super().setUp()
        self._repo = MemoryRepo.init_bare([], {})
        backend = DictBackend({b"/": self._repo})
        self._walker = _ProtocolGraphWalker(
            TestUploadPackHandler(backend, [b"/", b"host=lolcats"], TestProto()),
>           self._repo.object_store,
            self._repo.get_peeled,
            self._repo.refs.get_symrefs,
        )
E       AttributeError: 'NoneType' object has no attribute 'object_store'

tests/test_server.py:371: AttributeError
</pre>
</details>
<h3 id="test_serverpyprotocolgraphwalkertestcasetest_all_wants_satisfied">test_server.py::ProtocolGraphWalkerTestCase::test_all_wants_satisfied</h3>
<details><summary> <pre>test_server.py::ProtocolGraphWalkerTestCase::test_all_wants_satisfied</pre></summary><pre>
self = <tests.test_server.ProtocolGraphWalkerTestCase testMethod=test_all_wants_satisfied>

    def setUp(self):
        super().setUp()
        # Create the following commit tree:
        #   3---5
        #  /
        # 1---2---4
        commits = [
            make_commit(id=ONE, parents=[], commit_time=111),
            make_commit(id=TWO, parents=[ONE], commit_time=222),
            make_commit(id=THREE, parents=[ONE], commit_time=333),
            make_commit(id=FOUR, parents=[TWO], commit_time=444),
            make_commit(id=FIVE, parents=[THREE], commit_time=555),
        ]
        self._repo = MemoryRepo.init_bare(commits, {})
        backend = DictBackend({b"/": self._repo})
        self._walker = _ProtocolGraphWalker(
            TestUploadPackHandler(backend, [b"/", b"host=lolcats"], TestProto()),
>           self._repo.object_store,
            self._repo.get_peeled,
            self._repo.refs.get_symrefs,
        )
E       AttributeError: 'NoneType' object has no attribute 'object_store'

tests/test_server.py:405: AttributeError
</pre>
</details>
<h3 id="test_serverpyprotocolgraphwalkertestcasetest_all_wants_satisfied_have_branch">test_server.py::ProtocolGraphWalkerTestCase::test_all_wants_satisfied_have_branch</h3>
<details><summary> <pre>test_server.py::ProtocolGraphWalkerTestCase::test_all_wants_satisfied_have_branch</pre></summary><pre>
self = <tests.test_server.ProtocolGraphWalkerTestCase testMethod=test_all_wants_satisfied_have_branch>

    def setUp(self):
        super().setUp()
        # Create the following commit tree:
        #   3---5
        #  /
        # 1---2---4
        commits = [
            make_commit(id=ONE, parents=[], commit_time=111),
            make_commit(id=TWO, parents=[ONE], commit_time=222),
            make_commit(id=THREE, parents=[ONE], commit_time=333),
            make_commit(id=FOUR, parents=[TWO], commit_time=444),
            make_commit(id=FIVE, parents=[THREE], commit_time=555),
        ]
        self._repo = MemoryRepo.init_bare(commits, {})
        backend = DictBackend({b"/": self._repo})
        self._walker = _ProtocolGraphWalker(
            TestUploadPackHandler(backend, [b"/", b"host=lolcats"], TestProto()),
>           self._repo.object_store,
            self._repo.get_peeled,
            self._repo.refs.get_symrefs,
        )
E       AttributeError: 'NoneType' object has no attribute 'object_store'

tests/test_server.py:405: AttributeError
</pre>
</details>
<h3 id="test_serverpyprotocolgraphwalkertestcasetest_all_wants_satisfied_have_root">test_server.py::ProtocolGraphWalkerTestCase::test_all_wants_satisfied_have_root</h3>
<details><summary> <pre>test_server.py::ProtocolGraphWalkerTestCase::test_all_wants_satisfied_have_root</pre></summary><pre>
self = <tests.test_server.ProtocolGraphWalkerTestCase testMethod=test_all_wants_satisfied_have_root>

    def setUp(self):
        super().setUp()
        # Create the following commit tree:
        #   3---5
        #  /
        # 1---2---4
        commits = [
            make_commit(id=ONE, parents=[], commit_time=111),
            make_commit(id=TWO, parents=[ONE], commit_time=222),
            make_commit(id=THREE, parents=[ONE], commit_time=333),
            make_commit(id=FOUR, parents=[TWO], commit_time=444),
            make_commit(id=FIVE, parents=[THREE], commit_time=555),
        ]
        self._repo = MemoryRepo.init_bare(commits, {})
        backend = DictBackend({b"/": self._repo})
        self._walker = _ProtocolGraphWalker(
            TestUploadPackHandler(backend, [b"/", b"host=lolcats"], TestProto()),
>           self._repo.object_store,
            self._repo.get_peeled,
            self._repo.refs.get_symrefs,
        )
E       AttributeError: 'NoneType' object has no attribute 'object_store'

tests/test_server.py:405: AttributeError
</pre>
</details>
<h3 id="test_serverpyprotocolgraphwalkertestcasetest_all_wants_satisfied_no_haves">test_server.py::ProtocolGraphWalkerTestCase::test_all_wants_satisfied_no_haves</h3>
<details><summary> <pre>test_server.py::ProtocolGraphWalkerTestCase::test_all_wants_satisfied_no_haves</pre></summary><pre>
self = <tests.test_server.ProtocolGraphWalkerTestCase testMethod=test_all_wants_satisfied_no_haves>

    def setUp(self):
        super().setUp()
        # Create the following commit tree:
        #   3---5
        #  /
        # 1---2---4
        commits = [
            make_commit(id=ONE, parents=[], commit_time=111),
            make_commit(id=TWO, parents=[ONE], commit_time=222),
            make_commit(id=THREE, parents=[ONE], commit_time=333),
            make_commit(id=FOUR, parents=[TWO], commit_time=444),
            make_commit(id=FIVE, parents=[THREE], commit_time=555),
        ]
        self._repo = MemoryRepo.init_bare(commits, {})
        backend = DictBackend({b"/": self._repo})
        self._walker = _ProtocolGraphWalker(
            TestUploadPackHandler(backend, [b"/", b"host=lolcats"], TestProto()),
>           self._repo.object_store,
            self._repo.get_peeled,
            self._repo.refs.get_symrefs,
        )
E       AttributeError: 'NoneType' object has no attribute 'object_store'

tests/test_server.py:405: AttributeError
</pre>
</details>
<h3 id="test_serverpyprotocolgraphwalkertestcasetest_determine_wants">test_server.py::ProtocolGraphWalkerTestCase::test_determine_wants</h3>
<details><summary> <pre>test_server.py::ProtocolGraphWalkerTestCase::test_determine_wants</pre></summary><pre>
self = <tests.test_server.ProtocolGraphWalkerTestCase testMethod=test_determine_wants>

    def setUp(self):
        super().setUp()
        # Create the following commit tree:
        #   3---5
        #  /
        # 1---2---4
        commits = [
            make_commit(id=ONE, parents=[], commit_time=111),
            make_commit(id=TWO, parents=[ONE], commit_time=222),
            make_commit(id=THREE, parents=[ONE], commit_time=333),
            make_commit(id=FOUR, parents=[TWO], commit_time=444),
            make_commit(id=FIVE, parents=[THREE], commit_time=555),
        ]
        self._repo = MemoryRepo.init_bare(commits, {})
        backend = DictBackend({b"/": self._repo})
        self._walker = _ProtocolGraphWalker(
            TestUploadPackHandler(backend, [b"/", b"host=lolcats"], TestProto()),
>           self._repo.object_store,
            self._repo.get_peeled,
            self._repo.refs.get_symrefs,
        )
E       AttributeError: 'NoneType' object has no attribute 'object_store'

tests/test_server.py:405: AttributeError
</pre>
</details>
<h3 id="test_serverpyprotocolgraphwalkertestcasetest_determine_wants_advertisement">test_server.py::ProtocolGraphWalkerTestCase::test_determine_wants_advertisement</h3>
<details><summary> <pre>test_server.py::ProtocolGraphWalkerTestCase::test_determine_wants_advertisement</pre></summary><pre>
self = <tests.test_server.ProtocolGraphWalkerTestCase testMethod=test_determine_wants_advertisement>

    def setUp(self):
        super().setUp()
        # Create the following commit tree:
        #   3---5
        #  /
        # 1---2---4
        commits = [
            make_commit(id=ONE, parents=[], commit_time=111),
            make_commit(id=TWO, parents=[ONE], commit_time=222),
            make_commit(id=THREE, parents=[ONE], commit_time=333),
            make_commit(id=FOUR, parents=[TWO], commit_time=444),
            make_commit(id=FIVE, parents=[THREE], commit_time=555),
        ]
        self._repo = MemoryRepo.init_bare(commits, {})
        backend = DictBackend({b"/": self._repo})
        self._walker = _ProtocolGraphWalker(
            TestUploadPackHandler(backend, [b"/", b"host=lolcats"], TestProto()),
>           self._repo.object_store,
            self._repo.get_peeled,
            self._repo.refs.get_symrefs,
        )
E       AttributeError: 'NoneType' object has no attribute 'object_store'

tests/test_server.py:405: AttributeError
</pre>
</details>
<h3 id="test_serverpyprotocolgraphwalkertestcasetest_handle_shallow_request_no_client_shallows">test_server.py::ProtocolGraphWalkerTestCase::test_handle_shallow_request_no_client_shallows</h3>
<details><summary> <pre>test_server.py::ProtocolGraphWalkerTestCase::test_handle_shallow_request_no_client_shallows</pre></summary><pre>
self = <tests.test_server.ProtocolGraphWalkerTestCase testMethod=test_handle_shallow_request_no_client_shallows>

    def setUp(self):
        super().setUp()
        # Create the following commit tree:
        #   3---5
        #  /
        # 1---2---4
        commits = [
            make_commit(id=ONE, parents=[], commit_time=111),
            make_commit(id=TWO, parents=[ONE], commit_time=222),
            make_commit(id=THREE, parents=[ONE], commit_time=333),
            make_commit(id=FOUR, parents=[TWO], commit_time=444),
            make_commit(id=FIVE, parents=[THREE], commit_time=555),
        ]
        self._repo = MemoryRepo.init_bare(commits, {})
        backend = DictBackend({b"/": self._repo})
        self._walker = _ProtocolGraphWalker(
            TestUploadPackHandler(backend, [b"/", b"host=lolcats"], TestProto()),
>           self._repo.object_store,
            self._repo.get_peeled,
            self._repo.refs.get_symrefs,
        )
E       AttributeError: 'NoneType' object has no attribute 'object_store'

tests/test_server.py:405: AttributeError
</pre>
</details>
<h3 id="test_serverpyprotocolgraphwalkertestcasetest_handle_shallow_request_no_new_shallows">test_server.py::ProtocolGraphWalkerTestCase::test_handle_shallow_request_no_new_shallows</h3>
<details><summary> <pre>test_server.py::ProtocolGraphWalkerTestCase::test_handle_shallow_request_no_new_shallows</pre></summary><pre>
self = <tests.test_server.ProtocolGraphWalkerTestCase testMethod=test_handle_shallow_request_no_new_shallows>

    def setUp(self):
        super().setUp()
        # Create the following commit tree:
        #   3---5
        #  /
        # 1---2---4
        commits = [
            make_commit(id=ONE, parents=[], commit_time=111),
            make_commit(id=TWO, parents=[ONE], commit_time=222),
            make_commit(id=THREE, parents=[ONE], commit_time=333),
            make_commit(id=FOUR, parents=[TWO], commit_time=444),
            make_commit(id=FIVE, parents=[THREE], commit_time=555),
        ]
        self._repo = MemoryRepo.init_bare(commits, {})
        backend = DictBackend({b"/": self._repo})
        self._walker = _ProtocolGraphWalker(
            TestUploadPackHandler(backend, [b"/", b"host=lolcats"], TestProto()),
>           self._repo.object_store,
            self._repo.get_peeled,
            self._repo.refs.get_symrefs,
        )
E       AttributeError: 'NoneType' object has no attribute 'object_store'

tests/test_server.py:405: AttributeError
</pre>
</details>
<h3 id="test_serverpyprotocolgraphwalkertestcasetest_handle_shallow_request_unshallows">test_server.py::ProtocolGraphWalkerTestCase::test_handle_shallow_request_unshallows</h3>
<details><summary> <pre>test_server.py::ProtocolGraphWalkerTestCase::test_handle_shallow_request_unshallows</pre></summary><pre>
self = <tests.test_server.ProtocolGraphWalkerTestCase testMethod=test_handle_shallow_request_unshallows>

    def setUp(self):
        super().setUp()
        # Create the following commit tree:
        #   3---5
        #  /
        # 1---2---4
        commits = [
            make_commit(id=ONE, parents=[], commit_time=111),
            make_commit(id=TWO, parents=[ONE], commit_time=222),
            make_commit(id=THREE, parents=[ONE], commit_time=333),
            make_commit(id=FOUR, parents=[TWO], commit_time=444),
            make_commit(id=FIVE, parents=[THREE], commit_time=555),
        ]
        self._repo = MemoryRepo.init_bare(commits, {})
        backend = DictBackend({b"/": self._repo})
        self._walker = _ProtocolGraphWalker(
            TestUploadPackHandler(backend, [b"/", b"host=lolcats"], TestProto()),
>           self._repo.object_store,
            self._repo.get_peeled,
            self._repo.refs.get_symrefs,
        )
E       AttributeError: 'NoneType' object has no attribute 'object_store'

tests/test_server.py:405: AttributeError
</pre>
</details>
<h3 id="test_serverpyprotocolgraphwalkertestcasetest_split_proto_line">test_server.py::ProtocolGraphWalkerTestCase::test_split_proto_line</h3>
<details><summary> <pre>test_server.py::ProtocolGraphWalkerTestCase::test_split_proto_line</pre></summary><pre>
self = <tests.test_server.ProtocolGraphWalkerTestCase testMethod=test_split_proto_line>

    def setUp(self):
        super().setUp()
        # Create the following commit tree:
        #   3---5
        #  /
        # 1---2---4
        commits = [
            make_commit(id=ONE, parents=[], commit_time=111),
            make_commit(id=TWO, parents=[ONE], commit_time=222),
            make_commit(id=THREE, parents=[ONE], commit_time=333),
            make_commit(id=FOUR, parents=[TWO], commit_time=444),
            make_commit(id=FIVE, parents=[THREE], commit_time=555),
        ]
        self._repo = MemoryRepo.init_bare(commits, {})
        backend = DictBackend({b"/": self._repo})
        self._walker = _ProtocolGraphWalker(
            TestUploadPackHandler(backend, [b"/", b"host=lolcats"], TestProto()),
>           self._repo.object_store,
            self._repo.get_peeled,
            self._repo.refs.get_symrefs,
        )
E       AttributeError: 'NoneType' object has no attribute 'object_store'

tests/test_server.py:405: AttributeError
</pre>
</details>
<h3 id="test_serverpysingleackgraphwalkerimpltestcasetest_single_ack">test_server.py::SingleAckGraphWalkerImplTestCase::test_single_ack</h3>
<details><summary> <pre>test_server.py::SingleAckGraphWalkerImplTestCase::test_single_ack</pre></summary><pre>
self = <tests.test_server.SingleAckGraphWalkerImplTestCase testMethod=test_single_ack>

    def test_single_ack(self):
>       self.assertNextEquals(TWO)

tests/test_server.py:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.SingleAckGraphWalkerImplTestCase testMethod=test_single_ack>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpysingleackgraphwalkerimpltestcasetest_single_ack_flush">test_server.py::SingleAckGraphWalkerImplTestCase::test_single_ack_flush</h3>
<details><summary> <pre>test_server.py::SingleAckGraphWalkerImplTestCase::test_single_ack_flush</pre></summary><pre>
self = <tests.test_server.SingleAckGraphWalkerImplTestCase testMethod=test_single_ack_flush>

    def test_single_ack_flush(self):
        # same as ack test but ends with a flush-pkt instead of done
        self._walker.lines[-1] = (None, None)

>       self.assertNextEquals(TWO)

tests/test_server.py:698: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.SingleAckGraphWalkerImplTestCase testMethod=test_single_ack_flush>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpysingleackgraphwalkerimpltestcasetest_single_ack_nak">test_server.py::SingleAckGraphWalkerImplTestCase::test_single_ack_nak</h3>
<details><summary> <pre>test_server.py::SingleAckGraphWalkerImplTestCase::test_single_ack_nak</pre></summary><pre>
self = <tests.test_server.SingleAckGraphWalkerImplTestCase testMethod=test_single_ack_nak>

    def test_single_ack_nak(self):
>       self.assertNextEquals(TWO)

tests/test_server.py:712: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.SingleAckGraphWalkerImplTestCase testMethod=test_single_ack_nak>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpysingleackgraphwalkerimpltestcasetest_single_ack_nak_flush">test_server.py::SingleAckGraphWalkerImplTestCase::test_single_ack_nak_flush</h3>
<details><summary> <pre>test_server.py::SingleAckGraphWalkerImplTestCase::test_single_ack_nak_flush</pre></summary><pre>
self = <tests.test_server.SingleAckGraphWalkerImplTestCase testMethod=test_single_ack_nak_flush>

    def test_single_ack_nak_flush(self):
        # same as nak test but ends with a flush-pkt instead of done
        self._walker.lines[-1] = (None, None)

>       self.assertNextEquals(TWO)

tests/test_server.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.SingleAckGraphWalkerImplTestCase testMethod=test_single_ack_nak_flush>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpymultiackgraphwalkerimpltestcasetest_multi_ack">test_server.py::MultiAckGraphWalkerImplTestCase::test_multi_ack</h3>
<details><summary> <pre>test_server.py::MultiAckGraphWalkerImplTestCase::test_multi_ack</pre></summary><pre>
self = <tests.test_server.MultiAckGraphWalkerImplTestCase testMethod=test_multi_ack>

    def test_multi_ack(self):
>       self.assertNextEquals(TWO)

tests/test_server.py:747: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.MultiAckGraphWalkerImplTestCase testMethod=test_multi_ack>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpymultiackgraphwalkerimpltestcasetest_multi_ack_flush">test_server.py::MultiAckGraphWalkerImplTestCase::test_multi_ack_flush</h3>
<details><summary> <pre>test_server.py::MultiAckGraphWalkerImplTestCase::test_multi_ack_flush</pre></summary><pre>
self = <tests.test_server.MultiAckGraphWalkerImplTestCase testMethod=test_multi_ack_flush>

    def test_multi_ack_flush(self):
        self._walker.lines = [
            (b"have", TWO),
            (None, None),
            (b"have", ONE),
            (b"have", THREE),
            (b"done", None),
        ]
>       self.assertNextEquals(TWO)

tests/test_server.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.MultiAckGraphWalkerImplTestCase testMethod=test_multi_ack_flush>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpymultiackgraphwalkerimpltestcasetest_multi_ack_nak">test_server.py::MultiAckGraphWalkerImplTestCase::test_multi_ack_nak</h3>
<details><summary> <pre>test_server.py::MultiAckGraphWalkerImplTestCase::test_multi_ack_nak</pre></summary><pre>
self = <tests.test_server.MultiAckGraphWalkerImplTestCase testMethod=test_multi_ack_nak>

    def test_multi_ack_nak(self):
>       self.assertNextEquals(TWO)

tests/test_server.py:803: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.MultiAckGraphWalkerImplTestCase testMethod=test_multi_ack_nak>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpymultiackgraphwalkerimpltestcasetest_multi_ack_partial">test_server.py::MultiAckGraphWalkerImplTestCase::test_multi_ack_partial</h3>
<details><summary> <pre>test_server.py::MultiAckGraphWalkerImplTestCase::test_multi_ack_partial</pre></summary><pre>
self = <tests.test_server.MultiAckGraphWalkerImplTestCase testMethod=test_multi_ack_partial>

    def test_multi_ack_partial(self):
>       self.assertNextEquals(TWO)

tests/test_server.py:763: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.MultiAckGraphWalkerImplTestCase testMethod=test_multi_ack_partial>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack">test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack</h3>
<details><summary> <pre>test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack</pre></summary><pre>
self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack>

    def test_multi_ack(self):
>       self.assertNextEquals(TWO)

tests/test_server.py:821: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_flush">test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_flush</h3>
<details><summary> <pre>test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_flush</pre></summary><pre>
self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_flush>

    def test_multi_ack_flush(self):
        # same as ack test but contains a flush-pkt in the middle
        self._walker.lines = [
            (b"have", TWO),
            (None, None),
            (b"have", ONE),
            (b"have", THREE),
            (b"done", None),
            (None, None),
        ]
>       self.assertNextEquals(TWO)

tests/test_server.py:933: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_flush>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_flush_end">test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_flush_end</h3>
<details><summary> <pre>test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_flush_end</pre></summary><pre>
self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_flush_end>

    def test_multi_ack_flush_end(self):
        # transmission ends with a flush-pkt without a done but no-done is
        # assumed.
        self._walker.lines[-1] = (None, None)
>       self.assertNextEquals(TWO)

tests/test_server.py:867: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_flush_end>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_flush_end_nodone">test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_flush_end_nodone</h3>
<details><summary> <pre>test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_flush_end_nodone</pre></summary><pre>
self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_flush_end_nodone>

    def test_multi_ack_flush_end_nodone(self):
        # transmission ends with a flush-pkt without a done but no-done is
        # assumed.
        self._walker.lines[-1] = (None, None)
        self._walker.done_required = False
>       self.assertNextEquals(TWO)

tests/test_server.py:890: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_flush_end_nodone>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_nak">test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_nak</h3>
<details><summary> <pre>test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_nak</pre></summary><pre>
self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_nak>

    def test_multi_ack_nak(self):
>       self.assertNextEquals(TWO)

tests/test_server.py:952: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_nak>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_nak_flush">test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_nak_flush</h3>
<details><summary> <pre>test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_nak_flush</pre></summary><pre>
self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_nak_flush>

    def test_multi_ack_nak_flush(self):
        # same as nak test but contains a flush-pkt in the middle
        self._walker.lines = [
            (b"have", TWO),
            (None, None),
            (b"have", ONE),
            (b"have", THREE),
            (b"done", None),
        ]
>       self.assertNextEquals(TWO)

tests/test_server.py:996: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_nak_flush>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_nak_nodone">test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_nak_nodone</h3>
<details><summary> <pre>test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_nak_nodone</pre></summary><pre>
self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_nak_nodone>

    def test_multi_ack_nak_nodone(self):
        self._walker.done_required = False
>       self.assertNextEquals(TWO)

tests/test_server.py:970: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_nak_nodone>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_nodone">test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_nodone</h3>
<details><summary> <pre>test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_nodone</pre></summary><pre>
self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_nodone>

    def test_multi_ack_nodone(self):
        self._walker.done_required = False
>       self.assertNextEquals(TWO)

tests/test_server.py:843: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_nodone>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_partial">test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_partial</h3>
<details><summary> <pre>test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_partial</pre></summary><pre>
self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_partial>

    def test_multi_ack_partial(self):
>       self.assertNextEquals(TWO)

tests/test_server.py:909: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_partial>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_stateless">test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_stateless</h3>
<details><summary> <pre>test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_stateless</pre></summary><pre>
self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_stateless>

    def test_multi_ack_stateless(self):
        # transmission ends with a flush-pkt
        self._walker.lines[-1] = (None, None)
        self._walker.stateless_rpc = True

>       self.assertNextEquals(TWO)

tests/test_server.py:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_stateless>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpymultiackdetailedgraphwalkerimpltestcasetest_multi_ack_stateless_nodone">test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_stateless_nodone</h3>
<details><summary> <pre>test_server.py::MultiAckDetailedGraphWalkerImplTestCase::test_multi_ack_stateless_nodone</pre></summary><pre>
self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_stateless_nodone>

    def test_multi_ack_stateless_nodone(self):
        self._walker.done_required = False
        # transmission ends with a flush-pkt
        self._walker.lines[-1] = (None, None)
        self._walker.stateless_rpc = True

>       self.assertNextEquals(TWO)

tests/test_server.py:1037: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_server.MultiAckDetailedGraphWalkerImplTestCase testMethod=test_multi_ack_stateless_nodone>
sha = b'2222222222222222222222222222222222222222'

    def assertNextEquals(self, sha):
>       self.assertEqual(sha, next(self._impl))
E       TypeError: next expected at least 1 argument, got 0

tests/test_server.py:664: TypeError
</pre>
</details>
<h3 id="test_serverpyfilesystembackendteststest_absolute">test_server.py::FileSystemBackendTests::test_absolute</h3>
<details><summary> <pre>test_server.py::FileSystemBackendTests::test_absolute</pre></summary><pre>
self = <tests.test_server.FileSystemBackendTests testMethod=test_absolute>

    def test_absolute(self):
        repo = self.backend.open_repository(self.path)
        self.assertTrue(
            os.path.samefile(
>               os.path.abspath(repo.path), os.path.abspath(self.repo.path)
            )
        )
E       AttributeError: 'NoneType' object has no attribute 'path'

tests/test_server.py:1080: AttributeError
</pre>
</details>
<h3 id="test_serverpyfilesystembackendteststest_bad_repo_path">test_server.py::FileSystemBackendTests::test_bad_repo_path</h3>
<details><summary> <pre>test_server.py::FileSystemBackendTests::test_bad_repo_path</pre></summary><pre>
self = <tests.test_server.FileSystemBackendTests testMethod=test_bad_repo_path>

    def test_bad_repo_path(self):
        backend = FileSystemBackend()

>       self.assertRaises(NotGitRepository, lambda: backend.open_repository("/ups"))
E       AssertionError: NotGitRepository not raised by <lambda>

tests/test_server.py:1094: AssertionError
</pre>
</details>
<h3 id="test_serverpyfilesystembackendteststest_child">test_server.py::FileSystemBackendTests::test_child</h3>
<details><summary> <pre>test_server.py::FileSystemBackendTests::test_child</pre></summary><pre>
self = <tests.test_server.FileSystemBackendTests testMethod=test_child>

    def test_child(self):
>       self.assertRaises(
            NotGitRepository,
            self.backend.open_repository,
            os.path.join(self.path, "foo"),
        )
E       AssertionError: NotGitRepository not raised by open_repository

tests/test_server.py:1085: AssertionError
</pre>
</details>
<h3 id="test_serverpyfilesystembackendteststest_nonexistant">test_server.py::FileSystemBackendTests::test_nonexistant</h3>
<details><summary> <pre>test_server.py::FileSystemBackendTests::test_nonexistant</pre></summary><pre>
self = <tests.test_server.FileSystemBackendTests testMethod=test_nonexistant>

    def test_nonexistant(self):
>       self.assertRaises(
            NotGitRepository,
            self.backend.open_repository,
            "/does/not/exist/unless/foo",
        )
E       AssertionError: NotGitRepository not raised by open_repository

tests/test_server.py:1070: AssertionError
</pre>
</details>
<h3 id="test_serverpydictbackendteststest_bad_repo_path">test_server.py::DictBackendTests::test_bad_repo_path</h3>
<details><summary> <pre>test_server.py::DictBackendTests::test_bad_repo_path</pre></summary><pre>
self = <tests.test_server.DictBackendTests testMethod=test_bad_repo_path>

    def test_bad_repo_path(self):
        repo = MemoryRepo.init_bare([], {})
        backend = DictBackend({b"/": repo})

>       self.assertRaises(NotGitRepository, lambda: backend.open_repository("/ups"))
E       AssertionError: NotGitRepository not raised by <lambda>

tests/test_server.py:1113: AssertionError
</pre>
</details>
<h3 id="test_serverpydictbackendteststest_nonexistant">test_server.py::DictBackendTests::test_nonexistant</h3>
<details><summary> <pre>test_server.py::DictBackendTests::test_nonexistant</pre></summary><pre>
self = <tests.test_server.DictBackendTests testMethod=test_nonexistant>

    def test_nonexistant(self):
        repo = MemoryRepo.init_bare([], {})
        backend = DictBackend({b"/": repo})
>       self.assertRaises(
            NotGitRepository,
            backend.open_repository,
            "/does/not/exist/unless/foo",
        )
E       AssertionError: NotGitRepository not raised by open_repository

tests/test_server.py:1103: AssertionError
</pre>
</details>
<h3 id="test_serverpyservecommandteststest_receive_pack">test_server.py::ServeCommandTests::test_receive_pack</h3>
<details><summary> <pre>test_server.py::ServeCommandTests::test_receive_pack</pre></summary><pre>
self = <tests.test_server.ServeCommandTests testMethod=test_receive_pack>

    def test_receive_pack(self):
        commit = make_commit(id=ONE, parents=[], commit_time=111)
        self.backend.repos[b"/"] = MemoryRepo.init_bare(
>           [commit], {b"refs/heads/master": commit.id}
        )
E       AttributeError: 'NoneType' object has no attribute 'id'

tests/test_server.py:1135: AttributeError
</pre>
</details>
<h3 id="test_serverpyupdateserverinfoteststest_empty">test_server.py::UpdateServerInfoTests::test_empty</h3>
<details><summary> <pre>test_server.py::UpdateServerInfoTests::test_empty</pre></summary><pre>
self = <tests.test_server.UpdateServerInfoTests testMethod=test_empty>

    def test_empty(self):
        update_server_info(self.repo)
>       with open(os.path.join(self.path, ".git", "info", "refs"), "rb") as f:
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpbx1hjo5n/.git/info/refs'

tests/test_server.py:1162: FileNotFoundError
</pre>
</details>
<h3 id="test_serverpyupdateserverinfoteststest_simple">test_server.py::UpdateServerInfoTests::test_simple</h3>
<details><summary> <pre>test_server.py::UpdateServerInfoTests::test_simple</pre></summary><pre>
self = <tests.test_server.UpdateServerInfoTests testMethod=test_simple>

    def test_simple(self):
>       commit_id = self.repo.do_commit(
            message=b"foo",
            committer=b"Joe Example <joe@example.com>",
            ref=b"refs/heads/foo",
        )
E       AttributeError: 'NoneType' object has no attribute 'do_commit'

tests/test_server.py:1169: AttributeError
</pre>
</details>
<h3 id="test_stashpystashteststest_obtain">test_stash.py::StashTests::test_obtain</h3>
<details><summary> <pre>test_stash.py::StashTests::test_obtain</pre></summary><pre>
self = <tests.test_stash.StashTests testMethod=test_obtain>

    def test_obtain(self):
>       repo = MemoryRepo()

tests/test_stash.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dulwich.repo.MemoryRepo object at 0x7eec1f85f2e0>

    def __init__(self) -> None:
        from .config import ConfigFile
        self._reflog: List[Any] = []
>       refs_container = DictRefsContainer({}, logger=self._append_reflog)
E       AttributeError: 'MemoryRepo' object has no attribute '_append_reflog'

dulwich/repo.py:826: AttributeError
</pre>
</details>
<h3 id="test_utilspybuildcommitgraphtesttest_attrs">test_utils.py::BuildCommitGraphTest::test_attrs</h3>
<details><summary> <pre>test_utils.py::BuildCommitGraphTest::test_attrs</pre></summary><pre>
self = <tests.test_utils.BuildCommitGraphTest testMethod=test_attrs>

    def test_attrs(self):
>       c1, c2 = build_commit_graph(
            self.store, [[1], [2, 1]], attrs={1: {"message": b"Hooray!"}}
        )
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_utils.py:70: TypeError
</pre>
</details>
<h3 id="test_utilspybuildcommitgraphtesttest_commit_time">test_utils.py::BuildCommitGraphTest::test_commit_time</h3>
<details><summary> <pre>test_utils.py::BuildCommitGraphTest::test_commit_time</pre></summary><pre>
self = <tests.test_utils.BuildCommitGraphTest testMethod=test_commit_time>

    def test_commit_time(self):
>       c1, c2, c3 = build_commit_graph(
            self.store,
            [[1], [2, 1], [3, 2]],
            attrs={1: {"commit_time": 124}, 2: {"commit_time": 123}},
        )
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_utils.py:77: TypeError
</pre>
</details>
<h3 id="test_utilspybuildcommitgraphtesttest_linear">test_utils.py::BuildCommitGraphTest::test_linear</h3>
<details><summary> <pre>test_utils.py::BuildCommitGraphTest::test_linear</pre></summary><pre>
self = <tests.test_utils.BuildCommitGraphTest testMethod=test_linear>

    def test_linear(self):
>       c1, c2 = build_commit_graph(self.store, [[1], [2, 1]])
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_utils.py:36: TypeError
</pre>
</details>
<h3 id="test_utilspybuildcommitgraphtesttest_merge">test_utils.py::BuildCommitGraphTest::test_merge</h3>
<details><summary> <pre>test_utils.py::BuildCommitGraphTest::test_merge</pre></summary><pre>
self = <tests.test_utils.BuildCommitGraphTest testMethod=test_merge>

    def test_merge(self):
>       c1, c2, c3, c4 = build_commit_graph(
            self.store, [[1], [2, 1], [3, 1], [4, 2, 3]]
        )
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_utils.py:46: TypeError
</pre>
</details>
<h3 id="test_utilspybuildcommitgraphtesttest_missing_parent">test_utils.py::BuildCommitGraphTest::test_missing_parent</h3>
<details><summary> <pre>test_utils.py::BuildCommitGraphTest::test_missing_parent</pre></summary><pre>
self = <tests.test_utils.BuildCommitGraphTest testMethod=test_missing_parent>

    def test_missing_parent(self):
>       self.assertRaises(
            ValueError, build_commit_graph, self.store, [[1], [3, 2], [2, 1]]
        )
E       AssertionError: ValueError not raised by build_commit_graph

tests/test_utils.py:54: AssertionError
</pre>
</details>
<h3 id="test_utilspybuildcommitgraphtesttest_trees">test_utils.py::BuildCommitGraphTest::test_trees</h3>
<details><summary> <pre>test_utils.py::BuildCommitGraphTest::test_trees</pre></summary><pre>
self = <tests.test_utils.BuildCommitGraphTest testMethod=test_trees>

    def test_trees(self):
        a1 = make_object(Blob, data=b"aaa1")
        a2 = make_object(Blob, data=b"aaa2")
>       c1, c2 = build_commit_graph(
            self.store,
            [[1], [2, 1]],
            trees={1: [(b"a", a1)], 2: [(b"a", a2, 0o100644)]},
        )
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_utils.py:61: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_branch">test_walk.py::WalkerTest::test_branch</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_branch</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_branch>

    def test_branch(self):
>       c1, x2, x3, y4 = self.make_commits([[1], [2, 1], [3, 2], [4, 1]])
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:111: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_changes_multiple_parents">test_walk.py::WalkerTest::test_changes_multiple_parents</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_changes_multiple_parents</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_changes_multiple_parents>

    def test_changes_multiple_parents(self):
        blob_a1 = make_object(Blob, data=b"a1")
        blob_b2 = make_object(Blob, data=b"b2")
        blob_a3 = make_object(Blob, data=b"a3")
>       c1, c2, c3 = self.make_commits(
            [[1], [2], [3, 1, 2]],
            trees={
                1: [(b"a", blob_a1)],
                2: [(b"b", blob_b2)],
                3: [(b"a", blob_a3), (b"b", blob_b2)],
            },
        )
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:197: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_changes_one_parent">test_walk.py::WalkerTest::test_changes_one_parent</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_changes_one_parent</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_changes_one_parent>

    def test_changes_one_parent(self):
        blob_a1 = make_object(Blob, data=b"a1")
        blob_a2 = make_object(Blob, data=b"a2")
        blob_b2 = make_object(Blob, data=b"b2")
>       c1, c2 = self.make_linear_commits(
            2,
            trees={
                1: [(b"a", blob_a1)],
                2: [(b"a", blob_a2), (b"b", blob_b2)],
            },
        )
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:176: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_changes_with_renames">test_walk.py::WalkerTest::test_changes_with_renames</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_changes_with_renames</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_changes_with_renames>

    def test_changes_with_renames(self):
        blob = make_object(Blob, data=b"blob")
>       c1, c2 = self.make_linear_commits(
            2, trees={1: [(b"a", blob)], 2: [(b"b", blob)]}
        )
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:299: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_empty_walk">test_walk.py::WalkerTest::test_empty_walk</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_empty_walk</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_empty_walk>

    def test_empty_walk(self):
>       c1, c2, c3 = self.make_linear_commits(3)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:476: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_follow_rename">test_walk.py::WalkerTest::test_follow_rename</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_follow_rename</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_follow_rename>

    def test_follow_rename(self):
        blob = make_object(Blob, data=b"blob")
        names = [b"a", b"a", b"b", b"b", b"c", b"c"]

        trees = {i + 1: [(n, blob, F)] for i, n in enumerate(names)}
>       c1, c2, c3, c4, c5, c6 = self.make_linear_commits(6, trees=trees)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:327: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_follow_rename_remove_path">test_walk.py::WalkerTest::test_follow_rename_remove_path</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_follow_rename_remove_path</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_follow_rename_remove_path>

    def test_follow_rename_remove_path(self):
        blob = make_object(Blob, data=b"blob")
>       _, _, _, c4, c5, c6 = self.make_linear_commits(
            6,
            trees={
                1: [(b"a", blob), (b"c", blob)],
                2: [],
                3: [],
                4: [(b"b", blob)],
                5: [(b"a", blob)],
                6: [(b"c", blob)],
            },
        )
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:346: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_linear">test_walk.py::WalkerTest::test_linear</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_linear</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_linear>

    def test_linear(self):
>       c1, c2, c3 = self.make_linear_commits(3)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:89: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_max_entries">test_walk.py::WalkerTest::test_max_entries</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_max_entries</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_max_entries>

    def test_max_entries(self):
>       c1, c2, c3 = self.make_linear_commits(3)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:161: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_merge">test_walk.py::WalkerTest::test_merge</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_merge</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_merge>

    def test_merge(self):
>       c1, c2, c3, c4 = self.make_commits([[1], [2, 1], [3, 1], [4, 2, 3]])
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:121: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_merge_of_new_branch_from_old_base">test_walk.py::WalkerTest::test_merge_of_new_branch_from_old_base</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_merge_of_new_branch_from_old_base</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_merge_of_new_branch_from_old_base>

    def test_merge_of_new_branch_from_old_base(self):
        # The commit on the branch was made at a time after any of the
        # commits on master, but the branch was from an older commit.
        # See also test_merge_of_old_branch
        self.maxDiff = None
>       c1, c2, c3, c4, c5 = self.make_commits(
            [[1], [2, 1], [3, 2], [4, 1], [5, 3, 4]],
            times=[1, 2, 3, 4, 5],
        )
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:133: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_merge_of_old_branch">test_walk.py::WalkerTest::test_merge_of_old_branch</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_merge_of_old_branch</pre></summary><pre>
self = <TestCaseFunction test_merge_of_old_branch>
testcase = <tests.test_walk.WalkerTest testMethod=test_merge_of_old_branch>
rawexcinfo = (<class 'TypeError'>, TypeError('cannot unpack non-iterable NoneType object'), <traceback object at 0x7eec1f660200>)
reason = ''

    def addExpectedFailure(
        self,
        testcase: unittest.TestCase,
        rawexcinfo: _SysExcInfoType,
        reason: str = "",
    ) -> None:
        try:
>           xfail(str(reason))
E           _pytest.outcomes.XFailed

.venv/lib/python3.10/site-packages/_pytest/unittest.py:295: XFailed
</pre>
</details>
<h3 id="test_walkpywalkertesttest_missing">test_walk.py::WalkerTest::test_missing</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_missing</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_missing>

    def test_missing(self):
>       cs = list(reversed(self.make_linear_commits(20)))
E       TypeError: 'NoneType' object is not reversible

tests/test_walk.py:99: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_out_of_order_children">test_walk.py::WalkerTest::test_out_of_order_children</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_out_of_order_children</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_out_of_order_children>

    def test_out_of_order_children(self):
>       c1, c2, c3, c4, c5 = self.make_commits(
            [[1], [2, 1], [3, 2], [4, 1], [5, 3, 4]], times=[2, 1, 3, 4, 5]
        )
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:454: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_out_of_order_with_exclude">test_walk.py::WalkerTest::test_out_of_order_with_exclude</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_out_of_order_with_exclude</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_out_of_order_with_exclude>

    def test_out_of_order_with_exclude(self):
        # Create the following graph:
        # c1-------x2---m6
        #   \          /
        #    \-y3--y4-/--y5
        # Due to skew, y5 is the oldest commit.
>       c1, x2, y3, y4, y5, m6 = self.make_commits(
            [[1], [2, 1], [3, 1], [4, 3], [5, 4], [6, 2, 4]],
            times=[2, 3, 4, 5, 1, 6],
        )
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:466: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_path_matches">test_walk.py::WalkerTest::test_path_matches</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_path_matches</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_path_matches>

    def test_path_matches(self):
        walker = Walker(None, [], paths=[b"foo", b"bar", b"baz/quux"])
>       self.assertTrue(walker._path_matches(b"foo"))
E       AttributeError: 'Walker' object has no attribute '_path_matches'

tests/test_walk.py:218: AttributeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_paths">test_walk.py::WalkerTest::test_paths</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_paths</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_paths>

    def test_paths(self):
        blob_a1 = make_object(Blob, data=b"a1")
        blob_b2 = make_object(Blob, data=b"b2")
        blob_a3 = make_object(Blob, data=b"a3")
        blob_b3 = make_object(Blob, data=b"b3")
>       c1, c2, c3 = self.make_linear_commits(
            3,
            trees={
                1: [(b"a", blob_a1)],
                2: [(b"a", blob_a1), (b"x/b", blob_b2)],
                3: [(b"a", blob_a3), (b"x/b", blob_b3)],
            },
        )
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:236: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_paths_max_entries">test_walk.py::WalkerTest::test_paths_max_entries</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_paths_max_entries</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_paths_max_entries>

    def test_paths_max_entries(self):
        blob_a = make_object(Blob, data=b"a")
        blob_b = make_object(Blob, data=b"b")
>       c1, c2 = self.make_linear_commits(
            2, trees={1: [(b"a", blob_a)], 2: [(b"a", blob_a), (b"b", blob_b)]}
        )
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:275: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_paths_merge">test_walk.py::WalkerTest::test_paths_merge</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_paths_merge</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_paths_merge>

    def test_paths_merge(self):
        blob_a1 = make_object(Blob, data=b"a1")
        blob_a2 = make_object(Blob, data=b"a2")
        blob_a3 = make_object(Blob, data=b"a3")
>       x1, y2, m3, m4 = self.make_commits(
            [[1], [2], [3, 1, 2], [4, 1, 2]],
            trees={
                1: [(b"a", blob_a1)],
                2: [(b"a", blob_a2)],
                3: [(b"a", blob_a3)],
                4: [(b"a", blob_a1)],
            },
        )  # Non-conflicting
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:285: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_paths_subtree">test_walk.py::WalkerTest::test_paths_subtree</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_paths_subtree</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_paths_subtree>

    def test_paths_subtree(self):
        blob_a = make_object(Blob, data=b"a")
        blob_b = make_object(Blob, data=b"b")
>       c1, c2, c3 = self.make_linear_commits(
            3,
            trees={
                1: [(b"x/a", blob_a)],
                2: [(b"b", blob_b), (b"x/a", blob_a)],
                3: [(b"b", blob_b), (b"x/a", blob_a), (b"x/b", blob_b)],
            },
        )
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:261: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_reverse">test_walk.py::WalkerTest::test_reverse</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_reverse</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_reverse>

    def test_reverse(self):
>       c1, c2, c3 = self.make_linear_commits(3)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:157: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_reverse_after_max_entries">test_walk.py::WalkerTest::test_reverse_after_max_entries</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_reverse_after_max_entries</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_reverse_after_max_entries>

    def test_reverse_after_max_entries(self):
>       c1, c2, c3 = self.make_linear_commits(3)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:167: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_since">test_walk.py::WalkerTest::test_since</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_since</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_since>

    def test_since(self):
>       c1, c2, c3 = self.make_linear_commits(3)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:374: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_since_over_scan">test_walk.py::WalkerTest::test_since_over_scan</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_since_over_scan</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_since_over_scan>

    def test_since_over_scan(self):
        commits = self.make_linear_commits(11, times=[9, 0, 1, 2, 3, 4, 5, 8, 6, 7, 9])
>       c8, _, c10, c11 = commits[-4:]
E       TypeError: 'NoneType' object is not subscriptable

tests/test_walk.py:408: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_since_until">test_walk.py::WalkerTest::test_since_until</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_since_until</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_since_until>

    def test_since_until(self):
>       c1, c2, c3 = self.make_linear_commits(3)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:400: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_tag">test_walk.py::WalkerTest::test_tag</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_tag</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_tag>

    def test_tag(self):
>       c1, c2, c3 = self.make_linear_commits(3)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:83: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_topo_reorder_linear">test_walk.py::WalkerTest::test_topo_reorder_linear</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_topo_reorder_linear</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_topo_reorder_linear>

    def test_topo_reorder_linear(self):
        commits = self.make_linear_commits(5)
>       commits.reverse()
E       AttributeError: 'NoneType' object has no attribute 'reverse'

tests/test_walk.py:423: AttributeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_topo_reorder_multiple_children">test_walk.py::WalkerTest::test_topo_reorder_multiple_children</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_topo_reorder_multiple_children</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_topo_reorder_multiple_children>

    def test_topo_reorder_multiple_children(self):
>       c1, c2, c3 = self.make_commits([[1], [2, 1], [3, 1]])
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:442: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_topo_reorder_multiple_parents">test_walk.py::WalkerTest::test_topo_reorder_multiple_parents</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_topo_reorder_multiple_parents</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_topo_reorder_multiple_parents>

    def test_topo_reorder_multiple_parents(self):
>       c1, c2, c3 = self.make_commits([[1], [2], [3, 1, 2]])
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:428: TypeError
</pre>
</details>
<h3 id="test_walkpywalkertesttest_until">test_walk.py::WalkerTest::test_until</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_until</pre></summary><pre>
self = <tests.test_walk.WalkerTest testMethod=test_until>

    def test_until(self):
>       c1, c2, c3 = self.make_linear_commits(3)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:387: TypeError
</pre>
</details>
<h3 id="test_walkpywalkentrytesttest_all_changes">test_walk.py::WalkEntryTest::test_all_changes</h3>
<details><summary> <pre>test_walk.py::WalkEntryTest::test_all_changes</pre></summary><pre>
self = <tests.test_walk.WalkEntryTest testMethod=test_all_changes>

    def test_all_changes(self):
        # Construct a commit with 2 files in different subdirectories.
        blob_a = make_object(Blob, data=b"a")
        blob_b = make_object(Blob, data=b"b")
>       c1 = self.make_linear_commits(
            1,
            trees={1: [(b"x/a", blob_a), (b"y/b", blob_b)]},
        )[0]
E       TypeError: 'NoneType' object is not subscriptable

tests/test_walk.py:505: TypeError
</pre>
</details>
<h3 id="test_walkpywalkentrytesttest_all_with_merge">test_walk.py::WalkEntryTest::test_all_with_merge</h3>
<details><summary> <pre>test_walk.py::WalkEntryTest::test_all_with_merge</pre></summary><pre>
self = <tests.test_walk.WalkEntryTest testMethod=test_all_with_merge>

    def test_all_with_merge(self):
        blob_a = make_object(Blob, data=b"a")
        blob_a2 = make_object(Blob, data=b"a2")
        blob_b = make_object(Blob, data=b"b")
        blob_b2 = make_object(Blob, data=b"b2")
>       x1, y2, m3 = self.make_commits(
            [[1], [2], [3, 1, 2]],
            trees={
                1: [(b"x/a", blob_a)],
                2: [(b"y/b", blob_b)],
                3: [(b"x/a", blob_a2), (b"y/b", blob_b2)],
            },
        )
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:528: TypeError
</pre>
</details>
<h3 id="test_walkpywalkentrytesttest_filter_changes">test_walk.py::WalkEntryTest::test_filter_changes</h3>
<details><summary> <pre>test_walk.py::WalkEntryTest::test_filter_changes</pre></summary><pre>
self = <tests.test_walk.WalkEntryTest testMethod=test_filter_changes>

    def test_filter_changes(self):
        # Construct a commit with 2 files in different subdirectories.
        blob_a = make_object(Blob, data=b"a")
        blob_b = make_object(Blob, data=b"b")
>       c1 = self.make_linear_commits(
            1,
            trees={1: [(b"x/a", blob_a), (b"y/b", blob_b)]},
        )[0]
E       TypeError: 'NoneType' object is not subscriptable

tests/test_walk.py:567: TypeError
</pre>
</details>
<h3 id="test_walkpywalkentrytesttest_filter_with_merge">test_walk.py::WalkEntryTest::test_filter_with_merge</h3>
<details><summary> <pre>test_walk.py::WalkEntryTest::test_filter_with_merge</pre></summary><pre>
self = <tests.test_walk.WalkEntryTest testMethod=test_filter_with_merge>

    def test_filter_with_merge(self):
        blob_a = make_object(Blob, data=b"a")
        blob_a2 = make_object(Blob, data=b"a2")
        blob_b = make_object(Blob, data=b"b")
        blob_b2 = make_object(Blob, data=b"b2")
>       x1, y2, m3 = self.make_commits(
            [[1], [2], [3, 1, 2]],
            trees={
                1: [(b"x/a", blob_a)],
                2: [(b"y/b", blob_b)],
                3: [(b"x/a", blob_a2), (b"y/b", blob_b2)],
            },
        )
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_walk.py:589: TypeError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/dulwich/bundle.py b/dulwich/bundle.py</span>
<span class="gh">index f8ccfd2f..9386bab6 100644</span>
<span class="gd">--- a/dulwich/bundle.py</span>
<span class="gi">+++ b/dulwich/bundle.py</span>
<span class="gu">@@ -27,6 +27,34 @@ class Bundle:</span>
<span class="w"> </span>            return False
<span class="w"> </span>        return True

<span class="gi">+def write_bundle(f, bundle: Bundle) -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Write a bundle file.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      f: File-like object to write to</span>
<span class="gi">+      bundle: Bundle object to write</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if bundle.version is None:</span>
<span class="gi">+        f.write(b&#39;# v2 git bundle\n&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        f.write(f&#39;# v{bundle.version} git bundle\n&#39;.encode(&#39;ascii&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    for key, value in sorted(bundle.capabilities.items()):</span>
<span class="gi">+        f.write(f&#39;{key} {value}\n&#39;.encode(&#39;ascii&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    for sha, message in bundle.prerequisites:</span>
<span class="gi">+        f.write(b&#39;-&#39; + sha + b&#39; &#39; + message.encode(&#39;utf-8&#39;) + b&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    for name, sha in sorted(bundle.references.items()):</span>
<span class="gi">+        f.write(sha + b&#39; &#39; + name.encode(&#39;utf-8&#39;) + b&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    f.write(b&#39;\n&#39;)</span>
<span class="gi">+    if isinstance(bundle.pack_data, PackData):</span>
<span class="gi">+        write_pack_data(f, bundle.pack_data.iterobjects())</span>
<span class="gi">+    else:</span>
<span class="gi">+        for chunk in bundle.pack_data:</span>
<span class="gi">+            f.write(chunk)</span>
<span class="gi">+</span>
<span class="w"> </span>def read_bundle(f):
<span class="w"> </span>    &quot;&quot;&quot;Read a bundle file.&quot;&quot;&quot;
<span class="w"> </span>    pass
\ No newline at end of file
<span class="gh">diff --git a/dulwich/client.py b/dulwich/client.py</span>
<span class="gh">index 0c7a0014..3981dca3 100644</span>
<span class="gd">--- a/dulwich/client.py</span>
<span class="gi">+++ b/dulwich/client.py</span>
<span class="gu">@@ -805,7 +805,7 @@ class Urllib3HttpGitClient(AbstractHttpGitClient):</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.pool_manager = pool_manager
<span class="w"> </span>        if username is not None:
<span class="gd">-            credentials = f&#39;{username}:{password or &#39;&#39;}&#39;</span>
<span class="gi">+            credentials = f&#39;{username}:{password or &quot;&quot;}&#39;</span>
<span class="w"> </span>            import urllib3.util
<span class="w"> </span>            basic_auth = urllib3.util.make_headers(basic_auth=credentials)
<span class="w"> </span>            self.pool_manager.headers.update(basic_auth)
<span class="gh">diff --git a/dulwich/config.py b/dulwich/config.py</span>
<span class="gh">index 3295d2e1..68659e00 100644</span>
<span class="gd">--- a/dulwich/config.py</span>
<span class="gi">+++ b/dulwich/config.py</span>
<span class="gu">@@ -158,9 +158,91 @@ _ESCAPE_TABLE = {ord(b&#39;\\&#39;): ord(b&#39;\\&#39;), ord(b&#39;&quot;&#39;): ord(b&#39;&quot;&#39;), ord(b&#39;n&#39;): ord(b&#39;</span>
<span class="w"> </span>_COMMENT_CHARS = [ord(b&#39;#&#39;), ord(b&#39;;&#39;)]
<span class="w"> </span>_WHITESPACE_CHARS = [ord(b&#39;\t&#39;), ord(b&#39; &#39;)]

<span class="gi">+def _check_variable_name(name: bytes) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Check that a variable name is valid.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      name: Name to check</span>
<span class="gi">+    Returns: boolean indicating whether the name is valid</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    for c in name:</span>
<span class="gi">+        if c in (ord(b&#39; &#39;), ord(b&#39;,&#39;), ord(b&#39;\\&#39;), ord(b&#39;&quot;&#39;), ord(b&#39;.&#39;)):</span>
<span class="gi">+            return False</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+def _check_section_name(name: bytes) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Check that a section name is valid.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      name: Name to check</span>
<span class="gi">+    Returns: boolean indicating whether the name is valid</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    for c in name:</span>
<span class="gi">+        if c in (ord(b&#39; &#39;), ord(b&#39;,&#39;), ord(b&#39;\\&#39;), ord(b&#39;&quot;&#39;)):</span>
<span class="gi">+            return False</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+def get_xdg_config_home_path(*args) -&gt; str:</span>
<span class="gi">+    &quot;&quot;&quot;Get the XDG config home path.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      *args: Path components to join to the XDG config home path</span>
<span class="gi">+    Returns: Path to XDG config home directory</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    path = os.environ.get(&#39;XDG_CONFIG_HOME&#39;, os.path.expanduser(&#39;~/.config&#39;))</span>
<span class="gi">+    return os.path.join(path, *args)</span>
<span class="gi">+</span>
<span class="gi">+def _parse_string(value: bytes) -&gt; bytes:</span>
<span class="gi">+    &quot;&quot;&quot;Parse a string from a git config file.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      value: The string to parse</span>
<span class="gi">+    Returns: The parsed string</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if value.startswith(b&#39;&quot;&#39;) and value.endswith(b&#39;&quot;&#39;):</span>
<span class="gi">+        value = value[1:-1]</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        ret = []</span>
<span class="gi">+        while i &lt; len(value):</span>
<span class="gi">+            if value[i] == ord(b&#39;\\&#39;):</span>
<span class="gi">+                i += 1</span>
<span class="gi">+                if i &gt;= len(value):</span>
<span class="gi">+                    break</span>
<span class="gi">+                c = value[i]</span>
<span class="gi">+                if c == ord(b&#39;\\&#39;):</span>
<span class="gi">+                    ret.append(ord(b&#39;\\&#39;))</span>
<span class="gi">+                elif c == ord(b&#39;n&#39;):</span>
<span class="gi">+                    ret.append(ord(b&#39;\n&#39;))</span>
<span class="gi">+                elif c == ord(b&#39;t&#39;):</span>
<span class="gi">+                    ret.append(ord(b&#39;\t&#39;))</span>
<span class="gi">+                elif c == ord(b&#39;&quot;&#39;):</span>
<span class="gi">+                    ret.append(ord(b&#39;&quot;&#39;))</span>
<span class="gi">+                elif c == ord(b&#39;b&#39;):</span>
<span class="gi">+                    ret.append(ord(b&#39;\b&#39;))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    ret.append(c)</span>
<span class="gi">+            else:</span>
<span class="gi">+                ret.append(value[i])</span>
<span class="gi">+            i += 1</span>
<span class="gi">+        return bytes(ret)</span>
<span class="gi">+    return value</span>
<span class="gi">+</span>
<span class="gi">+def _format_string(value: bytes) -&gt; bytes:</span>
<span class="gi">+    &quot;&quot;&quot;Format a string for inclusion in a git config file.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      value: The string to format</span>
<span class="gi">+    Returns: The formatted string</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if any(c in value for c in (ord(b&#39;\n&#39;), ord(b&#39;\t&#39;), ord(b&#39;&quot;&#39;))):</span>
<span class="gi">+        return b&#39;&quot;&#39; + value.replace(b&#39;\\&#39;, b&#39;\\\\&#39;).replace(b&#39;\n&#39;, b&#39;\\n&#39;).replace(b&#39;\t&#39;, b&#39;\\t&#39;).replace(b&#39;&quot;&#39;, b&#39;\\&quot;&#39;) + b&#39;&quot;&#39;</span>
<span class="gi">+    return value</span>
<span class="gi">+</span>
<span class="w"> </span>def _escape_value(value: bytes) -&gt; bytes:
<span class="w"> </span>    &quot;&quot;&quot;Escape a value.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value.startswith(b&#39;&quot;&#39;) and value.endswith(b&#39;&quot;&#39;):</span>
<span class="gi">+        return value[1:-1].replace(b&#39;\\\\&#39;, b&#39;\\&#39;).replace(b&#39;\\n&#39;, b&#39;\n&#39;).replace(b&#39;\\t&#39;, b&#39;\t&#39;).replace(b&#39;\\&quot;&#39;, b&#39;&quot;&#39;)</span>
<span class="gi">+    return value</span>

<span class="w"> </span>class ConfigFile(ConfigDict):
<span class="w"> </span>    &quot;&quot;&quot;A Git configuration file, like .git/config or ~/.gitconfig.&quot;&quot;&quot;
<span class="gh">diff --git a/dulwich/credentials.py b/dulwich/credentials.py</span>
<span class="gh">index 92155898..821b81c2 100644</span>
<span class="gd">--- a/dulwich/credentials.py</span>
<span class="gi">+++ b/dulwich/credentials.py</span>
<span class="gu">@@ -8,9 +8,27 @@ from typing import Iterator, Optional</span>
<span class="w"> </span>from urllib.parse import ParseResult, urlparse
<span class="w"> </span>from .config import ConfigDict, SectionLike

<span class="gi">+def match_urls(url1: str, url2: str) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Match two URLs.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      url1: First URL to match</span>
<span class="gi">+      url2: Second URL to match</span>
<span class="gi">+    Returns: True if URLs match, False otherwise</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    parsed1 = urlparse(url1)</span>
<span class="gi">+    parsed2 = urlparse(url2)</span>
<span class="gi">+    return (parsed1.scheme == parsed2.scheme and</span>
<span class="gi">+            parsed1.netloc == parsed2.netloc and</span>
<span class="gi">+            parsed1.path == parsed2.path)</span>
<span class="gi">+</span>
<span class="w"> </span>def match_partial_url(valid_url: ParseResult, partial_url: str) -&gt; bool:
<span class="w"> </span>    &quot;&quot;&quot;Matches a parsed url with a partial url (no scheme/netloc).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not partial_url:</span>
<span class="gi">+        return True</span>
<span class="gi">+    if partial_url.startswith(&#39;/&#39;):</span>
<span class="gi">+        return valid_url.path == partial_url</span>
<span class="gi">+    return valid_url.path.endswith(partial_url)</span>

<span class="w"> </span>def urlmatch_credential_sections(config: ConfigDict, url: Optional[str]) -&gt; Iterator[SectionLike]:
<span class="w"> </span>    &quot;&quot;&quot;Returns credential sections from the config which match the given URL.&quot;&quot;&quot;
<span class="gh">diff --git a/dulwich/diff_tree.py b/dulwich/diff_tree.py</span>
<span class="gh">index e4ed578e..c2fcfc7a 100644</span>
<span class="gd">--- a/dulwich/diff_tree.py</span>
<span class="gi">+++ b/dulwich/diff_tree.py</span>
<span class="gu">@@ -22,6 +22,21 @@ REWRITE_THRESHOLD = None</span>
<span class="w"> </span>class TreeChange(namedtuple(&#39;TreeChange&#39;, [&#39;type&#39;, &#39;old&#39;, &#39;new&#39;])):
<span class="w"> </span>    &quot;&quot;&quot;Named tuple a single change between two trees.&quot;&quot;&quot;

<span class="gi">+def _is_tree(mode: int) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Return True if the mode indicates this is a tree.&quot;&quot;&quot;</span>
<span class="gi">+    return stat.S_ISDIR(mode)</span>
<span class="gi">+</span>
<span class="gi">+def _tree_change_key(entry):</span>
<span class="gi">+    &quot;&quot;&quot;Sort key for tree changes.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      entry: TreeEntry to get sort key for</span>
<span class="gi">+    Returns: Sort key for the entry</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if entry.type == b&#39;tree&#39;:</span>
<span class="gi">+        return entry.path + b&#39;/&#39;</span>
<span class="gi">+    return entry.path</span>
<span class="gi">+</span>
<span class="w"> </span>def _merge_entries(path, tree1, tree2):
<span class="w"> </span>    &quot;&quot;&quot;Merge the entries of two trees.

<span class="gu">@@ -36,7 +51,22 @@ def _merge_entries(path, tree1, tree2):</span>
<span class="w"> </span>        entry will have all attributes set to None. If neither entry&#39;s path is
<span class="w"> </span>        None, they are guaranteed to match.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    entries = []</span>
<span class="gi">+    if tree1 is None:</span>
<span class="gi">+        for entry in tree2.iteritems():</span>
<span class="gi">+            entries.append((_NULL_ENTRY, entry))</span>
<span class="gi">+    elif tree2 is None:</span>
<span class="gi">+        for entry in tree1.iteritems():</span>
<span class="gi">+            entries.append((entry, _NULL_ENTRY))</span>
<span class="gi">+    else:</span>
<span class="gi">+        entries1 = dict(tree1.iteritems())</span>
<span class="gi">+        entries2 = dict(tree2.iteritems())</span>
<span class="gi">+        all_keys = set(entries1) | set(entries2)</span>
<span class="gi">+        for key in sorted(all_keys):</span>
<span class="gi">+            entry1 = entries1.get(key, _NULL_ENTRY)</span>
<span class="gi">+            entry2 = entries2.get(key, _NULL_ENTRY)</span>
<span class="gi">+            entries.append((entry1, entry2))</span>
<span class="gi">+    return entries</span>

<span class="w"> </span>def walk_trees(store, tree1_id, tree2_id, prune_identical=False):
<span class="w"> </span>    &quot;&quot;&quot;Recursively walk all the entries of two trees.
<span class="gh">diff --git a/dulwich/graph.py b/dulwich/graph.py</span>
<span class="gh">index acde4e6a..a94091ef 100644</span>
<span class="gd">--- a/dulwich/graph.py</span>
<span class="gi">+++ b/dulwich/graph.py</span>
<span class="gu">@@ -7,6 +7,53 @@ class WorkList:</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self.pq = []

<span class="gi">+def _find_lcas(repo, commit_ids):</span>
<span class="gi">+    &quot;&quot;&quot;Find lowest common ancestors of commit_ids.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      repo: Repository object</span>
<span class="gi">+      commit_ids: list of commit ids</span>
<span class="gi">+    Returns:</span>
<span class="gi">+      list of lowest common ancestor commit_ids</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if not commit_ids:</span>
<span class="gi">+        return []</span>
<span class="gi">+    if len(commit_ids) == 1:</span>
<span class="gi">+        return [commit_ids[0]]</span>
<span class="gi">+</span>
<span class="gi">+    # Build a list of all commits reachable from each commit_id</span>
<span class="gi">+    reachable = []</span>
<span class="gi">+    for commit_id in commit_ids:</span>
<span class="gi">+        reachable_from_commit = set()</span>
<span class="gi">+        worklist = [commit_id]</span>
<span class="gi">+        while worklist:</span>
<span class="gi">+            commit_id = worklist.pop()</span>
<span class="gi">+            if commit_id in reachable_from_commit:</span>
<span class="gi">+                continue</span>
<span class="gi">+            reachable_from_commit.add(commit_id)</span>
<span class="gi">+            commit = repo[commit_id]</span>
<span class="gi">+            worklist.extend(commit.parents)</span>
<span class="gi">+        reachable.append(reachable_from_commit)</span>
<span class="gi">+</span>
<span class="gi">+    # Find the intersection of all reachable sets</span>
<span class="gi">+    lcas = reachable[0]</span>
<span class="gi">+    for r in reachable[1:]:</span>
<span class="gi">+        lcas &amp;= r</span>
<span class="gi">+</span>
<span class="gi">+    # Remove commits that have descendants in lcas</span>
<span class="gi">+    result = set(lcas)</span>
<span class="gi">+    for commit_id in lcas:</span>
<span class="gi">+        commit = repo[commit_id]</span>
<span class="gi">+        worklist = list(commit.parents)</span>
<span class="gi">+        while worklist:</span>
<span class="gi">+            parent_id = worklist.pop()</span>
<span class="gi">+            if parent_id in result:</span>
<span class="gi">+                result.remove(parent_id)</span>
<span class="gi">+                parent = repo[parent_id]</span>
<span class="gi">+                worklist.extend(parent.parents)</span>
<span class="gi">+</span>
<span class="gi">+    return sorted(result)</span>
<span class="gi">+</span>
<span class="w"> </span>def find_merge_base(repo, commit_ids):
<span class="w"> </span>    &quot;&quot;&quot;Find lowest common ancestors of commit_ids[0] and *any* of commits_ids[1:].

<span class="gu">@@ -16,7 +63,16 @@ def find_merge_base(repo, commit_ids):</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      list of lowest common ancestor commit_ids
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not commit_ids:</span>
<span class="gi">+        return []</span>
<span class="gi">+    if len(commit_ids) == 1:</span>
<span class="gi">+        return [commit_ids[0]]</span>
<span class="gi">+    </span>
<span class="gi">+    # Find LCAs between first commit and each other commit</span>
<span class="gi">+    result = set(_find_lcas(repo, [commit_ids[0], commit_ids[1]]))</span>
<span class="gi">+    for commit_id in commit_ids[2:]:</span>
<span class="gi">+        result |= set(_find_lcas(repo, [commit_ids[0], commit_id]))</span>
<span class="gi">+    return sorted(result)</span>

<span class="w"> </span>def find_octopus_base(repo, commit_ids):
<span class="w"> </span>    &quot;&quot;&quot;Find lowest common ancestors of *all* provided commit_ids.
<span class="gh">diff --git a/dulwich/index.py b/dulwich/index.py</span>
<span class="gh">index 769a9723..caead9e5 100644</span>
<span class="gd">--- a/dulwich/index.py</span>
<span class="gi">+++ b/dulwich/index.py</span>
<span class="gu">@@ -326,9 +326,46 @@ def build_file_from_blob(blob: Blob, mode: int, target_path: bytes, *, honor_fil</span>
<span class="w"> </span>    pass
<span class="w"> </span>INVALID_DOTNAMES = (b&#39;.git&#39;, b&#39;.&#39;, b&#39;..&#39;, b&#39;&#39;)

<span class="gi">+def validate_path_element_ntfs(element: bytes) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;NTFS path validator.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      element: Path element to validate</span>
<span class="gi">+    Returns: True if the path element is valid, False otherwise</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if element in INVALID_DOTNAMES:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if element.endswith(b&#39;.&#39;):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if element.endswith(b&#39; &#39;):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if any(c in element for c in (ord(b&#39;:&#39;), ord(b&#39;&lt;&#39;), ord(b&#39;&gt;&#39;), ord(b&#39;&quot;&#39;), ord(b&#39;|&#39;), ord(b&#39;?&#39;), ord(b&#39;*&#39;))):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if any(c &lt; 32 for c in element):</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+def validate_path_element_default(element: bytes) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Default path validator that just checks for .git/.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      element: Path element to validate</span>
<span class="gi">+    Returns: True if the path element is valid, False otherwise</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    return element not in INVALID_DOTNAMES</span>
<span class="gi">+</span>
<span class="w"> </span>def validate_path(path: bytes, element_validator=validate_path_element_default) -&gt; bool:
<span class="gd">-    &quot;&quot;&quot;Default path validator that just checks for .git/.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;Default path validator that just checks for .git/.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      path: Path to validate</span>
<span class="gi">+      element_validator: Function to validate path elements</span>
<span class="gi">+    Returns: True if the path is valid, False otherwise</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    for element in path.split(b&#39;/&#39;):</span>
<span class="gi">+        if not element_validator(element):</span>
<span class="gi">+            return False</span>
<span class="gi">+    return True</span>

<span class="w"> </span>def build_index_from_tree(root_path: Union[str, bytes], index_path: Union[str, bytes], object_store: ObjectContainer, tree_id: bytes, honor_filemode: bool=True, validate_path_element=validate_path_element_default, symlink_fn=None):
<span class="w"> </span>    &quot;&quot;&quot;Generate and materialize index from a tree.
<span class="gh">diff --git a/dulwich/objects.py b/dulwich/objects.py</span>
<span class="gh">index 2f7197ce..eb625fa3 100644</span>
<span class="gd">--- a/dulwich/objects.py</span>
<span class="gi">+++ b/dulwich/objects.py</span>
<span class="gu">@@ -40,31 +40,43 @@ def S_ISGITLINK(m):</span>
<span class="w"> </span>      m: Mode to check
<span class="w"> </span>    Returns: a ``boolean``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (m &amp; 0o170000) == S_IFGITLINK</span>

<span class="w"> </span>def sha_to_hex(sha):
<span class="w"> </span>    &quot;&quot;&quot;Takes a string and returns the hex of the sha within.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return binascii.hexlify(sha)</span>

<span class="w"> </span>def hex_to_sha(hex):
<span class="w"> </span>    &quot;&quot;&quot;Takes a hex sha and returns a binary sha.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return binascii.unhexlify(hex)</span>

<span class="w"> </span>def hex_to_filename(path, hex):
<span class="w"> </span>    &quot;&quot;&quot;Takes a hex sha and returns its filename relative to the given path.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dir = os.path.join(path, hex[:2])</span>
<span class="gi">+    return os.path.join(dir, hex[2:])</span>

<span class="w"> </span>def filename_to_hex(filename):
<span class="w"> </span>    &quot;&quot;&quot;Takes an object filename and returns its corresponding hex sha.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if os.path.sep != &#39;/&#39;:</span>
<span class="gi">+        filename = filename.replace(os.path.sep, &#39;/&#39;)</span>
<span class="gi">+    base = os.path.basename(filename)</span>
<span class="gi">+    dir = os.path.basename(os.path.dirname(filename))</span>
<span class="gi">+    return dir + base</span>

<span class="w"> </span>def object_header(num_type: int, length: int) -&gt; bytes:
<span class="w"> </span>    &quot;&quot;&quot;Return an object header for the given numeric type and text length.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (&#39;%s %d\0&#39; % (object_class(num_type).type_name.decode(&#39;ascii&#39;), length)).encode(&#39;ascii&#39;)</span>

<span class="w"> </span>def serializable_property(name: str, docstring: Optional[str]=None):
<span class="w"> </span>    &quot;&quot;&quot;A property that helps tracking whether serialization is necessary.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def set(obj, value):</span>
<span class="gi">+        setattr(obj, &#39;_&#39; + name, value)</span>
<span class="gi">+        obj._needs_serialization = True</span>
<span class="gi">+</span>
<span class="gi">+    def get(obj):</span>
<span class="gi">+        return getattr(obj, &#39;_&#39; + name)</span>
<span class="gi">+</span>
<span class="gi">+    return property(get, set, doc=docstring)</span>

<span class="w"> </span>def object_class(type: Union[bytes, int]) -&gt; Optional[Type[&#39;ShaFile&#39;]]:
<span class="w"> </span>    &quot;&quot;&quot;Get the object class corresponding to the given type.
<span class="gu">@@ -74,7 +86,33 @@ def object_class(type: Union[bytes, int]) -&gt; Optional[Type[&#39;ShaFile&#39;]]:</span>
<span class="w"> </span>    Returns: The ShaFile subclass corresponding to the given type, or None if
<span class="w"> </span>        type is not a valid type name/number.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(type, int):</span>
<span class="gi">+        for cls in (Blob, Tree, Commit, Tag):</span>
<span class="gi">+            if cls.type_num == type:</span>
<span class="gi">+                return cls</span>
<span class="gi">+        return None</span>
<span class="gi">+    elif isinstance(type, bytes):</span>
<span class="gi">+        for cls in (Blob, Tree, Commit, Tag):</span>
<span class="gi">+            if cls.type_name == type:</span>
<span class="gi">+                return cls</span>
<span class="gi">+        return None</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&quot;type must be bytes or int&quot;)</span>
<span class="gi">+</span>
<span class="gi">+def valid_hexsha(hex):</span>
<span class="gi">+    &quot;&quot;&quot;Check if a string is a valid hex sha string.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      hex: Hex string to check</span>
<span class="gi">+    Returns: bool indicating whether the string is valid</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if len(hex) != 40:</span>
<span class="gi">+        return False</span>
<span class="gi">+    try:</span>
<span class="gi">+        int(hex, 16)</span>
<span class="gi">+        return True</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return False</span>

<span class="w"> </span>def check_hexsha(hex, error_msg):
<span class="w"> </span>    &quot;&quot;&quot;Check if a string is a valid hex sha string.
<span class="gu">@@ -85,7 +123,8 @@ def check_hexsha(hex, error_msg):</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      ObjectFormatException: Raised when the string is not valid
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not valid_hexsha(hex):</span>
<span class="gi">+        raise ObjectFormatException(error_msg)</span>

<span class="w"> </span>def check_identity(identity: bytes, error_msg: str) -&gt; None:
<span class="w"> </span>    &quot;&quot;&quot;Check if the specified identity is valid.
<span class="gu">@@ -96,7 +135,14 @@ def check_identity(identity: bytes, error_msg: str) -&gt; None:</span>
<span class="w"> </span>      identity: Identity string
<span class="w"> </span>      error_msg: Error message to use in exception
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        email_start = identity.index(b&quot; &lt;&quot;)</span>
<span class="gi">+        email_end = identity.index(b&quot;&gt;&quot;, email_start)</span>
<span class="gi">+        if email_end + 1 != len(identity):</span>
<span class="gi">+            if identity[email_end + 1:].strip() != b&quot;&quot;:</span>
<span class="gi">+                raise ValueError</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise ObjectFormatException(error_msg)</span>

<span class="w"> </span>def check_time(time_seconds):
<span class="w"> </span>    &quot;&quot;&quot;Check if the specified time is not prone to overflow error.
<span class="gu">@@ -107,11 +153,12 @@ def check_time(time_seconds):</span>
<span class="w"> </span>      time_seconds: time in seconds

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if time_seconds &gt; MAX_TIME:</span>
<span class="gi">+        raise ObjectFormatException(&quot;Date field is too large to fit in a 32-bit signed integer&quot;)</span>

<span class="w"> </span>def git_line(*items):
<span class="w"> </span>    &quot;&quot;&quot;Formats items into a space separated line.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return b&quot; &quot;.join(items) + b&quot;\n&quot;</span>

<span class="w"> </span>class FixedSha:
<span class="w"> </span>    &quot;&quot;&quot;SHA object that behaves like hashlib&#39;s but is given a fixed value.&quot;&quot;&quot;
<span class="gu">@@ -127,11 +174,11 @@ class FixedSha:</span>

<span class="w"> </span>    def digest(self) -&gt; bytes:
<span class="w"> </span>        &quot;&quot;&quot;Return the raw SHA digest.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._sha</span>

<span class="w"> </span>    def hexdigest(self) -&gt; str:
<span class="w"> </span>        &quot;&quot;&quot;Return the hex SHA digest.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._hexsha.decode(&#39;ascii&#39;)</span>

<span class="w"> </span>class ShaFile:
<span class="w"> </span>    &quot;&quot;&quot;A git SHA file.&quot;&quot;&quot;
<span class="gu">@@ -321,6 +368,25 @@ class Blob(ShaFile):</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self._chunked_text = []
<span class="w"> </span>        self._needs_serialization = False
<span class="gi">+</span>
<span class="gi">+    def _get_data(self) -&gt; bytes:</span>
<span class="gi">+        &quot;&quot;&quot;Get blob data.&quot;&quot;&quot;</span>
<span class="gi">+        return b&#39;&#39;.join(self._chunked_text)</span>
<span class="gi">+</span>
<span class="gi">+    def _set_data(self, data: bytes) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Set blob data.&quot;&quot;&quot;</span>
<span class="gi">+        self._chunked_text = [data]</span>
<span class="gi">+        self._needs_serialization = False</span>
<span class="gi">+</span>
<span class="gi">+    def _get_chunked(self) -&gt; List[bytes]:</span>
<span class="gi">+        &quot;&quot;&quot;Get blob data as chunks.&quot;&quot;&quot;</span>
<span class="gi">+        return self._chunked_text</span>
<span class="gi">+</span>
<span class="gi">+    def _set_chunked(self, chunks: List[bytes]) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Set blob data as chunks.&quot;&quot;&quot;</span>
<span class="gi">+        self._chunked_text = chunks</span>
<span class="gi">+        self._needs_serialization = False</span>
<span class="gi">+</span>
<span class="w"> </span>    data = property(_get_data, _set_data, doc=&#39;The text contained within the blob object.&#39;)
<span class="w"> </span>    chunked = property(_get_chunked, _set_chunked, doc=&#39;The text in the blob object, as chunks (not necessarily lines)&#39;)

<span class="gu">@@ -330,14 +396,14 @@ class Blob(ShaFile):</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          ObjectFormatException: if the object is malformed in some way
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        super().check()</span>

<span class="w"> </span>    def splitlines(self) -&gt; List[bytes]:
<span class="w"> </span>        &quot;&quot;&quot;Return list of lines in this blob.

<span class="w"> </span>        This preserves the original line endings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.data.split(b&#39;\n&#39;)</span>

<span class="w"> </span>def _parse_message(chunks: Iterable[bytes]) -&gt; Iterator[Union[Tuple[None, None], Tuple[Optional[bytes], bytes]]]:
<span class="w"> </span>    &quot;&quot;&quot;Parse a message with a list of fields and a body.
<span class="gu">@@ -382,7 +448,18 @@ class Tag(ShaFile):</span>

<span class="w"> </span>        Returns: tuple of (object class, sha).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (self._object_class, self._object_sha)</span>
<span class="gi">+</span>
<span class="gi">+    def _set_object(self, value):</span>
<span class="gi">+        &quot;&quot;&quot;Set the object pointed to by this tag.</span>
<span class="gi">+</span>
<span class="gi">+        Args:</span>
<span class="gi">+          value: Tuple of (object class, sha)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        self._object_class = value[0]</span>
<span class="gi">+        self._object_sha = value[1]</span>
<span class="gi">+        self._needs_serialization = True</span>
<span class="gi">+</span>
<span class="w"> </span>    object = property(_get_object, _set_object)
<span class="w"> </span>    name = serializable_property(&#39;name&#39;, &#39;The name of this tag&#39;)
<span class="w"> </span>    tagger = serializable_property(&#39;tagger&#39;, &#39;Returns the name of the person who created this tag&#39;)
<span class="gh">diff --git a/dulwich/pack.py b/dulwich/pack.py</span>
<span class="gh">index bbd1b188..cb78ea2b 100644</span>
<span class="gd">--- a/dulwich/pack.py</span>
<span class="gi">+++ b/dulwich/pack.py</span>
<span class="gu">@@ -168,6 +168,59 @@ class UnpackedObject:</span>
<span class="w"> </span>        return &#39;{}({})&#39;.format(self.__class__.__name__, &#39;, &#39;.join(data))
<span class="w"> </span>_ZLIB_BUFSIZE = 4096

<span class="gi">+def _encode_copy_operation(offset: int, length: int) -&gt; bytes:</span>
<span class="gi">+    &quot;&quot;&quot;Encode a copy operation.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      offset: Offset to copy from</span>
<span class="gi">+      length: Length of data to copy</span>
<span class="gi">+    Returns: Encoded copy operation</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    ret = []</span>
<span class="gi">+    cmd = 0x80</span>
<span class="gi">+    for i, value in enumerate([offset, length]):</span>
<span class="gi">+        cmd |= (value &amp; 0x7f) &lt;&lt; (i * 4)</span>
<span class="gi">+        value &gt;&gt;= 7</span>
<span class="gi">+        while value:</span>
<span class="gi">+            ret.append(value &amp; 0x7f | 0x80)</span>
<span class="gi">+            value &gt;&gt;= 7</span>
<span class="gi">+    ret.insert(0, cmd)</span>
<span class="gi">+    return bytes(ret)</span>
<span class="gi">+</span>
<span class="gi">+def _delta_encode_size(size: int) -&gt; bytes:</span>
<span class="gi">+    &quot;&quot;&quot;Encode size as a git variable length number.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      size: Integer to encode</span>
<span class="gi">+    Returns: Encoded size</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    ret = []</span>
<span class="gi">+    c = size &amp; 0x7f</span>
<span class="gi">+    size &gt;&gt;= 7</span>
<span class="gi">+    while size:</span>
<span class="gi">+        ret.append(c | 0x80)</span>
<span class="gi">+        c = size &amp; 0x7f</span>
<span class="gi">+        size &gt;&gt;= 7</span>
<span class="gi">+    ret.append(c)</span>
<span class="gi">+    return bytes(ret)</span>
<span class="gi">+</span>
<span class="gi">+def full_unpacked_object(unpacked: UnpackedObject) -&gt; UnpackedObject:</span>
<span class="gi">+    &quot;&quot;&quot;Return a full copy of an UnpackedObject with all deltas resolved.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      unpacked: An UnpackedObject to resolve deltas for.</span>
<span class="gi">+    Returns: A copy of the UnpackedObject with all deltas resolved.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if unpacked.pack_type_num not in DELTA_TYPES:</span>
<span class="gi">+        return unpacked</span>
<span class="gi">+    if unpacked.obj_type_num is None or unpacked.obj_chunks is None:</span>
<span class="gi">+        raise UnresolvedDeltas([unpacked.sha()])</span>
<span class="gi">+    return UnpackedObject(</span>
<span class="gi">+        unpacked.obj_type_num,</span>
<span class="gi">+        decomp_chunks=unpacked.obj_chunks,</span>
<span class="gi">+        sha=unpacked._sha,</span>
<span class="gi">+        offset=unpacked.offset)</span>
<span class="gi">+</span>
<span class="w"> </span>def read_zlib_chunks(read_some: Callable[[int], bytes], unpacked: UnpackedObject, include_comp: bool=False, buffer_size: int=_ZLIB_BUFSIZE) -&gt; bytes:
<span class="w"> </span>    &quot;&quot;&quot;Read zlib data from a buffer.

<span class="gu">@@ -192,7 +245,40 @@ def read_zlib_chunks(read_some: Callable[[int], bytes], unpacked: UnpackedObject</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      zlib.error: if a decompression error occurred.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if include_comp:</span>
<span class="gi">+        comp_chunks = []</span>
<span class="gi">+        unpacked.comp_chunks = comp_chunks</span>
<span class="gi">+    else:</span>
<span class="gi">+        comp_chunks = None</span>
<span class="gi">+    decomp_chunks = unpacked.decomp_chunks</span>
<span class="gi">+    decomp_len = 0</span>
<span class="gi">+    crc32 = unpacked.crc32</span>
<span class="gi">+</span>
<span class="gi">+    # Start streaming the data to zlib</span>
<span class="gi">+    d = zlib.decompressobj()</span>
<span class="gi">+    while True:</span>
<span class="gi">+        add_data = read_some(buffer_size)</span>
<span class="gi">+        if not add_data:</span>
<span class="gi">+            break</span>
<span class="gi">+        if comp_chunks is not None:</span>
<span class="gi">+            comp_chunks.append(add_data)</span>
<span class="gi">+        if crc32 is not None:</span>
<span class="gi">+            crc32 = zlib.crc32(add_data, crc32)</span>
<span class="gi">+        decomp = d.decompress(add_data)</span>
<span class="gi">+        decomp_len += len(decomp)</span>
<span class="gi">+        decomp_chunks.append(decomp)</span>
<span class="gi">+        if d.unused_data:</span>
<span class="gi">+            leftover = d.unused_data</span>
<span class="gi">+            if comp_chunks is not None:</span>
<span class="gi">+                comp_chunks[-1] = add_data[:-len(leftover)]</span>
<span class="gi">+            if crc32 is not None:</span>
<span class="gi">+                crc32 = zlib.crc32(add_data[:-len(leftover)], crc32)</span>
<span class="gi">+            break</span>
<span class="gi">+    else:</span>
<span class="gi">+        leftover = b&#39;&#39;</span>
<span class="gi">+    unpacked.decomp_len = decomp_len</span>
<span class="gi">+    unpacked.crc32 = crc32</span>
<span class="gi">+    return leftover</span>

<span class="w"> </span>def iter_sha1(iter):
<span class="w"> </span>    &quot;&quot;&quot;Return the hexdigest of the SHA1 over a set of names.
<span class="gh">diff --git a/dulwich/protocol.py b/dulwich/protocol.py</span>
<span class="gh">index 761853e4..5a9a08be 100644</span>
<span class="gd">--- a/dulwich/protocol.py</span>
<span class="gi">+++ b/dulwich/protocol.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Generic functions for talking the git smart server protocol.&quot;&quot;&quot;
<span class="w"> </span>from io import BytesIO
<span class="w"> </span>from os import SEEK_END
<span class="gi">+from typing import Dict, List, Optional, Tuple</span>
<span class="w"> </span>import dulwich
<span class="w"> </span>from .errors import GitProtocolError, HangupException
<span class="w"> </span>TCP_GIT_PORT = 9418
<span class="gu">@@ -50,6 +51,20 @@ COMMAND_DONE = b&#39;done&#39;</span>
<span class="w"> </span>COMMAND_WANT = b&#39;want&#39;
<span class="w"> </span>COMMAND_HAVE = b&#39;have&#39;

<span class="gi">+def agent_string():</span>
<span class="gi">+    &quot;&quot;&quot;Return a string identifying this agent.</span>
<span class="gi">+</span>
<span class="gi">+    Returns: String identifying this agent.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    return f&quot;dulwich/{&#39;.&#39;.join(str(x) for x in dulwich.__version__)}&quot;</span>
<span class="gi">+</span>
<span class="gi">+def capability_agent():</span>
<span class="gi">+    &quot;&quot;&quot;Return agent capability string.</span>
<span class="gi">+</span>
<span class="gi">+    Returns: String describing agent capability.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    return CAPABILITY_AGENT + b&#39;=&#39; + agent_string().encode(&#39;ascii&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>def pkt_line(data):
<span class="w"> </span>    &quot;&quot;&quot;Wrap data in a pkt-line.

<span class="gu">@@ -58,7 +73,9 @@ def pkt_line(data):</span>
<span class="w"> </span>    Returns: The data prefixed with its length in pkt-line format; if data was
<span class="w"> </span>        None, returns the flush-pkt (&#39;0000&#39;).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if data is None:</span>
<span class="gi">+        return b&#39;0000&#39;</span>
<span class="gi">+    return (&#39;%04x&#39; % (len(data) + 4)).encode(&#39;ascii&#39;) + data</span>

<span class="w"> </span>class Protocol:
<span class="w"> </span>    &quot;&quot;&quot;Class for interacting with a remote git process over the wire.
<span class="gu">@@ -184,6 +201,96 @@ class ReceivableProtocol(Protocol):</span>
<span class="w"> </span>        self._rbuf = BytesIO()
<span class="w"> </span>        self._rbufsize = rbufsize

<span class="gi">+def parse_capability(capability: bytes) -&gt; Tuple[bytes, Optional[bytes]]:</span>
<span class="gi">+    &quot;&quot;&quot;Parse a capability string.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      capability: Capability string</span>
<span class="gi">+    Returns: Tuple of (capability name, optional value)</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    parts = capability.split(b&#39;=&#39;, 1)</span>
<span class="gi">+    if len(parts) == 1:</span>
<span class="gi">+        return parts[0], None</span>
<span class="gi">+    return parts[0], parts[1]</span>
<span class="gi">+</span>
<span class="gi">+def format_capability_line(name: bytes, value: Optional[bytes]=None) -&gt; bytes:</span>
<span class="gi">+    &quot;&quot;&quot;Format a capability line.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      name: Capability name</span>
<span class="gi">+      value: Optional capability value</span>
<span class="gi">+    Returns: Capability line</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        return name</span>
<span class="gi">+    return name + b&#39;=&#39; + value</span>
<span class="gi">+</span>
<span class="gi">+def format_ref_line(name: bytes, sha: bytes, capabilities: Optional[List[bytes]]=None) -&gt; bytes:</span>
<span class="gi">+    &quot;&quot;&quot;Format a ref line.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      name: Name of the ref</span>
<span class="gi">+      sha: SHA1 of the ref</span>
<span class="gi">+      capabilities: Optional list of capabilities</span>
<span class="gi">+    Returns: Ref line</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if capabilities:</span>
<span class="gi">+        return sha + b&#39;\x00&#39; + b&#39; &#39;.join(capabilities) + b&#39; &#39; + name + b&#39;\n&#39;</span>
<span class="gi">+    return sha + b&#39; &#39; + name + b&#39;\n&#39;</span>
<span class="gi">+</span>
<span class="gi">+def format_shallow_line(sha: bytes) -&gt; bytes:</span>
<span class="gi">+    &quot;&quot;&quot;Format a shallow line.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      sha: SHA1 to mark as shallow</span>
<span class="gi">+    Returns: Shallow line</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    return b&#39;shallow &#39; + sha + b&#39;\n&#39;</span>
<span class="gi">+</span>
<span class="gi">+def format_unshallow_line(sha: bytes) -&gt; bytes:</span>
<span class="gi">+    &quot;&quot;&quot;Format an unshallow line.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      sha: SHA1 to mark as unshallow</span>
<span class="gi">+    Returns: Unshallow line</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    return b&#39;unshallow &#39; + sha + b&#39;\n&#39;</span>
<span class="gi">+</span>
<span class="gi">+def symref_capabilities(refs: Dict[bytes, bytes]) -&gt; List[bytes]:</span>
<span class="gi">+    &quot;&quot;&quot;Get symref capabilities for a set of refs.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      refs: Dict of refs to get capabilities for</span>
<span class="gi">+    Returns: List of symref capabilities</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    ret = []</span>
<span class="gi">+    for name, target in refs.items():</span>
<span class="gi">+        if name.startswith(SYMREF):</span>
<span class="gi">+            ret.append(CAPABILITY_SYMREF + b&#39;=&#39; + name[len(SYMREF):] + b&#39;:&#39; + target)</span>
<span class="gi">+    return ret</span>
<span class="gi">+</span>
<span class="gi">+def format_ack_line(sha: bytes, ack_type: bytes=b&#39;&#39;, line_end: bytes=b&#39;\n&#39;) -&gt; bytes:</span>
<span class="gi">+    &quot;&quot;&quot;Format an ack line.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      sha: SHA1 to ack</span>
<span class="gi">+      ack_type: Optional ack type</span>
<span class="gi">+      line_end: Optional line ending</span>
<span class="gi">+    Returns: Ack line</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if ack_type:</span>
<span class="gi">+        return b&#39;ACK &#39; + sha + b&#39; &#39; + ack_type + line_end</span>
<span class="gi">+    return b&#39;ACK &#39; + sha + line_end</span>
<span class="gi">+</span>
<span class="gi">+def extract_capability_names(capabilities):</span>
<span class="gi">+    &quot;&quot;&quot;Extract capability names from a capabilities list.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      capabilities: List of capabilities as bytes</span>
<span class="gi">+    Returns: List of capability names as bytes</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    return [c.split(b&#39;=&#39;, 1)[0] for c in capabilities]</span>
<span class="gi">+</span>
<span class="w"> </span>def extract_capabilities(text):
<span class="w"> </span>    &quot;&quot;&quot;Extract a capabilities list from a string, if present.

<span class="gu">@@ -191,7 +298,10 @@ def extract_capabilities(text):</span>
<span class="w"> </span>      text: String to extract from
<span class="w"> </span>    Returns: Tuple with text with capabilities removed and list of capabilities
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not text.endswith(b&#39;\0&#39;):</span>
<span class="gi">+        return text, []</span>
<span class="gi">+    text, capabilities = text[:-1].split(b&#39;\0&#39;, 1)</span>
<span class="gi">+    return text, capabilities.split(b&#39; &#39;)</span>

<span class="w"> </span>def extract_want_line_capabilities(text):
<span class="w"> </span>    &quot;&quot;&quot;Extract a capabilities list from a want line, if present.
<span class="gh">diff --git a/dulwich/refs.py b/dulwich/refs.py</span>
<span class="gh">index 27ab6d1f..108c48de 100644</span>
<span class="gd">--- a/dulwich/refs.py</span>
<span class="gi">+++ b/dulwich/refs.py</span>
<span class="gu">@@ -460,14 +460,98 @@ def write_packed_refs(f, packed_refs, peeled_refs=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    pass

<span class="gd">-def write_info_refs(refs, store: ObjectContainer):</span>
<span class="gi">+def read_info_refs(f) -&gt; Dict[bytes, bytes]:</span>
<span class="gi">+    &quot;&quot;&quot;Read info refs file.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      f: File-like object to read from</span>
<span class="gi">+    Returns: Dict mapping ref names to SHA1s</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    ret = {}</span>
<span class="gi">+    for line in f:</span>
<span class="gi">+        if not line.strip():</span>
<span class="gi">+            continue</span>
<span class="gi">+        sha, name = line.rstrip(b&#39;\n&#39;).split(b&#39;\t&#39;)</span>
<span class="gi">+        if name.endswith(PEELED_TAG_SUFFIX):</span>
<span class="gi">+            name = name[:-3]</span>
<span class="gi">+        ret[name] = sha</span>
<span class="gi">+    return ret</span>
<span class="gi">+</span>
<span class="gi">+def write_info_refs(refs, store: ObjectContainer) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate info refs.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ret = []</span>
<span class="gi">+    for name, sha in sorted(refs.items()):</span>
<span class="gi">+        ret.append(git_line(sha, name))</span>
<span class="gi">+        if name.startswith(LOCAL_TAG_PREFIX):</span>
<span class="gi">+            try:</span>
<span class="gi">+                obj = store[sha]</span>
<span class="gi">+                if obj.type_name == b&#39;tag&#39;:</span>
<span class="gi">+                    ret.append(git_line(obj.object[1], name + PEELED_TAG_SUFFIX))</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+    return b&#39;&#39;.join(ret)</span>
<span class="gi">+</span>
<span class="gi">+def _import_remote_refs(refs: Dict[bytes, bytes], remote_refs: Dict[bytes, bytes], base: bytes) -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Import refs from remote repository.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      refs: Dict to add remote refs to</span>
<span class="gi">+      remote_refs: Dict with remote refs</span>
<span class="gi">+      base: Base prefix to add to remote refs</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    for name, value in remote_refs.items():</span>
<span class="gi">+        refs[base + b&#39;/&#39; + name] = value</span>
<span class="gi">+</span>
<span class="gi">+def serialize_refs(refs: Dict[bytes, bytes]) -&gt; bytes:</span>
<span class="gi">+    &quot;&quot;&quot;Serialize refs into a string.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      refs: Dict of refs to serialize</span>
<span class="gi">+    Returns: Serialized refs as bytes</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    ret = []</span>
<span class="gi">+    for name, value in sorted(refs.items()):</span>
<span class="gi">+        ret.append(git_line(value, name))</span>
<span class="gi">+    return b&#39;&#39;.join(ret)</span>

<span class="w"> </span>def strip_peeled_refs(refs):
<span class="w"> </span>    &quot;&quot;&quot;Remove all peeled refs.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return {k: v for k, v in refs.items() if not k.endswith(PEELED_TAG_SUFFIX)}</span>
<span class="gi">+</span>
<span class="gi">+def _set_head(refs: RefsContainer, target: bytes, ref_message: Optional[bytes]=None) -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Set HEAD to point at target.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      refs: RefsContainer to set HEAD in</span>
<span class="gi">+      target: Target to point HEAD at</span>
<span class="gi">+      ref_message: Optional reflog message</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    refs.set_symbolic_ref(HEADREF, target, message=ref_message)</span>
<span class="gi">+</span>
<span class="gi">+def _set_origin_head(refs: RefsContainer, origin: bytes, origin_head: bytes, ref_message: Optional[bytes]=None) -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Set origin HEAD.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      refs: RefsContainer to set origin HEAD in</span>
<span class="gi">+      origin: Origin name</span>
<span class="gi">+      origin_head: Origin HEAD target</span>
<span class="gi">+      ref_message: Optional reflog message</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    ref = LOCAL_REMOTE_PREFIX + origin + b&#39;/&#39; + HEADREF</span>
<span class="gi">+    refs.set_symbolic_ref(ref, origin_head, message=ref_message)</span>

<span class="w"> </span>def _set_default_branch(refs: RefsContainer, origin: bytes, origin_head: bytes, branch: bytes, ref_message: Optional[bytes]) -&gt; bytes:
<span class="gd">-    &quot;&quot;&quot;Set the default branch.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    &quot;&quot;&quot;Set the default branch.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      refs: RefsContainer to set default branch in</span>
<span class="gi">+      origin: Origin name</span>
<span class="gi">+      origin_head: Origin HEAD target</span>
<span class="gi">+      branch: Branch name</span>
<span class="gi">+      ref_message: Optional reflog message</span>
<span class="gi">+    Returns: Default branch name</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    _set_head(refs, branch, ref_message)</span>
<span class="gi">+    if origin and origin_head:</span>
<span class="gi">+        _set_origin_head(refs, origin, origin_head, ref_message)</span>
<span class="gi">+    return branch</span>
\ No newline at end of file
<span class="gh">diff --git a/dulwich/web.py b/dulwich/web.py</span>
<span class="gh">index bb7bf698..44b4426a 100644</span>
<span class="gd">--- a/dulwich/web.py</span>
<span class="gi">+++ b/dulwich/web.py</span>
<span class="gu">@@ -27,7 +27,13 @@ def url_prefix(mat) -&gt; str:</span>
<span class="w"> </span>        original string. Normalized to start with one leading slash and end
<span class="w"> </span>        with zero.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    prefix = mat.string[0:mat.start()]</span>
<span class="gi">+    n = len(prefix)</span>
<span class="gi">+    if n == 0 or prefix[0] != &#39;/&#39;:</span>
<span class="gi">+        prefix = &#39;/&#39; + prefix</span>
<span class="gi">+    if n &gt; 0 and prefix[n - 1] == &#39;/&#39;:</span>
<span class="gi">+        prefix = prefix[0:n - 1]</span>
<span class="gi">+    return prefix</span>

<span class="w"> </span>def get_repo(backend, mat) -&gt; BaseRepo:
<span class="w"> </span>    &quot;&quot;&quot;Get a Repo instance for the given backend and URL regex match.&quot;&quot;&quot;
<span class="gu">@@ -193,6 +199,141 @@ class WSGIServerLogger(WSGIServer):</span>
<span class="w"> </span>        &quot;&quot;&quot;Handle an error.&quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gi">+def get_text_file(req: HTTPGitRequest, backend: Backend, mat: re.Match) -&gt; Iterator[bytes]:</span>
<span class="gi">+    &quot;&quot;&quot;Get a text file from the repository.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      req: The HTTPGitRequest object.</span>
<span class="gi">+      backend: The backend object.</span>
<span class="gi">+      mat: The regex match object.</span>
<span class="gi">+    Returns: An iterator over the file contents.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    repo = get_repo(backend, mat)</span>
<span class="gi">+    path = mat.group(0).lstrip(&#39;/&#39;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        with repo.get_named_file(path) as f:</span>
<span class="gi">+            return send_file(req, f, &#39;text/plain&#39;)</span>
<span class="gi">+    except (KeyError, IOError):</span>
<span class="gi">+        yield req.not_found(&#39;Object not found&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def get_info_refs(req: HTTPGitRequest, backend: Backend, mat: re.Match) -&gt; Iterator[bytes]:</span>
<span class="gi">+    &quot;&quot;&quot;Get info/refs, which is used for the initial git clone/fetch.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      req: The HTTPGitRequest object.</span>
<span class="gi">+      backend: The backend object.</span>
<span class="gi">+      mat: The regex match object.</span>
<span class="gi">+    Returns: An iterator over the response.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    repo = get_repo(backend, mat)</span>
<span class="gi">+    service = req.environ.get(&#39;QUERY_STRING&#39;, &#39;&#39;).startswith(&#39;service=git-&#39;) and not req.dumb</span>
<span class="gi">+    if service:</span>
<span class="gi">+        service = req.environ[&#39;QUERY_STRING&#39;].split(&#39;=&#39;, 1)[1]</span>
<span class="gi">+        handler_cls = req.handlers.get(service, None)</span>
<span class="gi">+        if handler_cls is None:</span>
<span class="gi">+            yield req.forbidden(&#39;Unsupported service&#39;)</span>
<span class="gi">+            return</span>
<span class="gi">+        req.nocache()</span>
<span class="gi">+        write = req.respond(content_type=&#39;application/x-%s-advertisement&#39; % service)</span>
<span class="gi">+        proto = ReceivableProtocol(BytesIO().read, write)</span>
<span class="gi">+        handler = handler_cls(backend, [url_prefix(mat)], proto, stateless_rpc=True, advertise_refs=True)</span>
<span class="gi">+        handler.proto.write_pkt_line(b&#39;# service=&#39; + service.encode(&#39;ascii&#39;) + b&#39;\n&#39;)</span>
<span class="gi">+        handler.proto.write_pkt_line(None)</span>
<span class="gi">+        handler.handle()</span>
<span class="gi">+    else:</span>
<span class="gi">+        req.nocache()</span>
<span class="gi">+        write = req.respond(content_type=&#39;text/plain&#39;)</span>
<span class="gi">+        refs = generate_info_refs(repo)</span>
<span class="gi">+        write(refs)</span>
<span class="gi">+        yield None</span>
<span class="gi">+</span>
<span class="gi">+def get_info_packs(req: HTTPGitRequest, backend: Backend, mat: re.Match) -&gt; Iterator[bytes]:</span>
<span class="gi">+    &quot;&quot;&quot;Get info/packs, which is used to get the pack files.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      req: The HTTPGitRequest object.</span>
<span class="gi">+      backend: The backend object.</span>
<span class="gi">+      mat: The regex match object.</span>
<span class="gi">+    Returns: An iterator over the response.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    repo = get_repo(backend, mat)</span>
<span class="gi">+    req.cache_forever()</span>
<span class="gi">+    write = req.respond(content_type=&#39;text/plain&#39;)</span>
<span class="gi">+    write(generate_objects_info_packs(repo))</span>
<span class="gi">+    yield None</span>
<span class="gi">+</span>
<span class="gi">+def get_loose_object(req: HTTPGitRequest, backend: Backend, mat: re.Match) -&gt; Iterator[bytes]:</span>
<span class="gi">+    &quot;&quot;&quot;Get a loose object from the repository.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      req: The HTTPGitRequest object.</span>
<span class="gi">+      backend: The backend object.</span>
<span class="gi">+      mat: The regex match object.</span>
<span class="gi">+    Returns: An iterator over the response.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    repo = get_repo(backend, mat)</span>
<span class="gi">+    sha = (mat.group(1) + mat.group(2)).encode(&#39;ascii&#39;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        with repo.get_raw(sha) as f:</span>
<span class="gi">+            return send_file(req, f, &#39;application/x-git-loose-object&#39;)</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        yield req.not_found(&#39;Object not found&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def get_pack_file(req: HTTPGitRequest, backend: Backend, mat: re.Match) -&gt; Iterator[bytes]:</span>
<span class="gi">+    &quot;&quot;&quot;Get a pack file from the repository.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      req: The HTTPGitRequest object.</span>
<span class="gi">+      backend: The backend object.</span>
<span class="gi">+      mat: The regex match object.</span>
<span class="gi">+    Returns: An iterator over the response.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    repo = get_repo(backend, mat)</span>
<span class="gi">+    sha = mat.group(1).encode(&#39;ascii&#39;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        with repo.get_raw_pack(sha) as f:</span>
<span class="gi">+            return send_file(req, f, &#39;application/x-git-packed-objects&#39;)</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        yield req.not_found(&#39;Object not found&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def get_idx_file(req: HTTPGitRequest, backend: Backend, mat: re.Match) -&gt; Iterator[bytes]:</span>
<span class="gi">+    &quot;&quot;&quot;Get a pack index file from the repository.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      req: The HTTPGitRequest object.</span>
<span class="gi">+      backend: The backend object.</span>
<span class="gi">+      mat: The regex match object.</span>
<span class="gi">+    Returns: An iterator over the response.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    repo = get_repo(backend, mat)</span>
<span class="gi">+    sha = mat.group(1).encode(&#39;ascii&#39;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        with repo.get_raw_pack_idx(sha) as f:</span>
<span class="gi">+            return send_file(req, f, &#39;application/x-git-packed-objects-toc&#39;)</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        yield req.not_found(&#39;Object not found&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def handle_service_request(req: HTTPGitRequest, backend: Backend, mat: re.Match) -&gt; Iterator[bytes]:</span>
<span class="gi">+    &quot;&quot;&quot;Handle a service request.</span>
<span class="gi">+</span>
<span class="gi">+    Args:</span>
<span class="gi">+      req: The HTTPGitRequest object.</span>
<span class="gi">+      backend: The backend object.</span>
<span class="gi">+      mat: The regex match object.</span>
<span class="gi">+    Returns: An iterator over the response.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    service = os.path.basename(req.environ[&#39;PATH_INFO&#39;])</span>
<span class="gi">+    handler_cls = req.handlers.get(service, None)</span>
<span class="gi">+    if handler_cls is None:</span>
<span class="gi">+        yield req.forbidden(&#39;Unsupported service&#39;)</span>
<span class="gi">+        return</span>
<span class="gi">+    input = req.environ[&#39;wsgi.input&#39;]</span>
<span class="gi">+    write = req.respond(content_type=&#39;application/x-%s-result&#39; % service)</span>
<span class="gi">+    proto = ReceivableProtocol(input.read, write)</span>
<span class="gi">+    handler = handler_cls(backend, [url_prefix(mat)], proto, stateless_rpc=True)</span>
<span class="gi">+    handler.handle()</span>
<span class="gi">+    yield None</span>
<span class="gi">+</span>
<span class="w"> </span>def main(argv=sys.argv):
<span class="w"> </span>    &quot;&quot;&quot;Entry point for starting an HTTP git server.&quot;&quot;&quot;
<span class="w"> </span>    pass
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>