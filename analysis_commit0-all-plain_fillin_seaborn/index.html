
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin seaborn - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-seaborn" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin seaborn
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_nominal_default_palette_large" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_nominal_default_palette_large
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestdodgetest_faceted_fill" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestDodge::test_faceted_fill
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestnormtest_default_no_groupsx" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestNorm::test_default_no_groups[x]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestdodgetest_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestDodge::test_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupbypytest_at_least_one_grouping_variable_required" class="md-nav__link">
    <span class="md-ellipsis">
      test_groupby.py::test_at_least_one_grouping_variable_required
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestnormtest_default_no_groupsy" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestNorm::test_default_no_groups[y]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_nominal_named_palette" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_nominal_named_palette
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestnormtest_default_groupsx" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestNorm::test_default_groups[x]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupbypytest_agg_one_grouper" class="md-nav__link">
    <span class="md-ellipsis">
      test_groupby.py::test_agg_one_grouper
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupbypytest_agg_two_groupers" class="md-nav__link">
    <span class="md-ellipsis">
      test_groupby.py::test_agg_two_groupers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestnormtest_default_groupsy" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestNorm::test_default_groups[y]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_nominal_list_palette" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_nominal_list_palette
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupbypytest_agg_two_groupers_ordered" class="md-nav__link">
    <span class="md-ellipsis">
      test_groupby.py::test_agg_two_groupers_ordered
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupbypytest_apply_no_grouper" class="md-nav__link">
    <span class="md-ellipsis">
      test_groupby.py::test_apply_no_grouper
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestnormtest_sum" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestNorm::test_sum
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_nominal_dict_palette" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_nominal_dict_palette
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestnormtest_where" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestNorm::test_where
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_nominal_dict_with_missing_keys" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_nominal_dict_with_missing_keys
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_nominal_list_too_short" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_nominal_list_too_short
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestnormtest_percent" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestNorm::test_percent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupbypytest_apply_one_grouper" class="md-nav__link">
    <span class="md-ellipsis">
      test_groupby.py::test_apply_one_grouper
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupbypytest_apply_mutate_columns" class="md-nav__link">
    <span class="md-ellipsis">
      test_groupby.py::test_apply_mutate_columns
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcoordinatetest_bad_scale_arg_str" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestCoordinate::test_bad_scale_arg_str
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupbypytest_apply_replace_columns" class="md-nav__link">
    <span class="md-ellipsis">
      test_groupby.py::test_apply_replace_columns
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_nominal_list_too_long" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_nominal_list_too_long
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcoordinatetest_bad_scale_arg_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestCoordinate::test_bad_scale_arg_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_inferenceviridis-bool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_inference[viridis-bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_nominal_default_palette" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_nominal_default_palette
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_inferencemuted-num-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_inference[muted-num-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_continuous_default_palette" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_continuous_default_palette
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_inferencevalues4-num-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_inference[values4-num-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestdodgetest_fill" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestDodge::test_fill
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestdodgetest_faceted_drop" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestDodge::test_faceted_drop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_defaultnum" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_default[num]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_continuous_named_palette" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_continuous_named_palette
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_inferencevalues5-num-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_inference[values5-num-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_defaultbool" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_default[bool]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_continuous_tuple_palette" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_continuous_tuple_palette
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_inferencevalues6-num-continuous" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_inference[values6-num-Continuous]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_inference_listcat" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_inference_list[cat]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_inference_listnum" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_inference_list[num]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_inferencevalues7-cat-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_inference[values7-cat-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_inference_listbool" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_inference_list[bool]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_inferencevalues8-bool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_inference[values8-bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_continuous_callable_palette" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_continuous_callable_palette
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_inference_dictcat" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_inference_dict[cat]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_inferencevalues9-num-continuous" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_inference[values9-num-Continuous]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_continuous_missing" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_continuous_missing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_standardization" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_standardization
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_inference_dictnum" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_inference_dict[num]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_mapping_defaultcat" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_mapping_default[cat]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_defaultnum" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_default[num]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_inference_dictbool" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_inference_dict[bool]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_mapping_defaultnum" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_mapping_default[num]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_defaultbool" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_default[bool]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_dict_missing" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_dict_missing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_inference_listcat" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_inference_list[cat]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_mapping_from_listcat" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_mapping_from_list[cat]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_inference_dictbool" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_inference_dict[bool]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_mapping_from_listnum" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_mapping_from_list[num]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_dict_missing" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_dict_missing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_mapping_from_dictcat" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_mapping_from_dict[cat]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_mapping_from_dictnum" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_mapping_from_dict[num]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_mapping_defaultcat" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_mapping_default[cat]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_inference_listnum" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_inference_list[num]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_mapping_with_null_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_mapping_with_null_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_unique_default_large_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_unique_default_large_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_inference_listbool" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_inference_list[bool]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_mapping_defaultnum" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_mapping_default[num]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestdodgetest_drop" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestDodge::test_drop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_inference_dictcat" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_inference_dict[cat]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestdodgetest_orient" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestDodge::test_orient
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_inference_dictnum" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_inference_dict[num]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_mapping_from_listcat" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_mapping_from_list[cat]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_mapping_with_null_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_mapping_with_null_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_mapping_from_listnum" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_mapping_from_list[num]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_unique_default_large_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_unique_default_large_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_mapping_from_dictcat" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_mapping_from_dict[cat]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_bad_scale_values" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_bad_scale_values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_bad_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_bad_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_bad_style" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_bad_style
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_mapping_from_dictnum" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_mapping_from_dict[num]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinestyletest_bad_dashes" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineStyle::test_bad_dashes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestfilltest_inference_dictbool" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestFill::test_inference_dict[bool]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestmarkertest_bad_scale_values" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestMarker::test_bad_scale_values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestfilltest_values_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestFill::test_values_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestfilltest_mapping_categorical_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestFill::test_mapping_categorical_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestfilltest_defaultnum" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestFill::test_default[num]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestalphatest_defaultbool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestAlpha::test_default[bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestfilltest_mapping_numeric_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestFill::test_mapping_numeric_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestfilltest_defaultbool" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestFill::test_default[bool]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestalphatest_inferencearg0-cat-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestAlpha::test_inference[arg0-cat-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestfilltest_inference_listcat" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestFill::test_inference_list[cat]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestfilltest_mapping_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestFill::test_mapping_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestfilltest_inference_listnum" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestFill::test_inference_list[num]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestalphatest_inferencearg1-num-continuous" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestAlpha::test_inference[arg1-num-Continuous]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestfilltest_mapping_truthy_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestFill::test_mapping_truthy_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestfilltest_inference_listbool" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestFill::test_inference_list[bool]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestfilltest_mapping_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestFill::test_mapping_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestalphatest_inferencearg2-bool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestAlpha::test_inference[arg2-bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestfilltest_cycle_warning" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestFill::test_cycle_warning
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestfilltest_inference_dictcat" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestFill::test_inference_dict[cat]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestdodgetest_gap" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestDodge::test_gap
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestalphatest_inferencearg8-bool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestAlpha::test_inference[arg8-bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestalphatest_inferencearg3-cat-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestAlpha::test_inference[arg3-cat-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestfilltest_inference_dictnum" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestFill::test_inference_dict[num]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestdodgetest_single_semanticgrp2" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestDodge::test_single_semantic[grp2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestalphatest_mapped_interval_numeric" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestAlpha::test_mapped_interval_numeric
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinewidthtest_defaultbool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineWidth::test_default[bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestalphatest_inferencearg4-num-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestAlpha::test_inference[arg4-num-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinewidthtest_inferencearg0-cat-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineWidth::test_inference[arg0-cat-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestalphatest_mapped_interval_categorical" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestAlpha::test_mapped_interval_categorical
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestalphatest_inferencearg5-bool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestAlpha::test_inference[arg5-bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestalphatest_bad_scale_values_numeric_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestAlpha::test_bad_scale_values_numeric_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinewidthtest_inferencearg1-num-continuous" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineWidth::test_inference[arg1-num-Continuous]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestalphatest_inferencearg6-cat-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestAlpha::test_inference[arg6-cat-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestalphatest_bad_scale_values_categorical_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestAlpha::test_bad_scale_values_categorical_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinewidthtest_inferencearg2-bool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineWidth::test_inference[arg2-bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinewidthtest_mapped_interval_numeric" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineWidth::test_mapped_interval_numeric
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestalphatest_inferencearg7-num-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestAlpha::test_inference[arg7-num-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinewidthtest_mapped_interval_categorical" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineWidth::test_mapped_interval_categorical
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinewidthtest_inferencearg3-cat-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineWidth::test_inference[arg3-cat-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinewidthtest_inferencearg4-num-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineWidth::test_inference[arg4-num-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinewidthtest_bad_scale_values_numeric_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineWidth::test_bad_scale_values_numeric_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinewidthtest_inferencearg5-bool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineWidth::test_inference[arg5-bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinewidthtest_bad_scale_values_categorical_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineWidth::test_bad_scale_values_categorical_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestedgewidthtest_defaultbool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestEdgeWidth::test_default[bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinewidthtest_rcparam_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineWidth::test_rcparam_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestedgewidthtest_inferencearg0-cat-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestEdgeWidth::test_inference[arg0-cat-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinewidthtest_inferencearg6-cat-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineWidth::test_inference[arg6-cat-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestedgewidthtest_inferencearg2-bool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestEdgeWidth::test_inference[arg2-bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestedgewidthtest_inferencearg1-num-continuous" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestEdgeWidth::test_inference[arg1-num-Continuous]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestedgewidthtest_inferencearg3-cat-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestEdgeWidth::test_inference[arg3-cat-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinewidthtest_inferencearg7-num-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineWidth::test_inference[arg7-num-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestedgewidthtest_inferencearg6-cat-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestEdgeWidth::test_inference[arg6-cat-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestedgewidthtest_inferencearg4-num-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestEdgeWidth::test_inference[arg4-num-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestlinewidthtest_inferencearg8-bool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestLineWidth::test_inference[arg8-bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestedgewidthtest_inferencearg7-num-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestEdgeWidth::test_inference[arg7-num-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestedgewidthtest_inferencearg5-bool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestEdgeWidth::test_inference[arg5-bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestedgewidthtest_mapped_interval_categorical" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestEdgeWidth::test_mapped_interval_categorical
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestedgewidthtest_inferencearg8-bool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestEdgeWidth::test_inference[arg8-bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestedgewidthtest_bad_scale_values_numeric_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestEdgeWidth::test_bad_scale_values_numeric_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestpointsizetest_defaultbool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestPointSize::test_default[bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestedgewidthtest_bad_scale_values_categorical_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestEdgeWidth::test_bad_scale_values_categorical_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestdodgetest_widths_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestDodge::test_widths_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestedgewidthtest_mapped_interval_numeric" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestEdgeWidth::test_mapped_interval_numeric
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestpointsizetest_inferencearg0-cat-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestPointSize::test_inference[arg0-cat-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestedgewidthtest_rcparam_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestEdgeWidth::test_rcparam_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestpointsizetest_inferencearg8-bool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestPointSize::test_inference[arg8-bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestpointsizetest_inferencearg1-num-continuous" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestPointSize::test_inference[arg1-num-Continuous]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestpointsizetest_inferencearg5-bool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestPointSize::test_inference[arg5-bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestpointsizetest_mapped_interval_numeric" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestPointSize::test_mapped_interval_numeric
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestdodgetest_single_semanticgrp3" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestDodge::test_single_semantic[grp3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestpointsizetest_inferencearg6-cat-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestPointSize::test_inference[arg6-cat-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestpointsizetest_inferencearg2-bool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestPointSize::test_inference[arg2-bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestpointsizetest_mapped_interval_categorical" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestPointSize::test_mapped_interval_categorical
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestpointsizetest_inferencearg7-num-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestPointSize::test_inference[arg7-num-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestpointsizetest_inferencearg3-cat-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestPointSize::test_inference[arg3-cat-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestpointsizetest_bad_scale_values_numeric_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestPointSize::test_bad_scale_values_numeric_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestpointsizetest_bad_scale_values_categorical_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestPointSize::test_bad_scale_values_categorical_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestpointsizetest_areal_scaling_categorical" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestPointSize::test_areal_scaling_categorical
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestpointsizetest_inferencearg4-num-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestPointSize::test_inference[arg4-num-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rulespytest_categorical_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_rules.py::test_categorical_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rulespytest_variable_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_rules.py::test_variable_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestpointsizetest_areal_scaling_numeric" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestPointSize::test_areal_scaling_numeric
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestspecificationcheckstest_both_facets_and_wrap" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSpecificationChecks::test_both_facets_and_wrap
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestspecificationcheckstest_wrapped_columns_and_y_pairing" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSpecificationChecks::test_wrapped_columns_and_y_pairing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotspectest_single_subplot" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotSpec::test_single_subplot
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestspecificationcheckstest_wrapped_x_pairing_and_facetd_rows" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSpecificationChecks::test_wrapped_x_pairing_and_facetd_rows
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestspecificationcheckstest_cross_xy_pairing_and_wrap" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSpecificationChecks::test_cross_xy_pairing_and_wrap
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotspectest_single_facet" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotSpec::test_single_facet
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotspectest_two_facets" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotSpec::test_two_facets
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestspecificationcheckstest_col_facets_and_x_pairing" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSpecificationChecks::test_col_facets_and_x_pairing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotspectest_col_facet_wrapped" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotSpec::test_col_facet_wrapped
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotspectest_row_facet_wrapped" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotSpec::test_row_facet_wrapped
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotspectest_x_paired" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotSpec::test_x_paired
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotspectest_col_facet_wrapped_single_row" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotSpec::test_col_facet_wrapped_single_row
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotspectest_x_and_y_paired" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotSpec::test_x_and_y_paired
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotspectest_y_paired" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotSpec::test_y_paired
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotspectest_y_paired_and_wrapped" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotSpec::test_y_paired_and_wrapped
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotspectest_x_paired_and_wrapped" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotSpec::test_x_paired_and_wrapped
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotspectest_y_paired_and_wrapped_single_row" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotSpec::test_y_paired_and_wrapped_single_row
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotspectest_col_faceted_y_paired" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotSpec::test_col_faceted_y_paired
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotspectest_row_faceted_x_paired" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotSpec::test_row_faceted_x_paired
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotspectest_x_any_y_paired_non_cross" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotSpec::test_x_any_y_paired_non_cross
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotspectest_x_any_y_paired_non_cross_wrapped" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotSpec::test_x_any_y_paired_non_cross_wrapped
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotelementstest_single_facet_dimrow" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotElements::test_single_facet_dim[row]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotelementstest_single_subplot" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotElements::test_single_subplot
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotelementstest_single_facet_dimcol" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotElements::test_single_facet_dim[col]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotelementstest_single_facet_dim_wrappedcol" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotElements::test_single_facet_dim_wrapped[col]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotelementstest_both_facet_dims" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotElements::test_both_facet_dims
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotelementstest_single_facet_dim_wrappedrow" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotElements::test_single_facet_dim_wrapped[row]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotelementstest_single_paired_varx" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotElements::test_single_paired_var[x]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotelementstest_single_paired_vary" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotElements::test_single_paired_var[y]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotelementstest_single_paired_var_wrappedx" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotElements::test_single_paired_var_wrapped[x]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotelementstest_single_paired_var_wrappedy" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotElements::test_single_paired_var_wrapped[y]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotelementstest_both_paired_non_cross" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotElements::test_both_paired_non_cross
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotelementstest_both_paired_variables" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotElements::test_both_paired_variables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotelementstest_one_facet_one_pairedcol-y" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotElements::test_one_facet_one_paired[col-y]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_subplotspytestsubplotelementstest_one_facet_one_pairedrow-x" class="md-nav__link">
    <span class="md-ellipsis">
      test_subplots.py::TestSubplotElements::test_one_facet_one_paired[row-x]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestdodgetest_widths_fill" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestDodge::test_widths_fill
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestdodgetest_two_semantics" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestDodge::test_two_semantics
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestdodgetest_widths_drop" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestDodge::test_widths_drop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespyteststacktest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestStack::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespyteststacktest_faceted" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestStack::test_faceted
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespyteststacktest_misssing_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestStack::test_misssing_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespyteststacktest_baseline_homogeneity_check" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestStack::test_baseline_homogeneity_check
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_movespytestdodgetest_faceted_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_moves.py::TestDodge::test_faceted_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_bad_scale_values_continuous" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_bad_scale_values_continuous
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_bad_scale_values_nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_bad_scale_values_nominal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_bad_inference_arg" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_bad_inference_arg
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_defaultbool-boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_default[bool-Boolean]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_inferenceviridis-cat-nominal" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_inference[viridis-cat-Nominal]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propertiespytestcolortest_inferenceviridis-num-continuous" class="md-nav__link">
    <span class="md-ellipsis">
      test_properties.py::TestColor::test_inference[viridis-num-Continuous]
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-seaborn"><strong>Claude Sonnet 3.5 - Fill-in</strong>: seaborn</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">214</td>
</tr>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">29</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">243</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">243</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_propertiespytestcolortest_nominal_default_palette_large">test_properties.py::TestColor::test_nominal_default_palette_large</h3>
<details><summary> <pre>test_properties.py::TestColor::test_nominal_default_palette_large</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestdodgetest_faceted_fill">test_moves.py::TestDodge::test_faceted_fill</h3>
<details><summary> <pre>test_moves.py::TestDodge::test_faceted_fill</pre></summary><pre>
[gw2] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestnormtest_default_no_groupsx">test_moves.py::TestNorm::test_default_no_groups[x]</h3>
<details><summary> <pre>test_moves.py::TestNorm::test_default_no_groups[x]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestdodgetest_default">test_moves.py::TestDodge::test_default</h3>
<details><summary> <pre>test_moves.py::TestDodge::test_default</pre></summary><pre>
[gw0] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_groupbypytest_at_least_one_grouping_variable_required">test_groupby.py::test_at_least_one_grouping_variable_required</h3>
<details><summary> <pre>test_groupby.py::test_at_least_one_grouping_variable_required</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestnormtest_default_no_groupsy">test_moves.py::TestNorm::test_default_no_groups[y]</h3>
<details><summary> <pre>test_moves.py::TestNorm::test_default_no_groups[y]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_nominal_named_palette">test_properties.py::TestColor::test_nominal_named_palette</h3>
<details><summary> <pre>test_properties.py::TestColor::test_nominal_named_palette</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestnormtest_default_groupsx">test_moves.py::TestNorm::test_default_groups[x]</h3>
<details><summary> <pre>test_moves.py::TestNorm::test_default_groups[x]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_groupbypytest_agg_one_grouper">test_groupby.py::test_agg_one_grouper</h3>
<details><summary> <pre>test_groupby.py::test_agg_one_grouper</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_groupbypytest_agg_two_groupers">test_groupby.py::test_agg_two_groupers</h3>
<details><summary> <pre>test_groupby.py::test_agg_two_groupers</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestnormtest_default_groupsy">test_moves.py::TestNorm::test_default_groups[y]</h3>
<details><summary> <pre>test_moves.py::TestNorm::test_default_groups[y]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_nominal_list_palette">test_properties.py::TestColor::test_nominal_list_palette</h3>
<details><summary> <pre>test_properties.py::TestColor::test_nominal_list_palette</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_groupbypytest_agg_two_groupers_ordered">test_groupby.py::test_agg_two_groupers_ordered</h3>
<details><summary> <pre>test_groupby.py::test_agg_two_groupers_ordered</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_groupbypytest_apply_no_grouper">test_groupby.py::test_apply_no_grouper</h3>
<details><summary> <pre>test_groupby.py::test_apply_no_grouper</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestnormtest_sum">test_moves.py::TestNorm::test_sum</h3>
<details><summary> <pre>test_moves.py::TestNorm::test_sum</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_nominal_dict_palette">test_properties.py::TestColor::test_nominal_dict_palette</h3>
<details><summary> <pre>test_properties.py::TestColor::test_nominal_dict_palette</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestnormtest_where">test_moves.py::TestNorm::test_where</h3>
<details><summary> <pre>test_moves.py::TestNorm::test_where</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_nominal_dict_with_missing_keys">test_properties.py::TestColor::test_nominal_dict_with_missing_keys</h3>
<details><summary> <pre>test_properties.py::TestColor::test_nominal_dict_with_missing_keys</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_nominal_list_too_short">test_properties.py::TestColor::test_nominal_list_too_short</h3>
<details><summary> <pre>test_properties.py::TestColor::test_nominal_list_too_short</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestnormtest_percent">test_moves.py::TestNorm::test_percent</h3>
<details><summary> <pre>test_moves.py::TestNorm::test_percent</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_groupbypytest_apply_one_grouper">test_groupby.py::test_apply_one_grouper</h3>
<details><summary> <pre>test_groupby.py::test_apply_one_grouper</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_groupbypytest_apply_mutate_columns">test_groupby.py::test_apply_mutate_columns</h3>
<details><summary> <pre>test_groupby.py::test_apply_mutate_columns</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcoordinatetest_bad_scale_arg_str">test_properties.py::TestCoordinate::test_bad_scale_arg_str</h3>
<details><summary> <pre>test_properties.py::TestCoordinate::test_bad_scale_arg_str</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_groupbypytest_apply_replace_columns">test_groupby.py::test_apply_replace_columns</h3>
<details><summary> <pre>test_groupby.py::test_apply_replace_columns</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_nominal_list_too_long">test_properties.py::TestColor::test_nominal_list_too_long</h3>
<details><summary> <pre>test_properties.py::TestColor::test_nominal_list_too_long</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcoordinatetest_bad_scale_arg_type">test_properties.py::TestCoordinate::test_bad_scale_arg_type</h3>
<details><summary> <pre>test_properties.py::TestCoordinate::test_bad_scale_arg_type</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_inferenceviridis-bool-boolean">test_properties.py::TestColor::test_inference[viridis-bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestColor::test_inference[viridis-bool-Boolean]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_nominal_default_palette">test_properties.py::TestColor::test_nominal_default_palette</h3>
<details><summary> <pre>test_properties.py::TestColor::test_nominal_default_palette</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_inferencemuted-num-nominal">test_properties.py::TestColor::test_inference[muted-num-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestColor::test_inference[muted-num-Nominal]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_continuous_default_palette">test_properties.py::TestColor::test_continuous_default_palette</h3>
<details><summary> <pre>test_properties.py::TestColor::test_continuous_default_palette</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_inferencevalues4-num-nominal">test_properties.py::TestColor::test_inference[values4-num-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestColor::test_inference[values4-num-Nominal]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestdodgetest_fill">test_moves.py::TestDodge::test_fill</h3>
<details><summary> <pre>test_moves.py::TestDodge::test_fill</pre></summary><pre>
[gw0] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestdodgetest_faceted_drop">test_moves.py::TestDodge::test_faceted_drop</h3>
<details><summary> <pre>test_moves.py::TestDodge::test_faceted_drop</pre></summary><pre>
[gw2] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_defaultnum">test_properties.py::TestMarker::test_default[num]</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_default[num]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_continuous_named_palette">test_properties.py::TestColor::test_continuous_named_palette</h3>
<details><summary> <pre>test_properties.py::TestColor::test_continuous_named_palette</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_inferencevalues5-num-nominal">test_properties.py::TestColor::test_inference[values5-num-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestColor::test_inference[values5-num-Nominal]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_defaultbool">test_properties.py::TestMarker::test_default[bool]</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_default[bool]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_continuous_tuple_palette">test_properties.py::TestColor::test_continuous_tuple_palette</h3>
<details><summary> <pre>test_properties.py::TestColor::test_continuous_tuple_palette</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_inferencevalues6-num-continuous">test_properties.py::TestColor::test_inference[values6-num-Continuous]</h3>
<details><summary> <pre>test_properties.py::TestColor::test_inference[values6-num-Continuous]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_inference_listcat">test_properties.py::TestMarker::test_inference_list[cat]</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_inference_list[cat]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_inference_listnum">test_properties.py::TestMarker::test_inference_list[num]</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_inference_list[num]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_inferencevalues7-cat-nominal">test_properties.py::TestColor::test_inference[values7-cat-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestColor::test_inference[values7-cat-Nominal]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_inference_listbool">test_properties.py::TestMarker::test_inference_list[bool]</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_inference_list[bool]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_inferencevalues8-bool-boolean">test_properties.py::TestColor::test_inference[values8-bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestColor::test_inference[values8-bool-Boolean]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_continuous_callable_palette">test_properties.py::TestColor::test_continuous_callable_palette</h3>
<details><summary> <pre>test_properties.py::TestColor::test_continuous_callable_palette</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_inference_dictcat">test_properties.py::TestMarker::test_inference_dict[cat]</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_inference_dict[cat]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_inferencevalues9-num-continuous">test_properties.py::TestColor::test_inference[values9-num-Continuous]</h3>
<details><summary> <pre>test_properties.py::TestColor::test_inference[values9-num-Continuous]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_continuous_missing">test_properties.py::TestColor::test_continuous_missing</h3>
<details><summary> <pre>test_properties.py::TestColor::test_continuous_missing</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_standardization">test_properties.py::TestColor::test_standardization</h3>
<details><summary> <pre>test_properties.py::TestColor::test_standardization</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_inference_dictnum">test_properties.py::TestMarker::test_inference_dict[num]</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_inference_dict[num]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_mapping_defaultcat">test_properties.py::TestMarker::test_mapping_default[cat]</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_mapping_default[cat]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_defaultnum">test_properties.py::TestLineStyle::test_default[num]</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_default[num]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_inference_dictbool">test_properties.py::TestMarker::test_inference_dict[bool]</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_inference_dict[bool]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_mapping_defaultnum">test_properties.py::TestMarker::test_mapping_default[num]</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_mapping_default[num]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_defaultbool">test_properties.py::TestLineStyle::test_default[bool]</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_default[bool]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_dict_missing">test_properties.py::TestMarker::test_dict_missing</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_dict_missing</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_inference_listcat">test_properties.py::TestLineStyle::test_inference_list[cat]</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_inference_list[cat]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_mapping_from_listcat">test_properties.py::TestMarker::test_mapping_from_list[cat]</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_mapping_from_list[cat]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_inference_dictbool">test_properties.py::TestLineStyle::test_inference_dict[bool]</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_inference_dict[bool]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_mapping_from_listnum">test_properties.py::TestMarker::test_mapping_from_list[num]</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_mapping_from_list[num]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_dict_missing">test_properties.py::TestLineStyle::test_dict_missing</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_dict_missing</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_mapping_from_dictcat">test_properties.py::TestMarker::test_mapping_from_dict[cat]</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_mapping_from_dict[cat]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_mapping_from_dictnum">test_properties.py::TestMarker::test_mapping_from_dict[num]</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_mapping_from_dict[num]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_mapping_defaultcat">test_properties.py::TestLineStyle::test_mapping_default[cat]</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_mapping_default[cat]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_inference_listnum">test_properties.py::TestLineStyle::test_inference_list[num]</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_inference_list[num]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_mapping_with_null_value">test_properties.py::TestMarker::test_mapping_with_null_value</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_mapping_with_null_value</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_unique_default_large_n">test_properties.py::TestMarker::test_unique_default_large_n</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_unique_default_large_n</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_inference_listbool">test_properties.py::TestLineStyle::test_inference_list[bool]</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_inference_list[bool]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_mapping_defaultnum">test_properties.py::TestLineStyle::test_mapping_default[num]</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_mapping_default[num]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestdodgetest_drop">test_moves.py::TestDodge::test_drop</h3>
<details><summary> <pre>test_moves.py::TestDodge::test_drop</pre></summary><pre>
[gw0] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_inference_dictcat">test_properties.py::TestLineStyle::test_inference_dict[cat]</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_inference_dict[cat]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestdodgetest_orient">test_moves.py::TestDodge::test_orient</h3>
<details><summary> <pre>test_moves.py::TestDodge::test_orient</pre></summary><pre>
[gw2] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_inference_dictnum">test_properties.py::TestLineStyle::test_inference_dict[num]</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_inference_dict[num]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_mapping_from_listcat">test_properties.py::TestLineStyle::test_mapping_from_list[cat]</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_mapping_from_list[cat]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_mapping_with_null_value">test_properties.py::TestLineStyle::test_mapping_with_null_value</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_mapping_with_null_value</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_mapping_from_listnum">test_properties.py::TestLineStyle::test_mapping_from_list[num]</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_mapping_from_list[num]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_unique_default_large_n">test_properties.py::TestLineStyle::test_unique_default_large_n</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_unique_default_large_n</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_mapping_from_dictcat">test_properties.py::TestLineStyle::test_mapping_from_dict[cat]</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_mapping_from_dict[cat]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_bad_scale_values">test_properties.py::TestLineStyle::test_bad_scale_values</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_bad_scale_values</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_bad_type">test_properties.py::TestLineStyle::test_bad_type</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_bad_type</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_bad_style">test_properties.py::TestLineStyle::test_bad_style</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_bad_style</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_mapping_from_dictnum">test_properties.py::TestLineStyle::test_mapping_from_dict[num]</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_mapping_from_dict[num]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinestyletest_bad_dashes">test_properties.py::TestLineStyle::test_bad_dashes</h3>
<details><summary> <pre>test_properties.py::TestLineStyle::test_bad_dashes</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestfilltest_inference_dictbool">test_properties.py::TestFill::test_inference_dict[bool]</h3>
<details><summary> <pre>test_properties.py::TestFill::test_inference_dict[bool]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestmarkertest_bad_scale_values">test_properties.py::TestMarker::test_bad_scale_values</h3>
<details><summary> <pre>test_properties.py::TestMarker::test_bad_scale_values</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestfilltest_values_error">test_properties.py::TestFill::test_values_error</h3>
<details><summary> <pre>test_properties.py::TestFill::test_values_error</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestfilltest_mapping_categorical_data">test_properties.py::TestFill::test_mapping_categorical_data</h3>
<details><summary> <pre>test_properties.py::TestFill::test_mapping_categorical_data</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestfilltest_defaultnum">test_properties.py::TestFill::test_default[num]</h3>
<details><summary> <pre>test_properties.py::TestFill::test_default[num]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestalphatest_defaultbool-boolean">test_properties.py::TestAlpha::test_default[bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestAlpha::test_default[bool-Boolean]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestfilltest_mapping_numeric_data">test_properties.py::TestFill::test_mapping_numeric_data</h3>
<details><summary> <pre>test_properties.py::TestFill::test_mapping_numeric_data</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestfilltest_defaultbool">test_properties.py::TestFill::test_default[bool]</h3>
<details><summary> <pre>test_properties.py::TestFill::test_default[bool]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestalphatest_inferencearg0-cat-nominal">test_properties.py::TestAlpha::test_inference[arg0-cat-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestAlpha::test_inference[arg0-cat-Nominal]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestfilltest_inference_listcat">test_properties.py::TestFill::test_inference_list[cat]</h3>
<details><summary> <pre>test_properties.py::TestFill::test_inference_list[cat]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestfilltest_mapping_list">test_properties.py::TestFill::test_mapping_list</h3>
<details><summary> <pre>test_properties.py::TestFill::test_mapping_list</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestfilltest_inference_listnum">test_properties.py::TestFill::test_inference_list[num]</h3>
<details><summary> <pre>test_properties.py::TestFill::test_inference_list[num]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestalphatest_inferencearg1-num-continuous">test_properties.py::TestAlpha::test_inference[arg1-num-Continuous]</h3>
<details><summary> <pre>test_properties.py::TestAlpha::test_inference[arg1-num-Continuous]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestfilltest_mapping_truthy_list">test_properties.py::TestFill::test_mapping_truthy_list</h3>
<details><summary> <pre>test_properties.py::TestFill::test_mapping_truthy_list</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestfilltest_inference_listbool">test_properties.py::TestFill::test_inference_list[bool]</h3>
<details><summary> <pre>test_properties.py::TestFill::test_inference_list[bool]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestfilltest_mapping_dict">test_properties.py::TestFill::test_mapping_dict</h3>
<details><summary> <pre>test_properties.py::TestFill::test_mapping_dict</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestalphatest_inferencearg2-bool-boolean">test_properties.py::TestAlpha::test_inference[arg2-bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestAlpha::test_inference[arg2-bool-Boolean]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestfilltest_cycle_warning">test_properties.py::TestFill::test_cycle_warning</h3>
<details><summary> <pre>test_properties.py::TestFill::test_cycle_warning</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestfilltest_inference_dictcat">test_properties.py::TestFill::test_inference_dict[cat]</h3>
<details><summary> <pre>test_properties.py::TestFill::test_inference_dict[cat]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestdodgetest_gap">test_moves.py::TestDodge::test_gap</h3>
<details><summary> <pre>test_moves.py::TestDodge::test_gap</pre></summary><pre>
[gw0] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestalphatest_inferencearg8-bool-boolean">test_properties.py::TestAlpha::test_inference[arg8-bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestAlpha::test_inference[arg8-bool-Boolean]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestalphatest_inferencearg3-cat-nominal">test_properties.py::TestAlpha::test_inference[arg3-cat-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestAlpha::test_inference[arg3-cat-Nominal]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestfilltest_inference_dictnum">test_properties.py::TestFill::test_inference_dict[num]</h3>
<details><summary> <pre>test_properties.py::TestFill::test_inference_dict[num]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestdodgetest_single_semanticgrp2">test_moves.py::TestDodge::test_single_semantic[grp2]</h3>
<details><summary> <pre>test_moves.py::TestDodge::test_single_semantic[grp2]</pre></summary><pre>
[gw2] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestalphatest_mapped_interval_numeric">test_properties.py::TestAlpha::test_mapped_interval_numeric</h3>
<details><summary> <pre>test_properties.py::TestAlpha::test_mapped_interval_numeric</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinewidthtest_defaultbool-boolean">test_properties.py::TestLineWidth::test_default[bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestLineWidth::test_default[bool-Boolean]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestalphatest_inferencearg4-num-nominal">test_properties.py::TestAlpha::test_inference[arg4-num-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestAlpha::test_inference[arg4-num-Nominal]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinewidthtest_inferencearg0-cat-nominal">test_properties.py::TestLineWidth::test_inference[arg0-cat-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestLineWidth::test_inference[arg0-cat-Nominal]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestalphatest_mapped_interval_categorical">test_properties.py::TestAlpha::test_mapped_interval_categorical</h3>
<details><summary> <pre>test_properties.py::TestAlpha::test_mapped_interval_categorical</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestalphatest_inferencearg5-bool-boolean">test_properties.py::TestAlpha::test_inference[arg5-bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestAlpha::test_inference[arg5-bool-Boolean]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestalphatest_bad_scale_values_numeric_data">test_properties.py::TestAlpha::test_bad_scale_values_numeric_data</h3>
<details><summary> <pre>test_properties.py::TestAlpha::test_bad_scale_values_numeric_data</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinewidthtest_inferencearg1-num-continuous">test_properties.py::TestLineWidth::test_inference[arg1-num-Continuous]</h3>
<details><summary> <pre>test_properties.py::TestLineWidth::test_inference[arg1-num-Continuous]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestalphatest_inferencearg6-cat-nominal">test_properties.py::TestAlpha::test_inference[arg6-cat-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestAlpha::test_inference[arg6-cat-Nominal]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestalphatest_bad_scale_values_categorical_data">test_properties.py::TestAlpha::test_bad_scale_values_categorical_data</h3>
<details><summary> <pre>test_properties.py::TestAlpha::test_bad_scale_values_categorical_data</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinewidthtest_inferencearg2-bool-boolean">test_properties.py::TestLineWidth::test_inference[arg2-bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestLineWidth::test_inference[arg2-bool-Boolean]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinewidthtest_mapped_interval_numeric">test_properties.py::TestLineWidth::test_mapped_interval_numeric</h3>
<details><summary> <pre>test_properties.py::TestLineWidth::test_mapped_interval_numeric</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestalphatest_inferencearg7-num-nominal">test_properties.py::TestAlpha::test_inference[arg7-num-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestAlpha::test_inference[arg7-num-Nominal]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinewidthtest_mapped_interval_categorical">test_properties.py::TestLineWidth::test_mapped_interval_categorical</h3>
<details><summary> <pre>test_properties.py::TestLineWidth::test_mapped_interval_categorical</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinewidthtest_inferencearg3-cat-nominal">test_properties.py::TestLineWidth::test_inference[arg3-cat-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestLineWidth::test_inference[arg3-cat-Nominal]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinewidthtest_inferencearg4-num-nominal">test_properties.py::TestLineWidth::test_inference[arg4-num-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestLineWidth::test_inference[arg4-num-Nominal]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinewidthtest_bad_scale_values_numeric_data">test_properties.py::TestLineWidth::test_bad_scale_values_numeric_data</h3>
<details><summary> <pre>test_properties.py::TestLineWidth::test_bad_scale_values_numeric_data</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinewidthtest_inferencearg5-bool-boolean">test_properties.py::TestLineWidth::test_inference[arg5-bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestLineWidth::test_inference[arg5-bool-Boolean]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinewidthtest_bad_scale_values_categorical_data">test_properties.py::TestLineWidth::test_bad_scale_values_categorical_data</h3>
<details><summary> <pre>test_properties.py::TestLineWidth::test_bad_scale_values_categorical_data</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestedgewidthtest_defaultbool-boolean">test_properties.py::TestEdgeWidth::test_default[bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestEdgeWidth::test_default[bool-Boolean]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinewidthtest_rcparam_default">test_properties.py::TestLineWidth::test_rcparam_default</h3>
<details><summary> <pre>test_properties.py::TestLineWidth::test_rcparam_default</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestedgewidthtest_inferencearg0-cat-nominal">test_properties.py::TestEdgeWidth::test_inference[arg0-cat-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestEdgeWidth::test_inference[arg0-cat-Nominal]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinewidthtest_inferencearg6-cat-nominal">test_properties.py::TestLineWidth::test_inference[arg6-cat-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestLineWidth::test_inference[arg6-cat-Nominal]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestedgewidthtest_inferencearg2-bool-boolean">test_properties.py::TestEdgeWidth::test_inference[arg2-bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestEdgeWidth::test_inference[arg2-bool-Boolean]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestedgewidthtest_inferencearg1-num-continuous">test_properties.py::TestEdgeWidth::test_inference[arg1-num-Continuous]</h3>
<details><summary> <pre>test_properties.py::TestEdgeWidth::test_inference[arg1-num-Continuous]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestedgewidthtest_inferencearg3-cat-nominal">test_properties.py::TestEdgeWidth::test_inference[arg3-cat-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestEdgeWidth::test_inference[arg3-cat-Nominal]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinewidthtest_inferencearg7-num-nominal">test_properties.py::TestLineWidth::test_inference[arg7-num-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestLineWidth::test_inference[arg7-num-Nominal]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestedgewidthtest_inferencearg6-cat-nominal">test_properties.py::TestEdgeWidth::test_inference[arg6-cat-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestEdgeWidth::test_inference[arg6-cat-Nominal]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestedgewidthtest_inferencearg4-num-nominal">test_properties.py::TestEdgeWidth::test_inference[arg4-num-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestEdgeWidth::test_inference[arg4-num-Nominal]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestlinewidthtest_inferencearg8-bool-boolean">test_properties.py::TestLineWidth::test_inference[arg8-bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestLineWidth::test_inference[arg8-bool-Boolean]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestedgewidthtest_inferencearg7-num-nominal">test_properties.py::TestEdgeWidth::test_inference[arg7-num-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestEdgeWidth::test_inference[arg7-num-Nominal]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestedgewidthtest_inferencearg5-bool-boolean">test_properties.py::TestEdgeWidth::test_inference[arg5-bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestEdgeWidth::test_inference[arg5-bool-Boolean]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestedgewidthtest_mapped_interval_categorical">test_properties.py::TestEdgeWidth::test_mapped_interval_categorical</h3>
<details><summary> <pre>test_properties.py::TestEdgeWidth::test_mapped_interval_categorical</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestedgewidthtest_inferencearg8-bool-boolean">test_properties.py::TestEdgeWidth::test_inference[arg8-bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestEdgeWidth::test_inference[arg8-bool-Boolean]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestedgewidthtest_bad_scale_values_numeric_data">test_properties.py::TestEdgeWidth::test_bad_scale_values_numeric_data</h3>
<details><summary> <pre>test_properties.py::TestEdgeWidth::test_bad_scale_values_numeric_data</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestpointsizetest_defaultbool-boolean">test_properties.py::TestPointSize::test_default[bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestPointSize::test_default[bool-Boolean]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestedgewidthtest_bad_scale_values_categorical_data">test_properties.py::TestEdgeWidth::test_bad_scale_values_categorical_data</h3>
<details><summary> <pre>test_properties.py::TestEdgeWidth::test_bad_scale_values_categorical_data</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestdodgetest_widths_default">test_moves.py::TestDodge::test_widths_default</h3>
<details><summary> <pre>test_moves.py::TestDodge::test_widths_default</pre></summary><pre>
[gw0] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestedgewidthtest_mapped_interval_numeric">test_properties.py::TestEdgeWidth::test_mapped_interval_numeric</h3>
<details><summary> <pre>test_properties.py::TestEdgeWidth::test_mapped_interval_numeric</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestpointsizetest_inferencearg0-cat-nominal">test_properties.py::TestPointSize::test_inference[arg0-cat-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestPointSize::test_inference[arg0-cat-Nominal]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestedgewidthtest_rcparam_default">test_properties.py::TestEdgeWidth::test_rcparam_default</h3>
<details><summary> <pre>test_properties.py::TestEdgeWidth::test_rcparam_default</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestpointsizetest_inferencearg8-bool-boolean">test_properties.py::TestPointSize::test_inference[arg8-bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestPointSize::test_inference[arg8-bool-Boolean]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestpointsizetest_inferencearg1-num-continuous">test_properties.py::TestPointSize::test_inference[arg1-num-Continuous]</h3>
<details><summary> <pre>test_properties.py::TestPointSize::test_inference[arg1-num-Continuous]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestpointsizetest_inferencearg5-bool-boolean">test_properties.py::TestPointSize::test_inference[arg5-bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestPointSize::test_inference[arg5-bool-Boolean]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestpointsizetest_mapped_interval_numeric">test_properties.py::TestPointSize::test_mapped_interval_numeric</h3>
<details><summary> <pre>test_properties.py::TestPointSize::test_mapped_interval_numeric</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestdodgetest_single_semanticgrp3">test_moves.py::TestDodge::test_single_semantic[grp3]</h3>
<details><summary> <pre>test_moves.py::TestDodge::test_single_semantic[grp3]</pre></summary><pre>
[gw2] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestpointsizetest_inferencearg6-cat-nominal">test_properties.py::TestPointSize::test_inference[arg6-cat-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestPointSize::test_inference[arg6-cat-Nominal]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestpointsizetest_inferencearg2-bool-boolean">test_properties.py::TestPointSize::test_inference[arg2-bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestPointSize::test_inference[arg2-bool-Boolean]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestpointsizetest_mapped_interval_categorical">test_properties.py::TestPointSize::test_mapped_interval_categorical</h3>
<details><summary> <pre>test_properties.py::TestPointSize::test_mapped_interval_categorical</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestpointsizetest_inferencearg7-num-nominal">test_properties.py::TestPointSize::test_inference[arg7-num-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestPointSize::test_inference[arg7-num-Nominal]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestpointsizetest_inferencearg3-cat-nominal">test_properties.py::TestPointSize::test_inference[arg3-cat-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestPointSize::test_inference[arg3-cat-Nominal]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestpointsizetest_bad_scale_values_numeric_data">test_properties.py::TestPointSize::test_bad_scale_values_numeric_data</h3>
<details><summary> <pre>test_properties.py::TestPointSize::test_bad_scale_values_numeric_data</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestpointsizetest_bad_scale_values_categorical_data">test_properties.py::TestPointSize::test_bad_scale_values_categorical_data</h3>
<details><summary> <pre>test_properties.py::TestPointSize::test_bad_scale_values_categorical_data</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestpointsizetest_areal_scaling_categorical">test_properties.py::TestPointSize::test_areal_scaling_categorical</h3>
<details><summary> <pre>test_properties.py::TestPointSize::test_areal_scaling_categorical</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestpointsizetest_inferencearg4-num-nominal">test_properties.py::TestPointSize::test_inference[arg4-num-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestPointSize::test_inference[arg4-num-Nominal]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_rulespytest_categorical_order">test_rules.py::test_categorical_order</h3>
<details><summary> <pre>test_rules.py::test_categorical_order</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_rulespytest_variable_type">test_rules.py::test_variable_type</h3>
<details><summary> <pre>test_rules.py::test_variable_type</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestpointsizetest_areal_scaling_numeric">test_properties.py::TestPointSize::test_areal_scaling_numeric</h3>
<details><summary> <pre>test_properties.py::TestPointSize::test_areal_scaling_numeric</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestspecificationcheckstest_both_facets_and_wrap">test_subplots.py::TestSpecificationChecks::test_both_facets_and_wrap</h3>
<details><summary> <pre>test_subplots.py::TestSpecificationChecks::test_both_facets_and_wrap</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestspecificationcheckstest_wrapped_columns_and_y_pairing">test_subplots.py::TestSpecificationChecks::test_wrapped_columns_and_y_pairing</h3>
<details><summary> <pre>test_subplots.py::TestSpecificationChecks::test_wrapped_columns_and_y_pairing</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotspectest_single_subplot">test_subplots.py::TestSubplotSpec::test_single_subplot</h3>
<details><summary> <pre>test_subplots.py::TestSubplotSpec::test_single_subplot</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestspecificationcheckstest_wrapped_x_pairing_and_facetd_rows">test_subplots.py::TestSpecificationChecks::test_wrapped_x_pairing_and_facetd_rows</h3>
<details><summary> <pre>test_subplots.py::TestSpecificationChecks::test_wrapped_x_pairing_and_facetd_rows</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestspecificationcheckstest_cross_xy_pairing_and_wrap">test_subplots.py::TestSpecificationChecks::test_cross_xy_pairing_and_wrap</h3>
<details><summary> <pre>test_subplots.py::TestSpecificationChecks::test_cross_xy_pairing_and_wrap</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotspectest_single_facet">test_subplots.py::TestSubplotSpec::test_single_facet</h3>
<details><summary> <pre>test_subplots.py::TestSubplotSpec::test_single_facet</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotspectest_two_facets">test_subplots.py::TestSubplotSpec::test_two_facets</h3>
<details><summary> <pre>test_subplots.py::TestSubplotSpec::test_two_facets</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestspecificationcheckstest_col_facets_and_x_pairing">test_subplots.py::TestSpecificationChecks::test_col_facets_and_x_pairing</h3>
<details><summary> <pre>test_subplots.py::TestSpecificationChecks::test_col_facets_and_x_pairing</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotspectest_col_facet_wrapped">test_subplots.py::TestSubplotSpec::test_col_facet_wrapped</h3>
<details><summary> <pre>test_subplots.py::TestSubplotSpec::test_col_facet_wrapped</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotspectest_row_facet_wrapped">test_subplots.py::TestSubplotSpec::test_row_facet_wrapped</h3>
<details><summary> <pre>test_subplots.py::TestSubplotSpec::test_row_facet_wrapped</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotspectest_x_paired">test_subplots.py::TestSubplotSpec::test_x_paired</h3>
<details><summary> <pre>test_subplots.py::TestSubplotSpec::test_x_paired</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotspectest_col_facet_wrapped_single_row">test_subplots.py::TestSubplotSpec::test_col_facet_wrapped_single_row</h3>
<details><summary> <pre>test_subplots.py::TestSubplotSpec::test_col_facet_wrapped_single_row</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotspectest_x_and_y_paired">test_subplots.py::TestSubplotSpec::test_x_and_y_paired</h3>
<details><summary> <pre>test_subplots.py::TestSubplotSpec::test_x_and_y_paired</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotspectest_y_paired">test_subplots.py::TestSubplotSpec::test_y_paired</h3>
<details><summary> <pre>test_subplots.py::TestSubplotSpec::test_y_paired</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotspectest_y_paired_and_wrapped">test_subplots.py::TestSubplotSpec::test_y_paired_and_wrapped</h3>
<details><summary> <pre>test_subplots.py::TestSubplotSpec::test_y_paired_and_wrapped</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotspectest_x_paired_and_wrapped">test_subplots.py::TestSubplotSpec::test_x_paired_and_wrapped</h3>
<details><summary> <pre>test_subplots.py::TestSubplotSpec::test_x_paired_and_wrapped</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotspectest_y_paired_and_wrapped_single_row">test_subplots.py::TestSubplotSpec::test_y_paired_and_wrapped_single_row</h3>
<details><summary> <pre>test_subplots.py::TestSubplotSpec::test_y_paired_and_wrapped_single_row</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotspectest_col_faceted_y_paired">test_subplots.py::TestSubplotSpec::test_col_faceted_y_paired</h3>
<details><summary> <pre>test_subplots.py::TestSubplotSpec::test_col_faceted_y_paired</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotspectest_row_faceted_x_paired">test_subplots.py::TestSubplotSpec::test_row_faceted_x_paired</h3>
<details><summary> <pre>test_subplots.py::TestSubplotSpec::test_row_faceted_x_paired</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotspectest_x_any_y_paired_non_cross">test_subplots.py::TestSubplotSpec::test_x_any_y_paired_non_cross</h3>
<details><summary> <pre>test_subplots.py::TestSubplotSpec::test_x_any_y_paired_non_cross</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotspectest_x_any_y_paired_non_cross_wrapped">test_subplots.py::TestSubplotSpec::test_x_any_y_paired_non_cross_wrapped</h3>
<details><summary> <pre>test_subplots.py::TestSubplotSpec::test_x_any_y_paired_non_cross_wrapped</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotelementstest_single_facet_dimrow">test_subplots.py::TestSubplotElements::test_single_facet_dim[row]</h3>
<details><summary> <pre>test_subplots.py::TestSubplotElements::test_single_facet_dim[row]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotelementstest_single_subplot">test_subplots.py::TestSubplotElements::test_single_subplot</h3>
<details><summary> <pre>test_subplots.py::TestSubplotElements::test_single_subplot</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotelementstest_single_facet_dimcol">test_subplots.py::TestSubplotElements::test_single_facet_dim[col]</h3>
<details><summary> <pre>test_subplots.py::TestSubplotElements::test_single_facet_dim[col]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotelementstest_single_facet_dim_wrappedcol">test_subplots.py::TestSubplotElements::test_single_facet_dim_wrapped[col]</h3>
<details><summary> <pre>test_subplots.py::TestSubplotElements::test_single_facet_dim_wrapped[col]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotelementstest_both_facet_dims">test_subplots.py::TestSubplotElements::test_both_facet_dims</h3>
<details><summary> <pre>test_subplots.py::TestSubplotElements::test_both_facet_dims</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotelementstest_single_facet_dim_wrappedrow">test_subplots.py::TestSubplotElements::test_single_facet_dim_wrapped[row]</h3>
<details><summary> <pre>test_subplots.py::TestSubplotElements::test_single_facet_dim_wrapped[row]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotelementstest_single_paired_varx">test_subplots.py::TestSubplotElements::test_single_paired_var[x]</h3>
<details><summary> <pre>test_subplots.py::TestSubplotElements::test_single_paired_var[x]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotelementstest_single_paired_vary">test_subplots.py::TestSubplotElements::test_single_paired_var[y]</h3>
<details><summary> <pre>test_subplots.py::TestSubplotElements::test_single_paired_var[y]</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotelementstest_single_paired_var_wrappedx">test_subplots.py::TestSubplotElements::test_single_paired_var_wrapped[x]</h3>
<details><summary> <pre>test_subplots.py::TestSubplotElements::test_single_paired_var_wrapped[x]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotelementstest_single_paired_var_wrappedy">test_subplots.py::TestSubplotElements::test_single_paired_var_wrapped[y]</h3>
<details><summary> <pre>test_subplots.py::TestSubplotElements::test_single_paired_var_wrapped[y]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotelementstest_both_paired_non_cross">test_subplots.py::TestSubplotElements::test_both_paired_non_cross</h3>
<details><summary> <pre>test_subplots.py::TestSubplotElements::test_both_paired_non_cross</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotelementstest_both_paired_variables">test_subplots.py::TestSubplotElements::test_both_paired_variables</h3>
<details><summary> <pre>test_subplots.py::TestSubplotElements::test_both_paired_variables</pre></summary><pre>
[gw3] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotelementstest_one_facet_one_pairedcol-y">test_subplots.py::TestSubplotElements::test_one_facet_one_paired[col-y]</h3>
<details><summary> <pre>test_subplots.py::TestSubplotElements::test_one_facet_one_paired[col-y]</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_subplotspytestsubplotelementstest_one_facet_one_pairedrow-x">test_subplots.py::TestSubplotElements::test_one_facet_one_paired[row-x]</h3>
<details><summary> <pre>test_subplots.py::TestSubplotElements::test_one_facet_one_paired[row-x]</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestdodgetest_widths_fill">test_moves.py::TestDodge::test_widths_fill</h3>
<details><summary> <pre>test_moves.py::TestDodge::test_widths_fill</pre></summary><pre>
[gw0] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestdodgetest_two_semantics">test_moves.py::TestDodge::test_two_semantics</h3>
<details><summary> <pre>test_moves.py::TestDodge::test_two_semantics</pre></summary><pre>
[gw2] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestdodgetest_widths_drop">test_moves.py::TestDodge::test_widths_drop</h3>
<details><summary> <pre>test_moves.py::TestDodge::test_widths_drop</pre></summary><pre>
[gw0] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespyteststacktest_basic">test_moves.py::TestStack::test_basic</h3>
<details><summary> <pre>test_moves.py::TestStack::test_basic</pre></summary><pre>
[gw2] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespyteststacktest_faceted">test_moves.py::TestStack::test_faceted</h3>
<details><summary> <pre>test_moves.py::TestStack::test_faceted</pre></summary><pre>
[gw2] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespyteststacktest_misssing_data">test_moves.py::TestStack::test_misssing_data</h3>
<details><summary> <pre>test_moves.py::TestStack::test_misssing_data</pre></summary><pre>
[gw2] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespyteststacktest_baseline_homogeneity_check">test_moves.py::TestStack::test_baseline_homogeneity_check</h3>
<details><summary> <pre>test_moves.py::TestStack::test_baseline_homogeneity_check</pre></summary><pre>
[gw2] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_movespytestdodgetest_faceted_default">test_moves.py::TestDodge::test_faceted_default</h3>
<details><summary> <pre>test_moves.py::TestDodge::test_faceted_default</pre></summary><pre>
[gw0] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_bad_scale_values_continuous">test_properties.py::TestColor::test_bad_scale_values_continuous</h3>
<details><summary> <pre>test_properties.py::TestColor::test_bad_scale_values_continuous</pre></summary><pre>
[gw0] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_bad_scale_values_nominal">test_properties.py::TestColor::test_bad_scale_values_nominal</h3>
<details><summary> <pre>test_properties.py::TestColor::test_bad_scale_values_nominal</pre></summary><pre>
[gw0] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_bad_inference_arg">test_properties.py::TestColor::test_bad_inference_arg</h3>
<details><summary> <pre>test_properties.py::TestColor::test_bad_inference_arg</pre></summary><pre>
[gw0] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_defaultbool-boolean">test_properties.py::TestColor::test_default[bool-Boolean]</h3>
<details><summary> <pre>test_properties.py::TestColor::test_default[bool-Boolean]</pre></summary><pre>
[gw0] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_inferenceviridis-cat-nominal">test_properties.py::TestColor::test_inference[viridis-cat-Nominal]</h3>
<details><summary> <pre>test_properties.py::TestColor::test_inference[viridis-cat-Nominal]</pre></summary><pre>
[gw0] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_propertiespytestcolortest_inferenceviridis-num-continuous">test_properties.py::TestColor::test_inference[viridis-num-Continuous]</h3>
<details><summary> <pre>test_properties.py::TestColor::test_inference[viridis-num-Continuous]</pre></summary><pre>
[gw0] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/seaborn/_base.py b/seaborn/_base.py</span>
<span class="gh">index d7a46b61..98b73a20 100644</span>
<span class="gd">--- a/seaborn/_base.py</span>
<span class="gi">+++ b/seaborn/_base.py</span>
<span class="gu">@@ -25,11 +25,19 @@ class SemanticMapping:</span>

<span class="w"> </span>    def _check_list_length(self, levels, values, variable):
<span class="w"> </span>        &quot;&quot;&quot;Input check when values are provided as a list.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(values) != len(levels):</span>
<span class="gi">+            raise ValueError(f&quot;The {variable} list has {len(values)} values,&quot;</span>
<span class="gi">+                             f&quot; but there are {len(levels)} {variable} levels&quot;)</span>

<span class="w"> </span>    def _lookup_single(self, key):
<span class="gd">-        &quot;&quot;&quot;Apply the mapping to a single data value.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;Get the size for a single value, using norm to interpolate.&quot;&quot;&quot;</span>
<span class="gi">+        if self.map_type == &quot;numeric&quot;:</span>
<span class="gi">+            if self.norm is not None:</span>
<span class="gi">+                return self.size_range[0] + self.norm(key) * (self.size_range[1] - self.size_range[0])</span>
<span class="gi">+            else:</span>
<span class="gi">+                return self.lookup_table[key]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.lookup_table[key]</span>

<span class="w"> </span>    def __call__(self, key, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Get the attribute(s) values for the data key.&quot;&quot;&quot;
<span class="gu">@@ -93,19 +101,55 @@ class HueMapping(SemanticMapping):</span>

<span class="w"> </span>    def _lookup_single(self, key):
<span class="w"> </span>        &quot;&quot;&quot;Get the color for a single value, using colormap to interpolate.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.map_type == &quot;numeric&quot;:</span>
<span class="gi">+            if self.norm is not None:</span>
<span class="gi">+                normed = self.norm(key)</span>
<span class="gi">+                return self.cmap(normed)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return self.lookup_table[key]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.lookup_table[key]</span>

<span class="w"> </span>    def infer_map_type(self, palette, norm, input_format, var_type):
<span class="w"> </span>        &quot;&quot;&quot;Determine how to implement the mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(palette, dict):</span>
<span class="gi">+            return &quot;categorical&quot;</span>
<span class="gi">+        elif norm is not None:</span>
<span class="gi">+            return &quot;numeric&quot;</span>
<span class="gi">+        elif var_type == &quot;numeric&quot;:</span>
<span class="gi">+            return &quot;numeric&quot;</span>
<span class="gi">+        elif isinstance(palette, str) and palette in QUAL_PALETTES:</span>
<span class="gi">+            return &quot;categorical&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &quot;categorical&quot;</span>

<span class="w"> </span>    def categorical_mapping(self, data, palette, order):
<span class="w"> </span>        &quot;&quot;&quot;Determine colors when the hue mapping is categorical.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        levels = categorical_order(data, order)</span>
<span class="gi">+        n_colors = len(levels)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(palette, dict):</span>
<span class="gi">+            palette = [palette[k] for k in levels]</span>
<span class="gi">+        else:</span>
<span class="gi">+            palette = color_palette(palette, n_colors)</span>
<span class="gi">+</span>
<span class="gi">+        palette = [desaturate(c, self.saturation) for c in palette]</span>
<span class="gi">+        lookup_table = dict(zip(levels, palette))</span>
<span class="gi">+</span>
<span class="gi">+        return levels, lookup_table</span>

<span class="w"> </span>    def numeric_mapping(self, data, palette, norm):
<span class="w"> </span>        &quot;&quot;&quot;Determine colors when the hue variable is quantitative.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        levels = remove_na(data).unique()</span>
<span class="gi">+        if norm is None:</span>
<span class="gi">+            norm = mpl.colors.Normalize()</span>
<span class="gi">+        if isinstance(palette, str):</span>
<span class="gi">+            cmap = mpl.cm.get_cmap(palette)</span>
<span class="gi">+        else:</span>
<span class="gi">+            cmap = mpl.colors.ListedColormap(palette)</span>
<span class="gi">+        </span>
<span class="gi">+        lookup_table = {l: cmap(norm(l)) for l in levels}</span>
<span class="gi">+        return levels, lookup_table, norm, cmap</span>


<span class="w"> </span>class SizeMapping(SemanticMapping):
<span class="gu">@@ -189,11 +233,32 @@ class StyleMapping(SemanticMapping):</span>

<span class="w"> </span>    def _lookup_single(self, key, attr=None):
<span class="w"> </span>        &quot;&quot;&quot;Get attribute(s) for a given data point.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if key not in self.lookup_table:</span>
<span class="gi">+            return {}</span>
<span class="gi">+        if attr is None:</span>
<span class="gi">+            return self.lookup_table[key]</span>
<span class="gi">+        elif attr in self.lookup_table[key]:</span>
<span class="gi">+            return self.lookup_table[key][attr]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    def _map_attributes(self, arg, levels, defaults, attr):
<span class="w"> </span>        &quot;&quot;&quot;Handle the specification for a given style attribute.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if arg is True:</span>
<span class="gi">+            return dict(zip(levels, defaults))</span>
<span class="gi">+        elif isinstance(arg, dict):</span>
<span class="gi">+            missing = set(levels) - set(arg)</span>
<span class="gi">+            if missing:</span>
<span class="gi">+                msg = f&quot;These {attr} levels are missing: {missing}&quot;</span>
<span class="gi">+                raise ValueError(msg)</span>
<span class="gi">+            return arg</span>
<span class="gi">+        elif isinstance(arg, Sequence):</span>
<span class="gi">+            if len(arg) != len(levels):</span>
<span class="gi">+                msg = f&quot;The {attr} list has {len(arg)} values but there are {len(levels)} {attr} levels&quot;</span>
<span class="gi">+                raise ValueError(msg)</span>
<span class="gi">+            return dict(zip(levels, arg))</span>
<span class="gi">+        else:</span>
<span class="gi">+            return {}</span>


<span class="w"> </span>class VectorPlotter:
<span class="gu">@@ -214,7 +279,7 @@ class VectorPlotter:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def has_xy_data(self):
<span class="w"> </span>        &quot;&quot;&quot;Return True at least one of x or y is defined.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return any(var in self.plot_data for var in [&#39;x&#39;, &#39;y&#39;])</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def var_levels(self):
<span class="gu">@@ -229,7 +294,12 @@ class VectorPlotter:</span>
<span class="w"> </span>        tracking plot variables.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for var in [&quot;hue&quot;, &quot;size&quot;, &quot;style&quot;]:</span>
<span class="gi">+            if hasattr(self, f&quot;{var}_map&quot;):</span>
<span class="gi">+                mapper = getattr(self, f&quot;{var}_map&quot;)</span>
<span class="gi">+                if mapper.levels is not None:</span>
<span class="gi">+                    self._var_levels[var] = list(mapper.levels)</span>
<span class="gi">+        return self._var_levels</span>

<span class="w"> </span>    def assign_variables(self, data=None, variables={}):
<span class="w"> </span>        &quot;&quot;&quot;Define plot variables, optionally using lookup from `data`.&quot;&quot;&quot;
<span class="gh">diff --git a/seaborn/_compat.py b/seaborn/_compat.py</span>
<span class="gh">index 76dc5054..b41f939a 100644</span>
<span class="gd">--- a/seaborn/_compat.py</span>
<span class="gi">+++ b/seaborn/_compat.py</span>
<span class="gu">@@ -9,35 +9,72 @@ from seaborn.utils import _version_predates</span>

<span class="w"> </span>def norm_from_scale(scale, norm):
<span class="w"> </span>    &quot;&quot;&quot;Produce a Normalize object given a Scale and min/max domain limits.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(scale, mpl.scale.LogScale):</span>
<span class="gi">+        return mpl.colors.LogNorm(vmin=norm.vmin, vmax=norm.vmax)</span>
<span class="gi">+    elif isinstance(scale, mpl.scale.SymmetricalLogScale):</span>
<span class="gi">+        return mpl.colors.SymLogNorm(linthresh=scale.linthresh, linscale=scale.linscale,</span>
<span class="gi">+                                     vmin=norm.vmin, vmax=norm.vmax)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return mpl.colors.Normalize(vmin=norm.vmin, vmax=norm.vmax)</span>


<span class="w"> </span>def get_colormap(name):
<span class="w"> </span>    &quot;&quot;&quot;Handle changes to matplotlib colormap interface in 3.6.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _version_predates(mpl, &quot;3.6&quot;):</span>
<span class="gi">+        return mpl.cm.get_cmap(name)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return mpl.colormaps[name]</span>


<span class="w"> </span>def register_colormap(name, cmap):
<span class="w"> </span>    &quot;&quot;&quot;Handle changes to matplotlib colormap interface in 3.6.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _version_predates(mpl, &quot;3.6&quot;):</span>
<span class="gi">+        mpl.cm.register_cmap(name, cmap)</span>
<span class="gi">+    else:</span>
<span class="gi">+        mpl.colormaps.register(cmap, name=name)</span>


<span class="w"> </span>def set_layout_engine(fig: Figure, engine: Literal[&#39;constrained&#39;,
<span class="w"> </span>    &#39;compressed&#39;, &#39;tight&#39;, &#39;none&#39;]) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Handle changes to auto layout engine interface in 3.6&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _version_predates(mpl, &quot;3.6&quot;):</span>
<span class="gi">+        if engine == &#39;none&#39;:</span>
<span class="gi">+            fig.set_tight_layout(False)</span>
<span class="gi">+        elif engine == &#39;tight&#39;:</span>
<span class="gi">+            fig.set_tight_layout(True)</span>
<span class="gi">+        else:</span>
<span class="gi">+            fig.set_constrained_layout(True)</span>
<span class="gi">+    else:</span>
<span class="gi">+        fig.set_layout_engine(engine)</span>


<span class="w"> </span>def get_layout_engine(fig: Figure) -&gt;(mpl.layout_engine.LayoutEngine | None):
<span class="w"> </span>    &quot;&quot;&quot;Handle changes to auto layout engine interface in 3.6&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _version_predates(mpl, &quot;3.6&quot;):</span>
<span class="gi">+        if fig.get_tight_layout():</span>
<span class="gi">+            return &#39;tight&#39;</span>
<span class="gi">+        elif fig.get_constrained_layout():</span>
<span class="gi">+            return &#39;constrained&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+    else:</span>
<span class="gi">+        return fig.get_layout_engine()</span>


<span class="w"> </span>def share_axis(ax0, ax1, which):
<span class="w"> </span>    &quot;&quot;&quot;Handle changes to post-hoc axis sharing.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _version_predates(mpl, &quot;3.5&quot;):</span>
<span class="gi">+        if which == &#39;x&#39;:</span>
<span class="gi">+            ax0.get_shared_x_axes().join(ax0, ax1)</span>
<span class="gi">+        elif which == &#39;y&#39;:</span>
<span class="gi">+            ax0.get_shared_y_axes().join(ax0, ax1)</span>
<span class="gi">+    else:</span>
<span class="gi">+        ax0.sharex(ax1) if which == &#39;x&#39; else ax0.sharey(ax1)</span>


<span class="w"> </span>def get_legend_handles(legend):
<span class="w"> </span>    &quot;&quot;&quot;Handle legendHandles attribute rename.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _version_predates(mpl, &quot;3.7&quot;):</span>
<span class="gi">+        return legend.legendHandles</span>
<span class="gi">+    else:</span>
<span class="gi">+        return legend.legend_handles</span>
<span class="gh">diff --git a/seaborn/_core/data.py b/seaborn/_core/data.py</span>
<span class="gh">index e6ece7c9..f25682cd 100644</span>
<span class="gd">--- a/seaborn/_core/data.py</span>
<span class="gi">+++ b/seaborn/_core/data.py</span>
<span class="gu">@@ -64,7 +64,28 @@ class PlotData:</span>
<span class="w"> </span>    def join(self, data: DataSource, variables: (dict[str, VariableSpec] |
<span class="w"> </span>        None)) -&gt;PlotData:
<span class="w"> </span>        &quot;&quot;&quot;Add, replace, or drop variables and return as a new dataset.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new_data = handle_data_source(data)</span>
<span class="gi">+        if variables is None:</span>
<span class="gi">+            variables = {}</span>
<span class="gi">+        </span>
<span class="gi">+        new_frame, new_names, new_ids = self._assign_variables(new_data, variables)</span>
<span class="gi">+        </span>
<span class="gi">+        # Merge the new frame with the existing one</span>
<span class="gi">+        merged_frame = self.frame.join(new_frame, how=&#39;outer&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        # Update names and ids</span>
<span class="gi">+        merged_names = {**self.names, **new_names}</span>
<span class="gi">+        merged_ids = {**self.ids, **new_ids}</span>
<span class="gi">+        </span>
<span class="gi">+        # Create a new PlotData instance</span>
<span class="gi">+        new_plot_data = PlotData(merged_frame, {})</span>
<span class="gi">+        new_plot_data.frame = merged_frame</span>
<span class="gi">+        new_plot_data.names = merged_names</span>
<span class="gi">+        new_plot_data.ids = merged_ids</span>
<span class="gi">+        new_plot_data.source_data = {**self.source_data, **new_data} if isinstance(self.source_data, dict) else new_data</span>
<span class="gi">+        new_plot_data.source_vars = {**self.source_vars, **variables}</span>
<span class="gi">+        </span>
<span class="gi">+        return new_plot_data</span>

<span class="w"> </span>    def _assign_variables(self, data: (DataFrame | Mapping | None),
<span class="w"> </span>        variables: dict[str, VariableSpec]) -&gt;tuple[DataFrame, dict[str, 
<span class="gu">@@ -102,14 +123,58 @@ class PlotData:</span>
<span class="w"> </span>            non-indexed vector datatypes that have a different length from `data`.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(data, (pd.DataFrame, Mapping)) and data is not None:</span>
<span class="gi">+            raise TypeError(&quot;Data source must be a DataFrame, Mapping, or None&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        frame = pd.DataFrame()</span>
<span class="gi">+        names = {}</span>
<span class="gi">+        ids = {}</span>
<span class="gi">+</span>
<span class="gi">+        for var_name, var_spec in variables.items():</span>
<span class="gi">+            if isinstance(var_spec, str):</span>
<span class="gi">+                if data is None or var_spec not in data:</span>
<span class="gi">+                    raise ValueError(f&quot;Variable &#39;{var_spec}&#39; not found in data&quot;)</span>
<span class="gi">+                frame[var_name] = data[var_spec]</span>
<span class="gi">+                names[var_name] = var_spec</span>
<span class="gi">+                ids[var_name] = id(data[var_spec])</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    series = pd.Series(var_spec, name=var_name)</span>
<span class="gi">+                    if data is not None and len(series) != len(data):</span>
<span class="gi">+                        raise ValueError(f&quot;Length of variable &#39;{var_name}&#39; does not match data length&quot;)</span>
<span class="gi">+                    frame[var_name] = series</span>
<span class="gi">+                    names[var_name] = getattr(var_spec, &#39;name&#39;, None)</span>
<span class="gi">+                    ids[var_name] = id(var_spec)</span>
<span class="gi">+                except Exception as e:</span>
<span class="gi">+                    raise ValueError(f&quot;Could not convert variable &#39;{var_name}&#39; to Series: {str(e)}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return frame, names, ids</span>


<span class="w"> </span>def handle_data_source(data: object) -&gt;(pd.DataFrame | Mapping | None):
<span class="w"> </span>    &quot;&quot;&quot;Convert the data source object to a common union representation.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if data is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    elif isinstance(data, pd.DataFrame):</span>
<span class="gi">+        return data</span>
<span class="gi">+    elif isinstance(data, Mapping):</span>
<span class="gi">+        return data</span>
<span class="gi">+    elif hasattr(data, &#39;__dataframe__&#39;):  # Check for DataFrame exchange protocol</span>
<span class="gi">+        return convert_dataframe_to_pandas(data)</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return pd.DataFrame(data)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            raise TypeError(&quot;Unable to convert data source to DataFrame or Mapping&quot;)</span>


<span class="w"> </span>def convert_dataframe_to_pandas(data: object) -&gt;pd.DataFrame:
<span class="w"> </span>    &quot;&quot;&quot;Use the DataFrame exchange protocol, or fail gracefully.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        df = data.__dataframe__()</span>
<span class="gi">+        if isinstance(df, pd.DataFrame):</span>
<span class="gi">+            return df</span>
<span class="gi">+        else:</span>
<span class="gi">+            return pd.DataFrame(df.to_pandas())</span>
<span class="gi">+    except Exception as e:</span>
<span class="gi">+        raise ValueError(f&quot;Failed to convert data using DataFrame exchange protocol: {str(e)}&quot;)</span>
<span class="gh">diff --git a/seaborn/_core/exceptions.py b/seaborn/_core/exceptions.py</span>
<span class="gh">index b90716ec..c6db38aa 100644</span>
<span class="gd">--- a/seaborn/_core/exceptions.py</span>
<span class="gi">+++ b/seaborn/_core/exceptions.py</span>
<span class="gu">@@ -24,4 +24,7 @@ class PlotSpecError(RuntimeError):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Initialize the class to report the failure of a specific operation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        message = f&quot;Error occurred during {step}&quot;</span>
<span class="gi">+        if var:</span>
<span class="gi">+            message += f&quot; for variable &#39;{var}&#39;&quot;</span>
<span class="gi">+        return cls(message)</span>
<span class="gh">diff --git a/seaborn/_core/groupby.py b/seaborn/_core/groupby.py</span>
<span class="gh">index 89566c5e..451b35db 100644</span>
<span class="gd">--- a/seaborn/_core/groupby.py</span>
<span class="gi">+++ b/seaborn/_core/groupby.py</span>
<span class="gu">@@ -42,16 +42,33 @@ class GroupBy:</span>
<span class="w"> </span>            order = {k: None for k in order}
<span class="w"> </span>        self.order = order

<span class="gd">-    def _get_groups(self, data: DataFrame) -&gt;tuple[str | list[str], Index |</span>
<span class="gd">-        MultiIndex]:</span>
<span class="gi">+    def _get_groups(self, data: DataFrame) -&gt; tuple[str | list[str], Index | MultiIndex]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return index with Cartesian product of ordered grouping variable levels.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        groupers = []</span>
<span class="gi">+        levels = []</span>
<span class="gi">+        names = []</span>
<span class="gi">+        for var, order in self.order.items():</span>
<span class="gi">+            if var in data.columns:</span>
<span class="gi">+                groupers.append(data[var])</span>
<span class="gi">+                level = categorical_order(data[var], order)</span>
<span class="gi">+                levels.append(level)</span>
<span class="gi">+                names.append(var)</span>
<span class="gi">+        </span>
<span class="gi">+        if len(names) == 1:</span>
<span class="gi">+            index = pd.Index(levels[0], name=names[0])</span>
<span class="gi">+            return names[0], index</span>
<span class="gi">+        else:</span>
<span class="gi">+            index = pd.MultiIndex.from_product(levels, names=names)</span>
<span class="gi">+            return names, index</span>

<span class="w"> </span>    def _reorder_columns(self, res, data):
<span class="w"> </span>        &quot;&quot;&quot;Reorder result columns to match original order with new columns appended.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        original_cols = data.columns</span>
<span class="gi">+        new_cols = [col for col in res.columns if col not in original_cols]</span>
<span class="gi">+        reordered_cols = list(original_cols) + new_cols</span>
<span class="gi">+        return res.reindex(columns=reordered_cols)</span>

<span class="gd">-    def agg(self, data: DataFrame, *args, **kwargs) -&gt;DataFrame:</span>
<span class="gi">+    def agg(self, data: DataFrame, *args, **kwargs) -&gt; DataFrame:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Reduce each group to a single row in the output.

<span class="gu">@@ -60,9 +77,27 @@ class GroupBy:</span>
<span class="w"> </span>        those combinations do not appear in the dataset.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        groupers, index = self._get_groups(data)</span>
<span class="gi">+        grouped = data.groupby(groupers, observed=False)</span>
<span class="gi">+        res = grouped.agg(*args, **kwargs)</span>
<span class="gi">+        </span>
<span class="gi">+        if isinstance(res.index, pd.MultiIndex):</span>
<span class="gi">+            res = res.reindex(index)</span>
<span class="gi">+        else:</span>
<span class="gi">+            res = res.reindex(index.get_level_values(0))</span>
<span class="gi">+        </span>
<span class="gi">+        return self._reorder_columns(res, data)</span>

<span class="w"> </span>    def apply(self, data: DataFrame, func: Callable[..., DataFrame], *args,
<span class="gd">-        **kwargs) -&gt;DataFrame:</span>
<span class="gi">+        **kwargs) -&gt; DataFrame:</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply a DataFrame -&gt; DataFrame mapping to each group.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        groupers, index = self._get_groups(data)</span>
<span class="gi">+        grouped = data.groupby(groupers, observed=False)</span>
<span class="gi">+        res = grouped.apply(func, *args, **kwargs)</span>
<span class="gi">+        </span>
<span class="gi">+        if isinstance(res.index, pd.MultiIndex):</span>
<span class="gi">+            res = res.reindex(index.append(pd.Index(res.index.levels[-1])))</span>
<span class="gi">+        else:</span>
<span class="gi">+            res = res.reindex(index)</span>
<span class="gi">+        </span>
<span class="gi">+        return self._reorder_columns(res, data)</span>
<span class="gh">diff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py</span>
<span class="gh">index 0695b4a6..cb54a995 100644</span>
<span class="gd">--- a/seaborn/_core/plot.py</span>
<span class="gi">+++ b/seaborn/_core/plot.py</span>
<span class="gu">@@ -69,7 +69,12 @@ class PairSpec(TypedDict, total=(False)):</span>
<span class="w"> </span>@contextmanager
<span class="w"> </span>def theme_context(params: dict[str, Any]) -&gt;Generator:
<span class="w"> </span>    &quot;&quot;&quot;Temporarily modify specifc matplotlib rcParams.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    original_params = {k: mpl.rcParams[k] for k in params}</span>
<span class="gi">+    mpl.rcParams.update(params)</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        mpl.rcParams.update(original_params)</span>


<span class="w"> </span>def build_plot_signature(cls):
<span class="gu">@@ -81,7 +86,15 @@ def build_plot_signature(cls):</span>
<span class="w"> </span>    at which point dynamic signature generation would become more important.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def wrapper(cls):</span>
<span class="gi">+        params = [</span>
<span class="gi">+            inspect.Parameter(&quot;self&quot;, inspect.Parameter.POSITIONAL_OR_KEYWORD),</span>
<span class="gi">+            inspect.Parameter(&quot;data&quot;, inspect.Parameter.POSITIONAL_OR_KEYWORD, default=None),</span>
<span class="gi">+            *[inspect.Parameter(prop, inspect.Parameter.KEYWORD_ONLY) for prop in PROPERTIES]</span>
<span class="gi">+        ]</span>
<span class="gi">+        cls.__signature__ = inspect.Signature(params)</span>
<span class="gi">+        return cls</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>class ThemeConfig(mpl.RcParams):
<span class="gu">@@ -98,15 +111,24 @@ class ThemeConfig(mpl.RcParams):</span>

<span class="w"> </span>    def reset(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Update the theme dictionary with seaborn&#39;s default values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.clear()</span>
<span class="gi">+        with axes_style() as style, plotting_context() as context:</span>
<span class="gi">+            self.update(style)</span>
<span class="gi">+            self.update(context)</span>

<span class="w"> </span>    def update(self, other: (dict[str, Any] | None)=None, /, **kwds):
<span class="w"> </span>        &quot;&quot;&quot;Update the theme with a dictionary or keyword arguments of rc parameters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if other is not None:</span>
<span class="gi">+            kwds.update(other)</span>
<span class="gi">+        filtered = self._filter_params(kwds)</span>
<span class="gi">+        super().update(filtered)</span>

<span class="w"> </span>    def _filter_params(self, params: dict[str, Any]) -&gt;dict[str, Any]:
<span class="gd">-        &quot;&quot;&quot;Restruct to thematic rc params.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;Restrict to thematic rc params.&quot;&quot;&quot;</span>
<span class="gi">+        return {</span>
<span class="gi">+            k: v for k, v in params.items()</span>
<span class="gi">+            if any(k.startswith(f&quot;{group}.&quot;) for group in self.THEME_GROUPS)</span>
<span class="gi">+        }</span>


<span class="w"> </span>class DisplayConfig(TypedDict):
<span class="gu">@@ -132,7 +154,7 @@ class PlotConfig:</span>
<span class="w"> </span>        https://matplotlib.org/stable/tutorials/introductory/customizing.html

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return dict(self._theme)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def display(self) -&gt;DisplayConfig:
<span class="gu">@@ -146,7 +168,7 @@ class PlotConfig:</span>
<span class="w"> </span>        - hidpi (bool): When True, double the DPI while preserving the size

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._display.copy()</span>


<span class="w"> </span>@build_plot_signature
<span class="gh">diff --git a/seaborn/_core/properties.py b/seaborn/_core/properties.py</span>
<span class="gh">index 74be300e..b9137f0d 100644</span>
<span class="gd">--- a/seaborn/_core/properties.py</span>
<span class="gi">+++ b/seaborn/_core/properties.py</span>
<span class="gu">@@ -36,27 +36,48 @@ class Property:</span>

<span class="w"> </span>    def default_scale(self, data: Series) -&gt;Scale:
<span class="w"> </span>        &quot;&quot;&quot;Given data, initialize appropriate scale class.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data_type = variable_type(data)</span>
<span class="gi">+        if data_type == &quot;numeric&quot;:</span>
<span class="gi">+            return Continuous()</span>
<span class="gi">+        elif data_type == &quot;datetime&quot;:</span>
<span class="gi">+            return Temporal()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return Nominal()</span>

<span class="w"> </span>    def infer_scale(self, arg: Any, data: Series) -&gt;Scale:
<span class="w"> </span>        &quot;&quot;&quot;Given data and a scaling argument, initialize appropriate scale class.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(arg, Scale):</span>
<span class="gi">+            return arg</span>
<span class="gi">+        elif arg is None:</span>
<span class="gi">+            return self.default_scale(data)</span>
<span class="gi">+        elif isinstance(arg, str):</span>
<span class="gi">+            if arg.lower() in [&quot;categorical&quot;, &quot;nominal&quot;]:</span>
<span class="gi">+                return Nominal()</span>
<span class="gi">+            elif arg.lower() in [&quot;numeric&quot;, &quot;continuous&quot;]:</span>
<span class="gi">+                return Continuous()</span>
<span class="gi">+            elif arg.lower() == &quot;datetime&quot;:</span>
<span class="gi">+                return Temporal()</span>
<span class="gi">+        raise ValueError(f&quot;Unrecognized scale type: {arg}&quot;)</span>

<span class="w"> </span>    def get_mapping(self, scale: Scale, data: Series) -&gt;Mapping:
<span class="w"> </span>        &quot;&quot;&quot;Return a function that maps from data domain to property range.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return scale.get_mapping(data)</span>

<span class="w"> </span>    def standardize(self, val: Any) -&gt;Any:
<span class="w"> </span>        &quot;&quot;&quot;Coerce flexible property value to standardized representation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return val</span>

<span class="w"> </span>    def _check_dict_entries(self, levels: list, values: dict) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Input check when values are provided as a dictionary.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        missing = set(levels) - set(values)</span>
<span class="gi">+        if missing:</span>
<span class="gi">+            raise ValueError(f&quot;Missing values for levels: {&#39;, &#39;.join(missing)}&quot;)</span>

<span class="w"> </span>    def _check_list_length(self, levels: list, values: list) -&gt;list:
<span class="w"> </span>        &quot;&quot;&quot;Input check when values are provided as a list.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(values) &lt; len(levels):</span>
<span class="gi">+            raise ValueError(f&quot;Not enough values ({len(values)}) for levels ({len(levels)})&quot;)</span>
<span class="gi">+        return values[:len(levels)]</span>


<span class="w"> </span>class Coordinate(Property):
<span class="gu">@@ -74,35 +95,54 @@ class IntervalProperty(Property):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def default_range(self) -&gt;tuple[float, float]:
<span class="w"> </span>        &quot;&quot;&quot;Min and max values used by default for semantic mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._default_range</span>

<span class="w"> </span>    def _forward(self, values: ArrayLike) -&gt;ArrayLike:
<span class="w"> </span>        &quot;&quot;&quot;Transform applied to native values before linear mapping into interval.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return values</span>

<span class="w"> </span>    def _inverse(self, values: ArrayLike) -&gt;ArrayLike:
<span class="w"> </span>        &quot;&quot;&quot;Transform applied to results of mapping that returns to native values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return values</span>

<span class="w"> </span>    def infer_scale(self, arg: Any, data: Series) -&gt;Scale:
<span class="w"> </span>        &quot;&quot;&quot;Given data and a scaling argument, initialize appropriate scale class.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        scale = super().infer_scale(arg, data)</span>
<span class="gi">+        if isinstance(scale, Continuous):</span>
<span class="gi">+            scale.range = self.default_range</span>
<span class="gi">+        return scale</span>

<span class="w"> </span>    def get_mapping(self, scale: Scale, data: Series) -&gt;Mapping:
<span class="w"> </span>        &quot;&quot;&quot;Return a function that maps from data domain to property range.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(scale, Nominal):</span>
<span class="gi">+            return self._get_nominal_mapping(scale, data)</span>
<span class="gi">+        elif isinstance(scale, Boolean):</span>
<span class="gi">+            return self._get_boolean_mapping(scale, data)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return lambda x: np.interp(self._forward(x), (data.min(), data.max()), self.default_range)</span>

<span class="w"> </span>    def _get_nominal_mapping(self, scale: Nominal, data: Series) -&gt;Mapping:
<span class="w"> </span>        &quot;&quot;&quot;Identify evenly-spaced values using interval or explicit mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        levels = categorical_order(data)</span>
<span class="gi">+        values = self._get_values(scale, levels)</span>
<span class="gi">+        return lambda x: dict(zip(levels, values))[x]</span>

<span class="w"> </span>    def _get_boolean_mapping(self, scale: Boolean, data: Series) -&gt;Mapping:
<span class="w"> </span>        &quot;&quot;&quot;Identify evenly-spaced values using interval or explicit mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        values = self._get_values(scale, [False, True])</span>
<span class="gi">+        return lambda x: values[int(x)]</span>

<span class="w"> </span>    def _get_values(self, scale: Scale, levels: list) -&gt;list:
<span class="w"> </span>        &quot;&quot;&quot;Validate scale.values and identify a value for each level.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if scale.values is None:</span>
<span class="gi">+            n = len(levels)</span>
<span class="gi">+            values = np.linspace(*self.default_range, n)</span>
<span class="gi">+        elif isinstance(scale.values, dict):</span>
<span class="gi">+            self._check_dict_entries(levels, scale.values)</span>
<span class="gi">+            values = [scale.values[level] for level in levels]</span>
<span class="gi">+        else:</span>
<span class="gi">+            values = self._check_list_length(levels, scale.values)</span>
<span class="gi">+        return list(self._inverse(values))</span>


<span class="w"> </span>class PointSize(IntervalProperty):
<span class="gu">@@ -111,11 +151,11 @@ class PointSize(IntervalProperty):</span>

<span class="w"> </span>    def _forward(self, values):
<span class="w"> </span>        &quot;&quot;&quot;Square native values to implement linear scaling of point area.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return np.square(values)</span>

<span class="w"> </span>    def _inverse(self, values):
<span class="w"> </span>        &quot;&quot;&quot;Invert areal values back to point diameter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return np.sqrt(values)</span>


<span class="w"> </span>class LineWidth(IntervalProperty):
<span class="gu">@@ -124,7 +164,7 @@ class LineWidth(IntervalProperty):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def default_range(self) -&gt;tuple[float, float]:
<span class="w"> </span>        &quot;&quot;&quot;Min and max values used by default for semantic mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return 0.5, 2</span>


<span class="w"> </span>class EdgeWidth(IntervalProperty):
<span class="gu">@@ -133,7 +173,7 @@ class EdgeWidth(IntervalProperty):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def default_range(self) -&gt;tuple[float, float]:
<span class="w"> </span>        &quot;&quot;&quot;Min and max values used by default for semantic mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return 0, 2</span>


<span class="w"> </span>class Stroke(IntervalProperty):
<span class="gu">@@ -159,7 +199,7 @@ class FontSize(IntervalProperty):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def default_range(self) -&gt;tuple[float, float]:
<span class="w"> </span>        &quot;&quot;&quot;Min and max values used by default for semantic mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return 8, 12</span>


<span class="w"> </span>class ObjectProperty(Property):
<span class="gu">@@ -170,11 +210,20 @@ class ObjectProperty(Property):</span>

<span class="w"> </span>    def get_mapping(self, scale: Scale, data: Series) -&gt;Mapping:
<span class="w"> </span>        &quot;&quot;&quot;Define mapping as lookup into list of object values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        levels = categorical_order(data)</span>
<span class="gi">+        values = self._get_values(scale, levels)</span>
<span class="gi">+        return lambda x: dict(zip(levels, values)).get(x, self.null_value)</span>

<span class="w"> </span>    def _get_values(self, scale: Scale, levels: list) -&gt;list:
<span class="w"> </span>        &quot;&quot;&quot;Validate scale.values and identify a value for each level.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if scale.values is None:</span>
<span class="gi">+            values = self._default_values(len(levels))</span>
<span class="gi">+        elif isinstance(scale.values, dict):</span>
<span class="gi">+            self._check_dict_entries(levels, scale.values)</span>
<span class="gi">+            values = [scale.values[level] for level in levels]</span>
<span class="gi">+        else:</span>
<span class="gi">+            values = self._check_list_length(levels, scale.values)</span>
<span class="gi">+        return values</span>


<span class="w"> </span>class Marker(ObjectProperty):
<span class="gu">@@ -196,7 +245,11 @@ class Marker(ObjectProperty):</span>
<span class="w"> </span>            All markers will be filled.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        markers = [&#39;o&#39;, &#39;s&#39;, &#39;D&#39;, &#39;^&#39;, &#39;v&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;p&#39;, &#39;h&#39;, &#39;8&#39;]</span>
<span class="gi">+        if n &lt;= len(markers):</span>
<span class="gi">+            return [MarkerStyle(m) for m in markers[:n]]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [MarkerStyle(m) for m in markers + [f&#39;${i}$&#39; for i in range(n - len(markers))]]</span>


<span class="w"> </span>class LineStyle(ObjectProperty):
<span class="gu">@@ -220,12 +273,24 @@ class LineStyle(ObjectProperty):</span>
<span class="w"> </span>            dashes.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dashes = [&quot;&quot;, (4, 1.5), (1, 1),</span>
<span class="gi">+                  (3, 1, 1.5, 1), (5, 1, 1, 1),</span>
<span class="gi">+                  (5, 1, 2, 1, 2, 1), (2, 2, 3, 1.5),</span>
<span class="gi">+                  (1, 2.5, 3, 1.5), (4, 1, 2, 1, 2, 1)]</span>
<span class="gi">+        if n &lt;= len(dashes):</span>
<span class="gi">+            return [self._get_dash_pattern(d) for d in dashes[:n]]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [self._get_dash_pattern(d) for d in dashes + [(1, 1)] * (n - len(dashes))]</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _get_dash_pattern(style: (str | DashPattern)) -&gt;DashPatternWithOffset:
<span class="w"> </span>        &quot;&quot;&quot;Convert linestyle arguments to dash pattern with offset.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(style, str):</span>
<span class="gi">+            return mpl.lines._get_dash_pattern(style)</span>
<span class="gi">+        elif isinstance(style, tuple):</span>
<span class="gi">+            return (0, style)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Unrecognized linestyle: {style}&quot;)</span>


<span class="w"> </span>class TextAlignment(ObjectProperty):
<span class="gu">@@ -247,15 +312,40 @@ class Color(Property):</span>

<span class="w"> </span>    def _standardize_color_sequence(self, colors: ArrayLike) -&gt;ArrayLike:
<span class="w"> </span>        &quot;&quot;&quot;Convert color sequence to RGB(A) array, preserving but not adding alpha.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rgba = to_rgba_array(colors)</span>
<span class="gi">+        if np.all(rgba[:, 3] == 1):</span>
<span class="gi">+            return rgba[:, :3]</span>
<span class="gi">+        return rgba</span>

<span class="w"> </span>    def get_mapping(self, scale: Scale, data: Series) -&gt;Mapping:
<span class="w"> </span>        &quot;&quot;&quot;Return a function that maps from data domain to color values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(scale, Nominal):</span>
<span class="gi">+            levels = categorical_order(data)</span>
<span class="gi">+            palette = self._get_values(scale, levels)</span>
<span class="gi">+            color_list = self._standardize_color_sequence(palette)</span>
<span class="gi">+            return lambda x: dict(zip(levels, color_list))[x]</span>
<span class="gi">+        elif isinstance(scale, Boolean):</span>
<span class="gi">+            palette = self._get_values(scale, [False, True])</span>
<span class="gi">+            color_list = self._standardize_color_sequence(palette)</span>
<span class="gi">+            return lambda x: color_list[int(x)]</span>
<span class="gi">+        else:</span>
<span class="gi">+            palette = self._get_values(scale, [])</span>
<span class="gi">+            return lambda x: self._standardize_color_sequence(</span>
<span class="gi">+                blend_palette(palette, x, as_cmap=True)(x)</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def _get_values(self, scale: Scale, levels: list) -&gt;ArrayLike:
<span class="w"> </span>        &quot;&quot;&quot;Validate scale.values and identify a value for each level.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if scale.values is None:</span>
<span class="gi">+            n_colors = len(levels) if levels else 256</span>
<span class="gi">+            return color_palette(n_colors=n_colors)</span>
<span class="gi">+        elif isinstance(scale.values, str):</span>
<span class="gi">+            return color_palette(scale.values, n_colors=len(levels))</span>
<span class="gi">+        elif isinstance(scale.values, dict):</span>
<span class="gi">+            self._check_dict_entries(levels, scale.values)</span>
<span class="gi">+            return [scale.values[level] for level in levels]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._check_list_length(levels, scale.values)</span>


<span class="w"> </span>class Fill(Property):
<span class="gu">@@ -265,15 +355,29 @@ class Fill(Property):</span>

<span class="w"> </span>    def _default_values(self, n: int) -&gt;list:
<span class="w"> </span>        &quot;&quot;&quot;Return a list of n values, alternating True and False.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [i % 2 == 0 for i in range(n)]</span>

<span class="w"> </span>    def get_mapping(self, scale: Scale, data: Series) -&gt;Mapping:
<span class="w"> </span>        &quot;&quot;&quot;Return a function that maps each data value to True or False.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(scale, Nominal):</span>
<span class="gi">+            levels = categorical_order(data)</span>
<span class="gi">+            values = self._get_values(scale, levels)</span>
<span class="gi">+            return lambda x: dict(zip(levels, values))[x]</span>
<span class="gi">+        elif isinstance(scale, Boolean):</span>
<span class="gi">+            values = self._get_values(scale, [False, True])</span>
<span class="gi">+            return lambda x: values[int(x)]</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Fill property only supports nominal or boolean scales&quot;)</span>

<span class="w"> </span>    def _get_values(self, scale: Scale, levels: list) -&gt;list:
<span class="w"> </span>        &quot;&quot;&quot;Validate scale.values and identify a value for each level.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if scale.values is None:</span>
<span class="gi">+            return self._default_values(len(levels))</span>
<span class="gi">+        elif isinstance(scale.values, dict):</span>
<span class="gi">+            self._check_dict_entries(levels, scale.values)</span>
<span class="gi">+            return [scale.values[level] for level in levels]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._check_list_length(levels, scale.values)</span>


<span class="w"> </span>PROPERTY_CLASSES = {&#39;x&#39;: Coordinate, &#39;y&#39;: Coordinate, &#39;color&#39;: Color,
<span class="gh">diff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py</span>
<span class="gh">index d78093c0..a6be865e 100644</span>
<span class="gd">--- a/seaborn/_core/rules.py</span>
<span class="gi">+++ b/seaborn/_core/rules.py</span>
<span class="gu">@@ -57,7 +57,32 @@ def variable_type(vector: Series, boolean_type: Literal[&#39;numeric&#39;,</span>
<span class="w"> </span>    var_type : &#39;numeric&#39;, &#39;categorical&#39;, or &#39;datetime&#39;
<span class="w"> </span>        Name identifying the type of data in the vector.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(vector, pd.Series):</span>
<span class="gi">+        vector = pd.Series(vector)</span>
<span class="gi">+</span>
<span class="gi">+    if pd.api.types.is_datetime64_any_dtype(vector):</span>
<span class="gi">+        return VarType(&#39;datetime&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if strict_boolean and pd.api.types.is_bool_dtype(vector):</span>
<span class="gi">+        return VarType(boolean_type)</span>
<span class="gi">+</span>
<span class="gi">+    if pd.api.types.is_numeric_dtype(vector):</span>
<span class="gi">+        if set(vector.dropna().unique()) &lt;= {0, 1}:</span>
<span class="gi">+            return VarType(boolean_type)</span>
<span class="gi">+        return VarType(&#39;numeric&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if pd.api.types.is_categorical_dtype(vector):</span>
<span class="gi">+        return VarType(&#39;categorical&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # Check if all values are numeric</span>
<span class="gi">+    try:</span>
<span class="gi">+        pd.to_numeric(vector, errors=&#39;raise&#39;)</span>
<span class="gi">+        return VarType(&#39;numeric&#39;)</span>
<span class="gi">+    except (ValueError, TypeError):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # If we reach here, it&#39;s likely categorical</span>
<span class="gi">+    return VarType(&#39;categorical&#39;)</span>


<span class="w"> </span>def categorical_order(vector: Series, order: (list | None)=None) -&gt;list:
<span class="gu">@@ -78,4 +103,16 @@ def categorical_order(vector: Series, order: (list | None)=None) -&gt;list:</span>
<span class="w"> </span>        Ordered list of category levels not including null values.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if order is not None:</span>
<span class="gi">+        return [c for c in order if c in vector.unique()]</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(vector, &quot;categories&quot;):</span>
<span class="gi">+        return [c for c in vector.categories if c in vector.unique()]</span>
<span class="gi">+</span>
<span class="gi">+    if vector.dtype.name == &quot;category&quot;:</span>
<span class="gi">+        return [c for c in vector.cat.categories if c in vector.unique()]</span>
<span class="gi">+</span>
<span class="gi">+    if pd.api.types.is_numeric_dtype(vector):</span>
<span class="gi">+        return sorted(vector.unique())</span>
<span class="gi">+</span>
<span class="gi">+    return pd.Series(vector).unique().tolist()</span>
<span class="gh">diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py</span>
<span class="gh">index 99f98988..4b3d09ab 100644</span>
<span class="gd">--- a/seaborn/_core/scales.py</span>
<span class="gi">+++ b/seaborn/_core/scales.py</span>
<span class="gu">@@ -101,7 +101,9 @@ class Nominal(Scale):</span>
<span class="w"> </span>        Copy of self with new tick configuration.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new_scale = copy(self)</span>
<span class="gi">+        new_scale._tick_params = {&quot;locator&quot;: locator}</span>
<span class="gi">+        return new_scale</span>

<span class="w"> </span>    def label(self, formatter: (Formatter | None)=None) -&gt;Nominal:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -122,7 +124,9 @@ class Nominal(Scale):</span>
<span class="w"> </span>            Copy of self with new tick configuration.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new_scale = copy(self)</span>
<span class="gi">+        new_scale._label_params = {&quot;formatter&quot;: formatter}</span>
<span class="gi">+        return new_scale</span>


<span class="w"> </span>@dataclass
<span class="gu">@@ -180,7 +184,17 @@ class Continuous(ContinuousBase):</span>
<span class="w"> </span>            Copy of self with new tick configuration.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new_scale = copy(self)</span>
<span class="gi">+        new_scale._tick_params = {</span>
<span class="gi">+            &quot;locator&quot;: locator,</span>
<span class="gi">+            &quot;at&quot;: at,</span>
<span class="gi">+            &quot;upto&quot;: upto,</span>
<span class="gi">+            &quot;count&quot;: count,</span>
<span class="gi">+            &quot;every&quot;: every,</span>
<span class="gi">+            &quot;between&quot;: between,</span>
<span class="gi">+            &quot;minor&quot;: minor</span>
<span class="gi">+        }</span>
<span class="gi">+        return new_scale</span>

<span class="w"> </span>    def label(self, formatter: (Formatter | None)=None, *, like: (str |
<span class="w"> </span>        Callable | None)=None, base: (int | None | Default)=default, unit:
<span class="gu">@@ -211,7 +225,14 @@ class Continuous(ContinuousBase):</span>
<span class="w"> </span>            Copy of self with new label configuration.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new_scale = copy(self)</span>
<span class="gi">+        new_scale._label_params = {</span>
<span class="gi">+            &quot;formatter&quot;: formatter,</span>
<span class="gi">+            &quot;like&quot;: like,</span>
<span class="gi">+            &quot;base&quot;: base,</span>
<span class="gi">+            &quot;unit&quot;: unit</span>
<span class="gi">+        }</span>
<span class="gi">+        return new_scale</span>


<span class="w"> </span>@dataclass
<span class="gu">@@ -243,7 +264,12 @@ class Temporal(ContinuousBase):</span>
<span class="w"> </span>            Copy of self with new tick configuration.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new_scale = copy(self)</span>
<span class="gi">+        new_scale._tick_params = {</span>
<span class="gi">+            &quot;locator&quot;: locator,</span>
<span class="gi">+            &quot;upto&quot;: upto</span>
<span class="gi">+        }</span>
<span class="gi">+        return new_scale</span>

<span class="w"> </span>    def label(self, formatter: (Formatter | None)=None, *, concise: bool=False
<span class="w"> </span>        ) -&gt;Temporal:
<span class="gu">@@ -267,7 +293,12 @@ class Temporal(ContinuousBase):</span>
<span class="w"> </span>            Copy of self with new label configuration.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new_scale = copy(self)</span>
<span class="gi">+        new_scale._label_params = {</span>
<span class="gi">+            &quot;formatter&quot;: formatter,</span>
<span class="gi">+            &quot;concise&quot;: concise</span>
<span class="gi">+        }</span>
<span class="gi">+        return new_scale</span>


<span class="w"> </span>class PseudoAxis:
<span class="gh">diff --git a/seaborn/_core/subplots.py b/seaborn/_core/subplots.py</span>
<span class="gh">index ab72e2f0..3263459e 100644</span>
<span class="gd">--- a/seaborn/_core/subplots.py</span>
<span class="gi">+++ b/seaborn/_core/subplots.py</span>
<span class="gu">@@ -39,27 +39,71 @@ class Subplots:</span>
<span class="w"> </span>    def _check_dimension_uniqueness(self, facet_spec: FacetSpec, pair_spec:
<span class="w"> </span>        PairSpec) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Reject specs that pair and facet on (or wrap to) same figure dimension.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        facet_dims = set(facet_spec.get(&quot;col&quot;, &quot;&quot;)) | set(facet_spec.get(&quot;row&quot;, &quot;&quot;))</span>
<span class="gi">+        pair_dims = set(pair_spec.get(&quot;x&quot;, &quot;&quot;)) | set(pair_spec.get(&quot;y&quot;, &quot;&quot;))</span>
<span class="gi">+        </span>
<span class="gi">+        if facet_dims &amp; pair_dims:</span>
<span class="gi">+            raise ValueError(&quot;Cannot facet and pair on the same dimension.&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        if facet_spec.get(&quot;wrap&quot;) and (facet_spec.get(&quot;wrap&quot;) in pair_dims):</span>
<span class="gi">+            raise ValueError(&quot;Cannot wrap facets on a dimension used for pairing.&quot;)</span>

<span class="w"> </span>    def _determine_grid_dimensions(self, facet_spec: FacetSpec, pair_spec:
<span class="w"> </span>        PairSpec) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Parse faceting and pairing information to define figure structure.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.nrows = facet_spec.get(&quot;row&quot;, 1)</span>
<span class="gi">+        self.ncols = facet_spec.get(&quot;col&quot;, 1)</span>
<span class="gi">+        </span>
<span class="gi">+        if pair_spec:</span>
<span class="gi">+            self.nrows *= len(pair_spec.get(&quot;y&quot;, [1]))</span>
<span class="gi">+            self.ncols *= len(pair_spec.get(&quot;x&quot;, [1]))</span>
<span class="gi">+        </span>
<span class="gi">+        self.n_subplots = self.nrows * self.ncols</span>

<span class="w"> </span>    def _handle_wrapping(self, facet_spec: FacetSpec, pair_spec: PairSpec
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Update figure structure parameters based on facet/pair wrapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        wrap = facet_spec.get(&quot;wrap&quot;)</span>
<span class="gi">+        if wrap:</span>
<span class="gi">+            total_subplots = self.nrows * self.ncols</span>
<span class="gi">+            self.ncols = min(wrap, total_subplots)</span>
<span class="gi">+            self.nrows = (total_subplots - 1) // self.ncols + 1</span>

<span class="w"> </span>    def _determine_axis_sharing(self, pair_spec: PairSpec) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Update subplot spec with default or specified axis sharing parameters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.subplot_spec.setdefault(&quot;sharex&quot;, &quot;col&quot; in pair_spec)</span>
<span class="gi">+        self.subplot_spec.setdefault(&quot;sharey&quot;, &quot;row&quot; in pair_spec)</span>

<span class="w"> </span>    def init_figure(self, pair_spec: PairSpec, pyplot: bool=False,
<span class="w"> </span>        figure_kws: (dict | None)=None, target: (Axes | Figure | SubFigure |
<span class="w"> </span>        None)=None) -&gt;Figure:
<span class="w"> </span>        &quot;&quot;&quot;Initialize matplotlib objects and add seaborn-relevant metadata.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if target is None:</span>
<span class="gi">+            if pyplot:</span>
<span class="gi">+                fig, axes = plt.subplots(self.nrows, self.ncols, **self.subplot_spec)</span>
<span class="gi">+            else:</span>
<span class="gi">+                fig = Figure(**figure_kws or {})</span>
<span class="gi">+                axes = fig.subplots(self.nrows, self.ncols, **self.subplot_spec)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(target, Axes):</span>
<span class="gi">+                fig = target.figure</span>
<span class="gi">+                axes = np.array([[target]])</span>
<span class="gi">+            elif isinstance(target, (Figure, SubFigure)):</span>
<span class="gi">+                fig = target</span>
<span class="gi">+                axes = fig.subplots(self.nrows, self.ncols, **self.subplot_spec)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise TypeError(&quot;Unsupported target type&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self._subplot_list = [</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;ax&quot;: ax,</span>
<span class="gi">+                &quot;row&quot;: i // self.ncols,</span>
<span class="gi">+                &quot;col&quot;: i % self.ncols,</span>
<span class="gi">+            }</span>
<span class="gi">+            for i, ax in enumerate(axes.flat)</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        return fig</span>

<span class="w"> </span>    def __iter__(self) -&gt;Generator[dict, None, None]:
<span class="w"> </span>        &quot;&quot;&quot;Yield each subplot dictionary with Axes object and metadata.&quot;&quot;&quot;
<span class="gh">diff --git a/seaborn/_docstrings.py b/seaborn/_docstrings.py</span>
<span class="gh">index 92bca3b0..6d90fb35 100644</span>
<span class="gd">--- a/seaborn/_docstrings.py</span>
<span class="gi">+++ b/seaborn/_docstrings.py</span>
<span class="gu">@@ -36,12 +36,25 @@ class DocstringComponents:</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_nested_components(cls, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Add multiple sub-sets of components.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        entries = {}</span>
<span class="gi">+        for key, value in kwargs.items():</span>
<span class="gi">+            if isinstance(value, cls):</span>
<span class="gi">+                entries.update(value.entries)</span>
<span class="gi">+            elif isinstance(value, dict):</span>
<span class="gi">+                entries.update(value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(f&quot;Invalid component type for {key}&quot;)</span>
<span class="gi">+        return cls(entries)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_function_params(cls, func):
<span class="w"> </span>        &quot;&quot;&quot;Use the numpydoc parser to extract components from existing func.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        doc = NumpyDocString(pydoc.getdoc(func))</span>
<span class="gi">+        params = {}</span>
<span class="gi">+        for param in doc[&#39;Parameters&#39;]:</span>
<span class="gi">+            name, _, desc = param</span>
<span class="gi">+            params[name] = &#39;\n&#39;.join(desc)</span>
<span class="gi">+        return cls(params)</span>


<span class="w"> </span>_core_params = dict(data=
<span class="gh">diff --git a/seaborn/_marks/area.py b/seaborn/_marks/area.py</span>
<span class="gh">index 427c1a16..bb3181cd 100644</span>
<span class="gd">--- a/seaborn/_marks/area.py</span>
<span class="gi">+++ b/seaborn/_marks/area.py</span>
<span class="gu">@@ -7,7 +7,30 @@ from seaborn._marks.base import Mark, Mappable, MappableBool, MappableFloat, Map</span>


<span class="w"> </span>class AreaBase:
<span class="gd">-    pass</span>
<span class="gi">+    def __init__(self):</span>
<span class="gi">+        self._artist = None</span>
<span class="gi">+</span>
<span class="gi">+    def _plot(self, ax, x, y, y2=None, **kwargs):</span>
<span class="gi">+        if y2 is None:</span>
<span class="gi">+            y2 = self.baseline</span>
<span class="gi">+        </span>
<span class="gi">+        fill_between_kwargs = {</span>
<span class="gi">+            &#39;x&#39;: x,</span>
<span class="gi">+            &#39;y1&#39;: y,</span>
<span class="gi">+            &#39;y2&#39;: y2,</span>
<span class="gi">+            &#39;color&#39;: kwargs.get(&#39;color&#39;),</span>
<span class="gi">+            &#39;alpha&#39;: kwargs.get(&#39;alpha&#39;),</span>
<span class="gi">+            &#39;edgecolor&#39;: kwargs.get(&#39;edgecolor&#39;),</span>
<span class="gi">+            &#39;linewidth&#39;: kwargs.get(&#39;edgewidth&#39;),</span>
<span class="gi">+            &#39;linestyle&#39;: kwargs.get(&#39;edgestyle&#39;),</span>
<span class="gi">+        }</span>
<span class="gi">+        </span>
<span class="gi">+        self._artist = ax.fill_between(**fill_between_kwargs)</span>
<span class="gi">+        return self._artist</span>
<span class="gi">+</span>
<span class="gi">+    def _legend_artist(self, color):</span>
<span class="gi">+        from matplotlib.patches import Rectangle</span>
<span class="gi">+        return Rectangle((0, 0), 1, 1, facecolor=color, edgecolor=None)</span>


<span class="w"> </span>@document_properties
<span class="gu">@@ -34,6 +57,22 @@ class Area(AreaBase, Mark):</span>
<span class="w"> </span>    edgestyle: MappableStyle = Mappable(&#39;-&#39;)
<span class="w"> </span>    baseline: MappableFloat = Mappable(0, grouping=False)

<span class="gi">+    def __post_init__(self):</span>
<span class="gi">+        super().__init__()</span>
<span class="gi">+</span>
<span class="gi">+    def plot(self, ax, x, y, **kwargs):</span>
<span class="gi">+        properties = resolve_properties(self, kwargs)</span>
<span class="gi">+        if not properties[&#39;fill&#39;]:</span>
<span class="gi">+            properties[&#39;alpha&#39;] = 0</span>
<span class="gi">+        </span>
<span class="gi">+        color = resolve_color(properties.pop(&#39;color&#39;))</span>
<span class="gi">+        properties[&#39;color&#39;] = color</span>
<span class="gi">+        </span>
<span class="gi">+        edgecolor = resolve_color(properties.pop(&#39;edgecolor&#39;), color)</span>
<span class="gi">+        properties[&#39;edgecolor&#39;] = edgecolor</span>
<span class="gi">+        </span>
<span class="gi">+        return self._plot(ax, x, y, **properties)</span>
<span class="gi">+</span>

<span class="w"> </span>@document_properties
<span class="w"> </span>@dataclass
<span class="gu">@@ -57,3 +96,19 @@ class Band(AreaBase, Mark):</span>
<span class="w"> </span>    edgealpha: MappableFloat = Mappable(1)
<span class="w"> </span>    edgewidth: MappableFloat = Mappable(0)
<span class="w"> </span>    edgestyle: MappableFloat = Mappable(&#39;-&#39;)
<span class="gi">+</span>
<span class="gi">+    def __post_init__(self):</span>
<span class="gi">+        super().__init__()</span>
<span class="gi">+</span>
<span class="gi">+    def plot(self, ax, x, y1, y2, **kwargs):</span>
<span class="gi">+        properties = resolve_properties(self, kwargs)</span>
<span class="gi">+        if not properties[&#39;fill&#39;]:</span>
<span class="gi">+            properties[&#39;alpha&#39;] = 0</span>
<span class="gi">+        </span>
<span class="gi">+        color = resolve_color(properties.pop(&#39;color&#39;))</span>
<span class="gi">+        properties[&#39;color&#39;] = color</span>
<span class="gi">+        </span>
<span class="gi">+        edgecolor = resolve_color(properties.pop(&#39;edgecolor&#39;), color)</span>
<span class="gi">+        properties[&#39;edgecolor&#39;] = edgecolor</span>
<span class="gi">+        </span>
<span class="gi">+        return self._plot(ax, x, y1, y2, **properties)</span>
<span class="gh">diff --git a/seaborn/_marks/base.py b/seaborn/_marks/base.py</span>
<span class="gh">index 03ee03a9..d643a8c5 100644</span>
<span class="gd">--- a/seaborn/_marks/base.py</span>
<span class="gi">+++ b/seaborn/_marks/base.py</span>
<span class="gu">@@ -62,12 +62,19 @@ class Mappable:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def depend(self) -&gt;Any:
<span class="w"> </span>        &quot;&quot;&quot;Return the name of the feature to source a default value from.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._depend</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def default(self) -&gt;Any:
<span class="w"> </span>        &quot;&quot;&quot;Get the default value for this feature, or access the relevant rcParam.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._val is not None:</span>
<span class="gi">+            return self._val</span>
<span class="gi">+        elif self._rc is not None:</span>
<span class="gi">+            return mpl.rcParams[self._rc]</span>
<span class="gi">+        elif self._auto:</span>
<span class="gi">+            return None  # This will be handled at compile time</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>


<span class="w"> </span>MappableBool = Union[bool, Mappable]
<span class="gu">@@ -103,12 +110,33 @@ class Mark:</span>
<span class="w"> </span>            of values with matching length).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        feature = getattr(self, name)</span>
<span class="gi">+        </span>
<span class="gi">+        if isinstance(feature, Mappable):</span>
<span class="gi">+            if feature.depend is not None:</span>
<span class="gi">+                return self._resolve(data, feature.depend, scales)</span>
<span class="gi">+            elif name in data:</span>
<span class="gi">+                if isinstance(data, dict):</span>
<span class="gi">+                    return data[name]</span>
<span class="gi">+                elif isinstance(data, DataFrame):</span>
<span class="gi">+                    if scales and name in scales:</span>
<span class="gi">+                        return scales[name].transform(data[name])</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        return data[name].to_numpy()</span>
<span class="gi">+            else:</span>
<span class="gi">+                return feature.default</span>
<span class="gi">+        else:</span>
<span class="gi">+            return feature</span>

<span class="w"> </span>    def _plot(self, split_generator: Callable[[], Generator], scales: dict[
<span class="w"> </span>        str, Scale], orient: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Main interface for creating a plot.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for split_data in split_generator():</span>
<span class="gi">+            self._draw(split_data, scales, orient)</span>
<span class="gi">+</span>
<span class="gi">+    def _draw(self, data: DataFrame, scales: dict[str, Scale], orient: str) -&gt;None:</span>
<span class="gi">+        &quot;&quot;&quot;Abstract method to be implemented by subclasses for actual drawing.&quot;&quot;&quot;</span>
<span class="gi">+        raise NotImplementedError(&quot;Subclasses must implement _draw method&quot;)</span>


<span class="w"> </span>def resolve_color(mark: Mark, data: (DataFrame | dict), prefix: str=&#39;&#39;,
<span class="gu">@@ -133,4 +161,21 @@ def resolve_color(mark: Mark, data: (DataFrame | dict), prefix: str=&#39;&#39;,</span>
<span class="w"> </span>        Support &quot;color&quot;, &quot;fillcolor&quot;, etc.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    color_name = f&quot;{prefix}color&quot; if prefix else &quot;color&quot;</span>
<span class="gi">+    alpha_name = f&quot;{prefix}alpha&quot; if prefix else &quot;alpha&quot;</span>
<span class="gi">+</span>
<span class="gi">+    color = mark._resolve(data, color_name, scales)</span>
<span class="gi">+    alpha = mark._resolve(data, alpha_name, scales)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(data, dict):</span>
<span class="gi">+        return _apply_alpha_to_color(color, alpha)</span>
<span class="gi">+    elif isinstance(data, DataFrame):</span>
<span class="gi">+        return np.array([_apply_alpha_to_color(c, a) for c, a in zip(color, alpha)])</span>
<span class="gi">+</span>
<span class="gi">+def _apply_alpha_to_color(color: Any, alpha: float) -&gt;RGBATuple:</span>
<span class="gi">+    &quot;&quot;&quot;Helper function to apply alpha to a color.&quot;&quot;&quot;</span>
<span class="gi">+    try:</span>
<span class="gi">+        c = mpl.colors.to_rgba(color)</span>
<span class="gi">+        return c[:3] + (alpha if alpha is not None else c[3],)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise PlotSpecError(f&quot;Invalid color specification: {color}&quot;)</span>
<span class="gh">diff --git a/seaborn/_statistics.py b/seaborn/_statistics.py</span>
<span class="gh">index 2b81faf7..ecbeb933 100644</span>
<span class="gd">--- a/seaborn/_statistics.py</span>
<span class="gi">+++ b/seaborn/_statistics.py</span>
<span class="gu">@@ -79,31 +79,66 @@ class KDE:</span>

<span class="w"> </span>    def _define_support_grid(self, x, bw, cut, clip, gridsize):
<span class="w"> </span>        &quot;&quot;&quot;Create the grid of evaluation points depending for vector x.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x = np.asarray(x)</span>
<span class="gi">+        support_min = x.min() - bw * cut</span>
<span class="gi">+        support_max = x.max() + bw * cut</span>
<span class="gi">+        if clip is not None:</span>
<span class="gi">+            support_min = max(support_min, clip[0])</span>
<span class="gi">+            support_max = min(support_max, clip[1])</span>
<span class="gi">+        return np.linspace(support_min, support_max, gridsize)</span>

<span class="w"> </span>    def _define_support_univariate(self, x, weights):
<span class="w"> </span>        &quot;&quot;&quot;Create a 1D grid of evaluation points.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kde = self._fit(x, weights)</span>
<span class="gi">+        bw = kde.factor * np.std(x, ddof=1)</span>
<span class="gi">+        return self._define_support_grid(x, bw, self.cut, self.clip, self.gridsize)</span>

<span class="w"> </span>    def _define_support_bivariate(self, x1, x2, weights):
<span class="w"> </span>        &quot;&quot;&quot;Create a 2D grid of evaluation points.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kde = self._fit(np.c_[x1, x2], weights)</span>
<span class="gi">+        bw = kde.factor * np.std([x1, x2], axis=1, ddof=1)</span>
<span class="gi">+        grid1 = self._define_support_grid(x1, bw[0], self.cut, self.clip[0], self.gridsize)</span>
<span class="gi">+        grid2 = self._define_support_grid(x2, bw[1], self.cut, self.clip[1], self.gridsize)</span>
<span class="gi">+        return np.meshgrid(grid1, grid2)</span>

<span class="w"> </span>    def define_support(self, x1, x2=None, weights=None, cache=True):
<span class="w"> </span>        &quot;&quot;&quot;Create the evaluation grid for a given data set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if x2 is None:</span>
<span class="gi">+            support = self._define_support_univariate(x1, weights)</span>
<span class="gi">+        else:</span>
<span class="gi">+            support = self._define_support_bivariate(x1, x2, weights)</span>
<span class="gi">+        </span>
<span class="gi">+        if cache:</span>
<span class="gi">+            self.support = support</span>
<span class="gi">+        return support</span>

<span class="w"> </span>    def _fit(self, fit_data, weights=None):
<span class="w"> </span>        &quot;&quot;&quot;Fit the scipy kde while adding bw_adjust logic and version check.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kde = gaussian_kde(fit_data.T, weights=weights, bw_method=self.bw_method)</span>
<span class="gi">+        kde.set_bandwidth(kde.factor * self.bw_adjust)</span>
<span class="gi">+        return kde</span>

<span class="w"> </span>    def _eval_univariate(self, x, weights=None):
<span class="w"> </span>        &quot;&quot;&quot;Fit and evaluate a univariate on univariate data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kde = self._fit(x[:, np.newaxis], weights)</span>
<span class="gi">+        if self.support is None:</span>
<span class="gi">+            self.define_support(x, weights=weights)</span>
<span class="gi">+        density = kde(self.support)</span>
<span class="gi">+        if self.cumulative:</span>
<span class="gi">+            density = np.cumsum(density) / density.sum()</span>
<span class="gi">+        return self.support, density</span>

<span class="w"> </span>    def _eval_bivariate(self, x1, x2, weights=None):
<span class="w"> </span>        &quot;&quot;&quot;Fit and evaluate a univariate on bivariate data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kde = self._fit(np.c_[x1, x2], weights)</span>
<span class="gi">+        if self.support is None:</span>
<span class="gi">+            self.define_support(x1, x2, weights=weights)</span>
<span class="gi">+        density = kde(np.vstack([self.support[0].ravel(), self.support[1].ravel()]))</span>
<span class="gi">+        density = density.reshape(self.support[0].shape)</span>
<span class="gi">+        if self.cumulative:</span>
<span class="gi">+            density = np.cumsum(density.ravel()).reshape(density.shape)</span>
<span class="gi">+            density /= density.max()</span>
<span class="gi">+        return self.support, density</span>

<span class="w"> </span>    def __call__(self, x1, x2=None, weights=None):
<span class="w"> </span>        &quot;&quot;&quot;Fit and evaluate on univariate or bivariate data.&quot;&quot;&quot;
<span class="gu">@@ -159,22 +194,75 @@ class Histogram:</span>
<span class="w"> </span>        self.cumulative = cumulative
<span class="w"> </span>        self.bin_kws = None

<span class="gd">-    def _define_bin_edges(self, x, weights, bins, binwidth, binrange, discrete</span>
<span class="gd">-        ):</span>
<span class="gi">+    def _define_bin_edges(self, x, weights, bins, binwidth, binrange, discrete):</span>
<span class="w"> </span>        &quot;&quot;&quot;Inner function that takes bin parameters as arguments.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if discrete:</span>
<span class="gi">+            bins = np.arange(x.min() - 0.5, x.max() + 1.5)</span>
<span class="gi">+        elif binwidth is not None:</span>
<span class="gi">+            bins = np.arange(binrange[0], binrange[1] + binwidth, binwidth)</span>
<span class="gi">+        else:</span>
<span class="gi">+            bins = np.histogram_bin_edges(x, bins, binrange, weights)</span>
<span class="gi">+        return bins</span>

<span class="w"> </span>    def define_bin_params(self, x1, x2=None, weights=None, cache=True):
<span class="w"> </span>        &quot;&quot;&quot;Given data, return numpy.histogram parameters to define bins.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if x2 is None:</span>
<span class="gi">+            bin_edges = self._define_bin_edges(x1, weights, self.bins, self.binwidth, self.binrange, self.discrete)</span>
<span class="gi">+            bin_kws = {&quot;bins&quot;: bin_edges}</span>
<span class="gi">+        else:</span>
<span class="gi">+            bin_edges1 = self._define_bin_edges(x1, weights, self.bins, self.binwidth, self.binrange[0], self.discrete[0])</span>
<span class="gi">+            bin_edges2 = self._define_bin_edges(x2, weights, self.bins, self.binwidth, self.binrange[1], self.discrete[1])</span>
<span class="gi">+            bin_kws = {&quot;bins&quot;: [bin_edges1, bin_edges2]}</span>
<span class="gi">+        </span>
<span class="gi">+        if cache:</span>
<span class="gi">+            self.bin_kws = bin_kws</span>
<span class="gi">+        return bin_kws</span>

<span class="w"> </span>    def _eval_bivariate(self, x1, x2, weights):
<span class="w"> </span>        &quot;&quot;&quot;Inner function for histogram of two variables.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.bin_kws is None:</span>
<span class="gi">+            self.define_bin_params(x1, x2, weights)</span>
<span class="gi">+        </span>
<span class="gi">+        hist, _, _ = np.histogram2d(x1, x2, weights=weights, **self.bin_kws)</span>
<span class="gi">+        </span>
<span class="gi">+        if self.stat == &quot;density&quot;:</span>
<span class="gi">+            hist /= hist.sum() * np.diff(self.bin_kws[&quot;bins&quot;][0]).mean() * np.diff(self.bin_kws[&quot;bins&quot;][1]).mean()</span>
<span class="gi">+        elif self.stat in [&quot;probability&quot;, &quot;proportion&quot;]:</span>
<span class="gi">+            hist /= hist.sum()</span>
<span class="gi">+        elif self.stat == &quot;percent&quot;:</span>
<span class="gi">+            hist /= hist.sum() / 100</span>
<span class="gi">+        elif self.stat == &quot;frequency&quot;:</span>
<span class="gi">+            hist /= np.diff(self.bin_kws[&quot;bins&quot;][0]).mean() * np.diff(self.bin_kws[&quot;bins&quot;][1]).mean()</span>
<span class="gi">+        </span>
<span class="gi">+        if self.cumulative:</span>
<span class="gi">+            hist = np.cumsum(hist)</span>
<span class="gi">+            if self.stat in [&quot;probability&quot;, &quot;proportion&quot;, &quot;percent&quot;]:</span>
<span class="gi">+                hist /= hist[-1, -1]</span>
<span class="gi">+        </span>
<span class="gi">+        return self.bin_kws[&quot;bins&quot;][0], self.bin_kws[&quot;bins&quot;][1], hist</span>

<span class="w"> </span>    def _eval_univariate(self, x, weights):
<span class="w"> </span>        &quot;&quot;&quot;Inner function for histogram of one variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.bin_kws is None:</span>
<span class="gi">+            self.define_bin_params(x, weights=weights)</span>
<span class="gi">+        </span>
<span class="gi">+        hist, bin_edges = np.histogram(x, weights=weights, **self.bin_kws)</span>
<span class="gi">+        </span>
<span class="gi">+        if self.stat == &quot;density&quot;:</span>
<span class="gi">+            hist = hist / (hist.sum() * np.diff(bin_edges))</span>
<span class="gi">+        elif self.stat in [&quot;probability&quot;, &quot;proportion&quot;]:</span>
<span class="gi">+            hist = hist / hist.sum()</span>
<span class="gi">+        elif self.stat == &quot;percent&quot;:</span>
<span class="gi">+            hist = hist / hist.sum() * 100</span>
<span class="gi">+        elif self.stat == &quot;frequency&quot;:</span>
<span class="gi">+            hist = hist / np.diff(bin_edges)</span>
<span class="gi">+        </span>
<span class="gi">+        if self.cumulative:</span>
<span class="gi">+            hist = np.cumsum(hist)</span>
<span class="gi">+            if self.stat in [&quot;probability&quot;, &quot;proportion&quot;, &quot;percent&quot;]:</span>
<span class="gi">+                hist /= hist[-1]</span>
<span class="gi">+        </span>
<span class="gi">+        return bin_edges, hist</span>

<span class="w"> </span>    def __call__(self, x1, x2=None, weights=None):
<span class="w"> </span>        &quot;&quot;&quot;Count the occurrences in each bin, maybe normalize.&quot;&quot;&quot;
<span class="gu">@@ -204,11 +292,28 @@ class ECDF:</span>

<span class="w"> </span>    def _eval_bivariate(self, x1, x2, weights):
<span class="w"> </span>        &quot;&quot;&quot;Inner function for ECDF of two variables.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;Bivariate ECDF is not implemented.&quot;)</span>

<span class="w"> </span>    def _eval_univariate(self, x, weights):
<span class="w"> </span>        &quot;&quot;&quot;Inner function for ECDF of one variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sorter = np.argsort(x)</span>
<span class="gi">+        x = x[sorter]</span>
<span class="gi">+        weights = weights[sorter]</span>
<span class="gi">+        </span>
<span class="gi">+        cumulative_weights = np.cumsum(weights)</span>
<span class="gi">+        total_weight = cumulative_weights[-1]</span>
<span class="gi">+        </span>
<span class="gi">+        if self.stat == &quot;count&quot;:</span>
<span class="gi">+            y = cumulative_weights</span>
<span class="gi">+        elif self.stat == &quot;proportion&quot;:</span>
<span class="gi">+            y = cumulative_weights / total_weight</span>
<span class="gi">+        elif self.stat == &quot;percent&quot;:</span>
<span class="gi">+            y = 100 * cumulative_weights / total_weight</span>
<span class="gi">+        </span>
<span class="gi">+        if self.complementary:</span>
<span class="gi">+            y = total_weight - y if self.stat == &quot;count&quot; else 1 - y</span>
<span class="gi">+        </span>
<span class="gi">+        return x, y</span>

<span class="w"> </span>    def __call__(self, x1, x2=None, weights=None):
<span class="w"> </span>        &quot;&quot;&quot;Return proportion or count of observations below each sorted datapoint.&quot;&quot;&quot;
<span class="gu">@@ -379,12 +484,39 @@ class LetterValues:</span>
<span class="w"> </span>        return {&#39;k&#39;: k, &#39;levels&#39;: levels, &#39;percs&#39;: percentiles, &#39;values&#39;:
<span class="w"> </span>            values, &#39;fliers&#39;: fliers, &#39;median&#39;: median}

<span class="gi">+    def _compute_k(self, n):</span>
<span class="gi">+        &quot;&quot;&quot;Compute the number of letter values to use.&quot;&quot;&quot;</span>
<span class="gi">+        if isinstance(self.k_depth, int):</span>
<span class="gi">+            return min(self.k_depth, int(np.log2(n)))</span>
<span class="gi">+        elif self.k_depth == &#39;tukey&#39;:</span>
<span class="gi">+            return min(int(np.log2(n)), 3)</span>
<span class="gi">+        elif self.k_depth == &#39;proportion&#39;:</span>
<span class="gi">+            return min(int(np.log2(n)), max(1, int(-np.log2(2 * self.outlier_prop))))</span>
<span class="gi">+        elif self.k_depth == &#39;trustworthy&#39;:</span>
<span class="gi">+            return min(int(np.log2(n)), max(1, int(-np.log2(2 * self.trust_alpha / n))))</span>
<span class="gi">+        else:  # &#39;full&#39;</span>
<span class="gi">+            return int(np.log2(n))</span>
<span class="gi">+</span>

<span class="w"> </span>def _percentile_interval(data, width):
<span class="w"> </span>    &quot;&quot;&quot;Return a percentile interval from data of a given width.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    low, high = (50 - width / 2, 50 + width / 2)</span>
<span class="gi">+    return np.percentile(data, [low, high])</span>


<span class="w"> </span>def _validate_errorbar_arg(arg):
<span class="w"> </span>    &quot;&quot;&quot;Check type and value of errorbar argument and assign default level.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if arg is None:</span>
<span class="gi">+        return None, None</span>
<span class="gi">+    elif isinstance(arg, str):</span>
<span class="gi">+        method = arg</span>
<span class="gi">+        level = .95 if method == &quot;ci&quot; else 1</span>
<span class="gi">+    elif isinstance(arg, tuple):</span>
<span class="gi">+        method, level = arg</span>
<span class="gi">+    elif callable(arg):</span>
<span class="gi">+        method = arg</span>
<span class="gi">+        level = None</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Input {arg!r} not understood for errorbar.&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    return method, level</span>
<span class="gh">diff --git a/seaborn/_stats/base.py b/seaborn/_stats/base.py</span>
<span class="gh">index 4c8201ba..3055a586 100644</span>
<span class="gd">--- a/seaborn/_stats/base.py</span>
<span class="gi">+++ b/seaborn/_stats/base.py</span>
<span class="gu">@@ -18,14 +18,30 @@ class Stat:</span>

<span class="w"> </span>    def _check_param_one_of(self, param: str, options: Iterable[Any]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Raise when parameter value is not one of a specified set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if param not in options:</span>
<span class="gi">+            raise ValueError(f&quot;Parameter &#39;{param}&#39; must be one of {options}&quot;)</span>

<span class="w"> </span>    def _check_grouping_vars(self, param: str, data_vars: list[str],
<span class="w"> </span>        stacklevel: int=2) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Warn if vars are named in parameter without being present in the data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        missing_vars = set(param.split()) - set(data_vars)</span>
<span class="gi">+        if missing_vars:</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                f&quot;The following variable(s) are not present in the data: {&#39;, &#39;.join(missing_vars)}&quot;,</span>
<span class="gi">+                UserWarning,</span>
<span class="gi">+                stacklevel=stacklevel</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def __call__(self, data: DataFrame, groupby: GroupBy, orient: str,
<span class="w"> </span>        scales: dict[str, Scale]) -&gt;DataFrame:
<span class="w"> </span>        &quot;&quot;&quot;Apply statistical transform to data subgroups and return combined result.&quot;&quot;&quot;
<span class="gd">-        return data</span>
<span class="gi">+        if self.group_by_orient:</span>
<span class="gi">+            grouped_data = groupby.apply(data, self._transform, orient, scales)</span>
<span class="gi">+        else:</span>
<span class="gi">+            grouped_data = groupby.agg(data, self._transform, orient, scales)</span>
<span class="gi">+        return grouped_data</span>
<span class="gi">+</span>
<span class="gi">+    def _transform(self, data: DataFrame, orient: str, scales: dict[str, Scale]) -&gt;DataFrame:</span>
<span class="gi">+        &quot;&quot;&quot;Implement the statistical transformation.&quot;&quot;&quot;</span>
<span class="gi">+        # This method should be overridden in subclasses</span>
<span class="gi">+        raise NotImplementedError(&quot;Subclasses must implement _transform method&quot;)</span>
<span class="gh">diff --git a/seaborn/_stats/counting.py b/seaborn/_stats/counting.py</span>
<span class="gh">index b1bf2a2d..ebcd2f42 100644</span>
<span class="gd">--- a/seaborn/_stats/counting.py</span>
<span class="gi">+++ b/seaborn/_stats/counting.py</span>
<span class="gu">@@ -112,11 +112,45 @@ class Hist(Stat):</span>
<span class="w"> </span>    def _define_bin_edges(self, vals, weight, bins, binwidth, binrange,
<span class="w"> </span>        discrete):
<span class="w"> </span>        &quot;&quot;&quot;Inner function that takes bin parameters as arguments.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if discrete:</span>
<span class="gi">+            if binrange is None:</span>
<span class="gi">+                start, stop = int(vals.min()), int(vals.max())</span>
<span class="gi">+            else:</span>
<span class="gi">+                start, stop = map(int, binrange)</span>
<span class="gi">+            return np.arange(start - 0.5, stop + 1.5)</span>
<span class="gi">+</span>
<span class="gi">+        if binwidth is not None:</span>
<span class="gi">+            if binrange is None:</span>
<span class="gi">+                start, stop = vals.min(), vals.max()</span>
<span class="gi">+            else:</span>
<span class="gi">+                start, stop = binrange</span>
<span class="gi">+            return np.arange(start, stop + binwidth, binwidth)</span>
<span class="gi">+</span>
<span class="gi">+        if np.isscalar(bins):</span>
<span class="gi">+            if binrange is not None:</span>
<span class="gi">+                range_param = binrange</span>
<span class="gi">+            else:</span>
<span class="gi">+                range_param = (vals.min(), vals.max())</span>
<span class="gi">+            return np.histogram_bin_edges(vals, bins, range_param, weights=weight)</span>
<span class="gi">+</span>
<span class="gi">+        return np.asarray(bins)</span>

<span class="w"> </span>    def _define_bin_params(self, data, orient, scale_type):
<span class="w"> </span>        &quot;&quot;&quot;Given data, return numpy.histogram parameters to define bins.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        vals = data[orient].to_numpy()</span>
<span class="gi">+        weight = data.get(&quot;weight&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        if scale_type == &quot;datetime&quot;:</span>
<span class="gi">+            vals = vals.astype(float)</span>
<span class="gi">+</span>
<span class="gi">+        bin_edges = self._define_bin_edges(</span>
<span class="gi">+            vals, weight, self.bins, self.binwidth, self.binrange, self.discrete</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if scale_type == &quot;datetime&quot;:</span>
<span class="gi">+            bin_edges = pd.to_datetime(bin_edges)</span>
<span class="gi">+</span>
<span class="gi">+        return dict(bins=bin_edges, range=(bin_edges[0], bin_edges[-1]))</span>

<span class="w"> </span>    def __call__(self, data: DataFrame, groupby: GroupBy, orient: str,
<span class="w"> </span>        scales: dict[str, Scale]) -&gt;DataFrame:
<span class="gh">diff --git a/seaborn/_stats/density.py b/seaborn/_stats/density.py</span>
<span class="gh">index 410c1a0b..896aca3b 100644</span>
<span class="gd">--- a/seaborn/_stats/density.py</span>
<span class="gi">+++ b/seaborn/_stats/density.py</span>
<span class="gu">@@ -96,25 +96,61 @@ class KDE(Stat):</span>
<span class="w"> </span>    def _check_var_list_or_boolean(self, param: str, grouping_vars: Any
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Do input checks on grouping parameters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(getattr(self, param), (bool, list)):</span>
<span class="gi">+            raise TypeError(f&quot;{param} must be boolean or list of variables&quot;)</span>
<span class="gi">+        if isinstance(getattr(self, param), list):</span>
<span class="gi">+            invalid_vars = set(getattr(self, param)) - set(grouping_vars)</span>
<span class="gi">+            if invalid_vars:</span>
<span class="gi">+                raise ValueError(f&quot;Invalid variables in {param}: {invalid_vars}&quot;)</span>

<span class="w"> </span>    def _fit(self, data: DataFrame, orient: str) -&gt;gaussian_kde:
<span class="w"> </span>        &quot;&quot;&quot;Fit and return a KDE object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x = data[orient].to_numpy()</span>
<span class="gi">+        weights = data[&#39;weight&#39;].to_numpy()</span>
<span class="gi">+        kde = gaussian_kde(x, weights=weights, bw_method=self.bw_method)</span>
<span class="gi">+        kde.set_bandwidth(kde.factor * self.bw_adjust)</span>
<span class="gi">+        return kde</span>

<span class="w"> </span>    def _get_support(self, data: DataFrame, orient: str) -&gt;ndarray:
<span class="w"> </span>        &quot;&quot;&quot;Define the grid that the KDE will be evaluated on.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x = data[orient]</span>
<span class="gi">+        if self.gridsize is None:</span>
<span class="gi">+            return x.to_numpy()</span>
<span class="gi">+        </span>
<span class="gi">+        bw = self._fit(data, orient).factor</span>
<span class="gi">+        grid_min = x.min() - self.cut * bw</span>
<span class="gi">+        grid_max = x.max() + self.cut * bw</span>
<span class="gi">+        return np.linspace(grid_min, grid_max, self.gridsize)</span>

<span class="w"> </span>    def _fit_and_evaluate(self, data: DataFrame, orient: str, support: ndarray
<span class="w"> </span>        ) -&gt;DataFrame:
<span class="w"> </span>        &quot;&quot;&quot;Transform single group by fitting a KDE and evaluating on a support grid.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kde = self._fit(data, orient)</span>
<span class="gi">+        density = kde(support)</span>
<span class="gi">+        </span>
<span class="gi">+        if self.cumulative:</span>
<span class="gi">+            density = np.cumsum(density) / np.sum(density)</span>
<span class="gi">+        </span>
<span class="gi">+        return pd.DataFrame({orient: support, &#39;density&#39;: density})</span>

<span class="w"> </span>    def _transform(self, data: DataFrame, orient: str, grouping_vars: list[str]
<span class="w"> </span>        ) -&gt;DataFrame:
<span class="w"> </span>        &quot;&quot;&quot;Transform multiple groups by fitting KDEs and evaluating.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        support = self._get_support(data, orient)</span>
<span class="gi">+        </span>
<span class="gi">+        if not grouping_vars:</span>
<span class="gi">+            return self._fit_and_evaluate(data, orient, support)</span>
<span class="gi">+        </span>
<span class="gi">+        groups = data.groupby(grouping_vars)</span>
<span class="gi">+        results = []</span>
<span class="gi">+        </span>
<span class="gi">+        for _, group_data in groups:</span>
<span class="gi">+            group_result = self._fit_and_evaluate(group_data, orient, support)</span>
<span class="gi">+            for var, val in zip(grouping_vars, group_data[grouping_vars].iloc[0]):</span>
<span class="gi">+                group_result[var] = val</span>
<span class="gi">+            results.append(group_result)</span>
<span class="gi">+        </span>
<span class="gi">+        return pd.concat(results, ignore_index=True)</span>

<span class="w"> </span>    def __call__(self, data: DataFrame, groupby: GroupBy, orient: str,
<span class="w"> </span>        scales: dict[str, Scale]) -&gt;DataFrame:
<span class="gh">diff --git a/seaborn/algorithms.py b/seaborn/algorithms.py</span>
<span class="gh">index 2939e8bd..0ecef9ae 100644</span>
<span class="gd">--- a/seaborn/algorithms.py</span>
<span class="gi">+++ b/seaborn/algorithms.py</span>
<span class="gu">@@ -32,9 +32,51 @@ def bootstrap(*args, **kwargs):</span>
<span class="w"> </span>        array of bootstrapped statistic values

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n_boot = kwargs.get(&#39;n_boot&#39;, 10000)</span>
<span class="gi">+    axis = kwargs.get(&#39;axis&#39;, None)</span>
<span class="gi">+    units = kwargs.get(&#39;units&#39;, None)</span>
<span class="gi">+    func = kwargs.get(&#39;func&#39;, &#39;mean&#39;)</span>
<span class="gi">+    seed = kwargs.get(&#39;seed&#39;, None)</span>

<span class="gi">+    if isinstance(func, str):</span>
<span class="gi">+        if func.startswith(&#39;nan&#39;):</span>
<span class="gi">+            func = getattr(np, func)</span>
<span class="gi">+        else:</span>
<span class="gi">+            func = getattr(np, func)</span>
<span class="gi">+            if np.any([np.isnan(arg).any() for arg in args]):</span>
<span class="gi">+                func = getattr(np, f&#39;nan{func}&#39;)</span>

<span class="gd">-def _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):</span>
<span class="gi">+    if axis is not None:</span>
<span class="gi">+        kwargs[&#39;axis&#39;] = axis</span>
<span class="gi">+</span>
<span class="gi">+    if units is not None:</span>
<span class="gi">+        return _structured_bootstrap(args, n_boot, units, func, kwargs, seed)</span>
<span class="gi">+</span>
<span class="gi">+    rng = np.random.default_rng(seed)</span>
<span class="gi">+    boot_dist = []</span>
<span class="gi">+    for _ in range(n_boot):</span>
<span class="gi">+        resampled = [rng.choice(arg, size=len(arg), replace=True) for arg in args]</span>
<span class="gi">+        boot_dist.append(func(*resampled, **kwargs))</span>
<span class="gi">+</span>
<span class="gi">+    return np.array(boot_dist)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _structured_bootstrap(args, n_boot, units, func, func_kwargs, seed):</span>
<span class="w"> </span>    &quot;&quot;&quot;Resample units instead of datapoints.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    unique_units = np.unique(units)</span>
<span class="gi">+    n_units = len(unique_units)</span>
<span class="gi">+</span>
<span class="gi">+    rng = np.random.default_rng(seed)</span>
<span class="gi">+    boot_dist = []</span>
<span class="gi">+</span>
<span class="gi">+    for _ in range(n_boot):</span>
<span class="gi">+        resampled_units = rng.choice(unique_units, size=n_units, replace=True)</span>
<span class="gi">+        resampled_data = []</span>
<span class="gi">+</span>
<span class="gi">+        for arg in args:</span>
<span class="gi">+            resampled = np.concatenate([arg[units == unit] for unit in resampled_units])</span>
<span class="gi">+            resampled_data.append(resampled)</span>
<span class="gi">+</span>
<span class="gi">+        boot_dist.append(func(*resampled_data, **func_kwargs))</span>
<span class="gi">+</span>
<span class="gi">+    return np.array(boot_dist)</span>
<span class="gh">diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py</span>
<span class="gh">index 54c0052d..cfc82ce7 100644</span>
<span class="gd">--- a/seaborn/axisgrid.py</span>
<span class="gi">+++ b/seaborn/axisgrid.py</span>
<span class="gu">@@ -24,17 +24,21 @@ class _BaseGrid:</span>

<span class="w"> </span>    def set(self, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Set attributes on each subplot Axes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for ax in self.axes.flat:</span>
<span class="gi">+            ax.set(**kwargs)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def fig(self):
<span class="w"> </span>        &quot;&quot;&quot;DEPRECATED: prefer the `figure` property.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        import warnings</span>
<span class="gi">+        warnings.warn(&quot;The `fig` property is deprecated. Use `figure` instead.&quot;, DeprecationWarning)</span>
<span class="gi">+        return self.figure</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def figure(self):
<span class="w"> </span>        &quot;&quot;&quot;Access the :class:`matplotlib.figure.Figure` object underlying the grid.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._figure</span>

<span class="w"> </span>    def apply(self, func, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -48,7 +52,8 @@ class _BaseGrid:</span>
<span class="w"> </span>        Added in v0.12.0.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        func(self, *args, **kwargs)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def pipe(self, func, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -62,7 +67,7 @@ class _BaseGrid:</span>
<span class="w"> </span>        Added in v0.12.0.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return func(self, *args, **kwargs)</span>

<span class="w"> </span>    def savefig(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -72,7 +77,8 @@ class _BaseGrid:</span>
<span class="w"> </span>        by default. Parameters are passed through to the matplotlib function.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs.setdefault(&quot;bbox_inches&quot;, &quot;tight&quot;)</span>
<span class="gi">+        self.figure.savefig(*args, **kwargs)</span>


<span class="w"> </span>class Grid(_BaseGrid):
<span class="gu">@@ -87,7 +93,10 @@ class Grid(_BaseGrid):</span>

<span class="w"> </span>    def tight_layout(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Call fig.tight_layout within rect that exclude the legend.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs.setdefault(&quot;rect&quot;, self._tight_layout_rect)</span>
<span class="gi">+        kwargs.setdefault(&quot;pad&quot;, self._tight_layout_pad)</span>
<span class="gi">+        self.figure.tight_layout(*args, **kwargs)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def add_legend(self, legend_data=None, title=None, label_order=None,
<span class="w"> </span>        adjust_subtitles=False, **kwargs):
<span class="gu">@@ -117,20 +126,51 @@ class Grid(_BaseGrid):</span>
<span class="w"> </span>            Returns self for easy chaining.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Use default legend data if not provided</span>
<span class="gi">+        if legend_data is None:</span>
<span class="gi">+            legend_data = self._legend_data</span>
<span class="gi">+</span>
<span class="gi">+        # Use default title if not provided</span>
<span class="gi">+        if title is None:</span>
<span class="gi">+            title = self._hue_var</span>
<span class="gi">+</span>
<span class="gi">+        # Use default label order if not provided</span>
<span class="gi">+        if label_order is None:</span>
<span class="gi">+            label_order = self.hue_names</span>
<span class="gi">+</span>
<span class="gi">+        # Create the legend</span>
<span class="gi">+        legend = self.figure.legend(</span>
<span class="gi">+            handles=[legend_data[label] for label in label_order],</span>
<span class="gi">+            labels=label_order,</span>
<span class="gi">+            title=title,</span>
<span class="gi">+            **kwargs</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if adjust_subtitles:</span>
<span class="gi">+            adjust_legend_subtitles(legend)</span>
<span class="gi">+</span>
<span class="gi">+        self._legend = legend</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def _update_legend_data(self, ax):
<span class="w"> </span>        &quot;&quot;&quot;Extract the legend data from an axes object and save it.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        handles, labels = ax.get_legend_handles_labels()</span>
<span class="gi">+        self._legend_data.update(dict(zip(labels, handles)))</span>

<span class="w"> </span>    def _get_palette(self, data, hue, hue_order, palette):
<span class="w"> </span>        &quot;&quot;&quot;Get a list of colors for the hue variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if palette is None:</span>
<span class="gi">+            if hue is None:</span>
<span class="gi">+                palette = color_palette()</span>
<span class="gi">+            else:</span>
<span class="gi">+                n_colors = len(data[hue].unique())</span>
<span class="gi">+                palette = color_palette(n_colors=n_colors)</span>
<span class="gi">+        return palette</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def legend(self):
<span class="w"> </span>        &quot;&quot;&quot;The :class:`matplotlib.legend.Legend` object, if present.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._legend</span>

<span class="w"> </span>    def tick_params(self, axis=&#39;both&#39;, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Modify the ticks, tick labels, and gridlines.
<span class="gu">@@ -149,7 +189,9 @@ class Grid(_BaseGrid):</span>
<span class="w"> </span>            Returns self for easy chaining.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for ax in self.axes.flat:</span>
<span class="gi">+            ax.tick_params(axis=axis, **kwargs)</span>
<span class="gi">+        return self</span>


<span class="w"> </span>_facet_docs = dict(data=dedent(
<span class="gh">diff --git a/seaborn/categorical.py b/seaborn/categorical.py</span>
<span class="gh">index b0ff7288..9a7f5b2d 100644</span>
<span class="gd">--- a/seaborn/categorical.py</span>
<span class="gi">+++ b/seaborn/categorical.py</span>
<span class="gu">@@ -1033,23 +1033,58 @@ class Beeswarm:</span>

<span class="w"> </span>    def beeswarm(self, orig_xyr):
<span class="w"> </span>        &quot;&quot;&quot;Adjust x position of points to avoid overlaps.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        swarm = []</span>
<span class="gi">+        for xyr_i in orig_xyr:</span>
<span class="gi">+            candidates = self.position_candidates(xyr_i, self.could_overlap(xyr_i, swarm))</span>
<span class="gi">+            new_xyr_i = self.first_non_overlapping_candidate(candidates, swarm)</span>
<span class="gi">+            swarm.append(new_xyr_i)</span>
<span class="gi">+        return np.array(swarm)</span>

<span class="w"> </span>    def could_overlap(self, xyr_i, swarm):
<span class="w"> </span>        &quot;&quot;&quot;Return a list of all swarm points that could overlap with target.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x, y, r = xyr_i</span>
<span class="gi">+        neighbors = []</span>
<span class="gi">+        r_search = r * 2</span>
<span class="gi">+        for xyr_j in swarm:</span>
<span class="gi">+            if abs(xyr_j[1] - y) &lt;= r_search:</span>
<span class="gi">+                neighbors.append(xyr_j)</span>
<span class="gi">+        return neighbors</span>

<span class="w"> </span>    def position_candidates(self, xyr_i, neighbors):
<span class="w"> </span>        &quot;&quot;&quot;Return a list of coordinates that might be valid by adjusting x.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x, y, r = xyr_i</span>
<span class="gi">+        candidates = [xyr_i]</span>
<span class="gi">+        if neighbors:</span>
<span class="gi">+            for side in [-1, 1]:</span>
<span class="gi">+                for neighbor in neighbors:</span>
<span class="gi">+                    new_x = neighbor[0] + (r + neighbor[2]) * side</span>
<span class="gi">+                    new_xyr = (new_x, y, r)</span>
<span class="gi">+                    candidates.append(new_xyr)</span>
<span class="gi">+        return candidates</span>

<span class="w"> </span>    def first_non_overlapping_candidate(self, candidates, neighbors):
<span class="w"> </span>        &quot;&quot;&quot;Find the first candidate that does not overlap with the swarm.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for xyr_i in candidates:</span>
<span class="gi">+            if not any(self.overlap(xyr_i, xyr_j) for xyr_j in neighbors):</span>
<span class="gi">+                return xyr_i</span>
<span class="gi">+        return candidates[0]  # If all overlap, return original position</span>
<span class="gi">+</span>
<span class="gi">+    def overlap(self, xyr_i, xyr_j):</span>
<span class="gi">+        &quot;&quot;&quot;Check if two points overlap.&quot;&quot;&quot;</span>
<span class="gi">+        xi, yi, ri = xyr_i</span>
<span class="gi">+        xj, yj, rj = xyr_j</span>
<span class="gi">+        return (xi - xj) ** 2 + (yi - yj) ** 2 &lt; (ri + rj) ** 2</span>

<span class="w"> </span>    def add_gutters(self, points, center, trans_fwd, trans_inv):
<span class="w"> </span>        &quot;&quot;&quot;Stop points from extending beyond their territory.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        half_width = self.width / 2</span>
<span class="gi">+        low_gutter = trans_inv(trans_fwd(center) - half_width)</span>
<span class="gi">+        high_gutter = trans_inv(trans_fwd(center) + half_width)</span>
<span class="gi">+        </span>
<span class="gi">+        if self.orient == &quot;y&quot;:</span>
<span class="gi">+            low_gutter, high_gutter = high_gutter, low_gutter</span>
<span class="gi">+        </span>
<span class="gi">+        np.clip(points, low_gutter, high_gutter, out=points)</span>


<span class="w"> </span>BoxPlotArtists = namedtuple(&#39;BoxPlotArtists&#39;,
<span class="gu">@@ -1074,11 +1109,15 @@ class BoxPlotContainer:</span>

<span class="w"> </span>    def __getitem__(self, idx):
<span class="w"> </span>        pair_slice = slice(2 * idx, 2 * idx + 2)
<span class="gd">-        return BoxPlotArtists(self.boxes[idx] if self.boxes else [], self.</span>
<span class="gd">-            medians[idx] if self.medians else [], self.whiskers[pair_slice] if</span>
<span class="gd">-            self.whiskers else [], self.caps[pair_slice] if self.caps else</span>
<span class="gd">-            [], self.fliers[idx] if self.fliers else [], self.means[idx] if</span>
<span class="gd">-            self.means else [])</span>
<span class="gi">+        return BoxPlotArtists(</span>
<span class="gi">+            box=self.boxes[idx] if self.boxes else [],</span>
<span class="gi">+            median=self.medians[idx] if self.medians else [],</span>
<span class="gi">+            whiskers=self.whiskers[pair_slice] if self.whiskers else [],</span>
<span class="gi">+            caps=self.caps[pair_slice] if self.caps else [],</span>
<span class="gi">+            fliers=self.fliers[idx] if self.fliers else [],</span>
<span class="gi">+            mean=self.means[idx] if self.means else []</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __iter__(self):
<span class="gd">-        yield from (self[i] for i in range(len(self.boxes)))</span>
<span class="gi">+        for i in range(len(self.boxes)):</span>
<span class="gi">+            yield self[i]</span>
<span class="gh">diff --git a/seaborn/distributions.py b/seaborn/distributions.py</span>
<span class="gh">index 36572494..279ecac0 100644</span>
<span class="gd">--- a/seaborn/distributions.py</span>
<span class="gi">+++ b/seaborn/distributions.py</span>
<span class="gu">@@ -73,46 +73,115 @@ class _DistributionPlotter(VectorPlotter):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def univariate(self):
<span class="w"> </span>        &quot;&quot;&quot;Return True if only x or y are used.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bool(self.variables.get(&quot;x&quot;)) != bool(self.variables.get(&quot;y&quot;))</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def data_variable(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the variable with data for univariate plots.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &quot;x&quot; if self.variables.get(&quot;x&quot;) else &quot;y&quot;</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def has_xy_data(self):
<span class="w"> </span>        &quot;&quot;&quot;Return True at least one of x or y is defined.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bool(self.variables.get(&quot;x&quot;)) or bool(self.variables.get(&quot;y&quot;))</span>

<span class="w"> </span>    def _add_legend(self, ax_obj, artist, fill, element, multiple, alpha,
<span class="w"> </span>        artist_kws, legend_kws):
<span class="w"> </span>        &quot;&quot;&quot;Add artists that reflect semantic mappings and put then in a legend.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        handles = []</span>
<span class="gi">+        labels = []</span>
<span class="gi">+        for level in self.var_levels:</span>
<span class="gi">+            if fill:</span>
<span class="gi">+                handle = plt.Rectangle((0, 0), 0, 0, **artist_kws)</span>
<span class="gi">+            else:</span>
<span class="gi">+                handle = plt.Line2D([], [], **artist_kws)</span>
<span class="gi">+            handles.append(handle)</span>
<span class="gi">+            labels.append(level)</span>
<span class="gi">+        </span>
<span class="gi">+        legend = ax_obj.legend(handles, labels, **legend_kws)</span>
<span class="gi">+        return legend</span>

<span class="w"> </span>    def _artist_kws(self, kws, fill, element, multiple, color, alpha):
<span class="w"> </span>        &quot;&quot;&quot;Handle differences between artists in filled/unfilled plots.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fill:</span>
<span class="gi">+            kws.setdefault(&quot;facecolor&quot;, color)</span>
<span class="gi">+            kws.setdefault(&quot;edgecolor&quot;, &quot;none&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+        </span>
<span class="gi">+        if element == &quot;bars&quot;:</span>
<span class="gi">+            kws.setdefault(&quot;edgecolor&quot;, &quot;none&quot;)</span>
<span class="gi">+        elif element in [&quot;step&quot;, &quot;poly&quot;]:</span>
<span class="gi">+            kws.setdefault(&quot;linewidth&quot;, 2)</span>
<span class="gi">+        </span>
<span class="gi">+        if multiple in [&quot;stack&quot;, &quot;fill&quot;]:</span>
<span class="gi">+            kws[&quot;alpha&quot;] = 1 if alpha is None else alpha</span>
<span class="gi">+        else:</span>
<span class="gi">+            kws.setdefault(&quot;alpha&quot;, 0.5 if alpha is None else alpha)</span>
<span class="gi">+        </span>
<span class="gi">+        return kws</span>

<span class="w"> </span>    def _quantile_to_level(self, data, quantile):
<span class="w"> </span>        &quot;&quot;&quot;Return data levels corresponding to quantile cuts of mass.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        isoprop = np.asarray(quantile)</span>
<span class="gi">+        values = np.ravel(data)</span>
<span class="gi">+        sorted_values = np.sort(values)[::-1]</span>
<span class="gi">+        normalized_values = np.cumsum(sorted_values) / values.sum()</span>
<span class="gi">+        idx = np.searchsorted(normalized_values, 1 - isoprop)</span>
<span class="gi">+        levels = np.take(sorted_values, idx, mode=&quot;clip&quot;)</span>
<span class="gi">+        return levels</span>

<span class="w"> </span>    def _cmap_from_color(self, color):
<span class="w"> </span>        &quot;&quot;&quot;Return a sequential colormap given a color seed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rgb = mpl.colors.to_rgb(color)</span>
<span class="gi">+        light_rgb = [1 - (1 - c) * .25 for c in rgb]</span>
<span class="gi">+        colors = [light_rgb, rgb]</span>
<span class="gi">+        return mpl.colors.LinearSegmentedColormap.from_list(&quot;blend&quot;, colors)</span>

<span class="w"> </span>    def _default_discrete(self):
<span class="w"> </span>        &quot;&quot;&quot;Find default values for discrete hist estimation based on variable type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.univariate:</span>
<span class="gi">+            data = self.plot_data[self.data_variable]</span>
<span class="gi">+        else:</span>
<span class="gi">+            data = self.plot_data[[&quot;x&quot;, &quot;y&quot;]]</span>
<span class="gi">+        </span>
<span class="gi">+        if pd.api.types.is_integer_dtype(data):</span>
<span class="gi">+            discrete = True</span>
<span class="gi">+            binwidth = 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            discrete = False</span>
<span class="gi">+            binwidth = None</span>
<span class="gi">+        </span>
<span class="gi">+        return discrete, binwidth</span>

<span class="w"> </span>    def _resolve_multiple(self, curves, multiple):
<span class="w"> </span>        &quot;&quot;&quot;Modify the density data structure to handle multiple densities.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if multiple == &quot;layer&quot;:</span>
<span class="gi">+            return curves</span>
<span class="gi">+        elif multiple == &quot;stack&quot;:</span>
<span class="gi">+            return np.cumsum(curves, axis=0)</span>
<span class="gi">+        elif multiple == &quot;fill&quot;:</span>
<span class="gi">+            cumulative = np.cumsum(curves, axis=0)</span>
<span class="gi">+            return cumulative / cumulative.max(axis=0)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;multiple must be &#39;layer&#39;, &#39;stack&#39;, or &#39;fill&#39;, not {multiple}&quot;)</span>

<span class="w"> </span>    def _plot_single_rug(self, sub_data, var, height, ax, kws):
<span class="w"> </span>        &quot;&quot;&quot;Draw a rugplot along one axis of the plot.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kws = kws.copy()</span>
<span class="gi">+        if var == &quot;x&quot;:</span>
<span class="gi">+            trans = tx.blended_transform_factory(ax.transData, ax.transAxes)</span>
<span class="gi">+            xy = np.column_stack([sub_data, np.zeros_like(sub_data)])</span>
<span class="gi">+            kws[&quot;height&quot;] = height</span>
<span class="gi">+        else:</span>
<span class="gi">+            trans = tx.blended_transform_factory(ax.transAxes, ax.transData)</span>
<span class="gi">+            xy = np.column_stack([np.zeros_like(sub_data), sub_data])</span>
<span class="gi">+            kws[&quot;width&quot;] = height</span>
<span class="gi">+        </span>
<span class="gi">+        ax.tick_params(direction=&quot;in&quot;)</span>
<span class="gi">+        kws.setdefault(&quot;linewidth&quot;, 1)</span>
<span class="gi">+        lines = LineCollection(np.expand_dims(xy, 1), transform=trans, **kws)</span>
<span class="gi">+        ax.add_collection(lines)</span>


<span class="w"> </span>histplot.__doc__ = (
<span class="gu">@@ -537,7 +606,14 @@ about the breadth of options available for each plot kind.</span>

<span class="w"> </span>def _freedman_diaconis_bins(a):
<span class="w"> </span>    &quot;&quot;&quot;Calculate number of hist bins using Freedman-Diaconis rule.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    a = np.asarray(a)</span>
<span class="gi">+    if len(a) &lt; 2:</span>
<span class="gi">+        return 1</span>
<span class="gi">+    h = 2 * (np.percentile(a, 75) - np.percentile(a, 25))</span>
<span class="gi">+    if h == 0:</span>
<span class="gi">+        return int(np.sqrt(a.size))</span>
<span class="gi">+    else:</span>
<span class="gi">+        return int(np.ceil((a.max() - a.min()) / h))</span>


<span class="w"> </span>def distplot(a=None, bins=None, hist=True, kde=True, rug=False, fit=None,
<span class="gu">@@ -556,4 +632,101 @@ def distplot(a=None, bins=None, hist=True, kde=True, rug=False, fit=None,</span>
<span class="w"> </span>    https://gist.github.com/mwaskom/de44147ed2974457ad6372750bbe5751

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import warnings</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &quot;distplot is a deprecated function and will be removed in seaborn v0.14.0. &quot;</span>
<span class="gi">+        &quot;Please adapt your code to use either displot (a figure-level function with &quot;</span>
<span class="gi">+        &quot;similar flexibility) or histplot (an axes-level function for histograms).&quot;,</span>
<span class="gi">+        FutureWarning</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if x is not None:</span>
<span class="gi">+        a = x</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;The `x` parameter has been renamed to `a`. &quot;</span>
<span class="gi">+            &quot;Please update your code as the `x` parameter will be removed in v0.14.0.&quot;,</span>
<span class="gi">+            FutureWarning</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    # Intelligently label the support axis</span>
<span class="gi">+    label_ax = axlabel or (label if label is not None else None)</span>
<span class="gi">+</span>
<span class="gi">+    # Make a a 1-d array</span>
<span class="gi">+    a = np.asarray(a).squeeze()</span>
<span class="gi">+</span>
<span class="gi">+    # Decide if the hist is normed</span>
<span class="gi">+    norm_hist = norm_hist or kde</span>
<span class="gi">+</span>
<span class="gi">+    # Handle dictionary defaults</span>
<span class="gi">+    hist_kws = {} if hist_kws is None else hist_kws.copy()</span>
<span class="gi">+    kde_kws = {} if kde_kws is None else kde_kws.copy()</span>
<span class="gi">+    rug_kws = {} if rug_kws is None else rug_kws.copy()</span>
<span class="gi">+    fit_kws = {} if fit_kws is None else fit_kws.copy()</span>
<span class="gi">+</span>
<span class="gi">+    # Get the color from the current color cycle</span>
<span class="gi">+    if color is None:</span>
<span class="gi">+        color = next(ax._get_lines.prop_cycler)[&#39;color&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # Plug the label into the right kwarg dictionary</span>
<span class="gi">+    if label is not None:</span>
<span class="gi">+        if hist:</span>
<span class="gi">+            hist_kws[&#39;label&#39;] = label</span>
<span class="gi">+        elif kde:</span>
<span class="gi">+            kde_kws[&#39;label&#39;] = label</span>
<span class="gi">+        elif rug:</span>
<span class="gi">+            rug_kws[&#39;label&#39;] = label</span>
<span class="gi">+        elif fit:</span>
<span class="gi">+            fit_kws[&#39;label&#39;] = label</span>
<span class="gi">+</span>
<span class="gi">+    if hist:</span>
<span class="gi">+        if bins is None:</span>
<span class="gi">+            bins = min(_freedman_diaconis_bins(a), 50)</span>
<span class="gi">+        hist_kws.setdefault(&#39;alpha&#39;, 0.4)</span>
<span class="gi">+        hist_kws.setdefault(&#39;density&#39;, norm_hist)</span>
<span class="gi">+</span>
<span class="gi">+        orientation = &#39;horizontal&#39; if vertical else &#39;vertical&#39;</span>
<span class="gi">+        hist_color = hist_kws.pop(&#39;color&#39;, color)</span>
<span class="gi">+        ax.hist(a, bins=bins, orientation=orientation,</span>
<span class="gi">+                color=hist_color, **hist_kws)</span>
<span class="gi">+</span>
<span class="gi">+        if hist_color != color:</span>
<span class="gi">+            hist_kws[&#39;color&#39;] = hist_color</span>
<span class="gi">+</span>
<span class="gi">+    if kde:</span>
<span class="gi">+        kde_color = kde_kws.pop(&#39;color&#39;, color)</span>
<span class="gi">+        kdeplot(a, vertical=vertical, ax=ax, color=kde_color, **kde_kws)</span>
<span class="gi">+        if kde_color != color:</span>
<span class="gi">+            kde_kws[&#39;color&#39;] = kde_color</span>
<span class="gi">+</span>
<span class="gi">+    if rug:</span>
<span class="gi">+        rug_color = rug_kws.pop(&#39;color&#39;, color)</span>
<span class="gi">+        axis = &#39;y&#39; if vertical else &#39;x&#39;</span>
<span class="gi">+        rugplot(a, axis=axis, ax=ax, color=rug_color, **rug_kws)</span>
<span class="gi">+        if rug_color != color:</span>
<span class="gi">+            rug_kws[&#39;color&#39;] = rug_color</span>
<span class="gi">+</span>
<span class="gi">+    if fit is not None:</span>
<span class="gi">+        fit_color = fit_kws.pop(&#39;color&#39;, &#39;#282828&#39;)</span>
<span class="gi">+        gridsize = fit_kws.pop(&#39;gridsize&#39;, 200)</span>
<span class="gi">+        cut = fit_kws.pop(&#39;cut&#39;, 3)</span>
<span class="gi">+        clip = fit_kws.pop(&#39;clip&#39;, (-np.inf, np.inf))</span>
<span class="gi">+        bw = gaussian_kde(a).scotts_factor() * a.std(ddof=1)</span>
<span class="gi">+        x = _kde_support(a, bw, gridsize, cut, clip)</span>
<span class="gi">+        params = fit(*x.T).params</span>
<span class="gi">+        y = fit.pdf(x, *params)</span>
<span class="gi">+        if vertical:</span>
<span class="gi">+            x, y = y, x</span>
<span class="gi">+        ax.plot(x, y, color=fit_color, **fit_kws)</span>
<span class="gi">+        if fit_color != &#39;#282828&#39;:</span>
<span class="gi">+            fit_kws[&#39;color&#39;] = fit_color</span>
<span class="gi">+</span>
<span class="gi">+    if label_ax is not None:</span>
<span class="gi">+        if vertical:</span>
<span class="gi">+            ax.set_ylabel(label_ax)</span>
<span class="gi">+        else:</span>
<span class="gi">+            ax.set_xlabel(label_ax)</span>
<span class="gi">+</span>
<span class="gi">+    return ax</span>
<span class="gh">diff --git a/seaborn/external/appdirs.py b/seaborn/external/appdirs.py</span>
<span class="gh">index dc520cd6..b7fba415 100644</span>
<span class="gd">--- a/seaborn/external/appdirs.py</span>
<span class="gi">+++ b/seaborn/external/appdirs.py</span>
<span class="gu">@@ -83,7 +83,28 @@ def user_cache_dir(appname=None, appauthor=None, version=None, opinion=True):</span>
<span class="w"> </span>    OPINION: This function appends &quot;Cache&quot; to the `CSIDL_LOCAL_APPDATA` value.
<span class="w"> </span>    This can be disabled with the `opinion=False` option.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if system == &quot;win32&quot;:</span>
<span class="gi">+        if appauthor is None:</span>
<span class="gi">+            appauthor = appname</span>
<span class="gi">+        path = os.path.normpath(_get_win_folder(&quot;CSIDL_LOCAL_APPDATA&quot;))</span>
<span class="gi">+        if appname:</span>
<span class="gi">+            if appauthor is not False:</span>
<span class="gi">+                path = os.path.join(path, appauthor, appname)</span>
<span class="gi">+            else:</span>
<span class="gi">+                path = os.path.join(path, appname)</span>
<span class="gi">+            if opinion:</span>
<span class="gi">+                path = os.path.join(path, &quot;Cache&quot;)</span>
<span class="gi">+    elif system == &#39;darwin&#39;:</span>
<span class="gi">+        path = os.path.expanduser(&#39;~/Library/Caches&#39;)</span>
<span class="gi">+        if appname:</span>
<span class="gi">+            path = os.path.join(path, appname)</span>
<span class="gi">+    else:</span>
<span class="gi">+        path = os.getenv(&#39;XDG_CACHE_HOME&#39;, os.path.expanduser(&#39;~/.cache&#39;))</span>
<span class="gi">+        if appname:</span>
<span class="gi">+            path = os.path.join(path, appname)</span>
<span class="gi">+    if appname and version:</span>
<span class="gi">+        path = os.path.join(path, version)</span>
<span class="gi">+    return path</span>


<span class="w"> </span>def _get_win_folder_from_registry(csidl_name):
<span class="gu">@@ -91,7 +112,20 @@ def _get_win_folder_from_registry(csidl_name):</span>
<span class="w"> </span>    registry for this guarantees us the correct answer for all CSIDL_*
<span class="w"> </span>    names.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import winreg as _winreg</span>
<span class="gi">+</span>
<span class="gi">+    shell_folder_name = {</span>
<span class="gi">+        &quot;CSIDL_APPDATA&quot;: &quot;AppData&quot;,</span>
<span class="gi">+        &quot;CSIDL_COMMON_APPDATA&quot;: &quot;Common AppData&quot;,</span>
<span class="gi">+        &quot;CSIDL_LOCAL_APPDATA&quot;: &quot;Local AppData&quot;,</span>
<span class="gi">+    }[csidl_name]</span>
<span class="gi">+</span>
<span class="gi">+    key = _winreg.OpenKey(</span>
<span class="gi">+        _winreg.HKEY_CURRENT_USER,</span>
<span class="gi">+        r&quot;Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    dir, type = _winreg.QueryValueEx(key, shell_folder_name)</span>
<span class="gi">+    return dir</span>


<span class="w"> </span>if system == &#39;win32&#39;:
<span class="gh">diff --git a/seaborn/external/docscrape.py b/seaborn/external/docscrape.py</span>
<span class="gh">index c3814e10..17f2ec82 100644</span>
<span class="gd">--- a/seaborn/external/docscrape.py</span>
<span class="gi">+++ b/seaborn/external/docscrape.py</span>
<span class="gu">@@ -39,7 +39,13 @@ import sys</span>

<span class="w"> </span>def strip_blank_lines(l):
<span class="w"> </span>    &quot;&quot;&quot;Remove leading and trailing blank lines from a list of lines&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Strip leading blank lines</span>
<span class="gi">+    while l and not l[0].strip():</span>
<span class="gi">+        l.pop(0)</span>
<span class="gi">+    # Strip trailing blank lines</span>
<span class="gi">+    while l and not l[-1].strip():</span>
<span class="gi">+        l.pop()</span>
<span class="gi">+    return l</span>


<span class="w"> </span>class Reader:
<span class="gu">@@ -136,7 +142,31 @@ class NumpyDocString(Mapping):</span>
<span class="w"> </span>        func_name1, func_name2, :meth:`func_name`, func_name3

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = []</span>
<span class="gi">+        current_func = None</span>
<span class="gi">+        current_desc = []</span>
<span class="gi">+</span>
<span class="gi">+        for line in content:</span>
<span class="gi">+            line = line.strip()</span>
<span class="gi">+            if not line:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            match = self._line_rgx.match(line)</span>
<span class="gi">+            if match:</span>
<span class="gi">+                if current_func:</span>
<span class="gi">+                    result.append((current_func, &#39; &#39;.join(current_desc)))</span>
<span class="gi">+                current_func = match.group(&#39;allfuncs&#39;)</span>
<span class="gi">+                current_desc = [match.group(&#39;desc&#39;) or &#39;&#39;]</span>
<span class="gi">+            else:</span>
<span class="gi">+                if current_desc:</span>
<span class="gi">+                    current_desc.append(line)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    result.append((line, &#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        if current_func:</span>
<span class="gi">+            result.append((current_func, &#39; &#39;.join(current_desc)))</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def _parse_index(self, section, content):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -144,11 +174,38 @@ class NumpyDocString(Mapping):</span>
<span class="w"> </span>           :refguide: something, else, and more

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = {}</span>
<span class="gi">+        for line in content:</span>
<span class="gi">+            line = line.strip()</span>
<span class="gi">+            if line.startswith(&#39;:&#39;):</span>
<span class="gi">+                key, value = line[1:].split(&#39;:&#39;, 1)</span>
<span class="gi">+                key = key.strip()</span>
<span class="gi">+                value = value.strip()</span>
<span class="gi">+                result[key] = value.split(&#39;, &#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                result[&#39;default&#39;] = line.strip()</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def _parse_summary(self):
<span class="w"> </span>        &quot;&quot;&quot;Grab signature (if given) and summary&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._is_at_section():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # If several signatures present, take the last one</span>
<span class="gi">+        while True:</span>
<span class="gi">+            summary = self._doc.read_to_next_empty_line()</span>
<span class="gi">+            summary_str = &quot; &quot;.join([s.strip() for s in summary]).strip()</span>
<span class="gi">+            if re.compile(&#39;^([\w., ]+=)?\s*[\w\.]+\(.*\)$&#39;).search(summary_str):</span>
<span class="gi">+                self[&#39;Signature&#39;] = summary_str</span>
<span class="gi">+                if not self._is_at_section():</span>
<span class="gi">+                    continue</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+        if summary is not None:</span>
<span class="gi">+            self[&#39;Summary&#39;] = summary</span>
<span class="gi">+</span>
<span class="gi">+        if not self._is_at_section():</span>
<span class="gi">+            self[&#39;Extended Summary&#39;] = self._read_to_next_section()</span>

<span class="w"> </span>    def __str__(self, func_role=&#39;&#39;):
<span class="w"> </span>        out = []
<span class="gu">@@ -170,7 +227,14 @@ class NumpyDocString(Mapping):</span>

<span class="w"> </span>def dedent_lines(lines):
<span class="w"> </span>    &quot;&quot;&quot;Deindent a list of lines maximally&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not lines:</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    # Find minimum indentation</span>
<span class="gi">+    min_indent = min(len(line) - len(line.lstrip()) for line in lines if line.strip())</span>
<span class="gi">+</span>
<span class="gi">+    # Dedent lines</span>
<span class="gi">+    return [line[min_indent:] if line.strip() else line for line in lines]</span>


<span class="w"> </span>class FunctionDoc(NumpyDocString):
<span class="gh">diff --git a/seaborn/external/kde.py b/seaborn/external/kde.py</span>
<span class="gh">index 4765f446..97dde721 100644</span>
<span class="gd">--- a/seaborn/external/kde.py</span>
<span class="gi">+++ b/seaborn/external/kde.py</span>
<span class="gu">@@ -204,7 +204,37 @@ class gaussian_kde:</span>
<span class="w"> </span>                     the dimensionality of the KDE.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        points = atleast_2d(asarray(points))</span>
<span class="gi">+</span>
<span class="gi">+        d, m = points.shape</span>
<span class="gi">+        if d != self.d:</span>
<span class="gi">+            if d == 1 and m == self.d:</span>
<span class="gi">+                # points was passed in as a row vector</span>
<span class="gi">+                points = reshape(points, (self.d, 1))</span>
<span class="gi">+                m = 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(&quot;points have dimension %s, dataset has dimension %s&quot; % (d, self.d))</span>
<span class="gi">+</span>
<span class="gi">+        result = zeros((m,), dtype=float)</span>
<span class="gi">+</span>
<span class="gi">+        if m &gt;= self.n:</span>
<span class="gi">+            # there are more points than data, so loop over data</span>
<span class="gi">+            for i in range(self.n):</span>
<span class="gi">+                diff = self.dataset[:, i, newaxis] - points</span>
<span class="gi">+                tdiff = dot(self.inv_cov, diff)</span>
<span class="gi">+                energy = sum(diff * tdiff, axis=0) / 2.0</span>
<span class="gi">+                result = result + self.weights[i] * exp(-energy)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # loop over points</span>
<span class="gi">+            for i in range(m):</span>
<span class="gi">+                diff = self.dataset - points[:, i, newaxis]</span>
<span class="gi">+                tdiff = dot(self.inv_cov, diff)</span>
<span class="gi">+                energy = sum(diff * tdiff, axis=0) / 2.0</span>
<span class="gi">+                result[i] = sum(self.weights * exp(-energy))</span>
<span class="gi">+</span>
<span class="gi">+        result = result / self._norm_factor</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="w"> </span>    __call__ = evaluate

<span class="w"> </span>    def scotts_factor(self):
<span class="gu">@@ -215,7 +245,7 @@ class gaussian_kde:</span>
<span class="w"> </span>        s : float
<span class="w"> </span>            Scott&#39;s factor.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return power(self.neff, -1./(self.d+4))</span>

<span class="w"> </span>    def silverman_factor(self):
<span class="w"> </span>        &quot;&quot;&quot;Compute the Silverman factor.
<span class="gu">@@ -225,7 +255,7 @@ class gaussian_kde:</span>
<span class="w"> </span>        s : float
<span class="w"> </span>            The silverman factor.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return power(self.neff * (self.d + 2.0) / 4.0, -1. / (self.d + 4))</span>
<span class="w"> </span>    covariance_factor = scotts_factor
<span class="w"> </span>    covariance_factor.__doc__ = &quot;&quot;&quot;Computes the coefficient (`kde.factor`) that
<span class="w"> </span>        multiplies the data covariance matrix to obtain the kernel covariance
<span class="gu">@@ -254,13 +284,40 @@ class gaussian_kde:</span>
<span class="w"> </span>        .. versionadded:: 0.11

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if bw_method is None:</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif bw_method == &#39;scott&#39;:</span>
<span class="gi">+            self.covariance_factor = self.scotts_factor</span>
<span class="gi">+        elif bw_method == &#39;silverman&#39;:</span>
<span class="gi">+            self.covariance_factor = self.silverman_factor</span>
<span class="gi">+        elif np.isscalar(bw_method) and not isinstance(bw_method, str):</span>
<span class="gi">+            self._bw_method = &#39;use constant&#39;</span>
<span class="gi">+            self.covariance_factor = lambda: bw_method</span>
<span class="gi">+        elif callable(bw_method):</span>
<span class="gi">+            self._bw_method = bw_method</span>
<span class="gi">+            self.covariance_factor = lambda: self._bw_method(self)</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = &quot;`bw_method` should be &#39;scott&#39;, &#39;silverman&#39;, a scalar &quot; \</span>
<span class="gi">+                  &quot;or a callable.&quot;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        self._compute_covariance()</span>

<span class="w"> </span>    def _compute_covariance(self):
<span class="w"> </span>        &quot;&quot;&quot;Computes the covariance matrix for each Gaussian kernel using
<span class="w"> </span>        covariance_factor().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.factor = self.covariance_factor()</span>
<span class="gi">+        # Cache covariance and inverse covariance of the data</span>
<span class="gi">+        if not hasattr(self, &#39;_data_inv_cov&#39;):</span>
<span class="gi">+            self._data_covariance = atleast_2d(cov(self.dataset, rowvar=1,</span>
<span class="gi">+                                               bias=False,</span>
<span class="gi">+                                               aweights=self.weights))</span>
<span class="gi">+            self._data_inv_cov = linalg.inv(self._data_covariance)</span>
<span class="gi">+</span>
<span class="gi">+        self.covariance = self._data_covariance * self.factor**2</span>
<span class="gi">+        self.inv_cov = self._data_inv_cov / self.factor**2</span>
<span class="gi">+        self._norm_factor = sqrt(linalg.det(2*pi*self.covariance)) * self.n</span>

<span class="w"> </span>    def pdf(self, x):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -272,4 +329,4 @@ class gaussian_kde:</span>
<span class="w"> </span>        docstring for more details.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.evaluate(x)</span>
<span class="gh">diff --git a/seaborn/external/version.py b/seaborn/external/version.py</span>
<span class="gh">index 1dfe1611..3ba73baa 100644</span>
<span class="gd">--- a/seaborn/external/version.py</span>
<span class="gi">+++ b/seaborn/external/version.py</span>
<span class="gu">@@ -220,4 +220,21 @@ def _parse_local_version(local: str) -&gt;Optional[LocalType]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Takes a string like abc.1.twelve and turns it into (&quot;abc&quot;, 1, &quot;twelve&quot;).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if local is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    </span>
<span class="gi">+    parts = []</span>
<span class="gi">+    for part in _local_version_separators.split(local):</span>
<span class="gi">+        if not part:</span>
<span class="gi">+            continue</span>
<span class="gi">+        </span>
<span class="gi">+        # Try to convert to integer if possible</span>
<span class="gi">+        try:</span>
<span class="gi">+            parts.append(int(part))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            parts.append(part)</span>
<span class="gi">+    </span>
<span class="gi">+    if len(parts) == 0:</span>
<span class="gi">+        return None</span>
<span class="gi">+    </span>
<span class="gi">+    return tuple(parts)</span>
<span class="gh">diff --git a/seaborn/miscplot.py b/seaborn/miscplot.py</span>
<span class="gh">index 3bbc63a0..30ea1f0b 100644</span>
<span class="gd">--- a/seaborn/miscplot.py</span>
<span class="gi">+++ b/seaborn/miscplot.py</span>
<span class="gu">@@ -16,9 +16,25 @@ def palplot(pal, size=1):</span>
<span class="w"> </span>        scaling factor for size of plot

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = len(pal)</span>
<span class="gi">+    fig, ax = plt.subplots(1, 1, figsize=(n * size, size))</span>
<span class="gi">+    ax.imshow(np.arange(n).reshape(1, n),</span>
<span class="gi">+              cmap=mpl.colors.ListedColormap(list(pal)),</span>
<span class="gi">+              interpolation=&quot;nearest&quot;, aspect=&quot;auto&quot;)</span>
<span class="gi">+    ax.set_xticks(np.arange(n) - 0.5)</span>
<span class="gi">+    ax.set_yticks([-0.5, 0.5])</span>
<span class="gi">+    ax.set_xticklabels([])</span>
<span class="gi">+    ax.set_yticklabels([])</span>
<span class="gi">+    ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;, length=0)</span>
<span class="gi">+    ax.set_xlim(-0.5, n - 0.5)</span>
<span class="gi">+    ax.set_ylim(0.5, -0.5)</span>


<span class="w"> </span>def dogplot(*_, **__):
<span class="w"> </span>    &quot;&quot;&quot;Who&#39;s a good boy?&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fig, ax = plt.subplots()</span>
<span class="gi">+    ax.text(0.5, 0.5, &quot;Woof!&quot;, ha=&#39;center&#39;, va=&#39;center&#39;, fontsize=30)</span>
<span class="gi">+    ax.set_xlim(0, 1)</span>
<span class="gi">+    ax.set_ylim(0, 1)</span>
<span class="gi">+    ax.axis(&#39;off&#39;)</span>
<span class="gi">+    return fig</span>
<span class="gh">diff --git a/seaborn/palettes.py b/seaborn/palettes.py</span>
<span class="gh">index 6447384e..67afa6e9 100644</span>
<span class="gd">--- a/seaborn/palettes.py</span>
<span class="gi">+++ b/seaborn/palettes.py</span>
<span class="gu">@@ -238,277 +238,128 @@ def mpl_palette(name, n_colors=6, as_cmap=False):</span>

<span class="w"> </span>def _color_to_rgb(color, input):
<span class="w"> </span>    &quot;&quot;&quot;Add some more flexibility to color choices.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(color, str):</span>
<span class="gi">+        if input == &quot;hls&quot;:</span>
<span class="gi">+            return husl.hls_to_rgb(*color)</span>
<span class="gi">+        elif input == &quot;husl&quot;:</span>
<span class="gi">+            return husl.husl_to_rgb(*color)</span>
<span class="gi">+        elif input == &quot;xkcd&quot;:</span>
<span class="gi">+            return xkcd_rgb[color]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return mpl.colors.to_rgb(color)</span>
<span class="gi">+    elif isinstance(color, (tuple, list)):</span>
<span class="gi">+        return color</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;Color must be a string or rgb tuple&quot;)</span>


<span class="w"> </span>def dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input=&#39;rgb&#39;):
<span class="gd">-    &quot;&quot;&quot;Make a sequential palette that blends from dark to ``color``.</span>
<span class="gd">-</span>
<span class="gd">-    This kind of palette is good for data that range between relatively</span>
<span class="gd">-    uninteresting low values and interesting high values.</span>
<span class="gd">-</span>
<span class="gd">-    The ``color`` parameter can be specified in a number of ways, including</span>
<span class="gd">-    all options for defining a color in matplotlib and several additional</span>
<span class="gd">-    color spaces that are handled by seaborn. You can also use the database</span>
<span class="gd">-    of named colors from the XKCD color survey.</span>
<span class="gd">-</span>
<span class="gd">-    If you are using the IPython notebook, you can also choose this palette</span>
<span class="gd">-    interactively with the :func:`choose_dark_palette` function.</span>
<span class="gd">-</span>
<span class="gd">-    Parameters</span>
<span class="gd">-    ----------</span>
<span class="gd">-    color : base color for high values</span>
<span class="gd">-        hex, rgb-tuple, or html color name</span>
<span class="gd">-    n_colors : int, optional</span>
<span class="gd">-        number of colors in the palette</span>
<span class="gd">-    reverse : bool, optional</span>
<span class="gd">-        if True, reverse the direction of the blend</span>
<span class="gd">-    as_cmap : bool, optional</span>
<span class="gd">-        If True, return a :class:`matplotlib.colors.ListedColormap`.</span>
<span class="gd">-    input : {&#39;rgb&#39;, &#39;hls&#39;, &#39;husl&#39;, xkcd&#39;}</span>
<span class="gd">-        Color space to interpret the input color. The first three options</span>
<span class="gd">-        apply to tuple inputs and the latter applies to string inputs.</span>
<span class="gd">-</span>
<span class="gd">-    Returns</span>
<span class="gd">-    -------</span>
<span class="gd">-    palette</span>
<span class="gd">-        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`</span>
<span class="gd">-</span>
<span class="gd">-    See Also</span>
<span class="gd">-    --------</span>
<span class="gd">-    light_palette : Create a sequential palette with bright low values.</span>
<span class="gd">-    diverging_palette : Create a diverging palette with two colors.</span>
<span class="gd">-</span>
<span class="gd">-    Examples</span>
<span class="gd">-    --------</span>
<span class="gd">-    .. include:: ../docstrings/dark_palette.rst</span>
<span class="gd">-</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def light_palette(color, n_colors=6, reverse=False, as_cmap=False, input=&#39;rgb&#39;</span>
<span class="gd">-    ):</span>
<span class="gd">-    &quot;&quot;&quot;Make a sequential palette that blends from light to ``color``.</span>
<span class="gd">-</span>
<span class="gd">-    The ``color`` parameter can be specified in a number of ways, including</span>
<span class="gd">-    all options for defining a color in matplotlib and several additional</span>
<span class="gd">-    color spaces that are handled by seaborn. You can also use the database</span>
<span class="gd">-    of named colors from the XKCD color survey.</span>
<span class="gd">-</span>
<span class="gd">-    If you are using a Jupyter notebook, you can also choose this palette</span>
<span class="gd">-    interactively with the :func:`choose_light_palette` function.</span>
<span class="gd">-</span>
<span class="gd">-    Parameters</span>
<span class="gd">-    ----------</span>
<span class="gd">-    color : base color for high values</span>
<span class="gd">-        hex code, html color name, or tuple in `input` space.</span>
<span class="gd">-    n_colors : int, optional</span>
<span class="gd">-        number of colors in the palette</span>
<span class="gd">-    reverse : bool, optional</span>
<span class="gd">-        if True, reverse the direction of the blend</span>
<span class="gd">-    as_cmap : bool, optional</span>
<span class="gd">-        If True, return a :class:`matplotlib.colors.ListedColormap`.</span>
<span class="gd">-    input : {&#39;rgb&#39;, &#39;hls&#39;, &#39;husl&#39;, xkcd&#39;}</span>
<span class="gd">-        Color space to interpret the input color. The first three options</span>
<span class="gd">-        apply to tuple inputs and the latter applies to string inputs.</span>
<span class="gd">-</span>
<span class="gd">-    Returns</span>
<span class="gd">-    -------</span>
<span class="gd">-    palette</span>
<span class="gd">-        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`</span>
<span class="gi">+    &quot;&quot;&quot;Make a sequential palette that blends from dark to ``color``.&quot;&quot;&quot;</span>
<span class="gi">+    rgb = _color_to_rgb(color, input)</span>
<span class="gi">+    colors = [(0, 0, 0), rgb]</span>
<span class="gi">+    pal = blend_palette(colors, n_colors, as_cmap)</span>
<span class="gi">+    return pal[::-1] if reverse else pal</span>

<span class="gd">-    See Also</span>
<span class="gd">-    --------</span>
<span class="gd">-    dark_palette : Create a sequential palette with dark low values.</span>
<span class="gd">-    diverging_palette : Create a diverging palette with two colors.</span>

<span class="gd">-    Examples</span>
<span class="gd">-    --------</span>
<span class="gd">-    .. include:: ../docstrings/light_palette.rst</span>
<span class="gd">-</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def light_palette(color, n_colors=6, reverse=False, as_cmap=False, input=&#39;rgb&#39;):</span>
<span class="gi">+    &quot;&quot;&quot;Make a sequential palette that blends from light to ``color``.&quot;&quot;&quot;</span>
<span class="gi">+    rgb = _color_to_rgb(color, input)</span>
<span class="gi">+    colors = [(1, 1, 1), rgb]</span>
<span class="gi">+    pal = blend_palette(colors, n_colors, as_cmap)</span>
<span class="gi">+    return pal[::-1] if reverse else pal</span>


<span class="w"> </span>def diverging_palette(h_neg, h_pos, s=75, l=50, sep=1, n=6, center=&#39;light&#39;,
<span class="w"> </span>    as_cmap=False):
<span class="gd">-    &quot;&quot;&quot;Make a diverging palette between two HUSL colors.</span>
<span class="gd">-</span>
<span class="gd">-    If you are using the IPython notebook, you can also choose this palette</span>
<span class="gd">-    interactively with the :func:`choose_diverging_palette` function.</span>
<span class="gd">-</span>
<span class="gd">-    Parameters</span>
<span class="gd">-    ----------</span>
<span class="gd">-    h_neg, h_pos : float in [0, 359]</span>
<span class="gd">-        Anchor hues for negative and positive extents of the map.</span>
<span class="gd">-    s : float in [0, 100], optional</span>
<span class="gd">-        Anchor saturation for both extents of the map.</span>
<span class="gd">-    l : float in [0, 100], optional</span>
<span class="gd">-        Anchor lightness for both extents of the map.</span>
<span class="gd">-    sep : int, optional</span>
<span class="gd">-        Size of the intermediate region.</span>
<span class="gd">-    n : int, optional</span>
<span class="gd">-        Number of colors in the palette (if not returning a cmap)</span>
<span class="gd">-    center : {&quot;light&quot;, &quot;dark&quot;}, optional</span>
<span class="gd">-        Whether the center of the palette is light or dark</span>
<span class="gd">-    as_cmap : bool, optional</span>
<span class="gd">-        If True, return a :class:`matplotlib.colors.ListedColormap`.</span>
<span class="gd">-</span>
<span class="gd">-    Returns</span>
<span class="gd">-    -------</span>
<span class="gd">-    palette</span>
<span class="gd">-        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`</span>
<span class="gd">-</span>
<span class="gd">-    See Also</span>
<span class="gd">-    --------</span>
<span class="gd">-    dark_palette : Create a sequential palette with dark values.</span>
<span class="gd">-    light_palette : Create a sequential palette with light values.</span>
<span class="gd">-</span>
<span class="gd">-    Examples</span>
<span class="gd">-    --------</span>
<span class="gd">-    .. include: ../docstrings/diverging_palette.rst</span>
<span class="gd">-</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;Make a diverging palette between two HUSL colors.&quot;&quot;&quot;</span>
<span class="gi">+    s, l = s / 100, l / 100</span>
<span class="gi">+    h_neg, h_pos = h_neg % 360, h_pos % 360</span>
<span class="gi">+    </span>
<span class="gi">+    if center == &#39;light&#39;:</span>
<span class="gi">+        l_center = 0.95</span>
<span class="gi">+    elif center == &#39;dark&#39;:</span>
<span class="gi">+        l_center = 0.15</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;center must be &#39;light&#39; or &#39;dark&#39;&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if n % 2:</span>
<span class="gi">+        n_half = int((n - 1) / 2)</span>
<span class="gi">+        pal_neg = husl_palette(n_half + 1, h=h_neg, s=s, l=l)</span>
<span class="gi">+        pal_pos = husl_palette(n_half + 1, h=h_pos, s=s, l=l)</span>
<span class="gi">+        neg = pal_neg[:-1][::-1]</span>
<span class="gi">+        pos = pal_pos[1:]</span>
<span class="gi">+        midpoint = [(l_center, l_center, l_center)]</span>
<span class="gi">+    else:</span>
<span class="gi">+        n_half = int(n / 2)</span>
<span class="gi">+        pal_neg = husl_palette(n_half, h=h_neg, s=s, l=l)</span>
<span class="gi">+        pal_pos = husl_palette(n_half, h=h_pos, s=s, l=l)</span>
<span class="gi">+        neg = pal_neg[::-1]</span>
<span class="gi">+        pos = pal_pos</span>
<span class="gi">+        midpoint = []</span>
<span class="gi">+</span>
<span class="gi">+    pal = neg + midpoint + pos</span>
<span class="gi">+</span>
<span class="gi">+    if sep &gt; 1:</span>
<span class="gi">+        pal = blend_palette(pal, n, as_cmap=as_cmap)</span>
<span class="gi">+</span>
<span class="gi">+    return pal if not as_cmap else mpl.colors.ListedColormap(pal)</span>


<span class="w"> </span>def blend_palette(colors, n_colors=6, as_cmap=False, input=&#39;rgb&#39;):
<span class="gd">-    &quot;&quot;&quot;Make a palette that blends between a list of colors.</span>
<span class="gd">-</span>
<span class="gd">-    Parameters</span>
<span class="gd">-    ----------</span>
<span class="gd">-    colors : sequence of colors in various formats interpreted by `input`</span>
<span class="gd">-        hex code, html color name, or tuple in `input` space.</span>
<span class="gd">-    n_colors : int, optional</span>
<span class="gd">-        Number of colors in the palette.</span>
<span class="gd">-    as_cmap : bool, optional</span>
<span class="gd">-        If True, return a :class:`matplotlib.colors.ListedColormap`.</span>
<span class="gd">-</span>
<span class="gd">-    Returns</span>
<span class="gd">-    -------</span>
<span class="gd">-    palette</span>
<span class="gd">-        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`</span>
<span class="gd">-</span>
<span class="gd">-    Examples</span>
<span class="gd">-    --------</span>
<span class="gd">-    .. include: ../docstrings/blend_palette.rst</span>
<span class="gd">-</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;Make a palette that blends between a list of colors.&quot;&quot;&quot;</span>
<span class="gi">+    colors = [_color_to_rgb(color, input) for color in colors]</span>
<span class="gi">+    name = &quot;blend&quot;</span>
<span class="gi">+    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        return pal</span>
<span class="gi">+    else:</span>
<span class="gi">+        return pal(np.linspace(0, 1, n_colors))</span>


<span class="w"> </span>def xkcd_palette(colors):
<span class="gd">-    &quot;&quot;&quot;Make a palette with color names from the xkcd color survey.</span>
<span class="gd">-</span>
<span class="gd">-    See xkcd for the full list of colors: https://xkcd.com/color/rgb/</span>
<span class="gd">-</span>
<span class="gd">-    This is just a simple wrapper around the `seaborn.xkcd_rgb` dictionary.</span>
<span class="gd">-</span>
<span class="gd">-    Parameters</span>
<span class="gd">-    ----------</span>
<span class="gd">-    colors : list of strings</span>
<span class="gd">-        List of keys in the `seaborn.xkcd_rgb` dictionary.</span>
<span class="gd">-</span>
<span class="gd">-    Returns</span>
<span class="gd">-    -------</span>
<span class="gd">-    palette</span>
<span class="gd">-        A list of colors as RGB tuples.</span>
<span class="gd">-</span>
<span class="gd">-    See Also</span>
<span class="gd">-    --------</span>
<span class="gd">-    crayon_palette : Make a palette with Crayola crayon colors.</span>
<span class="gd">-</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;Make a palette with color names from the xkcd color survey.&quot;&quot;&quot;</span>
<span class="gi">+    return [xkcd_rgb[name] for name in colors]</span>


<span class="w"> </span>def crayon_palette(colors):
<span class="gd">-    &quot;&quot;&quot;Make a palette with color names from Crayola crayons.</span>
<span class="gd">-</span>
<span class="gd">-    Colors are taken from here:</span>
<span class="gd">-    https://en.wikipedia.org/wiki/List_of_Crayola_crayon_colors</span>
<span class="gd">-</span>
<span class="gd">-    This is just a simple wrapper around the `seaborn.crayons` dictionary.</span>
<span class="gd">-</span>
<span class="gd">-    Parameters</span>
<span class="gd">-    ----------</span>
<span class="gd">-    colors : list of strings</span>
<span class="gd">-        List of keys in the `seaborn.crayons` dictionary.</span>
<span class="gd">-</span>
<span class="gd">-    Returns</span>
<span class="gd">-    -------</span>
<span class="gd">-    palette</span>
<span class="gd">-        A list of colors as RGB tuples.</span>
<span class="gd">-</span>
<span class="gd">-    See Also</span>
<span class="gd">-    --------</span>
<span class="gd">-    xkcd_palette : Make a palette with named colors from the XKCD color survey.</span>
<span class="gd">-</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;Make a palette with color names from Crayola crayons.&quot;&quot;&quot;</span>
<span class="gi">+    return [crayons[name] for name in colors]</span>


<span class="w"> </span>def cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,
<span class="w"> </span>    light=0.85, dark=0.15, reverse=False, as_cmap=False):
<span class="gd">-    &quot;&quot;&quot;Make a sequential palette from the cubehelix system.</span>
<span class="gd">-</span>
<span class="gd">-    This produces a colormap with linearly-decreasing (or increasing)</span>
<span class="gd">-    brightness. That means that information will be preserved if printed to</span>
<span class="gd">-    black and white or viewed by someone who is colorblind.  &quot;cubehelix&quot; is</span>
<span class="gd">-    also available as a matplotlib-based palette, but this function gives the</span>
<span class="gd">-    user more control over the look of the palette and has a different set of</span>
<span class="gd">-    defaults.</span>
<span class="gd">-</span>
<span class="gd">-    In addition to using this function, it is also possible to generate a</span>
<span class="gd">-    cubehelix palette generally in seaborn using a string starting with</span>
<span class="gd">-    `ch:` and containing other parameters (e.g. `&quot;ch:s=.25,r=-.5&quot;`).</span>
<span class="gd">-</span>
<span class="gd">-    Parameters</span>
<span class="gd">-    ----------</span>
<span class="gd">-    n_colors : int</span>
<span class="gd">-        Number of colors in the palette.</span>
<span class="gd">-    start : float, 0 &lt;= start &lt;= 3</span>
<span class="gd">-        The hue value at the start of the helix.</span>
<span class="gd">-    rot : float</span>
<span class="gd">-        Rotations around the hue wheel over the range of the palette.</span>
<span class="gd">-    gamma : float 0 &lt;= gamma</span>
<span class="gd">-        Nonlinearity to emphasize dark (gamma &lt; 1) or light (gamma &gt; 1) colors.</span>
<span class="gd">-    hue : float, 0 &lt;= hue &lt;= 1</span>
<span class="gd">-        Saturation of the colors.</span>
<span class="gd">-    dark : float 0 &lt;= dark &lt;= 1</span>
<span class="gd">-        Intensity of the darkest color in the palette.</span>
<span class="gd">-    light : float 0 &lt;= light &lt;= 1</span>
<span class="gd">-        Intensity of the lightest color in the palette.</span>
<span class="gd">-    reverse : bool</span>
<span class="gd">-        If True, the palette will go from dark to light.</span>
<span class="gd">-    as_cmap : bool</span>
<span class="gd">-        If True, return a :class:`matplotlib.colors.ListedColormap`.</span>
<span class="gd">-</span>
<span class="gd">-    Returns</span>
<span class="gd">-    -------</span>
<span class="gd">-    palette</span>
<span class="gd">-        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`</span>
<span class="gd">-</span>
<span class="gd">-    See Also</span>
<span class="gd">-    --------</span>
<span class="gd">-    choose_cubehelix_palette : Launch an interactive widget to select cubehelix</span>
<span class="gd">-                               palette parameters.</span>
<span class="gd">-    dark_palette : Create a sequential palette with dark low values.</span>
<span class="gd">-    light_palette : Create a sequential palette with bright low values.</span>
<span class="gd">-</span>
<span class="gd">-    References</span>
<span class="gd">-    ----------</span>
<span class="gd">-    Green, D. A. (2011). &quot;A colour scheme for the display of astronomical</span>
<span class="gd">-    intensity images&quot;. Bulletin of the Astromical Society of India, Vol. 39,</span>
<span class="gd">-    p. 289-295.</span>
<span class="gd">-</span>
<span class="gd">-    Examples</span>
<span class="gd">-    --------</span>
<span class="gd">-    .. include:: ../docstrings/cubehelix_palette.rst</span>
<span class="gd">-</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;Make a sequential palette from the cubehelix system.&quot;&quot;&quot;</span>
<span class="gi">+    def get_color_function(p0, p1):</span>
<span class="gi">+        def color(x):</span>
<span class="gi">+            # Apply gamma factor to emphasize low or high intensities</span>
<span class="gi">+            xg = x ** gamma</span>
<span class="gi">+            </span>
<span class="gi">+            # Calculate amplitude and angle of deviation from the black to white diagonal in the plane of constant</span>
<span class="gi">+            # perceived intensity</span>
<span class="gi">+            a = hue * xg * (1 - xg) / 2</span>
<span class="gi">+            </span>
<span class="gi">+            phi = 2 * np.pi * (start / 3 + rot * x)</span>
<span class="gi">+            </span>
<span class="gi">+            return xg + a * (p0 * np.cos(phi) + p1 * np.sin(phi))</span>
<span class="gi">+        return color</span>
<span class="gi">+</span>
<span class="gi">+    cdict = {</span>
<span class="gi">+        &quot;red&quot;: get_color_function(-0.14861, 1.78277),</span>
<span class="gi">+        &quot;green&quot;: get_color_function(-0.29227, -0.90649),</span>
<span class="gi">+        &quot;blue&quot;: get_color_function(1.97294, 0.0)</span>
<span class="gi">+    }</span>
<span class="gi">+    </span>
<span class="gi">+    cmap = mpl.colors.LinearSegmentedColormap(&quot;cubehelix&quot;, cdict)</span>
<span class="gi">+    </span>
<span class="gi">+    x = np.linspace(light, dark, n_colors)</span>
<span class="gi">+    pal = cmap(x)[:, :3].tolist()</span>
<span class="gi">+    if reverse:</span>
<span class="gi">+        pal = pal[::-1]</span>
<span class="gi">+    </span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        return mpl.colors.ListedColormap(pal)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return pal</span>


<span class="w"> </span>def _parse_cubehelix_args(argstr):
<span class="gh">diff --git a/seaborn/rcmod.py b/seaborn/rcmod.py</span>
<span class="gh">index 28795aea..6a95fc38 100644</span>
<span class="gd">--- a/seaborn/rcmod.py</span>
<span class="gi">+++ b/seaborn/rcmod.py</span>
<span class="gu">@@ -59,7 +59,21 @@ def set_theme(context=&#39;notebook&#39;, style=&#39;darkgrid&#39;, palette=&#39;deep&#39;, font=</span>
<span class="w"> </span>    .. include:: ../docstrings/set_theme.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Set the context (scaling)</span>
<span class="gi">+    set_context(context, font_scale)</span>
<span class="gi">+    </span>
<span class="gi">+    # Set the style</span>
<span class="gi">+    set_style(style)</span>
<span class="gi">+    </span>
<span class="gi">+    # Set the color palette</span>
<span class="gi">+    set_palette(palette, color_codes=color_codes)</span>
<span class="gi">+    </span>
<span class="gi">+    # Set the font</span>
<span class="gi">+    mpl.rcParams[&#39;font.family&#39;] = font</span>
<span class="gi">+    </span>
<span class="gi">+    # Override with custom rc parameters if provided</span>
<span class="gi">+    if rc is not None:</span>
<span class="gi">+        mpl.rcParams.update(rc)</span>


<span class="w"> </span>def set(*args, **kwargs):
<span class="gu">@@ -68,17 +82,17 @@ def set(*args, **kwargs):</span>

<span class="w"> </span>    This function may be removed in the future.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return set_theme(*args, **kwargs)</span>


<span class="w"> </span>def reset_defaults():
<span class="w"> </span>    &quot;&quot;&quot;Restore all RC params to default settings.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    mpl.rcParams.update(mpl.rcParamsDefault)</span>


<span class="w"> </span>def reset_orig():
<span class="w"> </span>    &quot;&quot;&quot;Restore all RC params to original settings (respects custom rc).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    mpl.rcParams.update(mpl.rcParamsOrig)</span>


<span class="w"> </span>def axes_style(style=None, rc=None):
<span class="gu">@@ -111,7 +125,40 @@ def axes_style(style=None, rc=None):</span>
<span class="w"> </span>    .. include:: ../docstrings/axes_style.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if style is None:</span>
<span class="gi">+        style = {}</span>
<span class="gi">+</span>
<span class="gi">+    # Define preset styles</span>
<span class="gi">+    preset_styles = {</span>
<span class="gi">+        &#39;darkgrid&#39;: {&#39;axes.facecolor&#39;: &#39;.15&#39;, &#39;axes.edgecolor&#39;: &#39;white&#39;,</span>
<span class="gi">+                     &#39;axes.grid&#39;: True, &#39;grid.color&#39;: &#39;white&#39;},</span>
<span class="gi">+        &#39;whitegrid&#39;: {&#39;axes.facecolor&#39;: &#39;white&#39;, &#39;axes.edgecolor&#39;: &#39;.15&#39;,</span>
<span class="gi">+                      &#39;axes.grid&#39;: True, &#39;grid.color&#39;: &#39;.8&#39;},</span>
<span class="gi">+        &#39;dark&#39;: {&#39;axes.facecolor&#39;: &#39;.15&#39;, &#39;axes.edgecolor&#39;: &#39;white&#39;,</span>
<span class="gi">+                 &#39;axes.grid&#39;: False},</span>
<span class="gi">+        &#39;white&#39;: {&#39;axes.facecolor&#39;: &#39;white&#39;, &#39;axes.edgecolor&#39;: &#39;.15&#39;,</span>
<span class="gi">+                  &#39;axes.grid&#39;: False},</span>
<span class="gi">+        &#39;ticks&#39;: {&#39;axes.facecolor&#39;: &#39;white&#39;, &#39;axes.edgecolor&#39;: &#39;.15&#39;,</span>
<span class="gi">+                  &#39;axes.grid&#39;: False, &#39;xtick.direction&#39;: &#39;out&#39;,</span>
<span class="gi">+                  &#39;ytick.direction&#39;: &#39;out&#39;}</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    # Use the specified style, or merge with custom rc if provided</span>
<span class="gi">+    if isinstance(style, str):</span>
<span class="gi">+        if style not in preset_styles:</span>
<span class="gi">+            raise ValueError(f&quot;style must be one of {&#39;, &#39;.join(preset_styles.keys())}&quot;)</span>
<span class="gi">+        style_dict = preset_styles[style].copy()</span>
<span class="gi">+    elif isinstance(style, dict):</span>
<span class="gi">+        style_dict = style.copy()</span>
<span class="gi">+    else:</span>
<span class="gi">+        style_dict = {}</span>
<span class="gi">+</span>
<span class="gi">+    # Update with custom rc if provided</span>
<span class="gi">+    if rc is not None:</span>
<span class="gi">+        style_dict.update(rc)</span>
<span class="gi">+</span>
<span class="gi">+    # Create and return the _AxesStyle object</span>
<span class="gi">+    return _AxesStyle(style_dict)</span>


<span class="w"> </span>def set_style(style=None, rc=None):
<span class="gu">@@ -142,7 +189,8 @@ def set_style(style=None, rc=None):</span>
<span class="w"> </span>    .. include:: ../docstrings/set_style.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    style_dict = axes_style(style, rc).copy()</span>
<span class="gi">+    mpl.rcParams.update(style_dict)</span>


<span class="w"> </span>def plotting_context(context=None, font_scale=1, rc=None):
<span class="gu">@@ -179,7 +227,43 @@ def plotting_context(context=None, font_scale=1, rc=None):</span>
<span class="w"> </span>    .. include:: ../docstrings/plotting_context.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if context is None:</span>
<span class="gi">+        context = {}</span>
<span class="gi">+</span>
<span class="gi">+    # Define preset contexts</span>
<span class="gi">+    preset_contexts = {</span>
<span class="gi">+        &#39;paper&#39;: {&#39;font.size&#39;: 8, &#39;axes.labelsize&#39;: 8, &#39;axes.titlesize&#39;: 9,</span>
<span class="gi">+                  &#39;xtick.labelsize&#39;: 7, &#39;ytick.labelsize&#39;: 7, &#39;legend.fontsize&#39;: 7},</span>
<span class="gi">+        &#39;notebook&#39;: {&#39;font.size&#39;: 10, &#39;axes.labelsize&#39;: 10, &#39;axes.titlesize&#39;: 11,</span>
<span class="gi">+                     &#39;xtick.labelsize&#39;: 9, &#39;ytick.labelsize&#39;: 9, &#39;legend.fontsize&#39;: 9},</span>
<span class="gi">+        &#39;talk&#39;: {&#39;font.size&#39;: 14, &#39;axes.labelsize&#39;: 14, &#39;axes.titlesize&#39;: 15,</span>
<span class="gi">+                 &#39;xtick.labelsize&#39;: 12, &#39;ytick.labelsize&#39;: 12, &#39;legend.fontsize&#39;: 12},</span>
<span class="gi">+        &#39;poster&#39;: {&#39;font.size&#39;: 18, &#39;axes.labelsize&#39;: 18, &#39;axes.titlesize&#39;: 19,</span>
<span class="gi">+                   &#39;xtick.labelsize&#39;: 16, &#39;ytick.labelsize&#39;: 16, &#39;legend.fontsize&#39;: 16}</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    # Use the specified context, or merge with custom rc if provided</span>
<span class="gi">+    if isinstance(context, str):</span>
<span class="gi">+        if context not in preset_contexts:</span>
<span class="gi">+            raise ValueError(f&quot;context must be one of {&#39;, &#39;.join(preset_contexts.keys())}&quot;)</span>
<span class="gi">+        context_dict = preset_contexts[context].copy()</span>
<span class="gi">+    elif isinstance(context, dict):</span>
<span class="gi">+        context_dict = context.copy()</span>
<span class="gi">+    else:</span>
<span class="gi">+        context_dict = preset_contexts[&#39;notebook&#39;].copy()</span>
<span class="gi">+</span>
<span class="gi">+    # Scale font sizes</span>
<span class="gi">+    font_keys = [&#39;font.size&#39;, &#39;axes.labelsize&#39;, &#39;axes.titlesize&#39;,</span>
<span class="gi">+                 &#39;xtick.labelsize&#39;, &#39;ytick.labelsize&#39;, &#39;legend.fontsize&#39;]</span>
<span class="gi">+    for key in font_keys:</span>
<span class="gi">+        context_dict[key] = context_dict[key] * font_scale</span>
<span class="gi">+</span>
<span class="gi">+    # Update with custom rc if provided</span>
<span class="gi">+    if rc is not None:</span>
<span class="gi">+        context_dict.update(rc)</span>
<span class="gi">+</span>
<span class="gi">+    # Create and return the _PlottingContext object</span>
<span class="gi">+    return _PlottingContext(context_dict)</span>


<span class="w"> </span>def set_context(context=None, font_scale=1, rc=None):
<span class="gu">@@ -215,7 +299,8 @@ def set_context(context=None, font_scale=1, rc=None):</span>
<span class="w"> </span>    .. include:: ../docstrings/set_context.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    context_dict = plotting_context(context, font_scale, rc).copy()</span>
<span class="gi">+    mpl.rcParams.update(context_dict)</span>


<span class="w"> </span>class _RCAesthetics(dict):
<span class="gu">@@ -274,4 +359,7 @@ def set_palette(palette, n_colors=None, desat=None, color_codes=False):</span>
<span class="w"> </span>    set_style : set the default parameters for figure style

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    colors = palettes.color_palette(palette, n_colors, desat)</span>
<span class="gi">+    if palettes.SEABORN_PALETTES.get(palette) is not None and color_codes:</span>
<span class="gi">+        palettes.set_color_codes(palette)</span>
<span class="gi">+    mpl.rcParams[&quot;axes.prop_cycle&quot;] = cycler(color=colors)</span>
<span class="gh">diff --git a/seaborn/regression.py b/seaborn/regression.py</span>
<span class="gh">index 9a41fe79..0a9476f6 100644</span>
<span class="gd">--- a/seaborn/regression.py</span>
<span class="gi">+++ b/seaborn/regression.py</span>
<span class="gu">@@ -28,11 +28,22 @@ class _LinearPlotter:</span>

<span class="w"> </span>    def establish_variables(self, data, **kws):
<span class="w"> </span>        &quot;&quot;&quot;Extract variables from data or use directly.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.data = data</span>
<span class="gi">+        for key, val in kws.items():</span>
<span class="gi">+            if isinstance(val, str):</span>
<span class="gi">+                kws[key] = data[val]</span>
<span class="gi">+            elif isinstance(val, list) and all(isinstance(v, str) for v in val):</span>
<span class="gi">+                kws[key] = data[val].values.T</span>
<span class="gi">+        self.__dict__.update(kws)</span>

<span class="w"> </span>    def dropna(self, *vars):
<span class="w"> </span>        &quot;&quot;&quot;Remove observations with missing data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if vars:</span>
<span class="gi">+            obs = pd.notnull(self.data[list(vars)]).all(axis=1)</span>
<span class="gi">+            if hasattr(self, &quot;weights&quot;):</span>
<span class="gi">+                self.weights = self.weights[obs]</span>
<span class="gi">+            for var in vars:</span>
<span class="gi">+                self.__dict__[var] = self.__dict__[var][obs]</span>


<span class="w"> </span>class _RegressionPlotter(_LinearPlotter):
<span class="gu">@@ -88,60 +99,154 @@ class _RegressionPlotter(_LinearPlotter):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def scatter_data(self):
<span class="w"> </span>        &quot;&quot;&quot;Data where each observation is a point.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x = self.x</span>
<span class="gi">+        y = self.y</span>
<span class="gi">+        if self.x_jitter is not None:</span>
<span class="gi">+            x = x + np.random.uniform(-self.x_jitter, self.x_jitter, len(x))</span>
<span class="gi">+        if self.y_jitter is not None:</span>
<span class="gi">+            y = y + np.random.uniform(-self.y_jitter, self.y_jitter, len(y))</span>
<span class="gi">+        return x, y</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def estimate_data(self):
<span class="w"> </span>        &quot;&quot;&quot;Data with a point estimate and CI for each discrete x value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x = self.x_discrete</span>
<span class="gi">+        if self.x_estimator is None:</span>
<span class="gi">+            return x, None, None</span>
<span class="gi">+        </span>
<span class="gi">+        y = self.y</span>
<span class="gi">+        vals, bins = pd.cut(x, bins=self.x_bins, retbins=True)</span>
<span class="gi">+        points = bins[:-1] + np.diff(bins) / 2</span>
<span class="gi">+</span>
<span class="gi">+        if self.x_ci == &#39;sd&#39;:</span>
<span class="gi">+            est = y.groupby(vals).agg([&#39;mean&#39;, &#39;std&#39;])</span>
<span class="gi">+            ci_low = est[&#39;mean&#39;] - est[&#39;std&#39;]</span>
<span class="gi">+            ci_high = est[&#39;mean&#39;] + est[&#39;std&#39;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            est = y.groupby(vals).agg(self.x_estimator)</span>
<span class="gi">+            if self.x_ci is None:</span>
<span class="gi">+                ci_low = ci_high = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                boots = algo.bootstrap(y, vals, func=self.x_estimator,</span>
<span class="gi">+                                       n_boot=self.n_boot, units=self.units)</span>
<span class="gi">+                ci_low, ci_high = utils.ci(boots, self.x_ci)</span>
<span class="gi">+        return points, est, (ci_low, ci_high)</span>

<span class="w"> </span>    def _check_statsmodels(self):
<span class="w"> </span>        &quot;&quot;&quot;Check whether statsmodels is installed if any boolean options require it.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not _has_statsmodels and (self.robust or self.logistic or self.lowess):</span>
<span class="gi">+            raise ImportError(&quot;The statsmodels package is required.&quot;)</span>

<span class="w"> </span>    def fit_regression(self, ax=None, x_range=None, grid=None):
<span class="w"> </span>        &quot;&quot;&quot;Fit the regression model.&quot;&quot;&quot;
<span class="gi">+        # Implementation depends on the specific regression type</span>
<span class="w"> </span>        pass

<span class="w"> </span>    def fit_fast(self, grid):
<span class="w"> </span>        &quot;&quot;&quot;Low-level regression and prediction using linear algebra.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        y = self.y</span>
<span class="gi">+        X = np.c_[np.ones(len(self.x)), self.x]</span>
<span class="gi">+        flat = grid.reshape(-1, 1)</span>
<span class="gi">+        grid_X = np.c_[np.ones(len(flat)), flat]</span>
<span class="gi">+        </span>
<span class="gi">+        def reg_func(_x, _y):</span>
<span class="gi">+            return np.linalg.pinv(_x).dot(_y)</span>
<span class="gi">+        </span>
<span class="gi">+        yhat = grid_X.dot(reg_func(X, y))</span>
<span class="gi">+        if self.ci is None:</span>
<span class="gi">+            return yhat</span>
<span class="gi">+        </span>
<span class="gi">+        beta_boots = algo.bootstrap(X, y, func=reg_func,</span>
<span class="gi">+                                    n_boot=self.n_boot, units=self.units).T</span>
<span class="gi">+        yhat_boots = grid_X.dot(beta_boots).T</span>
<span class="gi">+        return yhat, utils.ci(yhat_boots, self.ci)</span>

<span class="w"> </span>    def fit_poly(self, grid, order):
<span class="w"> </span>        &quot;&quot;&quot;Regression using numpy polyfit for higher-order trends.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x = self.x</span>
<span class="gi">+        y = self.y</span>
<span class="gi">+        </span>
<span class="gi">+        def reg_func(_x, _y):</span>
<span class="gi">+            return np.polyval(np.polyfit(_x, _y, order), grid)</span>
<span class="gi">+        </span>
<span class="gi">+        yhat = reg_func(x, y)</span>
<span class="gi">+        if self.ci is None:</span>
<span class="gi">+            return yhat</span>
<span class="gi">+        </span>
<span class="gi">+        yhat_boots = algo.bootstrap(x, y, func=reg_func,</span>
<span class="gi">+                                    n_boot=self.n_boot, units=self.units)</span>
<span class="gi">+        return yhat, utils.ci(yhat_boots, self.ci)</span>

<span class="w"> </span>    def fit_statsmodels(self, grid, model, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;More general regression function using statsmodels objects.&quot;&quot;&quot;
<span class="gi">+        # Implementation depends on the specific statsmodels model</span>
<span class="w"> </span>        pass

<span class="w"> </span>    def fit_lowess(self):
<span class="w"> </span>        &quot;&quot;&quot;Fit a locally-weighted regression, which returns its own grid.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from statsmodels.nonparametric.smoothers_lowess import lowess</span>
<span class="gi">+        x = self.x</span>
<span class="gi">+        y = self.y</span>
<span class="gi">+        return lowess(y, x, frac=1. / 3)</span>

<span class="w"> </span>    def fit_logx(self, grid):
<span class="w"> </span>        &quot;&quot;&quot;Fit the model in log-space.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x = self.x</span>
<span class="gi">+        y = self.y</span>
<span class="gi">+        </span>
<span class="gi">+        def reg_func(_x, _y):</span>
<span class="gi">+            return np.polyval(np.polyfit(np.log(_x), _y, 1), np.log(grid))</span>
<span class="gi">+        </span>
<span class="gi">+        yhat = reg_func(x, y)</span>
<span class="gi">+        if self.ci is None:</span>
<span class="gi">+            return yhat</span>
<span class="gi">+        </span>
<span class="gi">+        yhat_boots = algo.bootstrap(x, y, func=reg_func,</span>
<span class="gi">+                                    n_boot=self.n_boot, units=self.units)</span>
<span class="gi">+        return yhat, utils.ci(yhat_boots, self.ci)</span>

<span class="w"> </span>    def bin_predictor(self, bins):
<span class="w"> </span>        &quot;&quot;&quot;Discretize a predictor by assigning value to closest bin.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x = self.x</span>
<span class="gi">+        if np.isscalar(bins):</span>
<span class="gi">+            bins = np.linspace(x.min(), x.max(), bins)</span>
<span class="gi">+        else:</span>
<span class="gi">+            bins = np.asarray(bins)</span>
<span class="gi">+        return bins[np.digitize(x, bins[1:-1])]</span>

<span class="w"> </span>    def regress_out(self, a, b):
<span class="w"> </span>        &quot;&quot;&quot;Regress b from a keeping a&#39;s original mean.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        a_mean = a.mean()</span>
<span class="gi">+        a_norm = a - a_mean</span>
<span class="gi">+        b_norm = b - b.mean()</span>
<span class="gi">+        beta = np.dot(b_norm, a_norm) / np.dot(a_norm, a_norm)</span>
<span class="gi">+        return (a_norm - beta * b_norm) + a_mean</span>

<span class="w"> </span>    def plot(self, ax, scatter_kws, line_kws):
<span class="w"> </span>        &quot;&quot;&quot;Draw the full plot.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if ax is None:</span>
<span class="gi">+            ax = plt.gca()</span>
<span class="gi">+        </span>
<span class="gi">+        # Plot the scatter points</span>
<span class="gi">+        if self.scatter:</span>
<span class="gi">+            self.scatterplot(ax, scatter_kws)</span>
<span class="gi">+        </span>
<span class="gi">+        # Plot the regression line</span>
<span class="gi">+        if self.fit_reg:</span>
<span class="gi">+            self.lineplot(ax, line_kws)</span>
<span class="gi">+        </span>
<span class="gi">+        return ax</span>

<span class="w"> </span>    def scatterplot(self, ax, kws):
<span class="w"> </span>        &quot;&quot;&quot;Draw the data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x, y = self.scatter_data</span>
<span class="gi">+        ax.scatter(x, y, **kws)</span>

<span class="w"> </span>    def lineplot(self, ax, kws):
<span class="w"> </span>        &quot;&quot;&quot;Draw the model.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x = np.linspace(self.x.min(), self.x.max(), 100)</span>
<span class="gi">+        y = self.fit_regression(grid=x)</span>
<span class="gi">+        ax.plot(x, y, **kws)</span>


<span class="w"> </span>_regression_docs = dict(model_api=dedent(
<span class="gu">@@ -477,4 +582,41 @@ def residplot(data=None, *, x=None, y=None, x_partial=None, y_partial=None,</span>
<span class="w"> </span>    .. include:: ../docstrings/residplot.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    plotter = _RegressionPlotter(x, y, data, x_partial, y_partial,</span>
<span class="gi">+                                 order=order, robust=robust, dropna=dropna)</span>
<span class="gi">+    </span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+    </span>
<span class="gi">+    # Fit the regression model</span>
<span class="gi">+    grid = np.linspace(plotter.x.min(), plotter.x.max(), 100)</span>
<span class="gi">+    yhat = plotter.fit_regression(grid=grid)</span>
<span class="gi">+    </span>
<span class="gi">+    # Calculate residuals</span>
<span class="gi">+    resid = plotter.y - np.interp(plotter.x, grid, yhat)</span>
<span class="gi">+    </span>
<span class="gi">+    # Set up the scatter plot parameters</span>
<span class="gi">+    if scatter_kws is None:</span>
<span class="gi">+        scatter_kws = {}</span>
<span class="gi">+    if color is not None:</span>
<span class="gi">+        scatter_kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+    </span>
<span class="gi">+    # Plot the residuals</span>
<span class="gi">+    ax.scatter(plotter.x, resid, **scatter_kws)</span>
<span class="gi">+    </span>
<span class="gi">+    # Add the lowess line if requested</span>
<span class="gi">+    if lowess:</span>
<span class="gi">+        from statsmodels.nonparametric.smoothers_lowess import lowess as sm_lowess</span>
<span class="gi">+        smooth = sm_lowess(resid, plotter.x)</span>
<span class="gi">+        if line_kws is None:</span>
<span class="gi">+            line_kws = {}</span>
<span class="gi">+        if color is not None:</span>
<span class="gi">+            line_kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+        ax.plot(smooth[:, 0], smooth[:, 1], **line_kws)</span>
<span class="gi">+    </span>
<span class="gi">+    # Adjust the plot</span>
<span class="gi">+    ax.axhline(0, color=&quot;.2&quot;, linestyle=&quot;--&quot;)</span>
<span class="gi">+    ax.set_xlabel(plotter.x_var)</span>
<span class="gi">+    ax.set_ylabel(&quot;Residuals&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    return ax</span>
<span class="gh">diff --git a/seaborn/relational.py b/seaborn/relational.py</span>
<span class="gh">index 76efb2d1..63bc9243 100644</span>
<span class="gd">--- a/seaborn/relational.py</span>
<span class="gi">+++ b/seaborn/relational.py</span>
<span class="gu">@@ -206,7 +206,43 @@ class _LinePlotter(_RelationalPlotter):</span>

<span class="w"> </span>    def plot(self, ax, kws):
<span class="w"> </span>        &quot;&quot;&quot;Draw the plot onto an axes, passing matplotlib kwargs.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Set up the data</span>
<span class="gi">+        self.parse_data(self.data, self.variables)</span>
<span class="gi">+        data = self.plot_data</span>
<span class="gi">+</span>
<span class="gi">+        # Handle sorting</span>
<span class="gi">+        if self.sort:</span>
<span class="gi">+            data = data.sort_values(self.orient)</span>
<span class="gi">+</span>
<span class="gi">+        # Draw the main line</span>
<span class="gi">+        line_kws = dict(color=self.colors[0], linewidth=self.sizes[0])</span>
<span class="gi">+        line_kws.update(kws)</span>
<span class="gi">+        line, = ax.plot(data[self.orient], data[self.value_label], **line_kws)</span>
<span class="gi">+</span>
<span class="gi">+        # Add error bars if needed</span>
<span class="gi">+        if self.errorbar is not None:</span>
<span class="gi">+            err_kws = self.err_kws.copy()</span>
<span class="gi">+            err_kws.setdefault(&quot;color&quot;, line.get_color())</span>
<span class="gi">+            err_style = self.err_style or (&quot;band&quot; if self.orient == &quot;x&quot; else &quot;bars&quot;)</span>
<span class="gi">+            </span>
<span class="gi">+            if err_style == &quot;band&quot;:</span>
<span class="gi">+                ax.fill_between(data[self.orient], </span>
<span class="gi">+                                data[self.value_label] - data[self.errorbar],</span>
<span class="gi">+                                data[self.value_label] + data[self.errorbar],</span>
<span class="gi">+                                alpha=0.2, **err_kws)</span>
<span class="gi">+            elif err_style == &quot;bars&quot;:</span>
<span class="gi">+                ax.errorbar(data[self.orient], data[self.value_label],</span>
<span class="gi">+                            yerr=data[self.errorbar], fmt=&quot;none&quot;, **err_kws)</span>
<span class="gi">+</span>
<span class="gi">+        # Set the axis labels</span>
<span class="gi">+        if self.orient == &quot;x&quot;:</span>
<span class="gi">+            ax.set_xlabel(self.x_label)</span>
<span class="gi">+            ax.set_ylabel(self.y_label)</span>
<span class="gi">+        else:</span>
<span class="gi">+            ax.set_xlabel(self.y_label)</span>
<span class="gi">+            ax.set_ylabel(self.x_label)</span>
<span class="gi">+</span>
<span class="gi">+        return ax</span>


<span class="w"> </span>class _ScatterPlotter(_RelationalPlotter):
<span class="gu">@@ -218,6 +254,49 @@ class _ScatterPlotter(_RelationalPlotter):</span>
<span class="w"> </span>        super().__init__(data=data, variables=variables)
<span class="w"> </span>        self.legend = legend

<span class="gi">+    def plot(self, ax, kws):</span>
<span class="gi">+        &quot;&quot;&quot;Draw the plot onto an axes, passing matplotlib kwargs.&quot;&quot;&quot;</span>
<span class="gi">+        # Set up the data</span>
<span class="gi">+        self.parse_data(self.data, self.variables)</span>
<span class="gi">+        data = self.plot_data</span>
<span class="gi">+</span>
<span class="gi">+        # Set up the scatter plot parameters</span>
<span class="gi">+        scatter_kws = dict(</span>
<span class="gi">+            c=self.colors,</span>
<span class="gi">+            s=self.sizes,</span>
<span class="gi">+            marker=self.markers[0],</span>
<span class="gi">+            alpha=kws.pop(&quot;alpha&quot;, 0.8),</span>
<span class="gi">+        )</span>
<span class="gi">+        scatter_kws.update(kws)</span>
<span class="gi">+</span>
<span class="gi">+        # Draw the scatter plot</span>
<span class="gi">+        points = ax.scatter(data[self.x_label], data[self.y_label], **scatter_kws)</span>
<span class="gi">+</span>
<span class="gi">+        # Set the axis labels</span>
<span class="gi">+        ax.set_xlabel(self.x_label)</span>
<span class="gi">+        ax.set_ylabel(self.y_label)</span>
<span class="gi">+</span>
<span class="gi">+        # Handle the legend</span>
<span class="gi">+        if self.legend:</span>
<span class="gi">+            self._add_legend(ax, points)</span>
<span class="gi">+</span>
<span class="gi">+        return ax</span>
<span class="gi">+</span>
<span class="gi">+    def _add_legend(self, ax, points):</span>
<span class="gi">+        &quot;&quot;&quot;Add a legend to the plot.&quot;&quot;&quot;</span>
<span class="gi">+        handles, labels = [], []</span>
<span class="gi">+        for level in self.hue_levels:</span>
<span class="gi">+            handle = _scatter_legend_artist(</span>
<span class="gi">+                points,</span>
<span class="gi">+                c=self.colors[level],</span>
<span class="gi">+                s=self.sizes[level],</span>
<span class="gi">+                marker=self.markers[level],</span>
<span class="gi">+            )</span>
<span class="gi">+            handles.append(handle)</span>
<span class="gi">+            labels.append(level)</span>
<span class="gi">+</span>
<span class="gi">+        ax.legend(handles, labels, title=self.hue_label)</span>
<span class="gi">+</span>

<span class="w"> </span>lineplot.__doc__ = (
<span class="w"> </span>    &quot;&quot;&quot;Draw a line plot with possibility of several semantic groupings.
<span class="gh">diff --git a/seaborn/utils.py b/seaborn/utils.py</span>
<span class="gh">index ba736ec6..6e1c3b2b 100644</span>
<span class="gd">--- a/seaborn/utils.py</span>
<span class="gi">+++ b/seaborn/utils.py</span>
<span class="gu">@@ -39,17 +39,34 @@ def ci_to_errsize(cis, heights):</span>
<span class="w"> </span>        format as argument for plt.bar

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cis = np.asarray(cis)</span>
<span class="gi">+    heights = np.asarray(heights)</span>
<span class="gi">+    errsize = []</span>
<span class="gi">+    for i in range(len(heights)):</span>
<span class="gi">+        low, high = cis[:, i]</span>
<span class="gi">+        errsize.append([heights[i] - low, high - heights[i]])</span>
<span class="gi">+    return np.array(errsize).T</span>


<span class="w"> </span>def _draw_figure(fig):
<span class="w"> </span>    &quot;&quot;&quot;Force draw of a matplotlib figure, accounting for back-compat.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fig.canvas.draw()</span>
<span class="gi">+    if hasattr(fig.canvas, &quot;flush_events&quot;):</span>
<span class="gi">+        fig.canvas.flush_events()</span>


<span class="w"> </span>def _default_color(method, hue, color, kws, saturation=1):
<span class="w"> </span>    &quot;&quot;&quot;If needed, get a default color by using the matplotlib property cycle.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if color is not None:</span>
<span class="gi">+        return color</span>
<span class="gi">+    elif hue is not None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    else:</span>
<span class="gi">+        cycler = mpl.rcParams[&#39;axes.prop_cycle&#39;]</span>
<span class="gi">+        color = next(cycler)[&#39;color&#39;]</span>
<span class="gi">+        if saturation &lt; 1:</span>
<span class="gi">+            color = desaturate(color, saturation)</span>
<span class="gi">+        return color</span>


<span class="w"> </span>def desaturate(color, prop):
<span class="gu">@@ -68,7 +85,10 @@ def desaturate(color, prop):</span>
<span class="w"> </span>        desaturated color code in RGB tuple representation

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rgb = mpl.colors.colorConverter.to_rgb(color)</span>
<span class="gi">+    hsv = colorsys.rgb_to_hsv(*rgb)</span>
<span class="gi">+    hsv = (hsv[0], hsv[1] * prop, hsv[2])</span>
<span class="gi">+    return colorsys.hsv_to_rgb(*hsv)</span>


<span class="w"> </span>def saturate(color):
<span class="gu">@@ -85,7 +105,10 @@ def saturate(color):</span>
<span class="w"> </span>        saturated color code in RGB tuple representation

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rgb = mpl.colors.colorConverter.to_rgb(color)</span>
<span class="gi">+    hsv = colorsys.rgb_to_hsv(*rgb)</span>
<span class="gi">+    hsv = (hsv[0], 1.0, hsv[2])</span>
<span class="gi">+    return colorsys.hsv_to_rgb(*hsv)</span>


<span class="w"> </span>def set_hls_values(color, h=None, l=None, s=None):
<span class="gh">diff --git a/seaborn/widgets.py b/seaborn/widgets.py</span>
<span class="gh">index 3941f65b..14552573 100644</span>
<span class="gd">--- a/seaborn/widgets.py</span>
<span class="gi">+++ b/seaborn/widgets.py</span>
<span class="gu">@@ -12,17 +12,23 @@ __all__ = [&#39;choose_colorbrewer_palette&#39;, &#39;choose_cubehelix_palette&#39;,</span>

<span class="w"> </span>def _init_mutable_colormap():
<span class="w"> </span>    &quot;&quot;&quot;Create a matplotlib colormap that will be updated by the widgets.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return LinearSegmentedColormap.from_list(&quot;interactive&quot;, [&quot;#FFFFFF&quot;, &quot;#000000&quot;], N=256)</span>


<span class="w"> </span>def _update_lut(cmap, colors):
<span class="w"> </span>    &quot;&quot;&quot;Change the LUT values in a matplotlib colormap in-place.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cmap._lut[:len(colors)] = colors</span>
<span class="gi">+    cmap._lut[len(colors):] = 0</span>
<span class="gi">+    cmap._init()</span>


<span class="w"> </span>def _show_cmap(cmap):
<span class="w"> </span>    &quot;&quot;&quot;Show a continuous matplotlib colormap.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fig, ax = plt.subplots(figsize=(12, 0.5))</span>
<span class="gi">+    gradient = np.linspace(0, 1, 256).reshape(1, -1)</span>
<span class="gi">+    ax.imshow(gradient, aspect=&#39;auto&#39;, cmap=cmap)</span>
<span class="gi">+    ax.set_axis_off()</span>
<span class="gi">+    plt.show()</span>


<span class="w"> </span>def choose_colorbrewer_palette(data_type, as_cmap=False):
<span class="gu">@@ -57,7 +63,24 @@ def choose_colorbrewer_palette(data_type, as_cmap=False):</span>


<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    data_type = data_type.lower()</span>
<span class="gi">+    if data_type.startswith(&quot;q&quot;):</span>
<span class="gi">+        palettes = [&quot;Set1&quot;, &quot;Set2&quot;, &quot;Set3&quot;, &quot;Paired&quot;, &quot;Accent&quot;, &quot;Pastel1&quot;, &quot;Pastel2&quot;, &quot;Dark2&quot;]</span>
<span class="gi">+    elif data_type.startswith(&quot;s&quot;):</span>
<span class="gi">+        palettes = [&quot;Blues&quot;, &quot;Greens&quot;, &quot;Reds&quot;, &quot;Oranges&quot;, &quot;Purples&quot;, &quot;Greys&quot;]</span>
<span class="gi">+    elif data_type.startswith(&quot;d&quot;):</span>
<span class="gi">+        palettes = [&quot;RdBu&quot;, &quot;RdGy&quot;, &quot;PRGn&quot;, &quot;PiYG&quot;, &quot;BrBG&quot;, &quot;RdYlBu&quot;, &quot;RdYlGn&quot;]</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;data_type must be either &#39;sequential&#39;, &#39;diverging&#39; or &#39;qualitative&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def show_palette(palette_name):</span>
<span class="gi">+        pal = color_palette(palette_name)</span>
<span class="gi">+        if as_cmap:</span>
<span class="gi">+            pal = LinearSegmentedColormap.from_list(palette_name, pal)</span>
<span class="gi">+        palplot(pal)</span>
<span class="gi">+        return pal</span>
<span class="gi">+</span>
<span class="gi">+    return interact(show_palette, palette_name=palettes)</span>


<span class="w"> </span>def choose_dark_palette(input=&#39;husl&#39;, as_cmap=False):
<span class="gu">@@ -91,7 +114,19 @@ def choose_dark_palette(input=&#39;husl&#39;, as_cmap=False):</span>
<span class="w"> </span>                        cubehelix system.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def show_dark_palette(color, n_colors, reverse):</span>
<span class="gi">+        pal = dark_palette(color, n_colors, reverse=reverse, input=input)</span>
<span class="gi">+        if as_cmap:</span>
<span class="gi">+            pal = LinearSegmentedColormap.from_list(&quot;dark&quot;, pal)</span>
<span class="gi">+        palplot(pal)</span>
<span class="gi">+        return pal</span>
<span class="gi">+</span>
<span class="gi">+    return interact(</span>
<span class="gi">+        show_dark_palette,</span>
<span class="gi">+        color=input,</span>
<span class="gi">+        n_colors=IntSlider(min=2, max=16, value=8),</span>
<span class="gi">+        reverse=False</span>
<span class="gi">+    )</span>


<span class="w"> </span>def choose_light_palette(input=&#39;husl&#39;, as_cmap=False):
<span class="gu">@@ -125,7 +160,19 @@ def choose_light_palette(input=&#39;husl&#39;, as_cmap=False):</span>
<span class="w"> </span>                        cubehelix system.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def show_light_palette(color, n_colors, reverse):</span>
<span class="gi">+        pal = light_palette(color, n_colors, reverse=reverse, input=input)</span>
<span class="gi">+        if as_cmap:</span>
<span class="gi">+            pal = LinearSegmentedColormap.from_list(&quot;light&quot;, pal)</span>
<span class="gi">+        palplot(pal)</span>
<span class="gi">+        return pal</span>
<span class="gi">+</span>
<span class="gi">+    return interact(</span>
<span class="gi">+        show_light_palette,</span>
<span class="gi">+        color=input,</span>
<span class="gi">+        n_colors=IntSlider(min=2, max=16, value=8),</span>
<span class="gi">+        reverse=False</span>
<span class="gi">+    )</span>


<span class="w"> </span>def choose_diverging_palette(as_cmap=False):
<span class="gu">@@ -156,7 +203,23 @@ def choose_diverging_palette(as_cmap=False):</span>
<span class="w"> </span>                                 colorbrewer set, including diverging palettes.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def show_diverging_palette(h_neg, h_pos, s, l, sep, n, center):</span>
<span class="gi">+        pal = diverging_palette(h_neg, h_pos, s=s, l=l, sep=sep, n=n, center=center)</span>
<span class="gi">+        if as_cmap:</span>
<span class="gi">+            pal = LinearSegmentedColormap.from_list(&quot;diverging&quot;, pal)</span>
<span class="gi">+        palplot(pal)</span>
<span class="gi">+        return pal</span>
<span class="gi">+</span>
<span class="gi">+    return interact(</span>
<span class="gi">+        show_diverging_palette,</span>
<span class="gi">+        h_neg=IntSlider(min=0, max=359, value=220),</span>
<span class="gi">+        h_pos=IntSlider(min=0, max=359, value=10),</span>
<span class="gi">+        s=IntSlider(min=0, max=99, value=75),</span>
<span class="gi">+        l=IntSlider(min=0, max=99, value=50),</span>
<span class="gi">+        sep=IntSlider(min=1, max=50, value=10),</span>
<span class="gi">+        n=IntSlider(min=2, max=16, value=8),</span>
<span class="gi">+        center=[&quot;light&quot;, &quot;dark&quot;]</span>
<span class="gi">+    )</span>


<span class="w"> </span>def choose_cubehelix_palette(as_cmap=False):
<span class="gu">@@ -187,4 +250,21 @@ def choose_cubehelix_palette(as_cmap=False):</span>
<span class="w"> </span>                        cubehelix system.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def show_cubehelix_palette(n_colors, start, rot, gamma, hue, dark, light, reverse):</span>
<span class="gi">+        pal = cubehelix_palette(n_colors, start, rot, gamma, hue, dark, light, reverse)</span>
<span class="gi">+        if as_cmap:</span>
<span class="gi">+            pal = LinearSegmentedColormap.from_list(&quot;cubehelix&quot;, pal)</span>
<span class="gi">+        palplot(pal)</span>
<span class="gi">+        return pal</span>
<span class="gi">+</span>
<span class="gi">+    return interact(</span>
<span class="gi">+        show_cubehelix_palette,</span>
<span class="gi">+        n_colors=IntSlider(min=2, max=16, value=8),</span>
<span class="gi">+        start=FloatSlider(min=0, max=3, value=0, step=0.1),</span>
<span class="gi">+        rot=FloatSlider(min=-1, max=1, value=0.4, step=0.05),</span>
<span class="gi">+        gamma=FloatSlider(min=0, max=5, value=1, step=0.05),</span>
<span class="gi">+        hue=FloatSlider(min=0, max=1, value=0.8, step=0.05),</span>
<span class="gi">+        dark=FloatSlider(min=0, max=1, value=0.15, step=0.05),</span>
<span class="gi">+        light=FloatSlider(min=0, max=1, value=0.85, step=0.05),</span>
<span class="gi">+        reverse=False</span>
<span class="gi">+    )</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>