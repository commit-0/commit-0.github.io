
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis openhands commit0 openhands more itertools - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#openhands-more-itertools" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis openhands commit0 openhands more itertools
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_morepychunkedteststest_strict_being_true_with_size_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ChunkedTests::test_strict_being_true_with_size_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_multi_prepend" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_multi_prepend
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_multi_prepend_peek" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_multi_prepend_peek
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_peek_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_peek_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_prepend" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_prepend
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_prepend_after_stop" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_prepend_after_stop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_prepend_indexing" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_prepend_indexing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_prepend_iterable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_prepend_iterable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_prepend_many" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_prepend_many
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_prepend_reversed" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_prepend_reversed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_prepend_slicing" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_prepend_slicing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_prepend_truthiness" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_prepend_truthiness
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_simple_peeking" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_simple_peeking
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_slicing" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_slicing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_slicing_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_slicing_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_slicing_reset" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_slicing_reset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypeekableteststest_truthiness" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PeekableTests::test_truthiness
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyconsumerteststest_consumer" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ConsumerTests::test_consumer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydistinctpermutationsteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DistinctPermutationsTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydistinctpermutationsteststest_r" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DistinctPermutationsTests::test_r
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydistinctpermutationsteststest_unhashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DistinctPermutationsTests::test_unhashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydistinctpermutationsteststest_unsortable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DistinctPermutationsTests::test_unsortable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydistinctpermutationsteststest_unsortable_r" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DistinctPermutationsTests::test_unsortable_r
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydistinctpermutationsteststest_unsorted_equivalent" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DistinctPermutationsTests::test_unsorted_equivalent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyilenteststest_ilen" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IlenTests::test_ilen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyminmaxteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MinMaxTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyminmaxteststest_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MinMaxTests::test_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyminmaxteststest_iterables" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MinMaxTests::test_iterables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyminmaxteststest_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MinMaxTests::test_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyminmaxteststest_unpacked" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MinMaxTests::test_unpacked
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepywithiterteststest_with_iter" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::WithIterTests::test_with_iter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyoneteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::OneTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyoneteststest_too_long" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::OneTests::test_too_long
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyoneteststest_too_long_default_message" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::OneTests::test_too_long_default_message
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyoneteststest_too_short" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::OneTests::test_too_short
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterspersetesttest_even" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IntersperseTest::test_even
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterspersetesttest_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IntersperseTest::test_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterspersetesttest_n_zero" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IntersperseTest::test_n_zero
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterspersetesttest_nested" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IntersperseTest::test_nested
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterspersetesttest_not_iterable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IntersperseTest::test_not_iterable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterspersetesttest_odd" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IntersperseTest::test_odd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyuniquetoeachteststest_all_unique" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::UniqueToEachTests::test_all_unique
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyuniquetoeachteststest_duplicates" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::UniqueToEachTests::test_duplicates
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyuniquetoeachteststest_mixed" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::UniqueToEachTests::test_mixed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepywindowedteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::WindowedTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepywindowedteststest_empty_seq" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::WindowedTests::test_empty_seq
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepywindowedteststest_fillvalue" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::WindowedTests::test_fillvalue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepywindowedteststest_fillvalue_step" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::WindowedTests::test_fillvalue_step
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepywindowedteststest_invalid_step" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::WindowedTests::test_invalid_step
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepywindowedteststest_negative" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::WindowedTests::test_negative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepywindowedteststest_step" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::WindowedTests::test_step
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysubstringsteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SubstringsTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysubstringsteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SubstringsTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysubstringsteststest_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SubstringsTests::test_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysubstringsteststest_strings" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SubstringsTests::test_strings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysubstringsindexesteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SubstringsIndexesTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysubstringsindexesteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SubstringsIndexesTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysubstringsindexesteststest_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SubstringsIndexesTests::test_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysubstringsindexesteststest_reverse" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SubstringsIndexesTests::test_reverse
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysubstringsindexesteststest_strings" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SubstringsIndexesTests::test_strings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepybucketteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::BucketTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepybucketteststest_in" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::BucketTests::test_in
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepybucketteststest_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::BucketTests::test_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepybucketteststest_list_validator" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::BucketTests::test_list_validator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepybucketteststest_validator" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::BucketTests::test_validator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyspyteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SpyTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyspyteststest_immutable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SpyTests::test_immutable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyspyteststest_too_many" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SpyTests::test_too_many
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyspyteststest_unpacking" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SpyTests::test_unpacking
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyspyteststest_zero" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SpyTests::test_zero
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterleaveteststest_even" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::InterleaveTests::test_even
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterleaveteststest_mixed_types" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::InterleaveTests::test_mixed_types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterleaveteststest_short" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::InterleaveTests::test_short
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterleavelongestteststest_even" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::InterleaveLongestTests::test_even
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterleavelongestteststest_mixed_types" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::InterleaveLongestTests::test_mixed_types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterleavelongestteststest_short" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::InterleaveLongestTests::test_short
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterleaveevenlyteststest_argument_mismatch_raises" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::InterleaveEvenlyTests::test_argument_mismatch_raises
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterleaveevenlyteststest_degenerate_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::InterleaveEvenlyTests::test_degenerate_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterleaveevenlyteststest_degenerate_one" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::InterleaveEvenlyTests::test_degenerate_one
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterleaveevenlyteststest_equal_lengths" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::InterleaveEvenlyTests::test_equal_lengths
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterleaveevenlyteststest_manual_lengths" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::InterleaveEvenlyTests::test_manual_lengths
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterleaveevenlyteststest_many_iters" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::InterleaveEvenlyTests::test_many_iters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterleaveevenlyteststest_no_length_raises" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::InterleaveEvenlyTests::test_no_length_raises
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterleaveevenlyteststest_not_proportional" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::InterleaveEvenlyTests::test_not_proportional
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterleaveevenlyteststest_proportional" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::InterleaveEvenlyTests::test_proportional
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyinterleaveevenlyteststest_three_iters" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::InterleaveEvenlyTests::test_three_iters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepytestcollapsetest_collapse" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::TestCollapse::test_collapse
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepytestcollapsetest_collapse_flatten" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::TestCollapse::test_collapse_flatten
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepytestcollapsetest_collapse_to_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::TestCollapse::test_collapse_to_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepytestcollapsetest_collapse_to_level" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::TestCollapse::test_collapse_to_level
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepytestcollapsetest_collapse_to_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::TestCollapse::test_collapse_to_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepytestcollapsetest_collapse_to_string" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::TestCollapse::test_collapse_to_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysideeffectteststest_before_after" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SideEffectTests::test_before_after
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysideeffectteststest_before_fails" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SideEffectTests::test_before_fails
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysideeffectteststest_chunked" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SideEffectTests::test_chunked
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysideeffectteststest_individual" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SideEffectTests::test_individual
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyslicedteststest_even" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SlicedTests::test_even
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyslicedteststest_numpy_like_array" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SlicedTests::test_numpy_like_array
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyslicedteststest_odd" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SlicedTests::test_odd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyslicedteststest_odd_and_strict" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SlicedTests::test_odd_and_strict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitatteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitAtTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitatteststest_combination" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitAtTests::test_combination
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitatteststest_keep_separator" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitAtTests::test_keep_separator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitatteststest_maxsplit" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitAtTests::test_maxsplit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitbeforetesttest_empty_collection" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitBeforeTest::test_empty_collection
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitbeforetesttest_ends_with_sep" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitBeforeTest::test_ends_with_sep
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitbeforetesttest_max_split" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitBeforeTest::test_max_split
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitbeforetesttest_no_sep" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitBeforeTest::test_no_sep
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitbeforetesttest_starts_with_sep" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitBeforeTest::test_starts_with_sep
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitaftertesttest_ends_with_sep" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitAfterTest::test_ends_with_sep
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitaftertesttest_max_split" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitAfterTest::test_max_split
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitaftertesttest_no_sep" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitAfterTest::test_no_sep
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitaftertesttest_starts_with_sep" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitAfterTest::test_starts_with_sep
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitwhenteststest_after_emulation_ends_with_sep" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitWhenTests::test_after_emulation_ends_with_sep
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitwhenteststest_after_emulation_no_sep" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitWhenTests::test_after_emulation_no_sep
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitwhenteststest_after_emulation_starts_with_sep" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitWhenTests::test_after_emulation_starts_with_sep
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitwhenteststest_before_emulation_ends_with_sep" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitWhenTests::test_before_emulation_ends_with_sep
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitwhenteststest_before_emulation_no_sep" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitWhenTests::test_before_emulation_no_sep
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitwhenteststest_before_emulation_starts_with_sep" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitWhenTests::test_before_emulation_starts_with_sep
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitwhenteststest_empty_iterable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitWhenTests::test_empty_iterable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitwhenteststest_max_split" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitWhenTests::test_max_split
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitwhenteststest_one_element" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitWhenTests::test_one_element
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitwhenteststest_one_element_is_first_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitWhenTests::test_one_element_is_first_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitwhenteststest_one_element_is_second_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitWhenTests::test_one_element_is_second_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitintoteststest_bool_in_sizes" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitIntoTests::test_bool_in_sizes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitintoteststest_both_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitIntoTests::test_both_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitintoteststest_generator_iterable_integrity" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitIntoTests::test_generator_iterable_integrity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitintoteststest_generator_sizes_integrity" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitIntoTests::test_generator_sizes_integrity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitintoteststest_invalid_in_sizes" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitIntoTests::test_invalid_in_sizes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitintoteststest_invalid_in_sizes_after_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitIntoTests::test_invalid_in_sizes_after_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitintoteststest_iterable_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitIntoTests::test_iterable_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitintoteststest_iterable_empty_using_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitIntoTests::test_iterable_empty_using_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitintoteststest_iterable_just_right" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitIntoTests::test_iterable_just_right
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitintoteststest_iterable_too_large" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitIntoTests::test_iterable_too_large
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitintoteststest_iterable_too_small" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitIntoTests::test_iterable_too_small
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitintoteststest_iterable_too_small_extra" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitIntoTests::test_iterable_too_small_extra
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitintoteststest_sizes_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitIntoTests::test_sizes_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitintoteststest_using_none_mid_sizes" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitIntoTests::test_using_none_mid_sizes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitintoteststest_using_none_with_leftover" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitIntoTests::test_using_none_with_leftover
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysplitintoteststest_using_none_without_leftover" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SplitIntoTests::test_using_none_without_leftover
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypaddedtesttest_invalid_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PaddedTest::test_invalid_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypaddedtesttest_next_multiple" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PaddedTest::test_next_multiple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypaddedtesttest_no_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PaddedTest::test_no_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypaddedtesttest_valid_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PaddedTest::test_valid_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrepeateachteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RepeatEachTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrepeateachteststest_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RepeatEachTests::test_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrepeateachteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RepeatEachTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrepeateachteststest_infinite_input" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RepeatEachTests::test_infinite_input
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrepeateachteststest_negative_repeat" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RepeatEachTests::test_negative_repeat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrepeateachteststest_no_repeat" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RepeatEachTests::test_no_repeat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrepeatlastteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RepeatLastTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrepeatlastteststest_default_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RepeatLastTests::test_default_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrepeatlastteststest_empty_iterable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RepeatLastTests::test_empty_iterable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydistributetesttest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DistributeTest::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydistributetesttest_invalid_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DistributeTest::test_invalid_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydistributetesttest_large_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DistributeTest::test_large_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepystaggertesttest_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::StaggerTest::test_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepystaggertesttest_longest" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::StaggerTest::test_longest
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepystaggertesttest_offsets" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::StaggerTest::test_offsets
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyzipequaltesttest_deprecation" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ZipEqualTest::test_deprecation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyzipequaltesttest_equal" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ZipEqualTest::test_equal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyzipequaltesttest_unequal_lists" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ZipEqualTest::test_unequal_lists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyzipoffsettesttest_longest" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ZipOffsetTest::test_longest
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyzipoffsettesttest_mismatch" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ZipOffsetTest::test_mismatch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyzipoffsettesttest_shortest" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ZipOffsetTest::test_shortest
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyunzipteststest_empty_iterable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::UnzipTests::test_empty_iterable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyunzipteststest_improperly_zipped" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::UnzipTests::test_improperly_zipped
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyunzipteststest_increasingly_zipped" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::UnzipTests::test_increasingly_zipped
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyunzipteststest_length_one_iterable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::UnzipTests::test_length_one_iterable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyunzipteststest_normal_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::UnzipTests::test_normal_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysorttogethertesttest_invalid_key_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SortTogetherTest::test_invalid_key_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysorttogethertesttest_key_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SortTogetherTest::test_key_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysorttogethertesttest_key_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SortTogetherTest::test_key_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysorttogethertesttest_reverse" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SortTogetherTest::test_reverse
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysorttogethertesttest_strict" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SortTogetherTest::test_strict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysorttogethertesttest_uneven_iterables" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SortTogetherTest::test_uneven_iterables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydividetesttest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DivideTest::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydividetesttest_invalid_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DivideTest::test_invalid_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydividetesttest_large_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DivideTest::test_large_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepytestalwaysiterabletest_base_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::TestAlwaysIterable::test_base_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepytestalwaysiterabletest_generator" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::TestAlwaysIterable::test_generator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepytestalwaysiterabletest_iterables" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::TestAlwaysIterable::test_iterables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepytestalwaysiterabletest_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::TestAlwaysIterable::test_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepytestalwaysiterabletest_single" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::TestAlwaysIterable::test_single
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepytestalwaysiterabletest_strings" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::TestAlwaysIterable::test_strings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyadjacentteststest_call_once" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AdjacentTests::test_call_once
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyadjacentteststest_consecutive_true" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AdjacentTests::test_consecutive_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyadjacentteststest_distance" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AdjacentTests::test_distance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyadjacentteststest_empty_iterable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AdjacentTests::test_empty_iterable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyadjacentteststest_grouping" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AdjacentTests::test_grouping
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyadjacentteststest_large_distance" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AdjacentTests::test_large_distance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyadjacentteststest_length_one" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AdjacentTests::test_length_one
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyadjacentteststest_negative_distance" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AdjacentTests::test_negative_distance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyadjacentteststest_typical" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AdjacentTests::test_typical
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyadjacentteststest_zero_distance" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AdjacentTests::test_zero_distance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepygroupbytransformteststest_default_funcs" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::GroupByTransformTests::test_default_funcs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepygroupbytransformteststest_no_valuefunc" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::GroupByTransformTests::test_no_valuefunc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepygroupbytransformteststest_reducefunc" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::GroupByTransformTests::test_reducefunc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepygroupbytransformteststest_valuefunc" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::GroupByTransformTests::test_valuefunc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynumericrangeteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NumericRangeTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynumericrangeteststest_eq" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NumericRangeTests::test_eq
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynumericrangeteststest_get_item_by_index" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NumericRangeTests::test_get_item_by_index
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynumericrangeteststest_get_item_by_slice" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NumericRangeTests::test_get_item_by_slice
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynumericrangeteststest_hash" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NumericRangeTests::test_hash
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynumericrangeteststest_index" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NumericRangeTests::test_index
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynumericrangeteststest_iter_twice" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NumericRangeTests::test_iter_twice
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynumericrangeteststest_len" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NumericRangeTests::test_len
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynumericrangeteststest_pickle" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NumericRangeTests::test_pickle
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynumericrangeteststest_reversed" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NumericRangeTests::test_reversed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycountcycleteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CountCycleTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycountcycleteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CountCycleTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycountcycleteststest_negative" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CountCycleTests::test_negative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepymarkendsteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MarkEndsTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepylocateteststest_custom_pred" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::LocateTests::test_custom_pred
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepylocateteststest_default_pred" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::LocateTests::test_default_pred
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepylocateteststest_no_matches" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::LocateTests::test_no_matches
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepylocateteststest_window_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::LocateTests::test_window_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepylocateteststest_window_size_large" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::LocateTests::test_window_size_large
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepylocateteststest_window_size_zero" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::LocateTests::test_window_size_zero
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepystripfunctionteststest_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::StripFunctionTests::test_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepystripfunctionteststest_math" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::StripFunctionTests::test_math
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepystripfunctionteststest_not_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::StripFunctionTests::test_not_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyisliceextendedteststest_all" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IsliceExtendedTests::test_all
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyisliceextendedteststest_slicing" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IsliceExtendedTests::test_slicing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyisliceextendedteststest_slicing_extensive" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IsliceExtendedTests::test_slicing_extensive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyisliceextendedteststest_zero_step" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IsliceExtendedTests::test_zero_step
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyconsecutivegroupstesttest_custom_ordering" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ConsecutiveGroupsTest::test_custom_ordering
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyconsecutivegroupstesttest_exotic_ordering" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ConsecutiveGroupsTest::test_exotic_ordering
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyconsecutivegroupstesttest_numbers" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ConsecutiveGroupsTest::test_numbers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydifferencetesttest_custom" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DifferenceTest::test_custom
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydifferencetesttest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DifferenceTest::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydifferencetesttest_initial" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DifferenceTest::test_initial
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydifferencetesttest_normal" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DifferenceTest::test_normal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydifferencetesttest_one" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DifferenceTest::test_one
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydifferencetesttest_roundtrip" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DifferenceTest::test_roundtrip
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyseekabletesttest_elements" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SeekableTest::test_elements
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyseekabletesttest_exhaustion_reset" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SeekableTest::test_exhaustion_reset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyseekabletesttest_forward" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SeekableTest::test_forward
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyseekabletesttest_maxlen" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SeekableTest::test_maxlen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyseekabletesttest_maxlen_zero" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SeekableTest::test_maxlen_zero
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyseekabletesttest_partial_reset" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SeekableTest::test_partial_reset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyseekabletesttest_past_end" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SeekableTest::test_past_end
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyseekabletesttest_peek_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SeekableTest::test_peek_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyseekabletesttest_relative_seek" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SeekableTest::test_relative_seek
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyseekabletesttest_simple_peeking" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SeekableTest::test_simple_peeking
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyseekabletesttest_truthiness" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SeekableTest::test_truthiness
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrunlengthtesttest_decode" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RunLengthTest::test_decode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrunlengthtesttest_encode" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RunLengthTest::test_encode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyexactlynteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ExactlyNTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyexactlynteststest_true" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ExactlyNTests::test_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyalwaysreversibleteststest_nonseq_reversed" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AlwaysReversibleTests::test_nonseq_reversed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyalwaysreversibleteststest_regular_reversed" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AlwaysReversibleTests::test_regular_reversed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycircularshiftsteststest_duplicates" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CircularShiftsTests::test_duplicates
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycircularshiftsteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CircularShiftsTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycircularshiftsteststest_simple_circular_shifts" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CircularShiftsTests::test_simple_circular_shifts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycircularshiftsteststest_steps_negative" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CircularShiftsTests::test_steps_negative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycircularshiftsteststest_steps_positive" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CircularShiftsTests::test_steps_positive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycircularshiftsteststest_steps_zero" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CircularShiftsTests::test_steps_zero
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepymakedecoratorteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MakeDecoratorTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepymakedecoratorteststest_result_index" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MakeDecoratorTests::test_result_index
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepymakedecoratorteststest_wrap_class" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MakeDecoratorTests::test_wrap_class
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepymapreduceteststest_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MapReduceTests::test_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepymapreduceteststest_reducefunc" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MapReduceTests::test_reducefunc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepymapreduceteststest_ret" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MapReduceTests::test_ret
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepymapreduceteststest_valuefunc" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MapReduceTests::test_valuefunc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrlocateteststest_custom_pred" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RlocateTests::test_custom_pred
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrlocateteststest_default_pred" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RlocateTests::test_default_pred
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrlocateteststest_efficient_reversal" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RlocateTests::test_efficient_reversal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrlocateteststest_no_matches" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RlocateTests::test_no_matches
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrlocateteststest_window_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RlocateTests::test_window_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrlocateteststest_window_size_large" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RlocateTests::test_window_size_large
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyrlocateteststest_window_size_zero" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::RlocateTests::test_window_size_zero
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyreplaceteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ReplaceTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyreplaceteststest_count" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ReplaceTests::test_count
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyreplaceteststest_iterable_substitutes" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ReplaceTests::test_iterable_substitutes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyreplaceteststest_window_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ReplaceTests::test_window_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyreplaceteststest_window_size_count" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ReplaceTests::test_window_size_count
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyreplaceteststest_window_size_end" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ReplaceTests::test_window_size_end
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyreplaceteststest_window_size_large" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ReplaceTests::test_window_size_large
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyreplaceteststest_window_size_zero" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ReplaceTests::test_window_size_zero
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypartitionstesttest_duplicates" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PartitionsTest::test_duplicates
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypartitionstesttest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PartitionsTest::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypartitionstesttest_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PartitionsTest::test_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypartitionstesttest_types" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PartitionsTest::test_types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysetpartitionsteststest_duplicates" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SetPartitionsTests::test_duplicates
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysetpartitionsteststest_each_correct" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SetPartitionsTests::test_each_correct
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysetpartitionsteststest_found_all" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SetPartitionsTests::test_found_all
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysetpartitionsteststest_max_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SetPartitionsTests::test_max_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysetpartitionsteststest_min_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SetPartitionsTests::test_min_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysetpartitionsteststest_no_group" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SetPartitionsTests::test_no_group
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysetpartitionsteststest_repeated" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SetPartitionsTests::test_repeated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysetpartitionsteststest_stirling_numbers" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SetPartitionsTests::test_stirling_numbers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysetpartitionsteststest_to_many_groups" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SetPartitionsTests::test_to_many_groups
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyonlyteststest_custom_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::OnlyTests::test_custom_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyonlyteststest_custom_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::OnlyTests::test_custom_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyonlyteststest_default_exception_message" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::OnlyTests::test_default_exception_message
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyonlyteststest_defaults" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::OnlyTests::test_defaults
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyichunkedteststest_even" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IchunkedTests::test_even
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyichunkedteststest_laziness" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IchunkedTests::test_laziness
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyichunkedteststest_memory_in_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IchunkedTests::test_memory_in_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyichunkedteststest_negative" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IchunkedTests::test_negative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyichunkedteststest_odd" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IchunkedTests::test_odd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyichunkedteststest_out_of_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IchunkedTests::test_out_of_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyichunkedteststest_zero" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IchunkedTests::test_zero
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydistinctcombinationsteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DistinctCombinationsTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydistinctcombinationsteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DistinctCombinationsTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydistinctcombinationsteststest_negative" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DistinctCombinationsTests::test_negative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyfilterexceptteststest_false" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::FilterExceptTests::test_false
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyfilterexceptteststest_multiple" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::FilterExceptTests::test_multiple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyfilterexceptteststest_no_exceptions_pass" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::FilterExceptTests::test_no_exceptions_pass
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyfilterexceptteststest_no_exceptions_raise" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::FilterExceptTests::test_no_exceptions_raise
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepymapexceptteststest_multiple" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MapExceptTests::test_multiple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepymapexceptteststest_no_exceptions_pass" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MapExceptTests::test_no_exceptions_pass
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepymapexceptteststest_no_exceptions_raise" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MapExceptTests::test_no_exceptions_raise
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepymapifteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MapIfTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepymapifteststest_with_func_else" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MapIfTests::test_with_func_else
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepymapifteststest_without_func_else" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::MapIfTests::test_without_func_else
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysampleteststest_counts" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SampleTests::test_counts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysampleteststest_counts_all" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SampleTests::test_counts_all
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysampleteststest_invariance_under_permutations_unweighted" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SampleTests::test_invariance_under_permutations_unweighted
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysampleteststest_invariance_under_permutations_weighted" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SampleTests::test_invariance_under_permutations_weighted
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysampleteststest_length" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SampleTests::test_length
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysampleteststest_negative" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SampleTests::test_negative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysampleteststest_sampling_entire_iterable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SampleTests::test_sampling_entire_iterable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysampleteststest_strict" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SampleTests::test_strict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepysampleteststest_unit_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::SampleTests::test_unit_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyissortedteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IsSortedTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycallbackiterteststest_abort" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CallbackIterTests::test_abort
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycallbackiterteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CallbackIterTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycallbackiterteststest_callback_kwd" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CallbackIterTests::test_callback_kwd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycallbackiterteststest_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CallbackIterTests::test_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycallbackiterteststest_no_result" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CallbackIterTests::test_no_result
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycallbackiterteststest_partial_consumption" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CallbackIterTests::test_partial_consumption
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepywindowedcompleteteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::WindowedCompleteTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepywindowedcompleteteststest_every_partition" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::WindowedCompleteTests::test_every_partition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepywindowedcompleteteststest_wrong_length" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::WindowedCompleteTests::test_wrong_length
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepywindowedcompleteteststest_zero_length" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::WindowedCompleteTests::test_zero_length
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyalluniqueteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AllUniqueTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyalluniqueteststest_infinite" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AllUniqueTests::test_infinite
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyalluniqueteststest_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AllUniqueTests::test_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyalluniqueteststest_non_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AllUniqueTests::test_non_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyalluniqueteststest_partially_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::AllUniqueTests::test_partially_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynthproductteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NthProductTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynthproductteststest_invalid_index" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NthProductTests::test_invalid_index
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynthproductteststest_long" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NthProductTests::test_long
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynthproductteststest_negative" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NthProductTests::test_negative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynthcombinationwithreplacementteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NthCombinationWithReplacementTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynthcombinationwithreplacementteststest_invalid_index" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NthCombinationWithReplacementTests::test_invalid_index
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynthcombinationwithreplacementteststest_invalid_r" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NthCombinationWithReplacementTests::test_invalid_r
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepynthcombinationwithreplacementteststest_long" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::NthCombinationWithReplacementTests::test_long
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyvaluechainteststest_complex" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ValueChainTests::test_complex
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyvaluechainteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ValueChainTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyvaluechainteststest_empty_lists" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ValueChainTests::test_empty_lists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyvaluechainteststest_more" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ValueChainTests::test_more
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyvaluechainteststest_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ValueChainTests::test_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyproductindexteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ProductIndexTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyproductindexteststest_invalid_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ProductIndexTests::test_invalid_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyproductindexteststest_invalid_large" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ProductIndexTests::test_invalid_large
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyproductindexteststest_invalid_match" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ProductIndexTests::test_invalid_match
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyproductindexteststest_invalid_small" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ProductIndexTests::test_invalid_small
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyproductindexteststest_long" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ProductIndexTests::test_long
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyproductindexteststest_multiplicity" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ProductIndexTests::test_multiplicity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycombinationindexteststest_invalid_large" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CombinationIndexTests::test_invalid_large
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycombinationindexteststest_invalid_match" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CombinationIndexTests::test_invalid_match
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycombinationindexteststest_invalid_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CombinationIndexTests::test_invalid_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycombinationindexteststest_long" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CombinationIndexTests::test_long
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycombinationindexteststest_multiplicity" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CombinationIndexTests::test_multiplicity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycombinationindexteststest_null" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CombinationIndexTests::test_null
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycombinationindexteststest_r_equal_to_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CombinationIndexTests::test_r_equal_to_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycombinationindexteststest_r_less_than_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CombinationIndexTests::test_r_less_than_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycombinationwithreplacementindexteststest_invalid_large" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CombinationWithReplacementIndexTests::test_invalid_large
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycombinationwithreplacementindexteststest_invalid_match" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CombinationWithReplacementIndexTests::test_invalid_match
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycombinationwithreplacementindexteststest_invalid_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CombinationWithReplacementIndexTests::test_invalid_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycombinationwithreplacementindexteststest_long" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CombinationWithReplacementIndexTests::test_long
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycombinationwithreplacementindexteststest_multiplicity" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CombinationWithReplacementIndexTests::test_multiplicity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycombinationwithreplacementindexteststest_null" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CombinationWithReplacementIndexTests::test_null
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycombinationwithreplacementindexteststest_r_equal_to_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CombinationWithReplacementIndexTests::test_r_equal_to_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepycombinationwithreplacementindexteststest_r_less_than_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::CombinationWithReplacementIndexTests::test_r_less_than_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypermutationindexteststest_invalid_large" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PermutationIndexTests::test_invalid_large
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypermutationindexteststest_invalid_match" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PermutationIndexTests::test_invalid_match
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypermutationindexteststest_long" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PermutationIndexTests::test_long
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypermutationindexteststest_multiplicity" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PermutationIndexTests::test_multiplicity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypermutationindexteststest_null" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PermutationIndexTests::test_null
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypermutationindexteststest_r_equal_to_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PermutationIndexTests::test_r_equal_to_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypermutationindexteststest_r_less_than_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PermutationIndexTests::test_r_less_than_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepychunkedeventeststest_0" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ChunkedEvenTests::test_0
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepychunkedeventeststest_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ChunkedEvenTests::test_1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepychunkedeventeststest_4" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ChunkedEvenTests::test_4
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepychunkedeventeststest_5" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ChunkedEvenTests::test_5
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepychunkedeventeststest_6" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ChunkedEvenTests::test_6
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepychunkedeventeststest_7" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ChunkedEvenTests::test_7
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepychunkedeventeststest_evenness" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ChunkedEvenTests::test_evenness
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepychunkedeventeststest_infinite" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ChunkedEvenTests::test_infinite
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyzipbroadcastteststest_scalar_types" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ZipBroadcastTests::test_scalar_types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyzipbroadcastteststest_zip" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ZipBroadcastTests::test_zip
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyuniqueinwindowteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::UniqueInWindowTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyuniqueinwindowteststest_invalid_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::UniqueInWindowTests::test_invalid_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyuniqueinwindowteststest_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::UniqueInWindowTests::test_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepystrictlynteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::StrictlyNTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepystrictlynteststest_too_long_custom" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::StrictlyNTests::test_too_long_custom
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepystrictlynteststest_too_long_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::StrictlyNTests::test_too_long_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepystrictlynteststest_too_short_custom" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::StrictlyNTests::test_too_short_custom
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepystrictlynteststest_too_short_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::StrictlyNTests::test_too_short_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyduplicateseverseenteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DuplicatesEverSeenTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyduplicateseverseenteststest_key_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DuplicatesEverSeenTests::test_key_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyduplicateseverseenteststest_key_non_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DuplicatesEverSeenTests::test_key_non_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyduplicateseverseenteststest_key_partially_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DuplicatesEverSeenTests::test_key_partially_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyduplicateseverseenteststest_non_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DuplicatesEverSeenTests::test_non_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyduplicateseverseenteststest_partially_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DuplicatesEverSeenTests::test_partially_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyduplicatesjustseenteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DuplicatesJustSeenTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyduplicatesjustseenteststest_key_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DuplicatesJustSeenTests::test_key_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyduplicatesjustseenteststest_key_non_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DuplicatesJustSeenTests::test_key_non_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyduplicatesjustseenteststest_key_partially_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DuplicatesJustSeenTests::test_key_partially_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyduplicatesjustseenteststest_nested" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DuplicatesJustSeenTests::test_nested
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyduplicatesjustseenteststest_non_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DuplicatesJustSeenTests::test_non_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyduplicatesjustseenteststest_partially_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DuplicatesJustSeenTests::test_partially_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyclassifyuniqueteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ClassifyUniqueTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyclassifyuniqueteststest_key_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ClassifyUniqueTests::test_key_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyclassifyuniqueteststest_key_non_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ClassifyUniqueTests::test_key_non_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyclassifyuniqueteststest_key_partially_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ClassifyUniqueTests::test_key_partially_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyclassifyuniqueteststest_non_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ClassifyUniqueTests::test_non_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyclassifyuniqueteststest_partially_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ClassifyUniqueTests::test_partially_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyclassifyuniqueteststest_vs_duplicates_everseen" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ClassifyUniqueTests::test_vs_duplicates_everseen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyclassifyuniqueteststest_vs_duplicates_everseen_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ClassifyUniqueTests::test_vs_duplicates_everseen_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyclassifyuniqueteststest_vs_duplicates_justseen" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ClassifyUniqueTests::test_vs_duplicates_justseen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyclassifyuniqueteststest_vs_duplicates_justseen_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ClassifyUniqueTests::test_vs_duplicates_justseen_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyclassifyuniqueteststest_vs_unique_everseen" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ClassifyUniqueTests::test_vs_unique_everseen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyclassifyuniqueteststest_vs_unique_everseen_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ClassifyUniqueTests::test_vs_unique_everseen_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyclassifyuniqueteststest_vs_unique_justseen" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ClassifyUniqueTests::test_vs_unique_justseen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyclassifyuniqueteststest_vs_unique_justseen_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ClassifyUniqueTests::test_vs_unique_justseen_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepylongestcommonprefixteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::LongestCommonPrefixTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepylongestcommonprefixteststest_contains_infinite_iterables" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::LongestCommonPrefixTests::test_contains_infinite_iterables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepylongestcommonprefixteststest_empty_iterables_only" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::LongestCommonPrefixTests::test_empty_iterables_only
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepylongestcommonprefixteststest_includes_empty_iterables" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::LongestCommonPrefixTests::test_includes_empty_iterables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepylongestcommonprefixteststest_infinite_iterables" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::LongestCommonPrefixTests::test_infinite_iterables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepylongestcommonprefixteststest_iterators" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::LongestCommonPrefixTests::test_iterators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepylongestcommonprefixteststest_no_iterables" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::LongestCommonPrefixTests::test_no_iterables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepylongestcommonprefixteststest_non_hashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::LongestCommonPrefixTests::test_non_hashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepylongestcommonprefixteststest_prefix_contains_elements_of_the_first_iterable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::LongestCommonPrefixTests::test_prefix_contains_elements_of_the_first_iterable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyiequalsteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IequalsTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyiequalsteststest_empty_iterables" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IequalsTests::test_empty_iterables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyiequalsteststest_more_than_two_iterable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IequalsTests::test_more_than_two_iterable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyiequalsteststest_no_iterables" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IequalsTests::test_no_iterables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyiequalsteststest_one_iterable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IequalsTests::test_one_iterable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyconstrainedbatchesteststest_bad_max" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ConstrainedBatchesTests::test_bad_max
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyconstrainedbatchesteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ConstrainedBatchesTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyconstrainedbatchesteststest_get_len" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ConstrainedBatchesTests::test_get_len
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyconstrainedbatchesteststest_max_count" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ConstrainedBatchesTests::test_max_count
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyconstrainedbatchesteststest_strict" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::ConstrainedBatchesTests::test_strict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepygrayproductteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::GrayProductTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepygrayproductteststest_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::GrayProductTests::test_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepygrayproductteststest_vs_product" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::GrayProductTests::test_vs_product
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypartialproductteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PartialProductTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypartialproductteststest_empty_iterable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PartialProductTests::test_empty_iterable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypartialproductteststest_no_iterables" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PartialProductTests::test_no_iterables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypartialproductteststest_one_iterable" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PartialProductTests::test_one_iterable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypartialproductteststest_two_iterables" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PartialProductTests::test_two_iterables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypartialproductteststest_uneven_length_iterables" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PartialProductTests::test_uneven_length_iterables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyiterateteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IterateTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyiterateteststest_func_controls_iteration_stop" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IterateTests::test_func_controls_iteration_stop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepytakewhileinclusiveteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::TakewhileInclusiveTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepytakewhileinclusiveteststest_collatz_sequence" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::TakewhileInclusiveTests::test_collatz_sequence
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepytakewhileinclusiveteststest_empty_iterator" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::TakewhileInclusiveTests::test_empty_iterator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyouterproductteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::OuterProductTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyitersuppressteststest_early_suppression" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IterSuppressTests::test_early_suppression
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyitersuppressteststest_no_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IterSuppressTests::test_no_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyitersuppressteststest_raises_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IterSuppressTests::test_raises_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyitersuppressteststest_suppression" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::IterSuppressTests::test_suppression
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyfiltermapteststest_filter" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::FilterMapTests::test_filter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyfiltermapteststest_filter_map" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::FilterMapTests::test_filter_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyfiltermapteststest_map" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::FilterMapTests::test_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyfiltermapteststest_no_iterables" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::FilterMapTests::test_no_iterables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypowersetofsetsteststest_hash_count" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PowersetOfSetsTests::test_hash_count
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepypowersetofsetsteststest_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::PowersetOfSetsTests::test_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyjoinmappingteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::JoinMappingTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepyjoinmappingteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::JoinMappingTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydiscretefouriertransformteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DiscreteFourierTransformTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydiscretefouriertransformteststest_roundtrip" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DiscreteFourierTransformTests::test_roundtrip
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydoublestarmapteststest_adding" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DoubleStarMapTests::test_adding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydoublestarmapteststest_construction" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DoubleStarMapTests::test_construction
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydoublestarmapteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DoubleStarMapTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_morepydoublestarmapteststest_identity" class="md-nav__link">
    <span class="md-ellipsis">
      test_more.py::DoubleStarMapTests::test_identity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespytabulateteststest_count" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::TabulateTests::test_count
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespytabulateteststest_simple_tabulate" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::TabulateTests::test_simple_tabulate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespytailteststest_iterator_equal" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::TailTests::test_iterator_equal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespytailteststest_iterator_greater" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::TailTests::test_iterator_greater
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespytailteststest_iterator_less" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::TailTests::test_iterator_less
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespytailteststest_sized_equal" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::TailTests::test_sized_equal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespytailteststest_sized_greater" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::TailTests::test_sized_greater
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespytailteststest_sized_less" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::TailTests::test_sized_less
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyconsumeteststest_negative_consume" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::ConsumeTests::test_negative_consume
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyconsumeteststest_sanity" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::ConsumeTests::test_sanity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyconsumeteststest_total_consume" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::ConsumeTests::test_total_consume
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespynthteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::NthTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespynthteststest_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::NthTests::test_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespynthteststest_negative_item_raises" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::NthTests::test_negative_item_raises
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyallequalteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::AllEqualTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyallequalteststest_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::AllEqualTests::test_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyallequalteststest_one" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::AllEqualTests::test_one
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyallequalteststest_tricky" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::AllEqualTests::test_tricky
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyallequalteststest_true" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::AllEqualTests::test_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyquantifyteststest_custom_predicate" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::QuantifyTests::test_custom_predicate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyquantifyteststest_happy_path" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::QuantifyTests::test_happy_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespypadnoneteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::PadnoneTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyncyclesteststest_happy_path" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::NcyclesTests::test_happy_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyncyclesteststest_null_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::NcyclesTests::test_null_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyncyclesteststest_pathological_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::NcyclesTests::test_pathological_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespydotproductteststest_happy_path" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::DotproductTests::test_happy_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyflattenteststest_basic_usage" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::FlattenTests::test_basic_usage
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyflattenteststest_single_level" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::FlattenTests::test_single_level
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyrepeatfuncteststest_added_arguments" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::RepeatfuncTests::test_added_arguments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyrepeatfuncteststest_finite_repeat" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::RepeatfuncTests::test_finite_repeat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyrepeatfuncteststest_null_times" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::RepeatfuncTests::test_null_times
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyrepeatfuncteststest_simple_repeat" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::RepeatfuncTests::test_simple_repeat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespygrouperteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::GrouperTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespygrouperteststest_fill" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::GrouperTests::test_fill
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespygrouperteststest_ignore" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::GrouperTests::test_ignore
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespygrouperteststest_invalid_incomplete" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::GrouperTests::test_invalid_incomplete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespygrouperteststest_strict" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::GrouperTests::test_strict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespygrouperteststest_strict_fails" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::GrouperTests::test_strict_fails
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyroundrobinteststest_even_groups" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::RoundrobinTests::test_even_groups
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyroundrobinteststest_uneven_groups" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::RoundrobinTests::test_uneven_groups
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespypartitionteststest_arbitrary" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::PartitionTests::test_arbitrary
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespypartitionteststest_bool" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::PartitionTests::test_bool
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespypartitionteststest_pred_is_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::PartitionTests::test_pred_is_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespypowersetteststest_combinatorics" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::PowersetTests::test_combinatorics
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyuniqueeverseenteststest_custom_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::UniqueEverseenTests::test_custom_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyuniqueeverseenteststest_everseen" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::UniqueEverseenTests::test_everseen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyuniqueeverseenteststest_unhashable" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::UniqueEverseenTests::test_unhashable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyuniqueeverseenteststest_unhashable_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::UniqueEverseenTests::test_unhashable_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyuniquejustseenteststest_custom_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::UniqueJustseenTests::test_custom_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyuniquejustseenteststest_justseen" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::UniqueJustseenTests::test_justseen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyuniqueteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::UniqueTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyuniqueteststest_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::UniqueTests::test_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyuniqueteststest_reverse" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::UniqueTests::test_reverse
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyiterexceptteststest_exact_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::IterExceptTests::test_exact_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyiterexceptteststest_first" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::IterExceptTests::test_first
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyiterexceptteststest_generic_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::IterExceptTests::test_generic_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyiterexceptteststest_multiple" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::IterExceptTests::test_multiple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyiterexceptteststest_uncaught_exception_is_raised" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::IterExceptTests::test_uncaught_exception_is_raised
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyfirsttrueteststest_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::FirstTrueTests::test_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyfirsttrueteststest_pred" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::FirstTrueTests::test_pred
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyfirsttrueteststest_something_true" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::FirstTrueTests::test_something_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyrandomproductteststest_list_with_repeat" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::RandomProductTests::test_list_with_repeat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyrandomproductteststest_simple_lists" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::RandomProductTests::test_simple_lists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyrandompermutationteststest_full_permutation" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::RandomPermutationTests::test_full_permutation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyrandompermutationteststest_partial_permutation" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::RandomPermutationTests::test_partial_permutation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyrandomcombinationteststest_no_replacement" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::RandomCombinationTests::test_no_replacement
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyrandomcombinationteststest_pseudorandomness" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::RandomCombinationTests::test_pseudorandomness
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyrandomcombinationwithreplacementteststest_pseudorandomness" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::RandomCombinationWithReplacementTests::test_pseudorandomness
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyrandomcombinationwithreplacementteststest_replacement" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::RandomCombinationWithReplacementTests::test_replacement
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespynthcombinationteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::NthCombinationTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespynthcombinationteststest_invalid_index" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::NthCombinationTests::test_invalid_index
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespynthcombinationteststest_invalid_r" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::NthCombinationTests::test_invalid_r
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespynthcombinationteststest_long" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::NthCombinationTests::test_long
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespynthpermutationteststest_invalid_index" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::NthPermutationTests::test_invalid_index
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespynthpermutationteststest_invalid_r" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::NthPermutationTests::test_invalid_r
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespynthpermutationteststest_negative_index" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::NthPermutationTests::test_negative_index
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespynthpermutationteststest_null" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::NthPermutationTests::test_null
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespynthpermutationteststest_r_equal_to_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::NthPermutationTests::test_r_equal_to_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespynthpermutationteststest_r_less_than_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::NthPermutationTests::test_r_less_than_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyprependteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::PrependTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyprependteststest_multiple" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::PrependTests::test_multiple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyconvolveteststest_derivative" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::Convolvetests::test_derivative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyconvolveteststest_infinite_signal" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::Convolvetests::test_infinite_signal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyconvolveteststest_moving_average" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::Convolvetests::test_moving_average
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespybeforeandafterteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::BeforeAndAfterTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespybeforeandafterteststest_nested_remainder" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::BeforeAndAfterTests::test_nested_remainder
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespybeforeandafterteststest_never_false" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::BeforeAndAfterTests::test_never_false
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespybeforeandafterteststest_never_true" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::BeforeAndAfterTests::test_never_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespybeforeandafterteststest_some_true" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::BeforeAndAfterTests::test_some_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespytriplewiseteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::TriplewiseTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyslidingwindowteststest_deque_version" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::SlidingWindowTests::test_deque_version
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyslidingwindowteststest_islice_version" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::SlidingWindowTests::test_islice_version
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyslidingwindowteststest_zero" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::SlidingWindowTests::test_zero
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespysubslicesteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::SubslicesTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespypolynomialfromrootsteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::PolynomialFromRootsTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespypolynomialevalteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::PolynomialEvalTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyiterindexteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::IterIndexTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyiterindexteststest_start" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::IterIndexTests::test_start
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyiterindexteststest_stop" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::IterIndexTests::test_stop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespysieveteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::SieveTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespysieveteststest_prime_counts" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::SieveTests::test_prime_counts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespysieveteststest_small_numbers" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::SieveTests::test_small_numbers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespybatchedteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::BatchedTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespybatchedteststest_strict" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::BatchedTests::test_strict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespytransposeteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::TransposeTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespytransposeteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::TransposeTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespytransposeteststest_incompatible_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::TransposeTests::test_incompatible_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyreshapeteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::ReshapeTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyreshapeteststest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::ReshapeTests::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyreshapeteststest_zero" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::ReshapeTests::test_zero
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespymatmulteststest_m_by_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::MatMulTests::test_m_by_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespymatmulteststest_n_by_n" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::MatMulTests::test_n_by_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyfactorteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::FactorTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespyfactorteststest_cross_check" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::FactorTests::test_cross_check
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespysumofsquaresteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::SumOfSquaresTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespypolynomialderivativeteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::PolynomialDerivativeTests::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recipespytotientteststest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_recipes.py::TotientTests::test_basic
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_openhands-commit0_openhands">back to OpenHands summary</a></p>
<h1 id="openhands-more-itertools"><strong>OpenHands</strong>: more-itertools</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">62</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">600</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">663</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">663</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_morepychunkedteststest_strict_being_true_with_size_none">test_more.py::ChunkedTests::test_strict_being_true_with_size_none</h3>
<details><summary> <pre>test_more.py::ChunkedTests::test_strict_being_true_with_size_none</pre></summary><pre>
self = <tests.test_more.ChunkedTests testMethod=test_strict_being_true_with_size_none>

    def test_strict_being_true_with_size_none(self):
        """Test when ``n`` has value ``None`` and the keyword strict is True
        (raising an exception).

        """

        def f():
            return list(mi.chunked('ABCDE', None, strict=True))

>       self.assertRaisesRegex(
            ValueError, "n must not be None when using strict mode.", f
        )
E       AssertionError: ValueError not raised by f

tests/test_more.py:102: AssertionError
</pre>
</details>
<h3 id="test_morepypeekableteststest_empty">test_more.py::PeekableTests::test_empty</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_empty</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_empty>

    def test_empty(self):
        """Tests prepending in front of an empty iterable"""
        it = mi.peekable([])
        it.prepend(10)
        actual = list(it)
        expected = [10]
>       self.assertEqual(actual, expected)
E       AssertionError: Lists differ: [] != [10]
E       
E       Second list contains 1 additional elements.
E       First extra element 0:
E       10
E       
E       - []
E       + [10]

tests/test_more.py:356: AssertionError
</pre>
</details>
<h3 id="test_morepypeekableteststest_multi_prepend">test_more.py::PeekableTests::test_multi_prepend</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_multi_prepend</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_multi_prepend>

    def test_multi_prepend(self):
        """Tests prepending multiple items and getting them in proper order"""
        it = mi.peekable(range(5))
        actual = [next(it), next(it)]
        it.prepend(10, 11, 12)
        it.prepend(20, 21)
        actual += list(it)
        expected = [0, 1, 20, 21, 10, 11, 12, 2, 3, 4]
>       self.assertEqual(actual, expected)
E       AssertionError: Lists differ: [0, 1, 2, 3, 4] != [0, 1, 20, 21, 10, 11, 12, 2, 3, 4]
E       
E       First differing element 2:
E       2
E       20
E       
E       Second list contains 5 additional elements.
E       First extra element 5:
E       11
E       
E       - [0, 1, 2, 3, 4]
E       + [0, 1, 20, 21, 10, 11, 12, 2, 3, 4]

tests/test_more.py:348: AssertionError
</pre>
</details>
<h3 id="test_morepypeekableteststest_multi_prepend_peek">test_more.py::PeekableTests::test_multi_prepend_peek</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_multi_prepend_peek</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_multi_prepend_peek>

    def test_multi_prepend_peek(self):
        """Tests prepending multiple elements and getting them in reverse order
        while peeking"""
        it = mi.peekable(range(5))
        actual = [next(it), next(it)]
>       self.assertEqual(it.peek(), 2)
E       AssertionError: None != 2

tests/test_more.py:377: AssertionError
</pre>
</details>
<h3 id="test_morepypeekableteststest_peek_default">test_more.py::PeekableTests::test_peek_default</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_peek_default</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_peek_default>

    def test_peek_default(self):
        """Make sure passing a default into ``peek()`` works."""
        p = self.cls([])
>       self.assertEqual(p.peek(7), 7)
E       AssertionError: None != 7

tests/test_more.py:211: AssertionError
</pre>
</details>
<h3 id="test_morepypeekableteststest_prepend">test_more.py::PeekableTests::test_prepend</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_prepend</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_prepend>

    def test_prepend(self):
        """Tests interspersed ``prepend()`` and ``next()`` calls"""
        it = mi.peekable(range(2))
        actual = []

        # Test prepend() before next()
        it.prepend(10)
        actual += [next(it), next(it)]

        # Test prepend() between next()s
        it.prepend(11)
>       actual += [next(it), next(it)]

tests/test_more.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <more_itertools.more.peekable object at 0x7fdd543a79b0>

    def __next__(self):
        if self._cache:
            return self._cache.popleft()
>       return next(self._it)
E       StopIteration

more_itertools/more.py:332: StopIteration
</pre>
</details>
<h3 id="test_morepypeekableteststest_prepend_after_stop">test_more.py::PeekableTests::test_prepend_after_stop</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_prepend_after_stop</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_prepend_after_stop>

    def test_prepend_after_stop(self):
        """Test resuming iteration after a previous exhaustion"""
        it = mi.peekable(range(3))
        self.assertEqual(list(it), [0, 1, 2])
        self.assertRaises(StopIteration, lambda: next(it))
        it.prepend(10)
>       self.assertEqual(next(it), 10)

tests/test_more.py:393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <more_itertools.more.peekable object at 0x7fdd543a9910>

    def __next__(self):
        if self._cache:
            return self._cache.popleft()
>       return next(self._it)
E       StopIteration

more_itertools/more.py:332: StopIteration
</pre>
</details>
<h3 id="test_morepypeekableteststest_prepend_indexing">test_more.py::PeekableTests::test_prepend_indexing</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_prepend_indexing</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_prepend_indexing>

    def test_prepend_indexing(self):
        """Tests interaction between prepending and indexing"""
        seq = list(range(20))
        p = mi.peekable(seq)

        p.prepend(30, 40, 50)

>       self.assertEqual(p[0], 30)
E       AssertionError: 0 != 30

tests/test_more.py:421: AssertionError
</pre>
</details>
<h3 id="test_morepypeekableteststest_prepend_iterable">test_more.py::PeekableTests::test_prepend_iterable</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_prepend_iterable</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_prepend_iterable>

    def test_prepend_iterable(self):
        """Tests prepending from an iterable"""
        it = mi.peekable(range(5))
        # Don't directly use the range() object to avoid any range-specific
        # optimizations
        it.prepend(*(x for x in range(5)))
        actual = list(it)
        expected = list(chain(range(5), range(5)))
>       self.assertEqual(actual, expected)
E       AssertionError: Lists differ: [0, 1, 2, 3, 4] != [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]
E       
E       Second list contains 5 additional elements.
E       First extra element 5:
E       0
E       
E       - [0, 1, 2, 3, 4]
E       + [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]

tests/test_more.py:441: AssertionError
</pre>
</details>
<h3 id="test_morepypeekableteststest_prepend_many">test_more.py::PeekableTests::test_prepend_many</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_prepend_many</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_prepend_many>

    def test_prepend_many(self):
        """Tests that prepending a huge number of elements works"""
        it = mi.peekable(range(5))
        # Don't directly use the range() object to avoid any range-specific
        # optimizations
        it.prepend(*(x for x in range(20000)))
        actual = list(it)
        expected = list(chain(range(20000), range(5)))
>       self.assertEqual(actual, expected)
E       AssertionError: Lists differ: [0, 1, 2, 3, 4] != [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, [128845 chars]3, 4]
E       
E       Second list contains 20000 additional elements.
E       First extra element 5:
E       5
E       
E       Diff is 188938 characters long. Set self.maxDiff to None to see it.

tests/test_more.py:451: AssertionError
</pre>
</details>
<h3 id="test_morepypeekableteststest_prepend_reversed">test_more.py::PeekableTests::test_prepend_reversed</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_prepend_reversed</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_prepend_reversed>

    def test_prepend_reversed(self):
        """Tests prepending from a reversed iterable"""
        it = mi.peekable(range(3))
        it.prepend(*reversed((10, 11, 12)))
        actual = list(it)
        expected = [12, 11, 10, 0, 1, 2]
>       self.assertEqual(actual, expected)
E       AssertionError: Lists differ: [0, 1, 2] != [12, 11, 10, 0, 1, 2]
E       
E       First differing element 0:
E       0
E       12
E       
E       Second list contains 3 additional elements.
E       First extra element 3:
E       0
E       
E       - [0, 1, 2]
E       + [12, 11, 10, 0, 1, 2]

tests/test_more.py:459: AssertionError
</pre>
</details>
<h3 id="test_morepypeekableteststest_prepend_slicing">test_more.py::PeekableTests::test_prepend_slicing</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_prepend_slicing</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_prepend_slicing>

    def test_prepend_slicing(self):
        """Tests interaction between prepending and slicing"""
        seq = list(range(20))
        p = mi.peekable(seq)

        p.prepend(30, 40, 50)
        pseq = [30, 40, 50] + seq  # pseq for prepended_seq

        # adapt the specific tests from test_slicing
>       self.assertEqual(p[0], 30)
E       AssertionError: 0 != 30

tests/test_more.py:405: AssertionError
</pre>
</details>
<h3 id="test_morepypeekableteststest_prepend_truthiness">test_more.py::PeekableTests::test_prepend_truthiness</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_prepend_truthiness</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_prepend_truthiness>

    def test_prepend_truthiness(self):
        """Tests that ``__bool__()`` or ``__nonzero__()`` works properly
        with ``prepend()``"""
        it = mi.peekable(range(5))
        self.assertTrue(it)
        actual = list(it)
>       self.assertFalse(it)
E       AssertionError: <more_itertools.more.peekable object at 0x7fdd54792b70> is not false

tests/test_more.py:364: AssertionError
</pre>
</details>
<h3 id="test_morepypeekableteststest_simple_peeking">test_more.py::PeekableTests::test_simple_peeking</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_simple_peeking</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_simple_peeking>

    def test_simple_peeking(self):
        """Make sure ``next`` and ``peek`` advance and don't advance the
        iterator, respectively.

        """
        p = self.cls(range(10))
        self.assertEqual(next(p), 0)
>       self.assertEqual(p.peek(), 1)
E       AssertionError: None != 1

tests/test_more.py:231: AssertionError
</pre>
</details>
<h3 id="test_morepypeekableteststest_slicing">test_more.py::PeekableTests::test_slicing</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_slicing</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_slicing>

    def test_slicing(self):
        """Slicing the peekable shouldn't advance the iterator."""
        seq = list('abcdefghijkl')
        p = mi.peekable(seq)

        # Slicing the peekable should just be like slicing a re-iterable
>       self.assertEqual(p[1:4], seq[1:4])

tests/test_more.py:271: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <more_itertools.more.peekable object at 0x7fdd543b78f0>
index = slice(1, 4, None)

    def __getitem__(self, index):
        if isinstance(index, slice):
>           return self._get_slice(index)
E           AttributeError: 'peekable' object has no attribute '_get_slice'

more_itertools/more.py:336: AttributeError
</pre>
</details>
<h3 id="test_morepypeekableteststest_slicing_error">test_more.py::PeekableTests::test_slicing_error</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_slicing_error</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_slicing_error>

    def test_slicing_error(self):
        iterable = '01234567'
        p = mi.peekable(iter(iterable))

        # Prime the cache
        p.peek()
        old_cache = list(p._cache)

        # Illegal slice
        with self.assertRaises(ValueError):
>           p[1:-1:0]

tests/test_more.py:312: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def __getitem__(self, index):
        if isinstance(index, slice):
>           return self._get_slice(index)
E           AttributeError: 'peekable' object has no attribute '_get_slice'

more_itertools/more.py:336: AttributeError
</pre>
</details>
<h3 id="test_morepypeekableteststest_slicing_reset">test_more.py::PeekableTests::test_slicing_reset</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_slicing_reset</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_slicing_reset>

    def test_slicing_reset(self):
        """Test slicing on a fresh iterable each time"""
        iterable = ['0', '1', '2', '3', '4', '5']
        indexes = list(range(-4, len(iterable) + 4)) + [None]
        steps = [1, 2, 3, 4, -1, -2, -3, 4]
        for slice_args in product(indexes, indexes, steps):
            it = iter(iterable)
            p = mi.peekable(it)
            next(p)
            index = slice(*slice_args)
>           actual = p[index]

tests/test_more.py:298: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <more_itertools.more.peekable object at 0x7fdd543b7a70>
index = slice(-4, -4, 1)

    def __getitem__(self, index):
        if isinstance(index, slice):
>           return self._get_slice(index)
E           AttributeError: 'peekable' object has no attribute '_get_slice'

more_itertools/more.py:336: AttributeError
</pre>
</details>
<h3 id="test_morepypeekableteststest_truthiness">test_more.py::PeekableTests::test_truthiness</h3>
<details><summary> <pre>test_more.py::PeekableTests::test_truthiness</pre></summary><pre>
self = <tests.test_more.PeekableTests testMethod=test_truthiness>

    def test_truthiness(self):
        """Make sure a ``peekable`` tests true iff there are items remaining in
        the iterable.

        """
        p = self.cls([])
>       self.assertFalse(p)
E       AssertionError: <more_itertools.more.peekable object at 0x7fdd543b6870> is not false

tests/test_more.py:219: AssertionError
</pre>
</details>
<h3 id="test_morepyconsumerteststest_consumer">test_more.py::ConsumerTests::test_consumer</h3>
<details><summary> <pre>test_more.py::ConsumerTests::test_consumer</pre></summary><pre>
self = <tests.test_more.ConsumerTests testMethod=test_consumer>

    def test_consumer(self):
        @mi.consumer
        def eater():
            while True:
                x = yield  # noqa

>       e = eater()
E       TypeError: 'NoneType' object is not callable

tests/test_more.py:471: TypeError
</pre>
</details>
<h3 id="test_morepydistinctpermutationsteststest_basic">test_more.py::DistinctPermutationsTests::test_basic</h3>
<details><summary> <pre>test_more.py::DistinctPermutationsTests::test_basic</pre></summary><pre>
self = <tests.test_more.DistinctPermutationsTests testMethod=test_basic>

    def test_basic(self):
        iterable = ['z', 'a', 'a', 'q', 'q', 'q', 'y']
>       actual = list(mi.distinct_permutations(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:478: TypeError
</pre>
</details>
<h3 id="test_morepydistinctpermutationsteststest_r">test_more.py::DistinctPermutationsTests::test_r</h3>
<details><summary> <pre>test_more.py::DistinctPermutationsTests::test_r</pre></summary><pre>
self = <tests.test_more.DistinctPermutationsTests testMethod=test_r>

    def test_r(self):
        for iterable, r in (
            ('mississippi', 0),
            ('mississippi', 1),
            ('mississippi', 6),
            ('mississippi', 7),
            ('mississippi', 12),
            ([0, 1, 1, 0], 0),
            ([0, 1, 1, 0], 1),
            ([0, 1, 1, 0], 2),
            ([0, 1, 1, 0], 3),
            ([0, 1, 1, 0], 4),
            (['a'], 0),
            (['a'], 1),
            (['a'], 5),
            ([], 0),
            ([], 1),
            ([], 4),
        ):
            with self.subTest(iterable=iterable, r=r):
                expected = set(permutations(iterable, r))
>               actual = list(mi.distinct_permutations(iter(iterable), r))
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:503: TypeError
</pre>
</details>
<h3 id="test_morepydistinctpermutationsteststest_unhashable">test_more.py::DistinctPermutationsTests::test_unhashable</h3>
<details><summary> <pre>test_more.py::DistinctPermutationsTests::test_unhashable</pre></summary><pre>
self = <tests.test_more.DistinctPermutationsTests testMethod=test_unhashable>

    def test_unhashable(self):
        iterable = ([1], [1], 2)
>       actual = list(mi.distinct_permutations(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:528: TypeError
</pre>
</details>
<h3 id="test_morepydistinctpermutationsteststest_unsortable">test_more.py::DistinctPermutationsTests::test_unsortable</h3>
<details><summary> <pre>test_more.py::DistinctPermutationsTests::test_unsortable</pre></summary><pre>
self = <tests.test_more.DistinctPermutationsTests testMethod=test_unsortable>

    def test_unsortable(self):
        iterable = ['1', 2, 2, 3, 3, 3]
>       actual = list(mi.distinct_permutations(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:508: TypeError
</pre>
</details>
<h3 id="test_morepydistinctpermutationsteststest_unsortable_r">test_more.py::DistinctPermutationsTests::test_unsortable_r</h3>
<details><summary> <pre>test_more.py::DistinctPermutationsTests::test_unsortable_r</pre></summary><pre>
self = <tests.test_more.DistinctPermutationsTests testMethod=test_unsortable_r>

    def test_unsortable_r(self):
        iterable = ['1', 2, 2, 3, 3, 3]
        for r in range(len(iterable) + 1):
            with self.subTest(iterable=iterable, r=r):
>               actual = list(mi.distinct_permutations(iterable, r=r))
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:516: TypeError
</pre>
</details>
<h3 id="test_morepydistinctpermutationsteststest_unsorted_equivalent">test_more.py::DistinctPermutationsTests::test_unsorted_equivalent</h3>
<details><summary> <pre>test_more.py::DistinctPermutationsTests::test_unsorted_equivalent</pre></summary><pre>
self = <tests.test_more.DistinctPermutationsTests testMethod=test_unsorted_equivalent>

    def test_unsorted_equivalent(self):
        iterable = [1, True, '3']
>       actual = list(mi.distinct_permutations(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:522: TypeError
</pre>
</details>
<h3 id="test_morepyilenteststest_ilen">test_more.py::IlenTests::test_ilen</h3>
<details><summary> <pre>test_more.py::IlenTests::test_ilen</pre></summary><pre>
self = <tests.test_more.IlenTests testMethod=test_ilen>

    def test_ilen(self):
        """Sanity-checks for ``ilen()``."""
        # Non-empty
>       self.assertEqual(
            mi.ilen(filter(lambda x: x % 10 == 0, range(101))), 11
        )
E       AssertionError: None != 11

tests/test_more.py:537: AssertionError
</pre>
</details>
<h3 id="test_morepyminmaxteststest_basic">test_more.py::MinMaxTests::test_basic</h3>
<details><summary> <pre>test_more.py::MinMaxTests::test_basic</pre></summary><pre>
self = <tests.test_more.MinMaxTests testMethod=test_basic>

    def test_basic(self):
        for iterable, expected in (
            # easy case
            ([0, 1, 2, 3], (0, 3)),
            # min and max are not in the extremes + we have `int`s and `float`s
            ([3, 5.5, -1, 2], (-1, 5.5)),
            # unordered collection
            ({3, 5.5, -1, 2}, (-1, 5.5)),
            # with repetitions
            ([3, 5.5, float('-Inf'), 5.5], (float('-Inf'), 5.5)),
            # other collections
            ('banana', ('a', 'n')),
            ({0: 1, 2: 100, 1: 10}, (0, 2)),
            (range(3, 14), (3, 13)),
        ):
            with self.subTest(iterable=iterable, expected=expected):
                # check for expected results
>               self.assertTupleEqual(mi.minmax(iterable), expected)
E               AssertionError: First sequence is not a tuple: None

tests/test_more.py:566: AssertionError
</pre>
</details>
<h3 id="test_morepyminmaxteststest_default">test_more.py::MinMaxTests::test_default</h3>
<details><summary> <pre>test_more.py::MinMaxTests::test_default</pre></summary><pre>
self = <tests.test_more.MinMaxTests testMethod=test_default>

    def test_default(self):
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_more.py:595: AssertionError
</pre>
</details>
<h3 id="test_morepyminmaxteststest_iterables">test_more.py::MinMaxTests::test_iterables</h3>
<details><summary> <pre>test_more.py::MinMaxTests::test_iterables</pre></summary><pre>
self = <tests.test_more.MinMaxTests testMethod=test_iterables>

    def test_iterables(self):
>       self.assertTupleEqual(mi.minmax(x for x in [0, 1, 2, 3]), (0, 3))
E       AssertionError: First sequence is not a tuple: None

tests/test_more.py:577: AssertionError
</pre>
</details>
<h3 id="test_morepyminmaxteststest_key">test_more.py::MinMaxTests::test_key</h3>
<details><summary> <pre>test_more.py::MinMaxTests::test_key</pre></summary><pre>
self = <tests.test_more.MinMaxTests testMethod=test_key>

    def test_key(self):
>       self.assertTupleEqual(
            mi.minmax({(), (1, 4, 2), 'abcde', range(4)}, key=len),
            ((), 'abcde'),
        )
E       AssertionError: First sequence is not a tuple: None

tests/test_more.py:586: AssertionError
</pre>
</details>
<h3 id="test_morepyminmaxteststest_unpacked">test_more.py::MinMaxTests::test_unpacked</h3>
<details><summary> <pre>test_more.py::MinMaxTests::test_unpacked</pre></summary><pre>
self = <tests.test_more.MinMaxTests testMethod=test_unpacked>

    def test_unpacked(self):
>       self.assertTupleEqual(mi.minmax(2, 3, 1), (1, 3))
E       AssertionError: First sequence is not a tuple: None

tests/test_more.py:573: AssertionError
</pre>
</details>
<h3 id="test_morepywithiterteststest_with_iter">test_more.py::WithIterTests::test_with_iter</h3>
<details><summary> <pre>test_more.py::WithIterTests::test_with_iter</pre></summary><pre>
self = <tests.test_more.WithIterTests testMethod=test_with_iter>

    def test_with_iter(self):
        s = StringIO('One fish\nTwo fish')
>       initial_words = [line.split()[0] for line in mi.with_iter(s)]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:605: TypeError
</pre>
</details>
<h3 id="test_morepyoneteststest_basic">test_more.py::OneTests::test_basic</h3>
<details><summary> <pre>test_more.py::OneTests::test_basic</pre></summary><pre>
self = <tests.test_more.OneTests testMethod=test_basic>

    def test_basic(self):
        it = iter(['item'])
>       self.assertEqual(mi.one(it), 'item')
E       AssertionError: None != 'item'

tests/test_more.py:616: AssertionError
</pre>
</details>
<h3 id="test_morepyoneteststest_too_long">test_more.py::OneTests::test_too_long</h3>
<details><summary> <pre>test_more.py::OneTests::test_too_long</pre></summary><pre>
self = <tests.test_more.OneTests testMethod=test_too_long>

    def test_too_long(self):
        it = count()
>       self.assertRaises(ValueError, lambda: mi.one(it))  # burn 0 and 1
E       AssertionError: ValueError not raised by <lambda>

tests/test_more.py:639: AssertionError
</pre>
</details>
<h3 id="test_morepyoneteststest_too_long_default_message">test_more.py::OneTests::test_too_long_default_message</h3>
<details><summary> <pre>test_more.py::OneTests::test_too_long_default_message</pre></summary><pre>
self = <tests.test_more.OneTests testMethod=test_too_long_default_message>

    def test_too_long_default_message(self):
        it = count()
>       self.assertRaisesRegex(
            ValueError,
            "Expected exactly one item in "
            "iterable, but got 0, 1, and "
            "perhaps more.",
            lambda: mi.one(it),
        )
E       AssertionError: ValueError not raised by <lambda>

tests/test_more.py:647: AssertionError
</pre>
</details>
<h3 id="test_morepyoneteststest_too_short">test_more.py::OneTests::test_too_short</h3>
<details><summary> <pre>test_more.py::OneTests::test_too_short</pre></summary><pre>
self = <tests.test_more.OneTests testMethod=test_too_short>

    def test_too_short(self):
        it = iter([])
        for too_short, exc_type in [
            (None, ValueError),
            (IndexError, IndexError),
        ]:
            with self.subTest(too_short=too_short):
                try:
                    mi.one(it, too_short=too_short)
                except exc_type:
                    formatted_exc = format_exc()
                    self.assertIn('StopIteration', formatted_exc)
                    self.assertIn(
                        'The above exception was the direct cause',
                        formatted_exc,
                    )
                else:
>                   self.fail()
E                   AssertionError: None

tests/test_more.py:635: AssertionError
</pre>
</details>
<h3 id="test_morepyinterspersetesttest_even">test_more.py::IntersperseTest::test_even</h3>
<details><summary> <pre>test_more.py::IntersperseTest::test_even</pre></summary><pre>
self = <tests.test_more.IntersperseTest testMethod=test_even>

    def test_even(self):
        iterable = (x for x in '01')
        self.assertEqual(
>           list(mi.intersperse(None, iterable)), ['0', None, '1']
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:662: TypeError
</pre>
</details>
<h3 id="test_morepyinterspersetesttest_n">test_more.py::IntersperseTest::test_n</h3>
<details><summary> <pre>test_more.py::IntersperseTest::test_n</pre></summary><pre>
self = <tests.test_more.IntersperseTest testMethod=test_n>

    def test_n(self):
        for n, element, expected in [
            (1, '_', ['0', '_', '1', '_', '2', '_', '3', '_', '4', '_', '5']),
            (2, '_', ['0', '1', '_', '2', '3', '_', '4', '5']),
            (3, '_', ['0', '1', '2', '_', '3', '4', '5']),
            (4, '_', ['0', '1', '2', '3', '_', '4', '5']),
            (5, '_', ['0', '1', '2', '3', '4', '_', '5']),
            (6, '_', ['0', '1', '2', '3', '4', '5']),
            (7, '_', ['0', '1', '2', '3', '4', '5']),
            (3, ['a', 'b'], ['0', '1', '2', ['a', 'b'], '3', '4', '5']),
        ]:
            iterable = (x for x in '012345')
>           actual = list(mi.intersperse(element, iterable, n=n))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:693: TypeError
</pre>
</details>
<h3 id="test_morepyinterspersetesttest_n_zero">test_more.py::IntersperseTest::test_n_zero</h3>
<details><summary> <pre>test_more.py::IntersperseTest::test_n_zero</pre></summary><pre>
self = <tests.test_more.IntersperseTest testMethod=test_n_zero>

    def test_n_zero(self):
>       self.assertRaises(
            ValueError, lambda: list(mi.intersperse('x', '012', n=0))
        )

tests/test_more.py:697: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       ValueError, lambda: list(mi.intersperse('x', '012', n=0))
    )
E   TypeError: 'NoneType' object is not iterable

tests/test_more.py:698: TypeError
</pre>
</details>
<h3 id="test_morepyinterspersetesttest_nested">test_more.py::IntersperseTest::test_nested</h3>
<details><summary> <pre>test_more.py::IntersperseTest::test_nested</pre></summary><pre>
self = <tests.test_more.IntersperseTest testMethod=test_nested>

    def test_nested(self):
        element = ('a', 'b')
        iterable = (x for x in '012')
>       actual = list(mi.intersperse(element, iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:674: TypeError
</pre>
</details>
<h3 id="test_morepyinterspersetesttest_not_iterable">test_more.py::IntersperseTest::test_not_iterable</h3>
<details><summary> <pre>test_more.py::IntersperseTest::test_not_iterable</pre></summary><pre>
self = <tests.test_more.IntersperseTest testMethod=test_not_iterable>

    def test_not_iterable(self):
>       self.assertRaises(TypeError, lambda: mi.intersperse('x', 1))
E       AssertionError: TypeError not raised by <lambda>

tests/test_more.py:679: AssertionError
</pre>
</details>
<h3 id="test_morepyinterspersetesttest_odd">test_more.py::IntersperseTest::test_odd</h3>
<details><summary> <pre>test_more.py::IntersperseTest::test_odd</pre></summary><pre>
self = <tests.test_more.IntersperseTest testMethod=test_odd>

    def test_odd(self):
        iterable = (x for x in '012')
        self.assertEqual(
>           list(mi.intersperse(None, iterable)), ['0', None, '1', None, '2']
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:668: TypeError
</pre>
</details>
<h3 id="test_morepyuniquetoeachteststest_all_unique">test_more.py::UniqueToEachTests::test_all_unique</h3>
<details><summary> <pre>test_more.py::UniqueToEachTests::test_all_unique</pre></summary><pre>
self = <tests.test_more.UniqueToEachTests testMethod=test_all_unique>

    def test_all_unique(self):
        """When all the input iterables are unique the output should match
        the input."""
        iterables = [[1, 2], [3, 4, 5], [6, 7, 8]]
>       self.assertEqual(mi.unique_to_each(*iterables), iterables)
E       AssertionError: None != [[1, 2], [3, 4, 5], [6, 7, 8]]

tests/test_more.py:709: AssertionError
</pre>
</details>
<h3 id="test_morepyuniquetoeachteststest_duplicates">test_more.py::UniqueToEachTests::test_duplicates</h3>
<details><summary> <pre>test_more.py::UniqueToEachTests::test_duplicates</pre></summary><pre>
self = <tests.test_more.UniqueToEachTests testMethod=test_duplicates>

    def test_duplicates(self):
        """When there are duplicates in any of the input iterables that aren't
        in the rest, those duplicates should be emitted."""
        iterables = ["mississippi", "missouri"]
>       self.assertEqual(
            mi.unique_to_each(*iterables), [['p', 'p'], ['o', 'u', 'r']]
        )
E       AssertionError: None != [['p', 'p'], ['o', 'u', 'r']]

tests/test_more.py:715: AssertionError
</pre>
</details>
<h3 id="test_morepyuniquetoeachteststest_mixed">test_more.py::UniqueToEachTests::test_mixed</h3>
<details><summary> <pre>test_more.py::UniqueToEachTests::test_mixed</pre></summary><pre>
self = <tests.test_more.UniqueToEachTests testMethod=test_mixed>

    def test_mixed(self):
        """When the input iterables contain different types the function should
        still behave properly"""
        iterables = ['x', (i for i in range(3)), [1, 2, 3], tuple()]
>       self.assertEqual(mi.unique_to_each(*iterables), [['x'], [0], [3], []])
E       AssertionError: None != [['x'], [0], [3], []]

tests/test_more.py:723: AssertionError
</pre>
</details>
<h3 id="test_morepywindowedteststest_basic">test_more.py::WindowedTests::test_basic</h3>
<details><summary> <pre>test_more.py::WindowedTests::test_basic</pre></summary><pre>
self = <tests.test_more.WindowedTests testMethod=test_basic>

    def test_basic(self):
        iterable = [1, 2, 3, 4, 5]

        for n, expected in (
            (6, [(1, 2, 3, 4, 5, None)]),
            (5, [(1, 2, 3, 4, 5)]),
            (4, [(1, 2, 3, 4), (2, 3, 4, 5)]),
            (3, [(1, 2, 3), (2, 3, 4), (3, 4, 5)]),
            (2, [(1, 2), (2, 3), (3, 4), (4, 5)]),
            (1, [(1,), (2,), (3,), (4,), (5,)]),
            (0, [()]),
        ):
            with self.subTest(n=n):
>               actual = list(mi.windowed(iterable, n))
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:740: TypeError
</pre>
</details>
<h3 id="test_morepywindowedteststest_empty_seq">test_more.py::WindowedTests::test_empty_seq</h3>
<details><summary> <pre>test_more.py::WindowedTests::test_empty_seq</pre></summary><pre>
self = <tests.test_more.WindowedTests testMethod=test_empty_seq>

    def test_empty_seq(self):
>       actual = list(mi.windowed([], 3))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:778: TypeError
</pre>
</details>
<h3 id="test_morepywindowedteststest_fillvalue">test_more.py::WindowedTests::test_fillvalue</h3>
<details><summary> <pre>test_more.py::WindowedTests::test_fillvalue</pre></summary><pre>
self = <tests.test_more.WindowedTests testMethod=test_fillvalue>

    def test_fillvalue(self):
>       actual = list(mi.windowed([1, 2, 3, 4, 5], 6, fillvalue='!'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:744: TypeError
</pre>
</details>
<h3 id="test_morepywindowedteststest_fillvalue_step">test_more.py::WindowedTests::test_fillvalue_step</h3>
<details><summary> <pre>test_more.py::WindowedTests::test_fillvalue_step</pre></summary><pre>
self = <tests.test_more.WindowedTests testMethod=test_fillvalue_step>

    def test_fillvalue_step(self):
>       actual = list(mi.windowed([1, 2, 3, 4, 5], 3, fillvalue='!', step=3))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:769: TypeError
</pre>
</details>
<h3 id="test_morepywindowedteststest_invalid_step">test_more.py::WindowedTests::test_invalid_step</h3>
<details><summary> <pre>test_more.py::WindowedTests::test_invalid_step</pre></summary><pre>
self = <tests.test_more.WindowedTests testMethod=test_invalid_step>

    def test_invalid_step(self):
        # Step must be greater than or equal to 1
        with self.assertRaises(ValueError):
>           list(mi.windowed([1, 2, 3, 4, 5], 3, step=0))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:766: TypeError
</pre>
</details>
<h3 id="test_morepywindowedteststest_negative">test_more.py::WindowedTests::test_negative</h3>
<details><summary> <pre>test_more.py::WindowedTests::test_negative</pre></summary><pre>
self = <tests.test_more.WindowedTests testMethod=test_negative>

    def test_negative(self):
        with self.assertRaises(ValueError):
>           list(mi.windowed([1, 2, 3, 4, 5], -1))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:775: TypeError
</pre>
</details>
<h3 id="test_morepywindowedteststest_step">test_more.py::WindowedTests::test_step</h3>
<details><summary> <pre>test_more.py::WindowedTests::test_step</pre></summary><pre>
self = <tests.test_more.WindowedTests testMethod=test_step>

    def test_step(self):
        iterable = [1, 2, 3, 4, 5, 6, 7]
        for n, step, expected in [
            (3, 2, [(1, 2, 3), (3, 4, 5), (5, 6, 7)]),  # n > step
            (3, 3, [(1, 2, 3), (4, 5, 6), (7, None, None)]),  # n == step
            (3, 4, [(1, 2, 3), (5, 6, 7)]),  # lines up nicely
            (3, 5, [(1, 2, 3), (6, 7, None)]),  # off by one
            (3, 6, [(1, 2, 3), (7, None, None)]),  # off by two
            (3, 7, [(1, 2, 3)]),  # step past the end
            (7, 8, [(1, 2, 3, 4, 5, 6, 7)]),  # step > len(iterable)
        ]:
            with self.subTest(n=n, step=step):
>               actual = list(mi.windowed(iterable, n, step=step))
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:760: TypeError
</pre>
</details>
<h3 id="test_morepysubstringsteststest_basic">test_more.py::SubstringsTests::test_basic</h3>
<details><summary> <pre>test_more.py::SubstringsTests::test_basic</pre></summary><pre>
self = <tests.test_more.SubstringsTests testMethod=test_basic>

    def test_basic(self):
        iterable = (x for x in range(4))
>       actual = list(mi.substrings(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:786: TypeError
</pre>
</details>
<h3 id="test_morepysubstringsteststest_empty">test_more.py::SubstringsTests::test_empty</h3>
<details><summary> <pre>test_more.py::SubstringsTests::test_empty</pre></summary><pre>
self = <tests.test_more.SubstringsTests testMethod=test_empty>

    def test_empty(self):
        iterable = iter([])
>       actual = list(mi.substrings(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:816: TypeError
</pre>
</details>
<h3 id="test_morepysubstringsteststest_order">test_more.py::SubstringsTests::test_order</h3>
<details><summary> <pre>test_more.py::SubstringsTests::test_order</pre></summary><pre>
self = <tests.test_more.SubstringsTests testMethod=test_order>

    def test_order(self):
        iterable = [2, 0, 1]
>       actual = list(mi.substrings(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:822: TypeError
</pre>
</details>
<h3 id="test_morepysubstringsteststest_strings">test_more.py::SubstringsTests::test_strings</h3>
<details><summary> <pre>test_more.py::SubstringsTests::test_strings</pre></summary><pre>
self = <tests.test_more.SubstringsTests testMethod=test_strings>

    def test_strings(self):
        iterable = 'abc'
>       actual = list(mi.substrings(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:803: TypeError
</pre>
</details>
<h3 id="test_morepysubstringsindexesteststest_basic">test_more.py::SubstringsIndexesTests::test_basic</h3>
<details><summary> <pre>test_more.py::SubstringsIndexesTests::test_basic</pre></summary><pre>
self = <tests.test_more.SubstringsIndexesTests testMethod=test_basic>

    def test_basic(self):
        sequence = [x for x in range(4)]
>       actual = list(mi.substrings_indexes(sequence))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:830: TypeError
</pre>
</details>
<h3 id="test_morepysubstringsindexesteststest_empty">test_more.py::SubstringsIndexesTests::test_empty</h3>
<details><summary> <pre>test_more.py::SubstringsIndexesTests::test_empty</pre></summary><pre>
self = <tests.test_more.SubstringsIndexesTests testMethod=test_empty>

    def test_empty(self):
        sequence = []
>       actual = list(mi.substrings_indexes(sequence))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:860: TypeError
</pre>
</details>
<h3 id="test_morepysubstringsindexesteststest_order">test_more.py::SubstringsIndexesTests::test_order</h3>
<details><summary> <pre>test_more.py::SubstringsIndexesTests::test_order</pre></summary><pre>
self = <tests.test_more.SubstringsIndexesTests testMethod=test_order>

    def test_order(self):
        sequence = [2, 0, 1]
>       actual = list(mi.substrings_indexes(sequence))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:866: TypeError
</pre>
</details>
<h3 id="test_morepysubstringsindexesteststest_reverse">test_more.py::SubstringsIndexesTests::test_reverse</h3>
<details><summary> <pre>test_more.py::SubstringsIndexesTests::test_reverse</pre></summary><pre>
self = <tests.test_more.SubstringsIndexesTests testMethod=test_reverse>

    def test_reverse(self):
        sequence = [2, 0, 1]
>       actual = list(mi.substrings_indexes(sequence, reverse=True))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:879: TypeError
</pre>
</details>
<h3 id="test_morepysubstringsindexesteststest_strings">test_more.py::SubstringsIndexesTests::test_strings</h3>
<details><summary> <pre>test_more.py::SubstringsIndexesTests::test_strings</pre></summary><pre>
self = <tests.test_more.SubstringsIndexesTests testMethod=test_strings>

    def test_strings(self):
        sequence = 'abc'
>       actual = list(mi.substrings_indexes(sequence))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:847: TypeError
</pre>
</details>
<h3 id="test_morepybucketteststest_basic">test_more.py::BucketTests::test_basic</h3>
<details><summary> <pre>test_more.py::BucketTests::test_basic</pre></summary><pre>
self = <tests.test_more.BucketTests testMethod=test_basic>

    def test_basic(self):
        iterable = [10, 20, 30, 11, 21, 31, 12, 22, 23, 33]
        D = mi.bucket(iterable, key=lambda x: 10 * (x // 10))

        # In-order access
>       self.assertEqual(list(D[10]), [10, 11, 12])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:897: TypeError
</pre>
</details>
<h3 id="test_morepybucketteststest_in">test_more.py::BucketTests::test_in</h3>
<details><summary> <pre>test_more.py::BucketTests::test_in</pre></summary><pre>
self = <tests.test_more.BucketTests testMethod=test_in>

    def test_in(self):
        iterable = [10, 20, 30, 11, 21, 31, 12, 22, 23, 33]
        D = mi.bucket(iterable, key=lambda x: 10 * (x // 10))

>       self.assertIn(10, D)

tests/test_more.py:909: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <more_itertools.more.bucket object at 0x7fdd540ecf20>, value = 10

    def __contains__(self, value):
        if not self._validator(value):
            return False
        try:
>           item = next(self[value])
E           TypeError: 'NoneType' object is not an iterator

more_itertools/more.py:701: TypeError
</pre>
</details>
<h3 id="test_morepybucketteststest_list">test_more.py::BucketTests::test_list</h3>
<details><summary> <pre>test_more.py::BucketTests::test_list</pre></summary><pre>
self = <tests.test_more.BucketTests testMethod=test_list>

    def test_list(self):
        iterable = [10, 20, 30, 11, 21, 31, 12, 22, 23, 33]
        D = mi.bucket(iterable, key=lambda x: 10 * (x // 10))
>       self.assertEqual(list(D[10]), [10, 11, 12])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:930: TypeError
</pre>
</details>
<h3 id="test_morepybucketteststest_list_validator">test_more.py::BucketTests::test_list_validator</h3>
<details><summary> <pre>test_more.py::BucketTests::test_list_validator</pre></summary><pre>
self = <tests.test_more.BucketTests testMethod=test_list_validator>

    def test_list_validator(self):
        iterable = [10, 20, 30, 11, 21, 31, 12, 22, 23, 33]
        key = lambda x: 10 * (x // 10)
        validator = lambda x: x != 20
        D = mi.bucket(iterable, key, validator=validator)
        self.assertEqual(set(D), {10, 30})
>       self.assertEqual(list(D[10]), [10, 11, 12])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:941: TypeError
</pre>
</details>
<h3 id="test_morepybucketteststest_validator">test_more.py::BucketTests::test_validator</h3>
<details><summary> <pre>test_more.py::BucketTests::test_validator</pre></summary><pre>
self = <tests.test_more.BucketTests testMethod=test_validator>

    def test_validator(self):
        iterable = count(0)
        key = lambda x: int(str(x)[0])  # First digit of each number
        validator = lambda x: 0 < x < 10  # No leading zeros
        D = mi.bucket(iterable, key, validator=validator)
>       self.assertEqual(mi.take(3, D[1]), [1, 10, 11])

tests/test_more.py:922: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

n = 3, iterable = None

    def take(n, iterable):
        """Return first *n* items of the iterable as a list.

            >>> take(3, range(10))
            [0, 1, 2]

        If there are fewer than *n* items in the iterable, all of them are
        returned.

            >>> take(10, range(3))
            [0, 1, 2]

        """
>       return list(islice(iterable, n))
E       TypeError: 'NoneType' object is not iterable

more_itertools/recipes.py:71: TypeError
</pre>
</details>
<h3 id="test_morepyspyteststest_basic">test_more.py::SpyTests::test_basic</h3>
<details><summary> <pre>test_more.py::SpyTests::test_basic</pre></summary><pre>
self = <tests.test_more.SpyTests testMethod=test_basic>

    def test_basic(self):
        original_iterable = iter('abcdefg')
>       head, new_iterable = mi.spy(original_iterable)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_more.py:951: TypeError
</pre>
</details>
<h3 id="test_morepyspyteststest_immutable">test_more.py::SpyTests::test_immutable</h3>
<details><summary> <pre>test_more.py::SpyTests::test_immutable</pre></summary><pre>
self = <tests.test_more.SpyTests testMethod=test_immutable>

    def test_immutable(self):
        original_iterable = iter('abcdefg')
>       head, new_iterable = mi.spy(original_iterable, 3)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_more.py:981: TypeError
</pre>
</details>
<h3 id="test_morepyspyteststest_too_many">test_more.py::SpyTests::test_too_many</h3>
<details><summary> <pre>test_more.py::SpyTests::test_too_many</pre></summary><pre>
self = <tests.test_more.SpyTests testMethod=test_too_many>

    def test_too_many(self):
        original_iterable = iter('abc')
>       head, new_iterable = mi.spy(original_iterable, 4)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_more.py:969: TypeError
</pre>
</details>
<h3 id="test_morepyspyteststest_unpacking">test_more.py::SpyTests::test_unpacking</h3>
<details><summary> <pre>test_more.py::SpyTests::test_unpacking</pre></summary><pre>
self = <tests.test_more.SpyTests testMethod=test_unpacking>

    def test_unpacking(self):
        original_iterable = iter('abcdefg')
>       (first, second, third), new_iterable = mi.spy(original_iterable, 3)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_more.py:959: TypeError
</pre>
</details>
<h3 id="test_morepyspyteststest_zero">test_more.py::SpyTests::test_zero</h3>
<details><summary> <pre>test_more.py::SpyTests::test_zero</pre></summary><pre>
self = <tests.test_more.SpyTests testMethod=test_zero>

    def test_zero(self):
        original_iterable = iter('abc')
>       head, new_iterable = mi.spy(original_iterable, 0)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_more.py:975: TypeError
</pre>
</details>
<h3 id="test_morepyinterleaveteststest_even">test_more.py::InterleaveTests::test_even</h3>
<details><summary> <pre>test_more.py::InterleaveTests::test_even</pre></summary><pre>
self = <tests.test_more.InterleaveTests testMethod=test_even>

    def test_even(self):
>       actual = list(mi.interleave([1, 4, 7], [2, 5, 8], [3, 6, 9]))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:991: TypeError
</pre>
</details>
<h3 id="test_morepyinterleaveteststest_mixed_types">test_more.py::InterleaveTests::test_mixed_types</h3>
<details><summary> <pre>test_more.py::InterleaveTests::test_mixed_types</pre></summary><pre>
self = <tests.test_more.InterleaveTests testMethod=test_mixed_types>

    def test_mixed_types(self):
        it_list = ['a', 'b', 'c', 'd']
        it_str = '12345'
        it_inf = count()
>       actual = list(mi.interleave(it_list, it_str, it_inf))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1004: TypeError
</pre>
</details>
<h3 id="test_morepyinterleaveteststest_short">test_more.py::InterleaveTests::test_short</h3>
<details><summary> <pre>test_more.py::InterleaveTests::test_short</pre></summary><pre>
self = <tests.test_more.InterleaveTests testMethod=test_short>

    def test_short(self):
>       actual = list(mi.interleave([1, 4], [2, 5, 7], [3, 6, 8]))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:996: TypeError
</pre>
</details>
<h3 id="test_morepyinterleavelongestteststest_even">test_more.py::InterleaveLongestTests::test_even</h3>
<details><summary> <pre>test_more.py::InterleaveLongestTests::test_even</pre></summary><pre>
self = <tests.test_more.InterleaveLongestTests testMethod=test_even>

    def test_even(self):
>       actual = list(mi.interleave_longest([1, 4, 7], [2, 5, 8], [3, 6, 9]))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1011: TypeError
</pre>
</details>
<h3 id="test_morepyinterleavelongestteststest_mixed_types">test_more.py::InterleaveLongestTests::test_mixed_types</h3>
<details><summary> <pre>test_more.py::InterleaveLongestTests::test_mixed_types</pre></summary><pre>
self = <tests.test_more.InterleaveLongestTests testMethod=test_mixed_types>

    def test_mixed_types(self):
        it_list = ['a', 'b', 'c', 'd']
        it_str = '12345'
        it_gen = (x for x in range(3))
>       actual = list(mi.interleave_longest(it_list, it_str, it_gen))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1024: TypeError
</pre>
</details>
<h3 id="test_morepyinterleavelongestteststest_short">test_more.py::InterleaveLongestTests::test_short</h3>
<details><summary> <pre>test_more.py::InterleaveLongestTests::test_short</pre></summary><pre>
self = <tests.test_more.InterleaveLongestTests testMethod=test_short>

    def test_short(self):
>       actual = list(mi.interleave_longest([1, 4], [2, 5, 7], [3, 6, 8]))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1016: TypeError
</pre>
</details>
<h3 id="test_morepyinterleaveevenlyteststest_argument_mismatch_raises">test_more.py::InterleaveEvenlyTests::test_argument_mismatch_raises</h3>
<details><summary> <pre>test_more.py::InterleaveEvenlyTests::test_argument_mismatch_raises</pre></summary><pre>
self = <tests.test_more.InterleaveEvenlyTests testMethod=test_argument_mismatch_raises>

    def test_argument_mismatch_raises(self):
        # pass mismatching number of iterables and lengths
        iterables = [range(3)]
        lengths = [3, 4]
        with self.assertRaises(ValueError):
>           list(mi.interleave_evenly(iterables, lengths=lengths))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:1130: TypeError
</pre>
</details>
<h3 id="test_morepyinterleaveevenlyteststest_degenerate_empty">test_more.py::InterleaveEvenlyTests::test_degenerate_empty</h3>
<details><summary> <pre>test_more.py::InterleaveEvenlyTests::test_degenerate_empty</pre></summary><pre>
self = <tests.test_more.InterleaveEvenlyTests testMethod=test_degenerate_empty>

    def test_degenerate_empty(self):
        a = [1, 2, 3]
        b = []
        expected = [1, 2, 3]
>       actual = list(mi.interleave_evenly([a, b]))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1068: TypeError
</pre>
</details>
<h3 id="test_morepyinterleaveevenlyteststest_degenerate_one">test_more.py::InterleaveEvenlyTests::test_degenerate_one</h3>
<details><summary> <pre>test_more.py::InterleaveEvenlyTests::test_degenerate_one</pre></summary><pre>
self = <tests.test_more.InterleaveEvenlyTests testMethod=test_degenerate_one>

    def test_degenerate_one(self):
        a = [0, 1, 2, 3, 4]
        b = [5]
        expected = [0, 1, 2, 5, 3, 4]
>       actual = list(mi.interleave_evenly([a, b]))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1061: TypeError
</pre>
</details>
<h3 id="test_morepyinterleaveevenlyteststest_equal_lengths">test_more.py::InterleaveEvenlyTests::test_equal_lengths</h3>
<details><summary> <pre>test_more.py::InterleaveEvenlyTests::test_equal_lengths</pre></summary><pre>
self = <tests.test_more.InterleaveEvenlyTests testMethod=test_equal_lengths>

    def test_equal_lengths(self):
        # when lengths are equal, the relative order shouldn't change
        a = [1, 2, 3]
        b = [5, 6, 7]
>       actual = list(mi.interleave_evenly([a, b]))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1034: TypeError
</pre>
</details>
<h3 id="test_morepyinterleaveevenlyteststest_manual_lengths">test_more.py::InterleaveEvenlyTests::test_manual_lengths</h3>
<details><summary> <pre>test_more.py::InterleaveEvenlyTests::test_manual_lengths</pre></summary><pre>
self = <tests.test_more.InterleaveEvenlyTests testMethod=test_manual_lengths>

    def test_manual_lengths(self):
        a = combinations(range(4), 2)
        len_a = 4 * (4 - 1) // 2  # == 6
        b = combinations(range(4), 3)
        len_b = 4

        expected = [
            (0, 1),
            (0, 1, 2),
            (0, 2),
            (0, 3),
            (0, 1, 3),
            (1, 2),
            (0, 2, 3),
            (1, 3),
            (2, 3),
            (1, 2, 3),
        ]
>       actual = list(mi.interleave_evenly([a, b], lengths=[len_a, len_b]))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1116: TypeError
</pre>
</details>
<h3 id="test_morepyinterleaveevenlyteststest_many_iters">test_more.py::InterleaveEvenlyTests::test_many_iters</h3>
<details><summary> <pre>test_more.py::InterleaveEvenlyTests::test_many_iters</pre></summary><pre>
self = <tests.test_more.InterleaveEvenlyTests testMethod=test_many_iters>

    def test_many_iters(self):
        # smoke test with many iterables: create iterables with a random
        # number of elements starting with a character ("a0", "a1", ...)
        rng = Random(0)
        iterables = []
        for ch in ascii_letters:
            length = rng.randint(0, 100)
            iterable = [f"{ch}{i}" for i in range(length)]
            iterables.append(iterable)

>       interleaved = list(mi.interleave_evenly(iterables))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1089: TypeError
</pre>
</details>
<h3 id="test_morepyinterleaveevenlyteststest_no_length_raises">test_more.py::InterleaveEvenlyTests::test_no_length_raises</h3>
<details><summary> <pre>test_more.py::InterleaveEvenlyTests::test_no_length_raises</pre></summary><pre>
self = <tests.test_more.InterleaveEvenlyTests testMethod=test_no_length_raises>

    def test_no_length_raises(self):
        # combinations doesn't have __len__, should trigger ValueError
        iterables = [range(5), combinations(range(5), 2)]
        with self.assertRaises(ValueError):
>           list(mi.interleave_evenly(iterables))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:1123: TypeError
</pre>
</details>
<h3 id="test_morepyinterleaveevenlyteststest_not_proportional">test_more.py::InterleaveEvenlyTests::test_not_proportional</h3>
<details><summary> <pre>test_more.py::InterleaveEvenlyTests::test_not_proportional</pre></summary><pre>
self = <tests.test_more.InterleaveEvenlyTests testMethod=test_not_proportional>

    def test_not_proportional(self):
        a = [1, 2, 3, 4, 5, 6, 7]
        b = [8, 9, 10]
        expected = [1, 2, 8, 3, 4, 9, 5, 6, 10, 7]
>       actual = list(mi.interleave_evenly([a, b]))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1054: TypeError
</pre>
</details>
<h3 id="test_morepyinterleaveevenlyteststest_proportional">test_more.py::InterleaveEvenlyTests::test_proportional</h3>
<details><summary> <pre>test_more.py::InterleaveEvenlyTests::test_proportional</pre></summary><pre>
self = <tests.test_more.InterleaveEvenlyTests testMethod=test_proportional>

    def test_proportional(self):
        # easy case where the iterables have proportional length
        a = [1, 2, 3, 4]
        b = [5, 6]
>       actual = list(mi.interleave_evenly([a, b]))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1042: TypeError
</pre>
</details>
<h3 id="test_morepyinterleaveevenlyteststest_three_iters">test_more.py::InterleaveEvenlyTests::test_three_iters</h3>
<details><summary> <pre>test_more.py::InterleaveEvenlyTests::test_three_iters</pre></summary><pre>
self = <tests.test_more.InterleaveEvenlyTests testMethod=test_three_iters>

    def test_three_iters(self):
        a = ["a1", "a2", "a3", "a4", "a5"]
        b = ["b1", "b2", "b3"]
        c = ["c1"]
>       actual = list(mi.interleave_evenly([a, b, c]))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1075: TypeError
</pre>
</details>
<h3 id="test_morepytestcollapsetest_collapse">test_more.py::TestCollapse::test_collapse</h3>
<details><summary> <pre>test_more.py::TestCollapse::test_collapse</pre></summary><pre>
self = <tests.test_more.TestCollapse testMethod=test_collapse>

    def test_collapse(self):
        l = [[1], 2, [[3], 4], [[[5]]]]
>       self.assertEqual(list(mi.collapse(l)), [1, 2, 3, 4, 5])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1138: TypeError
</pre>
</details>
<h3 id="test_morepytestcollapsetest_collapse_flatten">test_more.py::TestCollapse::test_collapse_flatten</h3>
<details><summary> <pre>test_more.py::TestCollapse::test_collapse_flatten</pre></summary><pre>
self = <tests.test_more.TestCollapse testMethod=test_collapse_flatten>

    def test_collapse_flatten(self):
        l = [[1], [2], [[3], 4], [[[5]]]]
>       self.assertEqual(list(mi.collapse(l, levels=1)), list(mi.flatten(l)))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1152: TypeError
</pre>
</details>
<h3 id="test_morepytestcollapsetest_collapse_to_bytes">test_more.py::TestCollapse::test_collapse_to_bytes</h3>
<details><summary> <pre>test_more.py::TestCollapse::test_collapse_to_bytes</pre></summary><pre>
self = <tests.test_more.TestCollapse testMethod=test_collapse_to_bytes>

    def test_collapse_to_bytes(self):
        l = [[b"s1"], b"s2", [[b"s3"], b"s4"], [[[b"s5"]]]]
        self.assertEqual(
>           list(mi.collapse(l)), [b"s1", b"s2", b"s3", b"s4", b"s5"]
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1147: TypeError
</pre>
</details>
<h3 id="test_morepytestcollapsetest_collapse_to_level">test_more.py::TestCollapse::test_collapse_to_level</h3>
<details><summary> <pre>test_more.py::TestCollapse::test_collapse_to_level</pre></summary><pre>
self = <tests.test_more.TestCollapse testMethod=test_collapse_to_level>

    def test_collapse_to_level(self):
        l = [[1], 2, [[3], 4], [[[5]]]]
>       self.assertEqual(list(mi.collapse(l, levels=2)), [1, 2, 3, 4, [5]])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1156: TypeError
</pre>
</details>
<h3 id="test_morepytestcollapsetest_collapse_to_list">test_more.py::TestCollapse::test_collapse_to_list</h3>
<details><summary> <pre>test_more.py::TestCollapse::test_collapse_to_list</pre></summary><pre>
self = <tests.test_more.TestCollapse testMethod=test_collapse_to_list>

    def test_collapse_to_list(self):
        l = (1, [2], (3, [4, (5,)], 'ab'))
>       actual = list(mi.collapse(l, base_type=list))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1164: TypeError
</pre>
</details>
<h3 id="test_morepytestcollapsetest_collapse_to_string">test_more.py::TestCollapse::test_collapse_to_string</h3>
<details><summary> <pre>test_more.py::TestCollapse::test_collapse_to_string</pre></summary><pre>
self = <tests.test_more.TestCollapse testMethod=test_collapse_to_string>

    def test_collapse_to_string(self):
        l = [["s1"], "s2", [["s3"], "s4"], [[["s5"]]]]
>       self.assertEqual(list(mi.collapse(l)), ["s1", "s2", "s3", "s4", "s5"])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1142: TypeError
</pre>
</details>
<h3 id="test_morepysideeffectteststest_before_after">test_more.py::SideEffectTests::test_before_after</h3>
<details><summary> <pre>test_more.py::SideEffectTests::test_before_after</pre></summary><pre>
self = <tests.test_more.SideEffectTests testMethod=test_before_after>

    def test_before_after(self):
        f = StringIO()
        collector = []

        def func(item):
            print(item, file=f)
            collector.append(f.getvalue())

        def it():
            yield 'a'
            yield 'b'
            raise RuntimeError('kaboom')

        before = lambda: print('HEADER', file=f)
        after = f.close

        try:
            mi.consume(mi.side_effect(func, it(), before=before, after=after))
        except RuntimeError:
            pass

        # The iterable should have been written to the file
>       self.assertEqual(collector, ['HEADER\na\n', 'HEADER\na\nb\n'])
E       AssertionError: Lists differ: [] != ['HEADER\na\n', 'HEADER\na\nb\n']
E       
E       Second list contains 2 additional elements.
E       First extra element 0:
E       'HEADER\na\n'
E       
E       - []
E       + ['HEADER\na\n', 'HEADER\na\nb\n']

tests/test_more.py:1216: AssertionError
</pre>
</details>
<h3 id="test_morepysideeffectteststest_before_fails">test_more.py::SideEffectTests::test_before_fails</h3>
<details><summary> <pre>test_more.py::SideEffectTests::test_before_fails</pre></summary><pre>
self = <tests.test_more.SideEffectTests testMethod=test_before_fails>

    def test_before_fails(self):
        f = StringIO()
        func = lambda x: print(x, file=f)

        def before():
            raise RuntimeError('ouch')

        try:
            mi.consume(
                mi.side_effect(func, 'abc', before=before, after=f.close)
            )
        except RuntimeError:
            pass

        # The file should be closed even though something bad happened in the
        # before function
>       self.assertTrue(f.closed)
E       AssertionError: False is not true

tests/test_more.py:1237: AssertionError
</pre>
</details>
<h3 id="test_morepysideeffectteststest_chunked">test_more.py::SideEffectTests::test_chunked</h3>
<details><summary> <pre>test_more.py::SideEffectTests::test_chunked</pre></summary><pre>
self = <tests.test_more.SideEffectTests testMethod=test_chunked>

    def test_chunked(self):
        # The function increments the counter for each call
        counter = [0]

        def func(arg):
            counter[0] += 1

>       result = list(mi.side_effect(func, range(10), 2))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1190: TypeError
</pre>
</details>
<h3 id="test_morepysideeffectteststest_individual">test_more.py::SideEffectTests::test_individual</h3>
<details><summary> <pre>test_more.py::SideEffectTests::test_individual</pre></summary><pre>
self = <tests.test_more.SideEffectTests testMethod=test_individual>

    def test_individual(self):
        # The function increments the counter for each call
        counter = [0]

        def func(arg):
            counter[0] += 1

>       result = list(mi.side_effect(func, range(10)))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1179: TypeError
</pre>
</details>
<h3 id="test_morepyslicedteststest_even">test_more.py::SlicedTests::test_even</h3>
<details><summary> <pre>test_more.py::SlicedTests::test_even</pre></summary><pre>
self = <tests.test_more.SlicedTests testMethod=test_even>

    def test_even(self):
        """Test when the length of the sequence is divisible by *n*"""
        seq = 'ABCDEFGHI'
>       self.assertEqual(list(mi.sliced(seq, 3)), ['ABC', 'DEF', 'GHI'])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1246: TypeError
</pre>
</details>
<h3 id="test_morepyslicedteststest_numpy_like_array">test_more.py::SlicedTests::test_numpy_like_array</h3>
<details><summary> <pre>test_more.py::SlicedTests::test_numpy_like_array</pre></summary><pre>
self = <tests.test_more.SlicedTests testMethod=test_numpy_like_array>

    def test_numpy_like_array(self):
        # Numpy arrays don't behave like Python lists - calling bool()
        # on them doesn't return False for empty lists and True for non-empty
        # ones. Emulate that behavior.
        class FalseList(list):
            def __getitem__(self, key):
                ret = super().__getitem__(key)
                if isinstance(key, slice):
                    return FalseList(ret)

                return ret

            def __bool__(self):
                return False

        seq = FalseList(range(9))
>       actual = list(mi.sliced(seq, 3))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1281: TypeError
</pre>
</details>
<h3 id="test_morepyslicedteststest_odd">test_more.py::SlicedTests::test_odd</h3>
<details><summary> <pre>test_more.py::SlicedTests::test_odd</pre></summary><pre>
self = <tests.test_more.SlicedTests testMethod=test_odd>

    def test_odd(self):
        """Test when the length of the sequence is not divisible by *n*"""
        seq = 'ABCDEFGHI'
>       self.assertEqual(list(mi.sliced(seq, 4)), ['ABCD', 'EFGH', 'I'])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1251: TypeError
</pre>
</details>
<h3 id="test_morepyslicedteststest_odd_and_strict">test_more.py::SlicedTests::test_odd_and_strict</h3>
<details><summary> <pre>test_more.py::SlicedTests::test_odd_and_strict</pre></summary><pre>
self = <tests.test_more.SlicedTests testMethod=test_odd_and_strict>

    def test_odd_and_strict(self):
        seq = [x for x in 'ABCDEFGHI']

        with self.assertRaises(ValueError):
>           list(mi.sliced(seq, 4, strict=True))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:1263: TypeError
</pre>
</details>
<h3 id="test_morepysplitatteststest_basic">test_more.py::SplitAtTests::test_basic</h3>
<details><summary> <pre>test_more.py::SplitAtTests::test_basic</pre></summary><pre>
self = <tests.test_more.SplitAtTests testMethod=test_basic>

    def test_basic(self):
        for iterable, separator in [
            ('a,bb,ccc,dddd', ','),
            (',a,bb,ccc,dddd', ','),
            ('a,bb,ccc,dddd,', ','),
            ('a,bb,ccc,,dddd', ','),
            ('', ','),
            (',', ','),
            ('a,bb,ccc,dddd', ';'),
        ]:
            with self.subTest(iterable=iterable, separator=separator):
                it = iter(iterable)
                pred = lambda x: x == separator
>               actual = [''.join(x) for x in mi.split_at(it, pred)]
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:1300: TypeError
</pre>
</details>
<h3 id="test_morepysplitatteststest_combination">test_more.py::SplitAtTests::test_combination</h3>
<details><summary> <pre>test_more.py::SplitAtTests::test_combination</pre></summary><pre>
self = <tests.test_more.SplitAtTests testMethod=test_combination>

    def test_combination(self):
        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        pred = lambda x: x % 3 == 0
>       actual = list(
            mi.split_at(iterable, pred, maxsplit=2, keep_separator=True)
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1335: TypeError
</pre>
</details>
<h3 id="test_morepysplitatteststest_keep_separator">test_more.py::SplitAtTests::test_keep_separator</h3>
<details><summary> <pre>test_more.py::SplitAtTests::test_keep_separator</pre></summary><pre>
self = <tests.test_more.SplitAtTests testMethod=test_keep_separator>

    def test_keep_separator(self):
        separator = ','
        pred = lambda x: x == separator

        for iterable, expected in [
            ('a,bb,ccc', ['a', ',', 'bb', ',', 'ccc']),
            (',a,bb,ccc', ['', ',', 'a', ',', 'bb', ',', 'ccc']),
            ('a,bb,ccc,', ['a', ',', 'bb', ',', 'ccc', ',', '']),
        ]:
            with self.subTest(iterable=iterable):
                it = iter(iterable)
                result = mi.split_at(it, pred, keep_separator=True)
>               actual = [''.join(x) for x in result]
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:1329: TypeError
</pre>
</details>
<h3 id="test_morepysplitatteststest_maxsplit">test_more.py::SplitAtTests::test_maxsplit</h3>
<details><summary> <pre>test_more.py::SplitAtTests::test_maxsplit</pre></summary><pre>
self = <tests.test_more.SplitAtTests testMethod=test_maxsplit>

    def test_maxsplit(self):
        iterable = 'a,bb,ccc,dddd'
        separator = ','
        pred = lambda x: x == separator

        for maxsplit in range(-1, 4):
            with self.subTest(maxsplit=maxsplit):
                it = iter(iterable)
                result = mi.split_at(it, pred, maxsplit=maxsplit)
>               actual = [''.join(x) for x in result]
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:1313: TypeError
</pre>
</details>
<h3 id="test_morepysplitbeforetesttest_empty_collection">test_more.py::SplitBeforeTest::test_empty_collection</h3>
<details><summary> <pre>test_more.py::SplitBeforeTest::test_empty_collection</pre></summary><pre>
self = <tests.test_more.SplitBeforeTest testMethod=test_empty_collection>

    def test_empty_collection(self):
>       actual = list(mi.split_before([], lambda c: bool(c)))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1361: TypeError
</pre>
</details>
<h3 id="test_morepysplitbeforetesttest_ends_with_sep">test_more.py::SplitBeforeTest::test_ends_with_sep</h3>
<details><summary> <pre>test_more.py::SplitBeforeTest::test_ends_with_sep</pre></summary><pre>
self = <tests.test_more.SplitBeforeTest testMethod=test_ends_with_sep>

    def test_ends_with_sep(self):
>       actual = list(mi.split_before('ooxoox', lambda c: c == 'x'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1351: TypeError
</pre>
</details>
<h3 id="test_morepysplitbeforetesttest_max_split">test_more.py::SplitBeforeTest::test_max_split</h3>
<details><summary> <pre>test_more.py::SplitBeforeTest::test_max_split</pre></summary><pre>
self = <tests.test_more.SplitBeforeTest testMethod=test_max_split>

    def test_max_split(self):
        for args, expected in [
            (
                ('a,b,c,d', lambda c: c == ',', -1),
                [['a'], [',', 'b'], [',', 'c'], [',', 'd']],
            ),
            (
                ('a,b,c,d', lambda c: c == ',', 0),
                [['a', ',', 'b', ',', 'c', ',', 'd']],
            ),
            (
                ('a,b,c,d', lambda c: c == ',', 1),
                [['a'], [',', 'b', ',', 'c', ',', 'd']],
            ),
            (
                ('a,b,c,d', lambda c: c == ',', 2),
                [['a'], [',', 'b'], [',', 'c', ',', 'd']],
            ),
            (
                ('a,b,c,d', lambda c: c == ',', 10),
                [['a'], [',', 'b'], [',', 'c'], [',', 'd']],
            ),
            (
                ('a,b,c,d', lambda c: c == '@', 2),
                [['a', ',', 'b', ',', 'c', ',', 'd']],
            ),
            (
                ('a,b,c,d', lambda c: c != ',', 2),
                [['a', ','], ['b', ','], ['c', ',', 'd']],
            ),
        ]:
>           actual = list(mi.split_before(*args))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:1396: TypeError
</pre>
</details>
<h3 id="test_morepysplitbeforetesttest_no_sep">test_more.py::SplitBeforeTest::test_no_sep</h3>
<details><summary> <pre>test_more.py::SplitBeforeTest::test_no_sep</pre></summary><pre>
self = <tests.test_more.SplitBeforeTest testMethod=test_no_sep>

    def test_no_sep(self):
>       actual = list(mi.split_before('ooo', lambda c: c == 'x'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1356: TypeError
</pre>
</details>
<h3 id="test_morepysplitbeforetesttest_starts_with_sep">test_more.py::SplitBeforeTest::test_starts_with_sep</h3>
<details><summary> <pre>test_more.py::SplitBeforeTest::test_starts_with_sep</pre></summary><pre>
self = <tests.test_more.SplitBeforeTest testMethod=test_starts_with_sep>

    def test_starts_with_sep(self):
>       actual = list(mi.split_before('xooxoo', lambda c: c == 'x'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1346: TypeError
</pre>
</details>
<h3 id="test_morepysplitaftertesttest_ends_with_sep">test_more.py::SplitAfterTest::test_ends_with_sep</h3>
<details><summary> <pre>test_more.py::SplitAfterTest::test_ends_with_sep</pre></summary><pre>
self = <tests.test_more.SplitAfterTest testMethod=test_ends_with_sep>

    def test_ends_with_sep(self):
>       actual = list(mi.split_after('ooxoox', lambda c: c == 'x'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1409: TypeError
</pre>
</details>
<h3 id="test_morepysplitaftertesttest_max_split">test_more.py::SplitAfterTest::test_max_split</h3>
<details><summary> <pre>test_more.py::SplitAfterTest::test_max_split</pre></summary><pre>
self = <tests.test_more.SplitAfterTest testMethod=test_max_split>

    def test_max_split(self):
        for args, expected in [
            (
                ('a,b,c,d', lambda c: c == ',', -1),
                [['a', ','], ['b', ','], ['c', ','], ['d']],
            ),
            (
                ('a,b,c,d', lambda c: c == ',', 0),
                [['a', ',', 'b', ',', 'c', ',', 'd']],
            ),
            (
                ('a,b,c,d', lambda c: c == ',', 1),
                [['a', ','], ['b', ',', 'c', ',', 'd']],
            ),
            (
                ('a,b,c,d', lambda c: c == ',', 2),
                [['a', ','], ['b', ','], ['c', ',', 'd']],
            ),
            (
                ('a,b,c,d', lambda c: c == ',', 10),
                [['a', ','], ['b', ','], ['c', ','], ['d']],
            ),
            (
                ('a,b,c,d', lambda c: c == '@', 2),
                [['a', ',', 'b', ',', 'c', ',', 'd']],
            ),
            (
                ('a,b,c,d', lambda c: c != ',', 2),
                [['a'], [',', 'b'], [',', 'c', ',', 'd']],
            ),
            (
                ([1], lambda x: x == 1, 1),
                [[1]],
            ),
        ]:
>           actual = list(mi.split_after(*args))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:1453: TypeError
</pre>
</details>
<h3 id="test_morepysplitaftertesttest_no_sep">test_more.py::SplitAfterTest::test_no_sep</h3>
<details><summary> <pre>test_more.py::SplitAfterTest::test_no_sep</pre></summary><pre>
self = <tests.test_more.SplitAfterTest testMethod=test_no_sep>

    def test_no_sep(self):
>       actual = list(mi.split_after('ooo', lambda c: c == 'x'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1414: TypeError
</pre>
</details>
<h3 id="test_morepysplitaftertesttest_starts_with_sep">test_more.py::SplitAfterTest::test_starts_with_sep</h3>
<details><summary> <pre>test_more.py::SplitAfterTest::test_starts_with_sep</pre></summary><pre>
self = <tests.test_more.SplitAfterTest testMethod=test_starts_with_sep>

    def test_starts_with_sep(self):
>       actual = list(mi.split_after('xooxoo', lambda c: c == 'x'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1404: TypeError
</pre>
</details>
<h3 id="test_morepysplitwhenteststest_after_emulation_ends_with_sep">test_more.py::SplitWhenTests::test_after_emulation_ends_with_sep</h3>
<details><summary> <pre>test_more.py::SplitWhenTests::test_after_emulation_ends_with_sep</pre></summary><pre>
self = <tests.test_more.SplitWhenTests testMethod=test_after_emulation_ends_with_sep>

    def test_after_emulation_ends_with_sep(self):
>       actual = list(self._split_when_after('ooxoox', lambda c: c == 'x'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1491: TypeError
</pre>
</details>
<h3 id="test_morepysplitwhenteststest_after_emulation_no_sep">test_more.py::SplitWhenTests::test_after_emulation_no_sep</h3>
<details><summary> <pre>test_more.py::SplitWhenTests::test_after_emulation_no_sep</pre></summary><pre>
self = <tests.test_more.SplitWhenTests testMethod=test_after_emulation_no_sep>

    def test_after_emulation_no_sep(self):
>       actual = list(self._split_when_after('ooo', lambda c: c == 'x'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1496: TypeError
</pre>
</details>
<h3 id="test_morepysplitwhenteststest_after_emulation_starts_with_sep">test_more.py::SplitWhenTests::test_after_emulation_starts_with_sep</h3>
<details><summary> <pre>test_more.py::SplitWhenTests::test_after_emulation_starts_with_sep</pre></summary><pre>
self = <tests.test_more.SplitWhenTests testMethod=test_after_emulation_starts_with_sep>

    def test_after_emulation_starts_with_sep(self):
>       actual = list(self._split_when_after('xooxoo', lambda c: c == 'x'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1486: TypeError
</pre>
</details>
<h3 id="test_morepysplitwhenteststest_before_emulation_ends_with_sep">test_more.py::SplitWhenTests::test_before_emulation_ends_with_sep</h3>
<details><summary> <pre>test_more.py::SplitWhenTests::test_before_emulation_ends_with_sep</pre></summary><pre>
self = <tests.test_more.SplitWhenTests testMethod=test_before_emulation_ends_with_sep>

    def test_before_emulation_ends_with_sep(self):
>       actual = list(self._split_when_before('ooxoox', lambda c: c == 'x'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1475: TypeError
</pre>
</details>
<h3 id="test_morepysplitwhenteststest_before_emulation_no_sep">test_more.py::SplitWhenTests::test_before_emulation_no_sep</h3>
<details><summary> <pre>test_more.py::SplitWhenTests::test_before_emulation_no_sep</pre></summary><pre>
self = <tests.test_more.SplitWhenTests testMethod=test_before_emulation_no_sep>

    def test_before_emulation_no_sep(self):
>       actual = list(self._split_when_before('ooo', lambda c: c == 'x'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1480: TypeError
</pre>
</details>
<h3 id="test_morepysplitwhenteststest_before_emulation_starts_with_sep">test_more.py::SplitWhenTests::test_before_emulation_starts_with_sep</h3>
<details><summary> <pre>test_more.py::SplitWhenTests::test_before_emulation_starts_with_sep</pre></summary><pre>
self = <tests.test_more.SplitWhenTests testMethod=test_before_emulation_starts_with_sep>

    def test_before_emulation_starts_with_sep(self):
>       actual = list(self._split_when_before('xooxoo', lambda c: c == 'x'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1470: TypeError
</pre>
</details>
<h3 id="test_morepysplitwhenteststest_empty_iterable">test_more.py::SplitWhenTests::test_empty_iterable</h3>
<details><summary> <pre>test_more.py::SplitWhenTests::test_empty_iterable</pre></summary><pre>
self = <tests.test_more.SplitWhenTests testMethod=test_empty_iterable>

    def test_empty_iterable(self):
>       actual = list(mi.split_when('', lambda a, b: a != b))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1502: TypeError
</pre>
</details>
<h3 id="test_morepysplitwhenteststest_max_split">test_more.py::SplitWhenTests::test_max_split</h3>
<details><summary> <pre>test_more.py::SplitWhenTests::test_max_split</pre></summary><pre>
self = <tests.test_more.SplitWhenTests testMethod=test_max_split>

    def test_max_split(self):
        for args, expected in [
            (
                ('a,b,c,d', lambda a, _: a == ',', -1),
                [['a', ','], ['b', ','], ['c', ','], ['d']],
            ),
            (
                ('a,b,c,d', lambda a, _: a == ',', 0),
                [['a', ',', 'b', ',', 'c', ',', 'd']],
            ),
            (
                ('a,b,c,d', lambda _, b: b == ',', 1),
                [['a'], [',', 'b', ',', 'c', ',', 'd']],
            ),
            (
                ('a,b,c,d', lambda a, _: a == ',', 2),
                [['a', ','], ['b', ','], ['c', ',', 'd']],
            ),
            (
                ('0124376', lambda a, b: a > b, -1),
                [['0', '1', '2', '4'], ['3', '7'], ['6']],
            ),
            (
                ('0124376', lambda a, b: a > b, 0),
                [['0', '1', '2', '4', '3', '7', '6']],
            ),
            (
                ('0124376', lambda a, b: a > b, 1),
                [['0', '1', '2', '4'], ['3', '7', '6']],
            ),
            (
                ('0124376', lambda a, b: a > b, 2),
                [['0', '1', '2', '4'], ['3', '7'], ['6']],
            ),
        ]:
>           actual = list(mi.split_when(*args))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:1556: TypeError
</pre>
</details>
<h3 id="test_morepysplitwhenteststest_one_element">test_more.py::SplitWhenTests::test_one_element</h3>
<details><summary> <pre>test_more.py::SplitWhenTests::test_one_element</pre></summary><pre>
self = <tests.test_more.SplitWhenTests testMethod=test_one_element>

    def test_one_element(self):
>       actual = list(mi.split_when('o', lambda a, b: a == b))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1507: TypeError
</pre>
</details>
<h3 id="test_morepysplitwhenteststest_one_element_is_first_item">test_more.py::SplitWhenTests::test_one_element_is_first_item</h3>
<details><summary> <pre>test_more.py::SplitWhenTests::test_one_element_is_first_item</pre></summary><pre>
self = <tests.test_more.SplitWhenTests testMethod=test_one_element_is_first_item>

    def test_one_element_is_first_item(self):
>       actual = list(self._split_when_after('x', lambda c: c == 'x'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1517: TypeError
</pre>
</details>
<h3 id="test_morepysplitwhenteststest_one_element_is_second_item">test_more.py::SplitWhenTests::test_one_element_is_second_item</h3>
<details><summary> <pre>test_more.py::SplitWhenTests::test_one_element_is_second_item</pre></summary><pre>
self = <tests.test_more.SplitWhenTests testMethod=test_one_element_is_second_item>

    def test_one_element_is_second_item(self):
>       actual = list(self._split_when_before('x', lambda c: c == 'x'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1512: TypeError
</pre>
</details>
<h3 id="test_morepysplitintoteststest_bool_in_sizes">test_more.py::SplitIntoTests::test_bool_in_sizes</h3>
<details><summary> <pre>test_more.py::SplitIntoTests::test_bool_in_sizes</pre></summary><pre>
self = <tests.test_more.SplitIntoTests testMethod=test_bool_in_sizes>

    def test_bool_in_sizes(self):
        """A bool object is present in ``sizes`` is treated as a 1 or 0 for
        ``True`` or ``False`` due to bool being an instance of int."""
        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        sizes = [3, True, 2, False]
        expected = [[1, 2, 3], [4], [5, 6], []]
>       actual = list(mi.split_into(iterable, sizes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1670: TypeError
</pre>
</details>
<h3 id="test_morepysplitintoteststest_both_empty">test_more.py::SplitIntoTests::test_both_empty</h3>
<details><summary> <pre>test_more.py::SplitIntoTests::test_both_empty</pre></summary><pre>
self = <tests.test_more.SplitIntoTests testMethod=test_both_empty>

    def test_both_empty(self):
        """Both ``sizes`` and ``iterable`` arguments are empty. An empty
        generator is returned."""
        iterable = []
        sizes = []
        expected = []
>       actual = list(mi.split_into(iterable, sizes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1661: TypeError
</pre>
</details>
<h3 id="test_morepysplitintoteststest_generator_iterable_integrity">test_more.py::SplitIntoTests::test_generator_iterable_integrity</h3>
<details><summary> <pre>test_more.py::SplitIntoTests::test_generator_iterable_integrity</pre></summary><pre>
self = <tests.test_more.SplitIntoTests testMethod=test_generator_iterable_integrity>

    def test_generator_iterable_integrity(self):
        """Check that if ``iterable`` is an iterator, it is consumed only by as
        many items as the sum of ``sizes``."""
        iterable = (i for i in range(10))
        sizes = [2, 3]

        expected = [[0, 1], [2, 3, 4]]
>       actual = list(mi.split_into(iterable, sizes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1697: TypeError
</pre>
</details>
<h3 id="test_morepysplitintoteststest_generator_sizes_integrity">test_more.py::SplitIntoTests::test_generator_sizes_integrity</h3>
<details><summary> <pre>test_more.py::SplitIntoTests::test_generator_sizes_integrity</pre></summary><pre>
self = <tests.test_more.SplitIntoTests testMethod=test_generator_sizes_integrity>

    def test_generator_sizes_integrity(self):
        """Check that if ``sizes`` is an iterator, it is consumed only until a
        ``None`` item is reached"""
        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        sizes = (i for i in [1, 2, None, 3, 4])

        expected = [[1], [2, 3], [4, 5, 6, 7, 8, 9]]
>       actual = list(mi.split_into(iterable, sizes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1711: TypeError
</pre>
</details>
<h3 id="test_morepysplitintoteststest_invalid_in_sizes">test_more.py::SplitIntoTests::test_invalid_in_sizes</h3>
<details><summary> <pre>test_more.py::SplitIntoTests::test_invalid_in_sizes</pre></summary><pre>
self = <tests.test_more.SplitIntoTests testMethod=test_invalid_in_sizes>

    def test_invalid_in_sizes(self):
        """A ValueError is raised if an object in ``sizes`` is neither ``None``
        or an integer."""
        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        sizes = [1, [], 3]
        with self.assertRaises(ValueError):
>           list(mi.split_into(iterable, sizes))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:1679: TypeError
</pre>
</details>
<h3 id="test_morepysplitintoteststest_invalid_in_sizes_after_none">test_more.py::SplitIntoTests::test_invalid_in_sizes_after_none</h3>
<details><summary> <pre>test_more.py::SplitIntoTests::test_invalid_in_sizes_after_none</pre></summary><pre>
self = <tests.test_more.SplitIntoTests testMethod=test_invalid_in_sizes_after_none>

    def test_invalid_in_sizes_after_none(self):
        """A item in ``sizes`` that is invalid will not raise a TypeError if it
        comes after a ``None`` item."""
        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        sizes = [3, 4, None, []]
        expected = [[1, 2, 3], [4, 5, 6, 7], [8, 9]]
>       actual = list(mi.split_into(iterable, sizes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1687: TypeError
</pre>
</details>
<h3 id="test_morepysplitintoteststest_iterable_empty">test_more.py::SplitIntoTests::test_iterable_empty</h3>
<details><summary> <pre>test_more.py::SplitIntoTests::test_iterable_empty</pre></summary><pre>
self = <tests.test_more.SplitIntoTests testMethod=test_iterable_empty>

    def test_iterable_empty(self):
        """``iterable`` argument is empty but ``sizes`` is not. An empty
        list is returned for each item in ``sizes``."""
        iterable = []
        sizes = [2, 4, 2]
        expected = [[], [], []]
>       actual = list(mi.split_into(iterable, sizes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1633: TypeError
</pre>
</details>
<h3 id="test_morepysplitintoteststest_iterable_empty_using_none">test_more.py::SplitIntoTests::test_iterable_empty_using_none</h3>
<details><summary> <pre>test_more.py::SplitIntoTests::test_iterable_empty_using_none</pre></summary><pre>
self = <tests.test_more.SplitIntoTests testMethod=test_iterable_empty_using_none>

    def test_iterable_empty_using_none(self):
        """``iterable`` argument is empty but ``sizes`` is not. An empty
        list is returned for each item in ``sizes`` that is not after a
        None item."""
        iterable = []
        sizes = [2, 4, None, 2]
        expected = [[], [], []]
>       actual = list(mi.split_into(iterable, sizes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1643: TypeError
</pre>
</details>
<h3 id="test_morepysplitintoteststest_iterable_just_right">test_more.py::SplitIntoTests::test_iterable_just_right</h3>
<details><summary> <pre>test_more.py::SplitIntoTests::test_iterable_just_right</pre></summary><pre>
self = <tests.test_more.SplitIntoTests testMethod=test_iterable_just_right>

    def test_iterable_just_right(self):
        """Size of ``iterable`` equals the sum of ``sizes``."""
        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        sizes = [2, 3, 4]
        expected = [[1, 2], [3, 4, 5], [6, 7, 8, 9]]
>       actual = list(mi.split_into(iterable, sizes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1568: TypeError
</pre>
</details>
<h3 id="test_morepysplitintoteststest_iterable_too_large">test_more.py::SplitIntoTests::test_iterable_too_large</h3>
<details><summary> <pre>test_more.py::SplitIntoTests::test_iterable_too_large</pre></summary><pre>
self = <tests.test_more.SplitIntoTests testMethod=test_iterable_too_large>

    def test_iterable_too_large(self):
        """Size of ``iterable`` is larger than sum of ``sizes``. Not all
        items of iterable are returned."""
        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        sizes = [2, 3, 2]
        expected = [[1, 2], [3, 4, 5], [6, 7]]
>       actual = list(mi.split_into(iterable, sizes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1595: TypeError
</pre>
</details>
<h3 id="test_morepysplitintoteststest_iterable_too_small">test_more.py::SplitIntoTests::test_iterable_too_small</h3>
<details><summary> <pre>test_more.py::SplitIntoTests::test_iterable_too_small</pre></summary><pre>
self = <tests.test_more.SplitIntoTests testMethod=test_iterable_too_small>

    def test_iterable_too_small(self):
        """Size of ``iterable`` is smaller than sum of ``sizes``. Last return
        list is shorter as a result."""
        iterable = [1, 2, 3, 4, 5, 6, 7]
        sizes = [2, 3, 4]
        expected = [[1, 2], [3, 4, 5], [6, 7]]
>       actual = list(mi.split_into(iterable, sizes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1577: TypeError
</pre>
</details>
<h3 id="test_morepysplitintoteststest_iterable_too_small_extra">test_more.py::SplitIntoTests::test_iterable_too_small_extra</h3>
<details><summary> <pre>test_more.py::SplitIntoTests::test_iterable_too_small_extra</pre></summary><pre>
self = <tests.test_more.SplitIntoTests testMethod=test_iterable_too_small_extra>

    def test_iterable_too_small_extra(self):
        """Size of ``iterable`` is smaller than sum of ``sizes``. Second last
        return list is shorter and last return list is empty as a result."""
        iterable = [1, 2, 3, 4, 5, 6, 7]
        sizes = [2, 3, 4, 5]
        expected = [[1, 2], [3, 4, 5], [6, 7], []]
>       actual = list(mi.split_into(iterable, sizes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1586: TypeError
</pre>
</details>
<h3 id="test_morepysplitintoteststest_sizes_empty">test_more.py::SplitIntoTests::test_sizes_empty</h3>
<details><summary> <pre>test_more.py::SplitIntoTests::test_sizes_empty</pre></summary><pre>
self = <tests.test_more.SplitIntoTests testMethod=test_sizes_empty>

    def test_sizes_empty(self):
        """``sizes`` argument is empty but ``iterable`` is not. An empty
        generator is returned."""
        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        sizes = []
        expected = []
>       actual = list(mi.split_into(iterable, sizes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1652: TypeError
</pre>
</details>
<h3 id="test_morepysplitintoteststest_using_none_mid_sizes">test_more.py::SplitIntoTests::test_using_none_mid_sizes</h3>
<details><summary> <pre>test_more.py::SplitIntoTests::test_using_none_mid_sizes</pre></summary><pre>
self = <tests.test_more.SplitIntoTests testMethod=test_using_none_mid_sizes>

    def test_using_none_mid_sizes(self):
        """None is present in ``sizes`` but is not the last item. Last list
        returned stretches to fit all remaining items of ``iterable`` but
        all items in ``sizes`` after None are ignored."""
        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        sizes = [2, 3, None, 4]
        expected = [[1, 2], [3, 4, 5], [6, 7, 8, 9]]
>       actual = list(mi.split_into(iterable, sizes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1624: TypeError
</pre>
</details>
<h3 id="test_morepysplitintoteststest_using_none_with_leftover">test_more.py::SplitIntoTests::test_using_none_with_leftover</h3>
<details><summary> <pre>test_more.py::SplitIntoTests::test_using_none_with_leftover</pre></summary><pre>
self = <tests.test_more.SplitIntoTests testMethod=test_using_none_with_leftover>

    def test_using_none_with_leftover(self):
        """Last item of ``sizes`` is None when items still remain in
        ``iterable``. Last list returned stretches to fit all remaining items
        of ``iterable``."""
        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        sizes = [2, 3, None]
        expected = [[1, 2], [3, 4, 5], [6, 7, 8, 9]]
>       actual = list(mi.split_into(iterable, sizes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1605: TypeError
</pre>
</details>
<h3 id="test_morepysplitintoteststest_using_none_without_leftover">test_more.py::SplitIntoTests::test_using_none_without_leftover</h3>
<details><summary> <pre>test_more.py::SplitIntoTests::test_using_none_without_leftover</pre></summary><pre>
self = <tests.test_more.SplitIntoTests testMethod=test_using_none_without_leftover>

    def test_using_none_without_leftover(self):
        """Last item of ``sizes`` is None when no items remain in
        ``iterable``. Last list returned is empty."""
        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        sizes = [2, 3, 4, None]
        expected = [[1, 2], [3, 4, 5], [6, 7, 8, 9], []]
>       actual = list(mi.split_into(iterable, sizes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1614: TypeError
</pre>
</details>
<h3 id="test_morepypaddedtesttest_invalid_n">test_more.py::PaddedTest::test_invalid_n</h3>
<details><summary> <pre>test_more.py::PaddedTest::test_invalid_n</pre></summary><pre>
self = <tests.test_more.PaddedTest testMethod=test_invalid_n>

    def test_invalid_n(self):
>       self.assertRaises(ValueError, lambda: list(mi.padded([1, 2, 3], n=-1)))

tests/test_more.py:1734: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   self.assertRaises(ValueError, lambda: list(mi.padded([1, 2, 3], n=-1)))
E   TypeError: 'NoneType' object is not iterable

tests/test_more.py:1734: TypeError
</pre>
</details>
<h3 id="test_morepypaddedtesttest_next_multiple">test_more.py::PaddedTest::test_next_multiple</h3>
<details><summary> <pre>test_more.py::PaddedTest::test_next_multiple</pre></summary><pre>
self = <tests.test_more.PaddedTest testMethod=test_next_multiple>

    def test_next_multiple(self):
        seq = [1, 2, 3, 4, 5, 6]

        # No need for padding: len(seq) % n == 0
        self.assertEqual(
>           list(mi.padded(seq, n=3, next_multiple=True)), [1, 2, 3, 4, 5, 6]
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1759: TypeError
</pre>
</details>
<h3 id="test_morepypaddedtesttest_no_n">test_more.py::PaddedTest::test_no_n</h3>
<details><summary> <pre>test_more.py::PaddedTest::test_no_n</pre></summary><pre>
self = <tests.test_more.PaddedTest testMethod=test_no_n>

    def test_no_n(self):
        seq = [1, 2, 3]

        # No fillvalue
>       self.assertEqual(mi.take(5, mi.padded(seq)), [1, 2, 3, None, None])

tests/test_more.py:1726: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

n = 5, iterable = None

    def take(n, iterable):
        """Return first *n* items of the iterable as a list.

            >>> take(3, range(10))
            [0, 1, 2]

        If there are fewer than *n* items in the iterable, all of them are
        returned.

            >>> take(10, range(3))
            [0, 1, 2]

        """
>       return list(islice(iterable, n))
E       TypeError: 'NoneType' object is not iterable

more_itertools/recipes.py:71: TypeError
</pre>
</details>
<h3 id="test_morepypaddedtesttest_valid_n">test_more.py::PaddedTest::test_valid_n</h3>
<details><summary> <pre>test_more.py::PaddedTest::test_valid_n</pre></summary><pre>
self = <tests.test_more.PaddedTest testMethod=test_valid_n>

    def test_valid_n(self):
        seq = [1, 2, 3, 4, 5]

        # No need for padding: len(seq) <= n
>       self.assertEqual(list(mi.padded(seq, n=4)), [1, 2, 3, 4, 5])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1741: TypeError
</pre>
</details>
<h3 id="test_morepyrepeateachteststest_basic">test_more.py::RepeatEachTests::test_basic</h3>
<details><summary> <pre>test_more.py::RepeatEachTests::test_basic</pre></summary><pre>
self = <tests.test_more.RepeatEachTests testMethod=test_basic>

    def test_basic(self):
>       actual = list(mi.repeat_each('ABC', 3))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1795: TypeError
</pre>
</details>
<h3 id="test_morepyrepeateachteststest_default">test_more.py::RepeatEachTests::test_default</h3>
<details><summary> <pre>test_more.py::RepeatEachTests::test_default</pre></summary><pre>
self = <tests.test_more.RepeatEachTests testMethod=test_default>

    def test_default(self):
>       actual = list(mi.repeat_each('ABC'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1790: TypeError
</pre>
</details>
<h3 id="test_morepyrepeateachteststest_empty">test_more.py::RepeatEachTests::test_empty</h3>
<details><summary> <pre>test_more.py::RepeatEachTests::test_empty</pre></summary><pre>
self = <tests.test_more.RepeatEachTests testMethod=test_empty>

    def test_empty(self):
>       actual = list(mi.repeat_each(''))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1800: TypeError
</pre>
</details>
<h3 id="test_morepyrepeateachteststest_infinite_input">test_more.py::RepeatEachTests::test_infinite_input</h3>
<details><summary> <pre>test_more.py::RepeatEachTests::test_infinite_input</pre></summary><pre>
self = <tests.test_more.RepeatEachTests testMethod=test_infinite_input>

    def test_infinite_input(self):
        repeater = mi.repeat_each(cycle('AB'))
>       actual = mi.take(6, repeater)

tests/test_more.py:1816: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

n = 6, iterable = None

    def take(n, iterable):
        """Return first *n* items of the iterable as a list.

            >>> take(3, range(10))
            [0, 1, 2]

        If there are fewer than *n* items in the iterable, all of them are
        returned.

            >>> take(10, range(3))
            [0, 1, 2]

        """
>       return list(islice(iterable, n))
E       TypeError: 'NoneType' object is not iterable

more_itertools/recipes.py:71: TypeError
</pre>
</details>
<h3 id="test_morepyrepeateachteststest_negative_repeat">test_more.py::RepeatEachTests::test_negative_repeat</h3>
<details><summary> <pre>test_more.py::RepeatEachTests::test_negative_repeat</pre></summary><pre>
self = <tests.test_more.RepeatEachTests testMethod=test_negative_repeat>

    def test_negative_repeat(self):
>       actual = list(mi.repeat_each('ABC', -1))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1810: TypeError
</pre>
</details>
<h3 id="test_morepyrepeateachteststest_no_repeat">test_more.py::RepeatEachTests::test_no_repeat</h3>
<details><summary> <pre>test_more.py::RepeatEachTests::test_no_repeat</pre></summary><pre>
self = <tests.test_more.RepeatEachTests testMethod=test_no_repeat>

    def test_no_repeat(self):
>       actual = list(mi.repeat_each('ABC', 0))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1805: TypeError
</pre>
</details>
<h3 id="test_morepyrepeatlastteststest_basic">test_more.py::RepeatLastTests::test_basic</h3>
<details><summary> <pre>test_more.py::RepeatLastTests::test_basic</pre></summary><pre>
self = <tests.test_more.RepeatLastTests testMethod=test_basic>

    def test_basic(self):
        slice_length = 10
        iterable = (str(x) for x in range(5))
>       actual = mi.take(slice_length, mi.repeat_last(iterable))

tests/test_more.py:1840: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

n = 10, iterable = None

    def take(n, iterable):
        """Return first *n* items of the iterable as a list.

            >>> take(3, range(10))
            [0, 1, 2]

        If there are fewer than *n* items in the iterable, all of them are
        returned.

            >>> take(10, range(3))
            [0, 1, 2]

        """
>       return list(islice(iterable, n))
E       TypeError: 'NoneType' object is not iterable

more_itertools/recipes.py:71: TypeError
</pre>
</details>
<h3 id="test_morepyrepeatlastteststest_default_value">test_more.py::RepeatLastTests::test_default_value</h3>
<details><summary> <pre>test_more.py::RepeatLastTests::test_default_value</pre></summary><pre>
self = <tests.test_more.RepeatLastTests testMethod=test_default_value>

    def test_default_value(self):
        slice_length = 3
        iterable = iter([])
        default = '3'
>       actual = mi.take(slice_length, mi.repeat_last(iterable, default))

tests/test_more.py:1833: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

n = 3, iterable = None

    def take(n, iterable):
        """Return first *n* items of the iterable as a list.

            >>> take(3, range(10))
            [0, 1, 2]

        If there are fewer than *n* items in the iterable, all of them are
        returned.

            >>> take(10, range(3))
            [0, 1, 2]

        """
>       return list(islice(iterable, n))
E       TypeError: 'NoneType' object is not iterable

more_itertools/recipes.py:71: TypeError
</pre>
</details>
<h3 id="test_morepyrepeatlastteststest_empty_iterable">test_more.py::RepeatLastTests::test_empty_iterable</h3>
<details><summary> <pre>test_more.py::RepeatLastTests::test_empty_iterable</pre></summary><pre>
self = <tests.test_more.RepeatLastTests testMethod=test_empty_iterable>

    def test_empty_iterable(self):
        slice_length = 3
        iterable = iter([])
>       actual = mi.take(slice_length, mi.repeat_last(iterable))

tests/test_more.py:1825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

n = 3, iterable = None

    def take(n, iterable):
        """Return first *n* items of the iterable as a list.

            >>> take(3, range(10))
            [0, 1, 2]

        If there are fewer than *n* items in the iterable, all of them are
        returned.

            >>> take(10, range(3))
            [0, 1, 2]

        """
>       return list(islice(iterable, n))
E       TypeError: 'NoneType' object is not iterable

more_itertools/recipes.py:71: TypeError
</pre>
</details>
<h3 id="test_morepydistributetesttest_basic">test_more.py::DistributeTest::test_basic</h3>
<details><summary> <pre>test_more.py::DistributeTest::test_basic</pre></summary><pre>
self = <tests.test_more.DistributeTest testMethod=test_basic>

    def test_basic(self):
        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

        for n, expected in [
            (1, [iterable]),
            (2, [[1, 3, 5, 7, 9], [2, 4, 6, 8, 10]]),
            (3, [[1, 4, 7, 10], [2, 5, 8], [3, 6, 9]]),
            (10, [[n] for n in range(1, 10 + 1)]),
        ]:
            self.assertEqual(
>               [list(x) for x in mi.distribute(n, iterable)], expected
            )
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:1862: TypeError
</pre>
</details>
<h3 id="test_morepydistributetesttest_invalid_n">test_more.py::DistributeTest::test_invalid_n</h3>
<details><summary> <pre>test_more.py::DistributeTest::test_invalid_n</pre></summary><pre>
self = <tests.test_more.DistributeTest testMethod=test_invalid_n>

    def test_invalid_n(self):
>       self.assertRaises(ValueError, lambda: mi.distribute(-1, [1, 2, 3]))
E       AssertionError: ValueError not raised by <lambda>

tests/test_more.py:1849: AssertionError
</pre>
</details>
<h3 id="test_morepydistributetesttest_large_n">test_more.py::DistributeTest::test_large_n</h3>
<details><summary> <pre>test_more.py::DistributeTest::test_large_n</pre></summary><pre>
self = <tests.test_more.DistributeTest testMethod=test_large_n>

    def test_large_n(self):
        iterable = [1, 2, 3, 4]
        self.assertEqual(
>           [list(x) for x in mi.distribute(6, iterable)],
            [[1], [2], [3], [4], [], []],
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1868: TypeError
</pre>
</details>
<h3 id="test_morepystaggertesttest_default">test_more.py::StaggerTest::test_default</h3>
<details><summary> <pre>test_more.py::StaggerTest::test_default</pre></summary><pre>
self = <tests.test_more.StaggerTest testMethod=test_default>

    def test_default(self):
        iterable = [0, 1, 2, 3]
>       actual = list(mi.stagger(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1878: TypeError
</pre>
</details>
<h3 id="test_morepystaggertesttest_longest">test_more.py::StaggerTest::test_longest</h3>
<details><summary> <pre>test_more.py::StaggerTest::test_longest</pre></summary><pre>
self = <tests.test_more.StaggerTest testMethod=test_longest>

    def test_longest(self):
        iterable = [0, 1, 2, 3]
        for offsets, expected in [
            (
                (-1, 0, 1),
                [('', 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, ''), (3, '', '')],
            ),
            ((-2, -1), [('', ''), ('', 0), (0, 1), (1, 2), (2, 3), (3, '')]),
            ((1, 2), [(1, 2), (2, 3), (3, '')]),
        ]:
            all_groups = mi.stagger(
                iterable, offsets=offsets, fillvalue='', longest=True
            )
>           self.assertEqual(list(all_groups), expected)
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:1905: TypeError
</pre>
</details>
<h3 id="test_morepystaggertesttest_offsets">test_more.py::StaggerTest::test_offsets</h3>
<details><summary> <pre>test_more.py::StaggerTest::test_offsets</pre></summary><pre>
self = <tests.test_more.StaggerTest testMethod=test_offsets>

    def test_offsets(self):
        iterable = [0, 1, 2, 3]
        for offsets, expected in [
            ((-2, 0, 2), [('', 0, 2), ('', 1, 3)]),
            ((-2, -1), [('', ''), ('', 0), (0, 1), (1, 2), (2, 3)]),
            ((1, 2), [(1, 2), (2, 3)]),
        ]:
            all_groups = mi.stagger(iterable, offsets=offsets, fillvalue='')
>           self.assertEqual(list(all_groups), expected)
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:1890: TypeError
</pre>
</details>
<h3 id="test_morepyzipequaltesttest_deprecation">test_more.py::ZipEqualTest::test_deprecation</h3>
<details><summary> <pre>test_more.py::ZipEqualTest::test_deprecation</pre></summary><pre>
self = <tests.test_more.ZipEqualTest testMethod=test_deprecation>

    @skipIf(version_info[:2] < (3, 10), 'zip_equal deprecated for 3.10+')
    def test_deprecation(self):
        with warnings.catch_warnings(record=True) as caught:
            warnings.simplefilter('always')
            self.assertEqual(
>               list(mi.zip_equal([1, 2], [3, 4])), [(1, 3), (2, 4)]
            )
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:1914: TypeError
</pre>
</details>
<h3 id="test_morepyzipequaltesttest_equal">test_more.py::ZipEqualTest::test_equal</h3>
<details><summary> <pre>test_more.py::ZipEqualTest::test_equal</pre></summary><pre>
self = <tests.test_more.ZipEqualTest testMethod=test_equal>

    def test_equal(self):
        lists = [0, 1, 2], [2, 3, 4]

        for iterables in [lists, map(iter, lists)]:
>           actual = list(mi.zip_equal(*iterables))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:1924: TypeError
</pre>
</details>
<h3 id="test_morepyzipequaltesttest_unequal_lists">test_more.py::ZipEqualTest::test_unequal_lists</h3>
<details><summary> <pre>test_more.py::ZipEqualTest::test_unequal_lists</pre></summary><pre>
self = <tests.test_more.ZipEqualTest testMethod=test_unequal_lists>

    def test_unequal_lists(self):
        two_items = [0, 1]
        three_items = [2, 3, 4]
        four_items = [5, 6, 7, 8]

        # the mismatch is at index 1
        try:
>           list(mi.zip_equal(two_items, three_items, four_items))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:1935: TypeError
</pre>
</details>
<h3 id="test_morepyzipoffsettesttest_longest">test_more.py::ZipOffsetTest::test_longest</h3>
<details><summary> <pre>test_more.py::ZipOffsetTest::test_longest</pre></summary><pre>
self = <tests.test_more.ZipOffsetTest testMethod=test_longest>

    def test_longest(self):
        a_1 = [0, 1, 2, 3]
        a_2 = [0, 1, 2, 3, 4, 5]
        a_3 = [0, 1, 2, 3, 4, 5, 6, 7]
>       actual = list(
            mi.zip_offset(a_1, a_2, a_3, offsets=(-1, 0, 1), longest=True)
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1981: TypeError
</pre>
</details>
<h3 id="test_morepyzipoffsettesttest_mismatch">test_more.py::ZipOffsetTest::test_mismatch</h3>
<details><summary> <pre>test_more.py::ZipOffsetTest::test_mismatch</pre></summary><pre>
self = <tests.test_more.ZipOffsetTest testMethod=test_mismatch>

    def test_mismatch(self):
        iterables = [0, 1, 2], [2, 3, 4]
        offsets = (-1, 0, 1)
>       self.assertRaises(
            ValueError,
            lambda: list(mi.zip_offset(*iterables, offsets=offsets)),
        )

tests/test_more.py:1998: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: list(mi.zip_offset(*iterables, offsets=offsets)),
    )
E   TypeError: 'NoneType' object is not iterable

tests/test_more.py:2000: TypeError
</pre>
</details>
<h3 id="test_morepyzipoffsettesttest_shortest">test_more.py::ZipOffsetTest::test_shortest</h3>
<details><summary> <pre>test_more.py::ZipOffsetTest::test_shortest</pre></summary><pre>
self = <tests.test_more.ZipOffsetTest testMethod=test_shortest>

    def test_shortest(self):
        a_1 = [0, 1, 2, 3]
        a_2 = [0, 1, 2, 3, 4, 5]
        a_3 = [0, 1, 2, 3, 4, 5, 6, 7]
>       actual = list(
            mi.zip_offset(a_1, a_2, a_3, offsets=(-1, 0, 1), fillvalue='')
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:1971: TypeError
</pre>
</details>
<h3 id="test_morepyunzipteststest_empty_iterable">test_more.py::UnzipTests::test_empty_iterable</h3>
<details><summary> <pre>test_more.py::UnzipTests::test_empty_iterable</pre></summary><pre>
self = <tests.test_more.UnzipTests testMethod=test_empty_iterable>

    def test_empty_iterable(self):
>       self.assertEqual(list(mi.unzip([])), [])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2008: TypeError
</pre>
</details>
<h3 id="test_morepyunzipteststest_improperly_zipped">test_more.py::UnzipTests::test_improperly_zipped</h3>
<details><summary> <pre>test_more.py::UnzipTests::test_improperly_zipped</pre></summary><pre>
self = <tests.test_more.UnzipTests testMethod=test_improperly_zipped>

    def test_improperly_zipped(self):
        zipped = iter([(1, 2, 3), (4, 5), (6,)])
>       xs, ys, zs = mi.unzip(zipped)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_more.py:2029: TypeError
</pre>
</details>
<h3 id="test_morepyunzipteststest_increasingly_zipped">test_more.py::UnzipTests::test_increasingly_zipped</h3>
<details><summary> <pre>test_more.py::UnzipTests::test_increasingly_zipped</pre></summary><pre>
self = <tests.test_more.UnzipTests testMethod=test_increasingly_zipped>

    def test_increasingly_zipped(self):
        zipped = iter([(1, 2), (3, 4, 5), (6, 7, 8, 9)])
        unzipped = mi.unzip(zipped)
        # from the docstring:
        # len(first tuple) is the number of iterables zipped
>       self.assertEqual(len(unzipped), 2)
E       TypeError: object of type 'NoneType' has no len()

tests/test_more.py:2039: TypeError
</pre>
</details>
<h3 id="test_morepyunzipteststest_length_one_iterable">test_more.py::UnzipTests::test_length_one_iterable</h3>
<details><summary> <pre>test_more.py::UnzipTests::test_length_one_iterable</pre></summary><pre>
self = <tests.test_more.UnzipTests testMethod=test_length_one_iterable>

    def test_length_one_iterable(self):
>       xs, ys, zs = mi.unzip(zip([1], [2], [3]))
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_more.py:2014: TypeError
</pre>
</details>
<h3 id="test_morepyunzipteststest_normal_case">test_more.py::UnzipTests::test_normal_case</h3>
<details><summary> <pre>test_more.py::UnzipTests::test_normal_case</pre></summary><pre>
self = <tests.test_more.UnzipTests testMethod=test_normal_case>

    def test_normal_case(self):
        xs, ys, zs = range(10), range(1, 11), range(2, 12)
        zipped = zip(xs, ys, zs)
>       xs, ys, zs = mi.unzip(zipped)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_more.py:2022: TypeError
</pre>
</details>
<h3 id="test_morepysorttogethertesttest_invalid_key_list">test_more.py::SortTogetherTest::test_invalid_key_list</h3>
<details><summary> <pre>test_more.py::SortTogetherTest::test_invalid_key_list</pre></summary><pre>
self = <tests.test_more.SortTogetherTest testMethod=test_invalid_key_list>

    def test_invalid_key_list(self):
        """tests `key_list` for indexes not available in `iterables`"""
        iterables = [
            ['GA', 'GA', 'GA', 'CT', 'CT', 'CT'],
            ['May', 'Aug.', 'May', 'June', 'July', 'July'],
            [97, 20, 100, 70, 100, 20],
        ]

>       self.assertRaises(
            IndexError, lambda: mi.sort_together(iterables, key_list=(5,))
        )
E       AssertionError: IndexError not raised by <lambda>

tests/test_more.py:2100: AssertionError
</pre>
</details>
<h3 id="test_morepysorttogethertesttest_key_function">test_more.py::SortTogetherTest::test_key_function</h3>
<details><summary> <pre>test_more.py::SortTogetherTest::test_key_function</pre></summary><pre>
self = <tests.test_more.SortTogetherTest testMethod=test_key_function>

    def test_key_function(self):
        """tests `key` function, including interaction with `key_list`"""
        iterables = [
            ['GA', 'GA', 'GA', 'CT', 'CT', 'CT'],
            ['May', 'Aug.', 'May', 'June', 'July', 'July'],
            [97, 20, 100, 70, 100, 20],
        ]
>       self.assertEqual(
            mi.sort_together(iterables, key=lambda x: x),
            [
                ('CT', 'CT', 'CT', 'GA', 'GA', 'GA'),
                ('June', 'July', 'July', 'May', 'Aug.', 'May'),
                (70, 100, 20, 97, 20, 100),
            ],
        )
E       AssertionError: None != [('CT', 'CT', 'CT', 'GA', 'GA', 'GA'), ('[68 chars]100)]

tests/test_more.py:2111: AssertionError
</pre>
</details>
<h3 id="test_morepysorttogethertesttest_key_list">test_more.py::SortTogetherTest::test_key_list</h3>
<details><summary> <pre>test_more.py::SortTogetherTest::test_key_list</pre></summary><pre>
self = <tests.test_more.SortTogetherTest testMethod=test_key_list>

    def test_key_list(self):
        """tests `key_list` including default, iterables include duplicates"""
        iterables = [
            ['GA', 'GA', 'GA', 'CT', 'CT', 'CT'],
            ['May', 'Aug.', 'May', 'June', 'July', 'July'],
            [97, 20, 100, 70, 100, 20],
        ]

>       self.assertEqual(
            mi.sort_together(iterables),
            [
                ('CT', 'CT', 'CT', 'GA', 'GA', 'GA'),
                ('June', 'July', 'July', 'May', 'Aug.', 'May'),
                (70, 100, 20, 97, 20, 100),
            ],
        )
E       AssertionError: None != [('CT', 'CT', 'CT', 'GA', 'GA', 'GA'), ('[68 chars]100)]

tests/test_more.py:2056: AssertionError
</pre>
</details>
<h3 id="test_morepysorttogethertesttest_reverse">test_more.py::SortTogetherTest::test_reverse</h3>
<details><summary> <pre>test_more.py::SortTogetherTest::test_reverse</pre></summary><pre>
self = <tests.test_more.SortTogetherTest testMethod=test_reverse>

    def test_reverse(self):
        """tests `reverse` to ensure a reverse sort for `key_list` iterables"""
        iterables = [
            ['GA', 'GA', 'GA', 'CT', 'CT', 'CT'],
            ['May', 'Aug.', 'May', 'June', 'July', 'July'],
            [97, 20, 100, 70, 100, 20],
        ]

>       self.assertEqual(
            mi.sort_together(iterables, key_list=(0, 1, 2), reverse=True),
            [
                ('GA', 'GA', 'GA', 'CT', 'CT', 'CT'),
                ('May', 'May', 'Aug.', 'June', 'July', 'July'),
                (100, 97, 20, 70, 100, 20),
            ],
        )
E       AssertionError: None != [('GA', 'GA', 'GA', 'CT', 'CT', 'CT'), ('[68 chars] 20)]

tests/test_more.py:2150: AssertionError
</pre>
</details>
<h3 id="test_morepysorttogethertesttest_strict">test_more.py::SortTogetherTest::test_strict</h3>
<details><summary> <pre>test_more.py::SortTogetherTest::test_strict</pre></summary><pre>
self = <tests.test_more.SortTogetherTest testMethod=test_strict>

    def test_strict(self):
        # Test for list of lists or tuples
>       self.assertRaises(
            mi.UnequalIterablesError,
            lambda: mi.sort_together(
                [(4, 3, 2, 1), ('a', 'b', 'c')], strict=True
            ),
        )
E       AssertionError: UnequalIterablesError not raised by <lambda>

tests/test_more.py:2178: AssertionError
</pre>
</details>
<h3 id="test_morepysorttogethertesttest_uneven_iterables">test_more.py::SortTogetherTest::test_uneven_iterables</h3>
<details><summary> <pre>test_more.py::SortTogetherTest::test_uneven_iterables</pre></summary><pre>
self = <tests.test_more.SortTogetherTest testMethod=test_uneven_iterables>

    def test_uneven_iterables(self):
        """tests trimming of iterables to the shortest length before sorting"""
        iterables = [
            ['GA', 'GA', 'GA', 'CT', 'CT', 'CT', 'MA'],
            ['May', 'Aug.', 'May', 'June', 'July', 'July'],
            [97, 20, 100, 70, 100, 20, 0],
        ]

>       self.assertEqual(
            mi.sort_together(iterables),
            [
                ('CT', 'CT', 'CT', 'GA', 'GA', 'GA'),
                ('June', 'July', 'July', 'May', 'Aug.', 'May'),
                (70, 100, 20, 97, 20, 100),
            ],
        )
E       AssertionError: None != [('CT', 'CT', 'CT', 'GA', 'GA', 'GA'), ('[68 chars]100)]

tests/test_more.py:2167: AssertionError
</pre>
</details>
<h3 id="test_morepydividetesttest_basic">test_more.py::DivideTest::test_basic</h3>
<details><summary> <pre>test_more.py::DivideTest::test_basic</pre></summary><pre>
self = <tests.test_more.DivideTest testMethod=test_basic>

    def test_basic(self):
        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

        for n, expected in [
            (1, [iterable]),
            (2, [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]),
            (3, [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]),
            (10, [[n] for n in range(1, 10 + 1)]),
        ]:
            self.assertEqual(
>               [list(x) for x in mi.divide(n, iterable)], expected
            )
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:2217: TypeError
</pre>
</details>
<h3 id="test_morepydividetesttest_invalid_n">test_more.py::DivideTest::test_invalid_n</h3>
<details><summary> <pre>test_more.py::DivideTest::test_invalid_n</pre></summary><pre>
self = <tests.test_more.DivideTest testMethod=test_invalid_n>

    def test_invalid_n(self):
>       self.assertRaises(ValueError, lambda: mi.divide(-1, [1, 2, 3]))
E       AssertionError: ValueError not raised by <lambda>

tests/test_more.py:2204: AssertionError
</pre>
</details>
<h3 id="test_morepydividetesttest_large_n">test_more.py::DivideTest::test_large_n</h3>
<details><summary> <pre>test_more.py::DivideTest::test_large_n</pre></summary><pre>
self = <tests.test_more.DivideTest testMethod=test_large_n>

    def test_large_n(self):
        self.assertEqual(
>           [list(x) for x in mi.divide(6, iter(range(1, 4 + 1)))],
            [[1], [2], [3], [4], [], []],
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2222: TypeError
</pre>
</details>
<h3 id="test_morepytestalwaysiterabletest_base_type">test_more.py::TestAlwaysIterable::test_base_type</h3>
<details><summary> <pre>test_more.py::TestAlwaysIterable::test_base_type</pre></summary><pre>
self = <tests.test_more.TestAlwaysIterable testMethod=test_base_type>

    def test_base_type(self):
        dict_obj = {'a': 1, 'b': 2}
        str_obj = '123'

        # Default: dicts are iterable like they normally are
>       default_actual = list(mi.always_iterable(dict_obj))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2244: TypeError
</pre>
</details>
<h3 id="test_morepytestalwaysiterabletest_generator">test_more.py::TestAlwaysIterable::test_generator</h3>
<details><summary> <pre>test_more.py::TestAlwaysIterable::test_generator</pre></summary><pre>
self = <tests.test_more.TestAlwaysIterable testMethod=test_generator>

    def test_generator(self):
        def _gen():
            yield 0
            yield 1

>       self.assertEqual(list(mi.always_iterable(_gen())), [0, 1])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2282: TypeError
</pre>
</details>
<h3 id="test_morepytestalwaysiterabletest_iterables">test_more.py::TestAlwaysIterable::test_iterables</h3>
<details><summary> <pre>test_more.py::TestAlwaysIterable::test_iterables</pre></summary><pre>
self = <tests.test_more.TestAlwaysIterable testMethod=test_iterables>

    def test_iterables(self):
>       self.assertEqual(list(mi.always_iterable([0, 1])), [0, 1])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2265: TypeError
</pre>
</details>
<h3 id="test_morepytestalwaysiterabletest_none">test_more.py::TestAlwaysIterable::test_none</h3>
<details><summary> <pre>test_more.py::TestAlwaysIterable::test_none</pre></summary><pre>
self = <tests.test_more.TestAlwaysIterable testMethod=test_none>

    def test_none(self):
>       self.assertEqual(list(mi.always_iterable(None)), [])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2275: TypeError
</pre>
</details>
<h3 id="test_morepytestalwaysiterabletest_single">test_more.py::TestAlwaysIterable::test_single</h3>
<details><summary> <pre>test_more.py::TestAlwaysIterable::test_single</pre></summary><pre>
self = <tests.test_more.TestAlwaysIterable testMethod=test_single>

    def test_single(self):
>       self.assertEqual(list(mi.always_iterable(1)), [1])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2231: TypeError
</pre>
</details>
<h3 id="test_morepytestalwaysiterabletest_strings">test_more.py::TestAlwaysIterable::test_strings</h3>
<details><summary> <pre>test_more.py::TestAlwaysIterable::test_strings</pre></summary><pre>
self = <tests.test_more.TestAlwaysIterable testMethod=test_strings>

    def test_strings(self):
        for obj in ['foo', b'bar', 'baz']:
>           actual = list(mi.always_iterable(obj))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:2235: TypeError
</pre>
</details>
<h3 id="test_morepyadjacentteststest_call_once">test_more.py::AdjacentTests::test_call_once</h3>
<details><summary> <pre>test_more.py::AdjacentTests::test_call_once</pre></summary><pre>
self = <tests.test_more.AdjacentTests testMethod=test_call_once>

    def test_call_once(self):
        """Test that the predicate is only called once per item."""
        already_seen = set()
        iterable = range(10)

        def predicate(item):
            self.assertNotIn(item, already_seen)
            already_seen.add(item)
            return True

>       actual = list(mi.adjacent(predicate, iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2417: TypeError
</pre>
</details>
<h3 id="test_morepyadjacentteststest_consecutive_true">test_more.py::AdjacentTests::test_consecutive_true</h3>
<details><summary> <pre>test_more.py::AdjacentTests::test_consecutive_true</pre></summary><pre>
self = <tests.test_more.AdjacentTests testMethod=test_consecutive_true>

    def test_consecutive_true(self):
        """Test that when the predicate matches multiple consecutive elements
        it doesn't repeat elements in the output"""
>       actual = list(mi.adjacent(lambda x: x % 5 < 2, range(10)))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2319: TypeError
</pre>
</details>
<h3 id="test_morepyadjacentteststest_distance">test_more.py::AdjacentTests::test_distance</h3>
<details><summary> <pre>test_more.py::AdjacentTests::test_distance</pre></summary><pre>
self = <tests.test_more.AdjacentTests testMethod=test_distance>

    def test_distance(self):
>       actual = list(mi.adjacent(lambda x: x % 5 == 0, range(10), distance=2))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2335: TypeError
</pre>
</details>
<h3 id="test_morepyadjacentteststest_empty_iterable">test_more.py::AdjacentTests::test_empty_iterable</h3>
<details><summary> <pre>test_more.py::AdjacentTests::test_empty_iterable</pre></summary><pre>
self = <tests.test_more.AdjacentTests testMethod=test_empty_iterable>

    def test_empty_iterable(self):
>       actual = list(mi.adjacent(lambda x: x % 5 == 0, []))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2303: TypeError
</pre>
</details>
<h3 id="test_morepyadjacentteststest_grouping">test_more.py::AdjacentTests::test_grouping</h3>
<details><summary> <pre>test_more.py::AdjacentTests::test_grouping</pre></summary><pre>
self = <tests.test_more.AdjacentTests testMethod=test_grouping>

    def test_grouping(self):
        """Test interaction of adjacent() with groupby_transform()"""
        iterable = mi.adjacent(lambda x: x % 5 == 0, range(10))
        grouper = mi.groupby_transform(iterable, itemgetter(0), itemgetter(1))
>       actual = [(k, list(g)) for k, g in grouper]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2398: TypeError
</pre>
</details>
<h3 id="test_morepyadjacentteststest_large_distance">test_more.py::AdjacentTests::test_large_distance</h3>
<details><summary> <pre>test_more.py::AdjacentTests::test_large_distance</pre></summary><pre>
self = <tests.test_more.AdjacentTests testMethod=test_large_distance>

    def test_large_distance(self):
        """Test distance larger than the length of the iterable"""
        iterable = range(10)
>       actual = list(mi.adjacent(lambda x: x % 5 == 4, iterable, distance=20))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2368: TypeError
</pre>
</details>
<h3 id="test_morepyadjacentteststest_length_one">test_more.py::AdjacentTests::test_length_one</h3>
<details><summary> <pre>test_more.py::AdjacentTests::test_length_one</pre></summary><pre>
self = <tests.test_more.AdjacentTests testMethod=test_length_one>

    def test_length_one(self):
>       actual = list(mi.adjacent(lambda x: x % 5 == 0, [0]))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2308: TypeError
</pre>
</details>
<h3 id="test_morepyadjacentteststest_negative_distance">test_more.py::AdjacentTests::test_negative_distance</h3>
<details><summary> <pre>test_more.py::AdjacentTests::test_negative_distance</pre></summary><pre>
self = <tests.test_more.AdjacentTests testMethod=test_negative_distance>

    def test_negative_distance(self):
        """Test that adjacent() raises an error with negative distance"""
        pred = lambda x: x
>       self.assertRaises(
            ValueError, lambda: mi.adjacent(pred, range(1000), -1)
        )
E       AssertionError: ValueError not raised by <lambda>

tests/test_more.py:2387: AssertionError
</pre>
</details>
<h3 id="test_morepyadjacentteststest_typical">test_more.py::AdjacentTests::test_typical</h3>
<details><summary> <pre>test_more.py::AdjacentTests::test_typical</pre></summary><pre>
self = <tests.test_more.AdjacentTests testMethod=test_typical>

    def test_typical(self):
>       actual = list(mi.adjacent(lambda x: x % 5 == 0, range(10)))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2287: TypeError
</pre>
</details>
<h3 id="test_morepyadjacentteststest_zero_distance">test_more.py::AdjacentTests::test_zero_distance</h3>
<details><summary> <pre>test_more.py::AdjacentTests::test_zero_distance</pre></summary><pre>
self = <tests.test_more.AdjacentTests testMethod=test_zero_distance>

    def test_zero_distance(self):
        """Test that adjacent() reduces to zip+map when distance is 0"""
        iterable = range(1000)
        predicate = lambda x: x % 4 == 2
        actual = mi.adjacent(predicate, iterable, 0)
        expected = zip(map(predicate, iterable), iterable)
>       self.assertTrue(all(a == e for a, e in zip(actual, expected)))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2382: TypeError
</pre>
</details>
<h3 id="test_morepygroupbytransformteststest_default_funcs">test_more.py::GroupByTransformTests::test_default_funcs</h3>
<details><summary> <pre>test_more.py::GroupByTransformTests::test_default_funcs</pre></summary><pre>
self = <tests.test_more.GroupByTransformTests testMethod=test_default_funcs>

    def test_default_funcs(self):
        iterable = [(x // 5, x) for x in range(1000)]
        actual = mi.groupby_transform(iterable)
        expected = groupby(iterable)
>       self.assertAllGroupsEqual(actual, expected)

tests/test_more.py:2436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_more.GroupByTransformTests testMethod=test_default_funcs>
groupby1 = None, groupby2 = <itertools.groupby object at 0x7fdd5408e3e0>

    def assertAllGroupsEqual(self, groupby1, groupby2):
>       for a, b in zip(groupby1, groupby2):
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2424: TypeError
</pre>
</details>
<h3 id="test_morepygroupbytransformteststest_no_valuefunc">test_more.py::GroupByTransformTests::test_no_valuefunc</h3>
<details><summary> <pre>test_more.py::GroupByTransformTests::test_no_valuefunc</pre></summary><pre>
self = <tests.test_more.GroupByTransformTests testMethod=test_no_valuefunc>

    def test_no_valuefunc(self):
        iterable = range(1000)

        def key(x):
            return x // 5

        actual = mi.groupby_transform(iterable, key, valuefunc=None)
        expected = groupby(iterable, key)
>       self.assertAllGroupsEqual(actual, expected)

tests/test_more.py:2473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_more.GroupByTransformTests testMethod=test_no_valuefunc>
groupby1 = None, groupby2 = <itertools.groupby object at 0x7fdd5408e860>

    def assertAllGroupsEqual(self, groupby1, groupby2):
>       for a, b in zip(groupby1, groupby2):
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2424: TypeError
</pre>
</details>
<h3 id="test_morepygroupbytransformteststest_reducefunc">test_more.py::GroupByTransformTests::test_reducefunc</h3>
<details><summary> <pre>test_more.py::GroupByTransformTests::test_reducefunc</pre></summary><pre>
self = <tests.test_more.GroupByTransformTests testMethod=test_reducefunc>

    def test_reducefunc(self):
        iterable = range(50)
        keyfunc = lambda k: 10 * (k // 10)
        valuefunc = lambda v: v + 1
        reducefunc = sum
>       actual = list(
            mi.groupby_transform(
                iterable,
                keyfunc=keyfunc,
                valuefunc=valuefunc,
                reducefunc=reducefunc,
            )
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2484: TypeError
</pre>
</details>
<h3 id="test_morepygroupbytransformteststest_valuefunc">test_more.py::GroupByTransformTests::test_valuefunc</h3>
<details><summary> <pre>test_more.py::GroupByTransformTests::test_valuefunc</pre></summary><pre>
self = <tests.test_more.GroupByTransformTests testMethod=test_valuefunc>

    def test_valuefunc(self):
        iterable = [(int(x / 5), int(x / 3), x) for x in range(10)]

        # Test the standard usage of grouping one iterable using another's keys
        grouper = mi.groupby_transform(
            iterable, keyfunc=itemgetter(0), valuefunc=itemgetter(-1)
        )
>       actual = [(k, list(g)) for k, g in grouper]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:2445: TypeError
</pre>
</details>
<h3 id="test_morepynumericrangeteststest_basic">test_more.py::NumericRangeTests::test_basic</h3>
<details><summary> <pre>test_more.py::NumericRangeTests::test_basic</pre></summary><pre>
self = <tests.test_more.NumericRangeTests testMethod=test_basic>

    def test_basic(self):
        for args, expected in [
            ((4,), [0, 1, 2, 3]),
            ((4.0,), [0.0, 1.0, 2.0, 3.0]),
            ((1.0, 4), [1.0, 2.0, 3.0]),
            ((1, 4.0), [1.0, 2.0, 3.0]),
            ((1.0, 5), [1.0, 2.0, 3.0, 4.0]),
            ((0, 20, 5), [0, 5, 10, 15]),
            ((0, 20, 5.0), [0.0, 5.0, 10.0, 15.0]),
            ((0, 10, 3), [0, 3, 6, 9]),
            ((0, 10, 3.0), [0.0, 3.0, 6.0, 9.0]),
            ((0, -5, -1), [0, -1, -2, -3, -4]),
            ((0.0, -5, -1), [0.0, -1.0, -2.0, -3.0, -4.0]),
            ((1, 2, Fraction(1, 2)), [Fraction(1, 1), Fraction(3, 2)]),
            ((0,), []),
            ((0.0,), []),
            ((1, 0), []),
            ((1.0, 0.0), []),
            ((0.1, 0.30000000000000001, 0.2), [0.1]),  # IEE 754 !
            (
                (
                    Decimal("0.1"),
                    Decimal("0.30000000000000001"),
                    Decimal("0.2"),
                ),
                [Decimal("0.1"), Decimal("0.3")],
            ),  # okay with Decimal
            (
                (
                    Fraction(1, 10),
                    Fraction(30000000000000001, 100000000000000000),
                    Fraction(2, 10),
                ),
                [Fraction(1, 10), Fraction(3, 10)],
            ),  # okay with Fraction
            ((Fraction(2, 1),), [Fraction(0, 1), Fraction(1, 1)]),
            ((Decimal('2.0'),), [Decimal('0.0'), Decimal('1.0')]),
            (
                (
                    datetime(2019, 3, 29, 12, 34, 56),
                    datetime(2019, 3, 29, 12, 37, 55),
                    timedelta(minutes=1),
                ),
                [
                    datetime(2019, 3, 29, 12, 34, 56),
                    datetime(2019, 3, 29, 12, 35, 56),
                    datetime(2019, 3, 29, 12, 36, 56),
                ],
            ),
        ]:
>           actual = list(mi.numeric_range(*args))

tests/test_more.py:2547: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = numeric_range(0, 4)

    def __len__(self):
>       return self._len
E       AttributeError: 'numeric_range' object has no attribute '_len'

more_itertools/more.py:1523: AttributeError
</pre>
</details>
<h3 id="test_morepynumericrangeteststest_eq">test_more.py::NumericRangeTests::test_eq</h3>
<details><summary> <pre>test_more.py::NumericRangeTests::test_eq</pre></summary><pre>
self = <tests.test_more.NumericRangeTests testMethod=test_eq>

    def test_eq(self):
        for args1, args2 in [
            ((0, 5, 2), (0, 6, 2)),
            ((1.0, 9.9, 1.5), (1.0, 8.6, 1.5)),
            ((8.5, 0.0, -1.5), (8.5, 0.7, -1.5)),
            ((7.0, 0.0, 1.0), (17.0, 7.0, 0.5)),
            (
                (Decimal("1.0"), Decimal("9.9"), Decimal("1.5")),
                (Decimal("1.0"), Decimal("8.6"), Decimal("1.5")),
            ),
            (
                (Fraction(1, 1), Fraction(10, 1), Fraction(3, 2)),
                (Fraction(1, 1), Fraction(9, 1), Fraction(3, 2)),
            ),
            (
                (
                    datetime(2019, 3, 29),
                    datetime(2019, 3, 30),
                    timedelta(hours=10),
                ),
                (
                    datetime(2019, 3, 29),
                    datetime(2019, 3, 30, 1),
                    timedelta(hours=10),
                ),
            ),
        ]:
>           self.assertEqual(
                mi.numeric_range(*args1), mi.numeric_range(*args2)
            )

tests/test_more.py:2680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = numeric_range(0, 5, 2), other = numeric_range(0, 6, 2)

    def __eq__(self, other):
        if isinstance(other, numeric_range):
            empty_self = not bool(self)
            empty_other = not bool(other)
            if empty_self or empty_other:
                return empty_self and empty_other
            else:
>               return self._start == other._start and self._step == other._step and (self._get_by_index(-1) == other._get_by_index(-1))
E               AttributeError: 'numeric_range' object has no attribute '_get_by_index'

more_itertools/more.py:1484: AttributeError
</pre>
</details>
<h3 id="test_morepynumericrangeteststest_get_item_by_index">test_more.py::NumericRangeTests::test_get_item_by_index</h3>
<details><summary> <pre>test_more.py::NumericRangeTests::test_get_item_by_index</pre></summary><pre>
self = <tests.test_more.NumericRangeTests testMethod=test_get_item_by_index>

    def test_get_item_by_index(self):
        for args, index, expected in [
            ((1, 6), 2, 3),
            ((1.0, 6.0, 1.5), 0, 1.0),
            ((1.0, 6.0, 1.5), 1, 2.5),
            ((1.0, 6.0, 1.5), 2, 4.0),
            ((1.0, 6.0, 1.5), 3, 5.5),
            ((1.0, 6.0, 1.5), -1, 5.5),
            ((1.0, 6.0, 1.5), -2, 4.0),
            (
                (Decimal("1.0"), Decimal("9.0"), Decimal("1.5")),
                -1,
                Decimal("8.5"),
            ),
            (
                (Fraction(1, 1), Fraction(10, 1), Fraction(3, 2)),
                2,
                Fraction(4, 1),
            ),
            (
                (
                    datetime(2019, 3, 29),
                    datetime(2019, 3, 30),
                    timedelta(hours=10),
                ),
                1,
                datetime(2019, 3, 29, 10),
            ),
        ]:
>           self.assertEqual(expected, mi.numeric_range(*args)[index])

tests/test_more.py:2750: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = numeric_range(1, 6), key = 2

    def __getitem__(self, key):
        if isinstance(key, int):
>           return self._get_by_index(key)
E           AttributeError: 'numeric_range' object has no attribute '_get_by_index'

more_itertools/more.py:1490: AttributeError
</pre>
</details>
<h3 id="test_morepynumericrangeteststest_get_item_by_slice">test_more.py::NumericRangeTests::test_get_item_by_slice</h3>
<details><summary> <pre>test_more.py::NumericRangeTests::test_get_item_by_slice</pre></summary><pre>
self = <tests.test_more.NumericRangeTests testMethod=test_get_item_by_slice>

    def test_get_item_by_slice(self):
        for args, sl, expected_args in [
            ((1.0, 9.0, 1.5), slice(None, None, None), (1.0, 9.0, 1.5)),
            ((1.0, 9.0, 1.5), slice(None, 1, None), (1.0, 2.5, 1.5)),
            ((1.0, 9.0, 1.5), slice(None, None, 2), (1.0, 9.0, 3.0)),
            ((1.0, 9.0, 1.5), slice(None, 2, None), (1.0, 4.0, 1.5)),
            ((1.0, 9.0, 1.5), slice(1, 2, None), (2.5, 4.0, 1.5)),
            ((1.0, 9.0, 1.5), slice(1, -1, None), (2.5, 8.5, 1.5)),
            ((1.0, 9.0, 1.5), slice(10, None, 3), (9.0, 9.0, 4.5)),
            ((1.0, 9.0, 1.5), slice(-10, None, 3), (1.0, 9.0, 4.5)),
            ((1.0, 9.0, 1.5), slice(None, -10, 3), (1.0, 1.0, 4.5)),
            ((1.0, 9.0, 1.5), slice(None, 10, 3), (1.0, 9.0, 4.5)),
            (
                (Decimal("1.0"), Decimal("9.0"), Decimal("1.5")),
                slice(1, -1, None),
                (Decimal("2.5"), Decimal("8.5"), Decimal("1.5")),
            ),
            (
                (Fraction(1, 1), Fraction(5, 1), Fraction(3, 2)),
                slice(1, -1, None),
                (Fraction(5, 2), Fraction(4, 1), Fraction(3, 2)),
            ),
            (
                (
                    datetime(2019, 3, 29),
                    datetime(2019, 3, 30),
                    timedelta(hours=10),
                ),
                slice(1, -1, None),
                (
                    datetime(2019, 3, 29, 10),
                    datetime(2019, 3, 29, 20),
                    timedelta(hours=10),
                ),
            ),
        ]:
>           self.assertEqual(
                mi.numeric_range(*expected_args), mi.numeric_range(*args)[sl]
            )

tests/test_more.py:2807: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = numeric_range(1.0, 9.0, 1.5), other = numeric_range(1.0, 9.0, 1.5)

    def __eq__(self, other):
        if isinstance(other, numeric_range):
            empty_self = not bool(self)
            empty_other = not bool(other)
            if empty_self or empty_other:
                return empty_self and empty_other
            else:
>               return self._start == other._start and self._step == other._step and (self._get_by_index(-1) == other._get_by_index(-1))
E               AttributeError: 'numeric_range' object has no attribute '_get_by_index'

more_itertools/more.py:1484: AttributeError
</pre>
</details>
<h3 id="test_morepynumericrangeteststest_hash">test_more.py::NumericRangeTests::test_hash</h3>
<details><summary> <pre>test_more.py::NumericRangeTests::test_hash</pre></summary><pre>
self = <tests.test_more.NumericRangeTests testMethod=test_hash>

    def test_hash(self):
        for args, expected in [
            ((1.0, 6.0, 1.5), hash((1.0, 5.5, 1.5))),
            ((1.0, 7.0, 1.5), hash((1.0, 5.5, 1.5))),
            ((1.0, 7.5, 1.5), hash((1.0, 7.0, 1.5))),
            ((1.0, 1.5, 1.5), hash((1.0, 1.0, 1.5))),
            ((1.5, 1.0, 1.5), hash(range(0, 0))),
            ((1.5, 1.5, 1.5), hash(range(0, 0))),
            (
                (Decimal("1.0"), Decimal("9.0"), Decimal("1.5")),
                hash((Decimal("1.0"), Decimal("8.5"), Decimal("1.5"))),
            ),
            (
                (Fraction(1, 1), Fraction(5, 1), Fraction(3, 2)),
                hash((Fraction(1, 1), Fraction(4, 1), Fraction(3, 2))),
            ),
            (
                (
                    datetime(2019, 3, 29),
                    datetime(2019, 3, 30),
                    timedelta(hours=10),
                ),
                hash(
                    (
                        datetime(2019, 3, 29),
                        datetime(2019, 3, 29, 20),
                        timedelta(hours=10),
                    )
                ),
            ),
        ]:
>           self.assertEqual(expected, hash(mi.numeric_range(*args)))

tests/test_more.py:2842: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = numeric_range(1.0, 6.0, 1.5)

    def __hash__(self):
        if self:
>           return hash((self._start, self._get_by_index(-1), self._step))
E           AttributeError: 'numeric_range' object has no attribute '_get_by_index'

more_itertools/more.py:1511: AttributeError
</pre>
</details>
<h3 id="test_morepynumericrangeteststest_index">test_more.py::NumericRangeTests::test_index</h3>
<details><summary> <pre>test_more.py::NumericRangeTests::test_index</pre></summary><pre>
self = <tests.test_more.NumericRangeTests testMethod=test_index>

    def test_index(self):
        for args, v, i in [
            ((7.0,), 0.0, 0),
            ((7.0,), 6.0, 6),
            ((7.0, 0.0, -1.0), 7.0, 0),
            ((7.0, 0.0, -1.0), 1.0, 6),
            (
                (Decimal("1.0"), Decimal("5.0"), Decimal("1.5")),
                Decimal('4.0'),
                2,
            ),
            (
                (Fraction(1, 1), Fraction(5, 1), Fraction(3, 2)),
                Fraction(5, 2),
                1,
            ),
            (
                (
                    datetime(2019, 3, 29),
                    datetime(2019, 3, 30),
                    timedelta(hours=10),
                ),
                datetime(2019, 3, 29, 20),
                2,
            ),
        ]:
>           self.assertEqual(i, mi.numeric_range(*args).index(v))

tests/test_more.py:3000: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<frozen _collections_abc>:1057: in index
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = numeric_range(0.0, 7.0), key = 0

    def __getitem__(self, key):
        if isinstance(key, int):
>           return self._get_by_index(key)
E           AttributeError: 'numeric_range' object has no attribute '_get_by_index'

more_itertools/more.py:1490: AttributeError
</pre>
</details>
<h3 id="test_morepynumericrangeteststest_iter_twice">test_more.py::NumericRangeTests::test_iter_twice</h3>
<details><summary> <pre>test_more.py::NumericRangeTests::test_iter_twice</pre></summary><pre>
self = <tests.test_more.NumericRangeTests testMethod=test_iter_twice>

    def test_iter_twice(self):
        r1 = mi.numeric_range(1.0, 9.9, 1.5)
        r2 = mi.numeric_range(8.5, 0.0, -1.5)
>       self.assertEqual([1.0, 2.5, 4.0, 5.5, 7.0, 8.5], list(r1))

tests/test_more.py:2847: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = numeric_range(1.0, 9.9, 1.5)

    def __len__(self):
>       return self._len
E       AttributeError: 'numeric_range' object has no attribute '_len'

more_itertools/more.py:1523: AttributeError
</pre>
</details>
<h3 id="test_morepynumericrangeteststest_len">test_more.py::NumericRangeTests::test_len</h3>
<details><summary> <pre>test_more.py::NumericRangeTests::test_len</pre></summary><pre>
self = <tests.test_more.NumericRangeTests testMethod=test_len>

    def test_len(self):
        for args, expected in [
            ((1.0, 7.0, 1.5), 4),
            ((1.0, 7.01, 1.5), 5),
            ((7.0, 1.0, -1.5), 4),
            ((7.01, 1.0, -1.5), 5),
            ((0.1, 0.30000000000000001, 0.2), 1),  # IEE 754 !
            (
                (
                    Decimal("0.1"),
                    Decimal("0.30000000000000001"),
                    Decimal("0.2"),
                ),
                2,
            ),  # works with Decimal
            ((Decimal("1.0"), Decimal("9.0"), Decimal("1.5")), 6),
            ((Fraction(1, 1), Fraction(5, 1), Fraction(3, 2)), 3),
            (
                (
                    datetime(2019, 3, 29),
                    datetime(2019, 3, 30),
                    timedelta(hours=10),
                ),
                3,
            ),
        ]:
>           self.assertEqual(expected, len(mi.numeric_range(*args)))

tests/test_more.py:2878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = numeric_range(1.0, 7.0, 1.5)

    def __len__(self):
>       return self._len
E       AttributeError: 'numeric_range' object has no attribute '_len'

more_itertools/more.py:1523: AttributeError
</pre>
</details>
<h3 id="test_morepynumericrangeteststest_pickle">test_more.py::NumericRangeTests::test_pickle</h3>
<details><summary> <pre>test_more.py::NumericRangeTests::test_pickle</pre></summary><pre>
self = <tests.test_more.NumericRangeTests testMethod=test_pickle>

    def test_pickle(self):
        for args in [
            (7.0,),
            (5.0, 7.0),
            (5.0, 7.0, 3.0),
            (7.0, 5.0),
            (7.0, 5.0, 4.0),
            (7.0, 5.0, -1.0),
            (Decimal("1.0"), Decimal("5.0"), Decimal("1.5")),
            (Fraction(1, 1), Fraction(5, 1), Fraction(3, 2)),
            (datetime(2019, 3, 29), datetime(2019, 3, 30)),
        ]:
            r = mi.numeric_range(*args)
            self.assertTrue(dumps(r))  # assert not empty
>           self.assertEqual(r, loads(dumps(r)))

tests/test_more.py:3057: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = numeric_range(0.0, 7.0), other = numeric_range(0.0, 7.0)

    def __eq__(self, other):
        if isinstance(other, numeric_range):
            empty_self = not bool(self)
            empty_other = not bool(other)
            if empty_self or empty_other:
                return empty_self and empty_other
            else:
>               return self._start == other._start and self._step == other._step and (self._get_by_index(-1) == other._get_by_index(-1))
E               AttributeError: 'numeric_range' object has no attribute '_get_by_index'

more_itertools/more.py:1484: AttributeError
</pre>
</details>
<h3 id="test_morepynumericrangeteststest_reversed">test_more.py::NumericRangeTests::test_reversed</h3>
<details><summary> <pre>test_more.py::NumericRangeTests::test_reversed</pre></summary><pre>
self = <tests.test_more.NumericRangeTests testMethod=test_reversed>

    def test_reversed(self):
        for args, expected in [
            ((7.0,), [6.0, 5.0, 4.0, 3.0, 2.0, 1.0, 0.0]),
            ((1.0, 7.0), [6.0, 5.0, 4.0, 3.0, 2.0, 1.0]),
            ((7.0, 1.0, -1.5), [2.5, 4.0, 5.5, 7.0]),
            ((7.0, 0.9, -1.5), [1.0, 2.5, 4.0, 5.5, 7.0]),
            (
                (Decimal("1.0"), Decimal("5.0"), Decimal("1.5")),
                [Decimal('4.0'), Decimal('2.5'), Decimal('1.0')],
            ),
            (
                (Fraction(1, 1), Fraction(5, 1), Fraction(3, 2)),
                [Fraction(4, 1), Fraction(5, 2), Fraction(1, 1)],
            ),
            (
                (
                    datetime(2019, 3, 29),
                    datetime(2019, 3, 30),
                    timedelta(hours=10),
                ),
                [
                    datetime(2019, 3, 29, 20),
                    datetime(2019, 3, 29, 10),
                    datetime(2019, 3, 29),
                ],
            ),
        ]:
>           self.assertEqual(expected, list(reversed(mi.numeric_range(*args))))

tests/test_more.py:2943: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = numeric_range(0.0, 7.0)

    def __reversed__(self):
>       return iter(numeric_range(self._get_by_index(-1), self._start - self._step, -self._step))
E       AttributeError: 'numeric_range' object has no attribute '_get_by_index'

more_itertools/more.py:1535: AttributeError
</pre>
</details>
<h3 id="test_morepycountcycleteststest_basic">test_more.py::CountCycleTests::test_basic</h3>
<details><summary> <pre>test_more.py::CountCycleTests::test_basic</pre></summary><pre>
self = <tests.test_more.CountCycleTests testMethod=test_basic>

    def test_basic(self):
        expected = [
            (0, 'a'),
            (0, 'b'),
            (0, 'c'),
            (1, 'a'),
            (1, 'b'),
            (1, 'c'),
            (2, 'a'),
            (2, 'b'),
            (2, 'c'),
        ]
        for actual in [
>           mi.take(9, mi.count_cycle('abc')),  # n=None
            list(mi.count_cycle('abc', 3)),  # n=3
        ]:

tests/test_more.py:3074: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

n = 9, iterable = None

    def take(n, iterable):
        """Return first *n* items of the iterable as a list.

            >>> take(3, range(10))
            [0, 1, 2]

        If there are fewer than *n* items in the iterable, all of them are
        returned.

            >>> take(10, range(3))
            [0, 1, 2]

        """
>       return list(islice(iterable, n))
E       TypeError: 'NoneType' object is not iterable

more_itertools/recipes.py:71: TypeError
</pre>
</details>
<h3 id="test_morepycountcycleteststest_empty">test_more.py::CountCycleTests::test_empty</h3>
<details><summary> <pre>test_more.py::CountCycleTests::test_empty</pre></summary><pre>
self = <tests.test_more.CountCycleTests testMethod=test_empty>

    def test_empty(self):
>       self.assertEqual(list(mi.count_cycle('')), [])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3080: TypeError
</pre>
</details>
<h3 id="test_morepycountcycleteststest_negative">test_more.py::CountCycleTests::test_negative</h3>
<details><summary> <pre>test_more.py::CountCycleTests::test_negative</pre></summary><pre>
self = <tests.test_more.CountCycleTests testMethod=test_negative>

    def test_negative(self):
>       self.assertEqual(list(mi.count_cycle('abc', -3)), [])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3084: TypeError
</pre>
</details>
<h3 id="test_morepymarkendsteststest_basic">test_more.py::MarkEndsTests::test_basic</h3>
<details><summary> <pre>test_more.py::MarkEndsTests::test_basic</pre></summary><pre>
self = <tests.test_more.MarkEndsTests testMethod=test_basic>

    def test_basic(self):
        for size, expected in [
            (0, []),
            (1, [(True, True, '0')]),
            (2, [(True, False, '0'), (False, True, '1')]),
            (3, [(True, False, '0'), (False, False, '1'), (False, True, '2')]),
            (
                4,
                [
                    (True, False, '0'),
                    (False, False, '1'),
                    (False, False, '2'),
                    (False, True, '3'),
                ],
            ),
        ]:
            with self.subTest(size=size):
                iterable = map(str, range(size))
>               actual = list(mi.mark_ends(iterable))
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:3106: TypeError
</pre>
</details>
<h3 id="test_morepylocateteststest_custom_pred">test_more.py::LocateTests::test_custom_pred</h3>
<details><summary> <pre>test_more.py::LocateTests::test_custom_pred</pre></summary><pre>
self = <tests.test_more.LocateTests testMethod=test_custom_pred>

    def test_custom_pred(self):
        iterable = ['0', 1, 1, '0', 1, '0', '0']
        pred = lambda x: x == '0'
>       actual = list(mi.locate(iterable, pred))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3126: TypeError
</pre>
</details>
<h3 id="test_morepylocateteststest_default_pred">test_more.py::LocateTests::test_default_pred</h3>
<details><summary> <pre>test_more.py::LocateTests::test_default_pred</pre></summary><pre>
self = <tests.test_more.LocateTests testMethod=test_default_pred>

    def test_default_pred(self):
        iterable = [0, 1, 1, 0, 1, 0, 0]
>       actual = list(mi.locate(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3113: TypeError
</pre>
</details>
<h3 id="test_morepylocateteststest_no_matches">test_more.py::LocateTests::test_no_matches</h3>
<details><summary> <pre>test_more.py::LocateTests::test_no_matches</pre></summary><pre>
self = <tests.test_more.LocateTests testMethod=test_no_matches>

    def test_no_matches(self):
        iterable = [0, 0, 0]
>       actual = list(mi.locate(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3119: TypeError
</pre>
</details>
<h3 id="test_morepylocateteststest_window_size">test_more.py::LocateTests::test_window_size</h3>
<details><summary> <pre>test_more.py::LocateTests::test_window_size</pre></summary><pre>
self = <tests.test_more.LocateTests testMethod=test_window_size>

    def test_window_size(self):
        iterable = ['0', 1, 1, '0', 1, '0', '0']
        pred = lambda *args: args == ('0', 1)
>       actual = list(mi.locate(iterable, pred, window_size=2))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3133: TypeError
</pre>
</details>
<h3 id="test_morepylocateteststest_window_size_large">test_more.py::LocateTests::test_window_size_large</h3>
<details><summary> <pre>test_more.py::LocateTests::test_window_size_large</pre></summary><pre>
self = <tests.test_more.LocateTests testMethod=test_window_size_large>

    def test_window_size_large(self):
        iterable = [1, 2, 3, 4]
        pred = lambda a, b, c, d, e: True
>       actual = list(mi.locate(iterable, pred, window_size=5))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3140: TypeError
</pre>
</details>
<h3 id="test_morepylocateteststest_window_size_zero">test_more.py::LocateTests::test_window_size_zero</h3>
<details><summary> <pre>test_more.py::LocateTests::test_window_size_zero</pre></summary><pre>
self = <tests.test_more.LocateTests testMethod=test_window_size_zero>

    def test_window_size_zero(self):
        iterable = [1, 2, 3, 4]
        pred = lambda: True
        with self.assertRaises(ValueError):
>           list(mi.locate(iterable, pred, window_size=0))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:3148: TypeError
</pre>
</details>
<h3 id="test_morepystripfunctionteststest_hashable">test_more.py::StripFunctionTests::test_hashable</h3>
<details><summary> <pre>test_more.py::StripFunctionTests::test_hashable</pre></summary><pre>
self = <tests.test_more.StripFunctionTests testMethod=test_hashable>

    def test_hashable(self):
        iterable = list('www.example.com')
        pred = lambda x: x in set('cmowz.')

>       self.assertEqual(list(mi.lstrip(iterable, pred)), list('example.com'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3156: TypeError
</pre>
</details>
<h3 id="test_morepystripfunctionteststest_math">test_more.py::StripFunctionTests::test_math</h3>
<details><summary> <pre>test_more.py::StripFunctionTests::test_math</pre></summary><pre>
self = <tests.test_more.StripFunctionTests testMethod=test_math>

    def test_math(self):
        iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2]
        pred = lambda x: x <= 2

>       self.assertEqual(list(mi.lstrip(iterable, pred)), iterable[3:])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3177: TypeError
</pre>
</details>
<h3 id="test_morepystripfunctionteststest_not_hashable">test_more.py::StripFunctionTests::test_not_hashable</h3>
<details><summary> <pre>test_more.py::StripFunctionTests::test_not_hashable</pre></summary><pre>
self = <tests.test_more.StripFunctionTests testMethod=test_not_hashable>

    def test_not_hashable(self):
        iterable = [
            list('http://'),
            list('www'),
            list('.example'),
            list('.com'),
        ]
        pred = lambda x: x in [list('http://'), list('www'), list('.com')]

>       self.assertEqual(list(mi.lstrip(iterable, pred)), iterable[2:])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3169: TypeError
</pre>
</details>
<h3 id="test_morepyisliceextendedteststest_all">test_more.py::IsliceExtendedTests::test_all</h3>
<details><summary> <pre>test_more.py::IsliceExtendedTests::test_all</pre></summary><pre>
self = <tests.test_more.IsliceExtendedTests testMethod=test_all>

    def test_all(self):
        iterable = ['0', '1', '2', '3', '4', '5']
        indexes = [*range(-4, 10), None]
        steps = [1, 2, 3, 4, -1, -2, -3, -4]
        for slice_args in product(indexes, indexes, steps):
            with self.subTest(slice_args=slice_args):
>               actual = list(mi.islice_extended(iterable, *slice_args))

tests/test_more.py:3189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <more_itertools.more.islice_extended object at 0x7fdd540ced20>
iterable = ['0', '1', '2', '3', '4', '5'], args = (-4, -4, 1)
it = <list_iterator object at 0x7fdd540cfc10>

    def __init__(self, iterable, *args):
        it = iter(iterable)
        if args:
>           self._iterable = _islice_helper(it, slice(*args))
E           NameError: name '_islice_helper' is not defined

more_itertools/more.py:1697: NameError
</pre>
</details>
<h3 id="test_morepyisliceextendedteststest_slicing">test_more.py::IsliceExtendedTests::test_slicing</h3>
<details><summary> <pre>test_more.py::IsliceExtendedTests::test_slicing</pre></summary><pre>
self = <tests.test_more.IsliceExtendedTests testMethod=test_slicing>

    def test_slicing(self):
        iterable = map(str, count())
>       first_slice = mi.islice_extended(iterable)[10:]

tests/test_more.py:3199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <more_itertools.more.islice_extended object at 0x7fdd540cd820>
key = slice(10, None, None)

    def __getitem__(self, key):
        if isinstance(key, slice):
>           return islice_extended(_islice_helper(self._iterable, key))
E           NameError: name '_islice_helper' is not defined

more_itertools/more.py:1709: NameError
</pre>
</details>
<h3 id="test_morepyisliceextendedteststest_slicing_extensive">test_more.py::IsliceExtendedTests::test_slicing_extensive</h3>
<details><summary> <pre>test_more.py::IsliceExtendedTests::test_slicing_extensive</pre></summary><pre>
self = <tests.test_more.IsliceExtendedTests testMethod=test_slicing_extensive>

    def test_slicing_extensive(self):
        iterable = range(10)
        options = (None, 1, 2, 7, -1)
        for start, stop, step in product(options, options, options):
            with self.subTest(slice_args=(start, stop, step)):
                sliced_tuple_0 = tuple(
>                   mi.islice_extended(iterable)[start:stop:step]
                )

tests/test_more.py:3210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <more_itertools.more.islice_extended object at 0x7fdd540cc770>
key = slice(None, None, None)

    def __getitem__(self, key):
        if isinstance(key, slice):
>           return islice_extended(_islice_helper(self._iterable, key))
E           NameError: name '_islice_helper' is not defined

more_itertools/more.py:1709: NameError
</pre>
</details>
<h3 id="test_morepyisliceextendedteststest_zero_step">test_more.py::IsliceExtendedTests::test_zero_step</h3>
<details><summary> <pre>test_more.py::IsliceExtendedTests::test_zero_step</pre></summary><pre>
self = <tests.test_more.IsliceExtendedTests testMethod=test_zero_step>

    def test_zero_step(self):
        with self.assertRaises(ValueError):
>           list(mi.islice_extended([1, 2, 3], 0, 1, 0))

tests/test_more.py:3195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def __init__(self, iterable, *args):
        it = iter(iterable)
        if args:
>           self._iterable = _islice_helper(it, slice(*args))
E           NameError: name '_islice_helper' is not defined

more_itertools/more.py:1697: NameError
</pre>
</details>
<h3 id="test_morepyconsecutivegroupstesttest_custom_ordering">test_more.py::ConsecutiveGroupsTest::test_custom_ordering</h3>
<details><summary> <pre>test_more.py::ConsecutiveGroupsTest::test_custom_ordering</pre></summary><pre>
self = <tests.test_more.ConsecutiveGroupsTest testMethod=test_custom_ordering>

    def test_custom_ordering(self):
        iterable = ['1', '10', '11', '20', '21', '22', '30', '31']
        ordering = lambda x: int(x)
>       actual = [list(g) for g in mi.consecutive_groups(iterable, ordering)]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3234: TypeError
</pre>
</details>
<h3 id="test_morepyconsecutivegroupstesttest_exotic_ordering">test_more.py::ConsecutiveGroupsTest::test_exotic_ordering</h3>
<details><summary> <pre>test_more.py::ConsecutiveGroupsTest::test_exotic_ordering</pre></summary><pre>
self = <tests.test_more.ConsecutiveGroupsTest testMethod=test_exotic_ordering>

    def test_exotic_ordering(self):
        iterable = [
            ('a', 'b', 'c', 'd'),
            ('a', 'c', 'b', 'd'),
            ('a', 'c', 'd', 'b'),
            ('a', 'd', 'b', 'c'),
            ('d', 'b', 'c', 'a'),
            ('d', 'c', 'a', 'b'),
        ]
        ordering = list(permutations('abcd')).index
>       actual = [list(g) for g in mi.consecutive_groups(iterable, ordering)]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3248: TypeError
</pre>
</details>
<h3 id="test_morepyconsecutivegroupstesttest_numbers">test_more.py::ConsecutiveGroupsTest::test_numbers</h3>
<details><summary> <pre>test_more.py::ConsecutiveGroupsTest::test_numbers</pre></summary><pre>
self = <tests.test_more.ConsecutiveGroupsTest testMethod=test_numbers>

    def test_numbers(self):
        iterable = [-10, -8, -7, -6, 1, 2, 4, 5, -1, 7]
>       actual = [list(g) for g in mi.consecutive_groups(iterable)]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3227: TypeError
</pre>
</details>
<h3 id="test_morepydifferencetesttest_custom">test_more.py::DifferenceTest::test_custom</h3>
<details><summary> <pre>test_more.py::DifferenceTest::test_custom</pre></summary><pre>
self = <tests.test_more.DifferenceTest testMethod=test_custom>

    def test_custom(self):
        iterable = [10, 20, 30, 40, 50]
>       actual = list(mi.difference(iterable, add))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3266: TypeError
</pre>
</details>
<h3 id="test_morepydifferencetesttest_empty">test_more.py::DifferenceTest::test_empty</h3>
<details><summary> <pre>test_more.py::DifferenceTest::test_empty</pre></summary><pre>
self = <tests.test_more.DifferenceTest testMethod=test_empty>

    def test_empty(self):
>       self.assertEqual(list(mi.difference([])), [])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3280: TypeError
</pre>
</details>
<h3 id="test_morepydifferencetesttest_initial">test_more.py::DifferenceTest::test_initial</h3>
<details><summary> <pre>test_more.py::DifferenceTest::test_initial</pre></summary><pre>
self = <tests.test_more.DifferenceTest testMethod=test_initial>

    def test_initial(self):
        original = list(range(100))
        accumulated = accumulate(original, initial=100)
>       actual = list(mi.difference(accumulated, initial=100))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3285: TypeError
</pre>
</details>
<h3 id="test_morepydifferencetesttest_normal">test_more.py::DifferenceTest::test_normal</h3>
<details><summary> <pre>test_more.py::DifferenceTest::test_normal</pre></summary><pre>
self = <tests.test_more.DifferenceTest testMethod=test_normal>

    def test_normal(self):
        iterable = [10, 20, 30, 40, 50]
>       actual = list(mi.difference(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3260: TypeError
</pre>
</details>
<h3 id="test_morepydifferencetesttest_one">test_more.py::DifferenceTest::test_one</h3>
<details><summary> <pre>test_more.py::DifferenceTest::test_one</pre></summary><pre>
self = <tests.test_more.DifferenceTest testMethod=test_one>

    def test_one(self):
>       self.assertEqual(list(mi.difference([0])), [0])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3277: TypeError
</pre>
</details>
<h3 id="test_morepydifferencetesttest_roundtrip">test_more.py::DifferenceTest::test_roundtrip</h3>
<details><summary> <pre>test_more.py::DifferenceTest::test_roundtrip</pre></summary><pre>
self = <tests.test_more.DifferenceTest testMethod=test_roundtrip>

    def test_roundtrip(self):
        original = list(range(100))
        accumulated = accumulate(original)
>       actual = list(mi.difference(accumulated))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3273: TypeError
</pre>
</details>
<h3 id="test_morepyseekabletesttest_elements">test_more.py::SeekableTest::test_elements</h3>
<details><summary> <pre>test_more.py::SeekableTest::test_elements</pre></summary><pre>
self = <tests.test_more.SeekableTest testMethod=test_elements>

    def test_elements(self):
        iterable = map(str, count())

        s = mi.seekable(iterable)
        mi.take(10, s)

>       elements = s.elements()
E       AttributeError: 'seekable' object has no attribute 'elements'

tests/test_more.py:3341: AttributeError
</pre>
</details>
<h3 id="test_morepyseekabletesttest_exhaustion_reset">test_more.py::SeekableTest::test_exhaustion_reset</h3>
<details><summary> <pre>test_more.py::SeekableTest::test_exhaustion_reset</pre></summary><pre>
self = <tests.test_more.SeekableTest testMethod=test_exhaustion_reset>

    def test_exhaustion_reset(self):
        iterable = [str(n) for n in range(10)]

        s = mi.seekable(iterable)
        self.assertEqual(list(s), iterable)  # Normal iteration
        self.assertEqual(list(s), [])  # Iterable is exhausted

>       s.seek(0)
E       AttributeError: 'seekable' object has no attribute 'seek'

tests/test_more.py:3299: AttributeError
</pre>
</details>
<h3 id="test_morepyseekabletesttest_forward">test_more.py::SeekableTest::test_forward</h3>
<details><summary> <pre>test_more.py::SeekableTest::test_forward</pre></summary><pre>
self = <tests.test_more.SeekableTest testMethod=test_forward>

    def test_forward(self):
        iterable = [str(n) for n in range(10)]

        s = mi.seekable(iterable)
        self.assertEqual(mi.take(1, s), iterable[:1])  # Normal iteration

>       s.seek(3)  # Skip over index 2
E       AttributeError: 'seekable' object has no attribute 'seek'

tests/test_more.py:3317: AttributeError
</pre>
</details>
<h3 id="test_morepyseekabletesttest_maxlen">test_more.py::SeekableTest::test_maxlen</h3>
<details><summary> <pre>test_more.py::SeekableTest::test_maxlen</pre></summary><pre>
self = <tests.test_more.SeekableTest testMethod=test_maxlen>

    def test_maxlen(self):
        iterable = map(str, count())

        s = mi.seekable(iterable, maxlen=4)
        self.assertEqual(mi.take(10, s), [str(n) for n in range(10)])
>       self.assertEqual(list(s.elements()), ['6', '7', '8', '9'])
E       AttributeError: 'seekable' object has no attribute 'elements'

tests/test_more.py:3355: AttributeError
</pre>
</details>
<h3 id="test_morepyseekabletesttest_maxlen_zero">test_more.py::SeekableTest::test_maxlen_zero</h3>
<details><summary> <pre>test_more.py::SeekableTest::test_maxlen_zero</pre></summary><pre>
self = <tests.test_more.SeekableTest testMethod=test_maxlen_zero>

    def test_maxlen_zero(self):
        iterable = [str(x) for x in range(5)]
        s = mi.seekable(iterable, maxlen=0)
        self.assertEqual(list(s), iterable)
>       self.assertEqual(list(s.elements()), [])
E       AttributeError: 'seekable' object has no attribute 'elements'

tests/test_more.py:3365: AttributeError
</pre>
</details>
<h3 id="test_morepyseekabletesttest_partial_reset">test_more.py::SeekableTest::test_partial_reset</h3>
<details><summary> <pre>test_more.py::SeekableTest::test_partial_reset</pre></summary><pre>
self = <tests.test_more.SeekableTest testMethod=test_partial_reset>

    def test_partial_reset(self):
        iterable = [str(n) for n in range(10)]

        s = mi.seekable(iterable)
        self.assertEqual(mi.take(5, s), iterable[:5])  # Normal iteration

>       s.seek(1)
E       AttributeError: 'seekable' object has no attribute 'seek'

tests/test_more.py:3308: AttributeError
</pre>
</details>
<h3 id="test_morepyseekabletesttest_past_end">test_more.py::SeekableTest::test_past_end</h3>
<details><summary> <pre>test_more.py::SeekableTest::test_past_end</pre></summary><pre>
self = <tests.test_more.SeekableTest testMethod=test_past_end>

    def test_past_end(self):
        iterable = [str(n) for n in range(10)]

        s = mi.seekable(iterable)
        self.assertEqual(mi.take(1, s), iterable[:1])  # Normal iteration

>       s.seek(20)
E       AttributeError: 'seekable' object has no attribute 'seek'

tests/test_more.py:3329: AttributeError
</pre>
</details>
<h3 id="test_morepyseekabletesttest_peek_default">test_more.py::SeekableTest::test_peek_default</h3>
<details><summary> <pre>test_more.py::SeekableTest::test_peek_default</pre></summary><pre>
self = <tests.test_more.SeekableTest testMethod=test_peek_default>

    def test_peek_default(self):
        """Make sure passing a default into ``peek()`` works."""
        p = self.cls([])
>       self.assertEqual(p.peek(7), 7)
E       AttributeError: 'seekable' object has no attribute 'peek'

tests/test_more.py:211: AttributeError
</pre>
</details>
<h3 id="test_morepyseekabletesttest_relative_seek">test_more.py::SeekableTest::test_relative_seek</h3>
<details><summary> <pre>test_more.py::SeekableTest::test_relative_seek</pre></summary><pre>
self = <tests.test_more.SeekableTest testMethod=test_relative_seek>

    def test_relative_seek(self):
        iterable = [str(x) for x in range(5)]
        s = mi.seekable(iterable)
>       s.relative_seek(2)
E       AttributeError: 'seekable' object has no attribute 'relative_seek'

tests/test_more.py:3370: AttributeError
</pre>
</details>
<h3 id="test_morepyseekabletesttest_simple_peeking">test_more.py::SeekableTest::test_simple_peeking</h3>
<details><summary> <pre>test_more.py::SeekableTest::test_simple_peeking</pre></summary><pre>
self = <tests.test_more.SeekableTest testMethod=test_simple_peeking>

    def test_simple_peeking(self):
        """Make sure ``next`` and ``peek`` advance and don't advance the
        iterator, respectively.

        """
        p = self.cls(range(10))
        self.assertEqual(next(p), 0)
>       self.assertEqual(p.peek(), 1)
E       AttributeError: 'seekable' object has no attribute 'peek'

tests/test_more.py:231: AttributeError
</pre>
</details>
<h3 id="test_morepyseekabletesttest_truthiness">test_more.py::SeekableTest::test_truthiness</h3>
<details><summary> <pre>test_more.py::SeekableTest::test_truthiness</pre></summary><pre>
self = <tests.test_more.SeekableTest testMethod=test_truthiness>

    def test_truthiness(self):
        """Make sure a ``peekable`` tests true iff there are items remaining in
        the iterable.

        """
        p = self.cls([])
>       self.assertFalse(p)

tests/test_more.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <more_itertools.more.seekable object at 0x7fdd540c8b60>

    def __bool__(self):
        try:
>           self.peek()
E           AttributeError: 'seekable' object has no attribute 'peek'

more_itertools/more.py:1973: AttributeError
</pre>
</details>
<h3 id="test_morepyrunlengthtesttest_decode">test_more.py::RunLengthTest::test_decode</h3>
<details><summary> <pre>test_more.py::RunLengthTest::test_decode</pre></summary><pre>
self = <tests.test_more.RunLengthTest testMethod=test_decode>

    def test_decode(self):
        iterable = [('d', 4), ('c', 3), ('b', 2), ('a', 1)]
>       actual = ''.join(mi.run_length.decode(iterable))
E       AttributeError: type object 'run_length' has no attribute 'decode'

tests/test_more.py:3448: AttributeError
</pre>
</details>
<h3 id="test_morepyrunlengthtesttest_encode">test_more.py::RunLengthTest::test_encode</h3>
<details><summary> <pre>test_more.py::RunLengthTest::test_encode</pre></summary><pre>
self = <tests.test_more.RunLengthTest testMethod=test_encode>

    def test_encode(self):
        iterable = (int(str(n)[0]) for n in count(800))
>       actual = mi.take(4, mi.run_length.encode(iterable))
E       AttributeError: type object 'run_length' has no attribute 'encode'

tests/test_more.py:3442: AttributeError
</pre>
</details>
<h3 id="test_morepyexactlynteststest_empty">test_more.py::ExactlyNTests::test_empty</h3>
<details><summary> <pre>test_more.py::ExactlyNTests::test_empty</pre></summary><pre>
self = <tests.test_more.ExactlyNTests testMethod=test_empty>

    def test_empty(self):
        """Return ``True`` if the iterable is empty and ``n`` is 0"""
>       self.assertTrue(mi.exactly_n([], 0))
E       AssertionError: None is not true

tests/test_more.py:3473: AssertionError
</pre>
</details>
<h3 id="test_morepyexactlynteststest_true">test_more.py::ExactlyNTests::test_true</h3>
<details><summary> <pre>test_more.py::ExactlyNTests::test_true</pre></summary><pre>
self = <tests.test_more.ExactlyNTests testMethod=test_true>

    def test_true(self):
        """Iterable has ``n`` ``True`` elements"""
>       self.assertTrue(mi.exactly_n([True, False, True], 2))
E       AssertionError: None is not true

tests/test_more.py:3458: AssertionError
</pre>
</details>
<h3 id="test_morepyalwaysreversibleteststest_nonseq_reversed">test_more.py::AlwaysReversibleTests::test_nonseq_reversed</h3>
<details><summary> <pre>test_more.py::AlwaysReversibleTests::test_nonseq_reversed</pre></summary><pre>
self = <tests.test_more.AlwaysReversibleTests testMethod=test_nonseq_reversed>

    def test_nonseq_reversed(self):
        # Create a non-reversible generator from a sequence
        with self.assertRaises(TypeError):
            reversed(x for x in range(10))

        self.assertEqual(
            list(reversed(range(10))),
>           list(mi.always_reversible(x for x in range(10))),
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3499: TypeError
</pre>
</details>
<h3 id="test_morepyalwaysreversibleteststest_regular_reversed">test_more.py::AlwaysReversibleTests::test_regular_reversed</h3>
<details><summary> <pre>test_more.py::AlwaysReversibleTests::test_regular_reversed</pre></summary><pre>
self = <tests.test_more.AlwaysReversibleTests testMethod=test_regular_reversed>

    def test_regular_reversed(self):
        self.assertEqual(
>           list(reversed(range(10))), list(mi.always_reversible(range(10)))
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3482: TypeError
</pre>
</details>
<h3 id="test_morepycircularshiftsteststest_duplicates">test_more.py::CircularShiftsTests::test_duplicates</h3>
<details><summary> <pre>test_more.py::CircularShiftsTests::test_duplicates</pre></summary><pre>
self = <tests.test_more.CircularShiftsTests testMethod=test_duplicates>

    def test_duplicates(self):
        # test non-distinct entries
        self.assertEqual(
>           list(mi.circular_shifts([0, 1, 0, 1])),
            [(0, 1, 0, 1), (1, 0, 1, 0), (0, 1, 0, 1), (1, 0, 1, 0)],
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3526: TypeError
</pre>
</details>
<h3 id="test_morepycircularshiftsteststest_empty">test_more.py::CircularShiftsTests::test_empty</h3>
<details><summary> <pre>test_more.py::CircularShiftsTests::test_empty</pre></summary><pre>
self = <tests.test_more.CircularShiftsTests testMethod=test_empty>

    def test_empty(self):
        # empty iterable -> empty list
>       self.assertEqual(list(mi.circular_shifts([])), [])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3514: TypeError
</pre>
</details>
<h3 id="test_morepycircularshiftsteststest_simple_circular_shifts">test_more.py::CircularShiftsTests::test_simple_circular_shifts</h3>
<details><summary> <pre>test_more.py::CircularShiftsTests::test_simple_circular_shifts</pre></summary><pre>
self = <tests.test_more.CircularShiftsTests testMethod=test_simple_circular_shifts>

    def test_simple_circular_shifts(self):
        # test the a simple iterator case
        self.assertEqual(
>           list(mi.circular_shifts(range(4))),
            [(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)],
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3519: TypeError
</pre>
</details>
<h3 id="test_morepycircularshiftsteststest_steps_negative">test_more.py::CircularShiftsTests::test_steps_negative</h3>
<details><summary> <pre>test_more.py::CircularShiftsTests::test_steps_negative</pre></summary><pre>
self = <tests.test_more.CircularShiftsTests testMethod=test_steps_negative>

    def test_steps_negative(self):
>       actual = list(mi.circular_shifts(range(5), steps=-2))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3542: TypeError
</pre>
</details>
<h3 id="test_morepycircularshiftsteststest_steps_positive">test_more.py::CircularShiftsTests::test_steps_positive</h3>
<details><summary> <pre>test_more.py::CircularShiftsTests::test_steps_positive</pre></summary><pre>
self = <tests.test_more.CircularShiftsTests testMethod=test_steps_positive>

    def test_steps_positive(self):
>       actual = list(mi.circular_shifts(range(5), steps=2))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3531: TypeError
</pre>
</details>
<h3 id="test_morepycircularshiftsteststest_steps_zero">test_more.py::CircularShiftsTests::test_steps_zero</h3>
<details><summary> <pre>test_more.py::CircularShiftsTests::test_steps_zero</pre></summary><pre>
self = <tests.test_more.CircularShiftsTests testMethod=test_steps_zero>

    def test_steps_zero(self):
        with self.assertRaises(ValueError):
>           list(mi.circular_shifts(range(5), steps=0))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:3554: TypeError
</pre>
</details>
<h3 id="test_morepymakedecoratorteststest_basic">test_more.py::MakeDecoratorTests::test_basic</h3>
<details><summary> <pre>test_more.py::MakeDecoratorTests::test_basic</pre></summary><pre>
self = <tests.test_more.MakeDecoratorTests testMethod=test_basic>

    def test_basic(self):
        slicer = mi.make_decorator(islice)

>       @slicer(1, 10, 2)
E       TypeError: 'NoneType' object is not callable

tests/test_more.py:3561: TypeError
</pre>
</details>
<h3 id="test_morepymakedecoratorteststest_result_index">test_more.py::MakeDecoratorTests::test_result_index</h3>
<details><summary> <pre>test_more.py::MakeDecoratorTests::test_result_index</pre></summary><pre>
self = <tests.test_more.MakeDecoratorTests testMethod=test_result_index>

    def test_result_index(self):
        def stringify(*args, **kwargs):
            self.assertEqual(args[0], 'arg_0')
            iterable = args[1]
            self.assertEqual(args[2], 'arg_2')
            self.assertEqual(kwargs['kwarg_1'], 'kwarg_1')
            return map(str, iterable)

        stringifier = mi.make_decorator(stringify, result_index=1)

>       @stringifier('arg_0', 'arg_2', kwarg_1='kwarg_1')
E       TypeError: 'NoneType' object is not callable

tests/test_more.py:3583: TypeError
</pre>
</details>
<h3 id="test_morepymakedecoratorteststest_wrap_class">test_more.py::MakeDecoratorTests::test_wrap_class</h3>
<details><summary> <pre>test_more.py::MakeDecoratorTests::test_wrap_class</pre></summary><pre>
self = <tests.test_more.MakeDecoratorTests testMethod=test_wrap_class>

    def test_wrap_class(self):
        seeker = mi.make_decorator(mi.seekable)

>       @seeker()
E       TypeError: 'NoneType' object is not callable

tests/test_more.py:3595: TypeError
</pre>
</details>
<h3 id="test_morepymapreduceteststest_default">test_more.py::MapReduceTests::test_default</h3>
<details><summary> <pre>test_more.py::MapReduceTests::test_default</pre></summary><pre>
self = <tests.test_more.MapReduceTests testMethod=test_default>

    def test_default(self):
        iterable = (str(x) for x in range(5))
        keyfunc = lambda x: int(x) // 2
>       actual = sorted(mi.map_reduce(iterable, keyfunc).items())
E       AttributeError: 'NoneType' object has no attribute 'items'

tests/test_more.py:3610: AttributeError
</pre>
</details>
<h3 id="test_morepymapreduceteststest_reducefunc">test_more.py::MapReduceTests::test_reducefunc</h3>
<details><summary> <pre>test_more.py::MapReduceTests::test_reducefunc</pre></summary><pre>
self = <tests.test_more.MapReduceTests testMethod=test_reducefunc>

    def test_reducefunc(self):
        iterable = (str(x) for x in range(5))
        keyfunc = lambda x: int(x) // 2
        valuefunc = int
        reducefunc = lambda value_list: reduce(mul, value_list, 1)
        actual = sorted(
>           mi.map_reduce(iterable, keyfunc, valuefunc, reducefunc).items()
        )
E       AttributeError: 'NoneType' object has no attribute 'items'

tests/test_more.py:3628: AttributeError
</pre>
</details>
<h3 id="test_morepymapreduceteststest_ret">test_more.py::MapReduceTests::test_ret</h3>
<details><summary> <pre>test_more.py::MapReduceTests::test_ret</pre></summary><pre>
self = <tests.test_more.MapReduceTests testMethod=test_ret>

    def test_ret(self):
        d = mi.map_reduce([1, 0, 2, 0, 1, 0], bool)
>       self.assertEqual(d, {False: [0, 0, 0], True: [1, 2, 1]})
E       AssertionError: None != {False: [0, 0, 0], True: [1, 2, 1]}

tests/test_more.py:3635: AssertionError
</pre>
</details>
<h3 id="test_morepymapreduceteststest_valuefunc">test_more.py::MapReduceTests::test_valuefunc</h3>
<details><summary> <pre>test_more.py::MapReduceTests::test_valuefunc</pre></summary><pre>
self = <tests.test_more.MapReduceTests testMethod=test_valuefunc>

    def test_valuefunc(self):
        iterable = (str(x) for x in range(5))
        keyfunc = lambda x: int(x) // 2
        valuefunc = int
>       actual = sorted(mi.map_reduce(iterable, keyfunc, valuefunc).items())
E       AttributeError: 'NoneType' object has no attribute 'items'

tests/test_more.py:3618: AttributeError
</pre>
</details>
<h3 id="test_morepyrlocateteststest_custom_pred">test_more.py::RlocateTests::test_custom_pred</h3>
<details><summary> <pre>test_more.py::RlocateTests::test_custom_pred</pre></summary><pre>
self = <tests.test_more.RlocateTests testMethod=test_custom_pred>

    def test_custom_pred(self):
        iterable = ['0', 1, 1, '0', 1, '0', '0']
        pred = lambda x: x == '0'
        for it in (iterable[:], iter(iterable)):
>           actual = list(mi.rlocate(it, pred))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:3658: TypeError
</pre>
</details>
<h3 id="test_morepyrlocateteststest_default_pred">test_more.py::RlocateTests::test_default_pred</h3>
<details><summary> <pre>test_more.py::RlocateTests::test_default_pred</pre></summary><pre>
self = <tests.test_more.RlocateTests testMethod=test_default_pred>

    def test_default_pred(self):
        iterable = [0, 1, 1, 0, 1, 0, 0]
        for it in (iterable[:], iter(iterable)):
>           actual = list(mi.rlocate(it))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:3643: TypeError
</pre>
</details>
<h3 id="test_morepyrlocateteststest_efficient_reversal">test_more.py::RlocateTests::test_efficient_reversal</h3>
<details><summary> <pre>test_more.py::RlocateTests::test_efficient_reversal</pre></summary><pre>
self = <tests.test_more.RlocateTests testMethod=test_efficient_reversal>

    def test_efficient_reversal(self):
        iterable = range(9**9)  # Is efficiently reversible
        target = 9**9 - 2
        pred = lambda x: x == target  # Find-able from the right
>       actual = next(mi.rlocate(iterable, pred))
E       TypeError: 'NoneType' object is not an iterator

tests/test_more.py:3666: TypeError
</pre>
</details>
<h3 id="test_morepyrlocateteststest_no_matches">test_more.py::RlocateTests::test_no_matches</h3>
<details><summary> <pre>test_more.py::RlocateTests::test_no_matches</pre></summary><pre>
self = <tests.test_more.RlocateTests testMethod=test_no_matches>

    def test_no_matches(self):
        iterable = [0, 0, 0]
        for it in (iterable[:], iter(iterable)):
>           actual = list(mi.rlocate(it))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:3650: TypeError
</pre>
</details>
<h3 id="test_morepyrlocateteststest_window_size">test_more.py::RlocateTests::test_window_size</h3>
<details><summary> <pre>test_more.py::RlocateTests::test_window_size</pre></summary><pre>
self = <tests.test_more.RlocateTests testMethod=test_window_size>

    def test_window_size(self):
        iterable = ['0', 1, 1, '0', 1, '0', '0']
        pred = lambda *args: args == ('0', 1)
        for it in (iterable, iter(iterable)):
>           actual = list(mi.rlocate(it, pred, window_size=2))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:3673: TypeError
</pre>
</details>
<h3 id="test_morepyrlocateteststest_window_size_large">test_more.py::RlocateTests::test_window_size_large</h3>
<details><summary> <pre>test_more.py::RlocateTests::test_window_size_large</pre></summary><pre>
self = <tests.test_more.RlocateTests testMethod=test_window_size_large>

    def test_window_size_large(self):
        iterable = [1, 2, 3, 4]
        pred = lambda a, b, c, d, e: True
        for it in (iterable, iter(iterable)):
>           actual = list(mi.rlocate(iterable, pred, window_size=5))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:3681: TypeError
</pre>
</details>
<h3 id="test_morepyrlocateteststest_window_size_zero">test_more.py::RlocateTests::test_window_size_zero</h3>
<details><summary> <pre>test_more.py::RlocateTests::test_window_size_zero</pre></summary><pre>
self = <tests.test_more.RlocateTests testMethod=test_window_size_zero>

    def test_window_size_zero(self):
        iterable = [1, 2, 3, 4]
        pred = lambda: True
        for it in (iterable, iter(iterable)):
            with self.assertRaises(ValueError):
>               list(mi.locate(iterable, pred, window_size=0))
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:3690: TypeError
</pre>
</details>
<h3 id="test_morepyreplaceteststest_basic">test_more.py::ReplaceTests::test_basic</h3>
<details><summary> <pre>test_more.py::ReplaceTests::test_basic</pre></summary><pre>
self = <tests.test_more.ReplaceTests testMethod=test_basic>

    def test_basic(self):
        iterable = range(10)
        pred = lambda x: x % 2 == 0
        substitutes = []
>       actual = list(mi.replace(iterable, pred, substitutes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3698: TypeError
</pre>
</details>
<h3 id="test_morepyreplaceteststest_count">test_more.py::ReplaceTests::test_count</h3>
<details><summary> <pre>test_more.py::ReplaceTests::test_count</pre></summary><pre>
self = <tests.test_more.ReplaceTests testMethod=test_count>

    def test_count(self):
        iterable = range(10)
        pred = lambda x: x % 2 == 0
        substitutes = []
>       actual = list(mi.replace(iterable, pred, substitutes, count=4))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3706: TypeError
</pre>
</details>
<h3 id="test_morepyreplaceteststest_iterable_substitutes">test_more.py::ReplaceTests::test_iterable_substitutes</h3>
<details><summary> <pre>test_more.py::ReplaceTests::test_iterable_substitutes</pre></summary><pre>
self = <tests.test_more.ReplaceTests testMethod=test_iterable_substitutes>

    def test_iterable_substitutes(self):
        iterable = range(5)
        pred = lambda x: x % 2 == 0
        substitutes = iter('__')
>       actual = list(mi.replace(iterable, pred, substitutes))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3755: TypeError
</pre>
</details>
<h3 id="test_morepyreplaceteststest_window_size">test_more.py::ReplaceTests::test_window_size</h3>
<details><summary> <pre>test_more.py::ReplaceTests::test_window_size</pre></summary><pre>
self = <tests.test_more.ReplaceTests testMethod=test_window_size>

    def test_window_size(self):
        iterable = range(10)
        pred = lambda *args: args == (0, 1, 2)
        substitutes = []
>       actual = list(mi.replace(iterable, pred, substitutes, window_size=3))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3714: TypeError
</pre>
</details>
<h3 id="test_morepyreplaceteststest_window_size_count">test_more.py::ReplaceTests::test_window_size_count</h3>
<details><summary> <pre>test_more.py::ReplaceTests::test_window_size_count</pre></summary><pre>
self = <tests.test_more.ReplaceTests testMethod=test_window_size_count>

    def test_window_size_count(self):
        iterable = range(10)
        pred = lambda *args: (args == (0, 1, 2)) or (args == (7, 8, 9))
        substitutes = []
>       actual = list(
            mi.replace(iterable, pred, substitutes, count=1, window_size=3)
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3730: TypeError
</pre>
</details>
<h3 id="test_morepyreplaceteststest_window_size_end">test_more.py::ReplaceTests::test_window_size_end</h3>
<details><summary> <pre>test_more.py::ReplaceTests::test_window_size_end</pre></summary><pre>
self = <tests.test_more.ReplaceTests testMethod=test_window_size_end>

    def test_window_size_end(self):
        iterable = range(10)
        pred = lambda *args: args == (7, 8, 9)
        substitutes = []
>       actual = list(mi.replace(iterable, pred, substitutes, window_size=3))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3722: TypeError
</pre>
</details>
<h3 id="test_morepyreplaceteststest_window_size_large">test_more.py::ReplaceTests::test_window_size_large</h3>
<details><summary> <pre>test_more.py::ReplaceTests::test_window_size_large</pre></summary><pre>
self = <tests.test_more.ReplaceTests testMethod=test_window_size_large>

    def test_window_size_large(self):
        iterable = range(4)
        pred = lambda a, b, c, d, e: True
        substitutes = [5, 6, 7]
>       actual = list(mi.replace(iterable, pred, substitutes, window_size=5))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3740: TypeError
</pre>
</details>
<h3 id="test_morepyreplaceteststest_window_size_zero">test_more.py::ReplaceTests::test_window_size_zero</h3>
<details><summary> <pre>test_more.py::ReplaceTests::test_window_size_zero</pre></summary><pre>
self = <tests.test_more.ReplaceTests testMethod=test_window_size_zero>

    def test_window_size_zero(self):
        iterable = range(10)
        pred = lambda *args: True
        substitutes = []
        with self.assertRaises(ValueError):
>           list(mi.replace(iterable, pred, substitutes, window_size=0))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:3749: TypeError
</pre>
</details>
<h3 id="test_morepypartitionstesttest_duplicates">test_more.py::PartitionsTest::test_duplicates</h3>
<details><summary> <pre>test_more.py::PartitionsTest::test_duplicates</pre></summary><pre>
self = <tests.test_more.PartitionsTest testMethod=test_duplicates>

    def test_duplicates(self):
        iterable = [1, 1, 1]
>       actual = list(mi.partitions(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3791: TypeError
</pre>
</details>
<h3 id="test_morepypartitionstesttest_empty">test_more.py::PartitionsTest::test_empty</h3>
<details><summary> <pre>test_more.py::PartitionsTest::test_empty</pre></summary><pre>
self = <tests.test_more.PartitionsTest testMethod=test_empty>

    def test_empty(self):
        iterable = []
>       actual = list(mi.partitions(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3779: TypeError
</pre>
</details>
<h3 id="test_morepypartitionstesttest_order">test_more.py::PartitionsTest::test_order</h3>
<details><summary> <pre>test_more.py::PartitionsTest::test_order</pre></summary><pre>
self = <tests.test_more.PartitionsTest testMethod=test_order>

    def test_order(self):
        iterable = iter([3, 2, 1])
>       actual = list(mi.partitions(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3785: TypeError
</pre>
</details>
<h3 id="test_morepypartitionstesttest_types">test_more.py::PartitionsTest::test_types</h3>
<details><summary> <pre>test_more.py::PartitionsTest::test_types</pre></summary><pre>
self = <tests.test_more.PartitionsTest testMethod=test_types>

    def test_types(self):
        for iterable in ['abcd', ['a', 'b', 'c', 'd'], ('a', 'b', 'c', 'd')]:
            with self.subTest(iterable=iterable):
>               actual = list(mi.partitions(iterable))
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:3764: TypeError
</pre>
</details>
<h3 id="test_morepysetpartitionsteststest_duplicates">test_more.py::SetPartitionsTests::test_duplicates</h3>
<details><summary> <pre>test_more.py::SetPartitionsTests::test_duplicates</pre></summary><pre>
self = <tests.test_more.SetPartitionsTests testMethod=test_duplicates>

    def test_duplicates(self):
        a = set(range(6))
>       for p in mi.set_partitions(a):
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3878: TypeError
</pre>
</details>
<h3 id="test_morepysetpartitionsteststest_each_correct">test_more.py::SetPartitionsTests::test_each_correct</h3>
<details><summary> <pre>test_more.py::SetPartitionsTests::test_each_correct</pre></summary><pre>
self = <tests.test_more.SetPartitionsTests testMethod=test_each_correct>

    def test_each_correct(self):
        a = set(range(6))
>       for p in mi.set_partitions(a):
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3872: TypeError
</pre>
</details>
<h3 id="test_morepysetpartitionsteststest_found_all">test_more.py::SetPartitionsTests::test_found_all</h3>
<details><summary> <pre>test_more.py::SetPartitionsTests::test_found_all</pre></summary><pre>
self = <tests.test_more.SetPartitionsTests testMethod=test_found_all>

    def test_found_all(self):
        """small example, hand-checked"""
        expected = [
            [[0], [1], [2, 3, 4]],
            [[0], [1, 2], [3, 4]],
            [[0], [2], [1, 3, 4]],
            [[0], [3], [1, 2, 4]],
            [[0], [4], [1, 2, 3]],
            [[0], [1, 3], [2, 4]],
            [[0], [1, 4], [2, 3]],
            [[1], [2], [0, 3, 4]],
            [[1], [3], [0, 2, 4]],
            [[1], [4], [0, 2, 3]],
            [[1], [0, 2], [3, 4]],
            [[1], [0, 3], [2, 4]],
            [[1], [0, 4], [2, 3]],
            [[2], [3], [0, 1, 4]],
            [[2], [4], [0, 1, 3]],
            [[2], [0, 1], [3, 4]],
            [[2], [0, 3], [1, 4]],
            [[2], [0, 4], [1, 3]],
            [[3], [4], [0, 1, 2]],
            [[3], [0, 1], [2, 4]],
            [[3], [0, 2], [1, 4]],
            [[3], [0, 4], [1, 2]],
            [[4], [0, 1], [2, 3]],
            [[4], [0, 2], [1, 3]],
            [[4], [0, 3], [1, 2]],
        ]
        actual = mi.set_partitions(range(5), 3)
        self.assertEqual(
            self._normalize_partitions(expected),
>           self._normalize_partitions(actual),
        )

tests/test_more.py:3913: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ps = None

    @staticmethod
    def _normalize_partitions(ps):
        """
        Return a normalized set of all normalized partitions using
        _FrozenMultiset
        """
        return _FrozenMultiset(
>           SetPartitionsTests._normalize_partition(p) for p in ps
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3858: TypeError
</pre>
</details>
<h3 id="test_morepysetpartitionsteststest_max_size">test_more.py::SetPartitionsTests::test_max_size</h3>
<details><summary> <pre>test_more.py::SetPartitionsTests::test_max_size</pre></summary><pre>
self = <tests.test_more.SetPartitionsTests testMethod=test_max_size>

    def test_max_size(self):
        it = 'abc'
        actual = mi.set_partitions(it, max_size=2)
        expected = [['a', 'bc'], ['ab', 'c'], ['b', 'ac'], ['a', 'b', 'c']]
        self.assertEqual(
            self._normalize_partitions(expected),
>           self._normalize_partitions(actual),
        )

tests/test_more.py:3957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ps = None

    @staticmethod
    def _normalize_partitions(ps):
        """
        Return a normalized set of all normalized partitions using
        _FrozenMultiset
        """
        return _FrozenMultiset(
>           SetPartitionsTests._normalize_partition(p) for p in ps
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3858: TypeError
</pre>
</details>
<h3 id="test_morepysetpartitionsteststest_min_size">test_more.py::SetPartitionsTests::test_min_size</h3>
<details><summary> <pre>test_more.py::SetPartitionsTests::test_min_size</pre></summary><pre>
self = <tests.test_more.SetPartitionsTests testMethod=test_min_size>

    def test_min_size(self):
        it = 'abc'
        actual = mi.set_partitions(it, min_size=2)
        expected = [['abc']]
        self.assertEqual(
            self._normalize_partitions(expected),
>           self._normalize_partitions(actual),
        )

tests/test_more.py:3948: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ps = None

    @staticmethod
    def _normalize_partitions(ps):
        """
        Return a normalized set of all normalized partitions using
        _FrozenMultiset
        """
        return _FrozenMultiset(
>           SetPartitionsTests._normalize_partition(p) for p in ps
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3858: TypeError
</pre>
</details>
<h3 id="test_morepysetpartitionsteststest_no_group">test_more.py::SetPartitionsTests::test_no_group</h3>
<details><summary> <pre>test_more.py::SetPartitionsTests::test_no_group</pre></summary><pre>
self = <tests.test_more.SetPartitionsTests testMethod=test_no_group>

    def test_no_group(self):
        def helper():
            list(mi.set_partitions(range(4), -1))

>       self.assertRaises(ValueError, helper)

tests/test_more.py:3937: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def helper():
>       list(mi.set_partitions(range(4), -1))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3935: TypeError
</pre>
</details>
<h3 id="test_morepysetpartitionsteststest_repeated">test_more.py::SetPartitionsTests::test_repeated</h3>
<details><summary> <pre>test_more.py::SetPartitionsTests::test_repeated</pre></summary><pre>
self = <tests.test_more.SetPartitionsTests testMethod=test_repeated>

    def test_repeated(self):
        it = 'aaa'
        actual = mi.set_partitions(it, 2)
        expected = [['a', 'aa'], ['a', 'aa'], ['a', 'aa']]
        self.assertEqual(
            self._normalize_partitions(expected),
>           self._normalize_partitions(actual),
        )

tests/test_more.py:3867: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ps = None

    @staticmethod
    def _normalize_partitions(ps):
        """
        Return a normalized set of all normalized partitions using
        _FrozenMultiset
        """
        return _FrozenMultiset(
>           SetPartitionsTests._normalize_partition(p) for p in ps
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3858: TypeError
</pre>
</details>
<h3 id="test_morepysetpartitionsteststest_stirling_numbers">test_more.py::SetPartitionsTests::test_stirling_numbers</h3>
<details><summary> <pre>test_more.py::SetPartitionsTests::test_stirling_numbers</pre></summary><pre>
self = <tests.test_more.SetPartitionsTests testMethod=test_stirling_numbers>

    def test_stirling_numbers(self):
        """Check against https://en.wikipedia.org/wiki/
        Stirling_numbers_of_the_second_kind#Table_of_values"""
        cardinality_by_k_by_n = [
            [1],
            [1, 1],
            [1, 3, 1],
            [1, 7, 6, 1],
            [1, 15, 25, 10, 1],
            [1, 31, 90, 65, 15, 1],
        ]
        for n, cardinality_by_k in enumerate(cardinality_by_k_by_n, 1):
            for k, cardinality in enumerate(cardinality_by_k, 1):
                self.assertEqual(
>                   cardinality, len(list(mi.set_partitions(range(n), k)))
                )
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:3930: TypeError
</pre>
</details>
<h3 id="test_morepysetpartitionsteststest_to_many_groups">test_more.py::SetPartitionsTests::test_to_many_groups</h3>
<details><summary> <pre>test_more.py::SetPartitionsTests::test_to_many_groups</pre></summary><pre>
self = <tests.test_more.SetPartitionsTests testMethod=test_to_many_groups>

    def test_to_many_groups(self):
>       self.assertEqual([], list(mi.set_partitions(range(4), 5)))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:3940: TypeError
</pre>
</details>
<h3 id="test_morepyonlyteststest_custom_exception">test_more.py::OnlyTests::test_custom_exception</h3>
<details><summary> <pre>test_more.py::OnlyTests::test_custom_exception</pre></summary><pre>
self = <tests.test_more.OnlyTests testMethod=test_custom_exception>

    def test_custom_exception(self):
        self.assertEqual(mi.only([], too_long=RuntimeError), None)
>       self.assertEqual(mi.only([1], too_long=RuntimeError), 1)
E       AssertionError: None != 1

tests/test_more.py:4007: AssertionError
</pre>
</details>
<h3 id="test_morepyonlyteststest_custom_value">test_more.py::OnlyTests::test_custom_value</h3>
<details><summary> <pre>test_more.py::OnlyTests::test_custom_value</pre></summary><pre>
self = <tests.test_more.OnlyTests testMethod=test_custom_value>

    def test_custom_value(self):
>       self.assertEqual(mi.only([], default='!'), '!')
E       AssertionError: None != '!'

tests/test_more.py:4001: AssertionError
</pre>
</details>
<h3 id="test_morepyonlyteststest_default_exception_message">test_more.py::OnlyTests::test_default_exception_message</h3>
<details><summary> <pre>test_more.py::OnlyTests::test_default_exception_message</pre></summary><pre>
self = <tests.test_more.OnlyTests testMethod=test_default_exception_message>

    def test_default_exception_message(self):
>       self.assertRaisesRegex(
            ValueError,
            "Expected exactly one item in iterable, "
            "but got 'foo', 'bar', and perhaps more",
            lambda: mi.only(['foo', 'bar', 'baz']),
        )
E       AssertionError: ValueError not raised by <lambda>

tests/test_more.py:4013: AssertionError
</pre>
</details>
<h3 id="test_morepyonlyteststest_defaults">test_more.py::OnlyTests::test_defaults</h3>
<details><summary> <pre>test_more.py::OnlyTests::test_defaults</pre></summary><pre>
self = <tests.test_more.OnlyTests testMethod=test_defaults>

    def test_defaults(self):
        self.assertEqual(mi.only([]), None)
>       self.assertEqual(mi.only([1]), 1)
E       AssertionError: None != 1

tests/test_more.py:3997: AssertionError
</pre>
</details>
<h3 id="test_morepyichunkedteststest_even">test_more.py::IchunkedTests::test_even</h3>
<details><summary> <pre>test_more.py::IchunkedTests::test_even</pre></summary><pre>
self = <tests.test_more.IchunkedTests testMethod=test_even>

    def test_even(self):
        iterable = (str(x) for x in range(10))
>       actual = [''.join(c) for c in mi.ichunked(iterable, 5)]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4024: TypeError
</pre>
</details>
<h3 id="test_morepyichunkedteststest_laziness">test_more.py::IchunkedTests::test_laziness</h3>
<details><summary> <pre>test_more.py::IchunkedTests::test_laziness</pre></summary><pre>
self = <tests.test_more.IchunkedTests testMethod=test_laziness>

    def test_laziness(self):
        def gen():
            yield 0
            raise RuntimeError
            yield from count(1)

        it = mi.ichunked(gen(), 4)
>       chunk = next(it)
E       TypeError: 'NoneType' object is not an iterator

tests/test_more.py:4060: TypeError
</pre>
</details>
<h3 id="test_morepyichunkedteststest_memory_in_order">test_more.py::IchunkedTests::test_memory_in_order</h3>
<details><summary> <pre>test_more.py::IchunkedTests::test_memory_in_order</pre></summary><pre>
self = <tests.test_more.IchunkedTests testMethod=test_memory_in_order>

    def test_memory_in_order(self):
        gen_numbers = []

        def gen():
            for gen_number in count():
                gen_numbers.append(gen_number)
                yield gen_number

        # No items should be kept in memory when a ichunked is first called
        all_chunks = mi.ichunked(gen(), 4)
        self.assertEqual(gen_numbers, [])

        # The first item of each chunk should be generated on chunk generation
>       first_chunk = next(all_chunks)
E       TypeError: 'NoneType' object is not an iterator

tests/test_more.py:4077: TypeError
</pre>
</details>
<h3 id="test_morepyichunkedteststest_negative">test_more.py::IchunkedTests::test_negative</h3>
<details><summary> <pre>test_more.py::IchunkedTests::test_negative</pre></summary><pre>
self = <tests.test_more.IchunkedTests testMethod=test_negative>

    def test_negative(self):
        iterable = count()
        with self.assertRaises(ValueError):
>           [list(c) for c in mi.ichunked(iterable, -1)]
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:4043: TypeError
</pre>
</details>
<h3 id="test_morepyichunkedteststest_odd">test_more.py::IchunkedTests::test_odd</h3>
<details><summary> <pre>test_more.py::IchunkedTests::test_odd</pre></summary><pre>
self = <tests.test_more.IchunkedTests testMethod=test_odd>

    def test_odd(self):
        iterable = (str(x) for x in range(10))
>       actual = [''.join(c) for c in mi.ichunked(iterable, 4)]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4030: TypeError
</pre>
</details>
<h3 id="test_morepyichunkedteststest_out_of_order">test_more.py::IchunkedTests::test_out_of_order</h3>
<details><summary> <pre>test_more.py::IchunkedTests::test_out_of_order</pre></summary><pre>
self = <tests.test_more.IchunkedTests testMethod=test_out_of_order>

    def test_out_of_order(self):
        iterable = map(str, count())
        it = mi.ichunked(iterable, 4)
>       chunk_1 = next(it)
E       TypeError: 'NoneType' object is not an iterator

tests/test_more.py:4048: TypeError
</pre>
</details>
<h3 id="test_morepyichunkedteststest_zero">test_more.py::IchunkedTests::test_zero</h3>
<details><summary> <pre>test_more.py::IchunkedTests::test_zero</pre></summary><pre>
self = <tests.test_more.IchunkedTests testMethod=test_zero>

    def test_zero(self):
        iterable = []
>       actual = [list(c) for c in mi.ichunked(iterable, 0)]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4036: TypeError
</pre>
</details>
<h3 id="test_morepydistinctcombinationsteststest_basic">test_more.py::DistinctCombinationsTests::test_basic</h3>
<details><summary> <pre>test_more.py::DistinctCombinationsTests::test_basic</pre></summary><pre>
self = <tests.test_more.DistinctCombinationsTests testMethod=test_basic>

    def test_basic(self):
        for iterable in [
            (1, 2, 2, 3, 3, 3),  # In order
            range(6),  # All distinct
            'abbccc',  # Not numbers
            'cccbba',  # Backward
            'mississippi',  # No particular order
        ]:
            for r in range(len(iterable)):
                with self.subTest(iterable=iterable, r=r):
>                   actual = list(mi.distinct_combinations(iterable, r))
E                   TypeError: 'NoneType' object is not iterable

tests/test_more.py:4113: TypeError
</pre>
</details>
<h3 id="test_morepydistinctcombinationsteststest_empty">test_more.py::DistinctCombinationsTests::test_empty</h3>
<details><summary> <pre>test_more.py::DistinctCombinationsTests::test_empty</pre></summary><pre>
self = <tests.test_more.DistinctCombinationsTests testMethod=test_empty>

    def test_empty(self):
>       self.assertEqual(list(mi.distinct_combinations([], 2)), [])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4124: TypeError
</pre>
</details>
<h3 id="test_morepydistinctcombinationsteststest_negative">test_more.py::DistinctCombinationsTests::test_negative</h3>
<details><summary> <pre>test_more.py::DistinctCombinationsTests::test_negative</pre></summary><pre>
self = <tests.test_more.DistinctCombinationsTests testMethod=test_negative>

    def test_negative(self):
        with self.assertRaises(ValueError):
>           list(mi.distinct_combinations([], -1))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:4121: TypeError
</pre>
</details>
<h3 id="test_morepyfilterexceptteststest_false">test_more.py::FilterExceptTests::test_false</h3>
<details><summary> <pre>test_more.py::FilterExceptTests::test_false</pre></summary><pre>
self = <tests.test_more.FilterExceptTests testMethod=test_false>

    def test_false(self):
        # Even if the validator returns false, we pass through
        validator = lambda x: False
        iterable = ['0', '1', '2', 'three', None]
>       actual = list(mi.filter_except(validator, iterable, Exception))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4148: TypeError
</pre>
</details>
<h3 id="test_morepyfilterexceptteststest_multiple">test_more.py::FilterExceptTests::test_multiple</h3>
<details><summary> <pre>test_more.py::FilterExceptTests::test_multiple</pre></summary><pre>
self = <tests.test_more.FilterExceptTests testMethod=test_multiple>

    def test_multiple(self):
        iterable = ['0', '1', '2', 'three', None, '4']
>       actual = list(mi.filter_except(int, iterable, ValueError, TypeError))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4154: TypeError
</pre>
</details>
<h3 id="test_morepyfilterexceptteststest_no_exceptions_pass">test_more.py::FilterExceptTests::test_no_exceptions_pass</h3>
<details><summary> <pre>test_more.py::FilterExceptTests::test_no_exceptions_pass</pre></summary><pre>
self = <tests.test_more.FilterExceptTests testMethod=test_no_exceptions_pass>

    def test_no_exceptions_pass(self):
        iterable = '0123'
>       actual = list(mi.filter_except(int, iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4130: TypeError
</pre>
</details>
<h3 id="test_morepyfilterexceptteststest_no_exceptions_raise">test_more.py::FilterExceptTests::test_no_exceptions_raise</h3>
<details><summary> <pre>test_more.py::FilterExceptTests::test_no_exceptions_raise</pre></summary><pre>
self = <tests.test_more.FilterExceptTests testMethod=test_no_exceptions_raise>

    def test_no_exceptions_raise(self):
        iterable = ['0', '1', 'two', '3']
        with self.assertRaises(ValueError):
>           list(mi.filter_except(int, iterable))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:4137: TypeError
</pre>
</details>
<h3 id="test_morepymapexceptteststest_multiple">test_more.py::MapExceptTests::test_multiple</h3>
<details><summary> <pre>test_more.py::MapExceptTests::test_multiple</pre></summary><pre>
self = <tests.test_more.MapExceptTests testMethod=test_multiple>

    def test_multiple(self):
        iterable = ['0', '1', '2', 'three', None, '4']
>       actual = list(mi.map_except(int, iterable, ValueError, TypeError))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4178: TypeError
</pre>
</details>
<h3 id="test_morepymapexceptteststest_no_exceptions_pass">test_more.py::MapExceptTests::test_no_exceptions_pass</h3>
<details><summary> <pre>test_more.py::MapExceptTests::test_no_exceptions_pass</pre></summary><pre>
self = <tests.test_more.MapExceptTests testMethod=test_no_exceptions_pass>

    def test_no_exceptions_pass(self):
        iterable = '0123'
>       actual = list(mi.map_except(int, iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4162: TypeError
</pre>
</details>
<h3 id="test_morepymapexceptteststest_no_exceptions_raise">test_more.py::MapExceptTests::test_no_exceptions_raise</h3>
<details><summary> <pre>test_more.py::MapExceptTests::test_no_exceptions_raise</pre></summary><pre>
self = <tests.test_more.MapExceptTests testMethod=test_no_exceptions_raise>

    def test_no_exceptions_raise(self):
        iterable = ['0', '1', 'two', '3']
        with self.assertRaises(ValueError):
>           list(mi.map_except(int, iterable))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:4169: TypeError
</pre>
</details>
<h3 id="test_morepymapifteststest_empty">test_more.py::MapIfTests::test_empty</h3>
<details><summary> <pre>test_more.py::MapIfTests::test_empty</pre></summary><pre>
self = <tests.test_more.MapIfTests testMethod=test_empty>

    def test_empty(self):
>       actual = list(mi.map_if([], lambda x: len(x) > 5, lambda x: None))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4201: TypeError
</pre>
</details>
<h3 id="test_morepymapifteststest_with_func_else">test_more.py::MapIfTests::test_with_func_else</h3>
<details><summary> <pre>test_more.py::MapIfTests::test_with_func_else</pre></summary><pre>
self = <tests.test_more.MapIfTests testMethod=test_with_func_else>

    def test_with_func_else(self):
        iterable = list(range(-5, 5))
>       actual = list(
            mi.map_if(
                iterable, lambda x: x >= 0, lambda x: 'notneg', lambda x: 'neg'
            )
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4192: TypeError
</pre>
</details>
<h3 id="test_morepymapifteststest_without_func_else">test_more.py::MapIfTests::test_without_func_else</h3>
<details><summary> <pre>test_more.py::MapIfTests::test_without_func_else</pre></summary><pre>
self = <tests.test_more.MapIfTests testMethod=test_without_func_else>

    def test_without_func_else(self):
        iterable = list(range(-5, 5))
>       actual = list(mi.map_if(iterable, lambda x: x > 3, lambda x: 'toobig'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4186: TypeError
</pre>
</details>
<h3 id="test_morepysampleteststest_counts">test_more.py::SampleTests::test_counts</h3>
<details><summary> <pre>test_more.py::SampleTests::test_counts</pre></summary><pre>
self = <tests.test_more.SampleTests testMethod=test_counts>

    def test_counts(self):
        # Test with counts
        seed(0)
        iterable = ['red', 'blue']
        counts = [4, 2]
        k = 5
>       actual = list(mi.sample(iterable, counts=counts, k=k))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4246: TypeError
</pre>
</details>
<h3 id="test_morepysampleteststest_counts_all">test_more.py::SampleTests::test_counts_all</h3>
<details><summary> <pre>test_more.py::SampleTests::test_counts_all</pre></summary><pre>
self = <tests.test_more.SampleTests testMethod=test_counts_all>

    def test_counts_all(self):
        actual = Counter(mi.sample('uwxyz', 35, counts=(1, 0, 4, 10, 20)))
        expected = Counter({'u': 1, 'x': 4, 'y': 10, 'z': 20})
>       self.assertEqual(actual, expected)
E       AssertionError: Counter() != Counter({'z': 20, 'y': 10, 'x': 4, 'u': 1})

tests/test_more.py:4258: AssertionError
</pre>
</details>
<h3 id="test_morepysampleteststest_invariance_under_permutations_unweighted">test_more.py::SampleTests::test_invariance_under_permutations_unweighted</h3>
<details><summary> <pre>test_more.py::SampleTests::test_invariance_under_permutations_unweighted</pre></summary><pre>
self = <tests.test_more.SampleTests testMethod=test_invariance_under_permutations_unweighted>

    def test_invariance_under_permutations_unweighted(self):
        """The order of the data should not matter. This is a stochastic test,
        but it will fail in less than 1 / 10_000 cases."""

        # Create a data set and a reversed data set
        data = list(range(100))
        data_rev = list(reversed(data))

        # Sample each data set 10 times
>       data_means = [mean(mi.sample(data, k=50)) for _ in range(10)]

tests/test_more.py:4292: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/statistics.py:484: in mean
    T, total, n = _sum(data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = None

    def _sum(data):
        """_sum(data) -> (type, sum, count)

        Return a high-precision sum of the given numeric data as a fraction,
        together with the type to be converted to and the count of items.

        Examples
        --------

        >>> _sum([3, 2.25, 4.5, -0.5, 0.25])
        (<class 'float'>, Fraction(19, 2), 5)

        Some sources of round-off error will be avoided:

        # Built-in sum returns zero.
        >>> _sum([1e50, 1, -1e50] * 1000)
        (<class 'float'>, Fraction(1000, 1), 3000)

        Fractions and Decimals are also supported:

        >>> from fractions import Fraction as F
        >>> _sum([F(2, 3), F(7, 5), F(1, 4), F(5, 6)])
        (<class 'fractions.Fraction'>, Fraction(63, 20), 4)

        >>> from decimal import Decimal as D
        >>> data = [D("0.1375"), D("0.2108"), D("0.3061"), D("0.0419")]
        >>> _sum(data)
        (<class 'decimal.Decimal'>, Fraction(6963, 10000), 4)

        Mixed types are currently treated as an error, except that int is
        allowed.
        """
        count = 0
        types = set()
        types_add = types.add
        partials = {}
        partials_get = partials.get
>       for typ, values in groupby(data, type):
E       TypeError: 'NoneType' object is not iterable

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/statistics.py:191: TypeError
</pre>
</details>
<h3 id="test_morepysampleteststest_invariance_under_permutations_weighted">test_more.py::SampleTests::test_invariance_under_permutations_weighted</h3>
<details><summary> <pre>test_more.py::SampleTests::test_invariance_under_permutations_weighted</pre></summary><pre>
self = <tests.test_more.SampleTests testMethod=test_invariance_under_permutations_weighted>

    def test_invariance_under_permutations_weighted(self):
        """The order of the data should not matter. This is a stochastic test,
        but it will fail in less than 1 / 10_000 cases."""

        # Create a data set and a reversed data set
        data = list(range(1, 101))
        data_rev = list(reversed(data))

        # Sample each data set 10 times
        data_means = [
>           mean(mi.sample(data, k=50, weights=data)) for _ in range(10)
        ]

tests/test_more.py:4311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/statistics.py:484: in mean
    T, total, n = _sum(data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = None

    def _sum(data):
        """_sum(data) -> (type, sum, count)

        Return a high-precision sum of the given numeric data as a fraction,
        together with the type to be converted to and the count of items.

        Examples
        --------

        >>> _sum([3, 2.25, 4.5, -0.5, 0.25])
        (<class 'float'>, Fraction(19, 2), 5)

        Some sources of round-off error will be avoided:

        # Built-in sum returns zero.
        >>> _sum([1e50, 1, -1e50] * 1000)
        (<class 'float'>, Fraction(1000, 1), 3000)

        Fractions and Decimals are also supported:

        >>> from fractions import Fraction as F
        >>> _sum([F(2, 3), F(7, 5), F(1, 4), F(5, 6)])
        (<class 'fractions.Fraction'>, Fraction(63, 20), 4)

        >>> from decimal import Decimal as D
        >>> data = [D("0.1375"), D("0.2108"), D("0.3061"), D("0.0419")]
        >>> _sum(data)
        (<class 'decimal.Decimal'>, Fraction(6963, 10000), 4)

        Mixed types are currently treated as an error, except that int is
        allowed.
        """
        count = 0
        types = set()
        types_add = types.add
        partials = {}
        partials_get = partials.get
>       for typ, values in groupby(data, type):
E       TypeError: 'NoneType' object is not iterable

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/statistics.py:191: TypeError
</pre>
</details>
<h3 id="test_morepysampleteststest_length">test_more.py::SampleTests::test_length</h3>
<details><summary> <pre>test_more.py::SampleTests::test_length</pre></summary><pre>
self = <tests.test_more.SampleTests testMethod=test_length>

    def test_length(self):
        """Check that *k* elements are sampled."""
        data = [1, 2, 3, 4, 5]
        for k in [0, 3, 5, 7]:
            sampled = mi.sample(data, k=k)
>           actual = len(sampled)
E           TypeError: object of type 'NoneType' has no len()

tests/test_more.py:4230: TypeError
</pre>
</details>
<h3 id="test_morepysampleteststest_negative">test_more.py::SampleTests::test_negative</h3>
<details><summary> <pre>test_more.py::SampleTests::test_negative</pre></summary><pre>
self = <tests.test_more.SampleTests testMethod=test_negative>

    def test_negative(self):
        data = [1, 2, 3, 4, 5]
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_more.py:4222: AssertionError
</pre>
</details>
<h3 id="test_morepysampleteststest_sampling_entire_iterable">test_more.py::SampleTests::test_sampling_entire_iterable</h3>
<details><summary> <pre>test_more.py::SampleTests::test_sampling_entire_iterable</pre></summary><pre>
self = <tests.test_more.SampleTests testMethod=test_sampling_entire_iterable>

    def test_sampling_entire_iterable(self):
        """If k=len(iterable), the sample contains the original elements."""
        data = ["a", 2, "a", 4, (1, 2, 3)]
>       actual = set(mi.sample(data, k=len(data)))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4263: TypeError
</pre>
</details>
<h3 id="test_morepysampleteststest_strict">test_more.py::SampleTests::test_strict</h3>
<details><summary> <pre>test_more.py::SampleTests::test_strict</pre></summary><pre>
self = <tests.test_more.SampleTests testMethod=test_strict>

    def test_strict(self):
        data = ['1', '2', '3', '4', '5']
>       self.assertEqual(set(mi.sample(data, 6, strict=False)), set(data))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4236: TypeError
</pre>
</details>
<h3 id="test_morepysampleteststest_unit_case">test_more.py::SampleTests::test_unit_case</h3>
<details><summary> <pre>test_more.py::SampleTests::test_unit_case</pre></summary><pre>
self = <tests.test_more.SampleTests testMethod=test_unit_case>

    def test_unit_case(self):
        """Test against a fixed case by seeding the random module."""
        # Beware that this test really just verifies random.random() behavior.
        # If the algorithm is changed (e.g. to a more naive implementation)
        # this test will fail, but the algorithm might be correct.
        # Also, this test can pass and the algorithm can be completely wrong.
        data = "abcdef"
        weights = list(range(1, len(data) + 1))
        seed(123)
        actual = mi.sample(data, k=2, weights=weights)
        expected = ['f', 'e']
>       self.assertEqual(actual, expected)
E       AssertionError: None != ['f', 'e']

tests/test_more.py:4218: AssertionError
</pre>
</details>
<h3 id="test_morepyissortedteststest_basic">test_more.py::IsSortedTests::test_basic</h3>
<details><summary> <pre>test_more.py::IsSortedTests::test_basic</pre></summary><pre>
self = <tests.test_more.IsSortedTests testMethod=test_basic>

    def test_basic(self):
        for iterable, kwargs, expected in [
            ([], {}, True),
            ([1], {}, True),
            ([1, 2, 3], {}, True),
            ([1, 1, 2, 3], {}, True),
            ([1, 10, 2, 3], {}, False),
            ([3, float('nan'), 1, 2], {}, True),
            (['1', '10', '2', '3'], {}, True),
            (['1', '10', '2', '3'], {'key': int}, False),
            ([1, 2, 3], {'reverse': True}, False),
            ([1, 1, 2, 3], {'reverse': True}, False),
            ([1, 10, 2, 3], {'reverse': True}, False),
            (['3', '2', '10', '1'], {'reverse': True}, True),
            (['3', '2', '10', '1'], {'key': int, 'reverse': True}, False),
            # strict
            ([], {'strict': True}, True),
            ([1], {'strict': True}, True),
            ([1, 1], {'strict': True}, False),
            ([1, 2, 3], {'strict': True}, True),
            ([1, 1, 2, 3], {'strict': True}, False),
            ([1, 10, 2, 3], {'strict': True}, False),
            (['1', '10', '2', '3'], {'strict': True}, True),
            (['1', '10', '2', '3', '3'], {'strict': True}, False),
            (['1', '10', '2', '3'], {'strict': True, 'key': int}, False),
            ([1, 2, 3], {'strict': True, 'reverse': True}, False),
            ([1, 1, 2, 3], {'strict': True, 'reverse': True}, False),
            ([1, 10, 2, 3], {'strict': True, 'reverse': True}, False),
            (['3', '2', '10', '1'], {'strict': True, 'reverse': True}, True),
            (
                ['3', '2', '10', '10', '1'],
                {'strict': True, 'reverse': True},
                False,
            ),
            (
                ['3', '2', '10', '1'],
                {'strict': True, 'key': int, 'reverse': True},
                False,
            ),
            # We'll do the same weird thing as Python here
            (['nan', 0, 'nan', 0], {'key': float}, True),
            ([0, 'nan', 0, 'nan'], {'key': float}, True),
            (['nan', 0, 'nan', 0], {'key': float, 'reverse': True}, True),
            ([0, 'nan', 0, 'nan'], {'key': float, 'reverse': True}, True),
            ([0, 'nan', 0, 'nan'], {'strict': True, 'key': float}, True),
            (
                ['nan', 0, 'nan', 0],
                {'strict': True, 'key': float, 'reverse': True},
                True,
            ),
        ]:
            key = kwargs.get('key', None)
            reverse = kwargs.get('reverse', False)
            strict = kwargs.get('strict', False)

            with self.subTest(
                iterable=iterable, key=key, reverse=reverse, strict=strict
            ):
                mi_result = mi.is_sorted(
                    iter(iterable), key=key, reverse=reverse, strict=strict
                )

                sorted_iterable = sorted(iterable, key=key, reverse=reverse)
                if strict:
                    sorted_iterable = list(mi.unique_justseen(sorted_iterable))

                py_result = iterable == sorted_iterable

>               self.assertEqual(mi_result, expected)
E               AssertionError: None != True

tests/test_more.py:4394: AssertionError
</pre>
</details>
<h3 id="test_morepycallbackiterteststest_abort">test_more.py::CallbackIterTests::test_abort</h3>
<details><summary> <pre>test_more.py::CallbackIterTests::test_abort</pre></summary><pre>
self = <tests.test_more.CallbackIterTests testMethod=test_abort>

    def test_abort(self):
        func = lambda callback=None: self._target(cb=callback, wait=0.1)
>       with mi.callback_iter(func) as it:

tests/test_more.py:4457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <more_itertools.more.callback_iter object at 0x7fdd540b0380>
func = <function CallbackIterTests.test_abort.<locals>.<lambda> at 0x7fdd54626980>
callback_kwd = 'callback', wait_seconds = 0.1

    def __init__(self, func, callback_kwd='callback', wait_seconds=0.1):
        self._func = func
        self._callback_kwd = callback_kwd
        self._aborted = False
        self._future = None
        self._wait_seconds = wait_seconds
        self._executor = __import__('concurrent.futures').futures.ThreadPoolExecutor(max_workers=1)
>       self._iterator = self._reader()
E       AttributeError: 'callback_iter' object has no attribute '_reader'

more_itertools/more.py:2567: AttributeError
</pre>
</details>
<h3 id="test_morepycallbackiterteststest_basic">test_more.py::CallbackIterTests::test_basic</h3>
<details><summary> <pre>test_more.py::CallbackIterTests::test_basic</pre></summary><pre>
self = <tests.test_more.CallbackIterTests testMethod=test_basic>

    def test_basic(self):
        func = lambda callback=None: self._target(cb=callback, wait=0.02)
>       with mi.callback_iter(func, wait_seconds=0.01) as it:

tests/test_more.py:4414: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <more_itertools.more.callback_iter object at 0x7fdd540b3ef0>
func = <function CallbackIterTests.test_basic.<locals>.<lambda> at 0x7fdd546268e0>
callback_kwd = 'callback', wait_seconds = 0.01

    def __init__(self, func, callback_kwd='callback', wait_seconds=0.1):
        self._func = func
        self._callback_kwd = callback_kwd
        self._aborted = False
        self._future = None
        self._wait_seconds = wait_seconds
        self._executor = __import__('concurrent.futures').futures.ThreadPoolExecutor(max_workers=1)
>       self._iterator = self._reader()
E       AttributeError: 'callback_iter' object has no attribute '_reader'

more_itertools/more.py:2567: AttributeError
</pre>
</details>
<h3 id="test_morepycallbackiterteststest_callback_kwd">test_more.py::CallbackIterTests::test_callback_kwd</h3>
<details><summary> <pre>test_more.py::CallbackIterTests::test_callback_kwd</pre></summary><pre>
self = <tests.test_more.CallbackIterTests testMethod=test_callback_kwd>

    def test_callback_kwd(self):
>       with mi.callback_iter(self._target, callback_kwd='cb') as it:

tests/test_more.py:4438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <more_itertools.more.callback_iter object at 0x7fdd540b3890>
func = <bound method CallbackIterTests._target of <tests.test_more.CallbackIterTests testMethod=test_callback_kwd>>
callback_kwd = 'cb', wait_seconds = 0.1

    def __init__(self, func, callback_kwd='callback', wait_seconds=0.1):
        self._func = func
        self._callback_kwd = callback_kwd
        self._aborted = False
        self._future = None
        self._wait_seconds = wait_seconds
        self._executor = __import__('concurrent.futures').futures.ThreadPoolExecutor(max_workers=1)
>       self._iterator = self._reader()
E       AttributeError: 'callback_iter' object has no attribute '_reader'

more_itertools/more.py:2567: AttributeError
</pre>
</details>
<h3 id="test_morepycallbackiterteststest_exception">test_more.py::CallbackIterTests::test_exception</h3>
<details><summary> <pre>test_more.py::CallbackIterTests::test_exception</pre></summary><pre>
self = <tests.test_more.CallbackIterTests testMethod=test_exception>

    def test_exception(self):
        func = lambda callback=None: self._target(cb=callback, exc=ValueError)
>       with mi.callback_iter(func) as it:

tests/test_more.py:4471: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <more_itertools.more.callback_iter object at 0x7fdd54381c10>
func = <function CallbackIterTests.test_exception.<locals>.<lambda> at 0x7fdd54626ac0>
callback_kwd = 'callback', wait_seconds = 0.1

    def __init__(self, func, callback_kwd='callback', wait_seconds=0.1):
        self._func = func
        self._callback_kwd = callback_kwd
        self._aborted = False
        self._future = None
        self._wait_seconds = wait_seconds
        self._executor = __import__('concurrent.futures').futures.ThreadPoolExecutor(max_workers=1)
>       self._iterator = self._reader()
E       AttributeError: 'callback_iter' object has no attribute '_reader'

more_itertools/more.py:2567: AttributeError
</pre>
</details>
<h3 id="test_morepycallbackiterteststest_no_result">test_more.py::CallbackIterTests::test_no_result</h3>
<details><summary> <pre>test_more.py::CallbackIterTests::test_no_result</pre></summary><pre>
self = <tests.test_more.CallbackIterTests testMethod=test_no_result>

    def test_no_result(self):
        func = lambda callback=None: self._target(cb=callback)
>       with mi.callback_iter(func) as it:

tests/test_more.py:4465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <more_itertools.more.callback_iter object at 0x7fdd540b0290>
func = <function CallbackIterTests.test_no_result.<locals>.<lambda> at 0x7fdd54626b60>
callback_kwd = 'callback', wait_seconds = 0.1

    def __init__(self, func, callback_kwd='callback', wait_seconds=0.1):
        self._func = func
        self._callback_kwd = callback_kwd
        self._aborted = False
        self._future = None
        self._wait_seconds = wait_seconds
        self._executor = __import__('concurrent.futures').futures.ThreadPoolExecutor(max_workers=1)
>       self._iterator = self._reader()
E       AttributeError: 'callback_iter' object has no attribute '_reader'

more_itertools/more.py:2567: AttributeError
</pre>
</details>
<h3 id="test_morepycallbackiterteststest_partial_consumption">test_more.py::CallbackIterTests::test_partial_consumption</h3>
<details><summary> <pre>test_more.py::CallbackIterTests::test_partial_consumption</pre></summary><pre>
self = <tests.test_more.CallbackIterTests testMethod=test_partial_consumption>

    def test_partial_consumption(self):
        func = lambda callback=None: self._target(cb=callback)
>       with mi.callback_iter(func) as it:

tests/test_more.py:4450: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <more_itertools.more.callback_iter object at 0x7fdd540b3260>
func = <function CallbackIterTests.test_partial_consumption.<locals>.<lambda> at 0x7fdd54626c00>
callback_kwd = 'callback', wait_seconds = 0.1

    def __init__(self, func, callback_kwd='callback', wait_seconds=0.1):
        self._func = func
        self._callback_kwd = callback_kwd
        self._aborted = False
        self._future = None
        self._wait_seconds = wait_seconds
        self._executor = __import__('concurrent.futures').futures.ThreadPoolExecutor(max_workers=1)
>       self._iterator = self._reader()
E       AttributeError: 'callback_iter' object has no attribute '_reader'

more_itertools/more.py:2567: AttributeError
</pre>
</details>
<h3 id="test_morepywindowedcompleteteststest_basic">test_more.py::WindowedCompleteTests::test_basic</h3>
<details><summary> <pre>test_more.py::WindowedCompleteTests::test_basic</pre></summary><pre>
self = <tests.test_more.WindowedCompleteTests testMethod=test_basic>

    def test_basic(self):
>       actual = list(mi.windowed_complete([1, 2, 3, 4, 5], 3))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4485: TypeError
</pre>
</details>
<h3 id="test_morepywindowedcompleteteststest_every_partition">test_more.py::WindowedCompleteTests::test_every_partition</h3>
<details><summary> <pre>test_more.py::WindowedCompleteTests::test_every_partition</pre></summary><pre>
self = <tests.test_more.WindowedCompleteTests testMethod=test_every_partition>

    def test_every_partition(self):
        every_partition = lambda seq: chain(
            *map(partial(mi.windowed_complete, seq), range(len(seq)))
        )

        seq = 'ABC'
>       actual = list(every_partition(seq))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4516: TypeError
</pre>
</details>
<h3 id="test_morepywindowedcompleteteststest_wrong_length">test_more.py::WindowedCompleteTests::test_wrong_length</h3>
<details><summary> <pre>test_more.py::WindowedCompleteTests::test_wrong_length</pre></summary><pre>
self = <tests.test_more.WindowedCompleteTests testMethod=test_wrong_length>

    def test_wrong_length(self):
        seq = [1, 2, 3, 4, 5]
        for n in (-10, -1, len(seq) + 1, len(seq) + 10):
            with self.subTest(n=n):
                with self.assertRaises(ValueError):
>                   list(mi.windowed_complete(seq, n))
E                   TypeError: 'NoneType' object is not iterable

tests/test_more.py:4508: TypeError
</pre>
</details>
<h3 id="test_morepywindowedcompleteteststest_zero_length">test_more.py::WindowedCompleteTests::test_zero_length</h3>
<details><summary> <pre>test_more.py::WindowedCompleteTests::test_zero_length</pre></summary><pre>
self = <tests.test_more.WindowedCompleteTests testMethod=test_zero_length>

    def test_zero_length(self):
>       actual = list(mi.windowed_complete([1, 2, 3], 0))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4494: TypeError
</pre>
</details>
<h3 id="test_morepyalluniqueteststest_basic">test_more.py::AllUniqueTests::test_basic</h3>
<details><summary> <pre>test_more.py::AllUniqueTests::test_basic</pre></summary><pre>
self = <tests.test_more.AllUniqueTests testMethod=test_basic>

    def test_basic(self):
        for iterable, expected in [
            ([], True),
            ([1, 2, 3], True),
            ([1, 1], False),
            ([1, 2, 3, 1], False),
            ([1, 2, 3, '1'], True),
        ]:
            with self.subTest(args=(iterable,)):
>               self.assertEqual(mi.all_unique(iterable), expected)
E               AssertionError: None != True

tests/test_more.py:4541: AssertionError
</pre>
</details>
<h3 id="test_morepyalluniqueteststest_infinite">test_more.py::AllUniqueTests::test_infinite</h3>
<details><summary> <pre>test_more.py::AllUniqueTests::test_infinite</pre></summary><pre>
self = <tests.test_more.AllUniqueTests testMethod=test_infinite>

    def test_infinite(self):
>       self.assertEqual(mi.all_unique(mi.prepend(3, count())), False)
E       AssertionError: None != False

tests/test_more.py:4562: AssertionError
</pre>
</details>
<h3 id="test_morepyalluniqueteststest_key">test_more.py::AllUniqueTests::test_key</h3>
<details><summary> <pre>test_more.py::AllUniqueTests::test_key</pre></summary><pre>
self = <tests.test_more.AllUniqueTests testMethod=test_key>

    def test_key(self):
        iterable = ['A', 'B', 'C', 'b']
>       self.assertEqual(mi.all_unique(iterable, lambda x: x), True)
E       AssertionError: None != True

tests/test_more.py:4558: AssertionError
</pre>
</details>
<h3 id="test_morepyalluniqueteststest_non_hashable">test_more.py::AllUniqueTests::test_non_hashable</h3>
<details><summary> <pre>test_more.py::AllUniqueTests::test_non_hashable</pre></summary><pre>
self = <tests.test_more.AllUniqueTests testMethod=test_non_hashable>

    def test_non_hashable(self):
>       self.assertEqual(mi.all_unique([[1, 2], [3, 4]]), True)
E       AssertionError: None != True

tests/test_more.py:4544: AssertionError
</pre>
</details>
<h3 id="test_morepyalluniqueteststest_partially_hashable">test_more.py::AllUniqueTests::test_partially_hashable</h3>
<details><summary> <pre>test_more.py::AllUniqueTests::test_partially_hashable</pre></summary><pre>
self = <tests.test_more.AllUniqueTests testMethod=test_partially_hashable>

    def test_partially_hashable(self):
>       self.assertEqual(mi.all_unique([[1, 2], [3, 4], (5, 6)]), True)
E       AssertionError: None != True

tests/test_more.py:4548: AssertionError
</pre>
</details>
<h3 id="test_morepynthproductteststest_basic">test_more.py::NthProductTests::test_basic</h3>
<details><summary> <pre>test_more.py::NthProductTests::test_basic</pre></summary><pre>
self = <tests.test_more.NthProductTests testMethod=test_basic>

    def test_basic(self):
        iterables = ['ab', 'cdef', 'ghi']
        for index, expected in enumerate(product(*iterables)):
            actual = mi.nth_product(index, *iterables)
>           self.assertEqual(actual, expected)
E           AssertionError: None != ('a', 'c', 'g')

tests/test_more.py:4570: AssertionError
</pre>
</details>
<h3 id="test_morepynthproductteststest_invalid_index">test_more.py::NthProductTests::test_invalid_index</h3>
<details><summary> <pre>test_more.py::NthProductTests::test_invalid_index</pre></summary><pre>
self = <tests.test_more.NthProductTests testMethod=test_invalid_index>

    def test_invalid_index(self):
>       with self.assertRaises(IndexError):
E       AssertionError: IndexError not raised

tests/test_more.py:4584: AssertionError
</pre>
</details>
<h3 id="test_morepynthproductteststest_long">test_more.py::NthProductTests::test_long</h3>
<details><summary> <pre>test_more.py::NthProductTests::test_long</pre></summary><pre>
self = <tests.test_more.NthProductTests testMethod=test_long>

    def test_long(self):
        actual = mi.nth_product(1337, range(101), range(22), range(53))
        expected = (1, 3, 12)
>       self.assertEqual(actual, expected)
E       AssertionError: None != (1, 3, 12)

tests/test_more.py:4575: AssertionError
</pre>
</details>
<h3 id="test_morepynthproductteststest_negative">test_more.py::NthProductTests::test_negative</h3>
<details><summary> <pre>test_more.py::NthProductTests::test_negative</pre></summary><pre>
self = <tests.test_more.NthProductTests testMethod=test_negative>

    def test_negative(self):
        iterables = ['abc', 'de', 'fghi']
        for index, expected in enumerate(product(*iterables)):
            actual = mi.nth_product(index - 24, *iterables)
>           self.assertEqual(actual, expected)
E           AssertionError: None != ('a', 'd', 'f')

tests/test_more.py:4581: AssertionError
</pre>
</details>
<h3 id="test_morepynthcombinationwithreplacementteststest_basic">test_more.py::NthCombinationWithReplacementTests::test_basic</h3>
<details><summary> <pre>test_more.py::NthCombinationWithReplacementTests::test_basic</pre></summary><pre>
self = <tests.test_more.NthCombinationWithReplacementTests testMethod=test_basic>

    def test_basic(self):
        iterable = 'abcdefg'
        r = 4
        for index, expected in enumerate(
            combinations_with_replacement(iterable, r)
        ):
            actual = mi.nth_combination_with_replacement(iterable, r, index)
>           self.assertEqual(actual, expected)
E           AssertionError: None != ('a', 'a', 'a', 'a')

tests/test_more.py:4596: AssertionError
</pre>
</details>
<h3 id="test_morepynthcombinationwithreplacementteststest_invalid_index">test_more.py::NthCombinationWithReplacementTests::test_invalid_index</h3>
<details><summary> <pre>test_more.py::NthCombinationWithReplacementTests::test_invalid_index</pre></summary><pre>
self = <tests.test_more.NthCombinationWithReplacementTests testMethod=test_invalid_index>

    def test_invalid_index(self):
>       with self.assertRaises(IndexError):
E       AssertionError: IndexError not raised

tests/test_more.py:4609: AssertionError
</pre>
</details>
<h3 id="test_morepynthcombinationwithreplacementteststest_invalid_r">test_more.py::NthCombinationWithReplacementTests::test_invalid_r</h3>
<details><summary> <pre>test_more.py::NthCombinationWithReplacementTests::test_invalid_r</pre></summary><pre>
self = <tests.test_more.NthCombinationWithReplacementTests testMethod=test_invalid_r>

    def test_invalid_r(self):
        for r in (-1, 3):
>           with self.assertRaises(ValueError):
E           AssertionError: ValueError not raised

tests/test_more.py:4605: AssertionError
</pre>
</details>
<h3 id="test_morepynthcombinationwithreplacementteststest_long">test_more.py::NthCombinationWithReplacementTests::test_long</h3>
<details><summary> <pre>test_more.py::NthCombinationWithReplacementTests::test_long</pre></summary><pre>
self = <tests.test_more.NthCombinationWithReplacementTests testMethod=test_long>

    def test_long(self):
        actual = mi.nth_combination_with_replacement(range(90), 4, 2000000)
        expected = (22, 65, 68, 81)
>       self.assertEqual(actual, expected)
E       AssertionError: None != (22, 65, 68, 81)

tests/test_more.py:4601: AssertionError
</pre>
</details>
<h3 id="test_morepyvaluechainteststest_complex">test_more.py::ValueChainTests::test_complex</h3>
<details><summary> <pre>test_more.py::ValueChainTests::test_complex</pre></summary><pre>
self = <tests.test_more.ValueChainTests testMethod=test_complex>

    def test_complex(self):
        obj = object()
>       actual = list(
            mi.value_chain(
                (1, (2, (3,))),
                ['foo', ['bar', ['baz']], 'tic'],
                {'key': {'foo': 1}},
                obj,
            )
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4636: TypeError
</pre>
</details>
<h3 id="test_morepyvaluechainteststest_empty">test_more.py::ValueChainTests::test_empty</h3>
<details><summary> <pre>test_more.py::ValueChainTests::test_empty</pre></summary><pre>
self = <tests.test_more.ValueChainTests testMethod=test_empty>

    def test_empty(self):
>       actual = list(mi.value_chain())
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4615: TypeError
</pre>
</details>
<h3 id="test_morepyvaluechainteststest_empty_lists">test_more.py::ValueChainTests::test_empty_lists</h3>
<details><summary> <pre>test_more.py::ValueChainTests::test_empty_lists</pre></summary><pre>
self = <tests.test_more.ValueChainTests testMethod=test_empty_lists>

    def test_empty_lists(self):
>       actual = list(mi.value_chain(1, 2, [], [3, 4]))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4630: TypeError
</pre>
</details>
<h3 id="test_morepyvaluechainteststest_more">test_more.py::ValueChainTests::test_more</h3>
<details><summary> <pre>test_more.py::ValueChainTests::test_more</pre></summary><pre>
self = <tests.test_more.ValueChainTests testMethod=test_more>

    def test_more(self):
>       actual = list(mi.value_chain(b'bar', [1, 2, 3], 4, {'key': 1}))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4625: TypeError
</pre>
</details>
<h3 id="test_morepyvaluechainteststest_simple">test_more.py::ValueChainTests::test_simple</h3>
<details><summary> <pre>test_more.py::ValueChainTests::test_simple</pre></summary><pre>
self = <tests.test_more.ValueChainTests testMethod=test_simple>

    def test_simple(self):
>       actual = list(mi.value_chain(1, 2.71828, False, 'foo'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4620: TypeError
</pre>
</details>
<h3 id="test_morepyproductindexteststest_basic">test_more.py::ProductIndexTests::test_basic</h3>
<details><summary> <pre>test_more.py::ProductIndexTests::test_basic</pre></summary><pre>
self = <tests.test_more.ProductIndexTests testMethod=test_basic>

    def test_basic(self):
        iterables = ['ab', 'cdef', 'ghi']
        first_index = {}
        for index, element in enumerate(product(*iterables)):
            actual = mi.product_index(element, *iterables)
            expected = first_index.setdefault(element, index)
>           self.assertEqual(actual, expected)
E           AssertionError: None != 0

tests/test_more.py:4655: AssertionError
</pre>
</details>
<h3 id="test_morepyproductindexteststest_invalid_empty">test_more.py::ProductIndexTests::test_invalid_empty</h3>
<details><summary> <pre>test_more.py::ProductIndexTests::test_invalid_empty</pre></summary><pre>
self = <tests.test_more.ProductIndexTests testMethod=test_invalid_empty>

    def test_invalid_empty(self):
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_more.py:4671: AssertionError
</pre>
</details>
<h3 id="test_morepyproductindexteststest_invalid_large">test_more.py::ProductIndexTests::test_invalid_large</h3>
<details><summary> <pre>test_more.py::ProductIndexTests::test_invalid_large</pre></summary><pre>
self = <tests.test_more.ProductIndexTests testMethod=test_invalid_large>

    def test_invalid_large(self):
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_more.py:4679: AssertionError
</pre>
</details>
<h3 id="test_morepyproductindexteststest_invalid_match">test_more.py::ProductIndexTests::test_invalid_match</h3>
<details><summary> <pre>test_more.py::ProductIndexTests::test_invalid_match</pre></summary><pre>
self = <tests.test_more.ProductIndexTests testMethod=test_invalid_match>

    def test_invalid_match(self):
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_more.py:4683: AssertionError
</pre>
</details>
<h3 id="test_morepyproductindexteststest_invalid_small">test_more.py::ProductIndexTests::test_invalid_small</h3>
<details><summary> <pre>test_more.py::ProductIndexTests::test_invalid_small</pre></summary><pre>
self = <tests.test_more.ProductIndexTests testMethod=test_invalid_small>

    def test_invalid_small(self):
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_more.py:4675: AssertionError
</pre>
</details>
<h3 id="test_morepyproductindexteststest_long">test_more.py::ProductIndexTests::test_long</h3>
<details><summary> <pre>test_more.py::ProductIndexTests::test_long</pre></summary><pre>
self = <tests.test_more.ProductIndexTests testMethod=test_long>

    def test_long(self):
        actual = mi.product_index((1, 3, 12), range(101), range(22), range(53))
        expected = 1337
>       self.assertEqual(actual, expected)
E       AssertionError: None != 1337

tests/test_more.py:4668: AssertionError
</pre>
</details>
<h3 id="test_morepyproductindexteststest_multiplicity">test_more.py::ProductIndexTests::test_multiplicity</h3>
<details><summary> <pre>test_more.py::ProductIndexTests::test_multiplicity</pre></summary><pre>
self = <tests.test_more.ProductIndexTests testMethod=test_multiplicity>

    def test_multiplicity(self):
        iterables = ['ab', 'bab', 'cab']
        first_index = {}
        for index, element in enumerate(product(*iterables)):
            actual = mi.product_index(element, *iterables)
            expected = first_index.setdefault(element, index)
>           self.assertEqual(actual, expected)
E           AssertionError: None != 0

tests/test_more.py:4663: AssertionError
</pre>
</details>
<h3 id="test_morepycombinationindexteststest_invalid_large">test_more.py::CombinationIndexTests::test_invalid_large</h3>
<details><summary> <pre>test_more.py::CombinationIndexTests::test_invalid_large</pre></summary><pre>
self = <tests.test_more.CombinationIndexTests testMethod=test_invalid_large>

    def test_invalid_large(self):
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_more.py:4730: AssertionError
</pre>
</details>
<h3 id="test_morepycombinationindexteststest_invalid_match">test_more.py::CombinationIndexTests::test_invalid_match</h3>
<details><summary> <pre>test_more.py::CombinationIndexTests::test_invalid_match</pre></summary><pre>
self = <tests.test_more.CombinationIndexTests testMethod=test_invalid_match>

    def test_invalid_match(self):
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_more.py:4734: AssertionError
</pre>
</details>
<h3 id="test_morepycombinationindexteststest_invalid_order">test_more.py::CombinationIndexTests::test_invalid_order</h3>
<details><summary> <pre>test_more.py::CombinationIndexTests::test_invalid_order</pre></summary><pre>
self = <tests.test_more.CombinationIndexTests testMethod=test_invalid_order>

    def test_invalid_order(self):
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_more.py:4726: AssertionError
</pre>
</details>
<h3 id="test_morepycombinationindexteststest_long">test_more.py::CombinationIndexTests::test_long</h3>
<details><summary> <pre>test_more.py::CombinationIndexTests::test_long</pre></summary><pre>
self = <tests.test_more.CombinationIndexTests testMethod=test_long>

    def test_long(self):
        actual = mi.combination_index((2, 12, 35, 126), range(180))
        expected = 2000000
>       self.assertEqual(actual, expected)
E       AssertionError: None != 2000000

tests/test_more.py:4723: AssertionError
</pre>
</details>
<h3 id="test_morepycombinationindexteststest_multiplicity">test_more.py::CombinationIndexTests::test_multiplicity</h3>
<details><summary> <pre>test_more.py::CombinationIndexTests::test_multiplicity</pre></summary><pre>
self = <tests.test_more.CombinationIndexTests testMethod=test_multiplicity>

    def test_multiplicity(self):
        iterable = 'abacba'
        r = 3
        first_index = {}
        for index, element in enumerate(combinations(iterable, r)):
            actual = mi.combination_index(element, iterable)
            expected = first_index.setdefault(element, index)
>           self.assertEqual(actual, expected)
E           AssertionError: None != 0

tests/test_more.py:4713: AssertionError
</pre>
</details>
<h3 id="test_morepycombinationindexteststest_null">test_more.py::CombinationIndexTests::test_null</h3>
<details><summary> <pre>test_more.py::CombinationIndexTests::test_null</pre></summary><pre>
self = <tests.test_more.CombinationIndexTests testMethod=test_null>

    def test_null(self):
        actual = mi.combination_index(tuple(), [])
        expected = 0
>       self.assertEqual(actual, expected)
E       AssertionError: None != 0

tests/test_more.py:4718: AssertionError
</pre>
</details>
<h3 id="test_morepycombinationindexteststest_r_equal_to_n">test_more.py::CombinationIndexTests::test_r_equal_to_n</h3>
<details><summary> <pre>test_more.py::CombinationIndexTests::test_r_equal_to_n</pre></summary><pre>
self = <tests.test_more.CombinationIndexTests testMethod=test_r_equal_to_n>

    def test_r_equal_to_n(self):
        iterable = 'abcd'
        r = len(iterable)
        first_index = {}
        for index, element in enumerate(combinations(iterable, r=r)):
            actual = mi.combination_index(element, iterable)
            expected = first_index.setdefault(element, index)
>           self.assertEqual(actual, expected)
E           AssertionError: None != 0

tests/test_more.py:4704: AssertionError
</pre>
</details>
<h3 id="test_morepycombinationindexteststest_r_less_than_n">test_more.py::CombinationIndexTests::test_r_less_than_n</h3>
<details><summary> <pre>test_more.py::CombinationIndexTests::test_r_less_than_n</pre></summary><pre>
self = <tests.test_more.CombinationIndexTests testMethod=test_r_less_than_n>

    def test_r_less_than_n(self):
        iterable = 'abcdefg'
        r = 4
        first_index = {}
        for index, element in enumerate(combinations(iterable, r)):
            actual = mi.combination_index(element, iterable)
            expected = first_index.setdefault(element, index)
>           self.assertEqual(actual, expected)
E           AssertionError: None != 0

tests/test_more.py:4695: AssertionError
</pre>
</details>
<h3 id="test_morepycombinationwithreplacementindexteststest_invalid_large">test_more.py::CombinationWithReplacementIndexTests::test_invalid_large</h3>
<details><summary> <pre>test_more.py::CombinationWithReplacementIndexTests::test_invalid_large</pre></summary><pre>
self = <tests.test_more.CombinationWithReplacementIndexTests testMethod=test_invalid_large>

    def test_invalid_large(self):
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_more.py:4789: AssertionError
</pre>
</details>
<h3 id="test_morepycombinationwithreplacementindexteststest_invalid_match">test_more.py::CombinationWithReplacementIndexTests::test_invalid_match</h3>
<details><summary> <pre>test_more.py::CombinationWithReplacementIndexTests::test_invalid_match</pre></summary><pre>
self = <tests.test_more.CombinationWithReplacementIndexTests testMethod=test_invalid_match>

    def test_invalid_match(self):
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_more.py:4793: AssertionError
</pre>
</details>
<h3 id="test_morepycombinationwithreplacementindexteststest_invalid_order">test_more.py::CombinationWithReplacementIndexTests::test_invalid_order</h3>
<details><summary> <pre>test_more.py::CombinationWithReplacementIndexTests::test_invalid_order</pre></summary><pre>
self = <tests.test_more.CombinationWithReplacementIndexTests testMethod=test_invalid_order>

    def test_invalid_order(self):
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_more.py:4785: AssertionError
</pre>
</details>
<h3 id="test_morepycombinationwithreplacementindexteststest_long">test_more.py::CombinationWithReplacementIndexTests::test_long</h3>
<details><summary> <pre>test_more.py::CombinationWithReplacementIndexTests::test_long</pre></summary><pre>
self = <tests.test_more.CombinationWithReplacementIndexTests testMethod=test_long>

    def test_long(self):
        actual = mi.combination_with_replacement_index(
            (22, 65, 68, 81), range(90)
        )
        expected = 2000000
>       self.assertEqual(actual, expected)
E       AssertionError: None != 2000000

tests/test_more.py:4782: AssertionError
</pre>
</details>
<h3 id="test_morepycombinationwithreplacementindexteststest_multiplicity">test_more.py::CombinationWithReplacementIndexTests::test_multiplicity</h3>
<details><summary> <pre>test_more.py::CombinationWithReplacementIndexTests::test_multiplicity</pre></summary><pre>
self = <tests.test_more.CombinationWithReplacementIndexTests testMethod=test_multiplicity>

    def test_multiplicity(self):
        iterable = 'abacba'
        r = 3
        first_index = {}
        for index, element in enumerate(
            combinations_with_replacement(iterable, r)
        ):
            actual = mi.combination_with_replacement_index(element, iterable)
            expected = first_index.setdefault(element, index)
>           self.assertEqual(actual, expected)
E           AssertionError: None != 0

tests/test_more.py:4770: AssertionError
</pre>
</details>
<h3 id="test_morepycombinationwithreplacementindexteststest_null">test_more.py::CombinationWithReplacementIndexTests::test_null</h3>
<details><summary> <pre>test_more.py::CombinationWithReplacementIndexTests::test_null</pre></summary><pre>
self = <tests.test_more.CombinationWithReplacementIndexTests testMethod=test_null>

    def test_null(self):
        actual = mi.combination_with_replacement_index(tuple(), [])
        expected = 0
>       self.assertEqual(actual, expected)
E       AssertionError: None != 0

tests/test_more.py:4775: AssertionError
</pre>
</details>
<h3 id="test_morepycombinationwithreplacementindexteststest_r_equal_to_n">test_more.py::CombinationWithReplacementIndexTests::test_r_equal_to_n</h3>
<details><summary> <pre>test_more.py::CombinationWithReplacementIndexTests::test_r_equal_to_n</pre></summary><pre>
self = <tests.test_more.CombinationWithReplacementIndexTests testMethod=test_r_equal_to_n>

    def test_r_equal_to_n(self):
        iterable = 'abcd'
        r = len(iterable)
        first_index = {}
        for index, element in enumerate(
            combinations_with_replacement(iterable, r=r)
        ):
            actual = mi.combination_with_replacement_index(element, iterable)
            expected = first_index.setdefault(element, index)
>           self.assertEqual(actual, expected)
E           AssertionError: None != 0

tests/test_more.py:4759: AssertionError
</pre>
</details>
<h3 id="test_morepycombinationwithreplacementindexteststest_r_less_than_n">test_more.py::CombinationWithReplacementIndexTests::test_r_less_than_n</h3>
<details><summary> <pre>test_more.py::CombinationWithReplacementIndexTests::test_r_less_than_n</pre></summary><pre>
self = <tests.test_more.CombinationWithReplacementIndexTests testMethod=test_r_less_than_n>

    def test_r_less_than_n(self):
        iterable = 'abcdefg'
        r = 4
        first_index = {}
        for index, element in enumerate(
            combinations_with_replacement(iterable, r)
        ):
            actual = mi.combination_with_replacement_index(element, iterable)
            expected = first_index.setdefault(element, index)
>           self.assertEqual(actual, expected)
E           AssertionError: None != 0

tests/test_more.py:4748: AssertionError
</pre>
</details>
<h3 id="test_morepypermutationindexteststest_invalid_large">test_more.py::PermutationIndexTests::test_invalid_large</h3>
<details><summary> <pre>test_more.py::PermutationIndexTests::test_invalid_large</pre></summary><pre>
self = <tests.test_more.PermutationIndexTests testMethod=test_invalid_large>

    def test_invalid_large(self):
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_more.py:4835: AssertionError
</pre>
</details>
<h3 id="test_morepypermutationindexteststest_invalid_match">test_more.py::PermutationIndexTests::test_invalid_match</h3>
<details><summary> <pre>test_more.py::PermutationIndexTests::test_invalid_match</pre></summary><pre>
self = <tests.test_more.PermutationIndexTests testMethod=test_invalid_match>

    def test_invalid_match(self):
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_more.py:4839: AssertionError
</pre>
</details>
<h3 id="test_morepypermutationindexteststest_long">test_more.py::PermutationIndexTests::test_long</h3>
<details><summary> <pre>test_more.py::PermutationIndexTests::test_long</pre></summary><pre>
self = <tests.test_more.PermutationIndexTests testMethod=test_long>

    def test_long(self):
        actual = mi.permutation_index((2, 12, 35, 126), range(180))
        expected = 11631678
>       self.assertEqual(actual, expected)
E       AssertionError: None != 11631678

tests/test_more.py:4832: AssertionError
</pre>
</details>
<h3 id="test_morepypermutationindexteststest_multiplicity">test_more.py::PermutationIndexTests::test_multiplicity</h3>
<details><summary> <pre>test_more.py::PermutationIndexTests::test_multiplicity</pre></summary><pre>
self = <tests.test_more.PermutationIndexTests testMethod=test_multiplicity>

    def test_multiplicity(self):
        iterable = 'abacba'
        r = 3
        first_index = {}
        for index, element in enumerate(permutations(iterable, r)):
            actual = mi.permutation_index(element, iterable)
            expected = first_index.setdefault(element, index)
>           self.assertEqual(actual, expected)
E           AssertionError: None != 0

tests/test_more.py:4822: AssertionError
</pre>
</details>
<h3 id="test_morepypermutationindexteststest_null">test_more.py::PermutationIndexTests::test_null</h3>
<details><summary> <pre>test_more.py::PermutationIndexTests::test_null</pre></summary><pre>
self = <tests.test_more.PermutationIndexTests testMethod=test_null>

    def test_null(self):
        actual = mi.permutation_index(tuple(), [])
        expected = 0
>       self.assertEqual(actual, expected)
E       AssertionError: None != 0

tests/test_more.py:4827: AssertionError
</pre>
</details>
<h3 id="test_morepypermutationindexteststest_r_equal_to_n">test_more.py::PermutationIndexTests::test_r_equal_to_n</h3>
<details><summary> <pre>test_more.py::PermutationIndexTests::test_r_equal_to_n</pre></summary><pre>
self = <tests.test_more.PermutationIndexTests testMethod=test_r_equal_to_n>

    def test_r_equal_to_n(self):
        iterable = 'abcd'
        first_index = {}
        for index, element in enumerate(permutations(iterable)):
            actual = mi.permutation_index(element, iterable)
            expected = first_index.setdefault(element, index)
>           self.assertEqual(actual, expected)
E           AssertionError: None != 0

tests/test_more.py:4813: AssertionError
</pre>
</details>
<h3 id="test_morepypermutationindexteststest_r_less_than_n">test_more.py::PermutationIndexTests::test_r_less_than_n</h3>
<details><summary> <pre>test_more.py::PermutationIndexTests::test_r_less_than_n</pre></summary><pre>
self = <tests.test_more.PermutationIndexTests testMethod=test_r_less_than_n>

    def test_r_less_than_n(self):
        iterable = 'abcdefg'
        r = 4
        first_index = {}
        for index, element in enumerate(permutations(iterable, r)):
            actual = mi.permutation_index(element, iterable)
            expected = first_index.setdefault(element, index)
>           self.assertEqual(actual, expected)
E           AssertionError: None != 0

tests/test_more.py:4805: AssertionError
</pre>
</details>
<h3 id="test_morepychunkedeventeststest_0">test_more.py::ChunkedEvenTests::test_0</h3>
<details><summary> <pre>test_more.py::ChunkedEvenTests::test_0</pre></summary><pre>
self = <tests.test_more.ChunkedEvenTests testMethod=test_0>

    def test_0(self):
>       self._test_finite('', 3, [])

tests/test_more.py:4864: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_more.ChunkedEvenTests testMethod=test_0>, seq = '', n = 3
expected = []

    def _test_finite(self, seq, n, expected):
        # Check with and without `len()`
>       self.assertEqual(list(mi.chunked_even(seq, n)), expected)
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4885: TypeError
</pre>
</details>
<h3 id="test_morepychunkedeventeststest_1">test_more.py::ChunkedEvenTests::test_1</h3>
<details><summary> <pre>test_more.py::ChunkedEvenTests::test_1</pre></summary><pre>
self = <tests.test_more.ChunkedEvenTests testMethod=test_1>

    def test_1(self):
>       self._test_finite('A', 1, [['A']])

tests/test_more.py:4867: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_more.ChunkedEvenTests testMethod=test_1>, seq = 'A', n = 1
expected = [['A']]

    def _test_finite(self, seq, n, expected):
        # Check with and without `len()`
>       self.assertEqual(list(mi.chunked_even(seq, n)), expected)
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4885: TypeError
</pre>
</details>
<h3 id="test_morepychunkedeventeststest_4">test_more.py::ChunkedEvenTests::test_4</h3>
<details><summary> <pre>test_more.py::ChunkedEvenTests::test_4</pre></summary><pre>
self = <tests.test_more.ChunkedEvenTests testMethod=test_4>

    def test_4(self):
>       self._test_finite('ABCD', 3, [['A', 'B'], ['C', 'D']])

tests/test_more.py:4870: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_more.ChunkedEvenTests testMethod=test_4>, seq = 'ABCD', n = 3
expected = [['A', 'B'], ['C', 'D']]

    def _test_finite(self, seq, n, expected):
        # Check with and without `len()`
>       self.assertEqual(list(mi.chunked_even(seq, n)), expected)
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4885: TypeError
</pre>
</details>
<h3 id="test_morepychunkedeventeststest_5">test_more.py::ChunkedEvenTests::test_5</h3>
<details><summary> <pre>test_more.py::ChunkedEvenTests::test_5</pre></summary><pre>
self = <tests.test_more.ChunkedEvenTests testMethod=test_5>

    def test_5(self):
>       self._test_finite('ABCDE', 3, [['A', 'B', 'C'], ['D', 'E']])

tests/test_more.py:4873: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_more.ChunkedEvenTests testMethod=test_5>, seq = 'ABCDE'
n = 3, expected = [['A', 'B', 'C'], ['D', 'E']]

    def _test_finite(self, seq, n, expected):
        # Check with and without `len()`
>       self.assertEqual(list(mi.chunked_even(seq, n)), expected)
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4885: TypeError
</pre>
</details>
<h3 id="test_morepychunkedeventeststest_6">test_more.py::ChunkedEvenTests::test_6</h3>
<details><summary> <pre>test_more.py::ChunkedEvenTests::test_6</pre></summary><pre>
self = <tests.test_more.ChunkedEvenTests testMethod=test_6>

    def test_6(self):
>       self._test_finite('ABCDEF', 3, [['A', 'B', 'C'], ['D', 'E', 'F']])

tests/test_more.py:4876: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_more.ChunkedEvenTests testMethod=test_6>, seq = 'ABCDEF'
n = 3, expected = [['A', 'B', 'C'], ['D', 'E', 'F']]

    def _test_finite(self, seq, n, expected):
        # Check with and without `len()`
>       self.assertEqual(list(mi.chunked_even(seq, n)), expected)
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4885: TypeError
</pre>
</details>
<h3 id="test_morepychunkedeventeststest_7">test_more.py::ChunkedEvenTests::test_7</h3>
<details><summary> <pre>test_more.py::ChunkedEvenTests::test_7</pre></summary><pre>
self = <tests.test_more.ChunkedEvenTests testMethod=test_7>

    def test_7(self):
>       self._test_finite(
            'ABCDEFG', 3, [['A', 'B', 'C'], ['D', 'E'], ['F', 'G']]
        )

tests/test_more.py:4879: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_more.ChunkedEvenTests testMethod=test_7>, seq = 'ABCDEFG'
n = 3, expected = [['A', 'B', 'C'], ['D', 'E'], ['F', 'G']]

    def _test_finite(self, seq, n, expected):
        # Check with and without `len()`
>       self.assertEqual(list(mi.chunked_even(seq, n)), expected)
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:4885: TypeError
</pre>
</details>
<h3 id="test_morepychunkedeventeststest_evenness">test_more.py::ChunkedEvenTests::test_evenness</h3>
<details><summary> <pre>test_more.py::ChunkedEvenTests::test_evenness</pre></summary><pre>
self = <tests.test_more.ChunkedEvenTests testMethod=test_evenness>

    def test_evenness(self):
        for N in range(1, 50):
            for n in range(1, N + 2):
                lengths = []
                items = []
>               for l in mi.chunked_even(range(N), n):
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:4908: TypeError
</pre>
</details>
<h3 id="test_morepychunkedeventeststest_infinite">test_more.py::ChunkedEvenTests::test_infinite</h3>
<details><summary> <pre>test_more.py::ChunkedEvenTests::test_infinite</pre></summary><pre>
self = <tests.test_more.ChunkedEvenTests testMethod=test_infinite>

    def test_infinite(self):
        for n in range(1, 5):
            k = 0

            def count_with_assert():
                for i in count():
                    # Look-ahead should be less than n^2
                    self.assertLessEqual(i, n * k + n * n)
                    yield i

            ls = mi.chunked_even(count_with_assert(), n)
            while k < 2:
>               self.assertEqual(next(ls), list(range(k * n, (k + 1) * n)))
E               TypeError: 'NoneType' object is not an iterator

tests/test_more.py:4900: TypeError
</pre>
</details>
<h3 id="test_morepyzipbroadcastteststest_scalar_types">test_more.py::ZipBroadcastTests::test_scalar_types</h3>
<details><summary> <pre>test_more.py::ZipBroadcastTests::test_scalar_types</pre></summary><pre>
self = <tests.test_more.ZipBroadcastTests testMethod=test_scalar_types>

    def test_scalar_types(self):
        # Default: str and bytes are treated as scalar
        self.assertEqual(
>           list(mi.zip_broadcast('ab', [1, 2, 3])),
            [('ab', 1), ('ab', 2), ('ab', 3)],
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5001: TypeError
</pre>
</details>
<h3 id="test_morepyzipbroadcastteststest_zip">test_more.py::ZipBroadcastTests::test_zip</h3>
<details><summary> <pre>test_more.py::ZipBroadcastTests::test_zip</pre></summary><pre>
self = <tests.test_more.ZipBroadcastTests testMethod=test_zip>

    def test_zip(self):
        for objects, zipped, strict_ok in [
            # Empty
            ([], [], True),
            # One argument
            ([1], [(1,)], True),
            ([[1]], [(1,)], True),
            ([[1, 2]], [(1,), (2,)], True),
            # All scalars
            ([1, 2], [(1, 2)], True),
            ([1, 2, 3], [(1, 2, 3)], True),
            # Iterables with length = 0
            ([[], 1], [], True),
            ([1, []], [], True),
            ([[], []], [], True),
            ([[], 1, 2], [], True),
            ([[], 1, []], [], True),
            ([1, [], 2], [], True),
            ([1, [], []], [], True),
            ([[], [], 1], [], True),
            ([[], [], []], [], True),
            # Iterables with length = 1
            ([1, [2]], [(1, 2)], True),
            ([[1], 2], [(1, 2)], True),
            ([[1], [2]], [(1, 2)], True),
            ([1, [2], 3], [(1, 2, 3)], True),
            ([1, [2], [3]], [(1, 2, 3)], True),
            ([[1], 2, 3], [(1, 2, 3)], True),
            ([[1], 2, [3]], [(1, 2, 3)], True),
            ([[1], [2], 3], [(1, 2, 3)], True),
            ([[1], [2], [3]], [(1, 2, 3)], True),
            # Iterables with length > 1
            ([1, [2, 3]], [(1, 2), (1, 3)], True),
            ([[1, 2], 3], [(1, 3), (2, 3)], True),
            ([[1, 2], [3, 4]], [(1, 3), (2, 4)], True),
            ([1, [2, 3], 4], [(1, 2, 4), (1, 3, 4)], True),
            ([1, [2, 3], [4, 5]], [(1, 2, 4), (1, 3, 5)], True),
            ([[1, 2], 3, 4], [(1, 3, 4), (2, 3, 4)], True),
            ([[1, 2], 3, [4, 5]], [(1, 3, 4), (2, 3, 5)], True),
            ([[1, 2], [3, 4], 5], [(1, 3, 5), (2, 4, 5)], True),
            ([[1, 2], [3, 4], [5, 6]], [(1, 3, 5), (2, 4, 6)], True),
            # Iterables with different lengths
            ([[], [1]], [], False),
            ([[1], []], [], False),
            ([[1], [2, 3]], [(1, 2)], False),
            ([[1, 2], [3]], [(1, 3)], False),
            ([[1, 2], [3], [4]], [(1, 3, 4)], False),
            ([[1], [2, 3], [4]], [(1, 2, 4)], False),
            ([[1], [2], [3, 4]], [(1, 2, 3)], False),
            ([[1], [2, 3], [4, 5]], [(1, 2, 4)], False),
            ([[1, 2], [3], [4, 5]], [(1, 3, 4)], False),
            ([[1, 2], [3, 4], [5]], [(1, 3, 5)], False),
            ([1, [2, 3], [4, 5, 6]], [(1, 2, 4), (1, 3, 5)], False),
            ([[1, 2], 3, [4, 5, 6]], [(1, 3, 4), (2, 3, 5)], False),
            ([1, [2, 3, 4], [5, 6]], [(1, 2, 5), (1, 3, 6)], False),
            ([[1, 2, 3], 4, [5, 6]], [(1, 4, 5), (2, 4, 6)], False),
            ([[1, 2], [3, 4, 5], 6], [(1, 3, 6), (2, 4, 6)], False),
            ([[1, 2, 3], [4, 5], 6], [(1, 4, 6), (2, 5, 6)], False),
            # Infinite
            ([count(), 1, [2]], [(0, 1, 2)], False),
            ([count(), 1, [2, 3]], [(0, 1, 2), (1, 1, 3)], False),
            # Miscellaneous
            (['a', [1, 2], [3, 4, 5]], [('a', 1, 3), ('a', 2, 4)], False),
        ]:
            # Truncate by default
            with self.subTest(objects=objects, strict=False, zipped=zipped):
>               self.assertEqual(list(mi.zip_broadcast(*objects)), zipped)
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:4985: TypeError
</pre>
</details>
<h3 id="test_morepyuniqueinwindowteststest_basic">test_more.py::UniqueInWindowTests::test_basic</h3>
<details><summary> <pre>test_more.py::UniqueInWindowTests::test_basic</pre></summary><pre>
self = <tests.test_more.UniqueInWindowTests testMethod=test_basic>

    def test_basic(self):
        for iterable, n, expected in [
            (range(9), 10, list(range(9))),
            (range(20), 10, list(range(20))),
            ([1, 2, 3, 4, 4, 4], 1, [1, 2, 3, 4, 4, 4]),
            ([1, 2, 3, 4, 4, 4], 2, [1, 2, 3, 4]),
            ([1, 2, 3, 4, 4, 4], 3, [1, 2, 3, 4]),
            ([1, 2, 3, 4, 4, 4], 4, [1, 2, 3, 4]),
            ([1, 2, 3, 4, 4, 4], 5, [1, 2, 3, 4]),
            (
                [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 3, 4, 2],
                2,
                [0, 1, 0, 2, 3, 4, 2],
            ),
        ]:
            with self.subTest(expected=expected):
>               actual = list(mi.unique_in_window(iterable, n))
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:5041: TypeError
</pre>
</details>
<h3 id="test_morepyuniqueinwindowteststest_invalid_n">test_more.py::UniqueInWindowTests::test_invalid_n</h3>
<details><summary> <pre>test_more.py::UniqueInWindowTests::test_invalid_n</pre></summary><pre>
self = <tests.test_more.UniqueInWindowTests testMethod=test_invalid_n>

    def test_invalid_n(self):
        with self.assertRaises(ValueError):
>           list(mi.unique_in_window([], 0))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:5023: TypeError
</pre>
</details>
<h3 id="test_morepyuniqueinwindowteststest_key">test_more.py::UniqueInWindowTests::test_key</h3>
<details><summary> <pre>test_more.py::UniqueInWindowTests::test_key</pre></summary><pre>
self = <tests.test_more.UniqueInWindowTests testMethod=test_key>

    def test_key(self):
        iterable = [0, 1, 3, 4, 5, 6, 7, 8, 9]
        n = 3
        key = lambda x: x // 3
>       actual = list(mi.unique_in_window(iterable, n, key=key))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5048: TypeError
</pre>
</details>
<h3 id="test_morepystrictlynteststest_basic">test_more.py::StrictlyNTests::test_basic</h3>
<details><summary> <pre>test_more.py::StrictlyNTests::test_basic</pre></summary><pre>
self = <tests.test_more.StrictlyNTests testMethod=test_basic>

    def test_basic(self):
        iterable = ['a', 'b', 'c', 'd']
        n = 4
>       actual = list(mi.strictly_n(iter(iterable), n))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5057: TypeError
</pre>
</details>
<h3 id="test_morepystrictlynteststest_too_long_custom">test_more.py::StrictlyNTests::test_too_long_custom</h3>
<details><summary> <pre>test_more.py::StrictlyNTests::test_too_long_custom</pre></summary><pre>
self = <tests.test_more.StrictlyNTests testMethod=test_too_long_custom>

    def test_too_long_custom(self):
        import logging

        iterable = ['a', 'b', 'c', 'd']
        n = 2
        too_long = lambda item_count: logging.warning(
            'Picked the first %s items', n
        )

        with self.assertLogs(level='WARNING') as cm:
>           actual = list(mi.strictly_n(iter(iterable), n, too_long=too_long))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:5108: TypeError
</pre>
</details>
<h3 id="test_morepystrictlynteststest_too_long_default">test_more.py::StrictlyNTests::test_too_long_default</h3>
<details><summary> <pre>test_more.py::StrictlyNTests::test_too_long_default</pre></summary><pre>
self = <tests.test_more.StrictlyNTests testMethod=test_too_long_default>

    def test_too_long_default(self):
        iterable = ['a', 'b', 'c', 'd']
        n = 3
        with self.assertRaises(ValueError) as cm:
>           list(mi.strictly_n(iter(iterable), n))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:5075: TypeError
</pre>
</details>
<h3 id="test_morepystrictlynteststest_too_short_custom">test_more.py::StrictlyNTests::test_too_short_custom</h3>
<details><summary> <pre>test_more.py::StrictlyNTests::test_too_short_custom</pre></summary><pre>
self = <tests.test_more.StrictlyNTests testMethod=test_too_short_custom>

    def test_too_short_custom(self):
        call_count = 0

        def too_short(item_count):
            nonlocal call_count
            call_count += 1

        iterable = ['a', 'b', 'c', 'd']
        n = 6
        actual = []
>       for item in mi.strictly_n(iter(iterable), n, too_short=too_short):
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5092: TypeError
</pre>
</details>
<h3 id="test_morepystrictlynteststest_too_short_default">test_more.py::StrictlyNTests::test_too_short_default</h3>
<details><summary> <pre>test_more.py::StrictlyNTests::test_too_short_default</pre></summary><pre>
self = <tests.test_more.StrictlyNTests testMethod=test_too_short_default>

    def test_too_short_default(self):
        iterable = ['a', 'b', 'c', 'd']
        n = 5
        with self.assertRaises(ValueError) as exc:
>           list(mi.strictly_n(iter(iterable), n))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:5065: TypeError
</pre>
</details>
<h3 id="test_morepyduplicateseverseenteststest_basic">test_more.py::DuplicatesEverSeenTests::test_basic</h3>
<details><summary> <pre>test_more.py::DuplicatesEverSeenTests::test_basic</pre></summary><pre>
self = <tests.test_more.DuplicatesEverSeenTests testMethod=test_basic>

    def test_basic(self):
        for iterable, expected in [
            ([], []),
            ([1, 2, 3], []),
            ([1, 1], [1]),
            ([1, 2, 1, 2], [1, 2]),
            ([1, 2, 3, '1'], []),
        ]:
            with self.subTest(args=(iterable,)):
                self.assertEqual(
>                   list(mi.duplicates_everseen(iterable)), expected
                )
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:5125: TypeError
</pre>
</details>
<h3 id="test_morepyduplicateseverseenteststest_key_hashable">test_more.py::DuplicatesEverSeenTests::test_key_hashable</h3>
<details><summary> <pre>test_more.py::DuplicatesEverSeenTests::test_key_hashable</pre></summary><pre>
self = <tests.test_more.DuplicatesEverSeenTests testMethod=test_key_hashable>

    def test_key_hashable(self):
        iterable = 'HEheHEhe'
>       self.assertEqual(list(mi.duplicates_everseen(iterable)), list('HEhe'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5149: TypeError
</pre>
</details>
<h3 id="test_morepyduplicateseverseenteststest_key_non_hashable">test_more.py::DuplicatesEverSeenTests::test_key_non_hashable</h3>
<details><summary> <pre>test_more.py::DuplicatesEverSeenTests::test_key_non_hashable</pre></summary><pre>
self = <tests.test_more.DuplicatesEverSeenTests testMethod=test_key_non_hashable>

    def test_key_non_hashable(self):
        iterable = [[1, 2], [3, 0], [5, -2], [5, 6]]
        self.assertEqual(
>           list(mi.duplicates_everseen(iterable, lambda x: x)), []
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5158: TypeError
</pre>
</details>
<h3 id="test_morepyduplicateseverseenteststest_key_partially_hashable">test_more.py::DuplicatesEverSeenTests::test_key_partially_hashable</h3>
<details><summary> <pre>test_more.py::DuplicatesEverSeenTests::test_key_partially_hashable</pre></summary><pre>
self = <tests.test_more.DuplicatesEverSeenTests testMethod=test_key_partially_hashable>

    def test_key_partially_hashable(self):
        iterable = [[1, 2], (1, 2), [1, 2], [5, 6]]
        self.assertEqual(
>           list(mi.duplicates_everseen(iterable, lambda x: x)), [[1, 2]]
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5167: TypeError
</pre>
</details>
<h3 id="test_morepyduplicateseverseenteststest_non_hashable">test_more.py::DuplicatesEverSeenTests::test_non_hashable</h3>
<details><summary> <pre>test_more.py::DuplicatesEverSeenTests::test_non_hashable</pre></summary><pre>
self = <tests.test_more.DuplicatesEverSeenTests testMethod=test_non_hashable>

    def test_non_hashable(self):
>       self.assertEqual(list(mi.duplicates_everseen([[1, 2], [3, 4]])), [])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5129: TypeError
</pre>
</details>
<h3 id="test_morepyduplicateseverseenteststest_partially_hashable">test_more.py::DuplicatesEverSeenTests::test_partially_hashable</h3>
<details><summary> <pre>test_more.py::DuplicatesEverSeenTests::test_partially_hashable</pre></summary><pre>
self = <tests.test_more.DuplicatesEverSeenTests testMethod=test_partially_hashable>

    def test_partially_hashable(self):
        self.assertEqual(
>           list(mi.duplicates_everseen([[1, 2], [3, 4], (5, 6)])), []
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5136: TypeError
</pre>
</details>
<h3 id="test_morepyduplicatesjustseenteststest_basic">test_more.py::DuplicatesJustSeenTests::test_basic</h3>
<details><summary> <pre>test_more.py::DuplicatesJustSeenTests::test_basic</pre></summary><pre>
self = <tests.test_more.DuplicatesJustSeenTests testMethod=test_basic>

    def test_basic(self):
        for iterable, expected in [
            ([], []),
            ([1, 2, 3, 3, 2, 2], [3, 2]),
            ([1, 1], [1]),
            ([1, 2, 1, 2], []),
            ([1, 2, 3, '1'], []),
        ]:
            with self.subTest(args=(iterable,)):
                self.assertEqual(
>                   list(mi.duplicates_justseen(iterable)), expected
                )
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:5185: TypeError
</pre>
</details>
<h3 id="test_morepyduplicatesjustseenteststest_key_hashable">test_more.py::DuplicatesJustSeenTests::test_key_hashable</h3>
<details><summary> <pre>test_more.py::DuplicatesJustSeenTests::test_key_hashable</pre></summary><pre>
self = <tests.test_more.DuplicatesJustSeenTests testMethod=test_key_hashable>

    def test_key_hashable(self):
        iterable = 'HEheHHHhEheeEe'
>       self.assertEqual(list(mi.duplicates_justseen(iterable)), list('HHe'))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5222: TypeError
</pre>
</details>
<h3 id="test_morepyduplicatesjustseenteststest_key_non_hashable">test_more.py::DuplicatesJustSeenTests::test_key_non_hashable</h3>
<details><summary> <pre>test_more.py::DuplicatesJustSeenTests::test_key_non_hashable</pre></summary><pre>
self = <tests.test_more.DuplicatesJustSeenTests testMethod=test_key_non_hashable>

    def test_key_non_hashable(self):
        iterable = [[1, 2], [3, 0], [5, -2], [5, 6], [1, 2]]
        self.assertEqual(
>           list(mi.duplicates_justseen(iterable, lambda x: x)), []
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5231: TypeError
</pre>
</details>
<h3 id="test_morepyduplicatesjustseenteststest_key_partially_hashable">test_more.py::DuplicatesJustSeenTests::test_key_partially_hashable</h3>
<details><summary> <pre>test_more.py::DuplicatesJustSeenTests::test_key_partially_hashable</pre></summary><pre>
self = <tests.test_more.DuplicatesJustSeenTests testMethod=test_key_partially_hashable>

    def test_key_partially_hashable(self):
        iterable = [[1, 2], (1, 2), [1, 2], [5, 6], [1, 2]]
        self.assertEqual(
>           list(mi.duplicates_justseen(iterable, lambda x: x)), []
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5240: TypeError
</pre>
</details>
<h3 id="test_morepyduplicatesjustseenteststest_nested">test_more.py::DuplicatesJustSeenTests::test_nested</h3>
<details><summary> <pre>test_more.py::DuplicatesJustSeenTests::test_nested</pre></summary><pre>
self = <tests.test_more.DuplicatesJustSeenTests testMethod=test_nested>

    def test_nested(self):
        iterable = [[[1, 2], [1, 2]], [5, 6], [5, 6]]
>       self.assertEqual(list(mi.duplicates_justseen(iterable)), [[5, 6]])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5248: TypeError
</pre>
</details>
<h3 id="test_morepyduplicatesjustseenteststest_non_hashable">test_more.py::DuplicatesJustSeenTests::test_non_hashable</h3>
<details><summary> <pre>test_more.py::DuplicatesJustSeenTests::test_non_hashable</pre></summary><pre>
self = <tests.test_more.DuplicatesJustSeenTests testMethod=test_non_hashable>

    def test_non_hashable(self):
>       self.assertEqual(list(mi.duplicates_justseen([[1, 2], [3, 4]])), [])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5189: TypeError
</pre>
</details>
<h3 id="test_morepyduplicatesjustseenteststest_partially_hashable">test_more.py::DuplicatesJustSeenTests::test_partially_hashable</h3>
<details><summary> <pre>test_more.py::DuplicatesJustSeenTests::test_partially_hashable</pre></summary><pre>
self = <tests.test_more.DuplicatesJustSeenTests testMethod=test_partially_hashable>

    def test_partially_hashable(self):
        self.assertEqual(
>           list(mi.duplicates_justseen([[1, 2], [3, 4], (5, 6)])), []
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5201: TypeError
</pre>
</details>
<h3 id="test_morepyclassifyuniqueteststest_basic">test_more.py::ClassifyUniqueTests::test_basic</h3>
<details><summary> <pre>test_more.py::ClassifyUniqueTests::test_basic</pre></summary><pre>
self = <tests.test_more.ClassifyUniqueTests testMethod=test_basic>

    def test_basic(self):
        self.assertEqual(
>           list(mi.classify_unique('mississippi')),
            [
                ('m', True, True),
                ('i', True, True),
                ('s', True, True),
                ('s', False, False),
                ('i', True, False),
                ('s', True, False),
                ('s', False, False),
                ('i', True, False),
                ('p', True, True),
                ('p', False, False),
                ('i', True, False),
            ],
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5254: TypeError
</pre>
</details>
<h3 id="test_morepyclassifyuniqueteststest_key_hashable">test_more.py::ClassifyUniqueTests::test_key_hashable</h3>
<details><summary> <pre>test_more.py::ClassifyUniqueTests::test_key_hashable</pre></summary><pre>
self = <tests.test_more.ClassifyUniqueTests testMethod=test_key_hashable>

    def test_key_hashable(self):
        iterable = 'HEheHHHhEheeEe'
        self.assertEqual(
>           list(mi.classify_unique(iterable)),
            [
                ('H', True, True),
                ('E', True, True),
                ('h', True, True),
                ('e', True, True),
                ('H', True, False),
                ('H', False, False),
                ('H', False, False),
                ('h', True, False),
                ('E', True, False),
                ('h', True, False),
                ('e', True, False),
                ('e', False, False),
                ('E', True, False),
                ('e', True, False),
            ],
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5301: TypeError
</pre>
</details>
<h3 id="test_morepyclassifyuniqueteststest_key_non_hashable">test_more.py::ClassifyUniqueTests::test_key_non_hashable</h3>
<details><summary> <pre>test_more.py::ClassifyUniqueTests::test_key_non_hashable</pre></summary><pre>
self = <tests.test_more.ClassifyUniqueTests testMethod=test_key_non_hashable>

    def test_key_non_hashable(self):
        iterable = [[1, 2], [3, 0], [5, -2], [5, 6], [1, 2]]
        self.assertEqual(
>           list(mi.classify_unique(iterable, lambda x: x)),
            [
                ([1, 2], True, True),
                ([3, 0], True, True),
                ([5, -2], True, True),
                ([5, 6], True, True),
                ([1, 2], True, False),
            ],
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5342: TypeError
</pre>
</details>
<h3 id="test_morepyclassifyuniqueteststest_key_partially_hashable">test_more.py::ClassifyUniqueTests::test_key_partially_hashable</h3>
<details><summary> <pre>test_more.py::ClassifyUniqueTests::test_key_partially_hashable</pre></summary><pre>
self = <tests.test_more.ClassifyUniqueTests testMethod=test_key_partially_hashable>

    def test_key_partially_hashable(self):
        iterable = [[1, 2], (1, 2), [1, 2], [5, 6], [1, 2]]
        self.assertEqual(
>           list(mi.classify_unique(iterable, lambda x: x)),
            [
                ([1, 2], True, True),
                ((1, 2), True, True),
                ([1, 2], True, False),
                ([5, 6], True, True),
                ([1, 2], True, False),
            ],
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5365: TypeError
</pre>
</details>
<h3 id="test_morepyclassifyuniqueteststest_non_hashable">test_more.py::ClassifyUniqueTests::test_non_hashable</h3>
<details><summary> <pre>test_more.py::ClassifyUniqueTests::test_non_hashable</pre></summary><pre>
self = <tests.test_more.ClassifyUniqueTests testMethod=test_non_hashable>

    def test_non_hashable(self):
        self.assertEqual(
>           list(mi.classify_unique([[1, 2], [3, 4], [3, 4], [1, 2]])),
            [
                ([1, 2], True, True),
                ([3, 4], True, True),
                ([3, 4], False, False),
                ([1, 2], True, False),
            ],
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5272: TypeError
</pre>
</details>
<h3 id="test_morepyclassifyuniqueteststest_partially_hashable">test_more.py::ClassifyUniqueTests::test_partially_hashable</h3>
<details><summary> <pre>test_more.py::ClassifyUniqueTests::test_partially_hashable</pre></summary><pre>
self = <tests.test_more.ClassifyUniqueTests testMethod=test_partially_hashable>

    def test_partially_hashable(self):
        self.assertEqual(
>           list(
                mi.classify_unique(
                    [[1, 2], [3, 4], (5, 6), (5, 6), (3, 4), [1, 2]]
                )
            ),
            [
                ([1, 2], True, True),
                ([3, 4], True, True),
                ((5, 6), True, True),
                ((5, 6), False, False),
                ((3, 4), True, True),
                ([1, 2], True, False),
            ],
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5283: TypeError
</pre>
</details>
<h3 id="test_morepyclassifyuniqueteststest_vs_duplicates_everseen">test_more.py::ClassifyUniqueTests::test_vs_duplicates_everseen</h3>
<details><summary> <pre>test_more.py::ClassifyUniqueTests::test_vs_duplicates_everseen</pre></summary><pre>
self = <tests.test_more.ClassifyUniqueTests testMethod=test_vs_duplicates_everseen>

    def test_vs_duplicates_everseen(self):
        input = [1, 2, 1, 2]
>       output = [e for e, j, u in mi.classify_unique(input) if not u]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5411: TypeError
</pre>
</details>
<h3 id="test_morepyclassifyuniqueteststest_vs_duplicates_everseen_key">test_more.py::ClassifyUniqueTests::test_vs_duplicates_everseen_key</h3>
<details><summary> <pre>test_more.py::ClassifyUniqueTests::test_vs_duplicates_everseen_key</pre></summary><pre>
self = <tests.test_more.ClassifyUniqueTests testMethod=test_vs_duplicates_everseen_key>

    def test_vs_duplicates_everseen_key(self):
        input = 'HEheHEhe'
        output = [
>           e for e, j, u in mi.classify_unique(input, str.lower) if not u
        ]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5418: TypeError
</pre>
</details>
<h3 id="test_morepyclassifyuniqueteststest_vs_duplicates_justseen">test_more.py::ClassifyUniqueTests::test_vs_duplicates_justseen</h3>
<details><summary> <pre>test_more.py::ClassifyUniqueTests::test_vs_duplicates_justseen</pre></summary><pre>
self = <tests.test_more.ClassifyUniqueTests testMethod=test_vs_duplicates_justseen>

    def test_vs_duplicates_justseen(self):
        input = [1, 2, 3, 3, 2, 2]
>       output = [e for e, j, u in mi.classify_unique(input) if not j]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5427: TypeError
</pre>
</details>
<h3 id="test_morepyclassifyuniqueteststest_vs_duplicates_justseen_key">test_more.py::ClassifyUniqueTests::test_vs_duplicates_justseen_key</h3>
<details><summary> <pre>test_more.py::ClassifyUniqueTests::test_vs_duplicates_justseen_key</pre></summary><pre>
self = <tests.test_more.ClassifyUniqueTests testMethod=test_vs_duplicates_justseen_key>

    def test_vs_duplicates_justseen_key(self):
        input = 'HEheHHHhEheeEe'
        output = [
>           e for e, j, u in mi.classify_unique(input, str.lower) if not j
        ]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5434: TypeError
</pre>
</details>
<h3 id="test_morepyclassifyuniqueteststest_vs_unique_everseen">test_more.py::ClassifyUniqueTests::test_vs_unique_everseen</h3>
<details><summary> <pre>test_more.py::ClassifyUniqueTests::test_vs_unique_everseen</pre></summary><pre>
self = <tests.test_more.ClassifyUniqueTests testMethod=test_vs_unique_everseen>

    def test_vs_unique_everseen(self):
        input = 'AAAABBBBCCDAABBB'
>       output = [e for e, j, u in mi.classify_unique(input) if u]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5387: TypeError
</pre>
</details>
<h3 id="test_morepyclassifyuniqueteststest_vs_unique_everseen_key">test_more.py::ClassifyUniqueTests::test_vs_unique_everseen_key</h3>
<details><summary> <pre>test_more.py::ClassifyUniqueTests::test_vs_unique_everseen_key</pre></summary><pre>
self = <tests.test_more.ClassifyUniqueTests testMethod=test_vs_unique_everseen_key>

    def test_vs_unique_everseen_key(self):
        input = 'aAbACCc'
>       output = [e for e, j, u in mi.classify_unique(input, str.lower) if u]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5393: TypeError
</pre>
</details>
<h3 id="test_morepyclassifyuniqueteststest_vs_unique_justseen">test_more.py::ClassifyUniqueTests::test_vs_unique_justseen</h3>
<details><summary> <pre>test_more.py::ClassifyUniqueTests::test_vs_unique_justseen</pre></summary><pre>
self = <tests.test_more.ClassifyUniqueTests testMethod=test_vs_unique_justseen>

    def test_vs_unique_justseen(self):
        input = 'AAAABBBCCDABB'
>       output = [e for e, j, u in mi.classify_unique(input) if j]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5399: TypeError
</pre>
</details>
<h3 id="test_morepyclassifyuniqueteststest_vs_unique_justseen_key">test_more.py::ClassifyUniqueTests::test_vs_unique_justseen_key</h3>
<details><summary> <pre>test_more.py::ClassifyUniqueTests::test_vs_unique_justseen_key</pre></summary><pre>
self = <tests.test_more.ClassifyUniqueTests testMethod=test_vs_unique_justseen_key>

    def test_vs_unique_justseen_key(self):
        input = 'AABCcAD'
>       output = [e for e, j, u in mi.classify_unique(input, str.lower) if j]
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5405: TypeError
</pre>
</details>
<h3 id="test_morepylongestcommonprefixteststest_basic">test_more.py::LongestCommonPrefixTests::test_basic</h3>
<details><summary> <pre>test_more.py::LongestCommonPrefixTests::test_basic</pre></summary><pre>
self = <tests.test_more.LongestCommonPrefixTests testMethod=test_basic>

    def test_basic(self):
        iterables = [[1, 2], [1, 2, 3], [1, 2, 4]]
>       self.assertEqual(list(mi.longest_common_prefix(iterables)), [1, 2])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5445: TypeError
</pre>
</details>
<h3 id="test_morepylongestcommonprefixteststest_contains_infinite_iterables">test_more.py::LongestCommonPrefixTests::test_contains_infinite_iterables</h3>
<details><summary> <pre>test_more.py::LongestCommonPrefixTests::test_contains_infinite_iterables</pre></summary><pre>
self = <tests.test_more.LongestCommonPrefixTests testMethod=test_contains_infinite_iterables>

    def test_contains_infinite_iterables(self):
        iterables = [[0, 1, 2], count()]
>       self.assertEqual(list(mi.longest_common_prefix(iterables)), [0, 1, 2])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5486: TypeError
</pre>
</details>
<h3 id="test_morepylongestcommonprefixteststest_empty_iterables_only">test_more.py::LongestCommonPrefixTests::test_empty_iterables_only</h3>
<details><summary> <pre>test_more.py::LongestCommonPrefixTests::test_empty_iterables_only</pre></summary><pre>
self = <tests.test_more.LongestCommonPrefixTests testMethod=test_empty_iterables_only>

    def test_empty_iterables_only(self):
        iterables = [[], [], []]
>       self.assertEqual(list(mi.longest_common_prefix(iterables)), [])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5457: TypeError
</pre>
</details>
<h3 id="test_morepylongestcommonprefixteststest_includes_empty_iterables">test_more.py::LongestCommonPrefixTests::test_includes_empty_iterables</h3>
<details><summary> <pre>test_more.py::LongestCommonPrefixTests::test_includes_empty_iterables</pre></summary><pre>
self = <tests.test_more.LongestCommonPrefixTests testMethod=test_includes_empty_iterables>

    def test_includes_empty_iterables(self):
        iterables = [[1, 2], [1, 2, 3], [1, 2, 4], []]
>       self.assertEqual(list(mi.longest_common_prefix(iterables)), [])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5461: TypeError
</pre>
</details>
<h3 id="test_morepylongestcommonprefixteststest_infinite_iterables">test_more.py::LongestCommonPrefixTests::test_infinite_iterables</h3>
<details><summary> <pre>test_more.py::LongestCommonPrefixTests::test_infinite_iterables</pre></summary><pre>
self = <tests.test_more.LongestCommonPrefixTests testMethod=test_infinite_iterables>

    def test_infinite_iterables(self):
        prefix = mi.longest_common_prefix([count(), count()])
>       self.assertEqual(next(prefix), 0)
E       TypeError: 'NoneType' object is not an iterator

tests/test_more.py:5480: TypeError
</pre>
</details>
<h3 id="test_morepylongestcommonprefixteststest_iterators">test_more.py::LongestCommonPrefixTests::test_iterators</h3>
<details><summary> <pre>test_more.py::LongestCommonPrefixTests::test_iterators</pre></summary><pre>
self = <tests.test_more.LongestCommonPrefixTests testMethod=test_iterators>

    def test_iterators(self):
        iterables = iter([iter([1, 2]), iter([1, 2, 3]), iter([1, 2, 4])])
>       self.assertEqual(list(mi.longest_common_prefix(iterables)), [1, 2])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5449: TypeError
</pre>
</details>
<h3 id="test_morepylongestcommonprefixteststest_no_iterables">test_more.py::LongestCommonPrefixTests::test_no_iterables</h3>
<details><summary> <pre>test_more.py::LongestCommonPrefixTests::test_no_iterables</pre></summary><pre>
self = <tests.test_more.LongestCommonPrefixTests testMethod=test_no_iterables>

    def test_no_iterables(self):
        iterables = []
>       self.assertEqual(list(mi.longest_common_prefix(iterables)), [])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5453: TypeError
</pre>
</details>
<h3 id="test_morepylongestcommonprefixteststest_non_hashable">test_more.py::LongestCommonPrefixTests::test_non_hashable</h3>
<details><summary> <pre>test_more.py::LongestCommonPrefixTests::test_non_hashable</pre></summary><pre>
self = <tests.test_more.LongestCommonPrefixTests testMethod=test_non_hashable>

    def test_non_hashable(self):
        # See https://github.com/more-itertools/more-itertools/issues/603
        iterables = [[[1], [2]], [[1], [2], [3]], [[1], [2], [4]]]
>       self.assertEqual(list(mi.longest_common_prefix(iterables)), [[1], [2]])
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5466: TypeError
</pre>
</details>
<h3 id="test_morepylongestcommonprefixteststest_prefix_contains_elements_of_the_first_iterable">test_more.py::LongestCommonPrefixTests::test_prefix_contains_elements_of_the_first_iterable</h3>
<details><summary> <pre>test_more.py::LongestCommonPrefixTests::test_prefix_contains_elements_of_the_first_iterable</pre></summary><pre>
self = <tests.test_more.LongestCommonPrefixTests testMethod=test_prefix_contains_elements_of_the_first_iterable>

    def test_prefix_contains_elements_of_the_first_iterable(self):
        iterables = [[[1], [2]], [[1], [2], [3]], [[1], [2], [4]]]
>       prefix = list(mi.longest_common_prefix(iterables))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5470: TypeError
</pre>
</details>
<h3 id="test_morepyiequalsteststest_basic">test_more.py::IequalsTests::test_basic</h3>
<details><summary> <pre>test_more.py::IequalsTests::test_basic</pre></summary><pre>
self = <tests.test_more.IequalsTests testMethod=test_basic>

    def test_basic(self):
>       self.assertTrue(mi.iequals("abc", iter("abc")))
E       AssertionError: None is not true

tests/test_more.py:5491: AssertionError
</pre>
</details>
<h3 id="test_morepyiequalsteststest_empty_iterables">test_more.py::IequalsTests::test_empty_iterables</h3>
<details><summary> <pre>test_more.py::IequalsTests::test_empty_iterables</pre></summary><pre>
self = <tests.test_more.IequalsTests testMethod=test_empty_iterables>

    def test_empty_iterables(self):
>       self.assertTrue(mi.iequals([], ""))
E       AssertionError: None is not true

tests/test_more.py:5514: AssertionError
</pre>
</details>
<h3 id="test_morepyiequalsteststest_more_than_two_iterable">test_more.py::IequalsTests::test_more_than_two_iterable</h3>
<details><summary> <pre>test_more.py::IequalsTests::test_more_than_two_iterable</pre></summary><pre>
self = <tests.test_more.IequalsTests testMethod=test_more_than_two_iterable>

    def test_more_than_two_iterable(self):
>       self.assertTrue(mi.iequals("abc", iter("abc"), ['a', 'b', 'c']))
E       AssertionError: None is not true

tests/test_more.py:5502: AssertionError
</pre>
</details>
<h3 id="test_morepyiequalsteststest_no_iterables">test_more.py::IequalsTests::test_no_iterables</h3>
<details><summary> <pre>test_more.py::IequalsTests::test_no_iterables</pre></summary><pre>
self = <tests.test_more.IequalsTests testMethod=test_no_iterables>

    def test_no_iterables(self):
>       self.assertTrue(mi.iequals())
E       AssertionError: None is not true

tests/test_more.py:5496: AssertionError
</pre>
</details>
<h3 id="test_morepyiequalsteststest_one_iterable">test_more.py::IequalsTests::test_one_iterable</h3>
<details><summary> <pre>test_more.py::IequalsTests::test_one_iterable</pre></summary><pre>
self = <tests.test_more.IequalsTests testMethod=test_one_iterable>

    def test_one_iterable(self):
>       self.assertTrue(mi.iequals("abc"))
E       AssertionError: None is not true

tests/test_more.py:5499: AssertionError
</pre>
</details>
<h3 id="test_morepyconstrainedbatchesteststest_bad_max">test_more.py::ConstrainedBatchesTests::test_bad_max</h3>
<details><summary> <pre>test_more.py::ConstrainedBatchesTests::test_bad_max</pre></summary><pre>
self = <tests.test_more.ConstrainedBatchesTests testMethod=test_bad_max>

    def test_bad_max(self):
        with self.assertRaises(ValueError):
>           list(mi.constrained_batches([], 0))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:5623: TypeError
</pre>
</details>
<h3 id="test_morepyconstrainedbatchesteststest_basic">test_more.py::ConstrainedBatchesTests::test_basic</h3>
<details><summary> <pre>test_more.py::ConstrainedBatchesTests::test_basic</pre></summary><pre>
self = <tests.test_more.ConstrainedBatchesTests testMethod=test_basic>

    def test_basic(self):
        zen = [
            'Beautiful is better than ugly',
            'Explicit is better than implicit',
            'Simple is better than complex',
            'Complex is better than complicated',
            'Flat is better than nested',
            'Sparse is better than dense',
            'Readability counts',
        ]
        for size, expected in (
            (
                34,
                [
                    (zen[0],),
                    (zen[1],),
                    (zen[2],),
                    (zen[3],),
                    (zen[4],),
                    (zen[5],),
                    (zen[6],),
                ],
            ),
            (
                61,
                [
                    (zen[0], zen[1]),
                    (zen[2],),
                    (zen[3], zen[4]),
                    (zen[5], zen[6]),
                ],
            ),
            (
                90,
                [
                    (zen[0], zen[1], zen[2]),
                    (zen[3], zen[4], zen[5]),
                    (zen[6],),
                ],
            ),
            (
                124,
                [(zen[0], zen[1], zen[2], zen[3]), (zen[4], zen[5], zen[6])],
            ),
            (
                150,
                [(zen[0], zen[1], zen[2], zen[3], zen[4]), (zen[5], zen[6])],
            ),
            (
                177,
                [(zen[0], zen[1], zen[2], zen[3], zen[4], zen[5]), (zen[6],)],
            ),
        ):
            with self.subTest(size=size):
>               actual = list(mi.constrained_batches(iter(zen), size))
E               TypeError: 'NoneType' object is not iterable

tests/test_more.py:5580: TypeError
</pre>
</details>
<h3 id="test_morepyconstrainedbatchesteststest_get_len">test_more.py::ConstrainedBatchesTests::test_get_len</h3>
<details><summary> <pre>test_more.py::ConstrainedBatchesTests::test_get_len</pre></summary><pre>
self = <tests.test_more.ConstrainedBatchesTests testMethod=test_get_len>

    def test_get_len(self):
        class Record(tuple):
            def total_size(self):
                return sum(len(x) for x in self)

        record_3 = Record(('1', '23'))
        record_5 = Record(('1234', '1'))
        record_10 = Record(('1', '12345678', '1'))
        record_2 = Record(('1', '1'))
        iterable = [record_3, record_5, record_10, record_2]

        self.assertEqual(
>           list(
                mi.constrained_batches(
                    iterable, 10, get_len=lambda x: x.total_size()
                )
            ),
            [(record_3, record_5), (record_10,), (record_2,)],
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5613: TypeError
</pre>
</details>
<h3 id="test_morepyconstrainedbatchesteststest_max_count">test_more.py::ConstrainedBatchesTests::test_max_count</h3>
<details><summary> <pre>test_more.py::ConstrainedBatchesTests::test_max_count</pre></summary><pre>
self = <tests.test_more.ConstrainedBatchesTests testMethod=test_max_count>

    def test_max_count(self):
        iterable = ['1', '1', '12345678', '12345', '12345']
        max_size = 10
        max_count = 2
>       actual = list(mi.constrained_batches(iterable, max_size, max_count))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5587: TypeError
</pre>
</details>
<h3 id="test_morepyconstrainedbatchesteststest_strict">test_more.py::ConstrainedBatchesTests::test_strict</h3>
<details><summary> <pre>test_more.py::ConstrainedBatchesTests::test_strict</pre></summary><pre>
self = <tests.test_more.ConstrainedBatchesTests testMethod=test_strict>

    def test_strict(self):
        iterable = ['1', '123456789', '1']
        size = 8
        with self.assertRaises(ValueError):
>           list(mi.constrained_batches(iterable, size))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:5595: TypeError
</pre>
</details>
<h3 id="test_morepygrayproductteststest_basic">test_more.py::GrayProductTests::test_basic</h3>
<details><summary> <pre>test_more.py::GrayProductTests::test_basic</pre></summary><pre>
self = <tests.test_more.GrayProductTests testMethod=test_basic>

    def test_basic(self):
        self.assertEqual(
>           tuple(mi.gray_product(('a', 'b', 'c'), range(1, 3))),
            (("a", 1), ("b", 1), ("c", 1), ("c", 2), ("b", 2), ("a", 2)),
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5629: TypeError
</pre>
</details>
<h3 id="test_morepygrayproductteststest_errors">test_more.py::GrayProductTests::test_errors</h3>
<details><summary> <pre>test_more.py::GrayProductTests::test_errors</pre></summary><pre>
self = <tests.test_more.GrayProductTests testMethod=test_errors>

    def test_errors(self):
        with self.assertRaises(ValueError):
>           list(mi.gray_product((1, 2), ()))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:5659: TypeError
</pre>
</details>
<h3 id="test_morepygrayproductteststest_vs_product">test_more.py::GrayProductTests::test_vs_product</h3>
<details><summary> <pre>test_more.py::GrayProductTests::test_vs_product</pre></summary><pre>
self = <tests.test_more.GrayProductTests testMethod=test_vs_product>

    def test_vs_product(self):
        iters = (
            ("a", "b"),
            range(3, 6),
            [None, None],
            {"i", "j", "k", "l"},
            "XYZ",
        )
        self.assertEqual(
>           sorted(product(*iters)), sorted(mi.gray_product(*iters))
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5672: TypeError
</pre>
</details>
<h3 id="test_morepypartialproductteststest_basic">test_more.py::PartialProductTests::test_basic</h3>
<details><summary> <pre>test_more.py::PartialProductTests::test_basic</pre></summary><pre>
self = <tests.test_more.PartialProductTests testMethod=test_basic>

    def test_basic(self):
        ones = [1, 2, 3]
        tens = [10, 20, 30, 40, 50]
        hundreds = [100, 200]

        expected = [
            (1, 10, 100),
            (2, 10, 100),
            (3, 10, 100),
            (3, 20, 100),
            (3, 30, 100),
            (3, 40, 100),
            (3, 50, 100),
            (3, 50, 200),
        ]

>       actual = list(mi.partial_product(ones, tens, hundreds))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5729: TypeError
</pre>
</details>
<h3 id="test_morepypartialproductteststest_empty_iterable">test_more.py::PartialProductTests::test_empty_iterable</h3>
<details><summary> <pre>test_more.py::PartialProductTests::test_empty_iterable</pre></summary><pre>
self = <tests.test_more.PartialProductTests testMethod=test_empty_iterable>

    def test_empty_iterable(self):
>       self.assertEqual(tuple(mi.partial_product('AB', '', 'CD')), ())
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5681: TypeError
</pre>
</details>
<h3 id="test_morepypartialproductteststest_no_iterables">test_more.py::PartialProductTests::test_no_iterables</h3>
<details><summary> <pre>test_more.py::PartialProductTests::test_no_iterables</pre></summary><pre>
self = <tests.test_more.PartialProductTests testMethod=test_no_iterables>

    def test_no_iterables(self):
>       self.assertEqual(tuple(mi.partial_product()), ((),))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5678: TypeError
</pre>
</details>
<h3 id="test_morepypartialproductteststest_one_iterable">test_more.py::PartialProductTests::test_one_iterable</h3>
<details><summary> <pre>test_more.py::PartialProductTests::test_one_iterable</pre></summary><pre>
self = <tests.test_more.PartialProductTests testMethod=test_one_iterable>

    def test_one_iterable(self):
        # a single iterable should pass through
        self.assertEqual(
>           tuple(mi.partial_product('ABCD')),
            (
                ('A',),
                ('B',),
                ('C',),
                ('D',),
            ),
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5686: TypeError
</pre>
</details>
<h3 id="test_morepypartialproductteststest_two_iterables">test_more.py::PartialProductTests::test_two_iterables</h3>
<details><summary> <pre>test_more.py::PartialProductTests::test_two_iterables</pre></summary><pre>
self = <tests.test_more.PartialProductTests testMethod=test_two_iterables>

    def test_two_iterables(self):
        self.assertEqual(
>           list(mi.partial_product('ABCD', [1])),
            [('A', 1), ('B', 1), ('C', 1), ('D', 1)],
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5697: TypeError
</pre>
</details>
<h3 id="test_morepypartialproductteststest_uneven_length_iterables">test_more.py::PartialProductTests::test_uneven_length_iterables</h3>
<details><summary> <pre>test_more.py::PartialProductTests::test_uneven_length_iterables</pre></summary><pre>
self = <tests.test_more.PartialProductTests testMethod=test_uneven_length_iterables>

    def test_uneven_length_iterables(self):
        # this is also the docstring example
        expected = [
            ('A', 'C', 'D'),
            ('B', 'C', 'D'),
            ('B', 'C', 'E'),
            ('B', 'C', 'F'),
        ]

>       self.assertEqual(list(mi.partial_product('AB', 'C', 'DEF')), expected)
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5741: TypeError
</pre>
</details>
<h3 id="test_morepyiterateteststest_basic">test_more.py::IterateTests::test_basic</h3>
<details><summary> <pre>test_more.py::IterateTests::test_basic</pre></summary><pre>
self = <tests.test_more.IterateTests testMethod=test_basic>

    def test_basic(self) -> None:
>       result = list(islice(mi.iterate(lambda x: 2 * x, start=1), 10))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5746: TypeError
</pre>
</details>
<h3 id="test_morepyiterateteststest_func_controls_iteration_stop">test_more.py::IterateTests::test_func_controls_iteration_stop</h3>
<details><summary> <pre>test_more.py::IterateTests::test_func_controls_iteration_stop</pre></summary><pre>
self = <tests.test_more.IterateTests testMethod=test_func_controls_iteration_stop>

    def test_func_controls_iteration_stop(self) -> None:
        def func(num):
            if num > 100:
                raise StopIteration
            return num * 2

>       result = list(islice(mi.iterate(func, start=1), 10))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5756: TypeError
</pre>
</details>
<h3 id="test_morepytakewhileinclusiveteststest_basic">test_more.py::TakewhileInclusiveTests::test_basic</h3>
<details><summary> <pre>test_more.py::TakewhileInclusiveTests::test_basic</pre></summary><pre>
self = <tests.test_more.TakewhileInclusiveTests testMethod=test_basic>

    def test_basic(self) -> None:
>       result = list(mi.takewhile_inclusive(lambda x: x < 5, [1, 4, 6, 4, 1]))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5763: TypeError
</pre>
</details>
<h3 id="test_morepytakewhileinclusiveteststest_collatz_sequence">test_more.py::TakewhileInclusiveTests::test_collatz_sequence</h3>
<details><summary> <pre>test_more.py::TakewhileInclusiveTests::test_collatz_sequence</pre></summary><pre>
self = <tests.test_more.TakewhileInclusiveTests testMethod=test_collatz_sequence>

    def test_collatz_sequence(self) -> None:
        is_even = lambda n: n % 2 == 0
        start = 11
>       result = list(
            mi.takewhile_inclusive(
                lambda n: n != 1,
                mi.iterate(
                    lambda n: n // 2 if is_even(n) else 3 * n + 1, start
                ),
            )
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5775: TypeError
</pre>
</details>
<h3 id="test_morepytakewhileinclusiveteststest_empty_iterator">test_more.py::TakewhileInclusiveTests::test_empty_iterator</h3>
<details><summary> <pre>test_more.py::TakewhileInclusiveTests::test_empty_iterator</pre></summary><pre>
self = <tests.test_more.TakewhileInclusiveTests testMethod=test_empty_iterator>

    def test_empty_iterator(self) -> None:
>       result = list(mi.takewhile_inclusive(lambda x: True, []))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5768: TypeError
</pre>
</details>
<h3 id="test_morepyouterproductteststest_basic">test_more.py::OuterProductTests::test_basic</h3>
<details><summary> <pre>test_more.py::OuterProductTests::test_basic</pre></summary><pre>
self = <tests.test_more.OuterProductTests testMethod=test_basic>

    def test_basic(self) -> None:
        greetings = ['Hello', 'Goodbye']
        names = ['Alice', 'Bob', 'Carol']
        greet = lambda greeting, name: f'{greeting}, {name}!'
>       result = list(mi.outer_product(greet, greetings, names))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5792: TypeError
</pre>
</details>
<h3 id="test_morepyitersuppressteststest_early_suppression">test_more.py::IterSuppressTests::test_early_suppression</h3>
<details><summary> <pre>test_more.py::IterSuppressTests::test_early_suppression</pre></summary><pre>
self = <tests.test_more.IterSuppressTests testMethod=test_early_suppression>

    def test_early_suppression(self):
        iterator = self.Producer(ValueError, die_early=True)
>       actual = list(mi.iter_suppress(iterator, RuntimeError, ValueError))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5839: TypeError
</pre>
</details>
<h3 id="test_morepyitersuppressteststest_no_error">test_more.py::IterSuppressTests::test_no_error</h3>
<details><summary> <pre>test_more.py::IterSuppressTests::test_no_error</pre></summary><pre>
self = <tests.test_more.IterSuppressTests testMethod=test_no_error>

    def test_no_error(self):
        iterator = range(5)
>       actual = list(mi.iter_suppress(iterator, RuntimeError))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5822: TypeError
</pre>
</details>
<h3 id="test_morepyitersuppressteststest_raises_error">test_more.py::IterSuppressTests::test_raises_error</h3>
<details><summary> <pre>test_more.py::IterSuppressTests::test_raises_error</pre></summary><pre>
self = <tests.test_more.IterSuppressTests testMethod=test_raises_error>

    def test_raises_error(self):
        iterator = self.Producer(ValueError)
        with self.assertRaises(ValueError):
>           list(mi.iter_suppress(iterator, RuntimeError))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:5829: TypeError
</pre>
</details>
<h3 id="test_morepyitersuppressteststest_suppression">test_more.py::IterSuppressTests::test_suppression</h3>
<details><summary> <pre>test_more.py::IterSuppressTests::test_suppression</pre></summary><pre>
self = <tests.test_more.IterSuppressTests testMethod=test_suppression>

    def test_suppression(self):
        iterator = self.Producer(ValueError)
>       actual = list(mi.iter_suppress(iterator, RuntimeError, ValueError))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5833: TypeError
</pre>
</details>
<h3 id="test_morepyfiltermapteststest_filter">test_more.py::FilterMapTests::test_filter</h3>
<details><summary> <pre>test_more.py::FilterMapTests::test_filter</pre></summary><pre>
self = <tests.test_more.FilterMapTests testMethod=test_filter>

    def test_filter(self):
>       actual = list(mi.filter_map(lambda _: None, [1, 2, 3]))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5851: TypeError
</pre>
</details>
<h3 id="test_morepyfiltermapteststest_filter_map">test_more.py::FilterMapTests::test_filter_map</h3>
<details><summary> <pre>test_more.py::FilterMapTests::test_filter_map</pre></summary><pre>
self = <tests.test_more.FilterMapTests testMethod=test_filter_map>

    def test_filter_map(self):
>       actual = list(
            mi.filter_map(
                lambda x: int(x) if x.isnumeric() else None,
                ['1', 'a', '2', 'b', '3'],
            )
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5861: TypeError
</pre>
</details>
<h3 id="test_morepyfiltermapteststest_map">test_more.py::FilterMapTests::test_map</h3>
<details><summary> <pre>test_more.py::FilterMapTests::test_map</pre></summary><pre>
self = <tests.test_more.FilterMapTests testMethod=test_map>

    def test_map(self):
>       actual = list(mi.filter_map(lambda x: x + 1, [1, 2, 3]))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5856: TypeError
</pre>
</details>
<h3 id="test_morepyfiltermapteststest_no_iterables">test_more.py::FilterMapTests::test_no_iterables</h3>
<details><summary> <pre>test_more.py::FilterMapTests::test_no_iterables</pre></summary><pre>
self = <tests.test_more.FilterMapTests testMethod=test_no_iterables>

    def test_no_iterables(self):
>       actual = list(mi.filter_map(lambda _: None, []))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5846: TypeError
</pre>
</details>
<h3 id="test_morepypowersetofsetsteststest_hash_count">test_more.py::PowersetOfSetsTests::test_hash_count</h3>
<details><summary> <pre>test_more.py::PowersetOfSetsTests::test_hash_count</pre></summary><pre>
self = <tests.test_more.PowersetOfSetsTests testMethod=test_hash_count>

    def test_hash_count(self):
        hash_count = 0

        class Str(str):
            def __hash__(true_self):
                nonlocal hash_count
                hash_count += 1
                return super.__hash__(true_self)

        iterable = map(Str, 'ABBBCDD')
>       self.assertEqual(len(list(mi.powerset_of_sets(iterable))), 128)
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5888: TypeError
</pre>
</details>
<h3 id="test_morepypowersetofsetsteststest_simple">test_more.py::PowersetOfSetsTests::test_simple</h3>
<details><summary> <pre>test_more.py::PowersetOfSetsTests::test_simple</pre></summary><pre>
self = <tests.test_more.PowersetOfSetsTests testMethod=test_simple>

    def test_simple(self):
        iterable = [0, 1, 2]
>       actual = list(mi.powerset_of_sets(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5874: TypeError
</pre>
</details>
<h3 id="test_morepyjoinmappingteststest_basic">test_more.py::JoinMappingTests::test_basic</h3>
<details><summary> <pre>test_more.py::JoinMappingTests::test_basic</pre></summary><pre>
self = <tests.test_more.JoinMappingTests testMethod=test_basic>

    def test_basic(self):
        salary_map = {'e1': 12, 'e2': 23, 'e3': 34}
        dept_map = {'e1': 'eng', 'e2': 'sales', 'e3': 'eng'}
        service_map = {'e1': 5, 'e2': 9, 'e3': 2}
        field_to_map = {
            'salary': salary_map,
            'dept': dept_map,
            'service': service_map,
        }
        expected = {
            'e1': {'salary': 12, 'dept': 'eng', 'service': 5},
            'e2': {'salary': 23, 'dept': 'sales', 'service': 9},
            'e3': {'salary': 34, 'dept': 'eng', 'service': 2},
        }
>       self.assertEqual(dict(mi.join_mappings(**field_to_map)), expected)
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5907: TypeError
</pre>
</details>
<h3 id="test_morepyjoinmappingteststest_empty">test_more.py::JoinMappingTests::test_empty</h3>
<details><summary> <pre>test_more.py::JoinMappingTests::test_empty</pre></summary><pre>
self = <tests.test_more.JoinMappingTests testMethod=test_empty>

    def test_empty(self):
>       self.assertEqual(dict(mi.join_mappings()), {})
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5910: TypeError
</pre>
</details>
<h3 id="test_morepydiscretefouriertransformteststest_basic">test_more.py::DiscreteFourierTransformTests::test_basic</h3>
<details><summary> <pre>test_more.py::DiscreteFourierTransformTests::test_basic</pre></summary><pre>
self = <tests.test_more.DiscreteFourierTransformTests testMethod=test_basic>

    def test_basic(self):
        # Example calculation from:
        # https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Example
        xarr = [1, 2 - 1j, -1j, -1 + 2j]
        Xarr = [2, -2 - 2j, -2j, 4 + 4j]
>       self.assertTrue(all(map(cmath.isclose, mi.dft(xarr), Xarr)))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5919: TypeError
</pre>
</details>
<h3 id="test_morepydiscretefouriertransformteststest_roundtrip">test_more.py::DiscreteFourierTransformTests::test_roundtrip</h3>
<details><summary> <pre>test_more.py::DiscreteFourierTransformTests::test_roundtrip</pre></summary><pre>
self = <tests.test_more.DiscreteFourierTransformTests testMethod=test_roundtrip>

    def test_roundtrip(self):
        for _ in range(1_000):
            N = randrange(35)
            xarr = [complex(random(), random()) for i in range(N)]
>           Xarr = list(mi.dft(xarr))
E           TypeError: 'NoneType' object is not iterable

tests/test_more.py:5926: TypeError
</pre>
</details>
<h3 id="test_morepydoublestarmapteststest_adding">test_more.py::DoubleStarMapTests::test_adding</h3>
<details><summary> <pre>test_more.py::DoubleStarMapTests::test_adding</pre></summary><pre>
self = <tests.test_more.DoubleStarMapTests testMethod=test_adding>

    def test_adding(self):
        iterable = [{'a': 1, 'b': 2}, {'a': 3, 'b': 4}]
>       actual = list(mi.doublestarmap(lambda a, b: a + b, iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5945: TypeError
</pre>
</details>
<h3 id="test_morepydoublestarmapteststest_construction">test_more.py::DoubleStarMapTests::test_construction</h3>
<details><summary> <pre>test_more.py::DoubleStarMapTests::test_construction</pre></summary><pre>
self = <tests.test_more.DoubleStarMapTests testMethod=test_construction>

    def test_construction(self):
        iterable = [{'price': 1.23}, {'price': 42}, {'price': 0.1}]
>       actual = list(mi.doublestarmap('{price:.2f}'.format, iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5933: TypeError
</pre>
</details>
<h3 id="test_morepydoublestarmapteststest_empty">test_more.py::DoubleStarMapTests::test_empty</h3>
<details><summary> <pre>test_more.py::DoubleStarMapTests::test_empty</pre></summary><pre>
self = <tests.test_more.DoubleStarMapTests testMethod=test_empty>

    def test_empty(self):
>       actual = list(mi.doublestarmap(lambda x: x, []))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5970: TypeError
</pre>
</details>
<h3 id="test_morepydoublestarmapteststest_identity">test_more.py::DoubleStarMapTests::test_identity</h3>
<details><summary> <pre>test_more.py::DoubleStarMapTests::test_identity</pre></summary><pre>
self = <tests.test_more.DoubleStarMapTests testMethod=test_identity>

    def test_identity(self):
        iterable = [{'x': 1}, {'x': 2}, {'x': 3}]
>       actual = list(mi.doublestarmap(lambda x: x, iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_more.py:5939: TypeError
</pre>
</details>
<h3 id="test_recipespytabulateteststest_count">test_recipes.py::TabulateTests::test_count</h3>
<details><summary> <pre>test_recipes.py::TabulateTests::test_count</pre></summary><pre>
self = <tests.test_recipes.TabulateTests testMethod=test_count>

    def test_count(self):
        """Ensure tabulate accepts specific count"""
        t = mi.tabulate(lambda x: 2 * x, -1)
>       f = (next(t), next(t), next(t))
E       TypeError: 'NoneType' object is not an iterator

tests/test_recipes.py:58: TypeError
</pre>
</details>
<h3 id="test_recipespytabulateteststest_simple_tabulate">test_recipes.py::TabulateTests::test_simple_tabulate</h3>
<details><summary> <pre>test_recipes.py::TabulateTests::test_simple_tabulate</pre></summary><pre>
self = <tests.test_recipes.TabulateTests testMethod=test_simple_tabulate>

    def test_simple_tabulate(self):
        """Test the happy path"""
        t = mi.tabulate(lambda x: x)
>       f = tuple([next(t) for _ in range(3)])
E       TypeError: 'NoneType' object is not an iterator

tests/test_recipes.py:52: TypeError
</pre>
</details>
<h3 id="test_recipespytailteststest_iterator_equal">test_recipes.py::TailTests::test_iterator_equal</h3>
<details><summary> <pre>test_recipes.py::TailTests::test_iterator_equal</pre></summary><pre>
self = <tests.test_recipes.TailTests testMethod=test_iterator_equal>

    def test_iterator_equal(self):
        """Length of iterator is equal to the requested tail"""
>       self.assertEqual(list(mi.tail(7, iter('ABCDEFG'))), list('ABCDEFG'))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:71: TypeError
</pre>
</details>
<h3 id="test_recipespytailteststest_iterator_greater">test_recipes.py::TailTests::test_iterator_greater</h3>
<details><summary> <pre>test_recipes.py::TailTests::test_iterator_greater</pre></summary><pre>
self = <tests.test_recipes.TailTests testMethod=test_iterator_greater>

    def test_iterator_greater(self):
        """Length of iterator is greater than requested tail"""
>       self.assertEqual(list(mi.tail(3, iter('ABCDEFG'))), list('EFG'))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:67: TypeError
</pre>
</details>
<h3 id="test_recipespytailteststest_iterator_less">test_recipes.py::TailTests::test_iterator_less</h3>
<details><summary> <pre>test_recipes.py::TailTests::test_iterator_less</pre></summary><pre>
self = <tests.test_recipes.TailTests testMethod=test_iterator_less>

    def test_iterator_less(self):
        """Length of iterator is less than requested tail"""
>       self.assertEqual(list(mi.tail(8, iter('ABCDEFG'))), list('ABCDEFG'))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:75: TypeError
</pre>
</details>
<h3 id="test_recipespytailteststest_sized_equal">test_recipes.py::TailTests::test_sized_equal</h3>
<details><summary> <pre>test_recipes.py::TailTests::test_sized_equal</pre></summary><pre>
self = <tests.test_recipes.TailTests testMethod=test_sized_equal>

    def test_sized_equal(self):
        """Length of sized iterable is less than requested tail"""
>       self.assertEqual(list(mi.tail(7, 'ABCDEFG')), list('ABCDEFG'))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:83: TypeError
</pre>
</details>
<h3 id="test_recipespytailteststest_sized_greater">test_recipes.py::TailTests::test_sized_greater</h3>
<details><summary> <pre>test_recipes.py::TailTests::test_sized_greater</pre></summary><pre>
self = <tests.test_recipes.TailTests testMethod=test_sized_greater>

    def test_sized_greater(self):
        """Length of sized iterable is greater than requested tail"""
>       self.assertEqual(list(mi.tail(3, 'ABCDEFG')), list('EFG'))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:79: TypeError
</pre>
</details>
<h3 id="test_recipespytailteststest_sized_less">test_recipes.py::TailTests::test_sized_less</h3>
<details><summary> <pre>test_recipes.py::TailTests::test_sized_less</pre></summary><pre>
self = <tests.test_recipes.TailTests testMethod=test_sized_less>

    def test_sized_less(self):
        """Length of sized iterable is less than requested tail"""
>       self.assertEqual(list(mi.tail(8, 'ABCDEFG')), list('ABCDEFG'))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:87: TypeError
</pre>
</details>
<h3 id="test_recipespyconsumeteststest_negative_consume">test_recipes.py::ConsumeTests::test_negative_consume</h3>
<details><summary> <pre>test_recipes.py::ConsumeTests::test_negative_consume</pre></summary><pre>
self = <tests.test_recipes.ConsumeTests testMethod=test_negative_consume>

    def test_negative_consume(self):
        """Check that negative consumption throws an error"""
        r = (x for x in range(10))
>       self.assertRaises(ValueError, lambda: mi.consume(r, -1))
E       AssertionError: ValueError not raised by <lambda>

tests/test_recipes.py:108: AssertionError
</pre>
</details>
<h3 id="test_recipespyconsumeteststest_sanity">test_recipes.py::ConsumeTests::test_sanity</h3>
<details><summary> <pre>test_recipes.py::ConsumeTests::test_sanity</pre></summary><pre>
self = <tests.test_recipes.ConsumeTests testMethod=test_sanity>

    def test_sanity(self):
        """Test basic functionality"""
        r = (x for x in range(10))
        mi.consume(r, 3)
>       self.assertEqual(3, next(r))
E       AssertionError: 3 != 0

tests/test_recipes.py:97: AssertionError
</pre>
</details>
<h3 id="test_recipespyconsumeteststest_total_consume">test_recipes.py::ConsumeTests::test_total_consume</h3>
<details><summary> <pre>test_recipes.py::ConsumeTests::test_total_consume</pre></summary><pre>
self = <tests.test_recipes.ConsumeTests testMethod=test_total_consume>

    def test_total_consume(self):
        """Check that iterator is totally consumed by default"""
        r = (x for x in range(10))
        mi.consume(r)
>       self.assertRaises(StopIteration, lambda: next(r))
E       AssertionError: StopIteration not raised by <lambda>

tests/test_recipes.py:114: AssertionError
</pre>
</details>
<h3 id="test_recipespynthteststest_basic">test_recipes.py::NthTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::NthTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.NthTests testMethod=test_basic>

    def test_basic(self):
        """Make sure the nth item is returned"""
        l = range(10)
        for i, v in enumerate(l):
>           self.assertEqual(mi.nth(l, i), v)
E           AssertionError: None != 0

tests/test_recipes.py:124: AssertionError
</pre>
</details>
<h3 id="test_recipespynthteststest_default">test_recipes.py::NthTests::test_default</h3>
<details><summary> <pre>test_recipes.py::NthTests::test_default</pre></summary><pre>
self = <tests.test_recipes.NthTests testMethod=test_default>

    def test_default(self):
        """Ensure a default value is returned when nth item not found"""
        l = range(3)
>       self.assertEqual(mi.nth(l, 100, "zebra"), "zebra")
E       AssertionError: None != 'zebra'

tests/test_recipes.py:129: AssertionError
</pre>
</details>
<h3 id="test_recipespynthteststest_negative_item_raises">test_recipes.py::NthTests::test_negative_item_raises</h3>
<details><summary> <pre>test_recipes.py::NthTests::test_negative_item_raises</pre></summary><pre>
self = <tests.test_recipes.NthTests testMethod=test_negative_item_raises>

    def test_negative_item_raises(self):
        """Ensure asking for a negative item raises an exception"""
>       self.assertRaises(ValueError, lambda: mi.nth(range(10), -3))
E       AssertionError: ValueError not raised by <lambda>

tests/test_recipes.py:133: AssertionError
</pre>
</details>
<h3 id="test_recipespyallequalteststest_empty">test_recipes.py::AllEqualTests::test_empty</h3>
<details><summary> <pre>test_recipes.py::AllEqualTests::test_empty</pre></summary><pre>
self = <tests.test_recipes.AllEqualTests testMethod=test_empty>

    def test_empty(self):
>       self.assertTrue(mi.all_equal(''))
E       AssertionError: None is not true

tests/test_recipes.py:150: AssertionError
</pre>
</details>
<h3 id="test_recipespyallequalteststest_key">test_recipes.py::AllEqualTests::test_key</h3>
<details><summary> <pre>test_recipes.py::AllEqualTests::test_key</pre></summary><pre>
self = <tests.test_recipes.AllEqualTests testMethod=test_key>

    def test_key(self):
>       self.assertTrue(mi.all_equal('4٤໔４৪', key=int))
E       AssertionError: None is not true

tests/test_recipes.py:158: AssertionError
</pre>
</details>
<h3 id="test_recipespyallequalteststest_one">test_recipes.py::AllEqualTests::test_one</h3>
<details><summary> <pre>test_recipes.py::AllEqualTests::test_one</pre></summary><pre>
self = <tests.test_recipes.AllEqualTests testMethod=test_one>

    def test_one(self):
>       self.assertTrue(mi.all_equal('0'))
E       AssertionError: None is not true

tests/test_recipes.py:154: AssertionError
</pre>
</details>
<h3 id="test_recipespyallequalteststest_tricky">test_recipes.py::AllEqualTests::test_tricky</h3>
<details><summary> <pre>test_recipes.py::AllEqualTests::test_tricky</pre></summary><pre>
self = <tests.test_recipes.AllEqualTests testMethod=test_tricky>

    def test_tricky(self):
        items = [1, complex(1, 0), 1.0]
>       self.assertTrue(mi.all_equal(items))
E       AssertionError: None is not true

tests/test_recipes.py:147: AssertionError
</pre>
</details>
<h3 id="test_recipespyallequalteststest_true">test_recipes.py::AllEqualTests::test_true</h3>
<details><summary> <pre>test_recipes.py::AllEqualTests::test_true</pre></summary><pre>
self = <tests.test_recipes.AllEqualTests testMethod=test_true>

    def test_true(self):
>       self.assertTrue(mi.all_equal('aaaaaa'))
E       AssertionError: None is not true

tests/test_recipes.py:138: AssertionError
</pre>
</details>
<h3 id="test_recipespyquantifyteststest_custom_predicate">test_recipes.py::QuantifyTests::test_custom_predicate</h3>
<details><summary> <pre>test_recipes.py::QuantifyTests::test_custom_predicate</pre></summary><pre>
self = <tests.test_recipes.QuantifyTests testMethod=test_custom_predicate>

    def test_custom_predicate(self):
        """Ensure non-default predicates return as expected"""
        q = range(10)
>       self.assertEqual(mi.quantify(q, lambda x: x % 2 == 0), 5)
E       AssertionError: None != 5

tests/test_recipes.py:173: AssertionError
</pre>
</details>
<h3 id="test_recipespyquantifyteststest_happy_path">test_recipes.py::QuantifyTests::test_happy_path</h3>
<details><summary> <pre>test_recipes.py::QuantifyTests::test_happy_path</pre></summary><pre>
self = <tests.test_recipes.QuantifyTests testMethod=test_happy_path>

    def test_happy_path(self):
        """Make sure True count is returned"""
        q = [True, False, True]
>       self.assertEqual(mi.quantify(q), 2)
E       AssertionError: None != 2

tests/test_recipes.py:168: AssertionError
</pre>
</details>
<h3 id="test_recipespypadnoneteststest_basic">test_recipes.py::PadnoneTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::PadnoneTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.PadnoneTests testMethod=test_basic>

    def test_basic(self):
        iterable = range(2)
        for func in (mi.pad_none, mi.padnone):
            with self.subTest(func=func):
                p = func(iterable)
                self.assertEqual(
>                   [0, 1, None, None], [next(p) for _ in range(4)]
                )
E               TypeError: 'NoneType' object is not an iterator

tests/test_recipes.py:183: TypeError
</pre>
</details>
<h3 id="test_recipespyncyclesteststest_happy_path">test_recipes.py::NcyclesTests::test_happy_path</h3>
<details><summary> <pre>test_recipes.py::NcyclesTests::test_happy_path</pre></summary><pre>
self = <tests.test_recipes.NcyclesTests testMethod=test_happy_path>

    def test_happy_path(self):
        """cycle a sequence three times"""
        r = ["a", "b", "c"]
        n = mi.ncycles(r, 3)
        self.assertEqual(
>           ["a", "b", "c", "a", "b", "c", "a", "b", "c"], list(n)
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:195: TypeError
</pre>
</details>
<h3 id="test_recipespyncyclesteststest_null_case">test_recipes.py::NcyclesTests::test_null_case</h3>
<details><summary> <pre>test_recipes.py::NcyclesTests::test_null_case</pre></summary><pre>
self = <tests.test_recipes.NcyclesTests testMethod=test_null_case>

    def test_null_case(self):
        """asking for 0 cycles should return an empty iterator"""
        n = mi.ncycles(range(100), 0)
>       self.assertRaises(StopIteration, lambda: next(n))

tests/test_recipes.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   self.assertRaises(StopIteration, lambda: next(n))
E   TypeError: 'NoneType' object is not an iterator

tests/test_recipes.py:201: TypeError
</pre>
</details>
<h3 id="test_recipespyncyclesteststest_pathological_case">test_recipes.py::NcyclesTests::test_pathological_case</h3>
<details><summary> <pre>test_recipes.py::NcyclesTests::test_pathological_case</pre></summary><pre>
self = <tests.test_recipes.NcyclesTests testMethod=test_pathological_case>

    def test_pathological_case(self):
        """asking for negative cycles should return an empty iterator"""
        n = mi.ncycles(range(100), -10)
>       self.assertRaises(StopIteration, lambda: next(n))

tests/test_recipes.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   self.assertRaises(StopIteration, lambda: next(n))
E   TypeError: 'NoneType' object is not an iterator

tests/test_recipes.py:206: TypeError
</pre>
</details>
<h3 id="test_recipespydotproductteststest_happy_path">test_recipes.py::DotproductTests::test_happy_path</h3>
<details><summary> <pre>test_recipes.py::DotproductTests::test_happy_path</pre></summary><pre>
self = <tests.test_recipes.DotproductTests testMethod=test_happy_path>

    def test_happy_path(self):
        """simple dotproduct example"""
>       self.assertEqual(400, mi.dotproduct([10, 10], [20, 20]))
E       AssertionError: 400 != None

tests/test_recipes.py:214: AssertionError
</pre>
</details>
<h3 id="test_recipespyflattenteststest_basic_usage">test_recipes.py::FlattenTests::test_basic_usage</h3>
<details><summary> <pre>test_recipes.py::FlattenTests::test_basic_usage</pre></summary><pre>
self = <tests.test_recipes.FlattenTests testMethod=test_basic_usage>

    def test_basic_usage(self):
        """ensure list of lists is flattened one level"""
        f = [[0, 1, 2], [3, 4, 5]]
>       self.assertEqual(list(range(6)), list(mi.flatten(f)))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:223: TypeError
</pre>
</details>
<h3 id="test_recipespyflattenteststest_single_level">test_recipes.py::FlattenTests::test_single_level</h3>
<details><summary> <pre>test_recipes.py::FlattenTests::test_single_level</pre></summary><pre>
self = <tests.test_recipes.FlattenTests testMethod=test_single_level>

    def test_single_level(self):
        """ensure list of lists is flattened only one level"""
        f = [[0, [1, 2]], [[3, 4], 5]]
>       self.assertEqual([0, [1, 2], [3, 4], 5], list(mi.flatten(f)))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:228: TypeError
</pre>
</details>
<h3 id="test_recipespyrepeatfuncteststest_added_arguments">test_recipes.py::RepeatfuncTests::test_added_arguments</h3>
<details><summary> <pre>test_recipes.py::RepeatfuncTests::test_added_arguments</pre></summary><pre>
self = <tests.test_recipes.RepeatfuncTests testMethod=test_added_arguments>

    def test_added_arguments(self):
        """ensure arguments are applied to the function"""
        r = mi.repeatfunc(lambda x: x, 2, 3)
>       self.assertEqual([3, 3], list(r))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:247: TypeError
</pre>
</details>
<h3 id="test_recipespyrepeatfuncteststest_finite_repeat">test_recipes.py::RepeatfuncTests::test_finite_repeat</h3>
<details><summary> <pre>test_recipes.py::RepeatfuncTests::test_finite_repeat</pre></summary><pre>
self = <tests.test_recipes.RepeatfuncTests testMethod=test_finite_repeat>

    def test_finite_repeat(self):
        """ensure limited repeat when times is provided"""
        r = mi.repeatfunc(lambda: 5, times=5)
>       self.assertEqual([5, 5, 5, 5, 5], list(r))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:242: TypeError
</pre>
</details>
<h3 id="test_recipespyrepeatfuncteststest_null_times">test_recipes.py::RepeatfuncTests::test_null_times</h3>
<details><summary> <pre>test_recipes.py::RepeatfuncTests::test_null_times</pre></summary><pre>
self = <tests.test_recipes.RepeatfuncTests testMethod=test_null_times>

    def test_null_times(self):
        """repeat 0 should return an empty iterator"""
        r = mi.repeatfunc(range, 0, 3)
>       self.assertRaises(StopIteration, lambda: next(r))

tests/test_recipes.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   self.assertRaises(StopIteration, lambda: next(r))
E   TypeError: 'NoneType' object is not an iterator

tests/test_recipes.py:252: TypeError
</pre>
</details>
<h3 id="test_recipespyrepeatfuncteststest_simple_repeat">test_recipes.py::RepeatfuncTests::test_simple_repeat</h3>
<details><summary> <pre>test_recipes.py::RepeatfuncTests::test_simple_repeat</pre></summary><pre>
self = <tests.test_recipes.RepeatfuncTests testMethod=test_simple_repeat>

    def test_simple_repeat(self):
        """test simple repeated functions"""
        r = mi.repeatfunc(lambda: 5)
>       self.assertEqual([5, 5, 5, 5, 5], [next(r) for _ in range(5)])
E       TypeError: 'NoneType' object is not an iterator

tests/test_recipes.py:237: TypeError
</pre>
</details>
<h3 id="test_recipespygrouperteststest_basic">test_recipes.py::GrouperTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::GrouperTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.GrouperTests testMethod=test_basic>

    def test_basic(self):
        seq = 'ABCDEF'
        for n, expected in [
            (3, [('A', 'B', 'C'), ('D', 'E', 'F')]),
            (4, [('A', 'B', 'C', 'D'), ('E', 'F', None, None)]),
            (5, [('A', 'B', 'C', 'D', 'E'), ('F', None, None, None, None)]),
            (6, [('A', 'B', 'C', 'D', 'E', 'F')]),
            (7, [('A', 'B', 'C', 'D', 'E', 'F', None)]),
        ]:
            with self.subTest(n=n):
>               actual = list(mi.grouper(iter(seq), n))
E               TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:286: TypeError
</pre>
</details>
<h3 id="test_recipespygrouperteststest_fill">test_recipes.py::GrouperTests::test_fill</h3>
<details><summary> <pre>test_recipes.py::GrouperTests::test_fill</pre></summary><pre>
self = <tests.test_recipes.GrouperTests testMethod=test_fill>

    def test_fill(self):
        seq = 'ABCDEF'
        fillvalue = 'x'
        for n, expected in [
            (1, ['A', 'B', 'C', 'D', 'E', 'F']),
            (2, ['AB', 'CD', 'EF']),
            (3, ['ABC', 'DEF']),
            (4, ['ABCD', 'EFxx']),
            (5, ['ABCDE', 'Fxxxx']),
            (6, ['ABCDEF']),
            (7, ['ABCDEFx']),
        ]:
            with self.subTest(n=n):
                it = mi.grouper(
                    iter(seq), n, incomplete='fill', fillvalue=fillvalue
                )
>               actual = [''.join(x) for x in it]
E               TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:305: TypeError
</pre>
</details>
<h3 id="test_recipespygrouperteststest_ignore">test_recipes.py::GrouperTests::test_ignore</h3>
<details><summary> <pre>test_recipes.py::GrouperTests::test_ignore</pre></summary><pre>
self = <tests.test_recipes.GrouperTests testMethod=test_ignore>

    def test_ignore(self):
        seq = 'ABCDEF'
        for n, expected in [
            (1, ['A', 'B', 'C', 'D', 'E', 'F']),
            (2, ['AB', 'CD', 'EF']),
            (3, ['ABC', 'DEF']),
            (4, ['ABCD']),
            (5, ['ABCDE']),
            (6, ['ABCDEF']),
            (7, []),
        ]:
            with self.subTest(n=n):
                it = mi.grouper(iter(seq), n, incomplete='ignore')
>               actual = [''.join(x) for x in it]
E               TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:321: TypeError
</pre>
</details>
<h3 id="test_recipespygrouperteststest_invalid_incomplete">test_recipes.py::GrouperTests::test_invalid_incomplete</h3>
<details><summary> <pre>test_recipes.py::GrouperTests::test_invalid_incomplete</pre></summary><pre>
self = <tests.test_recipes.GrouperTests testMethod=test_invalid_incomplete>

    def test_invalid_incomplete(self):
        with self.assertRaises(ValueError):
>           list(mi.grouper('ABCD', 3, incomplete='bogus'))
E           TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:346: TypeError
</pre>
</details>
<h3 id="test_recipespygrouperteststest_strict">test_recipes.py::GrouperTests::test_strict</h3>
<details><summary> <pre>test_recipes.py::GrouperTests::test_strict</pre></summary><pre>
self = <tests.test_recipes.GrouperTests testMethod=test_strict>

    def test_strict(self):
        seq = 'ABCDEF'
        for n, expected in [
            (1, ['A', 'B', 'C', 'D', 'E', 'F']),
            (2, ['AB', 'CD', 'EF']),
            (3, ['ABC', 'DEF']),
            (6, ['ABCDEF']),
        ]:
            with self.subTest(n=n):
                it = mi.grouper(iter(seq), n, incomplete='strict')
>               actual = [''.join(x) for x in it]
E               TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:334: TypeError
</pre>
</details>
<h3 id="test_recipespygrouperteststest_strict_fails">test_recipes.py::GrouperTests::test_strict_fails</h3>
<details><summary> <pre>test_recipes.py::GrouperTests::test_strict_fails</pre></summary><pre>
self = <tests.test_recipes.GrouperTests testMethod=test_strict_fails>

    def test_strict_fails(self):
        seq = 'ABCDEF'
        for n in [4, 5, 7]:
            with self.subTest(n=n):
                with self.assertRaises(ValueError):
>                   list(mi.grouper(iter(seq), n, incomplete='strict'))
E                   TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:342: TypeError
</pre>
</details>
<h3 id="test_recipespyroundrobinteststest_even_groups">test_recipes.py::RoundrobinTests::test_even_groups</h3>
<details><summary> <pre>test_recipes.py::RoundrobinTests::test_even_groups</pre></summary><pre>
self = <tests.test_recipes.RoundrobinTests testMethod=test_even_groups>

    def test_even_groups(self):
        """Ensure ordered output from evenly populated iterables"""
        self.assertEqual(
>           list(mi.roundrobin('ABC', [1, 2, 3], range(3))),
            ['A', 1, 0, 'B', 2, 1, 'C', 3, 2],
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:355: TypeError
</pre>
</details>
<h3 id="test_recipespyroundrobinteststest_uneven_groups">test_recipes.py::RoundrobinTests::test_uneven_groups</h3>
<details><summary> <pre>test_recipes.py::RoundrobinTests::test_uneven_groups</pre></summary><pre>
self = <tests.test_recipes.RoundrobinTests testMethod=test_uneven_groups>

    def test_uneven_groups(self):
        """Ensure ordered output from unevenly populated iterables"""
        self.assertEqual(
>           list(mi.roundrobin('ABCD', [1, 2], range(0))),
            ['A', 1, 'B', 2, 'C', 'D'],
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:362: TypeError
</pre>
</details>
<h3 id="test_recipespypartitionteststest_arbitrary">test_recipes.py::PartitionTests::test_arbitrary</h3>
<details><summary> <pre>test_recipes.py::PartitionTests::test_arbitrary</pre></summary><pre>
self = <tests.test_recipes.PartitionTests testMethod=test_arbitrary>

    def test_arbitrary(self):
>       divisibles, remainders = mi.partition(lambda x: x % 3, range(10))
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_recipes.py:376: TypeError
</pre>
</details>
<h3 id="test_recipespypartitionteststest_bool">test_recipes.py::PartitionTests::test_bool</h3>
<details><summary> <pre>test_recipes.py::PartitionTests::test_bool</pre></summary><pre>
self = <tests.test_recipes.PartitionTests testMethod=test_bool>

    def test_bool(self):
>       lesser, greater = mi.partition(lambda x: x > 5, range(10))
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_recipes.py:371: TypeError
</pre>
</details>
<h3 id="test_recipespypartitionteststest_pred_is_none">test_recipes.py::PartitionTests::test_pred_is_none</h3>
<details><summary> <pre>test_recipes.py::PartitionTests::test_pred_is_none</pre></summary><pre>
self = <tests.test_recipes.PartitionTests testMethod=test_pred_is_none>

    def test_pred_is_none(self):
>       falses, trues = mi.partition(None, range(3))
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_recipes.py:381: TypeError
</pre>
</details>
<h3 id="test_recipespypowersetteststest_combinatorics">test_recipes.py::PowersetTests::test_combinatorics</h3>
<details><summary> <pre>test_recipes.py::PowersetTests::test_combinatorics</pre></summary><pre>
self = <tests.test_recipes.PowersetTests testMethod=test_combinatorics>

    def test_combinatorics(self):
        """Ensure a proper enumeration"""
        p = mi.powerset([1, 2, 3])
        self.assertEqual(
>           list(p), [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:393: TypeError
</pre>
</details>
<h3 id="test_recipespyuniqueeverseenteststest_custom_key">test_recipes.py::UniqueEverseenTests::test_custom_key</h3>
<details><summary> <pre>test_recipes.py::UniqueEverseenTests::test_custom_key</pre></summary><pre>
self = <tests.test_recipes.UniqueEverseenTests testMethod=test_custom_key>

    def test_custom_key(self):
        u = mi.unique_everseen('aAbACCc', key=str.lower)
>       self.assertEqual(list('abC'), list(u))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:404: TypeError
</pre>
</details>
<h3 id="test_recipespyuniqueeverseenteststest_everseen">test_recipes.py::UniqueEverseenTests::test_everseen</h3>
<details><summary> <pre>test_recipes.py::UniqueEverseenTests::test_everseen</pre></summary><pre>
self = <tests.test_recipes.UniqueEverseenTests testMethod=test_everseen>

    def test_everseen(self):
        u = mi.unique_everseen('AAAABBBBCCDAABBB')
>       self.assertEqual(['A', 'B', 'C', 'D'], list(u))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:400: TypeError
</pre>
</details>
<h3 id="test_recipespyuniqueeverseenteststest_unhashable">test_recipes.py::UniqueEverseenTests::test_unhashable</h3>
<details><summary> <pre>test_recipes.py::UniqueEverseenTests::test_unhashable</pre></summary><pre>
self = <tests.test_recipes.UniqueEverseenTests testMethod=test_unhashable>

    def test_unhashable(self):
        iterable = ['a', [1, 2, 3], [1, 2, 3], 'a']
        u = mi.unique_everseen(iterable)
>       self.assertEqual(list(u), ['a', [1, 2, 3]])
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:409: TypeError
</pre>
</details>
<h3 id="test_recipespyuniqueeverseenteststest_unhashable_key">test_recipes.py::UniqueEverseenTests::test_unhashable_key</h3>
<details><summary> <pre>test_recipes.py::UniqueEverseenTests::test_unhashable_key</pre></summary><pre>
self = <tests.test_recipes.UniqueEverseenTests testMethod=test_unhashable_key>

    def test_unhashable_key(self):
        iterable = ['a', [1, 2, 3], [1, 2, 3], 'a']
        u = mi.unique_everseen(iterable, key=lambda x: x)
>       self.assertEqual(list(u), ['a', [1, 2, 3]])
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:414: TypeError
</pre>
</details>
<h3 id="test_recipespyuniquejustseenteststest_custom_key">test_recipes.py::UniqueJustseenTests::test_custom_key</h3>
<details><summary> <pre>test_recipes.py::UniqueJustseenTests::test_custom_key</pre></summary><pre>
self = <tests.test_recipes.UniqueJustseenTests testMethod=test_custom_key>

    def test_custom_key(self):
        u = mi.unique_justseen('AABCcAD', str.lower)
>       self.assertEqual(list('ABCAD'), list(u))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:424: TypeError
</pre>
</details>
<h3 id="test_recipespyuniquejustseenteststest_justseen">test_recipes.py::UniqueJustseenTests::test_justseen</h3>
<details><summary> <pre>test_recipes.py::UniqueJustseenTests::test_justseen</pre></summary><pre>
self = <tests.test_recipes.UniqueJustseenTests testMethod=test_justseen>

    def test_justseen(self):
        u = mi.unique_justseen('AAAABBBCCDABB')
>       self.assertEqual(list('ABCDAB'), list(u))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:420: TypeError
</pre>
</details>
<h3 id="test_recipespyuniqueteststest_basic">test_recipes.py::UniqueTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::UniqueTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.UniqueTests testMethod=test_basic>

    def test_basic(self):
        iterable = [0, 1, 1, 8, 9, 9, 9, 8, 8, 1, 9, 9]
>       actual = list(mi.unique(iterable))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:430: TypeError
</pre>
</details>
<h3 id="test_recipespyuniqueteststest_key">test_recipes.py::UniqueTests::test_key</h3>
<details><summary> <pre>test_recipes.py::UniqueTests::test_key</pre></summary><pre>
self = <tests.test_recipes.UniqueTests testMethod=test_key>

    def test_key(self):
        iterable = ['1', '1', '10', '10', '2', '2', '20', '20']
>       actual = list(mi.unique(iterable, key=int))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:436: TypeError
</pre>
</details>
<h3 id="test_recipespyuniqueteststest_reverse">test_recipes.py::UniqueTests::test_reverse</h3>
<details><summary> <pre>test_recipes.py::UniqueTests::test_reverse</pre></summary><pre>
self = <tests.test_recipes.UniqueTests testMethod=test_reverse>

    def test_reverse(self):
        iterable = ['1', '1', '10', '10', '2', '2', '20', '20']
>       actual = list(mi.unique(iterable, key=int, reverse=True))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:442: TypeError
</pre>
</details>
<h3 id="test_recipespyiterexceptteststest_exact_exception">test_recipes.py::IterExceptTests::test_exact_exception</h3>
<details><summary> <pre>test_recipes.py::IterExceptTests::test_exact_exception</pre></summary><pre>
self = <tests.test_recipes.IterExceptTests testMethod=test_exact_exception>

    def test_exact_exception(self):
        """ensure the exact specified exception is caught"""
        l = [1, 2, 3]
        i = mi.iter_except(l.pop, IndexError)
>       self.assertEqual(list(i), [3, 2, 1])
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:454: TypeError
</pre>
</details>
<h3 id="test_recipespyiterexceptteststest_first">test_recipes.py::IterExceptTests::test_first</h3>
<details><summary> <pre>test_recipes.py::IterExceptTests::test_first</pre></summary><pre>
self = <tests.test_recipes.IterExceptTests testMethod=test_first>

    def test_first(self):
        """ensure first is run before the function"""
        l = [1, 2, 3]
        f = lambda: 25
        i = mi.iter_except(l.pop, IndexError, f)
>       self.assertEqual(list(i), [25, 3, 2, 1])
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:473: TypeError
</pre>
</details>
<h3 id="test_recipespyiterexceptteststest_generic_exception">test_recipes.py::IterExceptTests::test_generic_exception</h3>
<details><summary> <pre>test_recipes.py::IterExceptTests::test_generic_exception</pre></summary><pre>
self = <tests.test_recipes.IterExceptTests testMethod=test_generic_exception>

    def test_generic_exception(self):
        """ensure the generic exception can be caught"""
        l = [1, 2]
        i = mi.iter_except(l.pop, Exception)
>       self.assertEqual(list(i), [2, 1])
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:460: TypeError
</pre>
</details>
<h3 id="test_recipespyiterexceptteststest_multiple">test_recipes.py::IterExceptTests::test_multiple</h3>
<details><summary> <pre>test_recipes.py::IterExceptTests::test_multiple</pre></summary><pre>
self = <tests.test_recipes.IterExceptTests testMethod=test_multiple>

    def test_multiple(self):
        """ensure can catch multiple exceptions"""

        class Fiz(Exception):
            pass

        class Buzz(Exception):
            pass

        i = 0

        def fizbuzz():
            nonlocal i
            i += 1
            if i % 3 == 0:
                raise Fiz
            if i % 5 == 0:
                raise Buzz
            return i

        expected = ([1, 2], [4], [], [7, 8], [])
        for x in expected:
>           self.assertEqual(list(mi.iter_except(fizbuzz, (Fiz, Buzz))), x)
E           TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:497: TypeError
</pre>
</details>
<h3 id="test_recipespyiterexceptteststest_uncaught_exception_is_raised">test_recipes.py::IterExceptTests::test_uncaught_exception_is_raised</h3>
<details><summary> <pre>test_recipes.py::IterExceptTests::test_uncaught_exception_is_raised</pre></summary><pre>
self = <tests.test_recipes.IterExceptTests testMethod=test_uncaught_exception_is_raised>

    def test_uncaught_exception_is_raised(self):
        """ensure a non-specified exception is raised"""
        l = [1, 2, 3]
        i = mi.iter_except(l.pop, KeyError)
>       self.assertRaises(IndexError, lambda: list(i))

tests/test_recipes.py:466: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   self.assertRaises(IndexError, lambda: list(i))
E   TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:466: TypeError
</pre>
</details>
<h3 id="test_recipespyfirsttrueteststest_default">test_recipes.py::FirstTrueTests::test_default</h3>
<details><summary> <pre>test_recipes.py::FirstTrueTests::test_default</pre></summary><pre>
self = <tests.test_recipes.FirstTrueTests testMethod=test_default>

    def test_default(self):
        """Test with a default keyword"""
>       self.assertEqual(mi.first_true([0, 0, 0], default='!'), '!')
E       AssertionError: None != '!'

tests/test_recipes.py:513: AssertionError
</pre>
</details>
<h3 id="test_recipespyfirsttrueteststest_pred">test_recipes.py::FirstTrueTests::test_pred</h3>
<details><summary> <pre>test_recipes.py::FirstTrueTests::test_pred</pre></summary><pre>
self = <tests.test_recipes.FirstTrueTests testMethod=test_pred>

    def test_pred(self):
        """Test with a custom predicate"""
>       self.assertEqual(
            mi.first_true([2, 4, 6], pred=lambda x: x % 3 == 0), 6
        )
E       AssertionError: None != 6

tests/test_recipes.py:517: AssertionError
</pre>
</details>
<h3 id="test_recipespyfirsttrueteststest_something_true">test_recipes.py::FirstTrueTests::test_something_true</h3>
<details><summary> <pre>test_recipes.py::FirstTrueTests::test_something_true</pre></summary><pre>
self = <tests.test_recipes.FirstTrueTests testMethod=test_something_true>

    def test_something_true(self):
        """Test with no keywords"""
>       self.assertEqual(mi.first_true(range(10)), 1)
E       AssertionError: None != 1

tests/test_recipes.py:505: AssertionError
</pre>
</details>
<h3 id="test_recipespyrandomproductteststest_list_with_repeat">test_recipes.py::RandomProductTests::test_list_with_repeat</h3>
<details><summary> <pre>test_recipes.py::RandomProductTests::test_list_with_repeat</pre></summary><pre>
self = <tests.test_recipes.RandomProductTests testMethod=test_list_with_repeat>

    def test_list_with_repeat(self):
        """ensure multiple items are chosen, and that they appear to be chosen
        from one list then the next, in proper order.

        """
        nums = [1, 2, 3]
        lets = ['a', 'b', 'c']
>       r = list(mi.random_product(nums, lets, repeat=100))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:556: TypeError
</pre>
</details>
<h3 id="test_recipespyrandomproductteststest_simple_lists">test_recipes.py::RandomProductTests::test_simple_lists</h3>
<details><summary> <pre>test_recipes.py::RandomProductTests::test_simple_lists</pre></summary><pre>
self = <tests.test_recipes.RandomProductTests testMethod=test_simple_lists>

    def test_simple_lists(self):
        """Ensure that one item is chosen from each list in each pair.
        Also ensure that each item from each list eventually appears in
        the chosen combinations.

        Odds are roughly 1 in 7.1 * 10e16 that one item from either list will
        not be chosen after 100 samplings of one item from each list. Just to
        be safe, better use a known random seed, too.

        """
        nums = [1, 2, 3]
        lets = ['a', 'b', 'c']
>       n, m = zip(*[mi.random_product(nums, lets) for _ in range(100)])
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:542: TypeError
</pre>
</details>
<h3 id="test_recipespyrandompermutationteststest_full_permutation">test_recipes.py::RandomPermutationTests::test_full_permutation</h3>
<details><summary> <pre>test_recipes.py::RandomPermutationTests::test_full_permutation</pre></summary><pre>
self = <tests.test_recipes.RandomPermutationTests testMethod=test_full_permutation>

    def test_full_permutation(self):
        """ensure every item from the iterable is returned in a new ordering

        15 elements have a 1 in 1.3 * 10e12 of appearing in sorted order, so
        we fix a seed value just to be sure.

        """
        i = range(15)
        r = mi.random_permutation(i)
>       self.assertEqual(set(i), set(r))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:577: TypeError
</pre>
</details>
<h3 id="test_recipespyrandompermutationteststest_partial_permutation">test_recipes.py::RandomPermutationTests::test_partial_permutation</h3>
<details><summary> <pre>test_recipes.py::RandomPermutationTests::test_partial_permutation</pre></summary><pre>
self = <tests.test_recipes.RandomPermutationTests testMethod=test_partial_permutation>

    def test_partial_permutation(self):
        """ensure all returned items are from the iterable, that the returned
        permutation is of the desired length, and that all items eventually
        get returned.

        Sampling 100 permutations of length 5 from a set of 15 leaves a
        (2/3)^100 chance that an item will not be chosen. Multiplied by 15
        items, there is a 1 in 2.6e16 chance that at least 1 item will not
        show up in the resulting output. Using a random seed will fix that.

        """
        items = range(15)
        item_set = set(items)
        all_items = set()
        for _ in range(100):
            permutation = mi.random_permutation(items, 5)
>           self.assertEqual(len(permutation), 5)
E           TypeError: object of type 'NoneType' has no len()

tests/test_recipes.py:597: TypeError
</pre>
</details>
<h3 id="test_recipespyrandomcombinationteststest_no_replacement">test_recipes.py::RandomCombinationTests::test_no_replacement</h3>
<details><summary> <pre>test_recipes.py::RandomCombinationTests::test_no_replacement</pre></summary><pre>
self = <tests.test_recipes.RandomCombinationTests testMethod=test_no_replacement>

    def test_no_replacement(self):
        """ensure that elements are sampled without replacement"""
        items = range(15)
        for _ in range(50):
            combination = mi.random_combination(items, len(items))
>           self.assertEqual(len(combination), len(set(combination)))
E           TypeError: object of type 'NoneType' has no len()

tests/test_recipes.py:622: TypeError
</pre>
</details>
<h3 id="test_recipespyrandomcombinationteststest_pseudorandomness">test_recipes.py::RandomCombinationTests::test_pseudorandomness</h3>
<details><summary> <pre>test_recipes.py::RandomCombinationTests::test_pseudorandomness</pre></summary><pre>
self = <tests.test_recipes.RandomCombinationTests testMethod=test_pseudorandomness>

    def test_pseudorandomness(self):
        """ensure different subsets of the iterable get returned over many
        samplings of random combinations"""
        items = range(15)
        all_items = set()
        for _ in range(50):
            combination = mi.random_combination(items, 5)
>           all_items |= set(combination)
E           TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:614: TypeError
</pre>
</details>
<h3 id="test_recipespyrandomcombinationwithreplacementteststest_pseudorandomness">test_recipes.py::RandomCombinationWithReplacementTests::test_pseudorandomness</h3>
<details><summary> <pre>test_recipes.py::RandomCombinationWithReplacementTests::test_pseudorandomness</pre></summary><pre>
self = <tests.test_recipes.RandomCombinationWithReplacementTests testMethod=test_pseudorandomness>

    def test_pseudorandomness(self):
        """ensure different subsets of the iterable get returned over many
        samplings of random combinations"""
        items = range(15)
        all_items = set()
        for _ in range(50):
            combination = mi.random_combination_with_replacement(items, 5)
>           all_items |= set(combination)
E           TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:646: TypeError
</pre>
</details>
<h3 id="test_recipespyrandomcombinationwithreplacementteststest_replacement">test_recipes.py::RandomCombinationWithReplacementTests::test_replacement</h3>
<details><summary> <pre>test_recipes.py::RandomCombinationWithReplacementTests::test_replacement</pre></summary><pre>
self = <tests.test_recipes.RandomCombinationWithReplacementTests testMethod=test_replacement>

    def test_replacement(self):
        """ensure that elements are sampled with replacement"""
        items = range(5)
        combo = mi.random_combination_with_replacement(items, len(items) * 2)
>       self.assertEqual(2 * len(items), len(combo))
E       TypeError: object of type 'NoneType' has no len()

tests/test_recipes.py:635: TypeError
</pre>
</details>
<h3 id="test_recipespynthcombinationteststest_basic">test_recipes.py::NthCombinationTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::NthCombinationTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.NthCombinationTests testMethod=test_basic>

    def test_basic(self):
        iterable = 'abcdefg'
        r = 4
        for index, expected in enumerate(combinations(iterable, r)):
            actual = mi.nth_combination(iterable, r, index)
>           self.assertEqual(actual, expected)
E           AssertionError: None != ('a', 'b', 'c', 'd')

tests/test_recipes.py:656: AssertionError
</pre>
</details>
<h3 id="test_recipespynthcombinationteststest_invalid_index">test_recipes.py::NthCombinationTests::test_invalid_index</h3>
<details><summary> <pre>test_recipes.py::NthCombinationTests::test_invalid_index</pre></summary><pre>
self = <tests.test_recipes.NthCombinationTests testMethod=test_invalid_index>

    def test_invalid_index(self):
>       with self.assertRaises(IndexError):
E       AssertionError: IndexError not raised

tests/test_recipes.py:669: AssertionError
</pre>
</details>
<h3 id="test_recipespynthcombinationteststest_invalid_r">test_recipes.py::NthCombinationTests::test_invalid_r</h3>
<details><summary> <pre>test_recipes.py::NthCombinationTests::test_invalid_r</pre></summary><pre>
self = <tests.test_recipes.NthCombinationTests testMethod=test_invalid_r>

    def test_invalid_r(self):
        for r in (-1, 3):
>           with self.assertRaises(ValueError):
E           AssertionError: ValueError not raised

tests/test_recipes.py:665: AssertionError
</pre>
</details>
<h3 id="test_recipespynthcombinationteststest_long">test_recipes.py::NthCombinationTests::test_long</h3>
<details><summary> <pre>test_recipes.py::NthCombinationTests::test_long</pre></summary><pre>
self = <tests.test_recipes.NthCombinationTests testMethod=test_long>

    def test_long(self):
        actual = mi.nth_combination(range(180), 4, 2000000)
        expected = (2, 12, 35, 126)
>       self.assertEqual(actual, expected)
E       AssertionError: None != (2, 12, 35, 126)

tests/test_recipes.py:661: AssertionError
</pre>
</details>
<h3 id="test_recipespynthpermutationteststest_invalid_index">test_recipes.py::NthPermutationTests::test_invalid_index</h3>
<details><summary> <pre>test_recipes.py::NthPermutationTests::test_invalid_index</pre></summary><pre>
self = <tests.test_recipes.NthPermutationTests testMethod=test_invalid_index>

    def test_invalid_index(self):
        iterable = 'abcde'
        r = 4
        n = factorial(len(iterable)) // factorial(len(iterable) - r)
        for index in [-1 - n, n + 1]:
>           with self.assertRaises(IndexError):
E           AssertionError: IndexError not raised

tests/test_recipes.py:713: AssertionError
</pre>
</details>
<h3 id="test_recipespynthpermutationteststest_invalid_r">test_recipes.py::NthPermutationTests::test_invalid_r</h3>
<details><summary> <pre>test_recipes.py::NthPermutationTests::test_invalid_r</pre></summary><pre>
self = <tests.test_recipes.NthPermutationTests testMethod=test_invalid_r>

    def test_invalid_r(self):
        iterable = 'abcde'
        r = 4
        n = factorial(len(iterable)) // factorial(len(iterable) - r)
        for r in [-1, n + 1]:
>           with self.assertRaises(ValueError):
E           AssertionError: ValueError not raised

tests/test_recipes.py:721: AssertionError
</pre>
</details>
<h3 id="test_recipespynthpermutationteststest_negative_index">test_recipes.py::NthPermutationTests::test_negative_index</h3>
<details><summary> <pre>test_recipes.py::NthPermutationTests::test_negative_index</pre></summary><pre>
self = <tests.test_recipes.NthPermutationTests testMethod=test_negative_index>

    def test_negative_index(self):
        iterable = 'abcde'
        r = 4
        n = factorial(len(iterable)) // factorial(len(iterable) - r)
        for index, expected in enumerate(permutations(iterable, r)):
            actual = mi.nth_permutation(iterable, r, index - n)
>           self.assertEqual(actual, expected)
E           AssertionError: None != ('a', 'b', 'c', 'd')

tests/test_recipes.py:706: AssertionError
</pre>
</details>
<h3 id="test_recipespynthpermutationteststest_null">test_recipes.py::NthPermutationTests::test_null</h3>
<details><summary> <pre>test_recipes.py::NthPermutationTests::test_null</pre></summary><pre>
self = <tests.test_recipes.NthPermutationTests testMethod=test_null>

    def test_null(self):
        actual = mi.nth_permutation([], 0, 0)
        expected = tuple()
>       self.assertEqual(actual, expected)
E       AssertionError: None != ()

tests/test_recipes.py:698: AssertionError
</pre>
</details>
<h3 id="test_recipespynthpermutationteststest_r_equal_to_n">test_recipes.py::NthPermutationTests::test_r_equal_to_n</h3>
<details><summary> <pre>test_recipes.py::NthPermutationTests::test_r_equal_to_n</pre></summary><pre>
self = <tests.test_recipes.NthPermutationTests testMethod=test_r_equal_to_n>

    def test_r_equal_to_n(self):
        iterable = 'abcde'
        for index, expected in enumerate(permutations(iterable)):
            actual = mi.nth_permutation(iterable, None, index)
>           self.assertEqual(actual, expected)
E           AssertionError: None != ('a', 'b', 'c', 'd', 'e')

tests/test_recipes.py:685: AssertionError
</pre>
</details>
<h3 id="test_recipespynthpermutationteststest_r_less_than_n">test_recipes.py::NthPermutationTests::test_r_less_than_n</h3>
<details><summary> <pre>test_recipes.py::NthPermutationTests::test_r_less_than_n</pre></summary><pre>
self = <tests.test_recipes.NthPermutationTests testMethod=test_r_less_than_n>

    def test_r_less_than_n(self):
        iterable = 'abcde'
        r = 4
        for index, expected in enumerate(permutations(iterable, r)):
            actual = mi.nth_permutation(iterable, r, index)
>           self.assertEqual(actual, expected)
E           AssertionError: None != ('a', 'b', 'c', 'd')

tests/test_recipes.py:679: AssertionError
</pre>
</details>
<h3 id="test_recipespyprependteststest_basic">test_recipes.py::PrependTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::PrependTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.PrependTests testMethod=test_basic>

    def test_basic(self):
        value = 'a'
        iterator = iter('bcdefg')
>       actual = list(mi.prepend(value, iterator))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:729: TypeError
</pre>
</details>
<h3 id="test_recipespyprependteststest_multiple">test_recipes.py::PrependTests::test_multiple</h3>
<details><summary> <pre>test_recipes.py::PrependTests::test_multiple</pre></summary><pre>
self = <tests.test_recipes.PrependTests testMethod=test_multiple>

    def test_multiple(self):
        value = 'ab'
        iterator = iter('cdefg')
>       actual = tuple(mi.prepend(value, iterator))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:736: TypeError
</pre>
</details>
<h3 id="test_recipespyconvolveteststest_derivative">test_recipes.py::Convolvetests::test_derivative</h3>
<details><summary> <pre>test_recipes.py::Convolvetests::test_derivative</pre></summary><pre>
self = <tests.test_recipes.Convolvetests testMethod=test_derivative>

    def test_derivative(self):
        signal = iter([10, 20, 30, 40, 50])
        kernel = [1, -1]
>       actual = list(mi.convolve(signal, kernel))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:759: TypeError
</pre>
</details>
<h3 id="test_recipespyconvolveteststest_infinite_signal">test_recipes.py::Convolvetests::test_infinite_signal</h3>
<details><summary> <pre>test_recipes.py::Convolvetests::test_infinite_signal</pre></summary><pre>
self = <tests.test_recipes.Convolvetests testMethod=test_infinite_signal>

    def test_infinite_signal(self):
        signal = count()
        kernel = [1, -1]
>       actual = mi.take(5, mi.convolve(signal, kernel))

tests/test_recipes.py:766: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

n = 5, iterable = None

    def take(n, iterable):
        """Return first *n* items of the iterable as a list.

            >>> take(3, range(10))
            [0, 1, 2]

        If there are fewer than *n* items in the iterable, all of them are
        returned.

            >>> take(10, range(3))
            [0, 1, 2]

        """
>       return list(islice(iterable, n))
E       TypeError: 'NoneType' object is not iterable

more_itertools/recipes.py:71: TypeError
</pre>
</details>
<h3 id="test_recipespyconvolveteststest_moving_average">test_recipes.py::Convolvetests::test_moving_average</h3>
<details><summary> <pre>test_recipes.py::Convolvetests::test_moving_average</pre></summary><pre>
self = <tests.test_recipes.Convolvetests testMethod=test_moving_average>

    def test_moving_average(self):
        signal = iter([10, 20, 30, 40, 50])
        kernel = [0.5, 0.5]
>       actual = list(mi.convolve(signal, kernel))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:745: TypeError
</pre>
</details>
<h3 id="test_recipespybeforeandafterteststest_empty">test_recipes.py::BeforeAndAfterTests::test_empty</h3>
<details><summary> <pre>test_recipes.py::BeforeAndAfterTests::test_empty</pre></summary><pre>
self = <tests.test_recipes.BeforeAndAfterTests testMethod=test_empty>

    def test_empty(self):
>       before, after = mi.before_and_after(bool, [])
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_recipes.py:773: TypeError
</pre>
</details>
<h3 id="test_recipespybeforeandafterteststest_nested_remainder">test_recipes.py::BeforeAndAfterTests::test_nested_remainder</h3>
<details><summary> <pre>test_recipes.py::BeforeAndAfterTests::test_nested_remainder</pre></summary><pre>
self = <tests.test_recipes.BeforeAndAfterTests testMethod=test_nested_remainder>

    def test_nested_remainder(self):
        events = ["SUM", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] * 1000
        events += ["MULTIPLY", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] * 1000

>       for operation, numbers in self._group_events(events):

tests/test_recipes.py:817: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

events = <list_iterator object at 0x7fdd543acc10>

    @staticmethod
    def _group_events(events):
        events = iter(events)

        while True:
            try:
                operation = next(events)
            except StopIteration:
                break
            assert operation in ["SUM", "MULTIPLY"]

            # Here, the remainder `events` is passed into `before_and_after`
            # again, which would be problematic if the remainder is a
            # generator function (as in Python 3.10 itertools recipes), since
            # that creates recursion. `itertools.chain` solves this problem.
>           numbers, events = mi.before_and_after(
                lambda e: isinstance(e, int), events
            )
E           TypeError: cannot unpack non-iterable NoneType object

tests/test_recipes.py:807: TypeError
</pre>
</details>
<h3 id="test_recipespybeforeandafterteststest_never_false">test_recipes.py::BeforeAndAfterTests::test_never_false</h3>
<details><summary> <pre>test_recipes.py::BeforeAndAfterTests::test_never_false</pre></summary><pre>
self = <tests.test_recipes.BeforeAndAfterTests testMethod=test_never_false>

    def test_never_false(self):
>       before, after = mi.before_and_after(bool, [1, True, Ellipsis, ' '])
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_recipes.py:783: TypeError
</pre>
</details>
<h3 id="test_recipespybeforeandafterteststest_never_true">test_recipes.py::BeforeAndAfterTests::test_never_true</h3>
<details><summary> <pre>test_recipes.py::BeforeAndAfterTests::test_never_true</pre></summary><pre>
self = <tests.test_recipes.BeforeAndAfterTests testMethod=test_never_true>

    def test_never_true(self):
>       before, after = mi.before_and_after(bool, [0, False, None, ''])
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_recipes.py:778: TypeError
</pre>
</details>
<h3 id="test_recipespybeforeandafterteststest_some_true">test_recipes.py::BeforeAndAfterTests::test_some_true</h3>
<details><summary> <pre>test_recipes.py::BeforeAndAfterTests::test_some_true</pre></summary><pre>
self = <tests.test_recipes.BeforeAndAfterTests testMethod=test_some_true>

    def test_some_true(self):
>       before, after = mi.before_and_after(bool, [1, True, 0, False])
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_recipes.py:788: TypeError
</pre>
</details>
<h3 id="test_recipespytriplewiseteststest_basic">test_recipes.py::TriplewiseTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::TriplewiseTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.TriplewiseTests testMethod=test_basic>

    def test_basic(self):
        for iterable, expected in [
            ([0], []),
            ([0, 1], []),
            ([0, 1, 2], [(0, 1, 2)]),
            ([0, 1, 2, 3], [(0, 1, 2), (1, 2, 3)]),
            ([0, 1, 2, 3, 4], [(0, 1, 2), (1, 2, 3), (2, 3, 4)]),
        ]:
            with self.subTest(expected=expected):
>               actual = list(mi.triplewise(iterable))
E               TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:836: TypeError
</pre>
</details>
<h3 id="test_recipespyslidingwindowteststest_deque_version">test_recipes.py::SlidingWindowTests::test_deque_version</h3>
<details><summary> <pre>test_recipes.py::SlidingWindowTests::test_deque_version</pre></summary><pre>
self = <tests.test_recipes.SlidingWindowTests testMethod=test_deque_version>

    def test_deque_version(self):
        iterable = map(str, range(100))
>       all_windows = list(mi.sliding_window(iterable, 95))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:858: TypeError
</pre>
</details>
<h3 id="test_recipespyslidingwindowteststest_islice_version">test_recipes.py::SlidingWindowTests::test_islice_version</h3>
<details><summary> <pre>test_recipes.py::SlidingWindowTests::test_islice_version</pre></summary><pre>
self = <tests.test_recipes.SlidingWindowTests testMethod=test_islice_version>

    def test_islice_version(self):
        for iterable, n, expected in [
            ([], 1, []),
            ([0], 1, [(0,)]),
            ([0, 1], 1, [(0,), (1,)]),
            ([0, 1, 2], 2, [(0, 1), (1, 2)]),
            ([0, 1, 2], 3, [(0, 1, 2)]),
            ([0, 1, 2], 4, []),
            ([0, 1, 2, 3], 4, [(0, 1, 2, 3)]),
            ([0, 1, 2, 3, 4], 4, [(0, 1, 2, 3), (1, 2, 3, 4)]),
        ]:
            with self.subTest(expected=expected):
>               actual = list(mi.sliding_window(iterable, n))
E               TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:853: TypeError
</pre>
</details>
<h3 id="test_recipespyslidingwindowteststest_zero">test_recipes.py::SlidingWindowTests::test_zero</h3>
<details><summary> <pre>test_recipes.py::SlidingWindowTests::test_zero</pre></summary><pre>
self = <tests.test_recipes.SlidingWindowTests testMethod=test_zero>

    def test_zero(self):
        iterable = map(str, range(100))
        with self.assertRaises(ValueError):
>           list(mi.sliding_window(iterable, 0))
E           TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:865: TypeError
</pre>
</details>
<h3 id="test_recipespysubslicesteststest_basic">test_recipes.py::SubslicesTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::SubslicesTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.SubslicesTests testMethod=test_basic>

    def test_basic(self):
        for iterable, expected in [
            ([], []),
            ([1], [[1]]),
            ([1, 2], [[1], [1, 2], [2]]),
            (iter([1, 2]), [[1], [1, 2], [2]]),
            ([2, 1], [[2], [2, 1], [1]]),
            (
                'ABCD',
                [
                    ['A'],
                    ['A', 'B'],
                    ['A', 'B', 'C'],
                    ['A', 'B', 'C', 'D'],
                    ['B'],
                    ['B', 'C'],
                    ['B', 'C', 'D'],
                    ['C'],
                    ['C', 'D'],
                    ['D'],
                ],
            ),
        ]:
            with self.subTest(expected=expected):
>               actual = list(mi.subslices(iterable))
E               TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:893: TypeError
</pre>
</details>
<h3 id="test_recipespypolynomialfromrootsteststest_basic">test_recipes.py::PolynomialFromRootsTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::PolynomialFromRootsTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.PolynomialFromRootsTests testMethod=test_basic>

    def test_basic(self):
        for roots, expected in [
            ((2, 1, -1), [1, -2, -1, 2]),
            ((2, 3), [1, -5, 6]),
            ((1, 2, 3), [1, -6, 11, -6]),
            ((2, 4, 1), [1, -7, 14, -8]),
        ]:
            with self.subTest(roots=roots):
                actual = mi.polynomial_from_roots(roots)
>               self.assertEqual(actual, expected)
E               AssertionError: None != [1, -2, -1, 2]

tests/test_recipes.py:907: AssertionError
</pre>
</details>
<h3 id="test_recipespypolynomialevalteststest_basic">test_recipes.py::PolynomialEvalTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::PolynomialEvalTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.PolynomialEvalTests testMethod=test_basic>

    def test_basic(self):
        for coefficients, x, expected in [
            ([1, -4, -17, 60], 2, 18),
            ([1, -4, -17, 60], 2.5, 8.125),
            ([1, -4, -17, 60], Fraction(2, 3), Fraction(1274, 27)),
            ([1, -4, -17, 60], Decimal('1.75'), Decimal('23.359375')),
            ([], 2, 0),
            ([], 2.5, 0.0),
            ([], Fraction(2, 3), Fraction(0, 1)),
            ([], Decimal('1.75'), Decimal('0.00')),
            ([11], 7, 11),
            ([11, 2], 7, 79),
        ]:
            with self.subTest(x=x):
                actual = mi.polynomial_eval(coefficients, x)
>               self.assertEqual(actual, expected)
E               AssertionError: None != 18

tests/test_recipes.py:926: AssertionError
</pre>
</details>
<h3 id="test_recipespyiterindexteststest_basic">test_recipes.py::IterIndexTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::IterIndexTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.IterIndexTests testMethod=test_basic>

    def test_basic(self):
        iterable = 'AABCADEAF'
        for wrapper in (list, iter):
            with self.subTest(wrapper=wrapper):
>               actual = list(mi.iter_index(wrapper(iterable), 'A'))
E               TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:935: TypeError
</pre>
</details>
<h3 id="test_recipespyiterindexteststest_start">test_recipes.py::IterIndexTests::test_start</h3>
<details><summary> <pre>test_recipes.py::IterIndexTests::test_start</pre></summary><pre>
self = <tests.test_recipes.IterIndexTests testMethod=test_start>

    def test_start(self):
        for wrapper in (list, iter):
            with self.subTest(wrapper=wrapper):
                iterable = 'AABCADEAF'
                i = -1
                actual = []
                while True:
                    try:
>                       i = next(
                            mi.iter_index(wrapper(iterable), 'A', start=i + 1)
                        )
E                       TypeError: 'NoneType' object is not an iterator

tests/test_recipes.py:947: TypeError
</pre>
</details>
<h3 id="test_recipespyiterindexteststest_stop">test_recipes.py::IterIndexTests::test_stop</h3>
<details><summary> <pre>test_recipes.py::IterIndexTests::test_stop</pre></summary><pre>
self = <tests.test_recipes.IterIndexTests testMethod=test_stop>

    def test_stop(self):
>       actual = list(mi.iter_index('AABCADEAF', 'A', stop=7))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:959: TypeError
</pre>
</details>
<h3 id="test_recipespysieveteststest_basic">test_recipes.py::SieveTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::SieveTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.SieveTests testMethod=test_basic>

    def test_basic(self):
        self.assertEqual(
>           list(mi.sieve(67)),
            [
                2,
                3,
                5,
                7,
                11,
                13,
                17,
                19,
                23,
                29,
                31,
                37,
                41,
                43,
                47,
                53,
                59,
                61,
            ],
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:967: TypeError
</pre>
</details>
<h3 id="test_recipespysieveteststest_prime_counts">test_recipes.py::SieveTests::test_prime_counts</h3>
<details><summary> <pre>test_recipes.py::SieveTests::test_prime_counts</pre></summary><pre>
self = <tests.test_recipes.SieveTests testMethod=test_prime_counts>

    def test_prime_counts(self):
        for n, expected in (
            (100, 25),
            (1_000, 168),
            (10_000, 1229),
            (100_000, 9592),
            (1_000_000, 78498),
        ):
            with self.subTest(n=n):
>               self.assertEqual(mi.ilen(mi.sieve(n)), expected)
E               AssertionError: None != 25

tests/test_recipes.py:1000: AssertionError
</pre>
</details>
<h3 id="test_recipespysieveteststest_small_numbers">test_recipes.py::SieveTests::test_small_numbers</h3>
<details><summary> <pre>test_recipes.py::SieveTests::test_small_numbers</pre></summary><pre>
self = <tests.test_recipes.SieveTests testMethod=test_small_numbers>

    def test_small_numbers(self):
        with self.assertRaises(ValueError):
>           list(mi.sieve(-1))
E           TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:1004: TypeError
</pre>
</details>
<h3 id="test_recipespybatchedteststest_basic">test_recipes.py::BatchedTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::BatchedTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.BatchedTests testMethod=test_basic>

    def test_basic(self):
        iterable = range(1, 5 + 1)
        for n, expected in (
            (1, [(1,), (2,), (3,), (4,), (5,)]),
            (2, [(1, 2), (3, 4), (5,)]),
            (3, [(1, 2, 3), (4, 5)]),
            (4, [(1, 2, 3, 4), (5,)]),
            (5, [(1, 2, 3, 4, 5)]),
            (6, [(1, 2, 3, 4, 5)]),
        ):
            with self.subTest(n=n):
>               actual = list(mi.batched(iterable, n))
E               TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:1023: TypeError
</pre>
</details>
<h3 id="test_recipespybatchedteststest_strict">test_recipes.py::BatchedTests::test_strict</h3>
<details><summary> <pre>test_recipes.py::BatchedTests::test_strict</pre></summary><pre>
self = <tests.test_recipes.BatchedTests testMethod=test_strict>

    def test_strict(self):
        with self.assertRaises(ValueError):
>           list(mi.batched('ABCDEFG', 3, strict=True))
E           TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:1028: TypeError
</pre>
</details>
<h3 id="test_recipespytransposeteststest_basic">test_recipes.py::TransposeTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::TransposeTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.TransposeTests testMethod=test_basic>

    def test_basic(self):
        it = [(10, 11, 12), (20, 21, 22), (30, 31, 32)]
>       actual = list(mi.transpose(it))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:1045: TypeError
</pre>
</details>
<h3 id="test_recipespytransposeteststest_empty">test_recipes.py::TransposeTests::test_empty</h3>
<details><summary> <pre>test_recipes.py::TransposeTests::test_empty</pre></summary><pre>
self = <tests.test_recipes.TransposeTests testMethod=test_empty>

    def test_empty(self):
        it = []
>       actual = list(mi.transpose(it))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:1039: TypeError
</pre>
</details>
<h3 id="test_recipespytransposeteststest_incompatible_error">test_recipes.py::TransposeTests::test_incompatible_error</h3>
<details><summary> <pre>test_recipes.py::TransposeTests::test_incompatible_error</pre></summary><pre>
self = <tests.test_recipes.TransposeTests testMethod=test_incompatible_error>

    @skipIf(version_info[:2] < (3, 10), 'strict=True missing on 3.9')
    def test_incompatible_error(self):
        it = [(10, 11, 12, 13), (20, 21, 22), (30, 31, 32)]
        with self.assertRaises(ValueError):
>           list(mi.transpose(it))
E           TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:1053: TypeError
</pre>
</details>
<h3 id="test_recipespyreshapeteststest_basic">test_recipes.py::ReshapeTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::ReshapeTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.ReshapeTests testMethod=test_basic>

    def test_basic(self):
        matrix = [(0, 1, 2, 3), (4, 5, 6, 7), (8, 9, 10, 11)]
        for cols, expected in (
            (
                1,
                [
                    (0,),
                    (1,),
                    (2,),
                    (3,),
                    (4,),
                    (5,),
                    (6,),
                    (7,),
                    (8,),
                    (9,),
                    (10,),
                    (11,),
                ],
            ),
            (2, [(0, 1), (2, 3), (4, 5), (6, 7), (8, 9), (10, 11)]),
            (3, [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11)]),
            (4, [(0, 1, 2, 3), (4, 5, 6, 7), (8, 9, 10, 11)]),
            (6, [(0, 1, 2, 3, 4, 5), (6, 7, 8, 9, 10, 11)]),
            (12, [(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)]),
        ):
            with self.subTest(cols=cols):
>               actual = list(mi.reshape(matrix, cols))
E               TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:1100: TypeError
</pre>
</details>
<h3 id="test_recipespyreshapeteststest_empty">test_recipes.py::ReshapeTests::test_empty</h3>
<details><summary> <pre>test_recipes.py::ReshapeTests::test_empty</pre></summary><pre>
self = <tests.test_recipes.ReshapeTests testMethod=test_empty>

    def test_empty(self):
>       actual = list(mi.reshape([], 3))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:1065: TypeError
</pre>
</details>
<h3 id="test_recipespyreshapeteststest_zero">test_recipes.py::ReshapeTests::test_zero</h3>
<details><summary> <pre>test_recipes.py::ReshapeTests::test_zero</pre></summary><pre>
self = <tests.test_recipes.ReshapeTests testMethod=test_zero>

    def test_zero(self):
        matrix = [(0, 1, 2, 3), (4, 5, 6, 7), (8, 9, 10, 11)]
        with self.assertRaises(ValueError):
>           list(mi.reshape(matrix, 0))
E           TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:1071: TypeError
</pre>
</details>
<h3 id="test_recipespymatmulteststest_m_by_n">test_recipes.py::MatMulTests::test_m_by_n</h3>
<details><summary> <pre>test_recipes.py::MatMulTests::test_m_by_n</pre></summary><pre>
self = <tests.test_recipes.MatMulTests testMethod=test_m_by_n>

    def test_m_by_n(self):
        m1 = [[2, 5], [7, 9], [3, 4]]
        m2 = [[7, 11, 5, 4, 9], [3, 5, 2, 6, 3]]
>       actual = list(mi.matmul(m1, m2))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:1113: TypeError
</pre>
</details>
<h3 id="test_recipespymatmulteststest_n_by_n">test_recipes.py::MatMulTests::test_n_by_n</h3>
<details><summary> <pre>test_recipes.py::MatMulTests::test_n_by_n</pre></summary><pre>
self = <tests.test_recipes.MatMulTests testMethod=test_n_by_n>

    def test_n_by_n(self):
>       actual = list(mi.matmul([(7, 5), (3, 5)], [[2, 5], [7, 9]]))
E       TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:1106: TypeError
</pre>
</details>
<h3 id="test_recipespyfactorteststest_basic">test_recipes.py::FactorTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::FactorTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.FactorTests testMethod=test_basic>

    def test_basic(self):
        for n, expected in (
            (0, []),
            (1, []),
            (2, [2]),
            (3, [3]),
            (4, [2, 2]),
            (6, [2, 3]),
            (360, [2, 2, 2, 3, 3, 5]),
            (128_884_753_939, [128_884_753_939]),
            (999953 * 999983, [999953, 999983]),
            (909_909_090_909, [3, 3, 7, 13, 13, 751, 113797]),
        ):
            with self.subTest(n=n):
>               actual = list(mi.factor(n))
E               TypeError: 'NoneType' object is not iterable

tests/test_recipes.py:1137: TypeError
</pre>
</details>
<h3 id="test_recipespyfactorteststest_cross_check">test_recipes.py::FactorTests::test_cross_check</h3>
<details><summary> <pre>test_recipes.py::FactorTests::test_cross_check</pre></summary><pre>
self = <tests.test_recipes.FactorTests testMethod=test_cross_check>

    def test_cross_check(self):
        prod = lambda x: reduce(mul, x, 1)
>       self.assertTrue(all(prod(mi.factor(n)) == n for n in range(1, 2000)))

tests/test_recipes.py:1142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_recipes.py:1142: in <genexpr>
    self.assertTrue(all(prod(mi.factor(n)) == n for n in range(1, 2000)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = None

>   prod = lambda x: reduce(mul, x, 1)
E   TypeError: reduce() arg 2 must support iteration

tests/test_recipes.py:1141: TypeError
</pre>
</details>
<h3 id="test_recipespysumofsquaresteststest_basic">test_recipes.py::SumOfSquaresTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::SumOfSquaresTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.SumOfSquaresTests testMethod=test_basic>

    def test_basic(self):
        for it, expected in (
            ([], 0),
            ([1, 2, 3], 1 + 4 + 9),
            ([2, 4, 6, 8], 4 + 16 + 36 + 64),
        ):
            with self.subTest(it=it):
                actual = mi.sum_of_squares(it)
>               self.assertEqual(actual, expected)
E               AssertionError: None != 0

tests/test_recipes.py:1162: AssertionError
</pre>
</details>
<h3 id="test_recipespypolynomialderivativeteststest_basic">test_recipes.py::PolynomialDerivativeTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::PolynomialDerivativeTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.PolynomialDerivativeTests testMethod=test_basic>

    def test_basic(self):
        for coefficients, expected in [
            ([], []),
            ([1], []),
            ([1, 2], [1]),
            ([1, 2, 3], [2, 2]),
            ([1, 2, 3, 4], [3, 4, 3]),
            ([1.1, 2, 3, 4], [(1.1 * 3), 4, 3]),
        ]:
            with self.subTest(coefficients=coefficients):
                actual = mi.polynomial_derivative(coefficients)
>               self.assertEqual(actual, expected)
E               AssertionError: None != []

tests/test_recipes.py:1177: AssertionError
</pre>
</details>
<h3 id="test_recipespytotientteststest_basic">test_recipes.py::TotientTests::test_basic</h3>
<details><summary> <pre>test_recipes.py::TotientTests::test_basic</pre></summary><pre>
self = <tests.test_recipes.TotientTests testMethod=test_basic>

    def test_basic(self):
        for n, expected in (
            (1, 1),
            (2, 1),
            (3, 2),
            (4, 2),
            (9, 6),
            (12, 4),
            (128_884_753_939, 128_884_753_938),
            (999953 * 999983, 999952 * 999982),
            (6**20, 1 * 2**19 * 2 * 3**19),
        ):
            with self.subTest(n=n):
>               self.assertEqual(mi.totient(n), expected)
E               AssertionError: None != 1

tests/test_recipes.py:1194: AssertionError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/more_itertools/more.py b/more_itertools/more.py</span>
<span class="gh">index 7ef1c96..d9287c7 100755</span>
<span class="gd">--- a/more_itertools/more.py</span>
<span class="gi">+++ b/more_itertools/more.py</span>
<span class="gu">@@ -16,6 +16,77 @@ from .recipes import _marker, _zip_equal, UnequalIterablesError, consume, flatte</span>
<span class="w"> </span>__all__ = [&#39;AbortThread&#39;, &#39;SequenceView&#39;, &#39;UnequalIterablesError&#39;, &#39;adjacent&#39;, &#39;all_unique&#39;, &#39;always_iterable&#39;, &#39;always_reversible&#39;, &#39;bucket&#39;, &#39;callback_iter&#39;, &#39;chunked&#39;, &#39;chunked_even&#39;, &#39;circular_shifts&#39;, &#39;collapse&#39;, &#39;combination_index&#39;, &#39;combination_with_replacement_index&#39;, &#39;consecutive_groups&#39;, &#39;constrained_batches&#39;, &#39;consumer&#39;, &#39;count_cycle&#39;, &#39;countable&#39;, &#39;dft&#39;, &#39;difference&#39;, &#39;distinct_combinations&#39;, &#39;distinct_permutations&#39;, &#39;distribute&#39;, &#39;divide&#39;, &#39;doublestarmap&#39;, &#39;duplicates_everseen&#39;, &#39;duplicates_justseen&#39;, &#39;classify_unique&#39;, &#39;exactly_n&#39;, &#39;filter_except&#39;, &#39;filter_map&#39;, &#39;first&#39;, &#39;gray_product&#39;, &#39;groupby_transform&#39;, &#39;ichunked&#39;, &#39;iequals&#39;, &#39;idft&#39;, &#39;ilen&#39;, &#39;interleave&#39;, &#39;interleave_evenly&#39;, &#39;interleave_longest&#39;, &#39;intersperse&#39;, &#39;is_sorted&#39;, &#39;islice_extended&#39;, &#39;iterate&#39;, &#39;iter_suppress&#39;, &#39;join_mappings&#39;, &#39;last&#39;, &#39;locate&#39;, &#39;longest_common_prefix&#39;, &#39;lstrip&#39;, &#39;make_decorator&#39;, &#39;map_except&#39;, &#39;map_if&#39;, &#39;map_reduce&#39;, &#39;mark_ends&#39;, &#39;minmax&#39;, &#39;nth_or_last&#39;, &#39;nth_permutation&#39;, &#39;nth_product&#39;, &#39;nth_combination_with_replacement&#39;, &#39;numeric_range&#39;, &#39;one&#39;, &#39;only&#39;, &#39;outer_product&#39;, &#39;padded&#39;, &#39;partial_product&#39;, &#39;partitions&#39;, &#39;peekable&#39;, &#39;permutation_index&#39;, &#39;powerset_of_sets&#39;, &#39;product_index&#39;, &#39;raise_&#39;, &#39;repeat_each&#39;, &#39;repeat_last&#39;, &#39;replace&#39;, &#39;rlocate&#39;, &#39;rstrip&#39;, &#39;run_length&#39;, &#39;sample&#39;, &#39;seekable&#39;, &#39;set_partitions&#39;, &#39;side_effect&#39;, &#39;sliced&#39;, &#39;sort_together&#39;, &#39;split_after&#39;, &#39;split_at&#39;, &#39;split_before&#39;, &#39;split_into&#39;, &#39;split_when&#39;, &#39;spy&#39;, &#39;stagger&#39;, &#39;strip&#39;, &#39;strictly_n&#39;, &#39;substrings&#39;, &#39;substrings_indexes&#39;, &#39;takewhile_inclusive&#39;, &#39;time_limited&#39;, &#39;unique_in_window&#39;, &#39;unique_to_each&#39;, &#39;unzip&#39;, &#39;value_chain&#39;, &#39;windowed&#39;, &#39;windowed_complete&#39;, &#39;with_iter&#39;, &#39;zip_broadcast&#39;, &#39;zip_equal&#39;, &#39;zip_offset&#39;]
<span class="w"> </span>_fsumprod = getattr(math, &#39;sumprod&#39;, lambda x, y: fsum(map(mul, x, y)))

<span class="gi">+def raise_(exception, *args):</span>
<span class="gi">+    &quot;&quot;&quot;Raise an exception in a context manager.</span>
<span class="gi">+</span>
<span class="gi">+    Used for conditional exception raising:</span>
<span class="gi">+</span>
<span class="gi">+        &gt;&gt;&gt; it = [&#39;a&#39;, &#39;b&#39;]</span>
<span class="gi">+        &gt;&gt;&gt; raise_(RuntimeError, &#39;Something bad happened&#39;) if len(it) &lt;= 2 else it[2]</span>
<span class="gi">+        Traceback (most recent call last):</span>
<span class="gi">+            ...</span>
<span class="gi">+        RuntimeError: Something bad happened</span>
<span class="gi">+</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    raise exception(*args)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def side_effect(func, iterable, chunk_size=None, before=None, after=None):</span>
<span class="gi">+    &quot;&quot;&quot;Invoke *func* on each item in *iterable* (or on each *chunk_size* group of</span>
<span class="gi">+    items) before yielding the item.</span>
<span class="gi">+</span>
<span class="gi">+    `func` must be a function that takes a single argument. Its return value</span>
<span class="gi">+    will be discarded.</span>
<span class="gi">+</span>
<span class="gi">+    *before* and *after* are optional functions that take no arguments. They</span>
<span class="gi">+    will be executed before iteration starts and after it ends, respectively.</span>
<span class="gi">+</span>
<span class="gi">+    `side_effect` can be used for logging, updating progress bars, or anything</span>
<span class="gi">+    that is not functionally &quot;pure.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    Emitting a status message:</span>
<span class="gi">+</span>
<span class="gi">+        &gt;&gt;&gt; func = lambda item: print(&#39;Received {}&#39;.format(item))</span>
<span class="gi">+        &gt;&gt;&gt; list(side_effect(func, range(2)))</span>
<span class="gi">+        Received 0</span>
<span class="gi">+        Received 1</span>
<span class="gi">+        [0, 1]</span>
<span class="gi">+</span>
<span class="gi">+    Operating on chunks of items:</span>
<span class="gi">+</span>
<span class="gi">+        &gt;&gt;&gt; pair_sum = lambda chunk: print(&#39;Sum of pair is {}&#39;.format(sum(chunk)))</span>
<span class="gi">+        &gt;&gt;&gt; list(side_effect(pair_sum, range(6), 2))</span>
<span class="gi">+        Sum of pair is 1</span>
<span class="gi">+        Sum of pair is 5</span>
<span class="gi">+        Sum of pair is 9</span>
<span class="gi">+        [0, 1, 2, 3, 4, 5]</span>
<span class="gi">+</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    def wrapped():</span>
<span class="gi">+        if before is not None:</span>
<span class="gi">+            before()</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            if chunk_size is None:</span>
<span class="gi">+                for item in iterable:</span>
<span class="gi">+                    func(item)</span>
<span class="gi">+                    yield item</span>
<span class="gi">+            else:</span>
<span class="gi">+                it = iter(iterable)</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    chunk = list(islice(it, chunk_size))</span>
<span class="gi">+                    if not chunk:</span>
<span class="gi">+                        break</span>
<span class="gi">+                    func(chunk)</span>
<span class="gi">+                    for item in chunk:</span>
<span class="gi">+                        yield item</span>
<span class="gi">+        finally:</span>
<span class="gi">+            if after is not None:</span>
<span class="gi">+                after()</span>
<span class="gi">+</span>
<span class="gi">+    return wrapped()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def chunked(iterable, n, strict=False):
<span class="w"> </span>    &quot;&quot;&quot;Break *iterable* into lists of length *n*:

<span class="gu">@@ -35,7 +106,20 @@ def chunked(iterable, n, strict=False):</span>
<span class="w"> </span>    list is yielded.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n is None:</span>
<span class="gi">+        yield list(iterable)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    iterator = iter(iterable)</span>
<span class="gi">+    while True:</span>
<span class="gi">+        chunk = list(islice(iterator, n))</span>
<span class="gi">+        if not chunk:</span>
<span class="gi">+            return</span>
<span class="gi">+        if strict and len(chunk) != n:</span>
<span class="gi">+            if n is None:</span>
<span class="gi">+                raise ValueError(&quot;n must not be None when using strict mode.&quot;)</span>
<span class="gi">+            raise ValueError(&quot;iterable is not divisible by n&quot;)</span>
<span class="gi">+        yield chunk</span>

<span class="w"> </span>def first(iterable, default=_marker):
<span class="w"> </span>    &quot;&quot;&quot;Return the first item of *iterable*, or *default* if *iterable* is
<span class="gu">@@ -54,7 +138,12 @@ def first(iterable, default=_marker):</span>
<span class="w"> </span>    ``next(iter(iterable), default)``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return next(iter(iterable))</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        if default is _marker:</span>
<span class="gi">+            raise ValueError(&#39;first() was called on an empty iterable&#39;)</span>
<span class="gi">+        return default</span>

<span class="w"> </span>def last(iterable, default=_marker):
<span class="w"> </span>    &quot;&quot;&quot;Return the last item of *iterable*, or *default* if *iterable* is
<span class="gu">@@ -68,7 +157,30 @@ def last(iterable, default=_marker):</span>
<span class="w"> </span>    If *default* is not provided and there are no items in the iterable,
<span class="w"> </span>    raise ``ValueError``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Try to get the last element using sequence protocol</span>
<span class="gi">+        if isinstance(iterable, Sequence):</span>
<span class="gi">+            if not iterable:</span>
<span class="gi">+                if default is _marker:</span>
<span class="gi">+                    raise ValueError(&#39;last() was called on an empty iterable&#39;)</span>
<span class="gi">+                return default</span>
<span class="gi">+            return iterable[-1]</span>
<span class="gi">+        </span>
<span class="gi">+        # Fall back to iterating</span>
<span class="gi">+        it = iter(iterable)</span>
<span class="gi">+        try:</span>
<span class="gi">+            item = next(it)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            if default is _marker:</span>
<span class="gi">+                raise ValueError(&#39;last() was called on an empty iterable&#39;)</span>
<span class="gi">+            return default</span>
<span class="gi">+            </span>
<span class="gi">+        for item in it:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return item</span>
<span class="gi">+    except (TypeError, KeyError, AttributeError):</span>
<span class="gi">+        # Handle mappings and other objects that don&#39;t support indexing</span>
<span class="gi">+        return last(list(iterable), default)</span>

<span class="w"> </span>def nth_or_last(iterable, n, default=_marker):
<span class="w"> </span>    &quot;&quot;&quot;Return the nth or the last item of *iterable*,
<span class="gu">@@ -84,7 +196,22 @@ def nth_or_last(iterable, n, default=_marker):</span>
<span class="w"> </span>    If *default* is not provided and there are no items in the iterable,
<span class="w"> </span>    raise ``ValueError``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    it = iter(iterable)</span>
<span class="gi">+    try:</span>
<span class="gi">+        item = next(it)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        if default is _marker:</span>
<span class="gi">+            raise ValueError(&#39;nth_or_last() was called on an empty iterable&#39;)</span>
<span class="gi">+        return default</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        for i, item in enumerate(chain([item], it)):</span>
<span class="gi">+            if i == n:</span>
<span class="gi">+                return item</span>
<span class="gi">+        return item  # If we get here, we ran out of items before reaching n</span>
<span class="gi">+    except (TypeError, KeyError, AttributeError):</span>
<span class="gi">+        # Handle mappings and other objects that don&#39;t support indexing</span>
<span class="gi">+        return nth_or_last(list(iterable), n, default)</span>

<span class="w"> </span>class peekable:
<span class="w"> </span>    &quot;&quot;&quot;Wrap an iterator to allow lookahead and prepending elements.
<span class="gh">diff --git a/more_itertools/recipes.py b/more_itertools/recipes.py</span>
<span class="gh">index 9c5e363..49c57ec 100644</span>
<span class="gd">--- a/more_itertools/recipes.py</span>
<span class="gi">+++ b/more_itertools/recipes.py</span>
<span class="gu">@@ -23,8 +23,38 @@ except TypeError:</span>
<span class="w"> </span>    _zip_strict = zip
<span class="w"> </span>else:
<span class="w"> </span>    _zip_strict = partial(zip, strict=True)
<span class="gi">+</span>
<span class="gi">+def _zip_equal(*iterables):</span>
<span class="gi">+    &quot;&quot;&quot;Like zip(), but ensures all iterables have the same length.&quot;&quot;&quot;</span>
<span class="gi">+    # zip_longest() wouldn&#39;t work here because it suppresses length differences</span>
<span class="gi">+    sentinel = object()</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for combo in zip_longest(*iterables, fillvalue=sentinel):</span>
<span class="gi">+        if any(x is sentinel for x in combo):</span>
<span class="gi">+            raise UnequalIterablesError()</span>
<span class="gi">+        result.append(combo)</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="w"> </span>_sumprod = getattr(math, &#39;sumprod&#39;, lambda x, y: dotproduct(x, y))

<span class="gi">+def batched(iterable, n, *, strict=False):</span>
<span class="gi">+    &quot;&quot;&quot;Batch data into lists of length *n*. The last batch may be shorter.</span>
<span class="gi">+</span>
<span class="gi">+    &gt;&gt;&gt; list(batched(&#39;ABCDEFG&#39;, 3))</span>
<span class="gi">+    [[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;], [&#39;D&#39;, &#39;E&#39;, &#39;F&#39;], [&#39;G&#39;]]</span>
<span class="gi">+</span>
<span class="gi">+    This recipe is from the ``itertools`` docs.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if n &lt; 1:</span>
<span class="gi">+        raise ValueError(&#39;n must be at least one&#39;)</span>
<span class="gi">+    it = iter(iterable)</span>
<span class="gi">+    while True:</span>
<span class="gi">+        batch = list(islice(it, n))</span>
<span class="gi">+        if not batch:</span>
<span class="gi">+            break</span>
<span class="gi">+        yield batch</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def take(n, iterable):
<span class="w"> </span>    &quot;&quot;&quot;Return first *n* items of the iterable as a list.

<span class="gu">@@ -38,7 +68,7 @@ def take(n, iterable):</span>
<span class="w"> </span>        [0, 1, 2]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return list(islice(iterable, n))</span>

<span class="w"> </span>def tabulate(function, start=0):
<span class="w"> </span>    &quot;&quot;&quot;Return an iterator over the results of ``func(start)``,
<span class="gu">@@ -217,12 +247,14 @@ def _pairwise(iterable):</span>
<span class="w"> </span>    On Python 3.10 and above, this is an alias for :func:`itertools.pairwise`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    a, b = tee(iterable)</span>
<span class="gi">+    next(b, None)</span>
<span class="gi">+    return zip(a, b)</span>
<span class="w"> </span>try:
<span class="w"> </span>    from itertools import pairwise as itertools_pairwise
<span class="gi">+    pairwise = itertools_pairwise</span>
<span class="w"> </span>except ImportError:
<span class="w"> </span>    pairwise = _pairwise
<span class="gd">-else:</span>
<span class="w"> </span>    pairwise.__doc__ = _pairwise.__doc__

<span class="w"> </span>class UnequalIterablesError(ValueError):
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>