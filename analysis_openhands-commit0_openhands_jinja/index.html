
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis openhands commit0 openhands jinja - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#openhands-jinja" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis openhands commit0 openhands jinja
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_openhands-commit0_openhands">back to OpenHands summary</a></p>
<h1 id="openhands-jinja"><strong>OpenHands</strong>: jinja</h1>
<h2 id="failed-to-run-pytests-for-test-tests">Failed to run pytests for test <code>tests</code></h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/conftest.py:5: in &lt;module&gt;
    from jinja2 import loaders
src/jinja2/__init__.py:9: in &lt;module&gt;
    from .environment import Environment as Environment
src/jinja2/environment.py:17: in &lt;module&gt;
    from .defaults import BLOCK_END_STRING
src/jinja2/defaults.py:2: in &lt;module&gt;
    from .filters import FILTERS as DEFAULT_FILTERS
src/jinja2/filters.py:18: in &lt;module&gt;
    from .runtime import Undefined
src/jinja2/runtime.py:4: in &lt;module&gt;
    def _dict_method_all(method: t.Callable[..., t.Any]) -&gt; t.Callable[..., t.Any]:
E   NameError: name &#39;t&#39; is not defined
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/jinja2/async_utils.py b/src/jinja2/async_utils.py</span>
<span class="gh">index 79c1adc..8264152 100644</span>
<span class="gd">--- a/src/jinja2/async_utils.py</span>
<span class="gi">+++ b/src/jinja2/async_utils.py</span>
<span class="gu">@@ -5,4 +5,88 @@ from functools import wraps</span>
<span class="w"> </span>from .utils import _PassArg
<span class="w"> </span>from .utils import pass_eval_context
<span class="w"> </span>V = t.TypeVar(&#39;V&#39;)
<span class="gd">-_common_primitives = {int, float, bool, str, list, dict, tuple, type(None)}</span>
\ No newline at end of file
<span class="gi">+_common_primitives = {int, float, bool, str, list, dict, tuple, type(None)}</span>
<span class="gi">+</span>
<span class="gi">+def async_variant(normal_func: t.Callable[..., V]) -&gt; t.Callable[..., t.Awaitable[V]]:</span>
<span class="gi">+    &quot;&quot;&quot;Returns an async variant of a sync function. This is useful to provide</span>
<span class="gi">+    async versions of filters and tests.</span>
<span class="gi">+</span>
<span class="gi">+    Example::</span>
<span class="gi">+</span>
<span class="gi">+        def foo(x):</span>
<span class="gi">+            return x</span>
<span class="gi">+</span>
<span class="gi">+        async_foo = async_variant(foo)</span>
<span class="gi">+</span>
<span class="gi">+    When called, the original function will be run in a thread executor.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    is_async = inspect.iscoroutinefunction(normal_func)</span>
<span class="gi">+    is_filter = getattr(normal_func, &#39;_jinja_filter&#39;, False)</span>
<span class="gi">+    is_test = getattr(normal_func, &#39;_jinja_test&#39;, False)</span>
<span class="gi">+    is_pass_arg = getattr(normal_func, &#39;_pass_arg&#39;, None)</span>
<span class="gi">+    is_pass_eval_context = getattr(normal_func, &#39;_pass_eval_context&#39;, False)</span>
<span class="gi">+</span>
<span class="gi">+    if is_async:</span>
<span class="gi">+        return normal_func</span>
<span class="gi">+</span>
<span class="gi">+    async def async_func(*args: t.Any, **kwargs: t.Any) -&gt; V:</span>
<span class="gi">+        if is_pass_arg is not None:</span>
<span class="gi">+            kwargs.pop(is_pass_arg.value, None)</span>
<span class="gi">+        if is_pass_eval_context:</span>
<span class="gi">+            args = args[1:]</span>
<span class="gi">+        return await normal_func(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    # Properly rewrap the function to carry over all the original attributes</span>
<span class="gi">+    # and metadata of the original function</span>
<span class="gi">+    async_func = wraps(normal_func, assigned=WRAPPER_ASSIGNMENTS)(async_func)</span>
<span class="gi">+    if is_filter:</span>
<span class="gi">+        async_func._jinja_filter = True  # type: ignore</span>
<span class="gi">+    if is_test:</span>
<span class="gi">+        async_func._jinja_test = True  # type: ignore</span>
<span class="gi">+    if is_pass_arg is not None:</span>
<span class="gi">+        async_func._pass_arg = is_pass_arg  # type: ignore</span>
<span class="gi">+    if is_pass_eval_context:</span>
<span class="gi">+        async_func._pass_eval_context = True  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    return async_func</span>
<span class="gi">+</span>
<span class="gi">+async def auto_aiter(value: t.Any) -&gt; t.AsyncIterator[t.Any]:</span>
<span class="gi">+    &quot;&quot;&quot;Convert an iterable into an async iterable. This is useful to</span>
<span class="gi">+    iterate over sync iterables in async contexts.</span>
<span class="gi">+</span>
<span class="gi">+    Example::</span>
<span class="gi">+</span>
<span class="gi">+        async for item in auto_aiter([1, 2, 3]):</span>
<span class="gi">+            ...</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if hasattr(value, &#39;__aiter__&#39;):</span>
<span class="gi">+        async for item in value:</span>
<span class="gi">+            yield item</span>
<span class="gi">+    else:</span>
<span class="gi">+        for item in value:</span>
<span class="gi">+            yield item</span>
<span class="gi">+</span>
<span class="gi">+async def auto_await(value: t.Any) -&gt; t.Any:</span>
<span class="gi">+    &quot;&quot;&quot;Convert a value into its awaited value if it&#39;s awaitable.</span>
<span class="gi">+    Otherwise return it as-is. This is useful to handle both async</span>
<span class="gi">+    and sync functions in the same code.</span>
<span class="gi">+</span>
<span class="gi">+    Example::</span>
<span class="gi">+</span>
<span class="gi">+        value = await auto_await(value)</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if hasattr(value, &#39;__await__&#39;):</span>
<span class="gi">+        return await value</span>
<span class="gi">+    return value</span>
<span class="gi">+</span>
<span class="gi">+async def auto_to_list(value: t.Any) -&gt; t.List[t.Any]:</span>
<span class="gi">+    &quot;&quot;&quot;Convert an iterable into a list. This is useful to handle both</span>
<span class="gi">+    async and sync iterables in the same code.</span>
<span class="gi">+</span>
<span class="gi">+    Example::</span>
<span class="gi">+</span>
<span class="gi">+        items = await auto_to_list(items)</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if hasattr(value, &#39;__aiter__&#39;):</span>
<span class="gi">+        return [item async for item in value]</span>
<span class="gi">+    return list(value)</span>
\ No newline at end of file
<span class="gh">diff --git a/src/jinja2/compiler.py b/src/jinja2/compiler.py</span>
<span class="gh">index 5d623b3..2ca8550 100644</span>
<span class="gd">--- a/src/jinja2/compiler.py</span>
<span class="gi">+++ b/src/jinja2/compiler.py</span>
<span class="gu">@@ -71,11 +71,26 @@ class Frame:</span>

<span class="w"> </span>    def copy(self) -&gt; &#39;Frame&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Create a copy of the current one.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = object.__new__(Frame)</span>
<span class="gi">+        rv.eval_ctx = self.eval_ctx</span>
<span class="gi">+        rv.parent = self.parent</span>
<span class="gi">+        rv.symbols = self.symbols</span>
<span class="gi">+        rv.require_output_check = self.require_output_check</span>
<span class="gi">+        rv.buffer = self.buffer</span>
<span class="gi">+        rv.block = self.block</span>
<span class="gi">+        rv.toplevel = self.toplevel</span>
<span class="gi">+        rv.rootlevel = self.rootlevel</span>
<span class="gi">+        rv.loop_frame = self.loop_frame</span>
<span class="gi">+        rv.block_frame = self.block_frame</span>
<span class="gi">+        rv.soft_frame = self.soft_frame</span>
<span class="gi">+        return rv</span>

<span class="w"> </span>    def inner(self, isolated: bool=False) -&gt; &#39;Frame&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Return an inner frame.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = Frame(self.eval_ctx, self, level=self.symbols.level + 1)</span>
<span class="gi">+        if isolated:</span>
<span class="gi">+            rv.symbols.add_level()</span>
<span class="gi">+        return rv</span>

<span class="w"> </span>    def soft(self) -&gt; &#39;Frame&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Return a soft frame.  A soft frame may not be modified as
<span class="gu">@@ -85,7 +100,19 @@ class Frame:</span>
<span class="w"> </span>        This is only used to implement if-statements and conditional
<span class="w"> </span>        expressions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = object.__new__(Frame)</span>
<span class="gi">+        rv.eval_ctx = self.eval_ctx</span>
<span class="gi">+        rv.parent = self.parent</span>
<span class="gi">+        rv.symbols = self.symbols</span>
<span class="gi">+        rv.require_output_check = self.require_output_check</span>
<span class="gi">+        rv.buffer = self.buffer</span>
<span class="gi">+        rv.block = self.block</span>
<span class="gi">+        rv.toplevel = False</span>
<span class="gi">+        rv.rootlevel = False</span>
<span class="gi">+        rv.loop_frame = self.loop_frame</span>
<span class="gi">+        rv.block_frame = self.block_frame</span>
<span class="gi">+        rv.soft_frame = True</span>
<span class="gi">+        return rv</span>
<span class="w"> </span>    __copy__ = copy

<span class="w"> </span>class VisitorExit(RuntimeError):
<span class="gu">@@ -100,7 +127,7 @@ class DependencyFinderVisitor(NodeVisitor):</span>

<span class="w"> </span>    def visit_Block(self, node: nodes.Block) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Stop visiting at blocks.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return</span>

<span class="w"> </span>class UndeclaredNameVisitor(NodeVisitor):
<span class="w"> </span>    &quot;&quot;&quot;A visitor that checks if a name is accessed without being
<span class="gu">@@ -114,7 +141,7 @@ class UndeclaredNameVisitor(NodeVisitor):</span>

<span class="w"> </span>    def visit_Block(self, node: nodes.Block) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Stop visiting a blocks.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return</span>

<span class="w"> </span>class CompilerExit(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Raised if the compiler encountered a situation where it just
<span class="gu">@@ -122,6 +149,22 @@ class CompilerExit(Exception):</span>
<span class="w"> </span>    raises such an exception is not further processed.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+def _make_binop(op: str) -&gt; t.Callable[[&#39;CodeGenerator&#39;, nodes.BinExpr, Frame], None]:</span>
<span class="gi">+    def visitor(self: &#39;CodeGenerator&#39;, node: nodes.BinExpr, frame: Frame) -&gt; None:</span>
<span class="gi">+        self.write(&#39;(&#39;)</span>
<span class="gi">+        self.visit(node.left, frame)</span>
<span class="gi">+        self.write(f&#39; {op} &#39;)</span>
<span class="gi">+        self.visit(node.right, frame)</span>
<span class="gi">+        self.write(&#39;)&#39;)</span>
<span class="gi">+    return visitor</span>
<span class="gi">+</span>
<span class="gi">+def _make_unop(op: str) -&gt; t.Callable[[&#39;CodeGenerator&#39;, nodes.UnaryExpr, Frame], None]:</span>
<span class="gi">+    def visitor(self: &#39;CodeGenerator&#39;, node: nodes.UnaryExpr, frame: Frame) -&gt; None:</span>
<span class="gi">+        self.write(&#39;(&#39; + op)</span>
<span class="gi">+        self.visit(node.node, frame)</span>
<span class="gi">+        self.write(&#39;)&#39;)</span>
<span class="gi">+    return visitor</span>
<span class="gi">+</span>
<span class="w"> </span>class CodeGenerator(NodeVisitor):

<span class="w"> </span>    def __init__(self, environment: &#39;Environment&#39;, name: t.Optional[str], filename: t.Optional[str], stream: t.Optional[t.TextIO]=None, defer_init: bool=False, optimized: bool=True) -&gt; None:
<span class="gu">@@ -156,57 +199,89 @@ class CodeGenerator(NodeVisitor):</span>

<span class="w"> </span>    def fail(self, msg: str, lineno: int) -&gt; &#39;te.NoReturn&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Fail with a :exc:`TemplateAssertionError`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise TemplateAssertionError(msg, lineno, self.name, self.filename)</span>

<span class="w"> </span>    def temporary_identifier(self) -&gt; str:
<span class="w"> </span>        &quot;&quot;&quot;Get a new unique identifier.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._last_identifier += 1</span>
<span class="gi">+        return f&#39;_tmp_{self._last_identifier}&#39;</span>

<span class="w"> </span>    def buffer(self, frame: Frame) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Enable buffering for the frame from that point onwards.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        frame.buffer = self.temporary_identifier()</span>

<span class="w"> </span>    def return_buffer_contents(self, frame: Frame, force_unescaped: bool=False) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Return the buffer contents of the frame.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not frame.buffer:</span>
<span class="gi">+            self.writeline(&#39;if 0: yield None&#39;)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if force_unescaped:</span>
<span class="gi">+            self.writeline(f&#39;yield str({frame.buffer})&#39;)</span>
<span class="gi">+        elif frame.eval_ctx.volatile:</span>
<span class="gi">+            self.writeline(f&#39;yield str({frame.buffer}) if context.eval_ctx.autoescape else {frame.buffer}&#39;)</span>
<span class="gi">+        elif frame.eval_ctx.autoescape:</span>
<span class="gi">+            self.writeline(f&#39;yield str({frame.buffer})&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.writeline(f&#39;yield {frame.buffer}&#39;)</span>

<span class="w"> </span>    def indent(self) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Indent by one.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._indentation += 1</span>

<span class="w"> </span>    def outdent(self, step: int=1) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Outdent by step.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._indentation = max(0, self._indentation - step)</span>

<span class="w"> </span>    def start_write(self, frame: Frame, node: t.Optional[nodes.Node]=None) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Yield or write into the frame buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if frame.buffer is None:</span>
<span class="gi">+            self.writeline(&#39;yield &#39;, node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.writeline(f&#39;{frame.buffer} = &#39;, node)</span>

<span class="w"> </span>    def end_write(self, frame: Frame) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;End the writing process started by `start_write`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if frame.buffer is not None:</span>
<span class="gi">+            self.writeline(f&#39;yield {frame.buffer}&#39;)</span>

<span class="w"> </span>    def simple_write(self, s: str, frame: Frame, node: t.Optional[nodes.Node]=None) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Simple shortcut for start_write + write + end_write.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.start_write(frame, node)</span>
<span class="gi">+        self.write(s)</span>
<span class="gi">+        self.end_write(frame)</span>

<span class="w"> </span>    def blockvisit(self, nodes: t.Iterable[nodes.Node], frame: Frame) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Visit a list of nodes as block in a frame.  If the current frame
<span class="w"> </span>        is no buffer a dummy ``if 0: yield None`` is written automatically.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if frame.buffer is None:</span>
<span class="gi">+            self.writeline(&#39;if 0: yield None&#39;)</span>
<span class="gi">+        for node in nodes:</span>
<span class="gi">+            self.visit(node, frame)</span>

<span class="w"> </span>    def write(self, x: str) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Write a string into the output stream.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._new_lines:</span>
<span class="gi">+            if not self._first_write:</span>
<span class="gi">+                self.stream.write(&#39;\n&#39; * self._new_lines)</span>
<span class="gi">+            self.stream.write(&#39;    &#39; * self._indentation)</span>
<span class="gi">+            self._new_lines = 0</span>
<span class="gi">+        self.stream.write(x)</span>
<span class="gi">+        self._first_write = False</span>

<span class="w"> </span>    def writeline(self, x: str, node: t.Optional[nodes.Node]=None, extra: int=0) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Combination of newline and write.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node is not None:</span>
<span class="gi">+            self._write_debug_info(node)</span>
<span class="gi">+        self.newline(node, extra)</span>
<span class="gi">+        self.write(x)</span>

<span class="w"> </span>    def newline(self, node: t.Optional[nodes.Node]=None, extra: int=0) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Add one or more newlines before the next write.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node is not None:</span>
<span class="gi">+            self._write_debug_info(node)</span>
<span class="gi">+        self._new_lines = max(self._new_lines, 1 + extra)</span>

<span class="w"> </span>    def signature(self, node: t.Union[nodes.Call, nodes.Filter, nodes.Test], frame: Frame, extra_kwargs: t.Optional[t.Mapping[str, t.Any]]=None) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Writes a function call to the stream for the current node.
<span class="gu">@@ -215,7 +290,33 @@ class CodeGenerator(NodeVisitor):</span>
<span class="w"> </span>        error could occur.  The extra keyword arguments should be given
<span class="w"> </span>        as python dict.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if extra_kwargs is None:</span>
<span class="gi">+            extra_kwargs = {}</span>
<span class="gi">+</span>
<span class="gi">+        # Regular argument handling</span>
<span class="gi">+        for arg in node.args:</span>
<span class="gi">+            self.write(&#39;, &#39;)</span>
<span class="gi">+            self.visit(arg, frame)</span>
<span class="gi">+</span>
<span class="gi">+        # Keyword argument handling</span>
<span class="gi">+        for kwarg in node.kwargs:</span>
<span class="gi">+            self.write(&#39;, &#39;)</span>
<span class="gi">+            self.write(kwarg.key + &#39;=&#39;)</span>
<span class="gi">+            self.visit(kwarg.value, frame)</span>
<span class="gi">+</span>
<span class="gi">+        # Dynamic arguments</span>
<span class="gi">+        if node.dyn_args is not None:</span>
<span class="gi">+            self.write(&#39;, *&#39;)</span>
<span class="gi">+            self.visit(node.dyn_args, frame)</span>
<span class="gi">+</span>
<span class="gi">+        # Dynamic keyword arguments</span>
<span class="gi">+        if node.dyn_kwargs is not None:</span>
<span class="gi">+            self.write(&#39;, **&#39;)</span>
<span class="gi">+            self.visit(node.dyn_kwargs, frame)</span>
<span class="gi">+</span>
<span class="gi">+        # Extra keyword arguments from the call</span>
<span class="gi">+        for key, value in extra_kwargs.items():</span>
<span class="gi">+            self.write(f&#39;, {key}={value!r}&#39;)</span>

<span class="w"> </span>    def pull_dependencies(self, nodes: t.Iterable[nodes.Node]) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Find all filter and test names used in the template and
<span class="gu">@@ -228,26 +329,71 @@ class CodeGenerator(NodeVisitor):</span>
<span class="w"> </span>            Filters and tests in If and CondExpr nodes are checked at
<span class="w"> </span>            runtime instead of compile time.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        visitor = DependencyFinderVisitor()</span>
<span class="gi">+        for node in nodes:</span>
<span class="gi">+            visitor.visit(node)</span>
<span class="gi">+        for name in visitor.filters:</span>
<span class="gi">+            if name not in self.filters:</span>
<span class="gi">+                self.filters[name] = self.temporary_identifier()</span>
<span class="gi">+        for name in visitor.tests:</span>
<span class="gi">+            if name not in self.tests:</span>
<span class="gi">+                self.tests[name] = self.temporary_identifier()</span>

<span class="w"> </span>    def macro_body(self, node: t.Union[nodes.Macro, nodes.CallBlock], frame: Frame) -&gt; t.Tuple[Frame, MacroRef]:
<span class="w"> </span>        &quot;&quot;&quot;Dump the function def of a macro or call block.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        macro_ref = MacroRef(node)</span>
<span class="gi">+        body_frame = frame.inner()</span>
<span class="gi">+        body_frame.require_output_check = False</span>
<span class="gi">+        self.writeline(&#39;def macro(&#39;, node)</span>
<span class="gi">+        self.indent()</span>
<span class="gi">+        self.write(&#39;caller=None&#39;)</span>
<span class="gi">+        for arg in node.args:</span>
<span class="gi">+            self.write(&#39;, &#39; + arg.name)</span>
<span class="gi">+            if arg.default is not None:</span>
<span class="gi">+                self.write(&#39;=&#39;)</span>
<span class="gi">+                self.visit(arg.default, frame)</span>
<span class="gi">+        self.write(&#39;, kwargs=None&#39;)</span>
<span class="gi">+        self.write(&#39;):&#39;)</span>
<span class="gi">+        self.indent()</span>
<span class="gi">+        self.buffer(body_frame)</span>
<span class="gi">+        self.pull_dependencies([node])</span>
<span class="gi">+        self.blockvisit(node.body, body_frame)</span>
<span class="gi">+        self.return_buffer_contents(body_frame)</span>
<span class="gi">+        self.outdent(2)</span>
<span class="gi">+        return body_frame, macro_ref</span>

<span class="w"> </span>    def macro_def(self, macro_ref: MacroRef, frame: Frame) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Dump the macro definition for the def created by macro_body.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write(&#39;Macro(environment, macro, None, &#39;)</span>
<span class="gi">+        if macro_ref.accesses_kwargs:</span>
<span class="gi">+            self.write(&#39;True&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write(&#39;False&#39;)</span>
<span class="gi">+        if macro_ref.accesses_varargs:</span>
<span class="gi">+            self.write(&#39;, True&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write(&#39;, False&#39;)</span>
<span class="gi">+        if macro_ref.accesses_caller:</span>
<span class="gi">+            self.write(&#39;, True&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write(&#39;, False&#39;)</span>
<span class="gi">+        self.write(&#39;)&#39;)</span>

<span class="w"> </span>    def position(self, node: nodes.Node) -&gt; str:
<span class="w"> </span>        &quot;&quot;&quot;Return a human readable position for the node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = f&#39;line {node.lineno}&#39;</span>
<span class="gi">+        if self.name is not None:</span>
<span class="gi">+            rv = f&#39;{rv} in {self.name}&#39;</span>
<span class="gi">+        return rv</span>

<span class="w"> </span>    def write_commons(self) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Writes a common preamble that is used by root and block functions.
<span class="w"> </span>        Primarily this sets up common local helpers and enforces a generator
<span class="w"> </span>        through a dead branch.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.writeline(&#39;resolve = context.resolve_or_missing&#39;)</span>
<span class="gi">+        self.writeline(&#39;undefined = environment.undefined&#39;)</span>
<span class="gi">+        self.writeline(&#39;if 0: yield None&#39;)</span>

<span class="w"> </span>    def push_parameter_definitions(self, frame: Frame) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Pushes all parameter targets from the given frame into a local
<span class="gu">@@ -256,51 +402,115 @@ class CodeGenerator(NodeVisitor):</span>
<span class="w"> </span>        undefined expressions for parameters in macros as macros can reference
<span class="w"> </span>        otherwise unbound parameters.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._param_def_block.append(frame.symbols.stores)</span>

<span class="w"> </span>    def pop_parameter_definitions(self) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Pops the current parameter definitions set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._param_def_block.pop()</span>

<span class="w"> </span>    def mark_parameter_stored(self, target: str) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Marks a parameter in the current parameter definitions as stored.
<span class="w"> </span>        This will skip the enforced undefined checks.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._param_def_block:</span>
<span class="gi">+            self._param_def_block[-1].add(target)</span>

<span class="w"> </span>    def parameter_is_undeclared(self, target: str) -&gt; bool:
<span class="w"> </span>        &quot;&quot;&quot;Checks if a given target is an undeclared parameter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._param_def_block:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return target not in self._param_def_block[-1]</span>

<span class="w"> </span>    def push_assign_tracking(self) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Pushes a new layer for assignment tracking.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._assign_stack.append(set())</span>

<span class="w"> </span>    def pop_assign_tracking(self, frame: Frame) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Pops the topmost level for assignment tracking and updates the
<span class="w"> </span>        context variables if necessary.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assignments = self._assign_stack.pop()</span>
<span class="gi">+        if assignments:</span>
<span class="gi">+            self.writeline(f&#39;{frame.symbols.store_set(assignments)} = context.exported_vars.add_update({assignments!r})&#39;)</span>

<span class="w"> </span>    def visit_Block(self, node: nodes.Block, frame: Frame) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Call a block and register it for the template.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        block_frame = frame.inner()</span>
<span class="gi">+        block_frame.block = node.name</span>
<span class="gi">+        self.writeline(f&#39;def block_{node.name}(context, missing=missing):&#39;, node)</span>
<span class="gi">+        self.indent()</span>
<span class="gi">+        self.buffer(block_frame)</span>
<span class="gi">+        self.blockvisit(node.body, block_frame)</span>
<span class="gi">+        self.return_buffer_contents(block_frame)</span>
<span class="gi">+        self.outdent()</span>
<span class="gi">+        self.blocks[node.name] = node</span>
<span class="gi">+        self.writeline(f&#39;blocks[{node.name!r}] = block_{node.name}&#39;)</span>

<span class="w"> </span>    def visit_Extends(self, node: nodes.Extends, frame: Frame) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Calls the extender.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not frame.toplevel:</span>
<span class="gi">+            self.fail(&#39;cannot use extend from a non top-level scope&#39;, node.lineno)</span>
<span class="gi">+        if self.has_known_extends:</span>
<span class="gi">+            self.fail(&#39;cannot have multiple extends tags&#39;, node.lineno)</span>
<span class="gi">+        if not self.extends_so_far:</span>
<span class="gi">+            self.writeline(&#39;parent_template = None&#39;)</span>
<span class="gi">+        self.writeline(&#39;for parent in [&#39;, node)</span>
<span class="gi">+        self.visit(node.template, frame)</span>
<span class="gi">+        self.write(&#39;]:&#39;)</span>
<span class="gi">+        self.indent()</span>
<span class="gi">+        self.writeline(&#39;parent_template = parent&#39;)</span>
<span class="gi">+        self.writeline(&#39;break&#39;)</span>
<span class="gi">+        self.outdent()</span>
<span class="gi">+        self.has_known_extends = True</span>

<span class="w"> </span>    def visit_Include(self, node: nodes.Include, frame: Frame) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Handles includes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.ignore_missing:</span>
<span class="gi">+            self.writeline(&#39;try:&#39;)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+        self.writeline(&#39;for event in (&#39;, node)</span>
<span class="gi">+        if node.with_context:</span>
<span class="gi">+            self.write(&#39;context.blocks[&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write(&#39;environment.get_template(&#39;)</span>
<span class="gi">+        self.visit(node.template, frame)</span>
<span class="gi">+        if node.ignore_missing:</span>
<span class="gi">+            self.write(&#39;).root_render_func(context)&#39;)</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+            self.writeline(&#39;except TemplateNotFound:&#39;)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            self.writeline(&#39;pass&#39;)</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write(&#39;).root_render_func(context)&#39;)</span>
<span class="gi">+            self.write(&#39;):&#39;)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            self.writeline(&#39;yield event&#39;)</span>
<span class="gi">+            self.outdent()</span>

<span class="w"> </span>    def visit_Import(self, node: nodes.Import, frame: Frame) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Visit regular imports.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.writeline(f&#39;template = environment.get_template(&#39;, node)</span>
<span class="gi">+        self.visit(node.template, frame)</span>
<span class="gi">+        self.write(&#39;)&#39;)</span>
<span class="gi">+        self.writeline(f&#39;{frame.symbols.ref(node.target)} = environment.make_module(&#39;)</span>
<span class="gi">+        self.write(&#39;template.make_module(context.get_all()&#39; if node.with_context else &#39;template.make_module()&#39;)</span>
<span class="gi">+        self.write(&#39;)&#39;)</span>
<span class="gi">+        frame.symbols.store(node.target)</span>

<span class="w"> </span>    def visit_FromImport(self, node: nodes.FromImport, frame: Frame) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Visit named imports.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.writeline(&#39;template = environment.get_template(&#39;, node)</span>
<span class="gi">+        self.visit(node.template, frame)</span>
<span class="gi">+        self.write(&#39;)&#39;)</span>
<span class="gi">+        self.writeline(&#39;module = template.make_module(&#39; + (&#39;context.get_all()&#39; if node.with_context else &#39;&#39;) + &#39;)&#39;)</span>
<span class="gi">+        for name in node.names:</span>
<span class="gi">+            if isinstance(name, tuple):</span>
<span class="gi">+                name, alias = name</span>
<span class="gi">+            else:</span>
<span class="gi">+                alias = name</span>
<span class="gi">+            self.writeline(f&#39;{frame.symbols.ref(alias)} = getattr(module, {name!r}, missing)&#39;)</span>
<span class="gi">+            frame.symbols.store(alias)</span>

<span class="w"> </span>    class _FinalizeInfo(t.NamedTuple):
<span class="w"> </span>        const: t.Optional[t.Callable[..., str]]
<span class="gu">@@ -312,7 +522,7 @@ class CodeGenerator(NodeVisitor):</span>
<span class="w"> </span>        configured with one. Or, if the environment has one, this is
<span class="w"> </span>        called on that function&#39;s output for constants.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return value</span>
<span class="w"> </span>    _finalize: t.Optional[_FinalizeInfo] = None

<span class="w"> </span>    def _make_finalize(self) -&gt; _FinalizeInfo:
<span class="gu">@@ -328,14 +538,20 @@ class CodeGenerator(NodeVisitor):</span>
<span class="w"> </span>            Source code to output around nodes to be evaluated at
<span class="w"> </span>            runtime.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        finalize = self.environment.finalize</span>
<span class="gi">+        if finalize is None:</span>
<span class="gi">+            return self._FinalizeInfo(const=self._default_finalize, src=None)</span>
<span class="gi">+        </span>
<span class="gi">+        src = self.temporary_identifier()</span>
<span class="gi">+        self.writeline(f&#39;{src} = environment.finalize&#39;)</span>
<span class="gi">+        return self._FinalizeInfo(const=finalize, src=src)</span>

<span class="w"> </span>    def _output_const_repr(self, group: t.Iterable[t.Any]) -&gt; str:
<span class="w"> </span>        &quot;&quot;&quot;Given a group of constant values converted from ``Output``
<span class="w"> </span>        child nodes, produce a string to write to the template module
<span class="w"> </span>        source.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return repr(concat(group))</span>

<span class="w"> </span>    def _output_child_to_const(self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo) -&gt; str:
<span class="w"> </span>        &quot;&quot;&quot;Try to optimize a child of an ``Output`` node by trying to
<span class="gu">@@ -345,19 +561,24 @@ class CodeGenerator(NodeVisitor):</span>
<span class="w"> </span>        will be evaluated at runtime. Any other exception will also be
<span class="w"> </span>        evaluated at runtime for easier debugging.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        const = node.as_const(frame.eval_ctx)</span>
<span class="gi">+        if finalize.const is not None:</span>
<span class="gi">+            const = finalize.const(const)</span>
<span class="gi">+        return str(const)</span>

<span class="w"> </span>    def _output_child_pre(self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Output extra source code before visiting a child of an
<span class="w"> </span>        ``Output`` node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if finalize.src is not None:</span>
<span class="gi">+            self.write(f&#39;{finalize.src}(&#39;)</span>

<span class="w"> </span>    def _output_child_post(self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Output extra source code after visiting a child of an
<span class="w"> </span>        ``Output`` node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if finalize.src is not None:</span>
<span class="gi">+            self.write(&#39;)&#39;)</span>
<span class="w"> </span>    visit_Add = _make_binop(&#39;+&#39;)
<span class="w"> </span>    visit_Sub = _make_binop(&#39;-&#39;)
<span class="w"> </span>    visit_Mul = _make_binop(&#39;*&#39;)
<span class="gh">diff --git a/src/jinja2/idtracking.py b/src/jinja2/idtracking.py</span>
<span class="gh">index 8171019..3c2f3f3 100644</span>
<span class="gd">--- a/src/jinja2/idtracking.py</span>
<span class="gi">+++ b/src/jinja2/idtracking.py</span>
<span class="gu">@@ -20,6 +20,10 @@ class Symbols:</span>
<span class="w"> </span>        self.loads: t.Dict[str, t.Any] = {}
<span class="w"> </span>        self.stores: t.Set[str] = set()

<span class="gi">+def _simple_visit(self, node: nodes.Node, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+    for child in node.iter_child_nodes():</span>
<span class="gi">+        self.sym_visitor.visit(child, **kwargs)</span>
<span class="gi">+</span>
<span class="w"> </span>class RootVisitor(NodeVisitor):

<span class="w"> </span>    def __init__(self, symbols: &#39;Symbols&#39;) -&gt; None:
<span class="gu">@@ -40,30 +44,37 @@ class FrameSymbolVisitor(NodeVisitor):</span>

<span class="w"> </span>    def visit_Name(self, node: nodes.Name, store_as_param: bool=False, **kwargs: t.Any) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;All assignments to names go through this function.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.ctx == &#39;store&#39;:</span>
<span class="gi">+            self.symbols.stores.add(node.name)</span>
<span class="gi">+            if store_as_param:</span>
<span class="gi">+                self.symbols.loads[node.name] = VAR_LOAD_PARAMETER</span>
<span class="gi">+        elif node.ctx == &#39;param&#39;:</span>
<span class="gi">+            self.symbols.loads[node.name] = VAR_LOAD_PARAMETER</span>

<span class="w"> </span>    def visit_Assign(self, node: nodes.Assign, **kwargs: t.Any) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Visit assignments in the correct order.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.visit(node.node, **kwargs)</span>
<span class="gi">+        self.visit(node.target, store_as_param=True, **kwargs)</span>

<span class="w"> </span>    def visit_For(self, node: nodes.For, **kwargs: t.Any) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Visiting stops at for blocks.  However the block sequence
<span class="w"> </span>        is visited as part of the outer scope.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.visit(node.iter, **kwargs)</span>
<span class="gi">+        self.visit(node.target, store_as_param=True, **kwargs)</span>

<span class="w"> </span>    def visit_AssignBlock(self, node: nodes.AssignBlock, **kwargs: t.Any) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Stop visiting at block assigns.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.visit(node.target, store_as_param=True, **kwargs)</span>

<span class="w"> </span>    def visit_Scope(self, node: nodes.Scope, **kwargs: t.Any) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Stop visiting at scopes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return</span>

<span class="w"> </span>    def visit_Block(self, node: nodes.Block, **kwargs: t.Any) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Stop visiting at blocks.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return</span>

<span class="w"> </span>    def visit_OverlayScope(self, node: nodes.OverlayScope, **kwargs: t.Any) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Do not visit into overlay scopes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
\ No newline at end of file
<span class="gi">+        return</span>
\ No newline at end of file
<span class="gh">diff --git a/src/jinja2/nodes.py b/src/jinja2/nodes.py</span>
<span class="gh">index 42b3187..5a313dd 100644</span>
<span class="gd">--- a/src/jinja2/nodes.py</span>
<span class="gi">+++ b/src/jinja2/nodes.py</span>
<span class="gu">@@ -16,6 +16,9 @@ _binop_to_func: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {&#39;*&#39;: operator.</span>
<span class="w"> </span>_uaop_to_func: t.Dict[str, t.Callable[[t.Any], t.Any]] = {&#39;not&#39;: operator.not_, &#39;+&#39;: operator.pos, &#39;-&#39;: operator.neg}
<span class="w"> </span>_cmpop_to_func: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {&#39;eq&#39;: operator.eq, &#39;ne&#39;: operator.ne, &#39;gt&#39;: operator.gt, &#39;gteq&#39;: operator.ge, &#39;lt&#39;: operator.lt, &#39;lteq&#39;: operator.le, &#39;in&#39;: lambda a, b: a in b, &#39;notin&#39;: lambda a, b: a not in b}

<span class="gi">+def _failing_new(cls, *args, **kwargs):</span>
<span class="gi">+    raise TypeError(&#39;abstract %r cannot be instantiated&#39; % cls.__name__)</span>
<span class="gi">+</span>
<span class="w"> </span>class Impossible(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Raised if the node could not perform a requested action.&quot;&quot;&quot;

<span class="gu">@@ -77,7 +80,7 @@ class Node(metaclass=NodeType):</span>
<span class="w"> </span>            if len(fields) != len(self.fields):
<span class="w"> </span>                if not self.fields:
<span class="w"> </span>                    raise TypeError(f&#39;{type(self).__name__!r} takes 0 arguments&#39;)
<span class="gd">-                raise TypeError(f&#39;{type(self).__name__!r} takes 0 or {len(self.fields)} argument{(&#39;s&#39; if len(self.fields) != 1 else &#39;&#39;)}&#39;)</span>
<span class="gi">+                raise TypeError(f&#39;{type(self).__name__!r} takes 0 or {len(self.fields)} argument{&quot;s&quot; if len(self.fields) != 1 else &quot;&quot;}&#39;)</span>
<span class="w"> </span>            for name, arg in zip(self.fields, fields):
<span class="w"> </span>                setattr(self, name, arg)
<span class="w"> </span>        for attr in self.attributes:
<span class="gu">@@ -92,26 +95,46 @@ class Node(metaclass=NodeType):</span>
<span class="w"> </span>        parameter or to exclude some using the `exclude` parameter.  Both
<span class="w"> </span>        should be sets or tuples of field names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name in self.fields:</span>
<span class="gi">+            if (exclude is None or name not in exclude) and (only is None or name in only):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    yield name, getattr(self, name)</span>
<span class="gi">+                except AttributeError:</span>
<span class="gi">+                    pass</span>

<span class="w"> </span>    def iter_child_nodes(self, exclude: t.Optional[t.Container[str]]=None, only: t.Optional[t.Container[str]]=None) -&gt; t.Iterator[&#39;Node&#39;]:
<span class="w"> </span>        &quot;&quot;&quot;Iterates over all direct child nodes of the node.  This iterates
<span class="w"> </span>        over all fields and yields the values of they are nodes.  If the value
<span class="w"> </span>        of a field is a list all the nodes in that list are returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for field, item in self.iter_fields(exclude, only):</span>
<span class="gi">+            if isinstance(item, list):</span>
<span class="gi">+                for n in item:</span>
<span class="gi">+                    if isinstance(n, Node):</span>
<span class="gi">+                        yield n</span>
<span class="gi">+            elif isinstance(item, Node):</span>
<span class="gi">+                yield item</span>

<span class="w"> </span>    def find(self, node_type: t.Type[_NodeBound]) -&gt; t.Optional[_NodeBound]:
<span class="w"> </span>        &quot;&quot;&quot;Find the first node of a given type.  If no such node exists the
<span class="w"> </span>        return value is `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(self, node_type):</span>
<span class="gi">+            return self</span>
<span class="gi">+        for child in self.iter_child_nodes():</span>
<span class="gi">+            result = child.find(node_type)</span>
<span class="gi">+            if result is not None:</span>
<span class="gi">+                return result</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def find_all(self, node_type: t.Union[t.Type[_NodeBound], t.Tuple[t.Type[_NodeBound], ...]]) -&gt; t.Iterator[_NodeBound]:
<span class="w"> </span>        &quot;&quot;&quot;Find all the nodes of a given type.  If the type is a tuple,
<span class="w"> </span>        the check is performed for any of the tuple items.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(self, node_type):</span>
<span class="gi">+            yield self</span>
<span class="gi">+        for child in self.iter_child_nodes():</span>
<span class="gi">+            yield from child.find_all(node_type)</span>

<span class="w"> </span>    def set_ctx(self, ctx: str) -&gt; &#39;Node&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Reset the context of a node and all child nodes.  Per default the
<span class="gu">@@ -119,15 +142,26 @@ class Node(metaclass=NodeType):</span>
<span class="w"> </span>        most common one.  This method is used in the parser to set assignment
<span class="w"> </span>        targets and other nodes to a store context.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hasattr(self, &#39;ctx&#39;):</span>
<span class="gi">+            self.ctx = ctx</span>
<span class="gi">+        for child in self.iter_child_nodes():</span>
<span class="gi">+            child.set_ctx(ctx)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def set_lineno(self, lineno: int, override: bool=False) -&gt; &#39;Node&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Set the line numbers of the node and children.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not hasattr(self, &#39;lineno&#39;) or override:</span>
<span class="gi">+            self.lineno = lineno</span>
<span class="gi">+        for child in self.iter_child_nodes():</span>
<span class="gi">+            child.set_lineno(lineno, override)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def set_environment(self, environment: &#39;Environment&#39;) -&gt; &#39;Node&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Set the environment for all nodes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.environment = environment</span>
<span class="gi">+        for child in self.iter_child_nodes():</span>
<span class="gi">+            child.set_environment(environment)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def __eq__(self, other: t.Any) -&gt; bool:
<span class="w"> </span>        if type(self) is not type(other):
<span class="gu">@@ -303,11 +337,11 @@ class Expr(Node):</span>
<span class="w"> </span>        .. versionchanged:: 2.4
<span class="w"> </span>           the `eval_ctx` parameter was added.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise Impossible()</span>

<span class="w"> </span>    def can_assign(self) -&gt; bool:
<span class="w"> </span>        &quot;&quot;&quot;Check if it&#39;s possible to assign something to this node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>class BinExpr(Expr):
<span class="w"> </span>    &quot;&quot;&quot;Baseclass for all binary expressions.&quot;&quot;&quot;
<span class="gu">@@ -361,7 +395,31 @@ class Const(Literal):</span>
<span class="w"> </span>        constant value in the generated code, otherwise it will raise
<span class="w"> </span>        an `Impossible` exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(value, (bool, int, float, str, Markup)):</span>
<span class="gi">+            return cls(value, lineno=lineno, environment=environment)</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return cls(None, lineno=lineno, environment=environment)</span>
<span class="gi">+        if isinstance(value, (tuple, list)):</span>
<span class="gi">+            items = []</span>
<span class="gi">+            for item in value:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    items.append(cls.from_untrusted(item, lineno=lineno,</span>
<span class="gi">+                                                  environment=environment).value)</span>
<span class="gi">+                except Impossible:</span>
<span class="gi">+                    raise Impossible(f&#39;Constant {value!r} includes non-constant value&#39;)</span>
<span class="gi">+            if isinstance(value, tuple):</span>
<span class="gi">+                return cls(tuple(items), lineno=lineno, environment=environment)</span>
<span class="gi">+            return cls(items, lineno=lineno, environment=environment)</span>
<span class="gi">+        if isinstance(value, dict):</span>
<span class="gi">+            items = {}</span>
<span class="gi">+            for key, value in value.items():</span>
<span class="gi">+                try:</span>
<span class="gi">+                    items[str(key)] = cls.from_untrusted(value, lineno=lineno,</span>
<span class="gi">+                                                       environment=environment).value</span>
<span class="gi">+                except Impossible:</span>
<span class="gi">+                    raise Impossible(f&#39;Constant {value!r} includes non-constant value&#39;)</span>
<span class="gi">+            return cls(items, lineno=lineno, environment=environment)</span>
<span class="gi">+        raise Impossible(f&#39;Value of type {type(value).__name__} is not JSON serializable&#39;)</span>

<span class="w"> </span>class TemplateData(Literal):
<span class="w"> </span>    &quot;&quot;&quot;A constant template string.&quot;&quot;&quot;
<span class="gh">diff --git a/src/jinja2/runtime.py b/src/jinja2/runtime.py</span>
<span class="gh">index ae56b56..6b4e04f 100644</span>
<span class="gd">--- a/src/jinja2/runtime.py</span>
<span class="gi">+++ b/src/jinja2/runtime.py</span>
<span class="gu">@@ -1,5 +1,11 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The runtime functions and state used by compiled templates.&quot;&quot;&quot;
<span class="w"> </span>import functools
<span class="gi">+</span>
<span class="gi">+def _dict_method_all(method: t.Callable[..., t.Any]) -&gt; t.Callable[..., t.Any]:</span>
<span class="gi">+    &quot;&quot;&quot;Wrap a dict method to return all values from parent and child.&quot;&quot;&quot;</span>
<span class="gi">+    def wrapped(self: &#39;Context&#39;) -&gt; t.Any:</span>
<span class="gi">+        return chain(method(self.vars), method(self.parent))</span>
<span class="gi">+    return wrapped</span>
<span class="w"> </span>import sys
<span class="w"> </span>import typing as t
<span class="w"> </span>from collections import abc
<span class="gu">@@ -38,15 +44,15 @@ def identity(x: V) -&gt; V:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns its argument. Useful for certain things in the
<span class="w"> </span>    environment.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return x</span>

<span class="w"> </span>def markup_join(seq: t.Iterable[t.Any]) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Concatenation that escapes if necessary and converts to string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Markup(&#39;&#39;).join(seq)</span>

<span class="w"> </span>def str_join(seq: t.Iterable[t.Any]) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Simple args to string conversion and concatenation.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &#39;&#39;.join(map(str, seq))</span>

<span class="w"> </span>def new_context(environment: &#39;Environment&#39;, template_name: t.Optional[str], blocks: t.Dict[str, t.Callable[[&#39;Context&#39;], t.Iterator[str]]], vars: t.Optional[t.Dict[str, t.Any]]=None, shared: bool=False, globals: t.Optional[t.MutableMapping[str, t.Any]]=None, locals: t.Optional[t.Mapping[str, t.Any]]=None) -&gt; &#39;Context&#39;:
<span class="w"> </span>    &quot;&quot;&quot;Internal helper for context creation.&quot;&quot;&quot;
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>