
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis test save commit0 baseline jinja - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-base-baseline" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis test save commit0 baseline jinja
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytest" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytest:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytest:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_and" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_and
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_and_blocked" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_and_blocked
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_or" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_or
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_nested_and" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_nested_and
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_nested_or" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_nested_or
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_nested_cond_with_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_nested_cond_with_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_cond_with_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_cond_with_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_cond_with_nested_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_cond_with_nested_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_cond_with_uncaught_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_cond_with_uncaught_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_iand_with_and_cond" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_iand_with_and_cond
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_iand_with_or_cond" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_iand_with_or_cond
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_ior_with_or_cond" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_ior_with_or_cond
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_ior_with_and_cond" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_ior_with_and_cond
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_immutable_results" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_immutable_results
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_shared_and_condition" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_shared_and_condition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_shared_or_condition" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_shared_or_condition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_condition_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_condition_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_result_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_result_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_nested_result_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_nested_result_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_event_queue_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_event_queue_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_negative_until" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_negative_until
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_resume" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_resume
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_until_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_until_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_with_processed_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_with_processed_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_with_untriggered_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_with_untriggered_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_succeed" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_succeed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_fail" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_fail
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_unavailable_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_unavailable_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_triggered" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_triggered
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_condition_callback_removal" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_condition_callback_removal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_condition_nested_callback_removal" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_condition_nested_callback_removal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_error_forwarding" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_error_forwarding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_no_parent_process" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_no_parent_process
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_crashing_child_traceback" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_crashing_child_traceback
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_exception_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_exception_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_invalid_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_invalid_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_exception_handling" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_exception_handling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_callback_exception_handling" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_callback_exception_handling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_process_exception_handling" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_process_exception_handling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_process_exception_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_process_exception_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_sys_excepthook" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_sys_excepthook
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interruption" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interruption
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_concurrent_interrupts" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_concurrent_interrupts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_concurrent_interrupts_and_events" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_concurrent_interrupts_and_events
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_init_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_init_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interrupt_terminated_process" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interrupt_terminated_process
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_multiple_interrupts" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_multiple_interrupts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interrupt_self" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interrupt_self
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_immediate_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_immediate_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interrupt_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interrupt_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_concurrent_behaviour" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_concurrent_behaviour
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_get_state" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_get_state
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_target" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_target
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_wait_for_proc" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_wait_for_proc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_return_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_return_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_child_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_child_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_interrupted_join" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_interrupted_join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_interrupted_join_and_rejoin" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_interrupted_join_and_rejoin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_context_manager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_slots" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_slots
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_continue_after_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_continue_after_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_release_after_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_release_after_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_immediate_requests" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_immediate_requests
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_cm_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_cm_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_with_condition" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_with_condition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_with_priority_queue" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_with_priority_queue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_sorted_queue_maxlen" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_sorted_queue_maxlen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_get_users" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_get_users
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_preemptive_resource" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_preemptive_resource
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_preemptive_resource_timeout_0" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_preemptive_resource_timeout_0
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_mixed_preemption" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_mixed_preemption
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_nested_preemption" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_nested_preemption
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_container" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_container
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_container_get_queued" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_container_get_queued
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_store" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_store
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_store_capacity" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_store_capacity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_store_cancel" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_store_cancel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_priority_store_item_priority" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_priority_store_item_priority
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_priority_store_stable_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_priority_store_stable_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_store" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_store
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_store_get_after_mismatch" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_store_get_after_mismatch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_calls_best_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_calls_best_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_calls_worst_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_calls_worst_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_immediate_put_request" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_immediate_put_request
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_immediate_get_request" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_immediate_get_request
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt01" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt[0.1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt005" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt[0.05]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt015" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt[0.15]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_multiple_call" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_multiple_call
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_slow_sim_default_behavior" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_slow_sim_default_behavior
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_slow_sim_no_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_slow_sim_no_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_illegal_until" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_illegal_until
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_sync" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_sync
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_run_with_untriggered_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_run_with_untriggered_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_discrete_time_steps" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_discrete_time_steps
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_negative_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_negative_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_timeout_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_timeout_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_shared_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_shared_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_triggered_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_triggered_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_start_delayed" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_start_delayed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_terminated_proc" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_terminated_proc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_with_join" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_with_join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_at_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_at_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_at_timeout_with_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_at_timeout_with_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_generator" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_generator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_wait_for_all_with_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_wait_for_all_with_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_chaining_intermediate_results" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_chaining_intermediate_results
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_with_triggered_events" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_with_triggered_events
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of_with_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of_with_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of_with_triggered_events" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of_with_triggered_events
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_empty_any_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_empty_any_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_empty_all_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_empty_all_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_expansion" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_expansion
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests_1" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pytest-summary_1" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytest_1" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytest:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytest:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_corepytest_empty_string" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_empty_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_hello_jp" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_hello_jp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_wcswidth_substr" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_wcswidth_substr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_null_width_0" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_null_width_0
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_control_c0_width_negative_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_control_c0_width_negative_1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_combining_width" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_combining_width
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_combining_cafe" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_combining_cafe
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_combining_enclosing" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_combining_enclosing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_balinese_script" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_balinese_script
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_kr_jamo" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_kr_jamo
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_kr_jamo_filler" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_kr_jamo_filler
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_devanagari_script" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_devanagari_script
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_tamil_script" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_tamil_script
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_kannada_script" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_kannada_script
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_kannada_script_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_kannada_script_2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_zero_wide_conflict" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_zero_wide_conflict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_emojispytest_unfinished_zwj_sequence" class="md-nav__link">
    <span class="md-ellipsis">
      test_emojis.py::test_unfinished_zwj_sequence
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_emojispytest_non_recommended_zwj_sequence" class="md-nav__link">
    <span class="md-ellipsis">
      test_emojis.py::test_non_recommended_zwj_sequence
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_emojispytest_another_emoji_zwj_sequence" class="md-nav__link">
    <span class="md-ellipsis">
      test_emojis.py::test_another_emoji_zwj_sequence
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_emojispytest_longer_emoji_zwj_sequence" class="md-nav__link">
    <span class="md-ellipsis">
      test_emojis.py::test_longer_emoji_zwj_sequence
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_emojispytest_recommended_emoji_zwj_sequences" class="md-nav__link">
    <span class="md-ellipsis">
      test_emojis.py::test_recommended_emoji_zwj_sequences
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_emojispytest_recommended_variation_16_sequences" class="md-nav__link">
    <span class="md-ellipsis">
      test_emojis.py::test_recommended_variation_16_sequences
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_emojispytest_unicode_9_vs16" class="md-nav__link">
    <span class="md-ellipsis">
      test_emojis.py::test_unicode_9_vs16
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_emojispytest_unicode_8_vs16" class="md-nav__link">
    <span class="md-ellipsis">
      test_emojis.py::test_unicode_8_vs16
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_table_integritypytest_verify_table_integrity" class="md-nav__link">
    <span class="md-ellipsis">
      test_table_integrity.py::test_verify_table_integrity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ucslevelpytest_nearest_505_str" class="md-nav__link">
    <span class="md-ellipsis">
      test_ucslevel.py::test_nearest_505_str
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ucslevelpytest_nearest_505_unicode" class="md-nav__link">
    <span class="md-ellipsis">
      test_ucslevel.py::test_nearest_505_unicode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ucslevelpytest_nearest_800_str" class="md-nav__link">
    <span class="md-ellipsis">
      test_ucslevel.py::test_nearest_800_str
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ucslevelpytest_nearest_800_unicode" class="md-nav__link">
    <span class="md-ellipsis">
      test_ucslevel.py::test_nearest_800_unicode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ucslevelpytest_nearest_999_str" class="md-nav__link">
    <span class="md-ellipsis">
      test_ucslevel.py::test_nearest_999_str
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ucslevelpytest_nearest_999_unicode" class="md-nav__link">
    <span class="md-ellipsis">
      test_ucslevel.py::test_nearest_999_unicode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ucslevelpytest_nonint_unicode" class="md-nav__link">
    <span class="md-ellipsis">
      test_ucslevel.py::test_nonint_unicode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ucslevelpytest_nonint_str" class="md-nav__link">
    <span class="md-ellipsis">
      test_ucslevel.py::test_nonint_str
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests_2" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests_3" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests_4" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_test-save-commit0_baseline">back to Claude Sonnet 3.5 - Base summary</a></p>
<h1 id="claude-sonnet-35-base-baseline"><strong>Claude Sonnet 3.5 - Base</strong>: baseline</h1>
<h2 id="pytest-summary">Pytest Summary</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">120</td>
</tr>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">20</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">140</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">150</td>
</tr>
<tr>
<td style="text-align: left;">deselected</td>
<td style="text-align: center;">10</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytest">Failed pytest:</h2>
<h3 id="test_conditionpytest_operator_and">test_condition.py::test_operator_and</h3>
<details><summary> <pre>test_condition.py::test_operator_and</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30d900>

    def test_operator_and(env):
        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            results = yield timeout[0] & timeout[1] & timeout[2]

            assert results == {
                timeout[0]: 0,
                timeout[1]: 1,
                timeout[2]: 2,
            }

        env.process(process(env))
>       env.run()

tests/test_condition.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa30d900>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_operator_and_blocked">test_condition.py::test_operator_and_blocked</h3>
<details><summary> <pre>test_condition.py::test_operator_and_blocked</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa432a40>

    def test_operator_and_blocked(env):
        def process(env):
            timeout = env.timeout(1)
            event = env.event()
            yield env.timeout(1)

            condition = timeout & event
            assert not condition.triggered

        env.process(process(env))
>       env.run()

tests/test_condition.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa432a40>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_operator_or">test_condition.py::test_operator_or</h3>
<details><summary> <pre>test_condition.py::test_operator_or</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bb340>

    def test_operator_or(env):
        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            results = yield timeout[0] | timeout[1] | timeout[2]

            assert results == {
                timeout[0]: 0,
            }

        env.process(process(env))
>       env.run()

tests/test_condition.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bb340>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_operator_nested_and">test_condition.py::test_operator_nested_and</h3>
<details><summary> <pre>test_condition.py::test_operator_nested_and</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa6697e0>

    def test_operator_nested_and(env):
        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            results = yield (timeout[0] & timeout[2]) | timeout[1]

            assert results == {
                timeout[0]: 0,
                timeout[1]: 1,
            }
            assert env.now == 1

        env.process(process(env))
>       env.run()

tests/test_condition.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa6697e0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_operator_nested_or">test_condition.py::test_operator_nested_or</h3>
<details><summary> <pre>test_condition.py::test_operator_nested_or</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9913cd0>

    def test_operator_nested_or(env):
        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            results = yield (timeout[0] | timeout[1]) & timeout[2]

            assert results == {
                timeout[0]: 0,
                timeout[1]: 1,
                timeout[2]: 2,
            }
            assert env.now == 2

        env.process(process(env))
>       env.run()

tests/test_condition.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9913cd0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_nested_cond_with_error">test_condition.py::test_nested_cond_with_error</h3>
<details><summary> <pre>test_condition.py::test_nested_cond_with_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa345960>

    def test_nested_cond_with_error(env):
        def explode(env):
            yield env.timeout(1)
            raise ValueError('Onoes!')

        def process(env):
            with pytest.raises(ValueError, match='Onoes!'):
                yield env.process(explode(env)) & env.timeout(1)

        env.process(process(env))
>       env.run()

tests/test_condition.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa345960>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_cond_with_error">test_condition.py::test_cond_with_error</h3>
<details><summary> <pre>test_condition.py::test_cond_with_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9966800>

    def test_cond_with_error(env):
        def explode(env, delay):
            yield env.timeout(delay)
            raise ValueError(f'Onoes, failed after {delay}!')

        def process(env):
            with pytest.raises(ValueError, match='Onoes, failed after 0!'):
                yield env.process(explode(env, 0)) | env.timeout(1)

        env.process(process(env))
>       env.run()

tests/test_condition.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9966800>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_cond_with_nested_error">test_condition.py::test_cond_with_nested_error</h3>
<details><summary> <pre>test_condition.py::test_cond_with_nested_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa98ec20>

    def test_cond_with_nested_error(env):
        def explode(env, delay):
            yield env.timeout(delay)
            raise ValueError(f'Onoes, failed after {delay}!')

        def process(env):
            with pytest.raises(ValueError, match='Onoes, failed after 0!'):
                yield env.process(explode(env, 0)) & env.timeout(1) | env.timeout(1)

        env.process(process(env))
>       env.run()

tests/test_condition.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa98ec20>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_cond_with_uncaught_error">test_condition.py::test_cond_with_uncaught_error</h3>
<details><summary> <pre>test_condition.py::test_cond_with_uncaught_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa420a60>

    def test_cond_with_uncaught_error(env):
        """Errors that happen after the condition has been triggered will not be
        handled by the condition and cause the simulation to crash."""

        def explode(env, delay):
            yield env.timeout(delay)
            raise ValueError(f'Onoes, failed after {delay}!')

        def process(env):
            yield env.timeout(1) | env.process(explode(env, 2))

        env.process(process(env))
        with pytest.raises(ValueError, match='Onoes, failed after'):
>           env.run()

tests/test_condition.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa420a60>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_iand_with_and_cond">test_condition.py::test_iand_with_and_cond</h3>
<details><summary> <pre>test_condition.py::test_iand_with_and_cond</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9912dd0>

    def test_iand_with_and_cond(env):
        def process(env):
            cond = env.timeout(1, value=1) & env.timeout(2, value=2)
            orig = cond

            cond &= env.timeout(0, value=0)
            assert cond is not orig

            results = yield cond
            assert list(results.values()) == [1, 2, 0]

        env.process(process(env))
>       env.run()

tests/test_condition.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9912dd0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_iand_with_or_cond">test_condition.py::test_iand_with_or_cond</h3>
<details><summary> <pre>test_condition.py::test_iand_with_or_cond</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa6d1c60>

    def test_iand_with_or_cond(env):
        def process(env):
            cond = env.timeout(1, value=1) | env.timeout(2, value=2)
            orig = cond

            cond &= env.timeout(0, value=0)
            assert cond is not orig

            results = yield cond
            assert list(results.values()) == [1, 0]

        env.process(process(env))
>       env.run()

tests/test_condition.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa6d1c60>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_ior_with_or_cond">test_condition.py::test_ior_with_or_cond</h3>
<details><summary> <pre>test_condition.py::test_ior_with_or_cond</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa4307f0>

    def test_ior_with_or_cond(env):
        def process(env):
            cond = env.timeout(1, value=1) | env.timeout(2, value=2)
            orig = cond

            cond |= env.timeout(0, value=0)
            assert cond is not orig

            results = yield cond
            assert list(results.values()) == [0]

        env.process(process(env))
>       env.run()

tests/test_condition.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa4307f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_ior_with_and_cond">test_condition.py::test_ior_with_and_cond</h3>
<details><summary> <pre>test_condition.py::test_ior_with_and_cond</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30f1f0>

    def test_ior_with_and_cond(env):
        def process(env):
            cond = env.timeout(1, value=1) & env.timeout(2, value=2)
            orig = cond

            cond |= env.timeout(0, value=0)
            assert cond is not orig

            results = yield cond
            assert list(results.values()) == [0]

        env.process(process(env))
>       env.run()

tests/test_condition.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa30f1f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_immutable_results">test_condition.py::test_immutable_results</h3>
<details><summary> <pre>test_condition.py::test_immutable_results</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa4214b0>

    def test_immutable_results(env):
        """Results of conditions should not change after they have been
        triggered."""

        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            # The or condition in this expression will trigger immediately. The and
            # condition will trigger later on.
            condition = timeout[0] | (timeout[1] & timeout[2])

            results = yield condition
            assert results == {timeout[0]: 0}

            # Make sure that the results of condition were frozen. The results of
            # the nested and condition do not become visible afterwards.
            yield env.timeout(2)
            assert results == {timeout[0]: 0}

        env.process(process(env))
>       env.run()

tests/test_condition.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa4214b0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_shared_and_condition">test_condition.py::test_shared_and_condition</h3>
<details><summary> <pre>test_condition.py::test_shared_and_condition</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa66b640>

    def test_shared_and_condition(env):
        timeout = [env.timeout(delay, value=delay) for delay in range(3)]
        c1 = timeout[0] & timeout[1]
        c2 = c1 & timeout[2]

        def p1(_, condition):
            results = yield condition
            assert results == {timeout[0]: 0, timeout[1]: 1}

        def p2(_, condition):
            results = yield condition
            assert results == {timeout[0]: 0, timeout[1]: 1, timeout[2]: 2}

        env.process(p1(env, c1))
        env.process(p2(env, c2))
>       env.run()

tests/test_condition.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa66b640>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_shared_or_condition">test_condition.py::test_shared_or_condition</h3>
<details><summary> <pre>test_condition.py::test_shared_or_condition</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30cc70>

    def test_shared_or_condition(env):
        timeout = [env.timeout(delay, value=delay) for delay in range(3)]
        c1 = timeout[0] | timeout[1]
        c2 = c1 | timeout[2]

        def p1(_, condition):
            results = yield condition
            assert results == {timeout[0]: 0}

        def p2(_, condition):
            results = yield condition
            assert results == {timeout[0]: 0}

        env.process(p1(env, c1))
        env.process(p2(env, c2))
>       env.run()

tests/test_condition.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa30cc70>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_condition_value">test_condition.py::test_condition_value</h3>
<details><summary> <pre>test_condition.py::test_condition_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa431510>

    def test_condition_value(env):
        """The value of a condition behaves like a readonly dictionary."""
        timeouts = [env.timeout(delay, value=delay) for delay in range(3)]

        def p(env, timeouts):
            results = yield env.all_of(timeouts)
            assert list(results) == timeouts
            assert list(results.keys()) == timeouts
            assert list(results.values()) == [0, 1, 2]
            assert list(results.items()) == list(zip(timeouts, [0, 1, 2]))
            assert timeouts[0] in results
            assert results[timeouts[0]] == 0
            assert results == results  # noqa: PLR0124
            assert results == results.todict()

        env.process(p(env, timeouts))
>       env.run()

tests/test_condition.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa431510>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_result_order">test_condition.py::test_result_order</h3>
<details><summary> <pre>test_condition.py::test_result_order</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30d750>

    def test_result_order(env):
        """The order of a conditions result is based on the order in which the
        events have been specified."""
        timeouts = list(reversed([env.timeout(delay) for delay in range(3)]))

        def p(env, timeouts):
            results = yield env.all_of(timeouts)
            assert list(results.keys()) == timeouts

        env.process(p(env, timeouts))
>       env.run()

tests/test_condition.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa30d750>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_nested_result_order">test_condition.py::test_nested_result_order</h3>
<details><summary> <pre>test_condition.py::test_nested_result_order</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04d030>

    def test_nested_result_order(env):
        """The order of a conditions result is based on the order in which the
        events have been specified (even if nested)."""
        timeouts = [env.timeout(delay) for delay in range(3)]
        condition = (timeouts[0] | timeouts[1]) & timeouts[2]

        def p(_, timeouts):
            results = yield condition
            assert list(results.keys()) == timeouts

        env.process(p(env, timeouts))
>       env.run()

tests/test_condition.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04d030>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_environmentpytest_event_queue_empty">test_environment.py::test_event_queue_empty</h3>
<details><summary> <pre>test_environment.py::test_event_queue_empty</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bbaf0>, log = []

    def test_event_queue_empty(env, log):
        """The simulation should stop if there are no more events, that means, no
        more active process."""

        def pem(env, log):
            while env.now < 2:
                log.append(env.now)
                yield env.timeout(1)

        env.process(pem(env, log))
>       env.run(10)

tests/test_environment.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bbaf0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_environmentpytest_run_negative_until">test_environment.py::test_run_negative_until</h3>
<details><summary> <pre>test_environment.py::test_run_negative_until</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a940e650>

    def test_run_negative_until(env):
        """Test passing a negative time to run."""
>       with pytest.raises(
            ValueError, match='must be greater than the current simulation time'
        ):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/test_environment.py:26: Failed
</pre>
</details>
<h3 id="test_environmentpytest_run_resume">test_environment.py::test_run_resume</h3>
<details><summary> <pre>test_environment.py::test_run_resume</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa98e080>

    def test_run_resume(env):
        """Stopped simulation can be resumed."""
        events = [env.timeout(t) for t in (5, 10, 15)]

        assert env.now == 0
        assert not any(event.processed for event in events)

>       env.run(until=10)

tests/test_environment.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa98e080>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Timeout' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_environmentpytest_run_until_value">test_environment.py::test_run_until_value</h3>
<details><summary> <pre>test_environment.py::test_run_until_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3f0460>

    def test_run_until_value(env):
        """Anything that can be converted to a float is a valid until value."""
>       env.run(until='3.141592')

tests/test_environment.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3f0460>, until = '3.141592'

    def run(self, until: Optional[Union[SimTime, Event]]=None) ->Optional[Any]:
        """Executes :meth:`step()` until the given criterion *until* is met.

        - If it is ``None`` (which is the default), this method will return
          when there are no further events to be processed.

        - If it is an :class:`~simpy.events.Event`, the method will continue
          stepping until this event has been triggered and will return its
          value.  Raises a :exc:`RuntimeError` if there are no further events
          to be processed and the *until* event was not triggered.

        - If it is a number, the method will continue stepping
          until the environment's time reaches *until*.

        """
        if until is None:
            while True:
                try:
                    self.step()
                except EmptySchedule:
                    return None
        elif isinstance(until, Event):
            until.callbacks.append(StopSimulation.callback)
            try:
                while not until.triggered:
                    self.step()
            except StopSimulation:
                return until.value
            except EmptySchedule:
                if not until.triggered:
                    raise RuntimeError('No scheduled events left but "until" event was not triggered')
        elif isinstance(until, (int, float)):
            try:
                while self._now < until:
                    self.step()
            except EmptySchedule:
                return None
        else:
>           raise ValueError('Invalid until parameter type')
E           ValueError: Invalid until parameter type

src/simpy/core.py:196: ValueError
</pre>
</details>
<h3 id="test_environmentpytest_run_with_processed_event">test_environment.py::test_run_with_processed_event</h3>
<details><summary> <pre>test_environment.py::test_run_with_processed_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9987430>

    def test_run_with_processed_event(env):
        """An already processed event may also be passed as until value."""
        timeout = env.timeout(1, value='spam')
>       assert env.run(until=timeout) == 'spam'
E       AssertionError: assert None == 'spam'
E        +  where None = run(until=<Timeout(1, value='spam') object at 0x7f67a9984d90>)
E        +    where run = <simpy.core.Environment object at 0x7f67a9987430>.run

tests/test_environment.py:63: AssertionError
</pre>
</details>
<h3 id="test_environmentpytest_run_with_untriggered_event">test_environment.py::test_run_with_untriggered_event</h3>
<details><summary> <pre>test_environment.py::test_run_with_untriggered_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30d420>

    def test_run_with_untriggered_event(env):
        excinfo = pytest.raises(RuntimeError, env.run, until=env.event())
>       assert str(excinfo.value).startswith(
            'No scheduled events left but "until" event was not triggered:'
        )
E       assert False
E        +  where False = <built-in method startswith of str object at 0x7f67a99d3d70>('No scheduled events left but "until" event was not triggered:')
E        +    where <built-in method startswith of str object at 0x7f67a99d3d70> = 'No scheduled events left but "until" event was not triggered'.startswith
E        +      where 'No scheduled events left but "until" event was not triggered' = str(RuntimeError('No scheduled events left but "until" event was not triggered'))
E        +        where RuntimeError('No scheduled events left but "until" event was not triggered') = <ExceptionInfo RuntimeError('No scheduled events left but "until" event was not triggered') tblen=2>.value

tests/test_environment.py:75: AssertionError
</pre>
</details>
<h3 id="test_eventpytest_succeed">test_event.py::test_succeed</h3>
<details><summary> <pre>test_event.py::test_succeed</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9985720>

    def test_succeed(env):
        """Test for the Environment.event() helper function."""

        def child(env, event):
            value = yield event
            assert value == 'ohai'
            assert env.now == 5

        def parent(env):
            event = env.event()
            env.process(child(env, event))
            yield env.timeout(5)
            event.succeed('ohai')

        env.process(parent(env))
>       env.run()

tests/test_event.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9985720>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_fail">test_event.py::test_fail</h3>
<details><summary> <pre>test_event.py::test_fail</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99b8cd0>

    def test_fail(env):
        """Test for the Environment.event() helper function."""

        def child(env, event):
            with pytest.raises(ValueError, match='ohai'):
                yield event
            assert env.now == 5

        def parent(env):
            event = env.event()
            env.process(child(env, event))
            yield env.timeout(5)
            event.fail(ValueError('ohai'))

        env.process(parent(env))
>       env.run()

tests/test_event.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99b8cd0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_value">test_event.py::test_value</h3>
<details><summary> <pre>test_event.py::test_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3f2830>

    def test_value(env):
        """After an event has been triggered, its value becomes accessible."""
        event = env.timeout(0, 'I am the value')

>       env.run()

tests/test_event.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3f2830>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Timeout' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_unavailable_value">test_event.py::test_unavailable_value</h3>
<details><summary> <pre>test_event.py::test_unavailable_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9987f40>

    def test_unavailable_value(env):
        """If an event has not yet been triggered, its value is not available and
        trying to access it will result in a AttributeError."""
        event = env.event()

        with pytest.raises(AttributeError, match='.* is not yet available$'):
>           _ = event.value

tests/test_event.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Event() object at 0x7f67a9984d90>

    @property
    def value(self) ->Optional[Any]:
        """The value of the event if it is available.

        The value is available when the event has been triggered.

        Raises :exc:`AttributeError` if the value is not yet available.

        """
        if self._value is PENDING:
>           raise AttributeError('Value not yet available')
E           AttributeError: Value not yet available. Did you mean: '_value'?

src/simpy/events.py:132: AttributeError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7f67a9987f40>

    def test_unavailable_value(env):
        """If an event has not yet been triggered, its value is not available and
        trying to access it will result in a AttributeError."""
        event = env.event()

>       with pytest.raises(AttributeError, match='.* is not yet available$'):
E       AssertionError: Regex pattern did not match.
E        Regex: '.* is not yet available$'
E        Input: 'Value not yet available'

tests/test_event.py:82: AssertionError
</pre>
</details>
<h3 id="test_eventpytest_triggered">test_event.py::test_triggered</h3>
<details><summary> <pre>test_event.py::test_triggered</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04ec50>

    def test_triggered(env):
        def pem(env, event):
            value = yield event
            return value

        event = env.event()
        event.succeed('i was already done')

>       result = env.run(env.process(pem(env, event)))

tests/test_event.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04ec50>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_condition_callback_removal">test_event.py::test_condition_callback_removal</h3>
<details><summary> <pre>test_event.py::test_condition_callback_removal</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa667430>

    def test_condition_callback_removal(env):
        """A condition will remove all outstanding callbacks from its events."""
        a, b = env.event(), env.event()
        a.succeed()
>       env.run(until=a | b)

tests/test_event.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa667430>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_condition_nested_callback_removal">test_event.py::test_condition_nested_callback_removal</h3>
<details><summary> <pre>test_event.py::test_condition_nested_callback_removal</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99874c0>

    def test_condition_nested_callback_removal(env):
        """A condition will remove all outstanding callbacks from its events (even
        if nested)."""
        a, b, c = env.event(), env.event(), env.event()
        b_and_c = b & c
        a_or_b_and_c = a | b_and_c
        a.succeed()
>       env.run(until=a_or_b_and_c)

tests/test_event.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99874c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_error_forwarding">test_exceptions.py::test_error_forwarding</h3>
<details><summary> <pre>test_exceptions.py::test_error_forwarding</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04c9d0>

    def test_error_forwarding(env):
        """Exceptions are forwarded from child to parent processes if there
        are any.

        """

        def child(env):
            raise ValueError('Onoes!')
            yield env.timeout(1)

        def parent(env):
            with pytest.raises(ValueError, match='Onoes!'):
                yield env.process(child(env))

        env.process(parent(env))
>       env.run()

tests/test_exceptions.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04c9d0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_no_parent_process">test_exceptions.py::test_no_parent_process</h3>
<details><summary> <pre>test_exceptions.py::test_no_parent_process</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa98cca0>

    def test_no_parent_process(env):
        """Exceptions should be normally raised if there are no processes waiting
        for the one that raises something.

        """

        def child(env):
            raise ValueError('Onoes!')
            yield env.timeout(1)

        def parent(env):
            try:
                env.process(child(env))
                yield env.timeout(1)
            except Exception as err:
                pytest.fail(f'There should be no error ({err}).')

        env.process(parent(env))
        with pytest.raises(ValueError, match='Onoes!'):
>           env.run()

tests/test_exceptions.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa98cca0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_crashing_child_traceback">test_exceptions.py::test_crashing_child_traceback</h3>
<details><summary> <pre>test_exceptions.py::test_crashing_child_traceback</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9ff13f0>

    def test_crashing_child_traceback(env):
        def panic(env):
            yield env.timeout(1)
            raise RuntimeError('Oh noes, roflcopter incoming... BOOM!')

        def root(env):
            try:
                yield env.process(panic(env))
                pytest.fail("Hey, where's the roflcopter?")
            except RuntimeError:
                # The current frame must be visible in the stacktrace.
                stacktrace = traceback.format_exc()
                assert 'yield env.process(panic(env))' in stacktrace
                assert "raise RuntimeError('Oh noes," in stacktrace

        env.process(root(env))
>       env.run()

tests/test_exceptions.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9ff13f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_exception_chaining">test_exceptions.py::test_exception_chaining</h3>
<details><summary> <pre>test_exceptions.py::test_exception_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04c640>

    def test_exception_chaining(env):
        """Unhandled exceptions pass through the entire event stack. This must be
        visible in the stacktrace of the exception.

        """

        def child(env):
            yield env.timeout(1)
            raise RuntimeError('foo')

        def parent(env):
            child_proc = env.process(child(env))
            yield child_proc

        def grandparent(env):
            parent_proc = env.process(parent(env))
            yield parent_proc

        env.process(grandparent(env))
        try:
>           env.run()

tests/test_exceptions.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04c640>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_invalid_event">test_exceptions.py::test_invalid_event</h3>
<details><summary> <pre>test_exceptions.py::test_invalid_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a940d8a0>

    def test_invalid_event(env):
        """Invalid yield values will cause the simulation to fail."""

        def root(_):
            yield None

        env.process(root(env))
        with pytest.raises(RuntimeError, match='Invalid yield value "None"'):
>           env.run()

tests/test_exceptions.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a940d8a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_exception_handling">test_exceptions.py::test_exception_handling</h3>
<details><summary> <pre>test_exceptions.py::test_exception_handling</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94d5240>

    def test_exception_handling(env):
        """If failed events are not defused (which is the default) the simulation
        crashes."""

        event = env.event()
        event.fail(RuntimeError())
        with pytest.raises(RuntimeError):
>           env.run(until=1)

tests/test_exceptions.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94d5240>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_callback_exception_handling">test_exceptions.py::test_callback_exception_handling</h3>
<details><summary> <pre>test_exceptions.py::test_callback_exception_handling</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa98d540>

    def test_callback_exception_handling(env):
        """Callbacks of events may handle exception by setting the ``defused``
        attribute of ``event`` to ``True``."""

        def callback(event):
            event.defused = True

        event = env.event()
        event.callbacks.append(callback)
        event.fail(RuntimeError())
        assert not event.defused, 'Event has been defused immediately'
>       env.run(until=1)

tests/test_exceptions.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa98d540>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_process_exception_handling">test_exceptions.py::test_process_exception_handling</h3>
<details><summary> <pre>test_exceptions.py::test_process_exception_handling</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9912ef0>

    def test_process_exception_handling(env):
        """Processes can't ignore failed events and auto-handle exceptions."""

        def pem(_, event):
            try:
                yield event
                pytest.fail('Hey, the event should fail!')
            except RuntimeError:
                pass

        event = env.event()
        env.process(pem(env, event))
        event.fail(RuntimeError())

        assert not event.defused, 'Event has been defused immediately'
>       env.run(until=1)

tests/test_exceptions.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9912ef0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_process_exception_chaining">test_exceptions.py::test_process_exception_chaining</h3>
<details><summary> <pre>test_exceptions.py::test_process_exception_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94d5c60>

    def test_process_exception_chaining(env):
        """Because multiple processes can be waiting for an event, exceptions of
        failed events are copied before being thrown into a process. Otherwise, the
        traceback of the exception gets modified by a process.

        See https://bitbucket.org/simpy/simpy/issue/60 for more details."""
        import traceback

        def process_a(event):
            try:
                yield event
            except RuntimeError:
                stacktrace = traceback.format_exc()
                assert 'process_b' not in stacktrace

        def process_b(event):
            try:
                yield event
            except RuntimeError:
                stacktrace = traceback.format_exc()
                assert 'process_a' not in stacktrace

        event = env.event()
        event.fail(RuntimeError('foo'))

        env.process(process_a(event))
        env.process(process_b(event))

>       env.run()

tests/test_exceptions.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94d5c60>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_sys_excepthook">test_exceptions.py::test_sys_excepthook</h3>
<details><summary> <pre>test_exceptions.py::test_sys_excepthook</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bab90>

    def test_sys_excepthook(env):
        """Check that the default exception hook reports exception chains."""

        def process_a(event):
            yield event

        def process_b(event):
            yield event

        event = env.event()
        event.fail(RuntimeError('foo'))

        env.process(process_b(env.process(process_a(event))))

        try:
>           env.run()

tests/test_exceptions.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bab90>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7f67a99bab90>

    def test_sys_excepthook(env):
        """Check that the default exception hook reports exception chains."""

        def process_a(event):
            yield event

        def process_b(event):
            yield event

        event = env.event()
        event.fail(RuntimeError('foo'))

        env.process(process_b(env.process(process_a(event))))

        try:
            env.run()
        except BaseException:
            # Let the default exception hook print the traceback to the redirected
            # standard error channel.
            import sys
            from io import StringIO

            stderr, sys.stderr = sys.stderr, StringIO()

            typ, e, tb = sys.exc_info()
            assert typ is not None
            assert e is not None
            sys.excepthook(typ, e, tb)

            traceback = sys.stderr.getvalue()

            sys.stderr = stderr

            # Check if frames of process_a and process_b are visible in the
            # traceback.
>           assert 'process_a' in traceback
E           assert 'process_a' in 'Traceback (most recent call last):\n  File "/testbed/tests/test_exceptions.py", line 244, in test_sys_excepthook\n   ..._callback(event)\nAttributeError: \'Initialize\' object has no attribute \'_callback\'. Did you mean: \'callbacks\'?\n'

tests/test_exceptions.py:264: AssertionError
</pre>
</details>
<h3 id="test_interruptspytest_interruption">test_interrupts.py::test_interruption</h3>
<details><summary> <pre>test_interrupts.py::test_interruption</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9ff13f0>

    def test_interruption(env):
        """Processes can be interrupted while waiting for other events."""

        def interruptee(env):
            with pytest.raises(simpy.Interrupt, match='interrupt!'):
                yield env.timeout(10)

        def interruptor(env):
            child_process = env.process(interruptee(env))
            yield env.timeout(5)
            child_process.interrupt('interrupt!')

        env.process(interruptor(env))
>       env.run()

tests/test_interrupts.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9ff13f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_concurrent_interrupts">test_interrupts.py::test_concurrent_interrupts</h3>
<details><summary> <pre>test_interrupts.py::test_concurrent_interrupts</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa6d13c0>, log = []

    def test_concurrent_interrupts(env, log):
        """Concurrent interrupts are scheduled in the order in which they
        occurred.

        """

        def fox(env, log):
            while True:
                try:
                    yield env.timeout(10)
                except simpy.Interrupt as interrupt:
                    log.append((env.now, interrupt.cause))

        def farmer(env, name, fox):
            fox.interrupt(name)
            yield env.timeout(1)

        fantastic_mr_fox = env.process(fox(env, log))
        for name in ('boggis', 'bunce', 'beans'):
            env.process(farmer(env, name, fantastic_mr_fox))

>       env.run(20)

tests/test_interrupts.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa6d13c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_concurrent_interrupts_and_events">test_interrupts.py::test_concurrent_interrupts_and_events</h3>
<details><summary> <pre>test_interrupts.py::test_concurrent_interrupts_and_events</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bb400>, log = []

    def test_concurrent_interrupts_and_events(env, log):
        """Interrupts interrupt a process while waiting for an event. Even if the
        event has happened concurrently with the interrupt."""

        def fox(env, coup, log):
            while True:
                try:
                    yield coup
                    log.append(f'coup completed at {env.now}')
                except simpy.Interrupt:
                    log.append(f'coup interrupted at {env.now}')
                else:
                    return

        def master_plan(env, fox, coup):
            yield env.timeout(1)
            # Succeed and interrupt concurrently.
            coup.succeed()
            fox.interrupt()

        coup = env.event()
        fantastic_mr_fox = env.process(fox(env, coup, log))
        env.process(master_plan(env, fantastic_mr_fox, coup))

>       env.run(5)

tests/test_interrupts.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bb400>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_init_interrupt">test_interrupts.py::test_init_interrupt</h3>
<details><summary> <pre>test_interrupts.py::test_init_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3f1e40>

    def test_init_interrupt(env):
        """An interrupt should always be executed after the Initialize event at the
        same time."""

        def child(env):
            try:
                yield env.timeout(10)
                pytest.fail('Should have been interrupted.')
            except simpy.Interrupt:
                assert env.now == 0

        def root(env):
            child_proc = env.process(child(env))
            child_proc.interrupt()

            yield env.timeout(1)

        env.process(root(env))
>       env.run()

tests/test_interrupts.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3f1e40>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_interrupt_terminated_process">test_interrupts.py::test_interrupt_terminated_process</h3>
<details><summary> <pre>test_interrupts.py::test_interrupt_terminated_process</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94d5ae0>

    def test_interrupt_terminated_process(env):
        """Dead processes cannot be interrupted."""

        def child(env):
            yield env.timeout(1)

        def parent(env):
            child_proc = env.process(child(env))

            # Wait long enough so that child_proc terminates.
            yield env.timeout(2)
            ei = pytest.raises(RuntimeError, child_proc.interrupt)
            assert re.match(
                r'<Process\(child\) object at 0x.*> has terminated '
                r'and cannot be interrupted.',
                ei.value.args[0],
            )

            yield env.timeout(1)

        env.process(parent(env))
>       env.run()

tests/test_interrupts.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94d5ae0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_multiple_interrupts">test_interrupts.py::test_multiple_interrupts</h3>
<details><summary> <pre>test_interrupts.py::test_multiple_interrupts</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa109bd0>

    def test_multiple_interrupts(env):
        """Interrupts on dead processes are discarded. If there are multiple
        concurrent interrupts on a process and the latter dies after
        handling the first interrupt, the remaining ones are silently
        ignored.

        """

        def child(env):
            try:
                yield env.timeout(1)
            except simpy.Interrupt as i:
                return i.cause

        def parent(env):
            c = env.process(child(env))
            yield env.timeout(0)
            c.interrupt(1)
            c.interrupt(2)
            result = yield c
            assert result == 1

        env.process(parent(env))
>       env.run()

tests/test_interrupts.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa109bd0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_interrupt_self">test_interrupts.py::test_interrupt_self</h3>
<details><summary> <pre>test_interrupts.py::test_interrupt_self</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa66bee0>

    def test_interrupt_self(env):
        """A process should not be able to interrupt itself."""

        def pem(env):
            pytest.raises(RuntimeError, env.active_process.interrupt)
            yield env.timeout(0)

        env.process(pem(env))
>       env.run()

tests/test_interrupts.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa66bee0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_immediate_interrupt">test_interrupts.py::test_immediate_interrupt</h3>
<details><summary> <pre>test_interrupts.py::test_immediate_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa4223b0>, log = []

    def test_immediate_interrupt(env, log):
        """Processes are immediately interruptable."""

        def child(env, log):
            try:
                yield env.event()
            except simpy.Interrupt:
                log.append(env.now)

        def parent(env, log):
            child_proc = env.process(child(env, log))
            child_proc.interrupt()
            return
            yield

        env.process(parent(env, log))
>       env.run()

tests/test_interrupts.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa4223b0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_interrupt_event">test_interrupts.py::test_interrupt_event</h3>
<details><summary> <pre>test_interrupts.py::test_interrupt_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a940cac0>

    def test_interrupt_event(env):
        """A process should be interruptable while waiting for an Event."""

        def child(env):
            try:
                yield env.event()
            except simpy.Interrupt:
                assert env.now == 5

        def parent(env):
            child_proc = env.process(child(env))
            yield env.timeout(5)
            child_proc.interrupt()

        env.process(parent(env))
>       env.run()

tests/test_interrupts.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a940cac0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_concurrent_behaviour">test_interrupts.py::test_concurrent_behaviour</h3>
<details><summary> <pre>test_interrupts.py::test_concurrent_behaviour</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa108280>

    def test_concurrent_behaviour(env):
        def proc_a(env):
            timeouts = [env.timeout(0) for i in range(2)]
            while timeouts:
                with pytest.raises(simpy.Interrupt):
                    yield timeouts.pop(0)

        def proc_b(_, proc_a):
            for _ in range(2):
                proc_a.interrupt()
            return
            yield

        proc_a = env.process(proc_a(env))
        env.process(proc_b(env, proc_a))

>       env.run()

tests/test_interrupts.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa108280>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_get_state">test_process.py::test_get_state</h3>
<details><summary> <pre>test_process.py::test_get_state</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa423430>

    def test_get_state(env):
        """A process is alive until it's generator has not terminated."""

        def pem_a(env):
            yield env.timeout(3)

        def pem_b(env, pem_a):
            yield env.timeout(1)
            assert pem_a.is_alive

            yield env.timeout(3)
            assert not pem_a.is_alive

        proc_a = env.process(pem_a(env))
        env.process(pem_b(env, proc_a))
>       env.run()

tests/test_process.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa423430>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_target">test_process.py::test_target</h3>
<details><summary> <pre>test_process.py::test_target</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3459c0>

    def test_target(env):
        def pem(env, event):
            yield event

        event = env.timeout(5)
        proc = env.process(pem(env, event))

        # Wait until "proc" is initialized and yielded the event
        while env.peek() < 5:
>           env.step()

tests/test_process.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3459c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_wait_for_proc">test_process.py::test_wait_for_proc</h3>
<details><summary> <pre>test_process.py::test_wait_for_proc</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa9803a0>

    def test_wait_for_proc(env):
        """A process can wait until another process finishes."""

        def finisher(env):
            yield env.timeout(5)

        def waiter(env, finisher):
            proc = env.process(finisher(env))
            yield proc  # Waits until "proc" finishes

            assert env.now == 5

        env.process(waiter(env, finisher))
>       env.run()

tests/test_process.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa9803a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_return_value">test_process.py::test_return_value</h3>
<details><summary> <pre>test_process.py::test_return_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa0ed0f0>

    def test_return_value(env):
        """Processes can set a return value."""

        def child(env):
            yield env.timeout(1)
            return env.now

        def parent(env):
            result1 = yield env.process(child(env))
            result2 = yield env.process(child(env))

            assert [result1, result2] == [1, 2]

        env.process(parent(env))
>       env.run()

tests/test_process.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa0ed0f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_child_exception">test_process.py::test_child_exception</h3>
<details><summary> <pre>test_process.py::test_child_exception</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94d5690>

    def test_child_exception(env):
        """A child catches an exception and sends it to its parent."""

        def child(env):
            yield env.timeout(1)
            return RuntimeError('Onoes!')

        def parent(env):
            result = yield env.process(child(env))
            assert isinstance(result, Exception)

        env.process(parent(env))
>       env.run()

tests/test_process.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94d5690>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_interrupted_join">test_process.py::test_interrupted_join</h3>
<details><summary> <pre>test_process.py::test_interrupted_join</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94e95a0>

    def test_interrupted_join(env):
        """Interrupts remove a process from the callbacks of its target."""

        def interruptor(env, process):
            yield env.timeout(1)
            process.interrupt()

        def child(env):
            yield env.timeout(2)

        def parent(env):
            child_proc = env.process(child(env))
            try:
                yield child_proc
                pytest.fail('Did not receive an interrupt.')
            except Interrupt:
                assert env.now == 1
                assert child_proc.is_alive

                # We should not get resumed when child terminates.
                yield env.timeout(5)
                assert env.now == 6

        parent_proc = env.process(parent(env))
        env.process(interruptor(env, parent_proc))
>       env.run()

tests/test_process.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94e95a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_interrupted_join_and_rejoin">test_process.py::test_interrupted_join_and_rejoin</h3>
<details><summary> <pre>test_process.py::test_interrupted_join_and_rejoin</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3f06a0>

    def test_interrupted_join_and_rejoin(env):
        """Tests that interrupts are raised while the victim is waiting for
        another process. The victim tries to join again.

        """

        def interruptor(env, process):
            yield env.timeout(1)
            process.interrupt()

        def child(env):
            yield env.timeout(2)

        def parent(env):
            child_proc = env.process(child(env))
            try:
                yield child_proc
                pytest.fail('Did not receive an interrupt.')
            except Interrupt:
                assert env.now == 1
                assert child_proc.is_alive

                yield child_proc
                assert env.now == 2

        parent_proc = env.process(parent(env))
        env.process(interruptor(env, parent_proc))
>       env.run()

tests/test_process.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3f06a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource">test_resources.py::test_resource</h3>
<details><summary> <pre>test_resources.py::test_resource</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa664df0>, log = []

    def test_resource(env, log):
        """A *resource* is something with a limited numer of slots that need
        to be requested before and released after the usage (e.g., gas pumps
        at a gas station).

        """

        def pem(env, name, resource, log):
            req = resource.request()
            yield req
            assert resource.count == 1

            yield env.timeout(1)
            resource.release(req)

            log.append((name, env.now))

        resource = simpy.Resource(env, capacity=1)
        assert resource.capacity == 1
        assert resource.count == 0
        env.process(pem(env, 'a', resource, log))
        env.process(pem(env, 'b', resource, log))
>       env.run()

tests/test_resources.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa664df0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_context_manager">test_resources.py::test_resource_context_manager</h3>
<details><summary> <pre>test_resources.py::test_resource_context_manager</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a940e500>, log = []

    def test_resource_context_manager(env, log):
        """The event that ``Resource.request()`` returns can be used as
        Context Manager."""

        def pem(env, name, resource, log):
            with resource.request() as request:
                yield request
                yield env.timeout(1)

            log.append((name, env.now))

        resource = simpy.Resource(env, capacity=1)
        env.process(pem(env, 'a', resource, log))
        env.process(pem(env, 'b', resource, log))
>       env.run()

tests/test_resources.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a940e500>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_slots">test_resources.py::test_resource_slots</h3>
<details><summary> <pre>test_resources.py::test_resource_slots</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa665f30>, log = []

    def test_resource_slots(env, log):
        def pem(env, name, resource, log):
            with resource.request() as req:
                yield req
                log.append((name, env.now))
                yield env.timeout(1)

        resource = simpy.Resource(env, capacity=3)
        for i in range(9):
            env.process(pem(env, str(i), resource, log))
>       env.run()

tests/test_resources.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa665f30>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_continue_after_interrupt">test_resources.py::test_resource_continue_after_interrupt</h3>
<details><summary> <pre>test_resources.py::test_resource_continue_after_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94eb8b0>

    def test_resource_continue_after_interrupt(env):
        """A process may be interrupted while waiting for a resource but
        should be able to continue waiting afterwards."""

        def pem(env, res):
            with res.request() as req:
                yield req
                yield env.timeout(1)

        def victim(env, res):
            evt = res.request()
            try:
                yield evt
                pytest.fail('Should not have gotten the resource.')
            except simpy.Interrupt:
                yield evt
                res.release(evt)
                assert env.now == 1

        def interruptor(proc):
            proc.interrupt()
            return 0
            yield

        res = simpy.Resource(env, 1)
        env.process(pem(env, res))
        proc = env.process(victim(env, res))
        env.process(interruptor(proc))
>       env.run()

tests/test_resources.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94eb8b0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_release_after_interrupt">test_resources.py::test_resource_release_after_interrupt</h3>
<details><summary> <pre>test_resources.py::test_resource_release_after_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa667850>

    def test_resource_release_after_interrupt(env):
        """A process needs to release a resource, even if it was interrupted
        and does not continue to wait for it."""

        def blocker(env, res):
            with res.request() as req:
                yield req
                yield env.timeout(1)

        def victim(env, res):
            evt = res.request()
            try:
                yield evt
                pytest.fail('Should not have gotten the resource.')
            except simpy.Interrupt:
                # Don't wait for the resource
                res.release(evt)
                assert env.now == 0

        def interruptor(proc):
            proc.interrupt()
            return 0
            yield

        res = simpy.Resource(env, 1)
        env.process(blocker(env, res))
        victim_proc = env.process(victim(env, res))
        env.process(interruptor(victim_proc))
>       env.run()

tests/test_resources.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa667850>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_immediate_requests">test_resources.py::test_resource_immediate_requests</h3>
<details><summary> <pre>test_resources.py::test_resource_immediate_requests</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a945e3b0>

    def test_resource_immediate_requests(env):
        """A process must not acquire a resource if it releases it and immediately
        requests it again while there are already other requesting processes."""

        def child(env, res):
            result = []
            for _ in range(3):
                with res.request() as req:
                    yield req
                    result.append(env.now)
                    yield env.timeout(1)
            return result

        def parent(env):
            res = simpy.Resource(env, 1)
            child_a = env.process(child(env, res))
            child_b = env.process(child(env, res))

            a_acquire_times = yield child_a
            b_acquire_times = yield child_b

            assert a_acquire_times == [0, 2, 4]
            assert b_acquire_times == [1, 3, 5]

        env.process(parent(env))
>       env.run()

tests/test_resources.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a945e3b0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_cm_exception">test_resources.py::test_resource_cm_exception</h3>
<details><summary> <pre>test_resources.py::test_resource_cm_exception</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa345a20>, log = []

    def test_resource_cm_exception(env, log):
        """Resource with context manager receives an exception."""

        def process(env, resource, log, raise_):
            with resource.request() as req:
                yield req
                yield env.timeout(1)
                log.append(env.now)
                if raise_:
                    with pytest.raises(ValueError, match='Foo'):
                        raise ValueError('Foo')

        resource = simpy.Resource(env, 1)
        env.process(process(env, resource, log, True))
        # The second process is used to check if it was able to access the
        # resource:
        env.process(process(env, resource, log, False))
>       env.run()

tests/test_resources.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa345a20>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_with_condition">test_resources.py::test_resource_with_condition</h3>
<details><summary> <pre>test_resources.py::test_resource_with_condition</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a945dc60>

    def test_resource_with_condition(env):
        def process(env, resource):
            with resource.request() as res_event:
                result = yield res_event | env.timeout(1)
                assert res_event in result

        resource = simpy.Resource(env, 1)
        env.process(process(env, resource))
>       env.run()

tests/test_resources.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a945dc60>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_with_priority_queue">test_resources.py::test_resource_with_priority_queue</h3>
<details><summary> <pre>test_resources.py::test_resource_with_priority_queue</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa6d0460>

    def test_resource_with_priority_queue(env):
        def process(env, delay, resource, priority, res_time):
            yield env.timeout(delay)
            req = resource.request(priority=priority)
            yield req
            assert env.now == res_time
            yield env.timeout(5)
            resource.release(req)

        resource = simpy.PriorityResource(env, capacity=1)
        env.process(process(env, 0, resource, 2, 0))
        env.process(process(env, 2, resource, 3, 10))
        env.process(process(env, 2, resource, 3, 15))  # Test equal priority
        env.process(process(env, 4, resource, 1, 5))
>       env.run()

tests/test_resources.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa6d0460>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_sorted_queue_maxlen">test_resources.py::test_sorted_queue_maxlen</h3>
<details><summary> <pre>test_resources.py::test_sorted_queue_maxlen</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a945c100>

    def test_sorted_queue_maxlen(env):
        """Requests must fail if more than *maxlen* requests happen
        concurrently."""
        resource = simpy.PriorityResource(env, capacity=1)
        resource.put_queue.maxlen = 1  # pyright: ignore

        def process(env, resource):
            # The first request immediately triggered and does not enter the queue.
            resource.request(priority=1)
            # The second request is enqueued.
            resource.request(priority=1)
            with pytest.raises(RuntimeError, match='Cannot append event. Queue is full.'):
                # The third request will now fail.
                resource.request(priority=1)
            yield env.timeout(0)

        env.process(process(env, resource))
>       env.run()

tests/test_resources.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a945c100>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_get_users">test_resources.py::test_get_users</h3>
<details><summary> <pre>test_resources.py::test_get_users</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa666d10>

    def test_get_users(env):
        def process(env, resource):
            with resource.request() as req:
                yield req
                yield env.timeout(1)

        resource = simpy.Resource(env, 1)
        procs = [env.process(process(env, resource)) for _ in range(3)]
>       env.run(until=1)

tests/test_resources.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa666d10>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_preemptive_resource">test_resources.py::test_preemptive_resource</h3>
<details><summary> <pre>test_resources.py::test_preemptive_resource</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa430400>

    def test_preemptive_resource(env):
        """Processes with a higher priority may preempt requests of lower priority
        processes. Note that higher priorities are indicated by a lower number
        value."""

        def proc_a(_, resource, prio):
            try:
                with resource.request(priority=prio) as req:
                    yield req
                    pytest.fail('Should have received an interrupt/preemption.')
            except simpy.Interrupt:
                pass

        def proc_b(_, resource, prio):
            with resource.request(priority=prio) as req:
                yield req

        resource = simpy.PreemptiveResource(env, 1)
        env.process(proc_a(env, resource, 1))
        env.process(proc_b(env, resource, 0))

>       env.run()

tests/test_resources.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa430400>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_preemptive_resource_timeout_0">test_resources.py::test_preemptive_resource_timeout_0</h3>
<details><summary> <pre>test_resources.py::test_preemptive_resource_timeout_0</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30ddb0>

    def test_preemptive_resource_timeout_0(env):
        def proc_a(env, resource, prio):
            with resource.request(priority=prio) as req:
                try:
                    yield req
                    yield env.timeout(1)
                    pytest.fail('Should have received an interrupt/preemption.')
                except simpy.Interrupt:
                    pass
            yield env.event()

        def proc_b(_, resource, prio):
            with resource.request(priority=prio) as req:
                yield req

        resource = simpy.PreemptiveResource(env, 1)
        env.process(proc_a(env, resource, 1))
        env.process(proc_b(env, resource, 0))

>       env.run()

tests/test_resources.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa30ddb0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_mixed_preemption">test_resources.py::test_mixed_preemption</h3>
<details><summary> <pre>test_resources.py::test_mixed_preemption</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a945f460>, log = []

    def test_mixed_preemption(env, log):
        def p(id, env, res, delay, prio, preempt, log):
            yield env.timeout(delay)
            with res.request(priority=prio, preempt=preempt) as req:
                try:
                    yield req
                    yield env.timeout(2)
                    log.append((env.now, id))
                except simpy.Interrupt as ir:
                    assert ir is not None  # noqa: PT017
                    assert isinstance(ir.cause, Preempted)  # noqa: PT017
                    log.append((env.now, id, (ir.cause.by, ir.cause.usage_since)))

        res = simpy.PreemptiveResource(env, 1)
        # p0: First user:
        env.process(p(0, env, res, delay=0, prio=2, preempt=True, log=log))
        # p1: Waits (cannot preempt):
        env.process(p(1, env, res, delay=0, prio=2, preempt=True, log=log))
        # p2: Waits later, but has a higher prio:
        env.process(p(2, env, res, delay=1, prio=1, preempt=False, log=log))
        # p3: Preempt the above proc:
        p3 = env.process(p(3, env, res, delay=3, prio=0, preempt=True, log=log))
        # p4: Wait again:
        env.process(p(4, env, res, delay=4, prio=3, preempt=True, log=log))

>       env.run()

tests/test_resources.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a945f460>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_nested_preemption">test_resources.py::test_nested_preemption</h3>
<details><summary> <pre>test_resources.py::test_nested_preemption</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa10aec0>, log = []

    def test_nested_preemption(env, log):
        def process(id, env, res, delay, prio, preempt, log):
            yield env.timeout(delay)
            with res.request(priority=prio, preempt=preempt) as req:
                try:
                    yield req
                    yield env.timeout(5)
                    log.append((env.now, id))
                except simpy.Interrupt as ir:
                    assert isinstance(ir.cause, Preempted)  # noqa: PT017
                    log.append((env.now, id, (ir.cause.by, ir.cause.usage_since)))

        def process2(id, env, res0, res1, delay, prio, preempt, log):
            yield env.timeout(delay)
            with res0.request(priority=prio, preempt=preempt) as req0:
                try:
                    yield req0
                    with res1.request(priority=prio, preempt=preempt) as req1:
                        try:
                            yield req1
                            yield env.timeout(5)
                            log.append((env.now, id))
                        except simpy.Interrupt as ir:
                            assert isinstance(ir.cause, Preempted)  # noqa: PT017
                            log.append(
                                (
                                    env.now,
                                    id,
                                    (ir.cause.by, ir.cause.usage_since, ir.cause.resource),
                                )
                            )
                except simpy.Interrupt as ir:
                    assert isinstance(ir.cause, Preempted)  # noqa: PT017
                    log.append(
                        (
                            env.now,
                            id,
                            (ir.cause.by, ir.cause.usage_since, ir.cause.resource),
                        )
                    )

        res0 = simpy.PreemptiveResource(env, 1)
        res1 = simpy.PreemptiveResource(env, 1)

        env.process(process2(0, env, res0, res1, 0, -1, True, log))
        p1 = env.process(process(1, env, res1, 1, -2, True, log))

        env.process(process2(2, env, res0, res1, 20, -1, True, log))
        p3 = env.process(process(3, env, res0, 21, -2, True, log))

        env.process(process2(4, env, res0, res1, 21, -1, True, log))

>       env.run()

tests/test_resources.py:406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa10aec0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_container">test_resources.py::test_container</h3>
<details><summary> <pre>test_resources.py::test_container</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9178d30>, log = []

    def test_container(env, log):
        """A *container* is a resource (of optionally limited capacity) where
        you can put in our take-out a discrete or continuous amount of
        things (e.g., a box of lump sugar or a can of milk).  The *put* and
        *get* operations block if the buffer is to full or to empty. If they
        return, the process knows that the *put* or *get* operation was
        successful.

        """

        def putter(env, buf, log):
            yield env.timeout(1)
            while True:
                yield buf.put(2)
                log.append(('p', env.now))
                yield env.timeout(1)

        def getter(env, buf, log):
            yield buf.get(1)
            log.append(('g', env.now))

            yield env.timeout(1)
            yield buf.get(1)
            log.append(('g', env.now))

        buf = simpy.Container(env, init=0, capacity=2)
        env.process(putter(env, buf, log))
        env.process(getter(env, buf, log))
>       env.run(until=5)

tests/test_resources.py:450: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9178d30>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_container_get_queued">test_resources.py::test_container_get_queued</h3>
<details><summary> <pre>test_resources.py::test_container_get_queued</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04cf40>

    def test_container_get_queued(env):
        def proc(env, wait, container, what):
            yield env.timeout(wait)
            with getattr(container, what)(1) as req:
                yield req

        container = simpy.Container(env, 1)
        p0 = env.process(proc(env, 0, container, 'get'))
        env.process(proc(env, 1, container, 'put'))
        env.process(proc(env, 1, container, 'put'))
        p3 = env.process(proc(env, 1, container, 'put'))

>       env.run(until=1)

tests/test_resources.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04cf40>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_store">test_resources.py::test_store</h3>
<details><summary> <pre>test_resources.py::test_store</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa430400>

    def test_store(env):
        """A store models the production and consumption of concrete python
        objects (in contrast to containers, where you only now if the *put*
        or *get* operations were successful but don't get concrete
        objects).

        """

        def putter(_, store, item):
            yield store.put(item)

        def getter(_, store, orig_item):
            item = yield store.get()
            assert item is orig_item

        store = simpy.Store(env, capacity=2)
        item = object()

        # NOTE: Does the start order matter? Need to test this.
        env.process(putter(env, store, item))
        env.process(getter(env, store, item))
>       env.run()

tests/test_resources.py:535: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa430400>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_store_capacity">test_resources.py::test_store_capacity</h3>
<details><summary> <pre>test_resources.py::test_store_capacity</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04d8d0>

    def test_store_capacity(env):
        with pytest.raises(ValueError, match='"capacity" must be > 0'):
            simpy.Store(env, 0)
        with pytest.raises(ValueError, match='"capacity" must be > 0'):
            simpy.Store(env, -1)

        capacity = 2
        store = simpy.Store(env, capacity)
        env.process(store.put(i) for i in range(capacity + 1))
>       env.run()

tests/test_resources.py:559: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04d8d0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_store_cancel">test_resources.py::test_store_cancel</h3>
<details><summary> <pre>test_resources.py::test_store_cancel</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a940c520>

    def test_store_cancel(env):
        store = simpy.Store(env, capacity=1)

        def acquire_implicit_cancel():
            with store.get():
                yield env.timeout(1)
                # implicit cancel() when exiting with-block

        env.process(acquire_implicit_cancel())
>       env.run()

tests/test_resources.py:574: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a940c520>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_priority_store_item_priority">test_resources.py::test_priority_store_item_priority</h3>
<details><summary> <pre>test_resources.py::test_priority_store_item_priority</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa980070>

    def test_priority_store_item_priority(env):
        pstore = simpy.PriorityStore(env, 3)
        log = []

        def getter(wait):
            yield env.timeout(wait)
            item = yield pstore.get()
            log.append(item)

        # Do not specify priority; the items themselves will be compared to
        # determine priority.
        env.process(pstore.put(s) for s in 'bcadefg')
        env.process(getter(1))
        env.process(getter(2))
        env.process(getter(3))
>       env.run()

tests/test_resources.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa980070>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_priority_store_stable_order">test_resources.py::test_priority_store_stable_order</h3>
<details><summary> <pre>test_resources.py::test_priority_store_stable_order</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bbee0>

    def test_priority_store_stable_order(env):
        pstore = simpy.PriorityStore(env, 3)
        log = []

        def getter(wait):
            yield env.timeout(wait)
            _, item = yield pstore.get()
            log.append(item)

        items = [object() for _ in range(3)]

        # Unorderable items are inserted with same priority.
        env.process(pstore.put(simpy.PriorityItem(0, item)) for item in items)
        env.process(getter(1))
        env.process(getter(2))
        env.process(getter(3))
>       env.run()

tests/test_resources.py:612: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bbee0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_filter_store">test_resources.py::test_filter_store</h3>
<details><summary> <pre>test_resources.py::test_filter_store</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91950c0>

    def test_filter_store(env):
        def pem(env):
            store = simpy.FilterStore(env, capacity=2)

            get_event = store.get(lambda item: item == 'b')
            yield store.put('a')
            assert not get_event.triggered
            yield store.put('b')
            assert get_event.triggered

        env.process(pem(env))
>       env.run()

tests/test_resources.py:630: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91950c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_filter_store_get_after_mismatch">test_resources.py::test_filter_store_get_after_mismatch</h3>
<details><summary> <pre>test_resources.py::test_filter_store_get_after_mismatch</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94d4910>

    def test_filter_store_get_after_mismatch(env):
        """Regression test for issue #49.

        Triggering get-events after a put in FilterStore wrongly breaks after the
        first mismatch.

        """

        def putter(env, store):
            # The order of putting 'spam' before 'eggs' is important here.
            yield store.put('spam')
            yield env.timeout(1)
            yield store.put('eggs')

        def getter(store):
            # The order of requesting 'eggs' before 'spam' is important here.
            eggs = store.get(lambda i: i == 'eggs')
            spam = store.get(lambda i: i == 'spam')

            ret = yield spam | eggs
            assert spam in ret
            assert eggs not in ret
            assert env.now == 0

            yield eggs
            assert env.now == 1

        store = simpy.FilterStore(env, capacity=2)
        env.process(getter(store))
        env.process(putter(env, store))
>       env.run()

tests/test_resources.py:663: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94d4910>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_filter_calls_best_case">test_resources.py::test_filter_calls_best_case</h3>
<details><summary> <pre>test_resources.py::test_filter_calls_best_case</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa980790>

    def test_filter_calls_best_case(env):
        """The filter function is called every item in the store until a match is
        found. In the best case the first item already matches."""
        log = []

        def log_filter(item):
            log.append(f'check {item}')
            return True

        store = simpy.FilterStore(env)
        store.items = [1, 2, 3]

        def getter(store):
            log.append(f'get {yield store.get(log_filter)}')
            log.append(f'get {yield store.get(log_filter)}')
            log.append(f'get {yield store.get(log_filter)}')

        env.process(getter(store))
>       env.run()

tests/test_resources.py:684: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa980790>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_filter_calls_worst_case">test_resources.py::test_filter_calls_worst_case</h3>
<details><summary> <pre>test_resources.py::test_filter_calls_worst_case</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3f1600>

    def test_filter_calls_worst_case(env):
        """In the worst case the filter function is being called for items multiple
        times."""

        log = []
        store = simpy.FilterStore(env)

        def putter(store):
            for i in range(4):
                log.append(f'put {i}')
                yield store.put(i)

        def log_filter(item):
            log.append(f'check {item}')
            return item >= 3

        def getter(store):
            log.append(f'get {yield store.get(log_filter)}')

        env.process(getter(store))
        env.process(putter(store))
>       env.run()

tests/test_resources.py:710: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3f1600>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_immediate_put_request">test_resources.py::test_immediate_put_request</h3>
<details><summary> <pre>test_resources.py::test_immediate_put_request</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa2d4b80>

    def test_immediate_put_request(env):
        """Put requests that can be fulfilled immediately do not enter the put
        queue."""
        resource = simpy.Resource(env, capacity=1)
        assert len(resource.users) == 0
        assert len(resource.queue) == 0

        # The resource is empty, the first request will succeed immediately without
        # entering the queue.
>       request = resource.request()

tests/test_resources.py:733: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/resources/resource.py:74: in __init__
    super().__init__(resource)
src/simpy/resources/base.py:39: in __init__
    resource._trigger_put(None)
src/simpy/resources/base.py:199: in _trigger_put
    if not self._do_put(put_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.resource.Resource object at 0x7f67aa2d5420>
event = <Event() object at 0x7f67aa2d55d0>

    def _do_put(self, event: PutType) ->Optional[bool]:
        """Perform the *put* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the put *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_put` for every event in the
        :attr:`put_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("The _do_put() method has to be implemented by subclasses.")
E       NotImplementedError: The _do_put() method has to be implemented by subclasses.

src/simpy/resources/base.py:186: NotImplementedError
</pre>
</details>
<h3 id="test_resourcespytest_immediate_get_request">test_resources.py::test_immediate_get_request</h3>
<details><summary> <pre>test_resources.py::test_immediate_get_request</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9910af0>

    def test_immediate_get_request(env):
        """Get requests that can be fulfilled immediately do not enter the get
        queue."""
        container = simpy.Container(env)
        # Put something in the container, this request is triggered immediately
        # without entering the queue.
>       request = container.put(1)

tests/test_resources.py:751: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/resources/container.py:30: in __init__
    super().__init__(container)
src/simpy/resources/base.py:39: in __init__
    resource._trigger_put(None)
src/simpy/resources/base.py:199: in _trigger_put
    if not self._do_put(put_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.container.Container object at 0x7f67a9912bc0>
event = <Event() object at 0x7f67a9913700>

    def _do_put(self, event: PutType) ->Optional[bool]:
        """Perform the *put* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the put *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_put` for every event in the
        :attr:`put_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("The _do_put() method has to be implemented by subclasses.")
E       NotImplementedError: The _do_put() method has to be implemented by subclasses.

src/simpy/resources/base.py:186: NotImplementedError
</pre>
</details>
<h3 id="test_rtpytest_rt01">test_rt.py::test_rt[0.1]</h3>
<details><summary> <pre>test_rt.py::test_rt[0.1]</pre></summary><pre>
log = [], factor = 0.1

    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])
    def test_rt(log, factor):
        """Basic tests for run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=factor)
        env.process(process(env, log, 0.01, 1))
        env.process(process(env, log, 0.02, 1))

>       env.run(2)

tests/test_rt.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a9444250>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_rt005">test_rt.py::test_rt[0.05]</h3>
<details><summary> <pre>test_rt.py::test_rt[0.05]</pre></summary><pre>
log = [], factor = 0.05

    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])
    def test_rt(log, factor):
        """Basic tests for run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=factor)
        env.process(process(env, log, 0.01, 1))
        env.process(process(env, log, 0.02, 1))

>       env.run(2)

tests/test_rt.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a9197580>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_rt015">test_rt.py::test_rt[0.15]</h3>
<details><summary> <pre>test_rt.py::test_rt[0.15]</pre></summary><pre>
log = [], factor = 0.15

    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])
    def test_rt(log, factor):
        """Basic tests for run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=factor)
        env.process(process(env, log, 0.01, 1))
        env.process(process(env, log, 0.02, 1))

>       env.run(2)

tests/test_rt.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a99b8190>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_rt_multiple_call">test_rt.py::test_rt_multiple_call</h3>
<details><summary> <pre>test_rt.py::test_rt_multiple_call</pre></summary><pre>
log = []

    def test_rt_multiple_call(log):
        """Test multiple calls to run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=0.05)

        env.process(process(env, log, 0.01, 2))
        env.process(process(env, log, 0.01, 3))

>       env.run(5)

tests/test_rt.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67aa2d7d00>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_rt_slow_sim_default_behavior">test_rt.py::test_rt_slow_sim_default_behavior</h3>
<details><summary> <pre>test_rt.py::test_rt_slow_sim_default_behavior</pre></summary><pre>
log = []

    def test_rt_slow_sim_default_behavior(log):
        """By default, SimPy should raise an error if a simulation is too
        slow for the selected real-time factor."""
        env = RealtimeEnvironment(factor=0.05)
        env.process(process(env, log, 0.1, 1))

        err = pytest.raises(RuntimeError, env.run, 3)
>       assert 'Simulation too slow for real time' in str(err.value)
E       AssertionError: assert 'Simulation too slow for real time' in 'Simulation too slow: 0.000 seconds late'
E        +  where 'Simulation too slow: 0.000 seconds late' = str(RuntimeError('Simulation too slow: 0.000 seconds late'))
E        +    where RuntimeError('Simulation too slow: 0.000 seconds late') = <ExceptionInfo RuntimeError('Simulation too slow: 0.000 seconds late') tblen=3>.value

tests/test_rt.py:68: AssertionError
</pre>
</details>
<h3 id="test_rtpytest_rt_slow_sim_no_error">test_rt.py::test_rt_slow_sim_no_error</h3>
<details><summary> <pre>test_rt.py::test_rt_slow_sim_no_error</pre></summary><pre>
log = []

    def test_rt_slow_sim_no_error(log):
        """Test ignoring slow simulations."""
        start = monotonic()
        env = RealtimeEnvironment(factor=0.05, strict=False)
        env.process(process(env, log, 0.1, 1))

>       env.run(2)

tests/test_rt.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
src/simpy/rt.py:76: in step
    super().step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a94796c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_rtpytest_rt_illegal_until">test_rt.py::test_rt_illegal_until</h3>
<details><summary> <pre>test_rt.py::test_rt_illegal_until</pre></summary><pre>
def test_rt_illegal_until():
        """Test illegal value for *until*."""
        env = RealtimeEnvironment()
>       with pytest.raises(
            ValueError,
            match=r'until \(-1\) must be greater than the current simulation time',
        ):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/test_rt.py:88: Failed
</pre>
</details>
<h3 id="test_rtpytest_rt_sync">test_rt.py::test_rt_sync</h3>
<details><summary> <pre>test_rt.py::test_rt_sync</pre></summary><pre>
log = []

    def test_rt_sync(log):
        """Test resetting the internal wall-clock reference time."""
        env = RealtimeEnvironment(factor=0.05)
        env.process(process(env, log, 0.01))
        sleep(0.06)  # Simulate massive workload :-)
        env.sync()
>       env.run(3)

tests/test_rt.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a9444b80>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_run_with_untriggered_event">test_rt.py::test_run_with_untriggered_event</h3>
<details><summary> <pre>test_rt.py::test_run_with_untriggered_event</pre></summary><pre>
env = <simpy.rt.RealtimeEnvironment object at 0x7f67a9483640>

    def test_run_with_untriggered_event(env):
        env = RealtimeEnvironment(factor=0.05)
>       excinfo = pytest.raises(RuntimeError, env.run, until=env.event())

tests/test_rt.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a9483640>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
>           sleep(expected_real_time - real_time)
E           OverflowError: timestamp too large to convert to C _PyTime_t

src/simpy/rt.py:72: OverflowError
</pre>
</details>
<h3 id="test_timeoutpytest_discrete_time_steps">test_timeout.py::test_discrete_time_steps</h3>
<details><summary> <pre>test_timeout.py::test_discrete_time_steps</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bbfa0>, log = []

    def test_discrete_time_steps(env, log):
        """envple envulation with discrete time steps."""

        def pem(env, log):
            while True:
                log.append(env.now)
                yield env.timeout(delay=1)

        env.process(pem(env, log))
>       env.run(until=3)

tests/test_timeout.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bbfa0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_timeoutpytest_negative_timeout">test_timeout.py::test_negative_timeout</h3>
<details><summary> <pre>test_timeout.py::test_negative_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91767a0>

    def test_negative_timeout(env):
        """Don't allow negative timeout times."""

        def pem(env):
            yield env.timeout(-1)

        env.process(pem(env))
        with pytest.raises(ValueError, match='Negative delay'):
>           env.run()

tests/test_timeout.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91767a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_timeoutpytest_timeout_value">test_timeout.py::test_timeout_value</h3>
<details><summary> <pre>test_timeout.py::test_timeout_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91ae140>

    def test_timeout_value(env):
        """You can pass an additional *value* to *timeout* which will be
        directly yielded back into the PEM. This is useful to implement some
        kinds of resources or other additions.

        See :class:`envpy.resources.Store` for an example.

        """

        def pem(env):
            val = yield env.timeout(1, 'ohai')
            assert val == 'ohai'

        env.process(pem(env))
>       env.run()

tests/test_timeout.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91ae140>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_timeoutpytest_shared_timeout">test_timeout.py::test_shared_timeout</h3>
<details><summary> <pre>test_timeout.py::test_shared_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9174130>, log = []

    def test_shared_timeout(env, log):
        def child(env, timeout, id, log):
            yield timeout
            log.append((id, env.now))

        timeout = env.timeout(1)
        for i in range(3):
            env.process(child(env, timeout, i, log))

>       env.run()

tests/test_timeout.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9174130>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_timeoutpytest_triggered_timeout">test_timeout.py::test_triggered_timeout</h3>
<details><summary> <pre>test_timeout.py::test_triggered_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91ac880>

    def test_triggered_timeout(env):
        def process(env):
            def child(env, event):
                value = yield event
                return value

            event = env.timeout(1, 'i was already done')
            # Start the child after the timeout has already happened.
            yield env.timeout(2)
            value = yield env.process(child(env, event))
            assert value == 'i was already done'

>       env.run(env.process(process(env)))

tests/test_timeout.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91ac880>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_start_delayed">test_util.py::test_start_delayed</h3>
<details><summary> <pre>test_util.py::test_start_delayed</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bb550>

    def test_start_delayed(env):
        def pem(env):
            assert env.now == 5
            yield env.timeout(1)

        start_delayed(env, pem(env), delay=5)
>       env.run()

tests/test_util.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bb550>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe">test_util.py::test_subscribe</h3>
<details><summary> <pre>test_util.py::test_subscribe</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa2d54e0>

    def test_subscribe(env):
        """Check async. interrupt if a process terminates."""

        def child(env):
            yield env.timeout(3)
            return 'ohai'

        def parent(env):
            child_proc = env.process(child(env))
            subscribe_at(child_proc)

            try:
                yield env.event()
            except Interrupt as interrupt:
                assert interrupt.cause is not None  # noqa: PT017
                assert interrupt.cause[0] is child_proc  # noqa: PT017
                assert interrupt.cause[1] == 'ohai'  # noqa: PT017
                assert env.now == 3

        env.process(parent(env))
>       env.run()

tests/test_util.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa2d54e0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_terminated_proc">test_util.py::test_subscribe_terminated_proc</h3>
<details><summary> <pre>test_util.py::test_subscribe_terminated_proc</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9985cf0>

    def test_subscribe_terminated_proc(env):
        """subscribe() proc should send a signal immediately if
        "other" has already terminated.

        """

        def child(env):
            yield env.timeout(1)

        def parent(env):
            child_proc = env.process(child(env))
            yield env.timeout(2)
            pytest.raises(RuntimeError, subscribe_at, child_proc)

        env.process(parent(env))
>       env.run()

tests/test_util.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9985cf0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_with_join">test_util.py::test_subscribe_with_join</h3>
<details><summary> <pre>test_util.py::test_subscribe_with_join</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9447a90>

    def test_subscribe_with_join(env):
        """Test that subscribe() works if a process waits for another one."""

        def child(env, i):
            yield env.timeout(i)

        def parent(env):
            child_proc1 = env.process(child(env, 1))
            child_proc2 = env.process(child(env, 2))
            try:
                subscribe_at(child_proc1)
                yield child_proc2
            except Interrupt as interrupt:
                assert env.now == 1
                assert interrupt.cause is not None  # noqa: PT017
                assert interrupt.cause[0] is child_proc1  # noqa: PT017
                assert child_proc2.is_alive

        env.process(parent(env))
>       env.run()

tests/test_util.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9447a90>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_at_timeout">test_util.py::test_subscribe_at_timeout</h3>
<details><summary> <pre>test_util.py::test_subscribe_at_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9482440>

    def test_subscribe_at_timeout(env):
        """You should be able to subscribe at arbitrary events."""

        def pem(env):
            to = env.timeout(2)
            subscribe_at(to)
            try:
                yield env.timeout(10)
            except Interrupt as interrupt:
                assert interrupt.cause == (to, None)  # noqa: PT017
                assert env.now == 2

        env.process(pem(env))
>       env.run()

tests/test_util.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9482440>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_at_timeout_with_value">test_util.py::test_subscribe_at_timeout_with_value</h3>
<details><summary> <pre>test_util.py::test_subscribe_at_timeout_with_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91749d0>

    def test_subscribe_at_timeout_with_value(env):
        """An event's value should be accessible via the interrupt cause."""

        def pem(env):
            val = 'ohai'
            to = env.timeout(2, value=val)
            subscribe_at(to)
            try:
                yield env.timeout(10)
            except Interrupt as interrupt:
                assert interrupt.cause == (to, val)  # noqa: PT017
                assert env.now == 2

        env.process(pem(env))
>       env.run()

tests/test_util.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91749d0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of">test_util.py::test_all_of</h3>
<details><summary> <pre>test_util.py::test_all_of</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a948b6a0>

    def test_all_of(env):
        """Wait for all events to be triggered."""

        def parent(env):
            # Start 10 events.
            events = [env.timeout(i, value=i) for i in range(10)]
            results = yield env.all_of(events)

            assert results == {events[i]: i for i in range(10)}
            assert env.now == 9

        env.process(parent(env))
>       env.run()

tests/test_util.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a948b6a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_generator">test_util.py::test_all_of_generator</h3>
<details><summary> <pre>test_util.py::test_all_of_generator</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa108670>

    def test_all_of_generator(env):
        """Conditions also work with generators."""

        def parent(env):
            # Start 10 events.
            events = (env.timeout(i, value=i) for i in range(10))
            results = yield env.all_of(events)

            assert list(results.values()) == list(range(10))
            assert env.now == 9

        env.process(parent(env))
>       env.run()

tests/test_util.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa108670>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_wait_for_all_with_errors">test_util.py::test_wait_for_all_with_errors</h3>
<details><summary> <pre>test_util.py::test_wait_for_all_with_errors</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91f2740>

    def test_wait_for_all_with_errors(env):
        """On default AllOf should fail immediately if one of its events
        fails."""

        def child_with_error(env, value):
            yield env.timeout(value)
            raise RuntimeError('crashing')

        def parent(env):
            events = [
                env.timeout(1, value=1),
                env.process(child_with_error(env, 2)),
                env.timeout(3, value=3),
            ]

            condition = env.all_of(events)
            with pytest.raises(RuntimeError, match='crashing'):
                yield condition

            # Although the condition has failed, interim values are available.
            assert condition._events[0].value == 1
            assert condition._events[1].value.args[0] == 'crashing'
            # The last child has not terminated yet.
            assert not events[2].processed

        env.process(parent(env))
>       env.run()

tests/test_util.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91f2740>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_chaining">test_util.py::test_all_of_chaining</h3>
<details><summary> <pre>test_util.py::test_all_of_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa0ee8c0>

    def test_all_of_chaining(env):
        """If a wait_for_all condition A is chained to a wait_for_all condition B,
        B will be merged into A."""

        def parent(env):
            condition_a = env.all_of([env.timeout(i, value=i) for i in range(2)])
            condition_b = env.all_of([env.timeout(i, value=i) for i in range(2)])

            condition_a &= condition_b

            results = yield condition_a
            assert list(results.values()) == [0, 1, 0, 1]

        env.process(parent(env))
>       env.run()

tests/test_util.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa0ee8c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_chaining_intermediate_results">test_util.py::test_all_of_chaining_intermediate_results</h3>
<details><summary> <pre>test_util.py::test_all_of_chaining_intermediate_results</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91b4910>

    def test_all_of_chaining_intermediate_results(env):
        """If a wait_for_all condition A with intermediate results is merged into
        another wait_for_all condition B, the results are copied into condition
        A."""

        def parent(env):
            condition_a = env.all_of([env.timeout(i, value=i) for i in range(2)])
            condition_b = env.all_of([env.timeout(i, value=i) for i in range(2)])

            yield env.timeout(0)

            condition = condition_a & condition_b
            result = ConditionValue()
            condition._populate_value(result)
            assert list(result.values()) == [0, 0]

            results = yield condition
            assert list(results.values()) == [0, 1, 0, 1]

        env.process(parent(env))
>       env.run()

tests/test_util.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91b4910>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_with_triggered_events">test_util.py::test_all_of_with_triggered_events</h3>
<details><summary> <pre>test_util.py::test_all_of_with_triggered_events</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9197490>

    def test_all_of_with_triggered_events(env):
        """Processed events can be added to a condition. Confirm this with
        all_of."""

        def parent(env):
            events = [env.timeout(0, value='spam'), env.timeout(1, value='eggs')]
            yield env.timeout(2)

            values = list((yield env.all_of(events)).values())
            assert values == ['spam', 'eggs']

        env.process(parent(env))
>       env.run()

tests/test_util.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9197490>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of">test_util.py::test_any_of</h3>
<details><summary> <pre>test_util.py::test_any_of</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9447730>

    def test_any_of(env):
        """Wait for any event to be triggered."""

        def parent(env):
            # Start 10 events.
            events = [env.timeout(i, value=i) for i in range(10)]
            results = yield env.any_of(events)

            assert results == {events[0]: 0}
            assert env.now == 0

        env.process(parent(env))
>       env.run()

tests/test_util.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9447730>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of_with_errors">test_util.py::test_any_of_with_errors</h3>
<details><summary> <pre>test_util.py::test_any_of_with_errors</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91f19f0>

    def test_any_of_with_errors(env):
        """On default any_of should fail if the event has failed too."""

        def child_with_error(env, value):
            yield env.timeout(value)
            raise RuntimeError('crashing')

        def parent(env):
            events = [env.process(child_with_error(env, 1)), env.timeout(2, value=2)]
            condition = env.any_of(events)
            with pytest.raises(RuntimeError, match='crashing'):
                yield condition

            assert condition._events[0].value.args[0] == 'crashing'
            # The last event has not terminated yet.
            assert not events[1].processed

        env.process(parent(env))
>       env.run()

tests/test_util.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91f19f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of_chaining">test_util.py::test_any_of_chaining</h3>
<details><summary> <pre>test_util.py::test_any_of_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9489d50>

    def test_any_of_chaining(env):
        """If a any_of condition A is chained to a any_of condition B,
        B will be merged into A."""

        def parent(env):
            condition_a = env.any_of([env.timeout(2, value='a')])
            condition_b = env.any_of([env.timeout(1, value='b')])

            condition_a |= condition_b

            results = yield condition_a
            assert list(results.values()) == ['b']

        env.process(parent(env))
>       env.run()

tests/test_util.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9489d50>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of_with_triggered_events">test_util.py::test_any_of_with_triggered_events</h3>
<details><summary> <pre>test_util.py::test_any_of_with_triggered_events</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9181d20>

    def test_any_of_with_triggered_events(env):
        """Processed events can be added to a condition. Confirm this with
        all_of."""

        def parent(env):
            events = [env.timeout(0, value='spam'), env.timeout(1, value='eggs')]
            yield env.timeout(2)

            values = list((yield env.any_of(events)).values())
            assert values == ['spam', 'eggs']

        env.process(parent(env))
>       env.run()

tests/test_util.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9181d20>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_empty_any_of">test_util.py::test_empty_any_of</h3>
<details><summary> <pre>test_util.py::test_empty_any_of</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9175de0>

    def test_empty_any_of(env):
        """AnyOf will trigger immediately if there are no events."""

        def parent(env):
            results = yield env.any_of([])
            assert results == {}

        env.process(parent(env))
>       env.run()

tests/test_util.py:317: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9175de0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_empty_all_of">test_util.py::test_empty_all_of</h3>
<details><summary> <pre>test_util.py::test_empty_all_of</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91b7280>

    def test_empty_all_of(env):
        """AllOf will trigger immediately if there are no events."""

        def parent(env):
            results = yield env.all_of([])
            assert results == {}

        env.process(parent(env))
>       env.run()

tests/test_util.py:328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91b7280>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_expansion">test_util.py::test_all_of_expansion</h3>
<details><summary> <pre>test_util.py::test_all_of_expansion</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9985240>

    def test_all_of_expansion(env):
        """The result of AllOf is an OrderedDict, which allows to expand its values
        directly into variables."""

        def p(env):
            timeouts = [env.timeout(d, d) for d in [3, 2, 1]]
            a, b, c = (yield env.all_of(timeouts)).values()
            assert a == 3
            assert b == 2
            assert c == 1

        env.process(p(env))
>       env.run()

tests/test_util.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9985240>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>

<h2 id="failed-to-run-pytests">Failed to run pytests</h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/conftest.py:7: in &lt;module&gt;
    from tinydb.middlewares import CachingMiddleware
tinydb/__init__.py:27: in &lt;module&gt;
    from .queries import Query, where
tinydb/queries.py:21: in &lt;module&gt;
    from .utils import freeze
tinydb/utils.py:84: in &lt;module&gt;
    class FrozenDict(dict):
tinydb/utils.py:95: in FrozenDict
    __setitem__ = _immutable
E   NameError: name &#39;_immutable&#39; is not defined
</code></pre></div>
<h2 id="failed-to-run-pytests_1">Failed to run pytests</h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/conftest.py:5: in &lt;module&gt;
    from tests.base import Blog, User, UserSchema
tests/base.py:11: in &lt;module&gt;
    from marshmallow import Schema, fields, missing, post_load, validate
src/marshmallow/__init__.py:17: in &lt;module&gt;
    from marshmallow.schema import Schema, SchemaOpts
src/marshmallow/schema.py:15: in &lt;module&gt;
    from marshmallow import fields as ma_fields
src/marshmallow/fields.py:18: in &lt;module&gt;
    from marshmallow.utils import is_aware, is_collection, resolve_field_instance
E   ImportError: cannot import name &#39;is_aware&#39; from &#39;marshmallow.utils&#39; (/testbed/src/marshmallow/utils.py)
</code></pre></div>
<h2 id="pytest-summary_1">Pytest Summary</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">6</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">32</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">39</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">39</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytest_1">Failed pytest:</h2>
<h3 id="test_corepytest_empty_string">test_core.py::test_empty_string</h3>
<details><summary> <pre>test_core.py::test_empty_string</pre></summary><pre>
def test_empty_string():
        """
        Test empty string is OK.

        https://github.com/jquast/wcwidth/issues/24
        """
        phrase = ""
        expect_length_each = 0
        expect_length_phrase = 0

        # exercise,
>       length_each = wcwidth.wcwidth(phrase)

tests/test_core.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

wc = '', unicode_version = 'auto'

    @lru_cache(maxsize=1000)
    def wcwidth(wc, unicode_version='auto'):
        """
        Given one Unicode character, return its printable length on a terminal.

        :param str wc: A single Unicode character.
        :param str unicode_version: A Unicode version number, such as
            ``'6.0.0'``. A list of version levels suported by wcwidth
            is returned by :func:`list_versions`.

            Any version string may be specified without error -- the nearest
            matching version is selected.  When ``latest`` (default), the
            highest Unicode version level is used.
        :return: The width, in cells, necessary to display the character of
            Unicode string character, ``wc``.  Returns 0 if the ``wc`` argument has
            no printable effect on a terminal (such as NUL '\\0'), -1 if ``wc`` is
            not printable, or has an indeterminate effect on the terminal, such as
            a control character.  Otherwise, the number of column positions the
            character occupies on a graphic terminal (1 or 2) is returned.
        :rtype: int

        See :ref:`Specification` for details of cell measurement.
        """
>       ucs = ord(wc)
E       TypeError: ord() expected a character, but string of length 0 found

wcwidth/wcwidth.py:129: TypeError
</pre>
</details>
<h3 id="test_corepytest_hello_jp">test_core.py::test_hello_jp</h3>
<details><summary> <pre>test_core.py::test_hello_jp</pre></summary><pre>
def test_hello_jp():
        u"""
        Width of Japanese phrase: , !

        Given a phrase of 5 and 3 Katakana ideographs, joined with
        3 English-ASCII punctuation characters, totaling 11, this
        phrase consumes 19 cells of a terminal emulator.
        """
        # given,
        phrase = u', !'
        expect_length_each = (2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 1)
        expect_length_phrase = sum(expect_length_each)

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 12467
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_wcswidth_substr">test_core.py::test_wcswidth_substr</h3>
<details><summary> <pre>test_core.py::test_wcswidth_substr</pre></summary><pre>
def test_wcswidth_substr():
        """
        Test wcswidth() optional 2nd parameter, ``n``.

        ``n`` determines at which position of the string
        to stop counting length.
        """
        # given,
        phrase = u', !'
        end = 7
        expect_length_each = (2, 2, 2, 2, 2, 1, 1,)
        expect_length_phrase = sum(expect_length_each)

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))[:end]

tests/test_core.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 12467
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_null_width_0">test_core.py::test_null_width_0</h3>
<details><summary> <pre>test_core.py::test_null_width_0</pre></summary><pre>
def test_null_width_0():
        """NULL (0) reports width 0."""
        # given,
        phrase = u'abc\x00def'
        expect_length_each = (1, 1, 1, 0, 1, 1, 1)
        expect_length_phrase = sum(expect_length_each)

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 97
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_control_c0_width_negative_1">test_core.py::test_control_c0_width_negative_1</h3>
<details><summary> <pre>test_core.py::test_control_c0_width_negative_1</pre></summary><pre>
def test_control_c0_width_negative_1():
        """How the API reacts to CSI (Control sequence initiate).

        An example of bad fortune, this terminal sequence is a width of 0
        on all terminals, but wcwidth doesn't parse Control-Sequence-Inducer
        (CSI) sequences.

        Also the "legacy" posix functions wcwidth and wcswidth return -1 for
        any string containing the C1 control character \x1b (ESC).
        """
        # given,
        phrase = u'\x1b[0m'
        expect_length_each = (-1, 1, 1, 1)
        expect_length_phrase = -1

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 91
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_combining_width">test_core.py::test_combining_width</h3>
<details><summary> <pre>test_core.py::test_combining_width</pre></summary><pre>
def test_combining_width():
        """Simple test combining reports total width of 4."""
        # given,
        phrase = u'--\u05bf--'
        expect_length_each = (1, 1, 0, 1, 1)
        expect_length_phrase = 4

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 45
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_combining_cafe">test_core.py::test_combining_cafe</h3>
<details><summary> <pre>test_core.py::test_combining_cafe</pre></summary><pre>
def test_combining_cafe():
        u"""Phrase cafe + COMBINING ACUTE ACCENT is caf of length 4."""
        phrase = u"cafe\u0301"
        expect_length_each = (1, 1, 1, 1, 0)
        expect_length_phrase = 4

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 99
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_combining_enclosing">test_core.py::test_combining_enclosing</h3>
<details><summary> <pre>test_core.py::test_combining_enclosing</pre></summary><pre>
def test_combining_enclosing():
        u"""CYRILLIC CAPITAL LETTER A + COMBINING CYRILLIC HUNDRED THOUSANDS SIGN is of length 1."""
        phrase = u"\u0410\u0488"
        expect_length_each = (1, 0)
        expect_length_phrase = 1

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 1040
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_balinese_script">test_core.py::test_balinese_script</h3>
<details><summary> <pre>test_core.py::test_balinese_script</pre></summary><pre>
def test_balinese_script():
        u"""
        Balinese kapal (ship) is length 3.

        This may be an example that is not yet correctly rendered by any terminal so
        far, like devanagari.
        """
        phrase = (u"\u1B13"    # Category 'Lo', EAW 'N' -- BALINESE LETTER KA
                  u"\u1B28"    # Category 'Lo', EAW 'N' -- BALINESE LETTER PA KAPAL
                  u"\u1B2E"    # Category 'Lo', EAW 'N' -- BALINESE LETTER LA
                  u"\u1B44")   # Category 'Mc', EAW 'N' -- BALINESE ADEG ADEG
        expect_length_each = (1, 1, 1, 0)
        expect_length_phrase = 3

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 6931
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_kr_jamo">test_core.py::test_kr_jamo</h3>
<details><summary> <pre>test_core.py::test_kr_jamo</pre></summary><pre>
def test_kr_jamo():
        """
        Test basic combining of HANGUL CHOSEONG and JUNGSEONG

        Example and from Raymond Chen's blog post,
        https://devblogs.microsoft.com/oldnewthing/20201009-00/?p=104351
        """
        # This is an example where both characters are "wide" when displayed alone.
        #
        # But JUNGSEONG (vowel) is designed for combination with a CHOSEONG (consonant).
        #
        # This wcwidth library understands their width only when combination,
        # and not by independent display, like other zero-width characters that may
        # only combine with an appropriate preceding character.
        phrase = (
            u"\u1100"  #  HANGUL CHOSEONG KIYEOK (consonant)
            u"\u1161"  #  HANGUL JUNGSEONG A (vowel)
        )
        expect_length_each = (2, 0)
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 4352
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_kr_jamo_filler">test_core.py::test_kr_jamo_filler</h3>
<details><summary> <pre>test_core.py::test_kr_jamo_filler</pre></summary><pre>
def test_kr_jamo_filler():
        u"""
        Jamo filler is 0 width.

        Example from https://www.unicode.org/L2/L2006/06310-hangul-decompose9.pdf
        """
        phrase = (
            u"\u1100"  # HANGUL CHOSEONG KIYEOK (consonant)
            u"\u1160"  # HANGUL JUNGSEONG FILLER (vowel)
        )
        expect_length_each = (2, 0)
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 4352
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_devanagari_script">test_core.py::test_devanagari_script</h3>
<details><summary> <pre>test_core.py::test_devanagari_script</pre></summary><pre>
def test_devanagari_script():
        """
        Attempt to test the measurement width of Devanagari script.

        I believe this 'phrase' should be length 3.

        This is a difficult problem, and this library does not yet get it right,
        because we interpret the unicode data files programmatically, but they do
        not correctly describe how their terminal width is measured.

        There are very few Terminals that do!

        As of 2023,

        - iTerm2: correct length but individual characters are out of order and
                  horizaontally misplaced as to be unreadable in its language when
                  using 'Noto Sans' font.
        - mlterm: mixed results, it offers several options in the configuration
                  dialog, "Xft", "Cario", and "Variable Column Width" have some
                  effect, but with neither 'Noto Sans' or 'unifont', it is not
                  recognizable as the Devanagari script it is meant to display.

        Previous testing with Devanagari documented at address https://benizi.com/vim/devanagari/

        See also, https://askubuntu.com/questions/8437/is-there-a-good-mono-spaced-font-for-devanagari-script-in-the-terminal
        """
        # This test adapted from https://www.unicode.org/L2/L2023/23107-terminal-suppt.pdf
        # please note that document correctly points out that the final width cannot be determined
        # as a sum of each individual width, as this library currently performs with exception of
        # ZWJ, but I think it incorrectly gestures what a stateless call to wcwidth.wcwidth of
        # each codepoint *should* return.
        phrase = (u"\u0915"    # Akhand, Category 'Lo', East Asian Width property 'N' -- DEVANAGARI LETTER KA
                  u"\u094D"    # Joiner, Category 'Mn', East Asian Width property 'N' -- DEVANAGARI SIGN VIRAMA
                  u"\u0937"    # Fused, Category 'Lo', East Asian Width property 'N' -- DEVANAGARI LETTER SSA
                  u"\u093F")   # MatraL, Category 'Mc', East Asian Width property 'N' -- DEVANAGARI VOWEL SIGN I
        # 23107-terminal-suppt.pdf suggests wcwidth.wcwidth should return (2, 0, 0, 1)
        expect_length_each = (1, 0, 1, 0)
        # I believe the final width *should* be 3.
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:318: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 2325
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_tamil_script">test_core.py::test_tamil_script</h3>
<details><summary> <pre>test_core.py::test_tamil_script</pre></summary><pre>
def test_tamil_script():
        # This test adapted from https://www.unicode.org/L2/L2023/23107-terminal-suppt.pdf
        phrase = (u"\u0b95"    # Akhand, Category 'Lo', East Asian Width property 'N' -- TAMIL LETTER KA
                  u"\u0bcd"    # Joiner, Category 'Mn', East Asian Width property 'N' -- TAMIL SIGN VIRAMA
                  u"\u0bb7"    # Fused, Category 'Lo', East Asian Width property 'N' -- TAMIL LETTER SSA
                  u"\u0bcc")   # MatraLR, Category 'Mc', East Asian Width property 'N' -- TAMIL VOWEL SIGN AU
        # 23107-terminal-suppt.pdf suggests wcwidth.wcwidth should return (3, 0, 0, 4)
        expect_length_each = (1, 0, 1, 0)

        # I believe the final width should be about 5 or 6.
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 2965
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_kannada_script">test_core.py::test_kannada_script</h3>
<details><summary> <pre>test_core.py::test_kannada_script</pre></summary><pre>
def test_kannada_script():
        # This test adapted from https://www.unicode.org/L2/L2023/23107-terminal-suppt.pdf
        # ||
        # |123|
        phrase = (u"\u0cb0"    # Repha, Category 'Lo', East Asian Width property 'N' -- KANNADA LETTER RA
                  u"\u0ccd"    # Joiner, Category 'Mn', East Asian Width property 'N' -- KANNADA SIGN VIRAMA
                  u"\u0c9d"    # Base, Category 'Lo', East Asian Width property 'N' -- KANNADA LETTER JHA
                  u"\u0cc8")   # MatraUR, Category 'Mc', East Asian Width property 'N' -- KANNADA VOWEL SIGN AI
        # 23107-terminal-suppt.pdf suggests should be (2, 0, 3, 1)
        expect_length_each = (1, 0, 1, 0)
        # I believe the correct final width *should* be 3 or 4.
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 3248
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_kannada_script_2">test_core.py::test_kannada_script_2</h3>
<details><summary> <pre>test_core.py::test_kannada_script_2</pre></summary><pre>
def test_kannada_script_2():
        # This test adapted from https://www.unicode.org/L2/L2023/23107-terminal-suppt.pdf
        # ||
        # |12|
        phrase = (u"\u0cb0"    # Base, Category 'Lo', East Asian Width property 'N' -- KANNADA LETTER RA
                  u"\u0cbc"    # Nukta, Category 'Mn', East Asian Width property 'N' -- KANNADA SIGN NUKTA
                  u"\u0ccd"    # Joiner, Category 'Lo', East Asian Width property 'N' -- KANNADA SIGN VIRAMA
                  u"\u0c9a")   # Subjoin, Category 'Mc', East Asian Width property 'N' -- KANNADA LETTER CA
        # 23107-terminal-suppt.pdf suggests wcwidth.wcwidth should return (2, 0, 0, 1)
        expect_length_each = (1, 0, 0, 1)
        # I believe the final width is correct, but maybe for the wrong reasons!
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:383: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 3248
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_zero_wide_conflict">test_core.py::test_zero_wide_conflict</h3>
<details><summary> <pre>test_core.py::test_zero_wide_conflict</pre></summary><pre>
def test_zero_wide_conflict():
        # Test characters considered both "wide" and "zero" width
        # -  (0x03000, 0x0303e,),  # Ideographic Space       ..Ideographic Variation In
        # +  (0x03000, 0x03029,),  # Ideographic Space       ..Hangzhou Numeral Nine
>       assert wcwidth.wcwidth(unichr(0x03029), unicode_version='4.1.0') == 2

tests/test_core.py:395: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 12329
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_emojispytest_unfinished_zwj_sequence">test_emojis.py::test_unfinished_zwj_sequence</h3>
<details><summary> <pre>test_emojis.py::test_unfinished_zwj_sequence</pre></summary><pre>
@pytest.mark.skipif(NARROW_ONLY, reason="Test cannot verify on python 'narrow' builds")
    def test_unfinished_zwj_sequence():
        u"""
        Ensure index-out-of-bounds does not occur for zero-width joiner without any following character
        """
        phrase = (u"\U0001f469"   # Base, Category So, East Asian Width property 'W' -- WOMAN
                  u"\U0001f3fb"   # Modifier, Category Sk, East Asian Width property 'W' -- EMOJI MODIFIER FITZPATRICK TYPE-1-2
                  u"\u200d")      # Joiner, Category Cf, East Asian Width property 'N'  -- ZERO WIDTH JOINER
        expect_length_each = (2, 0, 0)
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_emojis.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 128105
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_emojispytest_non_recommended_zwj_sequence">test_emojis.py::test_non_recommended_zwj_sequence</h3>
<details><summary> <pre>test_emojis.py::test_non_recommended_zwj_sequence</pre></summary><pre>
@pytest.mark.skipif(NARROW_ONLY, reason="Test cannot verify on python 'narrow' builds")
    def test_non_recommended_zwj_sequence():
        """
        Verify ZWJ is measured as though successful with characters that cannot be joined, wcwidth does not verify
        """
        phrase = (u"\U0001f469"   # Base, Category So, East Asian Width property 'W' -- WOMAN
                  u"\U0001f3fb"   # Modifier, Category Sk, East Asian Width property 'W' -- EMOJI MODIFIER FITZPATRICK TYPE-1-2
                  u"\u200d")      # Joiner, Category Cf, East Asian Width property 'N'  -- ZERO WIDTH JOINER
        expect_length_each = (2, 0, 0)
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_emojis.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 128105
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_emojispytest_another_emoji_zwj_sequence">test_emojis.py::test_another_emoji_zwj_sequence</h3>
<details><summary> <pre>test_emojis.py::test_another_emoji_zwj_sequence</pre></summary><pre>
@pytest.mark.skipif(NARROW_ONLY, reason="Test cannot verify on python 'narrow' builds")
    def test_another_emoji_zwj_sequence():
        phrase = (
            u"\u26F9"        # PERSON WITH BALL
            u"\U0001F3FB"    # EMOJI MODIFIER FITZPATRICK TYPE-1-2
            u"\u200D"        # ZERO WIDTH JOINER
            u"\u2640"        # FEMALE SIGN
            u"\uFE0F")       # VARIATION SELECTOR-16
        expect_length_each = (1, 0, 0, 1, 0)
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_emojis.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 9977
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_emojispytest_longer_emoji_zwj_sequence">test_emojis.py::test_longer_emoji_zwj_sequence</h3>
<details><summary> <pre>test_emojis.py::test_longer_emoji_zwj_sequence</pre></summary><pre>
@pytest.mark.skipif(NARROW_ONLY, reason="Test cannot verify on python 'narrow' builds")
    def test_longer_emoji_zwj_sequence():
        """
        A much longer emoji ZWJ sequence of 10 total codepoints is just 2 cells!

        Also test the same sequence in duplicate, verifying multiple VS-16 sequences
        in a single function call.
        """
        # 'Category Code', 'East Asian Width property' -- 'description'
        phrase = (u"\U0001F9D1"   # 'So', 'W' -- ADULT
                  u"\U0001F3FB"   # 'Sk', 'W' -- EMOJI MODIFIER FITZPATRICK TYPE-1-2
                  u"\u200d"       # 'Cf', 'N' -- ZERO WIDTH JOINER
                  u"\u2764"       # 'So', 'N' -- HEAVY BLACK HEART
                  u"\uFE0F"       # 'Mn', 'A' -- VARIATION SELECTOR-16
                  u"\u200d"       # 'Cf', 'N' -- ZERO WIDTH JOINER
                  u"\U0001F48B"   # 'So', 'W' -- KISS MARK
                  u"\u200d"       # 'Cf', 'N' -- ZERO WIDTH JOINER
                  u"\U0001F9D1"   # 'So', 'W' -- ADULT
                  u"\U0001F3FD"   # 'Sk', 'W' -- EMOJI MODIFIER FITZPATRICK TYPE-4
        ) * 2
        # This test adapted from https://www.unicode.org/L2/L2023/23107-terminal-suppt.pdf
        expect_length_each = (2, 0, 0, 1, 0, 0, 2, 0, 2, 0) * 2
        expect_length_phrase = 4

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_emojis.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 129489
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_emojispytest_recommended_emoji_zwj_sequences">test_emojis.py::test_recommended_emoji_zwj_sequences</h3>
<details><summary> <pre>test_emojis.py::test_recommended_emoji_zwj_sequences</pre></summary><pre>
@pytest.mark.skipif(NARROW_ONLY, reason="Some sequences in text file are not compatible with 'narrow' builds")
    def test_recommended_emoji_zwj_sequences():
        """
        Test wcswidth of all of the unicode.org-published emoji-zwj-sequences.txt
        """
        # given,
        lines, sequences = read_sequences_from_file('emoji-zwj-sequences.txt')

        errors = []
        # Exercise, track by zipping with original text file line, a debugging aide
        num = 0
        for sequence, line in zip(sequences, lines):
            num += 1
>           measured_width = wcwidth.wcswidth(sequence)

tests/test_emojis.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:177: in wcswidth
    char_width = wcwidth(char, unicode_version)
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 128104
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_emojispytest_recommended_variation_16_sequences">test_emojis.py::test_recommended_variation_16_sequences</h3>
<details><summary> <pre>test_emojis.py::test_recommended_variation_16_sequences</pre></summary><pre>
def test_recommended_variation_16_sequences():
        """
        Test wcswidth of all of the unicode.org-published emoji-variation-sequences.txt
        """
        # given,
        lines, sequences = read_sequences_from_file('emoji-variation-sequences.txt')

        errors = []
        num = 0
        for sequence, line in zip(sequences, lines):
            num += 1
            if '\ufe0f' not in sequence:
                # filter for only \uFE0F (VS-16)
                continue
>           measured_width = wcwidth.wcswidth(sequence)

tests/test_emojis.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:177: in wcswidth
    char_width = wcwidth(char, unicode_version)
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 35
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_emojispytest_unicode_9_vs16">test_emojis.py::test_unicode_9_vs16</h3>
<details><summary> <pre>test_emojis.py::test_unicode_9_vs16</pre></summary><pre>
def test_unicode_9_vs16():
        """Verify effect of VS-16 on unicode_version 9.0 and later"""
        phrase = (u"\u2640"        # FEMALE SIGN
                  u"\uFE0F")       # VARIATION SELECTOR-16

        expect_length_each = (1, 0)
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(wcwidth.wcwidth(w_char, unicode_version='9.0') for w_char in phrase)

tests/test_emojis.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_emojis.py:222: in <genexpr>
    length_each = tuple(wcwidth.wcwidth(w_char, unicode_version='9.0') for w_char in phrase)
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 9792
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_emojispytest_unicode_8_vs16">test_emojis.py::test_unicode_8_vs16</h3>
<details><summary> <pre>test_emojis.py::test_unicode_8_vs16</pre></summary><pre>
def test_unicode_8_vs16():
        """Verify that VS-16 has no effect on unicode_version 8.0 and earler"""
        phrase = (u"\u2640"        # FEMALE SIGN
                  u"\uFE0F")       # VARIATION SELECTOR-16

        expect_length_each = (1, 0)
        expect_length_phrase = 1

        # exercise,
>       length_each = tuple(wcwidth.wcwidth(w_char, unicode_version='8.0') for w_char in phrase)

tests/test_emojis.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_emojis.py:238: in <genexpr>
    length_each = tuple(wcwidth.wcwidth(w_char, unicode_version='8.0') for w_char in phrase)
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 9792
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_table_integritypytest_verify_table_integrity">test_table_integrity.py::test_verify_table_integrity</h3>
<details><summary> <pre>test_table_integrity.py::test_verify_table_integrity</pre></summary><pre>
('/testbed/tests/test_table_integrity.py', 10, 'Skipped: Test only with a single version of python')
</pre>
</details>
<h3 id="test_ucslevelpytest_nearest_505_str">test_ucslevel.py::test_nearest_505_str</h3>
<details><summary> <pre>test_ucslevel.py::test_nearest_505_str</pre></summary><pre>
def test_nearest_505_str():
        """wcwidth._wcmatch_version('5.0.5') returns nearest '5.0.0'. (str)"""
        # given
        given, expected = '5.0.5', '5.0.0'

        # exercise
>       result = wcwidth._wcmatch_version(given)

tests/test_ucslevel.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

given_version = '5.0.5'

    @lru_cache(maxsize=8)
    def _wcmatch_version(given_version):
        """
        Return nearest matching supported Unicode version level.

        If an exact match is not determined, the nearest lowest version level is
        returned after a warning is emitted.  For example, given supported levels
        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``
        is selected and returned:

        >>> _wcmatch_version('4.9.9')
        '4.1.0'
        >>> _wcmatch_version('8.0')
        '8.0.0'
        >>> _wcmatch_version('1')
        '4.1.0'

        :param str given_version: given version for compare, may be ``auto``
            (default), to select Unicode Version from Environment Variable,
            ``UNICODE_VERSION``. If the environment variable is not set, then the
            latest is used.
        :rtype: str
        :returns: unicode string, or non-unicode ``str`` type for python 2
            when given ``version`` is also type ``str``.
        """
        if given_version == 'auto':
            given_version = os.environ.get('UNICODE_VERSION', 'latest')

        if given_version == 'latest':
            return list_versions()[-1]

        supported_versions = list_versions()
        given_value = _wcversion_value(given_version)

        for version in reversed(supported_versions):
            if _wcversion_value(version) <= given_value:
                if version != given_version:
>                   warnings.warn(f"Unicode version '{given_version}' not found, using '{version}'")
E                   UserWarning: Unicode version '5.0.5' not found, using '5.0.0'

wcwidth/wcwidth.py:234: UserWarning
</pre>
</details>
<h3 id="test_ucslevelpytest_nearest_505_unicode">test_ucslevel.py::test_nearest_505_unicode</h3>
<details><summary> <pre>test_ucslevel.py::test_nearest_505_unicode</pre></summary><pre>
def test_nearest_505_unicode():
        """wcwidth._wcmatch_version(u'5.0.5') returns nearest u'5.0.0'. (unicode)"""
        # given
        given, expected = u'5.0.5', u'5.0.0'

        # exercise
>       result = wcwidth._wcmatch_version(given)

tests/test_ucslevel.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

given_version = '5.0.5'

    @lru_cache(maxsize=8)
    def _wcmatch_version(given_version):
        """
        Return nearest matching supported Unicode version level.

        If an exact match is not determined, the nearest lowest version level is
        returned after a warning is emitted.  For example, given supported levels
        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``
        is selected and returned:

        >>> _wcmatch_version('4.9.9')
        '4.1.0'
        >>> _wcmatch_version('8.0')
        '8.0.0'
        >>> _wcmatch_version('1')
        '4.1.0'

        :param str given_version: given version for compare, may be ``auto``
            (default), to select Unicode Version from Environment Variable,
            ``UNICODE_VERSION``. If the environment variable is not set, then the
            latest is used.
        :rtype: str
        :returns: unicode string, or non-unicode ``str`` type for python 2
            when given ``version`` is also type ``str``.
        """
        if given_version == 'auto':
            given_version = os.environ.get('UNICODE_VERSION', 'latest')

        if given_version == 'latest':
            return list_versions()[-1]

        supported_versions = list_versions()
        given_value = _wcversion_value(given_version)

        for version in reversed(supported_versions):
            if _wcversion_value(version) <= given_value:
                if version != given_version:
>                   warnings.warn(f"Unicode version '{given_version}' not found, using '{version}'")
E                   UserWarning: Unicode version '5.0.5' not found, using '5.0.0'

wcwidth/wcwidth.py:234: UserWarning
</pre>
</details>
<h3 id="test_ucslevelpytest_nearest_800_str">test_ucslevel.py::test_nearest_800_str</h3>
<details><summary> <pre>test_ucslevel.py::test_nearest_800_str</pre></summary><pre>
def test_nearest_800_str():
        """wcwidth._wcmatch_version('8') returns nearest '8.0.0'."""
        # given
        given, expected = '8', '8.0.0'

        # exercise
>       result = wcwidth._wcmatch_version(given)

tests/test_ucslevel.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

given_version = '8'

    @lru_cache(maxsize=8)
    def _wcmatch_version(given_version):
        """
        Return nearest matching supported Unicode version level.

        If an exact match is not determined, the nearest lowest version level is
        returned after a warning is emitted.  For example, given supported levels
        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``
        is selected and returned:

        >>> _wcmatch_version('4.9.9')
        '4.1.0'
        >>> _wcmatch_version('8.0')
        '8.0.0'
        >>> _wcmatch_version('1')
        '4.1.0'

        :param str given_version: given version for compare, may be ``auto``
            (default), to select Unicode Version from Environment Variable,
            ``UNICODE_VERSION``. If the environment variable is not set, then the
            latest is used.
        :rtype: str
        :returns: unicode string, or non-unicode ``str`` type for python 2
            when given ``version`` is also type ``str``.
        """
        if given_version == 'auto':
            given_version = os.environ.get('UNICODE_VERSION', 'latest')

        if given_version == 'latest':
            return list_versions()[-1]

        supported_versions = list_versions()
        given_value = _wcversion_value(given_version)

        for version in reversed(supported_versions):
            if _wcversion_value(version) <= given_value:
                if version != given_version:
>                   warnings.warn(f"Unicode version '{given_version}' not found, using '{version}'")
E                   UserWarning: Unicode version '8' not found, using '7.0.0'

wcwidth/wcwidth.py:234: UserWarning
</pre>
</details>
<h3 id="test_ucslevelpytest_nearest_800_unicode">test_ucslevel.py::test_nearest_800_unicode</h3>
<details><summary> <pre>test_ucslevel.py::test_nearest_800_unicode</pre></summary><pre>
def test_nearest_800_unicode():
        """wcwidth._wcmatch_version(u'8') returns nearest u'8.0.0'."""
        # given
        given, expected = u'8', u'8.0.0'

        # exercise
>       result = wcwidth._wcmatch_version(given)

tests/test_ucslevel.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

given_version = '8'

    @lru_cache(maxsize=8)
    def _wcmatch_version(given_version):
        """
        Return nearest matching supported Unicode version level.

        If an exact match is not determined, the nearest lowest version level is
        returned after a warning is emitted.  For example, given supported levels
        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``
        is selected and returned:

        >>> _wcmatch_version('4.9.9')
        '4.1.0'
        >>> _wcmatch_version('8.0')
        '8.0.0'
        >>> _wcmatch_version('1')
        '4.1.0'

        :param str given_version: given version for compare, may be ``auto``
            (default), to select Unicode Version from Environment Variable,
            ``UNICODE_VERSION``. If the environment variable is not set, then the
            latest is used.
        :rtype: str
        :returns: unicode string, or non-unicode ``str`` type for python 2
            when given ``version`` is also type ``str``.
        """
        if given_version == 'auto':
            given_version = os.environ.get('UNICODE_VERSION', 'latest')

        if given_version == 'latest':
            return list_versions()[-1]

        supported_versions = list_versions()
        given_value = _wcversion_value(given_version)

        for version in reversed(supported_versions):
            if _wcversion_value(version) <= given_value:
                if version != given_version:
>                   warnings.warn(f"Unicode version '{given_version}' not found, using '{version}'")
E                   UserWarning: Unicode version '8' not found, using '7.0.0'

wcwidth/wcwidth.py:234: UserWarning
</pre>
</details>
<h3 id="test_ucslevelpytest_nearest_999_str">test_ucslevel.py::test_nearest_999_str</h3>
<details><summary> <pre>test_ucslevel.py::test_nearest_999_str</pre></summary><pre>
def test_nearest_999_str():
        """wcwidth._wcmatch_version('999.0') returns nearest (latest)."""
        # given
        given, expected = '999.0', wcwidth.list_versions()[-1]

        # exercise
>       result = wcwidth._wcmatch_version(given)

tests/test_ucslevel.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

given_version = '999.0'

    @lru_cache(maxsize=8)
    def _wcmatch_version(given_version):
        """
        Return nearest matching supported Unicode version level.

        If an exact match is not determined, the nearest lowest version level is
        returned after a warning is emitted.  For example, given supported levels
        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``
        is selected and returned:

        >>> _wcmatch_version('4.9.9')
        '4.1.0'
        >>> _wcmatch_version('8.0')
        '8.0.0'
        >>> _wcmatch_version('1')
        '4.1.0'

        :param str given_version: given version for compare, may be ``auto``
            (default), to select Unicode Version from Environment Variable,
            ``UNICODE_VERSION``. If the environment variable is not set, then the
            latest is used.
        :rtype: str
        :returns: unicode string, or non-unicode ``str`` type for python 2
            when given ``version`` is also type ``str``.
        """
        if given_version == 'auto':
            given_version = os.environ.get('UNICODE_VERSION', 'latest')

        if given_version == 'latest':
            return list_versions()[-1]

        supported_versions = list_versions()
        given_value = _wcversion_value(given_version)

        for version in reversed(supported_versions):
            if _wcversion_value(version) <= given_value:
                if version != given_version:
>                   warnings.warn(f"Unicode version '{given_version}' not found, using '{version}'")
E                   UserWarning: Unicode version '999.0' not found, using '15.1.0'

wcwidth/wcwidth.py:234: UserWarning
</pre>
</details>
<h3 id="test_ucslevelpytest_nearest_999_unicode">test_ucslevel.py::test_nearest_999_unicode</h3>
<details><summary> <pre>test_ucslevel.py::test_nearest_999_unicode</pre></summary><pre>
def test_nearest_999_unicode():
        """wcwidth._wcmatch_version(u'999.0') returns nearest (latest)."""
        # given
        given, expected = u'999.0', wcwidth.list_versions()[-1]

        # exercise
>       result = wcwidth._wcmatch_version(given)

tests/test_ucslevel.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

given_version = '999.0'

    @lru_cache(maxsize=8)
    def _wcmatch_version(given_version):
        """
        Return nearest matching supported Unicode version level.

        If an exact match is not determined, the nearest lowest version level is
        returned after a warning is emitted.  For example, given supported levels
        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``
        is selected and returned:

        >>> _wcmatch_version('4.9.9')
        '4.1.0'
        >>> _wcmatch_version('8.0')
        '8.0.0'
        >>> _wcmatch_version('1')
        '4.1.0'

        :param str given_version: given version for compare, may be ``auto``
            (default), to select Unicode Version from Environment Variable,
            ``UNICODE_VERSION``. If the environment variable is not set, then the
            latest is used.
        :rtype: str
        :returns: unicode string, or non-unicode ``str`` type for python 2
            when given ``version`` is also type ``str``.
        """
        if given_version == 'auto':
            given_version = os.environ.get('UNICODE_VERSION', 'latest')

        if given_version == 'latest':
            return list_versions()[-1]

        supported_versions = list_versions()
        given_value = _wcversion_value(given_version)

        for version in reversed(supported_versions):
            if _wcversion_value(version) <= given_value:
                if version != given_version:
>                   warnings.warn(f"Unicode version '{given_version}' not found, using '{version}'")
E                   UserWarning: Unicode version '999.0' not found, using '15.1.0'

wcwidth/wcwidth.py:234: UserWarning
</pre>
</details>
<h3 id="test_ucslevelpytest_nonint_unicode">test_ucslevel.py::test_nonint_unicode</h3>
<details><summary> <pre>test_ucslevel.py::test_nonint_unicode</pre></summary><pre>
def test_nonint_unicode():
        """wcwidth._wcmatch_version(u'x.y.z') returns latest (unicode)."""
        # given
        given, expected = u'x.y.z', wcwidth.list_versions()[-1]
        warnings.resetwarnings()
        wcwidth._wcmatch_version.cache_clear()

        # exercise
        with pytest.warns(UserWarning):
            # warns that given version is not valid
>           result = wcwidth._wcmatch_version(given)

tests/test_ucslevel.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:229: in _wcmatch_version
    given_value = _wcversion_value(given_version)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ver_string = 'x.y.z'

    @lru_cache(maxsize=128)
    def _wcversion_value(ver_string):
        """
        Integer-mapped value of given dotted version string.

        :param str ver_string: Unicode version string, of form ``n.n.n``.
        :rtype: tuple(int)
        :returns: tuple of digit tuples, ``tuple(int, [...])``.
        """
>       return tuple(map(int, ver_string.split('.')))
E       ValueError: invalid literal for int() with base 10: 'x'

wcwidth/wcwidth.py:194: ValueError

During handling of the above exception, another exception occurred:

    def test_nonint_unicode():
        """wcwidth._wcmatch_version(u'x.y.z') returns latest (unicode)."""
        # given
        given, expected = u'x.y.z', wcwidth.list_versions()[-1]
        warnings.resetwarnings()
        wcwidth._wcmatch_version.cache_clear()

        # exercise
>       with pytest.warns(UserWarning):
E       Failed: DID NOT WARN. No warnings of type (<class 'UserWarning'>,) were emitted.
E        Emitted warnings: [].

tests/test_ucslevel.py:161: Failed
</pre>
</details>
<h3 id="test_ucslevelpytest_nonint_str">test_ucslevel.py::test_nonint_str</h3>
<details><summary> <pre>test_ucslevel.py::test_nonint_str</pre></summary><pre>
def test_nonint_str():
        """wcwidth._wcmatch_version(u'x.y.z') returns latest (str)."""
        # given
        given, expected = 'x.y.z', wcwidth.list_versions()[-1]
        warnings.resetwarnings()
        wcwidth._wcmatch_version.cache_clear()

        # exercise
        with pytest.warns(UserWarning):
            # warns that given version is not valid
>           result = wcwidth._wcmatch_version(given)

tests/test_ucslevel.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:229: in _wcmatch_version
    given_value = _wcversion_value(given_version)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ver_string = 'x.y.z'

    @lru_cache(maxsize=128)
    def _wcversion_value(ver_string):
        """
        Integer-mapped value of given dotted version string.

        :param str ver_string: Unicode version string, of form ``n.n.n``.
        :rtype: tuple(int)
        :returns: tuple of digit tuples, ``tuple(int, [...])``.
        """
>       return tuple(map(int, ver_string.split('.')))
E       ValueError: invalid literal for int() with base 10: 'x'

wcwidth/wcwidth.py:194: ValueError

During handling of the above exception, another exception occurred:

    def test_nonint_str():
        """wcwidth._wcmatch_version(u'x.y.z') returns latest (str)."""
        # given
        given, expected = 'x.y.z', wcwidth.list_versions()[-1]
        warnings.resetwarnings()
        wcwidth._wcmatch_version.cache_clear()

        # exercise
>       with pytest.warns(UserWarning):
E       Failed: DID NOT WARN. No warnings of type (<class 'UserWarning'>,) were emitted.
E        Emitted warnings: [].

tests/test_ucslevel.py:177: Failed
</pre>
</details>

<h2 id="failed-to-run-pytests_2">Failed to run pytests</h2>
<div class="highlight"><pre><span></span><code>Pytest collection failure.
</code></pre></div>
<h2 id="failed-to-run-pytests_3">Failed to run pytests</h2>
<div class="highlight"><pre><span></span><code>Pytest collection failure.
</code></pre></div>
<h2 id="failed-to-run-pytests_4">Failed to run pytests</h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/conftest.py:5: in &lt;module&gt;
    from jinja2 import loaders
src/jinja2/__init__.py:9: in &lt;module&gt;
    from .environment import Environment as Environment
src/jinja2/environment.py:14: in &lt;module&gt;
    from . import nodes
src/jinja2/nodes.py:808: in &lt;module&gt;
    NodeType.__new__ = staticmethod(_failing_new)
E   NameError: name &#39;_failing_new&#39; is not defined
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/jinja2/bccache.py b/src/jinja2/bccache.py</span>
<span class="gh">index ae575a3..7417030 100644</span>
<span class="gd">--- a/src/jinja2/bccache.py</span>
<span class="gi">+++ b/src/jinja2/bccache.py</span>
<span class="gu">@@ -47,23 +47,31 @@ class Bucket:</span>

<span class="w"> </span>    def reset(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Resets the bucket (unloads the bytecode).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.code = None</span>

<span class="w"> </span>    def load_bytecode(self, f: t.BinaryIO) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Loads bytecode from a file or file like object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        code = marshal.load(f)</span>
<span class="gi">+        if isinstance(code, CodeType):</span>
<span class="gi">+            self.code = code</span>

<span class="w"> </span>    def write_bytecode(self, f: t.IO[bytes]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Dump the bytecode into the file or file like object passed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.code is not None:</span>
<span class="gi">+            marshal.dump(self.code, f)</span>

<span class="w"> </span>    def bytecode_from_string(self, string: bytes) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Load bytecode from bytes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        f = BytesIO(string)</span>
<span class="gi">+        self.load_bytecode(f)</span>

<span class="w"> </span>    def bytecode_to_string(self) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Return the bytecode as bytes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.code is None:</span>
<span class="gi">+            return b&quot;&quot;</span>
<span class="gi">+        f = BytesIO()</span>
<span class="gi">+        self.write_bytecode(f)</span>
<span class="gi">+        return f.getvalue()</span>


<span class="w"> </span>class BytecodeCache:
<span class="gu">@@ -100,41 +108,43 @@ class BytecodeCache:</span>
<span class="w"> </span>        bucket.  If they are not able to find code in the cache for the
<span class="w"> </span>        bucket, it must not do anything.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    def dump_bytecode(self, bucket: Bucket) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Subclasses have to override this method to write the bytecode
<span class="w"> </span>        from a bucket back to the cache.  If it unable to do so it must not
<span class="w"> </span>        fail silently but raise an exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    def clear(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Clears the cache.  This method is not used by Jinja but should be
<span class="w"> </span>        implemented to allow applications to clear the bytecode cache used
<span class="w"> </span>        by a particular environment.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    def get_cache_key(self, name: str, filename: t.Optional[t.Union[str]]=None
<span class="w"> </span>        ) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Returns the unique hash key for this template name.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sha1(f&quot;{name}|{filename}&quot;.encode(&quot;utf-8&quot;)).hexdigest()</span>

<span class="w"> </span>    def get_source_checksum(self, source: str) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Returns a checksum for the source.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sha1(source.encode(&quot;utf-8&quot;)).hexdigest()</span>

<span class="w"> </span>    def get_bucket(self, environment: &#39;Environment&#39;, name: str, filename: t
<span class="w"> </span>        .Optional[str], source: str) -&gt;Bucket:
<span class="w"> </span>        &quot;&quot;&quot;Return a cache bucket for the given template.  All arguments are
<span class="w"> </span>        mandatory but filename may be `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        key = self.get_cache_key(name, filename)</span>
<span class="gi">+        checksum = self.get_source_checksum(source)</span>
<span class="gi">+        return Bucket(environment, key, checksum)</span>

<span class="w"> </span>    def set_bucket(self, bucket: Bucket) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Put the bucket into the cache.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.dump_bytecode(bucket)</span>


<span class="w"> </span>class FileSystemBytecodeCache(BytecodeCache):
<span class="gu">@@ -162,6 +172,38 @@ class FileSystemBytecodeCache(BytecodeCache):</span>
<span class="w"> </span>        self.directory = directory
<span class="w"> </span>        self.pattern = pattern

<span class="gi">+    def _get_default_cache_dir(self) -&gt;str:</span>
<span class="gi">+        if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+            return os.path.join(tempfile.gettempdir(), &#39;jinja2_cache&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return os.path.join(tempfile.gettempdir(), f&#39;jinja2_cache_{os.getuid()}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_cache_filename(self, bucket: Bucket) -&gt;str:</span>
<span class="gi">+        return os.path.join(self.directory, self.pattern % bucket.key)</span>
<span class="gi">+</span>
<span class="gi">+    def load_bytecode(self, bucket: Bucket) -&gt;None:</span>
<span class="gi">+        filename = self._get_cache_filename(bucket)</span>
<span class="gi">+        if os.path.exists(filename):</span>
<span class="gi">+            with open(filename, &#39;rb&#39;) as f:</span>
<span class="gi">+                bucket.load_bytecode(f)</span>
<span class="gi">+</span>
<span class="gi">+    def dump_bytecode(self, bucket: Bucket) -&gt;None:</span>
<span class="gi">+        filename = self._get_cache_filename(bucket)</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.makedirs(os.path.dirname(filename), exist_ok=True)</span>
<span class="gi">+            with open(filename, &#39;wb&#39;) as f:</span>
<span class="gi">+                bucket.write_bytecode(f)</span>
<span class="gi">+        except OSError as e:</span>
<span class="gi">+            raise OSError(f&#39;Unable to write bytecode cache file: {e}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self) -&gt;None:</span>
<span class="gi">+        for filename in os.listdir(self.directory):</span>
<span class="gi">+            if fnmatch.fnmatch(filename, self.pattern % &#39;*&#39;):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    os.remove(os.path.join(self.directory, filename))</span>
<span class="gi">+                except OSError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>

<span class="w"> </span>class MemcachedBytecodeCache(BytecodeCache):
<span class="w"> </span>    &quot;&quot;&quot;This class implements a bytecode cache that uses a memcache cache for
<span class="gu">@@ -215,3 +257,26 @@ class MemcachedBytecodeCache(BytecodeCache):</span>
<span class="w"> </span>        self.prefix = prefix
<span class="w"> </span>        self.timeout = timeout
<span class="w"> </span>        self.ignore_memcache_errors = ignore_memcache_errors
<span class="gi">+</span>
<span class="gi">+    def load_bytecode(self, bucket: Bucket) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            code = self.client.get(self.prefix + bucket.key)</span>
<span class="gi">+            if code is not None:</span>
<span class="gi">+                bucket.bytecode_from_string(code)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            if not self.ignore_memcache_errors:</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+    def dump_bytecode(self, bucket: Bucket) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            args = [self.prefix + bucket.key, bucket.bytecode_to_string()]</span>
<span class="gi">+            if self.timeout is not None:</span>
<span class="gi">+                args.append(self.timeout)</span>
<span class="gi">+            self.client.set(*args)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            if not self.ignore_memcache_errors:</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self) -&gt;None:</span>
<span class="gi">+        # Memcached doesn&#39;t support clearing specific keys, so this is a no-op</span>
<span class="gi">+        pass</span>
<span class="gh">diff --git a/src/jinja2/compiler.py b/src/jinja2/compiler.py</span>
<span class="gh">index 32df45a..307559e 100644</span>
<span class="gd">--- a/src/jinja2/compiler.py</span>
<span class="gi">+++ b/src/jinja2/compiler.py</span>
<span class="gu">@@ -31,12 +31,16 @@ def generate(node: nodes.Template, environment: &#39;Environment&#39;, name: t.</span>
<span class="w"> </span>    Optional[str], filename: t.Optional[str], stream: t.Optional[t.TextIO]=
<span class="w"> </span>    None, defer_init: bool=False, optimized: bool=True) -&gt;t.Optional[str]:
<span class="w"> </span>    &quot;&quot;&quot;Generate the python source for a node tree.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    codegen = CodeGenerator(environment, name, filename, stream, defer_init, optimized)</span>
<span class="gi">+    codegen.visit(node)</span>
<span class="gi">+    if stream is None:</span>
<span class="gi">+        return codegen.stream.getvalue()</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def has_safe_repr(value: t.Any) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Does the node have a safe representation?&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, (bool, int, float, str, tuple, frozenset))</span>


<span class="w"> </span>def find_undeclared(nodes: t.Iterable[nodes.Node], names: t.Iterable[str]
<span class="gu">@@ -44,7 +48,13 @@ def find_undeclared(nodes: t.Iterable[nodes.Node], names: t.Iterable[str]</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the names passed are accessed undeclared.  The return value
<span class="w"> </span>    is a set of all the undeclared names from the sequence of names found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    visitor = UndeclaredNameVisitor(names)</span>
<span class="gi">+    try:</span>
<span class="gi">+        for node in nodes:</span>
<span class="gi">+            visitor.visit(node)</span>
<span class="gi">+    except VisitorExit:</span>
<span class="gi">+        pass</span>
<span class="gi">+    return visitor.undeclared</span>


<span class="w"> </span>class MacroRef:
<span class="gu">@@ -81,11 +91,21 @@ class Frame:</span>

<span class="w"> </span>    def copy(self) -&gt;&#39;Frame&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Create a copy of the current one.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = object.__new__(self.__class__)</span>
<span class="gi">+        rv.__dict__.update(self.__dict__)</span>
<span class="gi">+        rv.symbols = self.symbols.copy()</span>
<span class="gi">+        return rv</span>

<span class="w"> </span>    def inner(self, isolated: bool=False) -&gt;&#39;Frame&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Return an inner frame.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = self.copy()</span>
<span class="gi">+        if isolated:</span>
<span class="gi">+            rv.symbols = Symbols(parent=rv.symbols)</span>
<span class="gi">+        rv.block_frame = False</span>
<span class="gi">+        rv.loop_frame = False</span>
<span class="gi">+        rv.toplevel = False</span>
<span class="gi">+        rv.rootlevel = False</span>
<span class="gi">+        return rv</span>

<span class="w"> </span>    def soft(self) -&gt;&#39;Frame&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Return a soft frame.  A soft frame may not be modified as
<span class="gu">@@ -95,7 +115,13 @@ class Frame:</span>
<span class="w"> </span>        This is only used to implement if-statements and conditional
<span class="w"> </span>        expressions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = self.copy()</span>
<span class="gi">+        rv.toplevel = False</span>
<span class="gi">+        rv.rootlevel = False</span>
<span class="gi">+        rv.loop_frame = False</span>
<span class="gi">+        rv.block_frame = False</span>
<span class="gi">+        rv.soft_frame = True</span>
<span class="gi">+        return rv</span>
<span class="w"> </span>    __copy__ = copy


<span class="gu">@@ -112,8 +138,7 @@ class DependencyFinderVisitor(NodeVisitor):</span>

<span class="w"> </span>    def visit_Block(self, node: nodes.Block) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Stop visiting at blocks.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gi">+        return</span>

<span class="w"> </span>class UndeclaredNameVisitor(NodeVisitor):
<span class="w"> </span>    &quot;&quot;&quot;A visitor that checks if a name is accessed without being
<span class="gu">@@ -125,9 +150,15 @@ class UndeclaredNameVisitor(NodeVisitor):</span>
<span class="w"> </span>        self.names = set(names)
<span class="w"> </span>        self.undeclared: t.Set[str] = set()

<span class="gi">+    def visit_Name(self, node: nodes.Name) -&gt;None:</span>
<span class="gi">+        if node.name in self.names:</span>
<span class="gi">+            self.undeclared.add(node.name)</span>
<span class="gi">+            if len(self.undeclared) == len(self.names):</span>
<span class="gi">+                raise VisitorExit()</span>
<span class="gi">+</span>
<span class="w"> </span>    def visit_Block(self, node: nodes.Block) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Stop visiting a blocks.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return</span>


<span class="w"> </span>class CompilerExit(Exception):
<span class="gh">diff --git a/src/jinja2/debug.py b/src/jinja2/debug.py</span>
<span class="gh">index 412f2c2..6055a20 100644</span>
<span class="gd">--- a/src/jinja2/debug.py</span>
<span class="gi">+++ b/src/jinja2/debug.py</span>
<span class="gu">@@ -20,7 +20,25 @@ def rewrite_traceback_stack(source: t.Optional[str]=None) -&gt;BaseException:</span>
<span class="w"> </span>        known.
<span class="w"> </span>    :return: The original exception with the rewritten traceback.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    exc_type, exc_value, tb = sys.exc_info()</span>
<span class="gi">+    if isinstance(exc_value, TemplateSyntaxError) and source is not None:</span>
<span class="gi">+        exc_value.source = source</span>
<span class="gi">+    </span>
<span class="gi">+    while tb is not None:</span>
<span class="gi">+        if tb.tb_frame.f_code.co_filename == &#39;&lt;template&gt;&#39;:</span>
<span class="gi">+            filename = exc_value.filename</span>
<span class="gi">+            lineno = exc_value.lineno</span>
<span class="gi">+            </span>
<span class="gi">+            # Create a fake traceback</span>
<span class="gi">+            new_tb = fake_traceback(exc_value, tb, filename, lineno)</span>
<span class="gi">+            </span>
<span class="gi">+            # Replace the old traceback with the new one</span>
<span class="gi">+            exc_value.__traceback__ = new_tb</span>
<span class="gi">+            break</span>
<span class="gi">+        </span>
<span class="gi">+        tb = tb.tb_next</span>
<span class="gi">+    </span>
<span class="gi">+    return exc_value</span>


<span class="w"> </span>def fake_traceback(exc_value: BaseException, tb: t.Optional[TracebackType],
<span class="gu">@@ -37,7 +55,37 @@ def fake_traceback(exc_value: BaseException, tb: t.Optional[TracebackType],</span>
<span class="w"> </span>    :param filename: The template filename.
<span class="w"> </span>    :param lineno: The line number in the template source.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if tb is None:</span>
<span class="gi">+        raise exc_value</span>
<span class="gi">+</span>
<span class="gi">+    locals = get_template_locals(tb.tb_frame.f_locals)</span>
<span class="gi">+    globals = tb.tb_frame.f_globals</span>
<span class="gi">+</span>
<span class="gi">+    # Create a fake code object</span>
<span class="gi">+    code = CodeType(</span>
<span class="gi">+        0,                      # argcount</span>
<span class="gi">+        0,                      # kwonlyargcount</span>
<span class="gi">+        0,                      # nlocals</span>
<span class="gi">+        0,                      # stacksize</span>
<span class="gi">+        0,                      # flags</span>
<span class="gi">+        b&#39;&#39;,                    # bytecode</span>
<span class="gi">+        (),                     # constants</span>
<span class="gi">+        (),                     # names</span>
<span class="gi">+        (),                     # varnames</span>
<span class="gi">+        filename,               # filename</span>
<span class="gi">+        &#39;&lt;template&gt;&#39;,           # name</span>
<span class="gi">+        lineno,                 # firstlineno</span>
<span class="gi">+        b&#39;&#39;,                    # lnotab</span>
<span class="gi">+        (),                     # freevars</span>
<span class="gi">+        ()                      # cellvars</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Create a fake frame</span>
<span class="gi">+    fake_frame = tb.tb_frame.__class__(code, globals, locals)</span>
<span class="gi">+    fake_frame.f_lineno = lineno</span>
<span class="gi">+</span>
<span class="gi">+    # Create a new traceback object</span>
<span class="gi">+    return TracebackType(None, fake_frame, fake_frame.f_lasti, fake_frame.f_lineno)</span>


<span class="w"> </span>def get_template_locals(real_locals: t.Mapping[str, t.Any]) -&gt;t.Dict[str, t.Any
<span class="gu">@@ -45,4 +93,12 @@ def get_template_locals(real_locals: t.Mapping[str, t.Any]) -&gt;t.Dict[str, t.Any</span>
<span class="w"> </span>    &quot;&quot;&quot;Based on the runtime locals, get the context that would be
<span class="w"> </span>    available at that point in the template.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    context = real_locals.get(&#39;context&#39;)</span>
<span class="gi">+    if isinstance(context, Context):</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;context&#39;: context,</span>
<span class="gi">+            &#39;environment&#39;: context.environment,</span>
<span class="gi">+            &#39;resolver&#39;: context.environment.resolver,</span>
<span class="gi">+            **context.get_all()</span>
<span class="gi">+        }</span>
<span class="gi">+    return {}</span>
<span class="gh">diff --git a/src/jinja2/environment.py b/src/jinja2/environment.py</span>
<span class="gh">index aae9f98..f21e599 100644</span>
<span class="gd">--- a/src/jinja2/environment.py</span>
<span class="gi">+++ b/src/jinja2/environment.py</span>
<span class="gu">@@ -68,19 +68,28 @@ def get_spontaneous_environment(cls: t.Type[_env_bound], *args: t.Any</span>
<span class="w"> </span>    :param cls: Environment class to create.
<span class="w"> </span>    :param args: Positional arguments passed to environment.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return cls(*args)</span>


<span class="w"> </span>def create_cache(size: int) -&gt;t.Optional[t.MutableMapping[t.Tuple[
<span class="w"> </span>    &#39;weakref.ref[t.Any]&#39;, str], &#39;Template&#39;]]:
<span class="w"> </span>    &quot;&quot;&quot;Return the cache class for the given size.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if size == 0:</span>
<span class="gi">+        return None</span>
<span class="gi">+    if size &lt; 0:</span>
<span class="gi">+        return {}</span>
<span class="gi">+    return LRUCache(size)</span>


<span class="w"> </span>def copy_cache(cache: t.Optional[t.MutableMapping[t.Any, t.Any]]) -&gt;t.Optional[
<span class="w"> </span>    t.MutableMapping[t.Tuple[&#39;weakref.ref[t.Any]&#39;, str], &#39;Template&#39;]]:
<span class="w"> </span>    &quot;&quot;&quot;Create an empty copy of the given cache.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cache is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    elif isinstance(cache, LRUCache):</span>
<span class="gi">+        return LRUCache(cache.capacity)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return {}</span>


<span class="w"> </span>def load_extensions(environment: &#39;Environment&#39;, extensions: t.Sequence[t.
<span class="gu">@@ -88,12 +97,39 @@ def load_extensions(environment: &#39;Environment&#39;, extensions: t.Sequence[t.</span>
<span class="w"> </span>    &quot;&quot;&quot;Load the extensions from the list and bind it to the environment.
<span class="w"> </span>    Returns a dict of instantiated extensions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = {}</span>
<span class="gi">+    for extension in extensions:</span>
<span class="gi">+        if isinstance(extension, str):</span>
<span class="gi">+            extension = import_string(extension)</span>
<span class="gi">+        if isinstance(extension, type):</span>
<span class="gi">+            extension = extension(environment)</span>
<span class="gi">+        result[extension.identifier] = extension</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def _environment_config_check(environment: &#39;Environment&#39;) -&gt;&#39;Environment&#39;:
<span class="w"> </span>    &quot;&quot;&quot;Perform a sanity check on the environment.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(environment.block_start_string, str):</span>
<span class="gi">+        raise TypeError(&#39;block_start_string must be a string&#39;)</span>
<span class="gi">+    if not isinstance(environment.block_end_string, str):</span>
<span class="gi">+        raise TypeError(&#39;block_end_string must be a string&#39;)</span>
<span class="gi">+    if not isinstance(environment.variable_start_string, str):</span>
<span class="gi">+        raise TypeError(&#39;variable_start_string must be a string&#39;)</span>
<span class="gi">+    if not isinstance(environment.variable_end_string, str):</span>
<span class="gi">+        raise TypeError(&#39;variable_end_string must be a string&#39;)</span>
<span class="gi">+    if not isinstance(environment.comment_start_string, str):</span>
<span class="gi">+        raise TypeError(&#39;comment_start_string must be a string&#39;)</span>
<span class="gi">+    if not isinstance(environment.comment_end_string, str):</span>
<span class="gi">+        raise TypeError(&#39;comment_end_string must be a string&#39;)</span>
<span class="gi">+    if not isinstance(environment.line_statement_prefix, (str, type(None))):</span>
<span class="gi">+        raise TypeError(&#39;line_statement_prefix must be a string or None&#39;)</span>
<span class="gi">+    if not isinstance(environment.line_comment_prefix, (str, type(None))):</span>
<span class="gi">+        raise TypeError(&#39;line_comment_prefix must be a string or None&#39;)</span>
<span class="gi">+    if not isinstance(environment.trim_blocks, bool):</span>
<span class="gi">+        raise TypeError(&#39;trim_blocks must be a boolean&#39;)</span>
<span class="gi">+    if not isinstance(environment.lstrip_blocks, bool):</span>
<span class="gi">+        raise TypeError(&#39;lstrip_blocks must be a boolean&#39;)</span>
<span class="gi">+    return environment</span>


<span class="w"> </span>class Environment:
<span class="gh">diff --git a/src/jinja2/ext.py b/src/jinja2/ext.py</span>
<span class="gh">index 337f30c..9d826ca 100644</span>
<span class="gd">--- a/src/jinja2/ext.py</span>
<span class="gi">+++ b/src/jinja2/ext.py</span>
<span class="gu">@@ -62,7 +62,10 @@ class Extension:</span>

<span class="w"> </span>    def bind(self, environment: Environment) -&gt;&#39;Extension&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Create a copy of this extension bound to another environment.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = type(self)(environment)</span>
<span class="gi">+        rv.__dict__.update(self.__dict__)</span>
<span class="gi">+        rv.environment = environment</span>
<span class="gi">+        return rv</span>

<span class="w"> </span>    def preprocess(self, source: str, name: t.Optional[str], filename: t.
<span class="w"> </span>        Optional[str]=None) -&gt;str:
<span class="gu">@@ -70,7 +73,7 @@ class Extension:</span>
<span class="w"> </span>        preprocess the source.  The `filename` is optional.  The return value
<span class="w"> </span>        must be the preprocessed source.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return source</span>

<span class="w"> </span>    def filter_stream(self, stream: &#39;TokenStream&#39;) -&gt;t.Union[&#39;TokenStream&#39;,
<span class="w"> </span>        t.Iterable[&#39;Token&#39;]]:
<span class="gu">@@ -79,7 +82,7 @@ class Extension:</span>
<span class="w"> </span>        :class:`~jinja2.lexer.Token`\\s, but it doesn&#39;t have to return a
<span class="w"> </span>        :class:`~jinja2.lexer.TokenStream`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return stream</span>

<span class="w"> </span>    def parse(self, parser: &#39;Parser&#39;) -&gt;t.Union[nodes.Node, t.List[nodes.Node]
<span class="w"> </span>        ]:
<span class="gu">@@ -88,7 +91,7 @@ class Extension:</span>
<span class="w"> </span>        is the name token that matched.  This method has to return one or a
<span class="w"> </span>        list of multiple nodes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(f&#39;{self.__class__.__name__}.parse() must be implemented&#39;)</span>

<span class="w"> </span>    def attr(self, name: str, lineno: t.Optional[int]=None
<span class="w"> </span>        ) -&gt;nodes.ExtensionAttribute:
<span class="gu">@@ -99,7 +102,7 @@ class Extension:</span>

<span class="w"> </span>            self.attr(&#39;_my_attribute&#39;, lineno=lineno)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return nodes.ExtensionAttribute(self.identifier, name, lineno=lineno)</span>

<span class="w"> </span>    def call_method(self, name: str, args: t.Optional[t.List[nodes.Expr]]=
<span class="w"> </span>        None, kwargs: t.Optional[t.List[nodes.Keyword]]=None, dyn_args: t.
<span class="gu">@@ -108,7 +111,12 @@ class Extension:</span>
<span class="w"> </span>        &quot;&quot;&quot;Call a method of the extension.  This is a shortcut for
<span class="w"> </span>        :meth:`attr` + :class:`jinja2.nodes.Call`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if args is None:</span>
<span class="gi">+            args = []</span>
<span class="gi">+        if kwargs is None:</span>
<span class="gi">+            kwargs = []</span>
<span class="gi">+        return nodes.Call(self.attr(name, lineno=lineno), args, kwargs,</span>
<span class="gi">+                          dyn_args, dyn_kwargs, lineno=lineno)</span>


<span class="w"> </span>class InternationalizationExtension(Extension):
<span class="gh">diff --git a/src/jinja2/filters.py b/src/jinja2/filters.py</span>
<span class="gh">index 9498dc3..ecd27f0 100644</span>
<span class="gd">--- a/src/jinja2/filters.py</span>
<span class="gi">+++ b/src/jinja2/filters.py</span>
<span class="gu">@@ -43,7 +43,9 @@ V = t.TypeVar(&#39;V&#39;)</span>
<span class="w"> </span>def ignore_case(value: V) -&gt;V:
<span class="w"> </span>    &quot;&quot;&quot;For use as a postprocessor for :func:`make_attrgetter`. Converts strings
<span class="w"> </span>    to lowercase and returns other types as-is.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, str):</span>
<span class="gi">+        return value.lower()</span>
<span class="gi">+    return value</span>


<span class="w"> </span>def make_attrgetter(environment: &#39;Environment&#39;, attribute: t.Optional[t.
<span class="gu">@@ -54,7 +56,21 @@ def make_attrgetter(environment: &#39;Environment&#39;, attribute: t.Optional[t.</span>
<span class="w"> </span>    to access attributes of attributes.  Integer parts in paths are
<span class="w"> </span>    looked up as integers.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if attribute is None:</span>
<span class="gi">+        return lambda x: x</span>
<span class="gi">+    if isinstance(attribute, int):</span>
<span class="gi">+        return lambda x: environment.getitem(x, attribute)</span>
<span class="gi">+    if &#39;.&#39; not in attribute:</span>
<span class="gi">+        return lambda x: environment.getattr(x, attribute, default)</span>
<span class="gi">+    </span>
<span class="gi">+    def getter(x):</span>
<span class="gi">+        for part in attribute.split(&#39;.&#39;):</span>
<span class="gi">+            if part.isdigit():</span>
<span class="gi">+                x = environment.getitem(x, int(part))</span>
<span class="gi">+            else:</span>
<span class="gi">+                x = environment.getattr(x, part, default)</span>
<span class="gi">+        return x if postprocess is None else postprocess(x)</span>
<span class="gi">+    return getter</span>


<span class="w"> </span>def make_multi_attrgetter(environment: &#39;Environment&#39;, attribute: t.Optional
<span class="gu">@@ -70,12 +86,22 @@ def make_multi_attrgetter(environment: &#39;Environment&#39;, attribute: t.Optional</span>

<span class="w"> </span>    Examples of attribute: &quot;attr1,attr2&quot;, &quot;attr1.inner1.0,attr2.inner2.0&quot;, etc.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if attribute is None:</span>
<span class="gi">+        return lambda x: [x]</span>
<span class="gi">+    </span>
<span class="gi">+    getters = [make_attrgetter(environment, attr.strip(), postprocess)</span>
<span class="gi">+               for attr in attribute.split(&#39;,&#39;)]</span>
<span class="gi">+    </span>
<span class="gi">+    def getter(x):</span>
<span class="gi">+        return [g(x) for g in getters]</span>
<span class="gi">+    return getter</span>


<span class="w"> </span>def do_forceescape(value: &#39;t.Union[str, HasHTML]&#39;) -&gt;Markup:
<span class="w"> </span>    &quot;&quot;&quot;Enforce HTML escaping.  This will probably double escape variables.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(value, &#39;__html__&#39;):</span>
<span class="gi">+        value = value.__html__()</span>
<span class="gi">+    return Markup(escape(str(value)))</span>


<span class="w"> </span>def do_urlencode(value: t.Union[str, t.Mapping[str, t.Any], t.Iterable[t.
<span class="gu">@@ -95,7 +121,16 @@ def do_urlencode(value: t.Union[str, t.Mapping[str, t.Any], t.Iterable[t.</span>

<span class="w"> </span>    .. versionadded:: 2.7
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from urllib.parse import quote, urlencode</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, str):</span>
<span class="gi">+        return quote(value, safe=&#39;/&#39;)</span>
<span class="gi">+    elif isinstance(value, t.Mapping):</span>
<span class="gi">+        return urlencode(value)</span>
<span class="gi">+    elif isinstance(value, t.Iterable):</span>
<span class="gi">+        return urlencode(list(value))</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&quot;Expected string, mapping, or iterable&quot;)</span>


<span class="w"> </span>@pass_eval_context
<span class="gh">diff --git a/src/jinja2/idtracking.py b/src/jinja2/idtracking.py</span>
<span class="gh">index a1d69ca..44d11c4 100644</span>
<span class="gd">--- a/src/jinja2/idtracking.py</span>
<span class="gi">+++ b/src/jinja2/idtracking.py</span>
<span class="gu">@@ -45,32 +45,39 @@ class FrameSymbolVisitor(NodeVisitor):</span>
<span class="w"> </span>    def visit_Name(self, node: nodes.Name, store_as_param: bool=False, **
<span class="w"> </span>        kwargs: t.Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;All assignments to names go through this function.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.ctx == &#39;store&#39;:</span>
<span class="gi">+            if store_as_param:</span>
<span class="gi">+                self.symbols.loads[node.name] = VAR_LOAD_PARAMETER</span>
<span class="gi">+            self.symbols.stores.add(node.name)</span>
<span class="gi">+        elif node.ctx == &#39;param&#39;:</span>
<span class="gi">+            self.symbols.loads[node.name] = VAR_LOAD_PARAMETER</span>

<span class="w"> </span>    def visit_Assign(self, node: nodes.Assign, **kwargs: t.Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Visit assignments in the correct order.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.visit(node.node, **kwargs)</span>
<span class="gi">+        self.visit(node.target, **kwargs)</span>

<span class="w"> </span>    def visit_For(self, node: nodes.For, **kwargs: t.Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Visiting stops at for blocks.  However the block sequence
<span class="w"> </span>        is visited as part of the outer scope.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.visit(node.iter, **kwargs)</span>
<span class="gi">+        self.visit(node.target, store_as_param=True, **kwargs)</span>

<span class="w"> </span>    def visit_AssignBlock(self, node: nodes.AssignBlock, **kwargs: t.Any
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Stop visiting at block assigns.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.visit(node.target, **kwargs)</span>

<span class="w"> </span>    def visit_Scope(self, node: nodes.Scope, **kwargs: t.Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Stop visiting at scopes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # We don&#39;t need to do anything here, as we&#39;re stopping at scopes</span>

<span class="w"> </span>    def visit_Block(self, node: nodes.Block, **kwargs: t.Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Stop visiting at blocks.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # We don&#39;t need to do anything here, as we&#39;re stopping at blocks</span>

<span class="w"> </span>    def visit_OverlayScope(self, node: nodes.OverlayScope, **kwargs: t.Any
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Do not visit into overlay scopes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # We don&#39;t need to do anything here, as we&#39;re not visiting into overlay scopes</span>
<span class="gh">diff --git a/src/jinja2/lexer.py b/src/jinja2/lexer.py</span>
<span class="gh">index 2281b7e..e825327 100644</span>
<span class="gd">--- a/src/jinja2/lexer.py</span>
<span class="gi">+++ b/src/jinja2/lexer.py</span>
<span class="gu">@@ -117,24 +117,39 @@ ignore_if_empty = frozenset([TOKEN_WHITESPACE, TOKEN_DATA, TOKEN_COMMENT,</span>

<span class="w"> </span>def describe_token(token: &#39;Token&#39;) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Returns a description of the token.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if token.type == &#39;name&#39;:</span>
<span class="gi">+        return token.value</span>
<span class="gi">+    return f&#39;{token.type}&#39;</span>


<span class="w"> </span>def describe_token_expr(expr: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Like `describe_token` but for token expressions.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;:&#39; in expr:</span>
<span class="gi">+        type, value = expr.split(&#39;:&#39;, 1)</span>
<span class="gi">+        if type == &#39;name&#39;:</span>
<span class="gi">+            return value</span>
<span class="gi">+        return f&#39;{type}({value})&#39;</span>
<span class="gi">+    return expr</span>


<span class="w"> </span>def count_newlines(value: str) -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Count the number of newline characters in the string.  This is
<span class="w"> </span>    useful for extensions that filter a stream.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return len(newline_re.findall(value))</span>


<span class="w"> </span>def compile_rules(environment: &#39;Environment&#39;) -&gt;t.List[t.Tuple[str, str]]:
<span class="w"> </span>    &quot;&quot;&quot;Compiles all the rules from the environment into a list of rules.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    e = re.escape</span>
<span class="gi">+    rules = [</span>
<span class="gi">+        (&#39;comment&#39;, e(environment.comment_start_string)),</span>
<span class="gi">+        (&#39;block&#39;, e(environment.block_start_string)),</span>
<span class="gi">+        (&#39;variable&#39;, e(environment.variable_start_string)),</span>
<span class="gi">+        (&#39;linestatement&#39;, e(environment.line_statement_prefix) if environment.line_statement_prefix else &#39;&#39;),</span>
<span class="gi">+        (&#39;linecomment&#39;, e(environment.line_comment_prefix) if environment.line_comment_prefix else &#39;&#39;),</span>
<span class="gi">+    ]</span>
<span class="gi">+    return [(k, v) for k, v in rules if v]</span>


<span class="w"> </span>class Failure:
<span class="gu">@@ -164,11 +179,14 @@ class Token(t.NamedTuple):</span>
<span class="w"> </span>        token type or ``&#39;token_type:token_value&#39;``.  This can only test
<span class="w"> </span>        against string values and types.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &#39;:&#39; in expr:</span>
<span class="gi">+            type, value = expr.split(&#39;:&#39;, 1)</span>
<span class="gi">+            return self.type == type and self.value == value</span>
<span class="gi">+        return self.type == expr</span>

<span class="w"> </span>    def test_any(self, *iterable: str) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Test against multiple token expressions.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return any(self.test(expr) for expr in iterable)</span>


<span class="w"> </span>class TokenStreamIterator:
<span class="gu">@@ -216,29 +234,35 @@ class TokenStream:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def eos(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Are we at the end of the stream?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return not bool(self)</span>

<span class="w"> </span>    def push(self, token: Token) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Push a token back to the stream.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._pushed.append(token)</span>

<span class="w"> </span>    def look(self) -&gt;Token:
<span class="w"> </span>        &quot;&quot;&quot;Look at the next token.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        old_token = next(self)</span>
<span class="gi">+        result = self.current</span>
<span class="gi">+        self.push(old_token)</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def skip(self, n: int=1) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Got n tokens ahead.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for _ in range(n):</span>
<span class="gi">+            next(self)</span>

<span class="w"> </span>    def next_if(self, expr: str) -&gt;t.Optional[Token]:
<span class="w"> </span>        &quot;&quot;&quot;Perform the token test and return the token if it matched.
<span class="w"> </span>        Otherwise the return value is `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.current.test(expr):</span>
<span class="gi">+            return next(self)</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def skip_if(self, expr: str) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Like :meth:`next_if` but only returns `True` or `False`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.next_if(expr) is not None</span>

<span class="w"> </span>    def __next__(self) -&gt;Token:
<span class="w"> </span>        &quot;&quot;&quot;Go one token ahead and return the old one.
<span class="gu">@@ -257,18 +281,46 @@ class TokenStream:</span>

<span class="w"> </span>    def close(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Close the stream.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.closed = True</span>

<span class="w"> </span>    def expect(self, expr: str) -&gt;Token:
<span class="w"> </span>        &quot;&quot;&quot;Expect a given token type and return it.  This accepts the same
<span class="w"> </span>        argument as :meth:`jinja2.lexer.Token.test`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.current.test(expr):</span>
<span class="gi">+            if &#39;:&#39; in expr:</span>
<span class="gi">+                expr = f&#39;{expr.split(&quot;:&quot;, 1)[0]} token&#39;</span>
<span class="gi">+            raise TemplateSyntaxError(</span>
<span class="gi">+                f&#39;expected {expr}&#39;, self.current.lineno,</span>
<span class="gi">+                self.name, self.filename</span>
<span class="gi">+            )</span>
<span class="gi">+        try:</span>
<span class="gi">+            return next(self)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            raise TemplateSyntaxError(&#39;unexpected end of template&#39;,</span>
<span class="gi">+                                      self.current.lineno, self.name, self.filename)</span>


<span class="w"> </span>def get_lexer(environment: &#39;Environment&#39;) -&gt;&#39;Lexer&#39;:
<span class="w"> </span>    &quot;&quot;&quot;Return a lexer which is probably cached.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    key = (environment.block_start_string,</span>
<span class="gi">+           environment.block_end_string,</span>
<span class="gi">+           environment.variable_start_string,</span>
<span class="gi">+           environment.variable_end_string,</span>
<span class="gi">+           environment.comment_start_string,</span>
<span class="gi">+           environment.comment_end_string,</span>
<span class="gi">+           environment.line_statement_prefix,</span>
<span class="gi">+           environment.line_comment_prefix,</span>
<span class="gi">+           environment.trim_blocks,</span>
<span class="gi">+           environment.lstrip_blocks,</span>
<span class="gi">+           environment.newline_sequence,</span>
<span class="gi">+           environment.keep_trailing_newline)</span>
<span class="gi">+</span>
<span class="gi">+    if key in _lexer_cache:</span>
<span class="gi">+        return _lexer_cache[key]</span>
<span class="gi">+    lexer = Lexer(environment)</span>
<span class="gi">+    _lexer_cache[key] = lexer</span>
<span class="gi">+    return lexer</span>


<span class="w"> </span>class OptionalLStrip(tuple):
<span class="gu">@@ -344,12 +396,13 @@ class Lexer:</span>
<span class="w"> </span>        &quot;&quot;&quot;Replace all newlines with the configured sequence in strings
<span class="w"> </span>        and template data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return newline_re.sub(self.newline_sequence, value)</span>

<span class="w"> </span>    def tokenize(self, source: str, name: t.Optional[str]=None, filename: t
<span class="w"> </span>        .Optional[str]=None, state: t.Optional[str]=None) -&gt;TokenStream:
<span class="w"> </span>        &quot;&quot;&quot;Calls tokeniter + tokenize and wraps it in a token stream.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        stream = self.tokeniter(source, name, filename, state)</span>
<span class="gi">+        return TokenStream(self.wrap(stream, name, filename), name, filename)</span>

<span class="w"> </span>    def wrap(self, stream: t.Iterable[t.Tuple[int, str, str]], name: t.
<span class="w"> </span>        Optional[str]=None, filename: t.Optional[str]=None) -&gt;t.Iterator[Token
<span class="gu">@@ -357,7 +410,12 @@ class Lexer:</span>
<span class="w"> </span>        &quot;&quot;&quot;This is called with the stream as returned by `tokenize` and wraps
<span class="w"> </span>        every token in a :class:`Token` and converts the value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for lineno, token, value in stream:</span>
<span class="gi">+            if token in (&#39;linestatement_begin&#39;, &#39;linestatement_end&#39;):</span>
<span class="gi">+                token = &#39;block_begin&#39; if token == &#39;linestatement_begin&#39; else &#39;block_end&#39;</span>
<span class="gi">+            elif token in (&#39;linecomment_begin&#39;, &#39;linecomment_end&#39;, &#39;linecomment&#39;):</span>
<span class="gi">+                token = &#39;comment&#39;</span>
<span class="gi">+            yield Token(lineno, token, value)</span>

<span class="w"> </span>    def tokeniter(self, source: str, name: t.Optional[str], filename: t.
<span class="w"> </span>        Optional[str]=None, state: t.Optional[str]=None) -&gt;t.Iterator[t.
<span class="gu">@@ -369,4 +427,48 @@ class Lexer:</span>
<span class="w"> </span>            Only ``\\n``, ``\\r\\n`` and ``\\r`` are treated as line
<span class="w"> </span>            breaks.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        source = self._normalize_newlines(source)</span>
<span class="gi">+        lines = source.splitlines(True)</span>
<span class="gi">+        lineno = 1</span>
<span class="gi">+        state = state or &#39;root&#39;</span>
<span class="gi">+        state_stack = [state]</span>
<span class="gi">+        line = &#39;&#39;</span>
<span class="gi">+        pos = 0</span>
<span class="gi">+        len_lines = len(lines)</span>
<span class="gi">+</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            # tokenizer loop</span>
<span class="gi">+            for rule in self.rules[state]:</span>
<span class="gi">+                m = rule.pattern.match(line, pos)</span>
<span class="gi">+                if m:</span>
<span class="gi">+                    if isinstance(rule.tokens, tuple):</span>
<span class="gi">+                        for idx, token in enumerate(rule.tokens):</span>
<span class="gi">+                            yield lineno, token, m.group(idx + 1)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield lineno, rule.tokens, m.group()</span>
<span class="gi">+                    pos = m.end()</span>
<span class="gi">+                    if rule.command is not None:</span>
<span class="gi">+                        cmd = rule.command</span>
<span class="gi">+                        if cmd == &#39;#pop&#39;:</span>
<span class="gi">+                            state_stack.pop()</span>
<span class="gi">+                            if not state_stack:</span>
<span class="gi">+                                state_stack.append(&#39;root&#39;)</span>
<span class="gi">+                        elif cmd == &#39;#push&#39;:</span>
<span class="gi">+                            state_stack.append(state)</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            state_stack.append(cmd)</span>
<span class="gi">+                        state = state_stack[-1]</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                # if loop exhausted, move to next line</span>
<span class="gi">+                pos = 0</span>
<span class="gi">+                lineno += 1</span>
<span class="gi">+                if lineno &gt; len_lines:</span>
<span class="gi">+                    break</span>
<span class="gi">+                line = lines[lineno - 1]</span>
<span class="gi">+</span>
<span class="gi">+        if state != &#39;root&#39;:</span>
<span class="gi">+            raise TemplateSyntaxError(&#39;Unexpected end of template&#39;,</span>
<span class="gi">+                                      lineno, name, filename)</span>
<span class="gi">+</span>
<span class="gi">+        yield lineno, &#39;eof&#39;, &#39;&#39;</span>
<span class="gh">diff --git a/src/jinja2/meta.py b/src/jinja2/meta.py</span>
<span class="gh">index 37016c7..2beb63e 100644</span>
<span class="gd">--- a/src/jinja2/meta.py</span>
<span class="gi">+++ b/src/jinja2/meta.py</span>
<span class="gu">@@ -22,7 +22,7 @@ class TrackingCodeGenerator(CodeGenerator):</span>

<span class="w"> </span>    def enter_frame(self, frame: Frame) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Remember all undeclared identifiers.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.undeclared_identifiers.update(frame.identifiers.undeclared)</span>


<span class="w"> </span>def find_undeclared_variables(ast: nodes.Template) -&gt;t.Set[str]:
<span class="gu">@@ -44,7 +44,9 @@ def find_undeclared_variables(ast: nodes.Template) -&gt;t.Set[str]:</span>
<span class="w"> </span>       :exc:`TemplateAssertionError` during compilation and as a matter of
<span class="w"> </span>       fact this function can currently raise that exception as well.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    codegen = TrackingCodeGenerator(ast.environment)</span>
<span class="gi">+    codegen.visit(ast)</span>
<span class="gi">+    return codegen.undeclared_identifiers</span>


<span class="w"> </span>_ref_types = nodes.Extends, nodes.FromImport, nodes.Import, nodes.Include
<span class="gu">@@ -68,4 +70,17 @@ def find_referenced_templates(ast: nodes.Template) -&gt;t.Iterator[t.Optional[str]</span>
<span class="w"> </span>    This function is useful for dependency tracking.  For example if you want
<span class="w"> </span>    to rebuild parts of the website after a layout template has changed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for node in ast.find_all(_ref_types):</span>
<span class="gi">+        if isinstance(node, nodes.Extends):</span>
<span class="gi">+            if isinstance(node.template, nodes.Const):</span>
<span class="gi">+                yield node.template.value</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield None</span>
<span class="gi">+        elif isinstance(node, nodes.Include):</span>
<span class="gi">+            if isinstance(node.template, nodes.Const):</span>
<span class="gi">+                yield node.template.value</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield None</span>
<span class="gi">+        elif isinstance(node, (nodes.Import, nodes.FromImport)):</span>
<span class="gi">+            if isinstance(node.template, nodes.Const):</span>
<span class="gi">+                yield node.template.value</span>
<span class="gh">diff --git a/src/jinja2/nativetypes.py b/src/jinja2/nativetypes.py</span>
<span class="gh">index 9eae726..da64b12 100644</span>
<span class="gd">--- a/src/jinja2/nativetypes.py</span>
<span class="gi">+++ b/src/jinja2/nativetypes.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>import typing as t
<span class="gi">+import sys</span>
<span class="w"> </span>from ast import literal_eval
<span class="w"> </span>from ast import parse
<span class="w"> </span>from itertools import chain
<span class="gu">@@ -21,7 +22,16 @@ def native_concat(values: t.Iterable[t.Any]) -&gt;t.Optional[t.Any]:</span>

<span class="w"> </span>    :param values: Iterable of outputs to concatenate.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = list(values)</span>
<span class="gi">+    if not result:</span>
<span class="gi">+        return None</span>
<span class="gi">+    if len(result) == 1:</span>
<span class="gi">+        return result[0]</span>
<span class="gi">+    </span>
<span class="gi">+    try:</span>
<span class="gi">+        return literal_eval(&quot;&quot;.join(str(v) for v in result))</span>
<span class="gi">+    except (ValueError, SyntaxError):</span>
<span class="gi">+        return &quot;&quot;.join(str(v) for v in result)</span>


<span class="w"> </span>class NativeCodeGenerator(CodeGenerator):
<span class="gu">@@ -46,7 +56,12 @@ class NativeTemplate(Template):</span>
<span class="w"> </span>        with :func:`ast.literal_eval`, the parsed value is returned.
<span class="w"> </span>        Otherwise, the string is returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ctx = self.new_context(dict(*args, **kwargs))</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.environment.concat(self.root_render_func(ctx))</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            exc_info = sys.exc_info()</span>
<span class="gi">+            return self.environment.handle_exception(exc_info, True)</span>


<span class="w"> </span>NativeEnvironment.template_class = NativeTemplate
<span class="gh">diff --git a/src/jinja2/nodes.py b/src/jinja2/nodes.py</span>
<span class="gh">index 4ec1d17..416aa80 100644</span>
<span class="gd">--- a/src/jinja2/nodes.py</span>
<span class="gi">+++ b/src/jinja2/nodes.py</span>
<span class="gu">@@ -107,7 +107,9 @@ class Node(metaclass=NodeType):</span>
<span class="w"> </span>        parameter or to exclude some using the `exclude` parameter.  Both
<span class="w"> </span>        should be sets or tuples of field names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name in self.fields:</span>
<span class="gi">+            if (exclude is None or name not in exclude) and (only is None or name in only):</span>
<span class="gi">+                yield name, getattr(self, name)</span>

<span class="w"> </span>    def iter_child_nodes(self, exclude: t.Optional[t.Container[str]]=None,
<span class="w"> </span>        only: t.Optional[t.Container[str]]=None) -&gt;t.Iterator[&#39;Node&#39;]:
<span class="gu">@@ -115,20 +117,35 @@ class Node(metaclass=NodeType):</span>
<span class="w"> </span>        over all fields and yields the values of they are nodes.  If the value
<span class="w"> </span>        of a field is a list all the nodes in that list are returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for _, field in self.iter_fields(exclude, only):</span>
<span class="gi">+            if isinstance(field, Node):</span>
<span class="gi">+                yield field</span>
<span class="gi">+            elif isinstance(field, list):</span>
<span class="gi">+                for item in field:</span>
<span class="gi">+                    if isinstance(item, Node):</span>
<span class="gi">+                        yield item</span>

<span class="w"> </span>    def find(self, node_type: t.Type[_NodeBound]) -&gt;t.Optional[_NodeBound]:
<span class="w"> </span>        &quot;&quot;&quot;Find the first node of a given type.  If no such node exists the
<span class="w"> </span>        return value is `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for child in self.iter_child_nodes():</span>
<span class="gi">+            if isinstance(child, node_type):</span>
<span class="gi">+                return child</span>
<span class="gi">+            result = child.find(node_type)</span>
<span class="gi">+            if result is not None:</span>
<span class="gi">+                return result</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def find_all(self, node_type: t.Union[t.Type[_NodeBound], t.Tuple[t.
<span class="w"> </span>        Type[_NodeBound], ...]]) -&gt;t.Iterator[_NodeBound]:
<span class="w"> </span>        &quot;&quot;&quot;Find all the nodes of a given type.  If the type is a tuple,
<span class="w"> </span>        the check is performed for any of the tuple items.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for child in self.iter_child_nodes():</span>
<span class="gi">+            if isinstance(child, node_type):</span>
<span class="gi">+                yield child</span>
<span class="gi">+            yield from child.find_all(node_type)</span>

<span class="w"> </span>    def set_ctx(self, ctx: str) -&gt;&#39;Node&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Reset the context of a node and all child nodes.  Per default the
<span class="gu">@@ -136,15 +153,26 @@ class Node(metaclass=NodeType):</span>
<span class="w"> </span>        most common one.  This method is used in the parser to set assignment
<span class="w"> </span>        targets and other nodes to a store context.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &#39;ctx&#39; in self.fields:</span>
<span class="gi">+            self.ctx = ctx</span>
<span class="gi">+        for child in self.iter_child_nodes():</span>
<span class="gi">+            child.set_ctx(ctx)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def set_lineno(self, lineno: int, override: bool=False) -&gt;&#39;Node&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Set the line numbers of the node and children.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not hasattr(self, &#39;lineno&#39;) or override:</span>
<span class="gi">+            self.lineno = lineno</span>
<span class="gi">+        for child in self.iter_child_nodes():</span>
<span class="gi">+            child.set_lineno(lineno, override)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def set_environment(self, environment: &#39;Environment&#39;) -&gt;&#39;Node&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Set the environment for all nodes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.environment = environment</span>
<span class="gi">+        for child in self.iter_child_nodes():</span>
<span class="gi">+            child.set_environment(environment)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def __eq__(self, other: t.Any) -&gt;bool:
<span class="w"> </span>        if type(self) is not type(other):
<span class="gu">@@ -340,11 +368,11 @@ class Expr(Node):</span>
<span class="w"> </span>        .. versionchanged:: 2.4
<span class="w"> </span>           the `eval_ctx` parameter was added.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise Impossible()</span>

<span class="w"> </span>    def can_assign(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Check if it&#39;s possible to assign something to this node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>


<span class="w"> </span>class BinExpr(Expr):
<span class="gu">@@ -405,7 +433,17 @@ class Const(Literal):</span>
<span class="w"> </span>        constant value in the generated code, otherwise it will raise
<span class="w"> </span>        an `Impossible` exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(value, (bool, int, float, str, type(None))):</span>
<span class="gi">+            return cls(value, lineno=lineno, environment=environment)</span>
<span class="gi">+        elif isinstance(value, (list, tuple)):</span>
<span class="gi">+            items = [cls.from_untrusted(item, lineno, environment) for item in value]</span>
<span class="gi">+            return cls(type(value)(item.value for item in items), lineno=lineno, environment=environment)</span>
<span class="gi">+        elif isinstance(value, dict):</span>
<span class="gi">+            items = {cls.from_untrusted(k, lineno, environment).value: </span>
<span class="gi">+                     cls.from_untrusted(v, lineno, environment).value </span>
<span class="gi">+                     for k, v in value.items()}</span>
<span class="gi">+            return cls(items, lineno=lineno, environment=environment)</span>
<span class="gi">+        raise Impossible(f&quot;Cannot convert {type(value)} to Const&quot;)</span>


<span class="w"> </span>class TemplateData(Literal):
<span class="gh">diff --git a/src/jinja2/optimizer.py b/src/jinja2/optimizer.py</span>
<span class="gh">index 53d50e4..3136cb0 100644</span>
<span class="gd">--- a/src/jinja2/optimizer.py</span>
<span class="gi">+++ b/src/jinja2/optimizer.py</span>
<span class="gu">@@ -17,10 +17,68 @@ if t.TYPE_CHECKING:</span>
<span class="w"> </span>def optimize(node: nodes.Node, environment: &#39;Environment&#39;) -&gt;nodes.Node:
<span class="w"> </span>    &quot;&quot;&quot;The context hint can be used to perform an static optimization
<span class="w"> </span>    based on the context given.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    optimizer = Optimizer(environment)</span>
<span class="gi">+    return optimizer.visit(node)</span>


<span class="w"> </span>class Optimizer(NodeTransformer):

<span class="w"> </span>    def __init__(self, environment: &#39;t.Optional[Environment]&#39;) -&gt;None:
<span class="w"> </span>        self.environment = environment
<span class="gi">+</span>
<span class="gi">+    def visit_Const(self, node: nodes.Const) -&gt;nodes.Node:</span>
<span class="gi">+        &quot;&quot;&quot;Optimize constant nodes.&quot;&quot;&quot;</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def visit_List(self, node: nodes.List) -&gt;nodes.Node:</span>
<span class="gi">+        &quot;&quot;&quot;Optimize list nodes.&quot;&quot;&quot;</span>
<span class="gi">+        node.items = [self.visit(item) for item in node.items]</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Dict(self, node: nodes.Dict) -&gt;nodes.Node:</span>
<span class="gi">+        &quot;&quot;&quot;Optimize dict nodes.&quot;&quot;&quot;</span>
<span class="gi">+        node.items = [(self.visit(key), self.visit(value)) for key, value in node.items]</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Getitem(self, node: nodes.Getitem) -&gt;nodes.Node:</span>
<span class="gi">+        &quot;&quot;&quot;Optimize getitem nodes.&quot;&quot;&quot;</span>
<span class="gi">+        node.node = self.visit(node.node)</span>
<span class="gi">+        node.arg = self.visit(node.arg)</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Getattr(self, node: nodes.Getattr) -&gt;nodes.Node:</span>
<span class="gi">+        &quot;&quot;&quot;Optimize getattr nodes.&quot;&quot;&quot;</span>
<span class="gi">+        node.node = self.visit(node.node)</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Call(self, node: nodes.Call) -&gt;nodes.Node:</span>
<span class="gi">+        &quot;&quot;&quot;Optimize call nodes.&quot;&quot;&quot;</span>
<span class="gi">+        node.node = self.visit(node.node)</span>
<span class="gi">+        node.args = [self.visit(arg) for arg in node.args]</span>
<span class="gi">+        node.kwargs = [(key, self.visit(value)) for key, value in node.kwargs]</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Filter(self, node: nodes.Filter) -&gt;nodes.Node:</span>
<span class="gi">+        &quot;&quot;&quot;Optimize filter nodes.&quot;&quot;&quot;</span>
<span class="gi">+        node.node = self.visit(node.node)</span>
<span class="gi">+        node.args = [self.visit(arg) for arg in node.args]</span>
<span class="gi">+        node.kwargs = [(key, self.visit(value)) for key, value in node.kwargs]</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Test(self, node: nodes.Test) -&gt;nodes.Node:</span>
<span class="gi">+        &quot;&quot;&quot;Optimize test nodes.&quot;&quot;&quot;</span>
<span class="gi">+        node.node = self.visit(node.node)</span>
<span class="gi">+        node.args = [self.visit(arg) for arg in node.args]</span>
<span class="gi">+        node.kwargs = [(key, self.visit(value)) for key, value in node.kwargs]</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def visit_CondExpr(self, node: nodes.CondExpr) -&gt;nodes.Node:</span>
<span class="gi">+        &quot;&quot;&quot;Optimize conditional expression nodes.&quot;&quot;&quot;</span>
<span class="gi">+        node.test = self.visit(node.test)</span>
<span class="gi">+        node.expr1 = self.visit(node.expr1)</span>
<span class="gi">+        node.expr2 = self.visit(node.expr2)</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def generic_visit(self, node: nodes.Node) -&gt;nodes.Node:</span>
<span class="gi">+        &quot;&quot;&quot;Visit a node.&quot;&quot;&quot;</span>
<span class="gi">+        return super().generic_visit(node)</span>
<span class="gh">diff --git a/src/jinja2/parser.py b/src/jinja2/parser.py</span>
<span class="gh">index 05ce33d..1a2147c 100644</span>
<span class="gd">--- a/src/jinja2/parser.py</span>
<span class="gi">+++ b/src/jinja2/parser.py</span>
<span class="gu">@@ -47,7 +47,9 @@ class Parser:</span>
<span class="w"> </span>        line number or last line number as well as the current name and
<span class="w"> </span>        filename.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if lineno is None:</span>
<span class="gi">+            lineno = self.stream.current.lineno</span>
<span class="gi">+        raise exc(msg, lineno, self.name, self.filename)</span>

<span class="w"> </span>    def fail_unknown_tag(self, name: str, lineno: t.Optional[int]=None
<span class="w"> </span>        ) -&gt;&#39;te.NoReturn&#39;:
<span class="gu">@@ -55,26 +57,54 @@ class Parser:</span>
<span class="w"> </span>        with a human readable error message that could help to identify
<span class="w"> </span>        the problem.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if lineno is None:</span>
<span class="gi">+            lineno = self.stream.current.lineno</span>
<span class="gi">+        if name in (&#39;endif&#39;, &#39;endfor&#39;, &#39;endblock&#39;, &#39;endmacro&#39;, &#39;endcall&#39;):</span>
<span class="gi">+            self.fail(f&#39;Unexpected end of block tag {name!r}&#39;, lineno)</span>
<span class="gi">+        elif name in _statement_keywords:</span>
<span class="gi">+            self.fail(f&#39;Block tag {name!r} expected&#39;, lineno)</span>
<span class="gi">+        self.fail(f&#39;Unknown tag {name!r}&#39;, lineno)</span>

<span class="w"> </span>    def fail_eof(self, end_tokens: t.Optional[t.Tuple[str, ...]]=None,
<span class="w"> </span>        lineno: t.Optional[int]=None) -&gt;&#39;te.NoReturn&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Like fail_unknown_tag but for end of template situations.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if end_tokens is not None:</span>
<span class="gi">+            expected = &#39; or &#39;.join(repr(x) for x in end_tokens)</span>
<span class="gi">+            msg = f&#39;Unexpected end of template. Expected {expected}.&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = &#39;Unexpected end of template.&#39;</span>
<span class="gi">+        self.fail(msg, lineno)</span>

<span class="w"> </span>    def is_tuple_end(self, extra_end_rules: t.Optional[t.Tuple[str, ...]]=None
<span class="w"> </span>        ) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Are we at the end of a tuple?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.stream.current.type in (&#39;variable_end&#39;, &#39;block_end&#39;, &#39;rparen&#39;):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if extra_end_rules is not None:</span>
<span class="gi">+            return self.stream.current.test_any(extra_end_rules)</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def free_identifier(self, lineno: t.Optional[int]=None
<span class="w"> </span>        ) -&gt;nodes.InternalName:
<span class="w"> </span>        &quot;&quot;&quot;Return a new free identifier as :class:`~jinja2.nodes.InternalName`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._last_identifier += 1</span>
<span class="gi">+        rv = object.__new__(nodes.InternalName)</span>
<span class="gi">+        rv.name = f&#39;fi{self._last_identifier}&#39;</span>
<span class="gi">+        rv.lineno = lineno</span>
<span class="gi">+        return rv</span>

<span class="w"> </span>    def parse_statement(self) -&gt;t.Union[nodes.Node, t.List[nodes.Node]]:
<span class="w"> </span>        &quot;&quot;&quot;Parse a single statement.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        token = self.stream.current</span>
<span class="gi">+        if token.type != &#39;name&#39;:</span>
<span class="gi">+            return self.parse_expression()</span>
<span class="gi">+        if token.value in _statement_keywords:</span>
<span class="gi">+            return getattr(self, f&#39;parse_{token.value}&#39;)()</span>
<span class="gi">+        if token.value == &#39;call&#39;:</span>
<span class="gi">+            return self.parse_call_block()</span>
<span class="gi">+        if token.value == &#39;filter&#39;:</span>
<span class="gi">+            return self.parse_filter_block()</span>
<span class="gi">+        return self.parse_expression()</span>

<span class="w"> </span>    def parse_statements(self, end_tokens: t.Tuple[str, ...], drop_needle:
<span class="w"> </span>        bool=False) -&gt;t.List[nodes.Node]:
<span class="gu">@@ -87,7 +117,20 @@ class Parser:</span>
<span class="w"> </span>        the call is the matched end token.  If this is not wanted `drop_needle`
<span class="w"> </span>        can be set to `True` and the end token is removed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = []</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            if self.stream.current.type == &#39;data&#39;:</span>
<span class="gi">+                result.append(nodes.Output([self.parse_tuple(with_condexpr=True)]))</span>
<span class="gi">+            elif self.stream.current.type == &#39;block_begin&#39;:</span>
<span class="gi">+                self.stream.next()</span>
<span class="gi">+                if self.stream.current.test_any(end_tokens):</span>
<span class="gi">+                    if drop_needle:</span>
<span class="gi">+                        self.stream.next()</span>
<span class="gi">+                    return result</span>
<span class="gi">+                result.append(self.parse_statement())</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        self.fail_eof(end_tokens)</span>

<span class="w"> </span>    def parse_set(self) -&gt;t.Union[nodes.Assign, nodes.AssignBlock]:
<span class="w"> </span>        &quot;&quot;&quot;Parse an assign statement.&quot;&quot;&quot;
<span class="gh">diff --git a/src/jinja2/runtime.py b/src/jinja2/runtime.py</span>
<span class="gh">index c88211d..1bceb54 100644</span>
<span class="gd">--- a/src/jinja2/runtime.py</span>
<span class="gi">+++ b/src/jinja2/runtime.py</span>
<span class="gu">@@ -43,17 +43,17 @@ def identity(x: V) -&gt;V:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns its argument. Useful for certain things in the
<span class="w"> </span>    environment.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return x</span>


<span class="w"> </span>def markup_join(seq: t.Iterable[t.Any]) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Concatenation that escapes if necessary and converts to string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Markup(&#39;&#39;).join(escape(soft_str(v)) for v in seq)</span>


<span class="w"> </span>def str_join(seq: t.Iterable[t.Any]) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Simple args to string conversion and concatenation.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &#39;&#39;.join(map(str, seq))</span>


<span class="w"> </span>def new_context(environment: &#39;Environment&#39;, template_name: t.Optional[str],
<span class="gu">@@ -62,7 +62,14 @@ def new_context(environment: &#39;Environment&#39;, template_name: t.Optional[str],</span>
<span class="w"> </span>    Optional[t.MutableMapping[str, t.Any]]=None, locals: t.Optional[t.
<span class="w"> </span>    Mapping[str, t.Any]]=None) -&gt;&#39;Context&#39;:
<span class="w"> </span>    &quot;&quot;&quot;Internal helper for context creation.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parent = environment.make_globals(globals)</span>
<span class="gi">+    if vars is not None:</span>
<span class="gi">+        parent.update(vars)</span>
<span class="gi">+    if shared:</span>
<span class="gi">+        parent = vars or {}</span>
<span class="gi">+    if locals:</span>
<span class="gi">+        parent.update(locals)</span>
<span class="gi">+    return Context(environment, parent, template_name, blocks)</span>


<span class="w"> </span>class TemplateReference:
<span class="gu">@@ -116,7 +123,14 @@ class Context:</span>
<span class="w"> </span>    def super(self, name: str, current: t.Callable[[&#39;Context&#39;], t.Iterator[
<span class="w"> </span>        str]]) -&gt;t.Union[&#39;BlockReference&#39;, &#39;Undefined&#39;]:
<span class="w"> </span>        &quot;&quot;&quot;Render a parent block.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            blocks = self.blocks[name]</span>
<span class="gi">+            index = blocks.index(current) + 1</span>
<span class="gi">+            if index &lt; len(blocks):</span>
<span class="gi">+                return BlockReference(name, self, blocks, index)</span>
<span class="gi">+        except (LookupError, ValueError):</span>
<span class="gi">+            pass</span>
<span class="gi">+        return self.environment.undefined(f&#39;there is no parent block called {name!r}.&#39;, name=&#39;super&#39;)</span>

<span class="w"> </span>    def get(self, key: str, default: t.Any=None) -&gt;t.Any:
<span class="w"> </span>        &quot;&quot;&quot;Look up a variable by name, or return a default if the key is
<span class="gu">@@ -125,7 +139,10 @@ class Context:</span>
<span class="w"> </span>        :param key: The variable name to look up.
<span class="w"> </span>        :param default: The value to return if the key is not found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self[key]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return default</span>

<span class="w"> </span>    def resolve(self, key: str) -&gt;t.Union[t.Any, &#39;Undefined&#39;]:
<span class="w"> </span>        &quot;&quot;&quot;Look up a variable by name, or return an :class:`Undefined`
<span class="gu">@@ -137,7 +154,10 @@ class Context:</span>

<span class="w"> </span>        :param key: The variable name to look up.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = self.resolve_or_missing(key)</span>
<span class="gi">+        if rv is missing:</span>
<span class="gi">+            return self.environment.undefined(name=key)</span>
<span class="gi">+        return rv</span>

<span class="w"> </span>    def resolve_or_missing(self, key: str) -&gt;t.Any:
<span class="w"> </span>        &quot;&quot;&quot;Look up a variable by name, or return a ``missing`` sentinel
<span class="gu">@@ -149,18 +169,22 @@ class Context:</span>

<span class="w"> </span>        :param key: The variable name to look up.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if key in self.vars:</span>
<span class="gi">+            return self.vars[key]</span>
<span class="gi">+        if key in self.parent:</span>
<span class="gi">+            return self.parent[key]</span>
<span class="gi">+        return missing</span>

<span class="w"> </span>    def get_exported(self) -&gt;t.Dict[str, t.Any]:
<span class="w"> </span>        &quot;&quot;&quot;Get a new dict with the exported variables.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {k: self.vars[k] for k in self.exported_vars}</span>

<span class="w"> </span>    def get_all(self) -&gt;t.Dict[str, t.Any]:
<span class="w"> </span>        &quot;&quot;&quot;Return the complete context as dict including the exported
<span class="w"> </span>        variables.  For optimizations reasons this might not return an
<span class="w"> </span>        actual copy so be careful with using it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {**self.parent, **self.vars}</span>

<span class="w"> </span>    @internalcode
<span class="w"> </span>    def call(__self, __obj: t.Callable[..., t.Any], *args: t.Any, **kwargs:
<span class="gu">@@ -170,14 +194,23 @@ class Context:</span>
<span class="w"> </span>        argument if the callable has :func:`pass_context` or
<span class="w"> </span>        :func:`pass_environment`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(__obj, _PassArg):</span>
<span class="gi">+            if __obj._type == &#39;context&#39;:</span>
<span class="gi">+                args = (__self,) + args</span>
<span class="gi">+            elif __obj._type == &#39;environment&#39;:</span>
<span class="gi">+                args = (__self.environment,) + args</span>
<span class="gi">+            return __obj._func(*args, **kwargs)</span>
<span class="gi">+        return __obj(*args, **kwargs)</span>

<span class="w"> </span>    def derived(self, locals: t.Optional[t.Dict[str, t.Any]]=None) -&gt;&#39;Context&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Internal helper function to create a derived context.  This is
<span class="w"> </span>        used in situations where the system needs a new context in the same
<span class="w"> </span>        template that is independent.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        context = new_context(self.environment, self.name, self.blocks,</span>
<span class="gi">+                              self.get_all(), True, None, locals)</span>
<span class="gi">+        context.globals_keys = self.globals_keys</span>
<span class="gi">+        return context</span>
<span class="w"> </span>    keys = _dict_method_all(dict.keys)
<span class="w"> </span>    values = _dict_method_all(dict.values)
<span class="w"> </span>    items = _dict_method_all(dict.items)
<span class="gh">diff --git a/src/jinja2/sandbox.py b/src/jinja2/sandbox.py</span>
<span class="gh">index b73a983..9ea91b9 100644</span>
<span class="gd">--- a/src/jinja2/sandbox.py</span>
<span class="gi">+++ b/src/jinja2/sandbox.py</span>
<span class="gu">@@ -35,7 +35,22 @@ def safe_range(*args: int) -&gt;range:</span>
<span class="w"> </span>    &quot;&quot;&quot;A range that can&#39;t generate ranges with a length of more than
<span class="w"> </span>    MAX_RANGE items.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(args) == 1:</span>
<span class="gi">+        start, stop, step = 0, args[0], 1</span>
<span class="gi">+    elif len(args) == 2:</span>
<span class="gi">+        start, stop, step = args[0], args[1], 1</span>
<span class="gi">+    elif len(args) == 3:</span>
<span class="gi">+        start, stop, step = args</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&#39;range() requires 1-3 integer arguments&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    # Calculate the length of the range</span>
<span class="gi">+    length = (stop - start + step - 1) // step</span>
<span class="gi">+    </span>
<span class="gi">+    if length &gt; MAX_RANGE:</span>
<span class="gi">+        raise OverflowError(f&#39;range() result has too many items (maximum is {MAX_RANGE})&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    return range(start, stop, step)</span>


<span class="w"> </span>def unsafe(f: F) -&gt;F:
<span class="gu">@@ -47,7 +62,8 @@ def unsafe(f: F) -&gt;F:</span>
<span class="w"> </span>        def delete(self):
<span class="w"> </span>            pass
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    f.unsafe_callable = True</span>
<span class="gi">+    return f</span>


<span class="w"> </span>def is_internal_attribute(obj: t.Any, attr: str) -&gt;bool:
<span class="gu">@@ -62,7 +78,11 @@ def is_internal_attribute(obj: t.Any, attr: str) -&gt;bool:</span>
<span class="w"> </span>    &gt;&gt;&gt; is_internal_attribute(str, &quot;upper&quot;)
<span class="w"> </span>    False
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return attr.startswith(&#39;__&#39;) and attr.endswith(&#39;__&#39;) or \</span>
<span class="gi">+           attr.startswith(&#39;func_&#39;) or \</span>
<span class="gi">+           attr.startswith(&#39;im_&#39;) or \</span>
<span class="gi">+           attr in UNSAFE_FUNCTION_ATTRIBUTES or \</span>
<span class="gi">+           attr in UNSAFE_METHOD_ATTRIBUTES</span>


<span class="w"> </span>def modifies_known_mutable(obj: t.Any, attr: str) -&gt;bool:
<span class="gu">@@ -84,7 +104,10 @@ def modifies_known_mutable(obj: t.Any, attr: str) -&gt;bool:</span>
<span class="w"> </span>    &gt;&gt;&gt; modifies_known_mutable(&quot;foo&quot;, &quot;upper&quot;)
<span class="w"> </span>    False
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for typ, mutable_attrs in _mutable_spec:</span>
<span class="gi">+        if isinstance(obj, typ):</span>
<span class="gi">+            return attr in mutable_attrs</span>
<span class="gi">+    return False</span>


<span class="w"> </span>class SandboxedEnvironment(Environment):
<span class="gu">@@ -120,7 +143,7 @@ class SandboxedEnvironment(Environment):</span>
<span class="w"> </span>        special attributes of internal python objects as returned by the
<span class="w"> </span>        :func:`is_internal_attribute` function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return not (attr.startswith(&#39;_&#39;) or is_internal_attribute(obj, attr))</span>

<span class="w"> </span>    def is_safe_callable(self, obj: t.Any) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Check if an object is safely callable. By default callables
<span class="gu">@@ -129,7 +152,10 @@ class SandboxedEnvironment(Environment):</span>
<span class="w"> </span>        This also recognizes the Django convention of setting
<span class="w"> </span>        ``func.alters_data = True``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return callable(obj) and not (</span>
<span class="gi">+            getattr(obj, &#39;unsafe_callable&#39;, False) or</span>
<span class="gi">+            getattr(obj, &#39;alters_data&#39;, False)</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def call_binop(self, context: Context, operator: str, left: t.Any,
<span class="w"> </span>        right: t.Any) -&gt;t.Any:
<span class="gu">@@ -139,7 +165,9 @@ class SandboxedEnvironment(Environment):</span>

<span class="w"> </span>        .. versionadded:: 2.6
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if operator not in self.binop_table:</span>
<span class="gi">+            raise SecurityError(f&#39;unsupported binary operator: {operator}&#39;)</span>
<span class="gi">+        return self.binop_table[operator](left, right)</span>

<span class="w"> </span>    def call_unop(self, context: Context, operator: str, arg: t.Any) -&gt;t.Any:
<span class="w"> </span>        &quot;&quot;&quot;For intercepted unary operator calls (:meth:`intercepted_unops`)
<span class="gu">@@ -148,22 +176,47 @@ class SandboxedEnvironment(Environment):</span>

<span class="w"> </span>        .. versionadded:: 2.6
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if operator not in self.unop_table:</span>
<span class="gi">+            raise SecurityError(f&#39;unsupported unary operator: {operator}&#39;)</span>
<span class="gi">+        return self.unop_table[operator](arg)</span>

<span class="w"> </span>    def getitem(self, obj: t.Any, argument: t.Union[str, t.Any]) -&gt;t.Union[
<span class="w"> </span>        t.Any, Undefined]:
<span class="w"> </span>        &quot;&quot;&quot;Subscribe an object from sandboxed code.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return obj[argument]</span>
<span class="gi">+        except (TypeError, LookupError):</span>
<span class="gi">+            if isinstance(argument, str):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    attr = str(argument)</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        return self.getattr(obj, attr)</span>
<span class="gi">+                    except RuntimeError:</span>
<span class="gi">+                        return self.undefined(obj=obj, name=argument)</span>
<span class="gi">+            return self.undefined(obj=obj, name=argument)</span>

<span class="w"> </span>    def getattr(self, obj: t.Any, attribute: str) -&gt;t.Union[t.Any, Undefined]:
<span class="w"> </span>        &quot;&quot;&quot;Subscribe an object from sandboxed code and prefer the
<span class="w"> </span>        attribute.  The attribute passed *must* be a bytestring.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = getattr(obj, attribute)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return self.undefined(obj=obj, name=attribute)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.is_safe_attribute(obj, attribute, value):</span>
<span class="gi">+                return value</span>
<span class="gi">+            return self.unsafe_undefined(obj, attribute)</span>

<span class="w"> </span>    def unsafe_undefined(self, obj: t.Any, attribute: str) -&gt;Undefined:
<span class="w"> </span>        &quot;&quot;&quot;Return an undefined object for unsafe attributes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.undefined(&#39;access to attribute %r of %r object is unsafe.&#39; % (</span>
<span class="gi">+            attribute,</span>
<span class="gi">+            obj.__class__.__name__</span>
<span class="gi">+        ), name=attribute, obj=obj, exc=SecurityError)</span>

<span class="w"> </span>    def format_string(self, s: str, args: t.Tuple[t.Any, ...], kwargs: t.
<span class="w"> </span>        Dict[str, t.Any], format_func: t.Optional[t.Callable[..., t.Any]]=None
<span class="gu">@@ -171,12 +224,21 @@ class SandboxedEnvironment(Environment):</span>
<span class="w"> </span>        &quot;&quot;&quot;If a format call is detected, then this is routed through this
<span class="w"> </span>        method so that our safety sandbox can be used for it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if format_func is not None:</span>
<span class="gi">+            formatter = SandboxedEscapeFormatter(self, format_func)</span>
<span class="gi">+        elif isinstance(s, Markup):</span>
<span class="gi">+            formatter = SandboxedEscapeFormatter(self, lambda x: x)</span>
<span class="gi">+        else:</span>
<span class="gi">+            formatter = SandboxedFormatter(self)</span>
<span class="gi">+        </span>
<span class="gi">+        return formatter.vformat(s, args, kwargs)</span>

<span class="w"> </span>    def call(__self, __context: Context, __obj: t.Any, *args: t.Any, **
<span class="w"> </span>        kwargs: t.Any) -&gt;t.Any:
<span class="w"> </span>        &quot;&quot;&quot;Call an object from sandboxed code.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not __self.is_safe_callable(__obj):</span>
<span class="gi">+            raise SecurityError(f&#39;{__obj!r} is not safely callable&#39;)</span>
<span class="gi">+        return __obj(*args, **kwargs)</span>


<span class="w"> </span>class ImmutableSandboxedEnvironment(SandboxedEnvironment):
<span class="gh">diff --git a/src/jinja2/tests.py b/src/jinja2/tests.py</span>
<span class="gh">index 2823a4b..0963a3e 100644</span>
<span class="gd">--- a/src/jinja2/tests.py</span>
<span class="gi">+++ b/src/jinja2/tests.py</span>
<span class="gu">@@ -11,17 +11,17 @@ if t.TYPE_CHECKING:</span>

<span class="w"> </span>def test_odd(value: int) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return true if the variable is odd.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value % 2 != 0</span>


<span class="w"> </span>def test_even(value: int) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return true if the variable is even.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value % 2 == 0</span>


<span class="w"> </span>def test_divisibleby(value: int, num: int) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check if a variable is divisible by a number.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value % num == 0</span>


<span class="w"> </span>def test_defined(value: t.Any) -&gt;bool:
<span class="gu">@@ -38,12 +38,12 @@ def test_defined(value: t.Any) -&gt;bool:</span>
<span class="w"> </span>    See the :func:`default` filter for a simple way to set undefined
<span class="w"> </span>    variables.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return not isinstance(value, Undefined)</span>


<span class="w"> </span>def test_undefined(value: t.Any) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Like :func:`defined` but the other way round.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, Undefined)</span>


<span class="w"> </span>@pass_environment
<span class="gu">@@ -61,7 +61,7 @@ def test_filter(env: &#39;Environment&#39;, value: str) -&gt;bool:</span>

<span class="w"> </span>    .. versionadded:: 3.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value in env.filters</span>


<span class="w"> </span>@pass_environment
<span class="gu">@@ -83,12 +83,12 @@ def test_test(env: &#39;Environment&#39;, value: str) -&gt;bool:</span>

<span class="w"> </span>    .. versionadded:: 3.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value in env.tests</span>


<span class="w"> </span>def test_none(value: t.Any) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return true if the variable is none.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value is None</span>


<span class="w"> </span>def test_boolean(value: t.Any) -&gt;bool:
<span class="gu">@@ -96,7 +96,7 @@ def test_boolean(value: t.Any) -&gt;bool:</span>

<span class="w"> </span>    .. versionadded:: 2.11
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, bool)</span>


<span class="w"> </span>def test_false(value: t.Any) -&gt;bool:
<span class="gu">@@ -104,7 +104,7 @@ def test_false(value: t.Any) -&gt;bool:</span>

<span class="w"> </span>    .. versionadded:: 2.11
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value is False</span>


<span class="w"> </span>def test_true(value: t.Any) -&gt;bool:
<span class="gu">@@ -112,7 +112,7 @@ def test_true(value: t.Any) -&gt;bool:</span>

<span class="w"> </span>    .. versionadded:: 2.11
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value is True</span>


<span class="w"> </span>def test_integer(value: t.Any) -&gt;bool:
<span class="gu">@@ -120,7 +120,7 @@ def test_integer(value: t.Any) -&gt;bool:</span>

<span class="w"> </span>    .. versionadded:: 2.11
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, int)</span>


<span class="w"> </span>def test_float(value: t.Any) -&gt;bool:
<span class="gu">@@ -128,22 +128,22 @@ def test_float(value: t.Any) -&gt;bool:</span>

<span class="w"> </span>    .. versionadded:: 2.11
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, float)</span>


<span class="w"> </span>def test_lower(value: str) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return true if the variable is lowercased.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, str) and value.islower()</span>


<span class="w"> </span>def test_upper(value: str) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return true if the variable is uppercased.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, str) and value.isupper()</span>


<span class="w"> </span>def test_string(value: t.Any) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return true if the object is a string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, str)</span>


<span class="w"> </span>def test_mapping(value: t.Any) -&gt;bool:
<span class="gu">@@ -151,19 +151,19 @@ def test_mapping(value: t.Any) -&gt;bool:</span>

<span class="w"> </span>    .. versionadded:: 2.6
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, abc.Mapping)</span>


<span class="w"> </span>def test_number(value: t.Any) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return true if the variable is a number.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, Number)</span>


<span class="w"> </span>def test_sequence(value: t.Any) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return true if the variable is a sequence. Sequences are variables
<span class="w"> </span>    that are iterable.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, (abc.Sequence, abc.Set)) and not isinstance(value, str)</span>


<span class="w"> </span>def test_sameas(value: t.Any, other: t.Any) -&gt;bool:
<span class="gu">@@ -176,17 +176,21 @@ def test_sameas(value: t.Any, other: t.Any) -&gt;bool:</span>
<span class="w"> </span>            the foo attribute really is the `False` singleton
<span class="w"> </span>        {% endif %}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value is other</span>


<span class="w"> </span>def test_iterable(value: t.Any) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check if it&#39;s possible to iterate over an object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        iter(value)</span>
<span class="gi">+        return True</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        return False</span>


<span class="w"> </span>def test_escaped(value: t.Any) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check if the value is escaped.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return hasattr(value, &#39;__html__&#39;)</span>


<span class="w"> </span>def test_in(value: t.Any, seq: t.Container[t.Any]) -&gt;bool:
<span class="gu">@@ -194,7 +198,7 @@ def test_in(value: t.Any, seq: t.Container[t.Any]) -&gt;bool:</span>

<span class="w"> </span>    .. versionadded:: 2.10
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value in seq</span>


<span class="w"> </span>TESTS = {&#39;odd&#39;: test_odd, &#39;even&#39;: test_even, &#39;divisibleby&#39;:
<span class="gh">diff --git a/src/jinja2/utils.py b/src/jinja2/utils.py</span>
<span class="gh">index 7563812..9a4ac9c 100644</span>
<span class="gd">--- a/src/jinja2/utils.py</span>
<span class="gi">+++ b/src/jinja2/utils.py</span>
<span class="gu">@@ -32,7 +32,8 @@ def pass_context(f: F) -&gt;F:</span>
<span class="w"> </span>    .. versionadded:: 3.0.0
<span class="w"> </span>        Replaces ``contextfunction`` and ``contextfilter``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    f.jinja_pass_arg = _PassArg.context</span>
<span class="gi">+    return f</span>


<span class="w"> </span>def pass_eval_context(f: F) -&gt;F:
<span class="gu">@@ -48,7 +49,8 @@ def pass_eval_context(f: F) -&gt;F:</span>
<span class="w"> </span>    .. versionadded:: 3.0.0
<span class="w"> </span>        Replaces ``evalcontextfunction`` and ``evalcontextfilter``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    f.jinja_pass_arg = _PassArg.eval_context</span>
<span class="gi">+    return f</span>


<span class="w"> </span>def pass_environment(f: F) -&gt;F:
<span class="gu">@@ -60,7 +62,8 @@ def pass_environment(f: F) -&gt;F:</span>
<span class="w"> </span>    .. versionadded:: 3.0.0
<span class="w"> </span>        Replaces ``environmentfunction`` and ``environmentfilter``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    f.jinja_pass_arg = _PassArg.environment</span>
<span class="gi">+    return f</span>


<span class="w"> </span>class _PassArg(enum.Enum):
<span class="gu">@@ -71,7 +74,8 @@ class _PassArg(enum.Enum):</span>

<span class="w"> </span>def internalcode(f: F) -&gt;F:
<span class="w"> </span>    &quot;&quot;&quot;Marks the function as internally used&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    internal_code.add(f.__code__)</span>
<span class="gi">+    return f</span>


<span class="w"> </span>def is_undefined(obj: t.Any) -&gt;bool:
<span class="gu">@@ -86,7 +90,8 @@ def is_undefined(obj: t.Any) -&gt;bool:</span>
<span class="w"> </span>                return default
<span class="w"> </span>            return var
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from .runtime import Undefined</span>
<span class="gi">+    return isinstance(obj, Undefined)</span>


<span class="w"> </span>def consume(iterable: t.Iterable[t.Any]) -&gt;None:
<span class="gh">diff --git a/src/jinja2/visitor.py b/src/jinja2/visitor.py</span>
<span class="gh">index ebb34c6..17dcc82 100644</span>
<span class="gd">--- a/src/jinja2/visitor.py</span>
<span class="gi">+++ b/src/jinja2/visitor.py</span>
<span class="gu">@@ -30,15 +30,19 @@ class NodeVisitor:</span>
<span class="w"> </span>        exists for this node.  In that case the generic visit function is
<span class="w"> </span>        used instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        method = &#39;visit_&#39; + node.__class__.__name__</span>
<span class="gi">+        return getattr(self, method, None)</span>

<span class="w"> </span>    def visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt;t.Any:
<span class="w"> </span>        &quot;&quot;&quot;Visit a node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        f = self.get_visitor(node)</span>
<span class="gi">+        if f is not None:</span>
<span class="gi">+            return f(node, *args, **kwargs)</span>
<span class="gi">+        return self.generic_visit(node, *args, **kwargs)</span>

<span class="w"> </span>    def generic_visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt;t.Any:
<span class="w"> </span>        &quot;&quot;&quot;Called if no explicit visitor function exists for a node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return node</span>


<span class="w"> </span>class NodeTransformer(NodeVisitor):
<span class="gu">@@ -52,9 +56,16 @@ class NodeTransformer(NodeVisitor):</span>
<span class="w"> </span>    replacement takes place.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def visit_list(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt;t.List[</span>
<span class="gd">-        Node]:</span>
<span class="gi">+    def visit_list(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt;t.List[Node]:</span>
<span class="w"> </span>        &quot;&quot;&quot;As transformers may return lists in some places this method
<span class="w"> </span>        can be used to enforce a list as return value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for child in node:</span>
<span class="gi">+            new_node = self.visit(child, *args, **kwargs)</span>
<span class="gi">+            if new_node is not None:</span>
<span class="gi">+                if isinstance(new_node, list):</span>
<span class="gi">+                    result.extend(new_node)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    result.append(new_node)</span>
<span class="gi">+        return result</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>