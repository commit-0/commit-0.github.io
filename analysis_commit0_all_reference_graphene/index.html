
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference graphene - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-graphene" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference graphene
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-graphene" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test graphene
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_custom_global_idpytestuuidglobalidtest_str_schema_correct" class="md-nav__link">
    <span class="md-ellipsis">
      test_custom_global_id.py::TestUUIDGlobalID::test_str_schema_correct
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_custom_global_idpytestuuidglobalidtest_get_by_id" class="md-nav__link">
    <span class="md-ellipsis">
      test_custom_global_id.py::TestUUIDGlobalID::test_get_by_id
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_custom_global_idpytestsimpleglobalidtest_str_schema_correct" class="md-nav__link">
    <span class="md-ellipsis">
      test_custom_global_id.py::TestSimpleGlobalID::test_str_schema_correct
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_custom_global_idpytestsimpleglobalidtest_get_by_id" class="md-nav__link">
    <span class="md-ellipsis">
      test_custom_global_id.py::TestSimpleGlobalID::test_get_by_id
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_custom_global_idpytestcustomglobalidtest_str_schema_correct" class="md-nav__link">
    <span class="md-ellipsis">
      test_custom_global_id.py::TestCustomGlobalID::test_str_schema_correct
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_custom_global_idpytestcustomglobalidtest_get_by_id" class="md-nav__link">
    <span class="md-ellipsis">
      test_custom_global_id.py::TestCustomGlobalID::test_get_by_id
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_custom_global_idpytestincompletecustomglobalidtest_must_define_to_global_id" class="md-nav__link">
    <span class="md-ellipsis">
      test_custom_global_id.py::TestIncompleteCustomGlobalID::test_must_define_to_global_id
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-graphene"><strong>Reference (Gold)</strong>: graphene</h1>
<h2 id="pytest-summary-for-test-graphene">Pytest Summary for test <code>graphene</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">440</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">7</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">447</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">447</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_custom_global_idpytestuuidglobalidtest_str_schema_correct">test_custom_global_id.py::TestUUIDGlobalID::test_str_schema_correct</h3>
<details><summary> <pre>test_custom_global_id.py::TestUUIDGlobalID::test_str_schema_correct</pre></summary><pre>
self = <graphene.relay.tests.test_custom_global_id.TestUUIDGlobalID object at 0x7fcd92483890>

    def test_str_schema_correct(self):
        """
        Check that the schema has the expected and custom node interface and user type and that they both use UUIDs
        """
>       parsed = re.findall(r"(.+) \{\n\s*([\w\W]*?)\n\}", str(self.schema))
E       AttributeError: 'TestUUIDGlobalID' object has no attribute 'schema'

graphene/relay/tests/test_custom_global_id.py:45: AttributeError
</pre>
</details>
<h3 id="test_custom_global_idpytestuuidglobalidtest_get_by_id">test_custom_global_id.py::TestUUIDGlobalID::test_get_by_id</h3>
<details><summary> <pre>test_custom_global_id.py::TestUUIDGlobalID::test_get_by_id</pre></summary><pre>
self = <graphene.relay.tests.test_custom_global_id.TestUUIDGlobalID object at 0x7fcd924838d0>

    def test_get_by_id(self):
        query = """query userById($id: UUID!) {
            user(id: $id) {
                id
                name
            }
        }"""
        # UUID need to be converted to string for serialization
        result = graphql_sync(
>           self.graphql_schema,
            query,
            variable_values={"id": str(self.user_list[0]["id"])},
        )
E       AttributeError: 'TestUUIDGlobalID' object has no attribute 'graphql_schema'

graphene/relay/tests/test_custom_global_id.py:70: AttributeError
</pre>
</details>
<h3 id="test_custom_global_idpytestsimpleglobalidtest_str_schema_correct">test_custom_global_id.py::TestSimpleGlobalID::test_str_schema_correct</h3>
<details><summary> <pre>test_custom_global_id.py::TestSimpleGlobalID::test_str_schema_correct</pre></summary><pre>
self = <graphene.relay.tests.test_custom_global_id.TestSimpleGlobalID object at 0x7fcd924817d0>

    def test_str_schema_correct(self):
        """
        Check that the schema has the expected and custom node interface and user type and that they both use UUIDs
        """
>       parsed = re.findall(r"(.+) \{\n\s*([\w\W]*?)\n\}", str(self.schema))
E       AttributeError: 'TestSimpleGlobalID' object has no attribute 'schema'

graphene/relay/tests/test_custom_global_id.py:113: AttributeError
</pre>
</details>
<h3 id="test_custom_global_idpytestsimpleglobalidtest_get_by_id">test_custom_global_id.py::TestSimpleGlobalID::test_get_by_id</h3>
<details><summary> <pre>test_custom_global_id.py::TestSimpleGlobalID::test_get_by_id</pre></summary><pre>
self = <graphene.relay.tests.test_custom_global_id.TestSimpleGlobalID object at 0x7fcd92480550>

    def test_get_by_id(self):
        query = """query {
            user(id: "my global primary key in clear 3") {
                id
                name
            }
        }"""
>       result = graphql_sync(self.graphql_schema, query)
E       AttributeError: 'TestSimpleGlobalID' object has no attribute 'graphql_schema'

graphene/relay/tests/test_custom_global_id.py:136: AttributeError
</pre>
</details>
<h3 id="test_custom_global_idpytestcustomglobalidtest_str_schema_correct">test_custom_global_id.py::TestCustomGlobalID::test_str_schema_correct</h3>
<details><summary> <pre>test_custom_global_id.py::TestCustomGlobalID::test_str_schema_correct</pre></summary><pre>
self = <graphene.relay.tests.test_custom_global_id.TestCustomGlobalID object at 0x7fcd92480cd0>

    def test_str_schema_correct(self):
        """
        Check that the schema has the expected and custom node interface and user type and that they both use UUIDs
        """
>       parsed = re.findall(r"(.+) \{\n\s*([\w\W]*?)\n\}", str(self.schema))
E       AttributeError: 'TestCustomGlobalID' object has no attribute 'schema'

graphene/relay/tests/test_custom_global_id.py:192: AttributeError
</pre>
</details>
<h3 id="test_custom_global_idpytestcustomglobalidtest_get_by_id">test_custom_global_id.py::TestCustomGlobalID::test_get_by_id</h3>
<details><summary> <pre>test_custom_global_id.py::TestCustomGlobalID::test_get_by_id</pre></summary><pre>
self = <graphene.relay.tests.test_custom_global_id.TestCustomGlobalID object at 0x7fcd92481f50>

    def test_get_by_id(self):
        query = """query {
            user(id: 2) {
                id
                name
            }
        }"""
>       result = graphql_sync(self.graphql_schema, query)
E       AttributeError: 'TestCustomGlobalID' object has no attribute 'graphql_schema'

graphene/relay/tests/test_custom_global_id.py:215: AttributeError
</pre>
</details>
<h3 id="test_custom_global_idpytestincompletecustomglobalidtest_must_define_to_global_id">test_custom_global_id.py::TestIncompleteCustomGlobalID::test_must_define_to_global_id</h3>
<details><summary> <pre>test_custom_global_id.py::TestIncompleteCustomGlobalID::test_must_define_to_global_id</pre></summary><pre>
self = <graphene.relay.tests.test_custom_global_id.TestIncompleteCustomGlobalID object at 0x7fcd924814d0>

    def test_must_define_to_global_id(self):
        """
        Test that if the `to_global_id` method is not defined, we can query the object, but we can't request its ID.
        """

        class CustomGlobalIDType(BaseGlobalIDType):
            graphene_type = Int

            @classmethod
            def resolve_global_id(cls, info, global_id):
                _type = info.return_type.graphene_type._meta.name
                return _type, global_id

        class CustomNode(Node):
            class Meta:
                global_id_type = CustomGlobalIDType

        class User(ObjectType):
            class Meta:
                interfaces = [CustomNode]

            name = String()

            @classmethod
            def get_node(cls, _type, _id):
                return self.users[_id]

        class RootQuery(ObjectType):
            user = CustomNode.Field(User)

        self.schema = Schema(query=RootQuery, types=[User])
        self.graphql_schema = self.schema.graphql_schema

        query = """query {
            user(id: 2) {
                name
            }
        }"""
        result = graphql_sync(self.graphql_schema, query)
>       assert not result.errors
E       assert not [GraphQLError("'TestIncompleteCustomGlobalID' object has no attribute 'users'", locations=[SourceLocation(line=2, column=13)], path=['user'])]
E        +  where [GraphQLError("'TestIncompleteCustomGlobalID' object has no attribute 'users'", locations=[SourceLocation(line=2, column=13)], path=['user'])] = ExecutionResult(data={'user': None}, errors=[GraphQLError("'TestIncompleteCustomGlobalID' object has no attribute 'users'", locations=[SourceLocation(line=2, column=13)], path=['user'])]).errors

graphene/relay/tests/test_custom_global_id.py:270: AssertionError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/graphene/pyutils/dataclasses.py b/graphene/pyutils/dataclasses.py</span>
<span class="gh">index f1ec952..1a47452 100644</span>
<span class="gd">--- a/graphene/pyutils/dataclasses.py</span>
<span class="gi">+++ b/graphene/pyutils/dataclasses.py</span>
<span class="gu">@@ -1,37 +1,185 @@</span>
<span class="gi">+# This is a polyfill for dataclasses</span>
<span class="gi">+# https://docs.python.org/3/library/dataclasses.html</span>
<span class="gi">+# Original PEP proposal: PEP 557</span>
<span class="gi">+# https://www.python.org/dev/peps/pep-0557/</span>
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="w"> </span>import copy
<span class="w"> </span>import types
<span class="w"> </span>import inspect
<span class="w"> </span>import keyword
<span class="gd">-__all__ = [&#39;dataclass&#39;, &#39;field&#39;, &#39;Field&#39;, &#39;FrozenInstanceError&#39;, &#39;InitVar&#39;,</span>
<span class="gd">-    &#39;MISSING&#39;, &#39;fields&#39;, &#39;asdict&#39;, &#39;astuple&#39;, &#39;make_dataclass&#39;, &#39;replace&#39;,</span>
<span class="gd">-    &#39;is_dataclass&#39;]</span>
<span class="gd">-</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;dataclass&quot;,</span>
<span class="gi">+    &quot;field&quot;,</span>
<span class="gi">+    &quot;Field&quot;,</span>
<span class="gi">+    &quot;FrozenInstanceError&quot;,</span>
<span class="gi">+    &quot;InitVar&quot;,</span>
<span class="gi">+    &quot;MISSING&quot;,</span>
<span class="gi">+    # Helper functions.</span>
<span class="gi">+    &quot;fields&quot;,</span>
<span class="gi">+    &quot;asdict&quot;,</span>
<span class="gi">+    &quot;astuple&quot;,</span>
<span class="gi">+    &quot;make_dataclass&quot;,</span>
<span class="gi">+    &quot;replace&quot;,</span>
<span class="gi">+    &quot;is_dataclass&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# Conditions for adding methods.  The boxes indicate what action the</span>
<span class="gi">+# dataclass decorator takes.  For all of these tables, when I talk</span>
<span class="gi">+# about init=, repr=, eq=, order=, unsafe_hash=, or frozen=, I&#39;m</span>
<span class="gi">+# referring to the arguments to the @dataclass decorator.  When</span>
<span class="gi">+# checking if a dunder method already exists, I mean check for an</span>
<span class="gi">+# entry in the class&#39;s __dict__.  I never check to see if an attribute</span>
<span class="gi">+# is defined in a base class.</span>
<span class="gi">+</span>
<span class="gi">+# Key:</span>
<span class="gi">+# +=========+=========================================+</span>
<span class="gi">+# + Value   | Meaning                                 |</span>
<span class="gi">+# +=========+=========================================+</span>
<span class="gi">+# | &lt;blank&gt; | No action: no method is added.          |</span>
<span class="gi">+# +---------+-----------------------------------------+</span>
<span class="gi">+# | add     | Generated method is added.              |</span>
<span class="gi">+# +---------+-----------------------------------------+</span>
<span class="gi">+# | raise   | TypeError is raised.                    |</span>
<span class="gi">+# +---------+-----------------------------------------+</span>
<span class="gi">+# | None    | Attribute is set to None.               |</span>
<span class="gi">+# +=========+=========================================+</span>
<span class="gi">+</span>
<span class="gi">+# __init__</span>
<span class="gi">+#</span>
<span class="gi">+#   +--- init= parameter</span>
<span class="gi">+#   |</span>
<span class="gi">+#   v     |       |       |</span>
<span class="gi">+#         |  no   |  yes  |  &lt;--- class has __init__ in __dict__?</span>
<span class="gi">+# +=======+=======+=======+</span>
<span class="gi">+# | False |       |       |</span>
<span class="gi">+# +-------+-------+-------+</span>
<span class="gi">+# | True  | add   |       |  &lt;- the default</span>
<span class="gi">+# +=======+=======+=======+</span>
<span class="gi">+</span>
<span class="gi">+# __repr__</span>
<span class="gi">+#</span>
<span class="gi">+#    +--- repr= parameter</span>
<span class="gi">+#    |</span>
<span class="gi">+#    v    |       |       |</span>
<span class="gi">+#         |  no   |  yes  |  &lt;--- class has __repr__ in __dict__?</span>
<span class="gi">+# +=======+=======+=======+</span>
<span class="gi">+# | False |       |       |</span>
<span class="gi">+# +-------+-------+-------+</span>
<span class="gi">+# | True  | add   |       |  &lt;- the default</span>
<span class="gi">+# +=======+=======+=======+</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# __setattr__</span>
<span class="gi">+# __delattr__</span>
<span class="gi">+#</span>
<span class="gi">+#    +--- frozen= parameter</span>
<span class="gi">+#    |</span>
<span class="gi">+#    v    |       |       |</span>
<span class="gi">+#         |  no   |  yes  |  &lt;--- class has __setattr__ or __delattr__ in __dict__?</span>
<span class="gi">+# +=======+=======+=======+</span>
<span class="gi">+# | False |       |       |  &lt;- the default</span>
<span class="gi">+# +-------+-------+-------+</span>
<span class="gi">+# | True  | add   | raise |</span>
<span class="gi">+# +=======+=======+=======+</span>
<span class="gi">+# Raise because not adding these methods would break the &quot;frozen-ness&quot;</span>
<span class="gi">+# of the class.</span>
<span class="gi">+</span>
<span class="gi">+# __eq__</span>
<span class="gi">+#</span>
<span class="gi">+#    +--- eq= parameter</span>
<span class="gi">+#    |</span>
<span class="gi">+#    v    |       |       |</span>
<span class="gi">+#         |  no   |  yes  |  &lt;--- class has __eq__ in __dict__?</span>
<span class="gi">+# +=======+=======+=======+</span>
<span class="gi">+# | False |       |       |</span>
<span class="gi">+# +-------+-------+-------+</span>
<span class="gi">+# | True  | add   |       |  &lt;- the default</span>
<span class="gi">+# +=======+=======+=======+</span>
<span class="gi">+</span>
<span class="gi">+# __lt__</span>
<span class="gi">+# __le__</span>
<span class="gi">+# __gt__</span>
<span class="gi">+# __ge__</span>
<span class="gi">+#</span>
<span class="gi">+#    +--- order= parameter</span>
<span class="gi">+#    |</span>
<span class="gi">+#    v    |       |       |</span>
<span class="gi">+#         |  no   |  yes  |  &lt;--- class has any comparison method in __dict__?</span>
<span class="gi">+# +=======+=======+=======+</span>
<span class="gi">+# | False |       |       |  &lt;- the default</span>
<span class="gi">+# +-------+-------+-------+</span>
<span class="gi">+# | True  | add   | raise |</span>
<span class="gi">+# +=======+=======+=======+</span>
<span class="gi">+# Raise because to allow this case would interfere with using</span>
<span class="gi">+# functools.total_ordering.</span>
<span class="gi">+</span>
<span class="gi">+# __hash__</span>
<span class="gi">+</span>
<span class="gi">+#    +------------------- unsafe_hash= parameter</span>
<span class="gi">+#    |       +----------- eq= parameter</span>
<span class="gi">+#    |       |       +--- frozen= parameter</span>
<span class="gi">+#    |       |       |</span>
<span class="gi">+#    v       v       v    |        |        |</span>
<span class="gi">+#                         |   no   |  yes   |  &lt;--- class has explicitly defined __hash__</span>
<span class="gi">+# +=======+=======+=======+========+========+</span>
<span class="gi">+# | False | False | False |        |        | No __eq__, use the base class __hash__</span>
<span class="gi">+# +-------+-------+-------+--------+--------+</span>
<span class="gi">+# | False | False | True  |        |        | No __eq__, use the base class __hash__</span>
<span class="gi">+# +-------+-------+-------+--------+--------+</span>
<span class="gi">+# | False | True  | False | None   |        | &lt;-- the default, not hashable</span>
<span class="gi">+# +-------+-------+-------+--------+--------+</span>
<span class="gi">+# | False | True  | True  | add    |        | Frozen, so hashable, allows override</span>
<span class="gi">+# +-------+-------+-------+--------+--------+</span>
<span class="gi">+# | True  | False | False | add    | raise  | Has no __eq__, but hashable</span>
<span class="gi">+# +-------+-------+-------+--------+--------+</span>
<span class="gi">+# | True  | False | True  | add    | raise  | Has no __eq__, but hashable</span>
<span class="gi">+# +-------+-------+-------+--------+--------+</span>
<span class="gi">+# | True  | True  | False | add    | raise  | Not frozen, but hashable</span>
<span class="gi">+# +-------+-------+-------+--------+--------+</span>
<span class="gi">+# | True  | True  | True  | add    | raise  | Frozen, so hashable</span>
<span class="gi">+# +=======+=======+=======+========+========+</span>
<span class="gi">+# For boxes that are blank, __hash__ is untouched and therefore</span>
<span class="gi">+# inherited from the base class.  If the base is object, then</span>
<span class="gi">+# id-based hashing is used.</span>
<span class="gi">+#</span>
<span class="gi">+# Note that a class may already have __hash__=None if it specified an</span>
<span class="gi">+# __eq__ method in the class body (not one that was created by</span>
<span class="gi">+# @dataclass).</span>
<span class="gi">+#</span>
<span class="gi">+# See _hash_action (below) for a coded version of this table.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Raised when an attempt is made to modify a frozen class.</span>
<span class="w"> </span>class FrozenInstanceError(AttributeError):
<span class="w"> </span>    pass


<span class="gi">+# A sentinel object for default values to signal that a default</span>
<span class="gi">+# factory will be used.  This is given a nice repr() which will appear</span>
<span class="gi">+# in the function signature of dataclasses&#39; constructors.</span>
<span class="w"> </span>class _HAS_DEFAULT_FACTORY_CLASS:
<span class="gd">-</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;factory&gt;&#39;</span>
<span class="gi">+        return &quot;&lt;factory&gt;&quot;</span>


<span class="w"> </span>_HAS_DEFAULT_FACTORY = _HAS_DEFAULT_FACTORY_CLASS()

<span class="gd">-</span>
<span class="gi">+# A sentinel object to detect if a parameter is supplied or not.  Use</span>
<span class="gi">+# a class to give it a better repr.</span>
<span class="w"> </span>class _MISSING_TYPE:
<span class="w"> </span>    pass


<span class="w"> </span>MISSING = _MISSING_TYPE()
<span class="gd">-_EMPTY_METADATA = types.MappingProxyType({})</span>

<span class="gi">+# Since most per-field metadata will be unused, create an empty</span>
<span class="gi">+# read-only proxy that can be shared among all fields.</span>
<span class="gi">+_EMPTY_METADATA = types.MappingProxyType({})</span>

<span class="gi">+# Markers for the various kinds of fields and pseudo-fields.</span>
<span class="w"> </span>class _FIELD_BASE:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, name):
<span class="w"> </span>        self.name = name

<span class="gu">@@ -39,17 +187,29 @@ class _FIELD_BASE:</span>
<span class="w"> </span>        return self.name


<span class="gd">-_FIELD = _FIELD_BASE(&#39;_FIELD&#39;)</span>
<span class="gd">-_FIELD_CLASSVAR = _FIELD_BASE(&#39;_FIELD_CLASSVAR&#39;)</span>
<span class="gd">-_FIELD_INITVAR = _FIELD_BASE(&#39;_FIELD_INITVAR&#39;)</span>
<span class="gd">-_FIELDS = &#39;__dataclass_fields__&#39;</span>
<span class="gd">-_PARAMS = &#39;__dataclass_params__&#39;</span>
<span class="gd">-_POST_INIT_NAME = &#39;__post_init__&#39;</span>
<span class="gd">-_MODULE_IDENTIFIER_RE = re.compile(&#39;^(?:\\s*(\\w+)\\s*\\.)?\\s*(\\w+)&#39;)</span>
<span class="gi">+_FIELD = _FIELD_BASE(&quot;_FIELD&quot;)</span>
<span class="gi">+_FIELD_CLASSVAR = _FIELD_BASE(&quot;_FIELD_CLASSVAR&quot;)</span>
<span class="gi">+_FIELD_INITVAR = _FIELD_BASE(&quot;_FIELD_INITVAR&quot;)</span>

<span class="gi">+# The name of an attribute on the class where we store the Field</span>
<span class="gi">+# objects.  Also used to check if a class is a Data Class.</span>
<span class="gi">+_FIELDS = &quot;__dataclass_fields__&quot;</span>

<span class="gd">-class _InitVarMeta(type):</span>
<span class="gi">+# The name of an attribute on the class that stores the parameters to</span>
<span class="gi">+# @dataclass.</span>
<span class="gi">+_PARAMS = &quot;__dataclass_params__&quot;</span>
<span class="gi">+</span>
<span class="gi">+# The name of the function, that if it exists, is called at the end of</span>
<span class="gi">+# __init__.</span>
<span class="gi">+_POST_INIT_NAME = &quot;__post_init__&quot;</span>
<span class="gi">+</span>
<span class="gi">+# String regex that string annotations for ClassVar or InitVar must match.</span>
<span class="gi">+# Allows &quot;identifier.identifier[&quot; or &quot;identifier[&quot;.</span>
<span class="gi">+# https://bugs.python.org/issue33453 for details.</span>
<span class="gi">+_MODULE_IDENTIFIER_RE = re.compile(r&quot;^(?:\s*(\w+)\s*\.)?\s*(\w+)&quot;)</span>

<span class="gi">+</span>
<span class="gi">+class _InitVarMeta(type):</span>
<span class="w"> </span>    def __getitem__(self, params):
<span class="w"> </span>        return self

<span class="gu">@@ -58,12 +218,31 @@ class InitVar(metaclass=_InitVarMeta):</span>
<span class="w"> </span>    pass


<span class="gi">+# Instances of Field are only ever created from within this module,</span>
<span class="gi">+# and only from the field() function, although Field instances are</span>
<span class="gi">+# exposed externally as (conceptually) read-only objects.</span>
<span class="gi">+#</span>
<span class="gi">+# name and type are filled in after the fact, not in __init__.</span>
<span class="gi">+# They&#39;re not known at the time this class is instantiated, but it&#39;s</span>
<span class="gi">+# convenient if they&#39;re available later.</span>
<span class="gi">+#</span>
<span class="gi">+# When cls._FIELDS is filled in with a list of Field objects, the name</span>
<span class="gi">+# and type fields will have been populated.</span>
<span class="w"> </span>class Field:
<span class="gd">-    __slots__ = (&#39;name&#39;, &#39;type&#39;, &#39;default&#39;, &#39;default_factory&#39;, &#39;repr&#39;,</span>
<span class="gd">-        &#39;hash&#39;, &#39;init&#39;, &#39;compare&#39;, &#39;metadata&#39;, &#39;_field_type&#39;)</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, default, default_factory, init, repr, hash, compare,</span>
<span class="gd">-        metadata):</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &quot;name&quot;,</span>
<span class="gi">+        &quot;type&quot;,</span>
<span class="gi">+        &quot;default&quot;,</span>
<span class="gi">+        &quot;default_factory&quot;,</span>
<span class="gi">+        &quot;repr&quot;,</span>
<span class="gi">+        &quot;hash&quot;,</span>
<span class="gi">+        &quot;init&quot;,</span>
<span class="gi">+        &quot;compare&quot;,</span>
<span class="gi">+        &quot;metadata&quot;,</span>
<span class="gi">+        &quot;_field_type&quot;,  # Private: not to be used by user code.</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, default, default_factory, init, repr, hash, compare, metadata):</span>
<span class="w"> </span>        self.name = None
<span class="w"> </span>        self.type = None
<span class="w"> </span>        self.default = default
<span class="gu">@@ -72,23 +251,47 @@ class Field:</span>
<span class="w"> </span>        self.repr = repr
<span class="w"> </span>        self.hash = hash
<span class="w"> </span>        self.compare = compare
<span class="gd">-        self.metadata = _EMPTY_METADATA if metadata is None or len(metadata</span>
<span class="gd">-            ) == 0 else types.MappingProxyType(metadata)</span>
<span class="gi">+        self.metadata = (</span>
<span class="gi">+            _EMPTY_METADATA</span>
<span class="gi">+            if metadata is None or len(metadata) == 0</span>
<span class="gi">+            else types.MappingProxyType(metadata)</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self._field_type = None

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return (
<span class="gd">-            f&#39;Field(name={self.name!r},type={self.type!r},default={self.default!r},default_factory={self.default_factory!r},init={self.init!r},repr={self.repr!r},hash={self.hash!r},compare={self.compare!r},metadata={self.metadata!r},_field_type={self._field_type})&#39;</span>
<span class="gd">-            )</span>
<span class="gd">-</span>
<span class="gi">+            &quot;Field(&quot;</span>
<span class="gi">+            f&quot;name={self.name!r},&quot;</span>
<span class="gi">+            f&quot;type={self.type!r},&quot;</span>
<span class="gi">+            f&quot;default={self.default!r},&quot;</span>
<span class="gi">+            f&quot;default_factory={self.default_factory!r},&quot;</span>
<span class="gi">+            f&quot;init={self.init!r},&quot;</span>
<span class="gi">+            f&quot;repr={self.repr!r},&quot;</span>
<span class="gi">+            f&quot;hash={self.hash!r},&quot;</span>
<span class="gi">+            f&quot;compare={self.compare!r},&quot;</span>
<span class="gi">+            f&quot;metadata={self.metadata!r},&quot;</span>
<span class="gi">+            f&quot;_field_type={self._field_type}&quot;</span>
<span class="gi">+            &quot;)&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # This is used to support the PEP 487 __set_name__ protocol in the</span>
<span class="gi">+    # case where we&#39;re using a field that contains a descriptor as a</span>
<span class="gi">+    # defaul value.  For details on __set_name__, see</span>
<span class="gi">+    # https://www.python.org/dev/peps/pep-0487/#implementation-details.</span>
<span class="gi">+    #</span>
<span class="gi">+    # Note that in _process_class, this Field object is overwritten</span>
<span class="gi">+    # with the default value, so the end result is a descriptor that</span>
<span class="gi">+    # had __set_name__ called on it at the right time.</span>
<span class="w"> </span>    def __set_name__(self, owner, name):
<span class="gd">-        func = getattr(type(self.default), &#39;__set_name__&#39;, None)</span>
<span class="gi">+        func = getattr(type(self.default), &quot;__set_name__&quot;, None)</span>
<span class="w"> </span>        if func:
<span class="gi">+            # There is a __set_name__ method on the descriptor, call</span>
<span class="gi">+            # it.</span>
<span class="w"> </span>            func(self.default, owner, name)


<span class="w"> </span>class _DataclassParams:
<span class="gd">-    __slots__ = &#39;init&#39;, &#39;repr&#39;, &#39;eq&#39;, &#39;order&#39;, &#39;unsafe_hash&#39;, &#39;frozen&#39;</span>
<span class="gi">+    __slots__ = (&quot;init&quot;, &quot;repr&quot;, &quot;eq&quot;, &quot;order&quot;, &quot;unsafe_hash&quot;, &quot;frozen&quot;)</span>

<span class="w"> </span>    def __init__(self, init, repr, eq, order, unsafe_hash, frozen):
<span class="w"> </span>        self.init = init
<span class="gu">@@ -100,12 +303,30 @@ class _DataclassParams:</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return (
<span class="gd">-            f&#39;_DataclassParams(init={self.init!r},repr={self.repr!r},eq={self.eq!r},order={self.order!r},unsafe_hash={self.unsafe_hash!r},frozen={self.frozen!r})&#39;</span>
<span class="gd">-            )</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def field(*, default=MISSING, default_factory=MISSING, init=True, repr=True,</span>
<span class="gd">-    hash=None, compare=True, metadata=None):</span>
<span class="gi">+            &quot;_DataclassParams(&quot;</span>
<span class="gi">+            f&quot;init={self.init!r},&quot;</span>
<span class="gi">+            f&quot;repr={self.repr!r},&quot;</span>
<span class="gi">+            f&quot;eq={self.eq!r},&quot;</span>
<span class="gi">+            f&quot;order={self.order!r},&quot;</span>
<span class="gi">+            f&quot;unsafe_hash={self.unsafe_hash!r},&quot;</span>
<span class="gi">+            f&quot;frozen={self.frozen!r}&quot;</span>
<span class="gi">+            &quot;)&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# This function is used instead of exposing Field creation directly,</span>
<span class="gi">+# so that a type checker can be told (via overloads) that this is a</span>
<span class="gi">+# function whose type depends on its parameters.</span>
<span class="gi">+def field(</span>
<span class="gi">+    *,</span>
<span class="gi">+    default=MISSING,</span>
<span class="gi">+    default_factory=MISSING,</span>
<span class="gi">+    init=True,</span>
<span class="gi">+    repr=True,</span>
<span class="gi">+    hash=None,</span>
<span class="gi">+    compare=True,</span>
<span class="gi">+    metadata=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Return an object to identify dataclass fields.

<span class="w"> </span>    default is the default value of the field.  default_factory is a
<span class="gu">@@ -119,22 +340,631 @@ def field(*, default=MISSING, default_factory=MISSING, init=True, repr=True,</span>

<span class="w"> </span>    It is an error to specify both default and default_factory.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-_hash_action = {(False, False, False, False): None, (False, False, False, </span>
<span class="gd">-    True): None, (False, False, True, False): None, (False, False, True, </span>
<span class="gd">-    True): None, (False, True, False, False): _hash_set_none, (False, True,</span>
<span class="gd">-    False, True): None, (False, True, True, False): _hash_add, (False, True,</span>
<span class="gd">-    True, True): None, (True, False, False, False): _hash_add, (True, False,</span>
<span class="gd">-    False, True): _hash_exception, (True, False, True, False): _hash_add, (</span>
<span class="gd">-    True, False, True, True): _hash_exception, (True, True, False, False):</span>
<span class="gd">-    _hash_add, (True, True, False, True): _hash_exception, (True, True, </span>
<span class="gd">-    True, False): _hash_add, (True, True, True, True): _hash_exception}</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def dataclass(_cls=None, *, init=True, repr=True, eq=True, order=False,</span>
<span class="gd">-    unsafe_hash=False, frozen=False):</span>
<span class="gi">+    if default is not MISSING and default_factory is not MISSING:</span>
<span class="gi">+        raise ValueError(&quot;cannot specify both default and default_factory&quot;)</span>
<span class="gi">+    return Field(default, default_factory, init, repr, hash, compare, metadata)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _tuple_str(obj_name, fields):</span>
<span class="gi">+    # Return a string representing each field of obj_name as a tuple</span>
<span class="gi">+    # member.  So, if fields is [&#39;x&#39;, &#39;y&#39;] and obj_name is &quot;self&quot;,</span>
<span class="gi">+    # return &quot;(self.x,self.y)&quot;.</span>
<span class="gi">+</span>
<span class="gi">+    # Special case for the 0-tuple.</span>
<span class="gi">+    if not fields:</span>
<span class="gi">+        return &quot;()&quot;</span>
<span class="gi">+    # Note the trailing comma, needed if this turns out to be a 1-tuple.</span>
<span class="gi">+    return f&#39;({&quot;,&quot;.join([f&quot;{obj_name}.{f.name}&quot; for f in fields])},)&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _create_fn(name, args, body, *, globals=None, locals=None, return_type=MISSING):</span>
<span class="gi">+    # Note that we mutate locals when exec() is called.  Caller</span>
<span class="gi">+    # beware!  The only callers are internal to this module, so no</span>
<span class="gi">+    # worries about external callers.</span>
<span class="gi">+    if locals is None:</span>
<span class="gi">+        locals = {}</span>
<span class="gi">+    return_annotation = &quot;&quot;</span>
<span class="gi">+    if return_type is not MISSING:</span>
<span class="gi">+        locals[&quot;_return_type&quot;] = return_type</span>
<span class="gi">+        return_annotation = &quot;-&gt;_return_type&quot;</span>
<span class="gi">+    args = &quot;,&quot;.join(args)</span>
<span class="gi">+    body = &quot;\n&quot;.join(f&quot; {b}&quot; for b in body)</span>
<span class="gi">+</span>
<span class="gi">+    # Compute the text of the entire function.</span>
<span class="gi">+    txt = f&quot;def {name}({args}){return_annotation}:\n{body}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    exec(txt, globals, locals)</span>
<span class="gi">+    return locals[name]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _field_assign(frozen, name, value, self_name):</span>
<span class="gi">+    # If we&#39;re a frozen class, then assign to our fields in __init__</span>
<span class="gi">+    # via object.__setattr__.  Otherwise, just use a simple</span>
<span class="gi">+    # assignment.</span>
<span class="gi">+    #</span>
<span class="gi">+    # self_name is what &quot;self&quot; is called in this function: don&#39;t</span>
<span class="gi">+    # hard-code &quot;self&quot;, since that might be a field name.</span>
<span class="gi">+    if frozen:</span>
<span class="gi">+        return f&quot;object.__setattr__({self_name},{name!r},{value})&quot;</span>
<span class="gi">+    return f&quot;{self_name}.{name}={value}&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _field_init(f, frozen, globals, self_name):</span>
<span class="gi">+    # Return the text of the line in the body of __init__ that will</span>
<span class="gi">+    # initialize this field.</span>
<span class="gi">+</span>
<span class="gi">+    default_name = f&quot;_dflt_{f.name}&quot;</span>
<span class="gi">+    if f.default_factory is not MISSING:</span>
<span class="gi">+        if f.init:</span>
<span class="gi">+            # This field has a default factory.  If a parameter is</span>
<span class="gi">+            # given, use it.  If not, call the factory.</span>
<span class="gi">+            globals[default_name] = f.default_factory</span>
<span class="gi">+            value = (</span>
<span class="gi">+                f&quot;{default_name}() &quot;</span>
<span class="gi">+                f&quot;if {f.name} is _HAS_DEFAULT_FACTORY &quot;</span>
<span class="gi">+                f&quot;else {f.name}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            # This is a field that&#39;s not in the __init__ params, but</span>
<span class="gi">+            # has a default factory function.  It needs to be</span>
<span class="gi">+            # initialized here by calling the factory function,</span>
<span class="gi">+            # because there&#39;s no other way to initialize it.</span>
<span class="gi">+</span>
<span class="gi">+            # For a field initialized with a default=defaultvalue, the</span>
<span class="gi">+            # class dict just has the default value</span>
<span class="gi">+            # (cls.fieldname=defaultvalue).  But that won&#39;t work for a</span>
<span class="gi">+            # default factory, the factory must be called in __init__</span>
<span class="gi">+            # and we must assign that to self.fieldname.  We can&#39;t</span>
<span class="gi">+            # fall back to the class dict&#39;s value, both because it&#39;s</span>
<span class="gi">+            # not set, and because it might be different per-class</span>
<span class="gi">+            # (which, after all, is why we have a factory function!).</span>
<span class="gi">+</span>
<span class="gi">+            globals[default_name] = f.default_factory</span>
<span class="gi">+            value = f&quot;{default_name}()&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        # No default factory.</span>
<span class="gi">+        if f.init:</span>
<span class="gi">+            if f.default is MISSING:</span>
<span class="gi">+                # There&#39;s no default, just do an assignment.</span>
<span class="gi">+                value = f.name</span>
<span class="gi">+            elif f.default is not MISSING:</span>
<span class="gi">+                globals[default_name] = f.default</span>
<span class="gi">+                value = f.name</span>
<span class="gi">+        else:</span>
<span class="gi">+            # This field does not need initialization.  Signify that</span>
<span class="gi">+            # to the caller by returning None.</span>
<span class="gi">+            return None</span>
<span class="gi">+    # Only test this now, so that we can create variables for the</span>
<span class="gi">+    # default.  However, return None to signify that we&#39;re not going</span>
<span class="gi">+    # to actually do the assignment statement for InitVars.</span>
<span class="gi">+    if f._field_type == _FIELD_INITVAR:</span>
<span class="gi">+        return None</span>
<span class="gi">+    # Now, actually generate the field assignment.</span>
<span class="gi">+    return _field_assign(frozen, f.name, value, self_name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _init_param(f):</span>
<span class="gi">+    # Return the __init__ parameter string for this field.  For</span>
<span class="gi">+    # example, the equivalent of &#39;x:int=3&#39; (except instead of &#39;int&#39;,</span>
<span class="gi">+    # reference a variable set to int, and instead of &#39;3&#39;, reference a</span>
<span class="gi">+    # variable set to 3).</span>
<span class="gi">+    if f.default is MISSING and f.default_factory is MISSING:</span>
<span class="gi">+        # There&#39;s no default, and no default_factory, just output the</span>
<span class="gi">+        # variable name and type.</span>
<span class="gi">+        default = &quot;&quot;</span>
<span class="gi">+    elif f.default is not MISSING:</span>
<span class="gi">+        # There&#39;s a default, this will be the name that&#39;s used to look</span>
<span class="gi">+        # it up.</span>
<span class="gi">+        default = f&quot;=_dflt_{f.name}&quot;</span>
<span class="gi">+    elif f.default_factory is not MISSING:</span>
<span class="gi">+        # There&#39;s a factory function.  Set a marker.</span>
<span class="gi">+        default = &quot;=_HAS_DEFAULT_FACTORY&quot;</span>
<span class="gi">+    return f&quot;{f.name}:_type_{f.name}{default}&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _init_fn(fields, frozen, has_post_init, self_name):</span>
<span class="gi">+    # fields contains both real fields and InitVar pseudo-fields.</span>
<span class="gi">+</span>
<span class="gi">+    # Make sure we don&#39;t have fields without defaults following fields</span>
<span class="gi">+    # with defaults.  This actually would be caught when exec-ing the</span>
<span class="gi">+    # function source code, but catching it here gives a better error</span>
<span class="gi">+    # message, and future-proofs us in case we build up the function</span>
<span class="gi">+    # using ast.</span>
<span class="gi">+    seen_default = False</span>
<span class="gi">+    for f in fields:</span>
<span class="gi">+        # Only consider fields in the __init__ call.</span>
<span class="gi">+        if f.init:</span>
<span class="gi">+            if not (f.default is MISSING and f.default_factory is MISSING):</span>
<span class="gi">+                seen_default = True</span>
<span class="gi">+            elif seen_default:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;non-default argument {f.name!r} &quot; &quot;follows default argument&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+    globals = {&quot;MISSING&quot;: MISSING, &quot;_HAS_DEFAULT_FACTORY&quot;: _HAS_DEFAULT_FACTORY}</span>
<span class="gi">+</span>
<span class="gi">+    body_lines = []</span>
<span class="gi">+    for f in fields:</span>
<span class="gi">+        line = _field_init(f, frozen, globals, self_name)</span>
<span class="gi">+        # line is None means that this field doesn&#39;t require</span>
<span class="gi">+        # initialization (it&#39;s a pseudo-field).  Just skip it.</span>
<span class="gi">+        if line:</span>
<span class="gi">+            body_lines.append(line)</span>
<span class="gi">+    # Does this class have a post-init function?</span>
<span class="gi">+    if has_post_init:</span>
<span class="gi">+        params_str = &quot;,&quot;.join(f.name for f in fields if f._field_type is _FIELD_INITVAR)</span>
<span class="gi">+        body_lines.append(f&quot;{self_name}.{_POST_INIT_NAME}({params_str})&quot;)</span>
<span class="gi">+    # If no body lines, use &#39;pass&#39;.</span>
<span class="gi">+    if not body_lines:</span>
<span class="gi">+        body_lines = [&quot;pass&quot;]</span>
<span class="gi">+    locals = {f&quot;_type_{f.name}&quot;: f.type for f in fields}</span>
<span class="gi">+    return _create_fn(</span>
<span class="gi">+        &quot;__init__&quot;,</span>
<span class="gi">+        [self_name] + [_init_param(f) for f in fields if f.init],</span>
<span class="gi">+        body_lines,</span>
<span class="gi">+        locals=locals,</span>
<span class="gi">+        globals=globals,</span>
<span class="gi">+        return_type=None,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _repr_fn(fields):</span>
<span class="gi">+    return _create_fn(</span>
<span class="gi">+        &quot;__repr__&quot;,</span>
<span class="gi">+        (&quot;self&quot;,),</span>
<span class="gi">+        [</span>
<span class="gi">+            &#39;return self.__class__.__qualname__ + f&quot;(&#39;</span>
<span class="gi">+            + &quot;, &quot;.join([f&quot;{f.name}={{self.{f.name}!r}}&quot; for f in fields])</span>
<span class="gi">+            + &#39;)&quot;&#39;</span>
<span class="gi">+        ],</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _frozen_get_del_attr(cls, fields):</span>
<span class="gi">+    # XXX: globals is modified on the first call to _create_fn, then</span>
<span class="gi">+    # the modified version is used in the second call.  Is this okay?</span>
<span class="gi">+    globals = {&quot;cls&quot;: cls, &quot;FrozenInstanceError&quot;: FrozenInstanceError}</span>
<span class="gi">+    if fields:</span>
<span class="gi">+        fields_str = &quot;(&quot; + &quot;,&quot;.join(repr(f.name) for f in fields) + &quot;,)&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Special case for the zero-length tuple.</span>
<span class="gi">+        fields_str = &quot;()&quot;</span>
<span class="gi">+    return (</span>
<span class="gi">+        _create_fn(</span>
<span class="gi">+            &quot;__setattr__&quot;,</span>
<span class="gi">+            (&quot;self&quot;, &quot;name&quot;, &quot;value&quot;),</span>
<span class="gi">+            (</span>
<span class="gi">+                f&quot;if type(self) is cls or name in {fields_str}:&quot;,</span>
<span class="gi">+                &#39; raise FrozenInstanceError(f&quot;cannot assign to field {name!r}&quot;)&#39;,</span>
<span class="gi">+                f&quot;super(cls, self).__setattr__(name, value)&quot;,</span>
<span class="gi">+            ),</span>
<span class="gi">+            globals=globals,</span>
<span class="gi">+        ),</span>
<span class="gi">+        _create_fn(</span>
<span class="gi">+            &quot;__delattr__&quot;,</span>
<span class="gi">+            (&quot;self&quot;, &quot;name&quot;),</span>
<span class="gi">+            (</span>
<span class="gi">+                f&quot;if type(self) is cls or name in {fields_str}:&quot;,</span>
<span class="gi">+                &#39; raise FrozenInstanceError(f&quot;cannot delete field {name!r}&quot;)&#39;,</span>
<span class="gi">+                f&quot;super(cls, self).__delattr__(name)&quot;,</span>
<span class="gi">+            ),</span>
<span class="gi">+            globals=globals,</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _cmp_fn(name, op, self_tuple, other_tuple):</span>
<span class="gi">+    # Create a comparison function.  If the fields in the object are</span>
<span class="gi">+    # named &#39;x&#39; and &#39;y&#39;, then self_tuple is the string</span>
<span class="gi">+    # &#39;(self.x,self.y)&#39; and other_tuple is the string</span>
<span class="gi">+    # &#39;(other.x,other.y)&#39;.</span>
<span class="gi">+</span>
<span class="gi">+    return _create_fn(</span>
<span class="gi">+        name,</span>
<span class="gi">+        (&quot;self&quot;, &quot;other&quot;),</span>
<span class="gi">+        [</span>
<span class="gi">+            &quot;if other.__class__ is self.__class__:&quot;,</span>
<span class="gi">+            f&quot; return {self_tuple}{op}{other_tuple}&quot;,</span>
<span class="gi">+            &quot;return NotImplemented&quot;,</span>
<span class="gi">+        ],</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _hash_fn(fields):</span>
<span class="gi">+    self_tuple = _tuple_str(&quot;self&quot;, fields)</span>
<span class="gi">+    return _create_fn(&quot;__hash__&quot;, (&quot;self&quot;,), [f&quot;return hash({self_tuple})&quot;])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_classvar(a_type, typing):</span>
<span class="gi">+    # This test uses a typing internal class, but it&#39;s the best way to</span>
<span class="gi">+    # test if this is a ClassVar.</span>
<span class="gi">+    return type(a_type) is typing._ClassVar</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_initvar(a_type, dataclasses):</span>
<span class="gi">+    # The module we&#39;re checking against is the module we&#39;re</span>
<span class="gi">+    # currently in (dataclasses.py).</span>
<span class="gi">+    return a_type is dataclasses.InitVar</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_type(annotation, cls, a_module, a_type, is_type_predicate):</span>
<span class="gi">+    # Given a type annotation string, does it refer to a_type in</span>
<span class="gi">+    # a_module?  For example, when checking that annotation denotes a</span>
<span class="gi">+    # ClassVar, then a_module is typing, and a_type is</span>
<span class="gi">+    # typing.ClassVar.</span>
<span class="gi">+</span>
<span class="gi">+    # It&#39;s possible to look up a_module given a_type, but it involves</span>
<span class="gi">+    # looking in sys.modules (again!), and seems like a waste since</span>
<span class="gi">+    # the caller already knows a_module.</span>
<span class="gi">+</span>
<span class="gi">+    # - annotation is a string type annotation</span>
<span class="gi">+    # - cls is the class that this annotation was found in</span>
<span class="gi">+    # - a_module is the module we want to match</span>
<span class="gi">+    # - a_type is the type in that module we want to match</span>
<span class="gi">+    # - is_type_predicate is a function called with (obj, a_module)</span>
<span class="gi">+    #   that determines if obj is of the desired type.</span>
<span class="gi">+</span>
<span class="gi">+    # Since this test does not do a local namespace lookup (and</span>
<span class="gi">+    # instead only a module (global) lookup), there are some things it</span>
<span class="gi">+    # gets wrong.</span>
<span class="gi">+</span>
<span class="gi">+    # With string annotations, cv0 will be detected as a ClassVar:</span>
<span class="gi">+    #   CV = ClassVar</span>
<span class="gi">+    #   @dataclass</span>
<span class="gi">+    #   class C0:</span>
<span class="gi">+    #     cv0: CV</span>
<span class="gi">+</span>
<span class="gi">+    # But in this example cv1 will not be detected as a ClassVar:</span>
<span class="gi">+    #   @dataclass</span>
<span class="gi">+    #   class C1:</span>
<span class="gi">+    #     CV = ClassVar</span>
<span class="gi">+    #     cv1: CV</span>
<span class="gi">+</span>
<span class="gi">+    # In C1, the code in this function (_is_type) will look up &quot;CV&quot; in</span>
<span class="gi">+    # the module and not find it, so it will not consider cv1 as a</span>
<span class="gi">+    # ClassVar.  This is a fairly obscure corner case, and the best</span>
<span class="gi">+    # way to fix it would be to eval() the string &quot;CV&quot; with the</span>
<span class="gi">+    # correct global and local namespaces.  However that would involve</span>
<span class="gi">+    # a eval() penalty for every single field of every dataclass</span>
<span class="gi">+    # that&#39;s defined.  It was judged not worth it.</span>
<span class="gi">+</span>
<span class="gi">+    match = _MODULE_IDENTIFIER_RE.match(annotation)</span>
<span class="gi">+    if match:</span>
<span class="gi">+        ns = None</span>
<span class="gi">+        module_name = match.group(1)</span>
<span class="gi">+        if not module_name:</span>
<span class="gi">+            # No module name, assume the class&#39;s module did</span>
<span class="gi">+            # &quot;from dataclasses import InitVar&quot;.</span>
<span class="gi">+            ns = sys.modules.get(cls.__module__).__dict__</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Look up module_name in the class&#39;s module.</span>
<span class="gi">+            module = sys.modules.get(cls.__module__)</span>
<span class="gi">+            if module and module.__dict__.get(module_name) is a_module:</span>
<span class="gi">+                ns = sys.modules.get(a_type.__module__).__dict__</span>
<span class="gi">+        if ns and is_type_predicate(ns.get(match.group(2)), a_module):</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_field(cls, a_name, a_type):</span>
<span class="gi">+    # Return a Field object for this field name and type.  ClassVars</span>
<span class="gi">+    # and InitVars are also returned, but marked as such (see</span>
<span class="gi">+    # f._field_type).</span>
<span class="gi">+</span>
<span class="gi">+    # If the default value isn&#39;t derived from Field, then it&#39;s only a</span>
<span class="gi">+    # normal default value.  Convert it to a Field().</span>
<span class="gi">+    default = getattr(cls, a_name, MISSING)</span>
<span class="gi">+    if isinstance(default, Field):</span>
<span class="gi">+        f = default</span>
<span class="gi">+    else:</span>
<span class="gi">+        if isinstance(default, types.MemberDescriptorType):</span>
<span class="gi">+            # This is a field in __slots__, so it has no default value.</span>
<span class="gi">+            default = MISSING</span>
<span class="gi">+        f = field(default=default)</span>
<span class="gi">+    # Only at this point do we know the name and the type.  Set them.</span>
<span class="gi">+    f.name = a_name</span>
<span class="gi">+    f.type = a_type</span>
<span class="gi">+</span>
<span class="gi">+    # Assume it&#39;s a normal field until proven otherwise.  We&#39;re next</span>
<span class="gi">+    # going to decide if it&#39;s a ClassVar or InitVar, everything else</span>
<span class="gi">+    # is just a normal field.</span>
<span class="gi">+    f._field_type = _FIELD</span>
<span class="gi">+</span>
<span class="gi">+    # In addition to checking for actual types here, also check for</span>
<span class="gi">+    # string annotations.  get_type_hints() won&#39;t always work for us</span>
<span class="gi">+    # (see https://github.com/python/typing/issues/508 for example),</span>
<span class="gi">+    # plus it&#39;s expensive and would require an eval for every stirng</span>
<span class="gi">+    # annotation.  So, make a best effort to see if this is a ClassVar</span>
<span class="gi">+    # or InitVar using regex&#39;s and checking that the thing referenced</span>
<span class="gi">+    # is actually of the correct type.</span>
<span class="gi">+</span>
<span class="gi">+    # For the complete discussion, see https://bugs.python.org/issue33453</span>
<span class="gi">+</span>
<span class="gi">+    # If typing has not been imported, then it&#39;s impossible for any</span>
<span class="gi">+    # annotation to be a ClassVar.  So, only look for ClassVar if</span>
<span class="gi">+    # typing has been imported by any module (not necessarily cls&#39;s</span>
<span class="gi">+    # module).</span>
<span class="gi">+    typing = sys.modules.get(&quot;typing&quot;)</span>
<span class="gi">+    if typing:</span>
<span class="gi">+        if _is_classvar(a_type, typing) or (</span>
<span class="gi">+            isinstance(f.type, str)</span>
<span class="gi">+            and _is_type(f.type, cls, typing, typing.ClassVar, _is_classvar)</span>
<span class="gi">+        ):</span>
<span class="gi">+            f._field_type = _FIELD_CLASSVAR</span>
<span class="gi">+    # If the type is InitVar, or if it&#39;s a matching string annotation,</span>
<span class="gi">+    # then it&#39;s an InitVar.</span>
<span class="gi">+    if f._field_type is _FIELD:</span>
<span class="gi">+        # The module we&#39;re checking against is the module we&#39;re</span>
<span class="gi">+        # currently in (dataclasses.py).</span>
<span class="gi">+        dataclasses = sys.modules[__name__]</span>
<span class="gi">+        if _is_initvar(a_type, dataclasses) or (</span>
<span class="gi">+            isinstance(f.type, str)</span>
<span class="gi">+            and _is_type(f.type, cls, dataclasses, dataclasses.InitVar, _is_initvar)</span>
<span class="gi">+        ):</span>
<span class="gi">+            f._field_type = _FIELD_INITVAR</span>
<span class="gi">+    # Validations for individual fields.  This is delayed until now,</span>
<span class="gi">+    # instead of in the Field() constructor, since only here do we</span>
<span class="gi">+    # know the field name, which allows for better error reporting.</span>
<span class="gi">+</span>
<span class="gi">+    # Special restrictions for ClassVar and InitVar.</span>
<span class="gi">+    if f._field_type in (_FIELD_CLASSVAR, _FIELD_INITVAR):</span>
<span class="gi">+        if f.default_factory is not MISSING:</span>
<span class="gi">+            raise TypeError(f&quot;field {f.name} cannot have a &quot; &quot;default factory&quot;)</span>
<span class="gi">+        # Should I check for other field settings? default_factory</span>
<span class="gi">+        # seems the most serious to check for.  Maybe add others.  For</span>
<span class="gi">+        # example, how about init=False (or really,</span>
<span class="gi">+        # init=&lt;not-the-default-init-value&gt;)?  It makes no sense for</span>
<span class="gi">+        # ClassVar and InitVar to specify init=&lt;anything&gt;.</span>
<span class="gi">+    # For real fields, disallow mutable defaults for known types.</span>
<span class="gi">+    if f._field_type is _FIELD and isinstance(f.default, (list, dict, set)):</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            f&quot;mutable default {type(f.default)} for field &quot;</span>
<span class="gi">+            f&quot;{f.name} is not allowed: use default_factory&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    return f</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _set_new_attribute(cls, name, value):</span>
<span class="gi">+    # Never overwrites an existing attribute.  Returns True if the</span>
<span class="gi">+    # attribute already exists.</span>
<span class="gi">+    if name in cls.__dict__:</span>
<span class="gi">+        return True</span>
<span class="gi">+    setattr(cls, name, value)</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Decide if/how we&#39;re going to create a hash function.  Key is</span>
<span class="gi">+# (unsafe_hash, eq, frozen, does-hash-exist).  Value is the action to</span>
<span class="gi">+# take.  The common case is to do nothing, so instead of providing a</span>
<span class="gi">+# function that is a no-op, use None to signify that.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _hash_set_none(cls, fields):</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _hash_add(cls, fields):</span>
<span class="gi">+    flds = [f for f in fields if (f.compare if f.hash is None else f.hash)]</span>
<span class="gi">+    return _hash_fn(flds)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _hash_exception(cls, fields):</span>
<span class="gi">+    # Raise an exception.</span>
<span class="gi">+    raise TypeError(f&quot;Cannot overwrite attribute __hash__ &quot; f&quot;in class {cls.__name__}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#</span>
<span class="gi">+#                +-------------------------------------- unsafe_hash?</span>
<span class="gi">+#                |      +------------------------------- eq?</span>
<span class="gi">+#                |      |      +------------------------ frozen?</span>
<span class="gi">+#                |      |      |      +----------------  has-explicit-hash?</span>
<span class="gi">+#                |      |      |      |</span>
<span class="gi">+#                |      |      |      |        +-------  action</span>
<span class="gi">+#                |      |      |      |        |</span>
<span class="gi">+#                v      v      v      v        v</span>
<span class="gi">+_hash_action = {</span>
<span class="gi">+    (False, False, False, False): None,</span>
<span class="gi">+    (False, False, False, True): None,</span>
<span class="gi">+    (False, False, True, False): None,</span>
<span class="gi">+    (False, False, True, True): None,</span>
<span class="gi">+    (False, True, False, False): _hash_set_none,</span>
<span class="gi">+    (False, True, False, True): None,</span>
<span class="gi">+    (False, True, True, False): _hash_add,</span>
<span class="gi">+    (False, True, True, True): None,</span>
<span class="gi">+    (True, False, False, False): _hash_add,</span>
<span class="gi">+    (True, False, False, True): _hash_exception,</span>
<span class="gi">+    (True, False, True, False): _hash_add,</span>
<span class="gi">+    (True, False, True, True): _hash_exception,</span>
<span class="gi">+    (True, True, False, False): _hash_add,</span>
<span class="gi">+    (True, True, False, True): _hash_exception,</span>
<span class="gi">+    (True, True, True, False): _hash_add,</span>
<span class="gi">+    (True, True, True, True): _hash_exception,</span>
<span class="gi">+}</span>
<span class="gi">+# See https://bugs.python.org/issue32929#msg312829 for an if-statement</span>
<span class="gi">+# version of this table.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen):</span>
<span class="gi">+    # Now that dicts retain insertion order, there&#39;s no reason to use</span>
<span class="gi">+    # an ordered dict.  I am leveraging that ordering here, because</span>
<span class="gi">+    # derived class fields overwrite base class fields, but the order</span>
<span class="gi">+    # is defined by the base class, which is found first.</span>
<span class="gi">+    fields = {}</span>
<span class="gi">+</span>
<span class="gi">+    setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order, unsafe_hash, frozen))</span>
<span class="gi">+</span>
<span class="gi">+    # Find our base classes in reverse MRO order, and exclude</span>
<span class="gi">+    # ourselves.  In reversed order so that more derived classes</span>
<span class="gi">+    # override earlier field definitions in base classes.  As long as</span>
<span class="gi">+    # we&#39;re iterating over them, see if any are frozen.</span>
<span class="gi">+    any_frozen_base = False</span>
<span class="gi">+    has_dataclass_bases = False</span>
<span class="gi">+    for b in cls.__mro__[-1:0:-1]:</span>
<span class="gi">+        # Only process classes that have been processed by our</span>
<span class="gi">+        # decorator.  That is, they have a _FIELDS attribute.</span>
<span class="gi">+        base_fields = getattr(b, _FIELDS, None)</span>
<span class="gi">+        if base_fields:</span>
<span class="gi">+            has_dataclass_bases = True</span>
<span class="gi">+            for f in base_fields.values():</span>
<span class="gi">+                fields[f.name] = f</span>
<span class="gi">+            if getattr(b, _PARAMS).frozen:</span>
<span class="gi">+                any_frozen_base = True</span>
<span class="gi">+    # Annotations that are defined in this class (not in base</span>
<span class="gi">+    # classes).  If __annotations__ isn&#39;t present, then this class</span>
<span class="gi">+    # adds no new annotations.  We use this to compute fields that are</span>
<span class="gi">+    # added by this class.</span>
<span class="gi">+    #</span>
<span class="gi">+    # Fields are found from cls_annotations, which is guaranteed to be</span>
<span class="gi">+    # ordered.  Default values are from class attributes, if a field</span>
<span class="gi">+    # has a default.  If the default value is a Field(), then it</span>
<span class="gi">+    # contains additional info beyond (and possibly including) the</span>
<span class="gi">+    # actual default value.  Pseudo-fields ClassVars and InitVars are</span>
<span class="gi">+    # included, despite the fact that they&#39;re not real fields.  That&#39;s</span>
<span class="gi">+    # dealt with later.</span>
<span class="gi">+    cls_annotations = cls.__dict__.get(&quot;__annotations__&quot;, {})</span>
<span class="gi">+</span>
<span class="gi">+    # Now find fields in our class.  While doing so, validate some</span>
<span class="gi">+    # things, and set the default values (as class attributes) where</span>
<span class="gi">+    # we can.</span>
<span class="gi">+    cls_fields = [</span>
<span class="gi">+        _get_field(cls, name, type_) for name, type_ in cls_annotations.items()</span>
<span class="gi">+    ]</span>
<span class="gi">+    for f in cls_fields:</span>
<span class="gi">+        fields[f.name] = f</span>
<span class="gi">+</span>
<span class="gi">+        # If the class attribute (which is the default value for this</span>
<span class="gi">+        # field) exists and is of type &#39;Field&#39;, replace it with the</span>
<span class="gi">+        # real default.  This is so that normal class introspection</span>
<span class="gi">+        # sees a real default value, not a Field.</span>
<span class="gi">+        if isinstance(getattr(cls, f.name, None), Field):</span>
<span class="gi">+            if f.default is MISSING:</span>
<span class="gi">+                # If there&#39;s no default, delete the class attribute.</span>
<span class="gi">+                # This happens if we specify field(repr=False), for</span>
<span class="gi">+                # example (that is, we specified a field object, but</span>
<span class="gi">+                # no default value).  Also if we&#39;re using a default</span>
<span class="gi">+                # factory.  The class attribute should not be set at</span>
<span class="gi">+                # all in the post-processed class.</span>
<span class="gi">+                delattr(cls, f.name)</span>
<span class="gi">+            else:</span>
<span class="gi">+                setattr(cls, f.name, f.default)</span>
<span class="gi">+    # Do we have any Field members that don&#39;t also have annotations?</span>
<span class="gi">+    for name, value in cls.__dict__.items():</span>
<span class="gi">+        if isinstance(value, Field) and not name in cls_annotations:</span>
<span class="gi">+            raise TypeError(f&quot;{name!r} is a field but has no type annotation&quot;)</span>
<span class="gi">+    # Check rules that apply if we are derived from any dataclasses.</span>
<span class="gi">+    if has_dataclass_bases:</span>
<span class="gi">+        # Raise an exception if any of our bases are frozen, but we&#39;re not.</span>
<span class="gi">+        if any_frozen_base and not frozen:</span>
<span class="gi">+            raise TypeError(&quot;cannot inherit non-frozen dataclass from a &quot; &quot;frozen one&quot;)</span>
<span class="gi">+        # Raise an exception if we&#39;re frozen, but none of our bases are.</span>
<span class="gi">+        if not any_frozen_base and frozen:</span>
<span class="gi">+            raise TypeError(&quot;cannot inherit frozen dataclass from a &quot; &quot;non-frozen one&quot;)</span>
<span class="gi">+    # Remember all of the fields on our class (including bases).  This</span>
<span class="gi">+    # also marks this class as being a dataclass.</span>
<span class="gi">+    setattr(cls, _FIELDS, fields)</span>
<span class="gi">+</span>
<span class="gi">+    # Was this class defined with an explicit __hash__?  Note that if</span>
<span class="gi">+    # __eq__ is defined in this class, then python will automatically</span>
<span class="gi">+    # set __hash__ to None.  This is a heuristic, as it&#39;s possible</span>
<span class="gi">+    # that such a __hash__ == None was not auto-generated, but it</span>
<span class="gi">+    # close enough.</span>
<span class="gi">+    class_hash = cls.__dict__.get(&quot;__hash__&quot;, MISSING)</span>
<span class="gi">+    has_explicit_hash = not (</span>
<span class="gi">+        class_hash is MISSING or (class_hash is None and &quot;__eq__&quot; in cls.__dict__)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # If we&#39;re generating ordering methods, we must be generating the</span>
<span class="gi">+    # eq methods.</span>
<span class="gi">+    if order and not eq:</span>
<span class="gi">+        raise ValueError(&quot;eq must be true if order is true&quot;)</span>
<span class="gi">+    if init:</span>
<span class="gi">+        # Does this class have a post-init function?</span>
<span class="gi">+        has_post_init = hasattr(cls, _POST_INIT_NAME)</span>
<span class="gi">+</span>
<span class="gi">+        # Include InitVars and regular fields (so, not ClassVars).</span>
<span class="gi">+        flds = [f for f in fields.values() if f._field_type in (_FIELD, _FIELD_INITVAR)]</span>
<span class="gi">+        _set_new_attribute(</span>
<span class="gi">+            cls,</span>
<span class="gi">+            &quot;__init__&quot;,</span>
<span class="gi">+            _init_fn(</span>
<span class="gi">+                flds,</span>
<span class="gi">+                frozen,</span>
<span class="gi">+                has_post_init,</span>
<span class="gi">+                # The name to use for the &quot;self&quot;</span>
<span class="gi">+                # param in __init__.  Use &quot;self&quot;</span>
<span class="gi">+                # if possible.</span>
<span class="gi">+                &quot;__dataclass_self__&quot; if &quot;self&quot; in fields else &quot;self&quot;,</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+    # Get the fields as a list, and include only real fields.  This is</span>
<span class="gi">+    # used in all of the following methods.</span>
<span class="gi">+    field_list = [f for f in fields.values() if f._field_type is _FIELD]</span>
<span class="gi">+</span>
<span class="gi">+    if repr:</span>
<span class="gi">+        flds = [f for f in field_list if f.repr]</span>
<span class="gi">+        _set_new_attribute(cls, &quot;__repr__&quot;, _repr_fn(flds))</span>
<span class="gi">+    if eq:</span>
<span class="gi">+        # Create _eq__ method.  There&#39;s no need for a __ne__ method,</span>
<span class="gi">+        # since python will call __eq__ and negate it.</span>
<span class="gi">+        flds = [f for f in field_list if f.compare]</span>
<span class="gi">+        self_tuple = _tuple_str(&quot;self&quot;, flds)</span>
<span class="gi">+        other_tuple = _tuple_str(&quot;other&quot;, flds)</span>
<span class="gi">+        _set_new_attribute(</span>
<span class="gi">+            cls, &quot;__eq__&quot;, _cmp_fn(&quot;__eq__&quot;, &quot;==&quot;, self_tuple, other_tuple)</span>
<span class="gi">+        )</span>
<span class="gi">+    if order:</span>
<span class="gi">+        # Create and set the ordering methods.</span>
<span class="gi">+        flds = [f for f in field_list if f.compare]</span>
<span class="gi">+        self_tuple = _tuple_str(&quot;self&quot;, flds)</span>
<span class="gi">+        other_tuple = _tuple_str(&quot;other&quot;, flds)</span>
<span class="gi">+        for name, op in [</span>
<span class="gi">+            (&quot;__lt__&quot;, &quot;&lt;&quot;),</span>
<span class="gi">+            (&quot;__le__&quot;, &quot;&lt;=&quot;),</span>
<span class="gi">+            (&quot;__gt__&quot;, &quot;&gt;&quot;),</span>
<span class="gi">+            (&quot;__ge__&quot;, &quot;&gt;=&quot;),</span>
<span class="gi">+        ]:</span>
<span class="gi">+            if _set_new_attribute(</span>
<span class="gi">+                cls, name, _cmp_fn(name, op, self_tuple, other_tuple)</span>
<span class="gi">+            ):</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;Cannot overwrite attribute {name} &quot;</span>
<span class="gi">+                    f&quot;in class {cls.__name__}. Consider using &quot;</span>
<span class="gi">+                    &quot;functools.total_ordering&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+    if frozen:</span>
<span class="gi">+        for fn in _frozen_get_del_attr(cls, field_list):</span>
<span class="gi">+            if _set_new_attribute(cls, fn.__name__, fn):</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;Cannot overwrite attribute {fn.__name__} &quot;</span>
<span class="gi">+                    f&quot;in class {cls.__name__}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+    # Decide if/how we&#39;re going to create a hash function.</span>
<span class="gi">+    hash_action = _hash_action[</span>
<span class="gi">+        bool(unsafe_hash), bool(eq), bool(frozen), has_explicit_hash</span>
<span class="gi">+    ]</span>
<span class="gi">+    if hash_action:</span>
<span class="gi">+        # No need to call _set_new_attribute here, since by the time</span>
<span class="gi">+        # we&#39;re here the overwriting is unconditional.</span>
<span class="gi">+        cls.__hash__ = hash_action(cls, field_list)</span>
<span class="gi">+    if not getattr(cls, &quot;__doc__&quot;):</span>
<span class="gi">+        # Create a class doc-string.</span>
<span class="gi">+        cls.__doc__ = cls.__name__ + str(inspect.signature(cls)).replace(&quot; -&gt; None&quot;, &quot;&quot;)</span>
<span class="gi">+    return cls</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# _cls should never be specified by keyword, so start it with an</span>
<span class="gi">+# underscore.  The presence of _cls is used to detect if this</span>
<span class="gi">+# decorator is being called with parameters or not.</span>
<span class="gi">+def dataclass(</span>
<span class="gi">+    _cls=None,</span>
<span class="gi">+    *,</span>
<span class="gi">+    init=True,</span>
<span class="gi">+    repr=True,</span>
<span class="gi">+    eq=True,</span>
<span class="gi">+    order=False,</span>
<span class="gi">+    unsafe_hash=False,</span>
<span class="gi">+    frozen=False,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the same class as was passed in, with dunder methods
<span class="w"> </span>    added based on the fields defined in the class.

<span class="gu">@@ -146,7 +976,16 @@ def dataclass(_cls=None, *, init=True, repr=True, eq=True, order=False,</span>
<span class="w"> </span>    __hash__() method function is added. If frozen is true, fields may
<span class="w"> </span>    not be assigned to after instance creation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def wrap(cls):</span>
<span class="gi">+        return _process_class(cls, init, repr, eq, order, unsafe_hash, frozen)</span>
<span class="gi">+</span>
<span class="gi">+    # See if we&#39;re being called as @dataclass or @dataclass().</span>
<span class="gi">+    if _cls is None:</span>
<span class="gi">+        # We&#39;re called with parens.</span>
<span class="gi">+        return wrap</span>
<span class="gi">+    # We&#39;re called as @dataclass without parens.</span>
<span class="gi">+    return wrap(_cls)</span>


<span class="w"> </span>def fields(class_or_instance):
<span class="gu">@@ -155,18 +994,26 @@ def fields(class_or_instance):</span>
<span class="w"> </span>    Accepts a dataclass or an instance of one. Tuple elements are of
<span class="w"> </span>    type Field.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # Might it be worth caching this, per class?</span>
<span class="gi">+    try:</span>
<span class="gi">+        fields = getattr(class_or_instance, _FIELDS)</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        raise TypeError(&quot;must be called with a dataclass type or instance&quot;)</span>
<span class="gi">+    # Exclude pseudo-fields.  Note that fields is sorted by insertion</span>
<span class="gi">+    # order, so the order of the tuple is as the fields were defined.</span>
<span class="gi">+    return tuple(f for f in fields.values() if f._field_type is _FIELD)</span>


<span class="w"> </span>def _is_dataclass_instance(obj):
<span class="w"> </span>    &quot;&quot;&quot;Returns True if obj is an instance of a dataclass.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return not isinstance(obj, type) and hasattr(obj, _FIELDS)</span>


<span class="w"> </span>def is_dataclass(obj):
<span class="w"> </span>    &quot;&quot;&quot;Returns True if obj is a dataclass or an instance of a
<span class="w"> </span>    dataclass.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return hasattr(obj, _FIELDS)</span>


<span class="w"> </span>def asdict(obj, *, dict_factory=dict):
<span class="gu">@@ -188,7 +1035,27 @@ def asdict(obj, *, dict_factory=dict):</span>
<span class="w"> </span>    dataclass instances. This will also look into built-in containers:
<span class="w"> </span>    tuples, lists, and dicts.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not _is_dataclass_instance(obj):</span>
<span class="gi">+        raise TypeError(&quot;asdict() should be called on dataclass instances&quot;)</span>
<span class="gi">+    return _asdict_inner(obj, dict_factory)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _asdict_inner(obj, dict_factory):</span>
<span class="gi">+    if _is_dataclass_instance(obj):</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for f in fields(obj):</span>
<span class="gi">+            value = _asdict_inner(getattr(obj, f.name), dict_factory)</span>
<span class="gi">+            result.append((f.name, value))</span>
<span class="gi">+        return dict_factory(result)</span>
<span class="gi">+    elif isinstance(obj, (list, tuple)):</span>
<span class="gi">+        return type(obj)(_asdict_inner(v, dict_factory) for v in obj)</span>
<span class="gi">+    elif isinstance(obj, dict):</span>
<span class="gi">+        return type(obj)(</span>
<span class="gi">+            (_asdict_inner(k, dict_factory), _asdict_inner(v, dict_factory))</span>
<span class="gi">+            for k, v in obj.items()</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        return copy.deepcopy(obj)</span>


<span class="w"> </span>def astuple(obj, *, tuple_factory=tuple):
<span class="gu">@@ -209,11 +1076,43 @@ def astuple(obj, *, tuple_factory=tuple):</span>
<span class="w"> </span>    dataclass instances. This will also look into built-in containers:
<span class="w"> </span>    tuples, lists, and dicts.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def make_dataclass(cls_name, fields, *, bases=(), namespace=None, init=True,</span>
<span class="gd">-    repr=True, eq=True, order=False, unsafe_hash=False, frozen=False):</span>
<span class="gi">+    if not _is_dataclass_instance(obj):</span>
<span class="gi">+        raise TypeError(&quot;astuple() should be called on dataclass instances&quot;)</span>
<span class="gi">+    return _astuple_inner(obj, tuple_factory)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _astuple_inner(obj, tuple_factory):</span>
<span class="gi">+    if _is_dataclass_instance(obj):</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for f in fields(obj):</span>
<span class="gi">+            value = _astuple_inner(getattr(obj, f.name), tuple_factory)</span>
<span class="gi">+            result.append(value)</span>
<span class="gi">+        return tuple_factory(result)</span>
<span class="gi">+    elif isinstance(obj, (list, tuple)):</span>
<span class="gi">+        return type(obj)(_astuple_inner(v, tuple_factory) for v in obj)</span>
<span class="gi">+    elif isinstance(obj, dict):</span>
<span class="gi">+        return type(obj)(</span>
<span class="gi">+            (_astuple_inner(k, tuple_factory), _astuple_inner(v, tuple_factory))</span>
<span class="gi">+            for k, v in obj.items()</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        return copy.deepcopy(obj)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_dataclass(</span>
<span class="gi">+    cls_name,</span>
<span class="gi">+    fields,</span>
<span class="gi">+    *,</span>
<span class="gi">+    bases=(),</span>
<span class="gi">+    namespace=None,</span>
<span class="gi">+    init=True,</span>
<span class="gi">+    repr=True,</span>
<span class="gi">+    eq=True,</span>
<span class="gi">+    order=False,</span>
<span class="gi">+    unsafe_hash=False,</span>
<span class="gi">+    frozen=False,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a new dynamically created dataclass.

<span class="w"> </span>    The dataclass name will be &#39;cls_name&#39;.  &#39;fields&#39; is an iterable
<span class="gu">@@ -236,7 +1135,48 @@ def make_dataclass(cls_name, fields, *, bases=(), namespace=None, init=True,</span>
<span class="w"> </span>    The parameters init, repr, eq, order, unsafe_hash, and frozen are passed to
<span class="w"> </span>    dataclass().
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if namespace is None:</span>
<span class="gi">+        namespace = {}</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Copy namespace since we&#39;re going to mutate it.</span>
<span class="gi">+        namespace = namespace.copy()</span>
<span class="gi">+    # While we&#39;re looking through the field names, validate that they</span>
<span class="gi">+    # are identifiers, are not keywords, and not duplicates.</span>
<span class="gi">+    seen = set()</span>
<span class="gi">+    anns = {}</span>
<span class="gi">+    for item in fields:</span>
<span class="gi">+        if isinstance(item, str):</span>
<span class="gi">+            name = item</span>
<span class="gi">+            tp = &quot;typing.Any&quot;</span>
<span class="gi">+        elif len(item) == 2:</span>
<span class="gi">+            (name, tp) = item</span>
<span class="gi">+        elif len(item) == 3:</span>
<span class="gi">+            name, tp, spec = item</span>
<span class="gi">+            namespace[name] = spec</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(f&quot;Invalid field: {item!r}&quot;)</span>
<span class="gi">+        if not isinstance(name, str) or not name.isidentifier():</span>
<span class="gi">+            raise TypeError(f&quot;Field names must be valid identifers: {name!r}&quot;)</span>
<span class="gi">+        if keyword.iskeyword(name):</span>
<span class="gi">+            raise TypeError(f&quot;Field names must not be keywords: {name!r}&quot;)</span>
<span class="gi">+        if name in seen:</span>
<span class="gi">+            raise TypeError(f&quot;Field name duplicated: {name!r}&quot;)</span>
<span class="gi">+        seen.add(name)</span>
<span class="gi">+        anns[name] = tp</span>
<span class="gi">+    namespace[&quot;__annotations__&quot;] = anns</span>
<span class="gi">+    # We use `types.new_class()` instead of simply `type()` to allow dynamic creation</span>
<span class="gi">+    # of generic dataclassses.</span>
<span class="gi">+    cls = types.new_class(cls_name, bases, {}, lambda ns: ns.update(namespace))</span>
<span class="gi">+    return dataclass(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        init=init,</span>
<span class="gi">+        repr=repr,</span>
<span class="gi">+        eq=eq,</span>
<span class="gi">+        order=order,</span>
<span class="gi">+        unsafe_hash=unsafe_hash,</span>
<span class="gi">+        frozen=frozen,</span>
<span class="gi">+    )</span>


<span class="w"> </span>def replace(obj, **changes):
<span class="gu">@@ -253,4 +1193,30 @@ def replace(obj, **changes):</span>
<span class="w"> </span>      c1 = replace(c, x=3)
<span class="w"> </span>      assert c1.x == 3 and c1.y == 2
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # We&#39;re going to mutate &#39;changes&#39;, but that&#39;s okay because it&#39;s a</span>
<span class="gi">+    # new dict, even if called with &#39;replace(obj, **my_changes)&#39;.</span>
<span class="gi">+</span>
<span class="gi">+    if not _is_dataclass_instance(obj):</span>
<span class="gi">+        raise TypeError(&quot;replace() should be called on dataclass instances&quot;)</span>
<span class="gi">+    # It&#39;s an error to have init=False fields in &#39;changes&#39;.</span>
<span class="gi">+    # If a field is not in &#39;changes&#39;, read its value from the provided obj.</span>
<span class="gi">+</span>
<span class="gi">+    for f in getattr(obj, _FIELDS).values():</span>
<span class="gi">+        if not f.init:</span>
<span class="gi">+            # Error if this field is specified in changes.</span>
<span class="gi">+            if f.name in changes:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    f&quot;field {f.name} is declared with &quot;</span>
<span class="gi">+                    &quot;init=False, it cannot be specified with &quot;</span>
<span class="gi">+                    &quot;replace()&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            continue</span>
<span class="gi">+        if f.name not in changes:</span>
<span class="gi">+            changes[f.name] = getattr(obj, f.name)</span>
<span class="gi">+    # Create the new object, which calls __init__() and</span>
<span class="gi">+    # __post_init__() (if defined), using all of the init fields we&#39;ve</span>
<span class="gi">+    # added and/or left in &#39;changes&#39;.  If there are values supplied in</span>
<span class="gi">+    # changes that aren&#39;t fields, this will correctly raise a</span>
<span class="gi">+    # TypeError.</span>
<span class="gi">+    return obj.__class__(**changes)</span>
<span class="gh">diff --git a/graphene/pyutils/version.py b/graphene/pyutils/version.py</span>
<span class="gh">index 7f16d40..8a3be07 100644</span>
<span class="gd">--- a/graphene/pyutils/version.py</span>
<span class="gi">+++ b/graphene/pyutils/version.py</span>
<span class="gu">@@ -1,24 +1,58 @@</span>
<span class="w"> </span>from __future__ import unicode_literals
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>import os
<span class="w"> </span>import subprocess


<span class="w"> </span>def get_version(version=None):
<span class="gd">-    &quot;&quot;&quot;Returns a PEP 440-compliant version number from VERSION.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;Returns a PEP 440-compliant version number from VERSION.&quot;</span>
<span class="gi">+    version = get_complete_version(version)</span>
<span class="gi">+</span>
<span class="gi">+    # Now build the two parts of the version number:</span>
<span class="gi">+    # main = X.Y[.Z]</span>
<span class="gi">+    # sub = .devN - for pre-alpha releases</span>
<span class="gi">+    #     | {a|b|rc}N - for alpha, beta, and rc releases</span>
<span class="gi">+</span>
<span class="gi">+    main = get_main_version(version)</span>
<span class="gi">+</span>
<span class="gi">+    sub = &quot;&quot;</span>
<span class="gi">+    if version[3] == &quot;alpha&quot; and version[4] == 0:</span>
<span class="gi">+        git_changeset = get_git_changeset()</span>
<span class="gi">+        sub = &quot;.dev%s&quot; % git_changeset if git_changeset else &quot;.dev&quot;</span>
<span class="gi">+    elif version[3] != &quot;final&quot;:</span>
<span class="gi">+        mapping = {&quot;alpha&quot;: &quot;a&quot;, &quot;beta&quot;: &quot;b&quot;, &quot;rc&quot;: &quot;rc&quot;}</span>
<span class="gi">+        sub = mapping[version[3]] + str(version[4])</span>
<span class="gi">+</span>
<span class="gi">+    return str(main + sub)</span>


<span class="w"> </span>def get_main_version(version=None):
<span class="gd">-    &quot;&quot;&quot;Returns main version (X.Y[.Z]) from VERSION.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;Returns main version (X.Y[.Z]) from VERSION.&quot;</span>
<span class="gi">+    version = get_complete_version(version)</span>
<span class="gi">+    parts = 2 if version[2] == 0 else 3</span>
<span class="gi">+    return &quot;.&quot;.join(str(x) for x in version[:parts])</span>


<span class="w"> </span>def get_complete_version(version=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a tuple of the graphene version. If version argument is non-empty,
<span class="w"> </span>    then checks for correctness of the tuple provided.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if version is None:</span>
<span class="gi">+        from graphene import VERSION as version</span>
<span class="gi">+    else:</span>
<span class="gi">+        assert len(version) == 5</span>
<span class="gi">+        assert version[3] in (&quot;alpha&quot;, &quot;beta&quot;, &quot;rc&quot;, &quot;final&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return version</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_docs_version(version=None):</span>
<span class="gi">+    version = get_complete_version(version)</span>
<span class="gi">+    if version[3] != &quot;final&quot;:</span>
<span class="gi">+        return &quot;dev&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return &quot;%d.%d&quot; % version[:2]</span>


<span class="w"> </span>def get_git_changeset():
<span class="gu">@@ -27,4 +61,18 @@ def get_git_changeset():</span>
<span class="w"> </span>    This value isn&#39;t guaranteed to be unique, but collisions are very unlikely,
<span class="w"> </span>    so it&#39;s sufficient for generating the development version numbers.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    repo_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span>
<span class="gi">+    try:</span>
<span class="gi">+        git_log = subprocess.Popen(</span>
<span class="gi">+            &quot;git log --pretty=format:%ct --quiet -1 HEAD&quot;,</span>
<span class="gi">+            stdout=subprocess.PIPE,</span>
<span class="gi">+            stderr=subprocess.PIPE,</span>
<span class="gi">+            shell=True,</span>
<span class="gi">+            cwd=repo_dir,</span>
<span class="gi">+            universal_newlines=True,</span>
<span class="gi">+        )</span>
<span class="gi">+        timestamp = git_log.communicate()[0]</span>
<span class="gi">+        timestamp = datetime.datetime.utcfromtimestamp(int(timestamp))</span>
<span class="gi">+    except:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return timestamp.strftime(&quot;%Y%m%d%H%M%S&quot;)</span>
<span class="gh">diff --git a/graphene/relay/connection.py b/graphene/relay/connection.py</span>
<span class="gh">index b1ab0bf..cc7d2da 100644</span>
<span class="gd">--- a/graphene/relay/connection.py</span>
<span class="gi">+++ b/graphene/relay/connection.py</span>
<span class="gu">@@ -2,7 +2,9 @@ import re</span>
<span class="w"> </span>from collections.abc import Iterable
<span class="w"> </span>from functools import partial
<span class="w"> </span>from typing import Type
<span class="gi">+</span>
<span class="w"> </span>from graphql_relay import connection_from_array
<span class="gi">+</span>
<span class="w"> </span>from ..types import Boolean, Enum, Int, Interface, List, NonNull, Scalar, String, Union
<span class="w"> </span>from ..types.field import Field
<span class="w"> </span>from ..types.objecttype import ObjectType, ObjectTypeOptions
<span class="gu">@@ -10,26 +12,72 @@ from ..utils.thenables import maybe_thenable</span>
<span class="w"> </span>from .node import is_node, AbstractNode


<span class="gd">-class PageInfo(ObjectType):</span>
<span class="gi">+def get_edge_class(</span>
<span class="gi">+    connection_class: Type[&quot;Connection&quot;],</span>
<span class="gi">+    _node: Type[AbstractNode],</span>
<span class="gi">+    base_name: str,</span>
<span class="gi">+    strict_types: bool = False,</span>
<span class="gi">+):</span>
<span class="gi">+    edge_class = getattr(connection_class, &quot;Edge&quot;, None)</span>

<span class="gi">+    class EdgeBase:</span>
<span class="gi">+        node = Field(</span>
<span class="gi">+            NonNull(_node) if strict_types else _node,</span>
<span class="gi">+            description=&quot;The item at the end of the edge&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        cursor = String(required=True, description=&quot;A cursor for use in pagination&quot;)</span>

<span class="gd">-    class Meta:</span>
<span class="gd">-        description = (</span>
<span class="gd">-            &#39;The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.&#39;</span>
<span class="gd">-            )</span>
<span class="gd">-    has_next_page = Boolean(required=True, name=&#39;hasNextPage&#39;, description=</span>
<span class="gd">-        &#39;When paginating forwards, are there more items?&#39;)</span>
<span class="gd">-    has_previous_page = Boolean(required=True, name=&#39;hasPreviousPage&#39;,</span>
<span class="gd">-        description=&#39;When paginating backwards, are there more items?&#39;)</span>
<span class="gd">-    start_cursor = String(name=&#39;startCursor&#39;, description=</span>
<span class="gd">-        &#39;When paginating backwards, the cursor to continue.&#39;)</span>
<span class="gd">-    end_cursor = String(name=&#39;endCursor&#39;, description=</span>
<span class="gd">-        &#39;When paginating forwards, the cursor to continue.&#39;)</span>
<span class="gi">+    class EdgeMeta:</span>
<span class="gi">+        description = f&quot;A Relay edge containing a `{base_name}` and its cursor.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    edge_name = f&quot;{base_name}Edge&quot;</span>
<span class="gi">+</span>
<span class="gi">+    edge_bases = [edge_class, EdgeBase] if edge_class else [EdgeBase]</span>
<span class="gi">+    if not isinstance(edge_class, ObjectType):</span>
<span class="gi">+        edge_bases = [*edge_bases, ObjectType]</span>
<span class="gi">+</span>
<span class="gi">+    return type(edge_name, tuple(edge_bases), {&quot;Meta&quot;: EdgeMeta})</span>


<span class="gi">+class PageInfo(ObjectType):</span>
<span class="gi">+    class Meta:</span>
<span class="gi">+        description = (</span>
<span class="gi">+            &quot;The Relay compliant `PageInfo` type, containing data necessary to&quot;</span>
<span class="gi">+            &quot; paginate this connection.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    has_next_page = Boolean(</span>
<span class="gi">+        required=True,</span>
<span class="gi">+        name=&quot;hasNextPage&quot;,</span>
<span class="gi">+        description=&quot;When paginating forwards, are there more items?&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    has_previous_page = Boolean(</span>
<span class="gi">+        required=True,</span>
<span class="gi">+        name=&quot;hasPreviousPage&quot;,</span>
<span class="gi">+        description=&quot;When paginating backwards, are there more items?&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    start_cursor = String(</span>
<span class="gi">+        name=&quot;startCursor&quot;,</span>
<span class="gi">+        description=&quot;When paginating backwards, the cursor to continue.&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    end_cursor = String(</span>
<span class="gi">+        name=&quot;endCursor&quot;,</span>
<span class="gi">+        description=&quot;When paginating forwards, the cursor to continue.&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# noinspection PyPep8Naming</span>
<span class="w"> </span>def page_info_adapter(startCursor, endCursor, hasPreviousPage, hasNextPage):
<span class="w"> </span>    &quot;&quot;&quot;Adapter for creating PageInfo instances&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return PageInfo(</span>
<span class="gi">+        start_cursor=startCursor,</span>
<span class="gi">+        end_cursor=endCursor,</span>
<span class="gi">+        has_previous_page=hasPreviousPage,</span>
<span class="gi">+        has_next_page=hasNextPage,</span>
<span class="gi">+    )</span>


<span class="w"> </span>class ConnectionOptions(ObjectTypeOptions):
<span class="gu">@@ -37,55 +85,116 @@ class ConnectionOptions(ObjectTypeOptions):</span>


<span class="w"> </span>class Connection(ObjectType):
<span class="gd">-</span>
<span class="gd">-</span>
<span class="w"> </span>    class Meta:
<span class="w"> </span>        abstract = True

<span class="w"> </span>    @classmethod
<span class="gd">-    def __init_subclass_with_meta__(cls, node=None, name=None, strict_types</span>
<span class="gd">-        =False, _meta=None, **options):</span>
<span class="gi">+    def __init_subclass_with_meta__(</span>
<span class="gi">+        cls, node=None, name=None, strict_types=False, _meta=None, **options</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        if not _meta:
<span class="w"> </span>            _meta = ConnectionOptions(cls)
<span class="gd">-        assert node, f&#39;You have to provide a node in {cls.__name__}.Meta&#39;</span>
<span class="gd">-        assert isinstance(node, NonNull) or issubclass(node, (Scalar, Enum,</span>
<span class="gd">-            ObjectType, Interface, Union, NonNull)</span>
<span class="gd">-            ), f&#39;Received incompatible node &quot;{node}&quot; for Connection {cls.__name__}.&#39;</span>
<span class="gd">-        base_name = re.sub(&#39;Connection$&#39;, &#39;&#39;, name or cls.__name__</span>
<span class="gd">-            ) or node._meta.name</span>
<span class="gi">+        assert node, f&quot;You have to provide a node in {cls.__name__}.Meta&quot;</span>
<span class="gi">+        assert isinstance(node, NonNull) or issubclass(</span>
<span class="gi">+            node, (Scalar, Enum, ObjectType, Interface, Union, NonNull)</span>
<span class="gi">+        ), f&#39;Received incompatible node &quot;{node}&quot; for Connection {cls.__name__}.&#39;</span>
<span class="gi">+</span>
<span class="gi">+        base_name = re.sub(&quot;Connection$&quot;, &quot;&quot;, name or cls.__name__) or node._meta.name</span>
<span class="w"> </span>        if not name:
<span class="gd">-            name = f&#39;{base_name}Connection&#39;</span>
<span class="gd">-        options[&#39;name&#39;] = name</span>
<span class="gi">+            name = f&quot;{base_name}Connection&quot;</span>
<span class="gi">+</span>
<span class="gi">+        options[&quot;name&quot;] = name</span>
<span class="gi">+</span>
<span class="w"> </span>        _meta.node = node
<span class="gi">+</span>
<span class="w"> </span>        if not _meta.fields:
<span class="w"> </span>            _meta.fields = {}
<span class="gd">-        if &#39;page_info&#39; not in _meta.fields:</span>
<span class="gd">-            _meta.fields[&#39;page_info&#39;] = Field(PageInfo, name=&#39;pageInfo&#39;,</span>
<span class="gd">-                required=True, description=</span>
<span class="gd">-                &#39;Pagination data for this connection.&#39;)</span>
<span class="gd">-        if &#39;edges&#39; not in _meta.fields:</span>
<span class="gd">-            edge_class = get_edge_class(cls, node, base_name, strict_types)</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;page_info&quot; not in _meta.fields:</span>
<span class="gi">+            _meta.fields[&quot;page_info&quot;] = Field(</span>
<span class="gi">+                PageInfo,</span>
<span class="gi">+                name=&quot;pageInfo&quot;,</span>
<span class="gi">+                required=True,</span>
<span class="gi">+                description=&quot;Pagination data for this connection.&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;edges&quot; not in _meta.fields:</span>
<span class="gi">+            edge_class = get_edge_class(cls, node, base_name, strict_types)  # type: ignore</span>
<span class="w"> </span>            cls.Edge = edge_class
<span class="gd">-            _meta.fields[&#39;edges&#39;] = Field(NonNull(List(NonNull(edge_class) if</span>
<span class="gd">-                strict_types else edge_class)), description=</span>
<span class="gd">-                &#39;Contains the nodes in this connection.&#39;)</span>
<span class="gd">-        return super(Connection, cls).__init_subclass_with_meta__(_meta=</span>
<span class="gd">-            _meta, **options)</span>
<span class="gi">+            _meta.fields[&quot;edges&quot;] = Field(</span>
<span class="gi">+                NonNull(List(NonNull(edge_class) if strict_types else edge_class)),</span>
<span class="gi">+                description=&quot;Contains the nodes in this connection.&quot;,</span>
<span class="gi">+            )</span>

<span class="gi">+        return super(Connection, cls).__init_subclass_with_meta__(</span>
<span class="gi">+            _meta=_meta, **options</span>
<span class="gi">+        )</span>

<span class="gi">+</span>
<span class="gi">+# noinspection PyPep8Naming</span>
<span class="w"> </span>def connection_adapter(cls, edges, pageInfo):
<span class="w"> </span>    &quot;&quot;&quot;Adapter for creating Connection instances&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return cls(edges=edges, page_info=pageInfo)</span>


<span class="w"> </span>class IterableConnectionField(Field):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, type_, *args, **kwargs):
<span class="gd">-        kwargs.setdefault(&#39;before&#39;, String())</span>
<span class="gd">-        kwargs.setdefault(&#39;after&#39;, String())</span>
<span class="gd">-        kwargs.setdefault(&#39;first&#39;, Int())</span>
<span class="gd">-        kwargs.setdefault(&#39;last&#39;, Int())</span>
<span class="gi">+        kwargs.setdefault(&quot;before&quot;, String())</span>
<span class="gi">+        kwargs.setdefault(&quot;after&quot;, String())</span>
<span class="gi">+        kwargs.setdefault(&quot;first&quot;, Int())</span>
<span class="gi">+        kwargs.setdefault(&quot;last&quot;, Int())</span>
<span class="w"> </span>        super(IterableConnectionField, self).__init__(type_, *args, **kwargs)

<span class="gi">+    @property</span>
<span class="gi">+    def type(self):</span>
<span class="gi">+        type_ = super(IterableConnectionField, self).type</span>
<span class="gi">+        connection_type = type_</span>
<span class="gi">+        if isinstance(type_, NonNull):</span>
<span class="gi">+            connection_type = type_.of_type</span>
<span class="gi">+</span>
<span class="gi">+        if is_node(connection_type):</span>
<span class="gi">+            raise Exception(</span>
<span class="gi">+                &quot;ConnectionFields now need a explicit ConnectionType for Nodes.\n&quot;</span>
<span class="gi">+                &quot;Read more: https://github.com/graphql-python/graphene/blob/v2.0.0/UPGRADE-v2.0.md#node-connections&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        assert issubclass(</span>
<span class="gi">+            connection_type, Connection</span>
<span class="gi">+        ), f&#39;{self.__class__.__name__} type has to be a subclass of Connection. Received &quot;{connection_type}&quot;.&#39;</span>
<span class="gi">+        return type_</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def resolve_connection(cls, connection_type, args, resolved):</span>
<span class="gi">+        if isinstance(resolved, connection_type):</span>
<span class="gi">+            return resolved</span>
<span class="gi">+</span>
<span class="gi">+        assert isinstance(resolved, Iterable), (</span>
<span class="gi">+            f&quot;Resolved value from the connection field has to be an iterable or instance of {connection_type}. &quot;</span>
<span class="gi">+            f&#39;Received &quot;{resolved}&quot;&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+        connection = connection_from_array(</span>
<span class="gi">+            resolved,</span>
<span class="gi">+            args,</span>
<span class="gi">+            connection_type=partial(connection_adapter, connection_type),</span>
<span class="gi">+            edge_type=connection_type.Edge,</span>
<span class="gi">+            page_info_type=page_info_adapter,</span>
<span class="gi">+        )</span>
<span class="gi">+        connection.iterable = resolved</span>
<span class="gi">+        return connection</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def connection_resolver(cls, resolver, connection_type, root, info, **args):</span>
<span class="gi">+        resolved = resolver(root, info, **args)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(connection_type, NonNull):</span>
<span class="gi">+            connection_type = connection_type.of_type</span>
<span class="gi">+</span>
<span class="gi">+        on_resolve = partial(cls.resolve_connection, connection_type, args)</span>
<span class="gi">+        return maybe_thenable(resolved, on_resolve)</span>
<span class="gi">+</span>
<span class="gi">+    def wrap_resolve(self, parent_resolver):</span>
<span class="gi">+        resolver = super(IterableConnectionField, self).wrap_resolve(parent_resolver)</span>
<span class="gi">+        return partial(self.connection_resolver, resolver, self.type)</span>
<span class="gi">+</span>

<span class="w"> </span>ConnectionField = IterableConnectionField
<span class="gh">diff --git a/graphene/relay/id_type.py b/graphene/relay/id_type.py</span>
<span class="gh">index 6278c7e..fb5c30e 100644</span>
<span class="gd">--- a/graphene/relay/id_type.py</span>
<span class="gi">+++ b/graphene/relay/id_type.py</span>
<span class="gu">@@ -1,6 +1,8 @@</span>
<span class="w"> </span>from graphql_relay import from_global_id, to_global_id
<span class="gi">+</span>
<span class="w"> </span>from ..types import ID, UUID
<span class="w"> </span>from ..types.base import BaseType
<span class="gi">+</span>
<span class="w"> </span>from typing import Type


<span class="gu">@@ -8,15 +10,45 @@ class BaseGlobalIDType:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Base class that define the required attributes/method for a type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    graphene_type = ID</span>
<span class="gi">+</span>
<span class="gi">+    graphene_type = ID  # type: Type[BaseType]</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def resolve_global_id(cls, info, global_id):</span>
<span class="gi">+        # return _type, _id</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def to_global_id(cls, _type, _id):</span>
<span class="gi">+        # return _id</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>class DefaultGlobalIDType(BaseGlobalIDType):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Default global ID type: base64 encoded version of &quot;&lt;node type name&gt;: &lt;node id&gt;&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    graphene_type = ID

<span class="gi">+    @classmethod</span>
<span class="gi">+    def resolve_global_id(cls, info, global_id):</span>
<span class="gi">+        try:</span>
<span class="gi">+            _type, _id = from_global_id(global_id)</span>
<span class="gi">+            if not _type:</span>
<span class="gi">+                raise ValueError(&quot;Invalid Global ID&quot;)</span>
<span class="gi">+            return _type, _id</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise Exception(</span>
<span class="gi">+                f&#39;Unable to parse global ID &quot;{global_id}&quot;. &#39;</span>
<span class="gi">+                &#39;Make sure it is a base64 encoded string in the format: &quot;TypeName:id&quot;. &#39;</span>
<span class="gi">+                f&quot;Exception message: {e}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def to_global_id(cls, _type, _id):</span>
<span class="gi">+        return to_global_id(_type, _id)</span>
<span class="gi">+</span>

<span class="w"> </span>class SimpleGlobalIDType(BaseGlobalIDType):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -24,12 +56,32 @@ class SimpleGlobalIDType(BaseGlobalIDType):</span>
<span class="w"> </span>    To be used carefully as the user is responsible for ensuring that the IDs are indeed global
<span class="w"> </span>    (otherwise it could cause request caching issues).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    graphene_type = ID

<span class="gi">+    @classmethod</span>
<span class="gi">+    def resolve_global_id(cls, info, global_id):</span>
<span class="gi">+        _type = info.return_type.graphene_type._meta.name</span>
<span class="gi">+        return _type, global_id</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def to_global_id(cls, _type, _id):</span>
<span class="gi">+        return _id</span>
<span class="gi">+</span>

<span class="w"> </span>class UUIDGlobalIDType(BaseGlobalIDType):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    UUID global ID type.
<span class="w"> </span>    By definition UUID are global so they are used as they are.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    graphene_type = UUID
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def resolve_global_id(cls, info, global_id):</span>
<span class="gi">+        _type = info.return_type.graphene_type._meta.name</span>
<span class="gi">+        return _type, global_id</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def to_global_id(cls, _type, _id):</span>
<span class="gi">+        return _id</span>
<span class="gh">diff --git a/graphene/relay/mutation.py b/graphene/relay/mutation.py</span>
<span class="gh">index 1ea7347..2f4a4b7 100644</span>
<span class="gd">--- a/graphene/relay/mutation.py</span>
<span class="gi">+++ b/graphene/relay/mutation.py</span>
<span class="gu">@@ -1,37 +1,66 @@</span>
<span class="w"> </span>import re
<span class="gi">+</span>
<span class="w"> </span>from ..types import Field, InputObjectType, String
<span class="w"> </span>from ..types.mutation import Mutation
<span class="w"> </span>from ..utils.thenables import maybe_thenable


<span class="w"> </span>class ClientIDMutation(Mutation):
<span class="gd">-</span>
<span class="gd">-</span>
<span class="w"> </span>    class Meta:
<span class="w"> </span>        abstract = True

<span class="w"> </span>    @classmethod
<span class="gd">-    def __init_subclass_with_meta__(cls, output=None, input_fields=None,</span>
<span class="gd">-        arguments=None, name=None, **options):</span>
<span class="gd">-        input_class = getattr(cls, &#39;Input&#39;, None)</span>
<span class="gd">-        base_name = re.sub(&#39;Payload$&#39;, &#39;&#39;, name or cls.__name__)</span>
<span class="gi">+    def __init_subclass_with_meta__(</span>
<span class="gi">+        cls, output=None, input_fields=None, arguments=None, name=None, **options</span>
<span class="gi">+    ):</span>
<span class="gi">+        input_class = getattr(cls, &quot;Input&quot;, None)</span>
<span class="gi">+        base_name = re.sub(&quot;Payload$&quot;, &quot;&quot;, name or cls.__name__)</span>
<span class="gi">+</span>
<span class="w"> </span>        assert not output, &quot;Can&#39;t specify any output&quot;
<span class="w"> </span>        assert not arguments, &quot;Can&#39;t specify any arguments&quot;
<span class="gd">-        bases = InputObjectType,</span>
<span class="gi">+</span>
<span class="gi">+        bases = (InputObjectType,)</span>
<span class="w"> </span>        if input_class:
<span class="gd">-            bases += input_class,</span>
<span class="gi">+            bases += (input_class,)</span>
<span class="gi">+</span>
<span class="w"> </span>        if not input_fields:
<span class="w"> </span>            input_fields = {}
<span class="gd">-        cls.Input = type(f&#39;{base_name}Input&#39;, bases, dict(input_fields,</span>
<span class="gd">-            client_mutation_id=String(name=&#39;clientMutationId&#39;)))</span>
<span class="gd">-        arguments = dict(input=cls.Input(required=True))</span>
<span class="gd">-        mutate_and_get_payload = getattr(cls, &#39;mutate_and_get_payload&#39;, None)</span>
<span class="gd">-        if (cls.mutate and cls.mutate.__func__ == ClientIDMutation.mutate.</span>
<span class="gd">-            __func__):</span>
<span class="gd">-            assert mutate_and_get_payload, f&#39;{name or cls.__name__}.mutate_and_get_payload method is required in a ClientIDMutation.&#39;</span>
<span class="gi">+</span>
<span class="gi">+        cls.Input = type(</span>
<span class="gi">+            f&quot;{base_name}Input&quot;,</span>
<span class="gi">+            bases,</span>
<span class="gi">+            dict(input_fields, client_mutation_id=String(name=&quot;clientMutationId&quot;)),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        arguments = dict(</span>
<span class="gi">+            input=cls.Input(required=True)</span>
<span class="gi">+            # &#39;client_mutation_id&#39;: String(name=&#39;clientMutationId&#39;)</span>
<span class="gi">+        )</span>
<span class="gi">+        mutate_and_get_payload = getattr(cls, &quot;mutate_and_get_payload&quot;, None)</span>
<span class="gi">+        if cls.mutate and cls.mutate.__func__ == ClientIDMutation.mutate.__func__:</span>
<span class="gi">+            assert mutate_and_get_payload, (</span>
<span class="gi">+                f&quot;{name or cls.__name__}.mutate_and_get_payload method is required&quot;</span>
<span class="gi">+                &quot; in a ClientIDMutation.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        if not name:
<span class="gd">-            name = f&#39;{base_name}Payload&#39;</span>
<span class="gd">-        super(ClientIDMutation, cls).__init_subclass_with_meta__(output=</span>
<span class="gd">-            None, arguments=arguments, name=name, **options)</span>
<span class="gd">-        cls._meta.fields[&#39;client_mutation_id&#39;] = Field(String, name=</span>
<span class="gd">-            &#39;clientMutationId&#39;)</span>
<span class="gi">+            name = f&quot;{base_name}Payload&quot;</span>
<span class="gi">+</span>
<span class="gi">+        super(ClientIDMutation, cls).__init_subclass_with_meta__(</span>
<span class="gi">+            output=None, arguments=arguments, name=name, **options</span>
<span class="gi">+        )</span>
<span class="gi">+        cls._meta.fields[&quot;client_mutation_id&quot;] = Field(String, name=&quot;clientMutationId&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def mutate(cls, root, info, input):</span>
<span class="gi">+        def on_resolve(payload):</span>
<span class="gi">+            try:</span>
<span class="gi">+                payload.client_mutation_id = input.get(&quot;client_mutation_id&quot;)</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                raise Exception(</span>
<span class="gi">+                    f&quot;Cannot set client_mutation_id in the payload object {repr(payload)}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            return payload</span>
<span class="gi">+</span>
<span class="gi">+        result = cls.mutate_and_get_payload(root, info, **input)</span>
<span class="gi">+        return maybe_thenable(result, on_resolve)</span>
<span class="gh">diff --git a/graphene/relay/node.py b/graphene/relay/node.py</span>
<span class="gh">index 138a893..5443828 100644</span>
<span class="gd">--- a/graphene/relay/node.py</span>
<span class="gi">+++ b/graphene/relay/node.py</span>
<span class="gu">@@ -1,5 +1,6 @@</span>
<span class="w"> </span>from functools import partial
<span class="w"> </span>from inspect import isclass
<span class="gi">+</span>
<span class="w"> </span>from ..types import Field, Interface, ObjectType
<span class="w"> </span>from ..types.interface import InterfaceOptions
<span class="w"> </span>from ..types.utils import get_type
<span class="gu">@@ -10,49 +11,125 @@ def is_node(objecttype):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check if the given objecttype has Node as an interface
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isclass(objecttype):</span>
<span class="gi">+        return False</span>

<span class="gi">+    if not issubclass(objecttype, ObjectType):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return any(issubclass(i, Node) for i in objecttype._meta.interfaces)</span>

<span class="gd">-class GlobalID(Field):</span>

<span class="gd">-    def __init__(self, node=None, parent_type=None, required=True,</span>
<span class="gd">-        global_id_type=DefaultGlobalIDType, *args, **kwargs):</span>
<span class="gd">-        super(GlobalID, self).__init__(global_id_type.graphene_type, *args,</span>
<span class="gd">-            required=required, **kwargs)</span>
<span class="gi">+class GlobalID(Field):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node=None,</span>
<span class="gi">+        parent_type=None,</span>
<span class="gi">+        required=True,</span>
<span class="gi">+        global_id_type=DefaultGlobalIDType,</span>
<span class="gi">+        *args,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="gi">+        super(GlobalID, self).__init__(</span>
<span class="gi">+            global_id_type.graphene_type, required=required, *args, **kwargs</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.node = node or Node
<span class="w"> </span>        self.parent_type_name = parent_type._meta.name if parent_type else None

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def id_resolver(parent_resolver, node, root, info, parent_type_name=None, **args):</span>
<span class="gi">+        type_id = parent_resolver(root, info, **args)</span>
<span class="gi">+        parent_type_name = parent_type_name or info.parent_type.name</span>
<span class="gi">+        return node.to_global_id(parent_type_name, type_id)  # root._meta.name</span>
<span class="gi">+</span>
<span class="gi">+    def wrap_resolve(self, parent_resolver):</span>
<span class="gi">+        return partial(</span>
<span class="gi">+            self.id_resolver,</span>
<span class="gi">+            parent_resolver,</span>
<span class="gi">+            self.node,</span>
<span class="gi">+            parent_type_name=self.parent_type_name,</span>
<span class="gi">+        )</span>

<span class="gd">-class NodeField(Field):</span>

<span class="gi">+class NodeField(Field):</span>
<span class="w"> </span>    def __init__(self, node, type_=False, **kwargs):
<span class="gd">-        assert issubclass(node, Node), &#39;NodeField can only operate in Nodes&#39;</span>
<span class="gi">+        assert issubclass(node, Node), &quot;NodeField can only operate in Nodes&quot;</span>
<span class="w"> </span>        self.node_type = node
<span class="w"> </span>        self.field_type = type_
<span class="w"> </span>        global_id_type = node._meta.global_id_type
<span class="gd">-        super(NodeField, self).__init__(type_ or node, id=global_id_type.</span>
<span class="gd">-            graphene_type(required=True, description=&#39;The ID of the object&#39;</span>
<span class="gd">-            ), **kwargs)</span>

<span class="gi">+        super(NodeField, self).__init__(</span>
<span class="gi">+            # If we don&#39;t specify a type, the field type will be the node interface</span>
<span class="gi">+            type_ or node,</span>
<span class="gi">+            id=global_id_type.graphene_type(</span>
<span class="gi">+                required=True, description=&quot;The ID of the object&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        )</span>

<span class="gd">-class AbstractNode(Interface):</span>
<span class="gi">+    def wrap_resolve(self, parent_resolver):</span>
<span class="gi">+        return partial(self.node_type.node_resolver, get_type(self.field_type))</span>


<span class="gi">+class AbstractNode(Interface):</span>
<span class="w"> </span>    class Meta:
<span class="w"> </span>        abstract = True

<span class="w"> </span>    @classmethod
<span class="gd">-    def __init_subclass_with_meta__(cls, global_id_type=DefaultGlobalIDType,</span>
<span class="gd">-        **options):</span>
<span class="gd">-        assert issubclass(global_id_type, BaseGlobalIDType</span>
<span class="gd">-            ), &#39;Custom ID type need to be implemented as a subclass of BaseGlobalIDType.&#39;</span>
<span class="gi">+    def __init_subclass_with_meta__(cls, global_id_type=DefaultGlobalIDType, **options):</span>
<span class="gi">+        assert issubclass(</span>
<span class="gi">+            global_id_type, BaseGlobalIDType</span>
<span class="gi">+        ), &quot;Custom ID type need to be implemented as a subclass of BaseGlobalIDType.&quot;</span>
<span class="w"> </span>        _meta = InterfaceOptions(cls)
<span class="w"> </span>        _meta.global_id_type = global_id_type
<span class="gd">-        _meta.fields = {&#39;id&#39;: GlobalID(cls, global_id_type=global_id_type,</span>
<span class="gd">-            description=&#39;The ID of the object&#39;)}</span>
<span class="gd">-        super(AbstractNode, cls).__init_subclass_with_meta__(_meta=_meta,</span>
<span class="gd">-            **options)</span>
<span class="gi">+        _meta.fields = {</span>
<span class="gi">+            &quot;id&quot;: GlobalID(</span>
<span class="gi">+                cls, global_id_type=global_id_type, description=&quot;The ID of the object&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        }</span>
<span class="gi">+        super(AbstractNode, cls).__init_subclass_with_meta__(_meta=_meta, **options)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def resolve_global_id(cls, info, global_id):</span>
<span class="gi">+        return cls._meta.global_id_type.resolve_global_id(info, global_id)</span>


<span class="w"> </span>class Node(AbstractNode):
<span class="w"> </span>    &quot;&quot;&quot;An object with an ID&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def Field(cls, *args, **kwargs):  # noqa: N802</span>
<span class="gi">+        return NodeField(cls, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def node_resolver(cls, only_type, root, info, id):</span>
<span class="gi">+        return cls.get_node_from_global_id(info, id, only_type=only_type)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def get_node_from_global_id(cls, info, global_id, only_type=None):</span>
<span class="gi">+        _type, _id = cls.resolve_global_id(info, global_id)</span>
<span class="gi">+</span>
<span class="gi">+        graphene_type = info.schema.get_type(_type)</span>
<span class="gi">+        if graphene_type is None:</span>
<span class="gi">+            raise Exception(f&#39;Relay Node &quot;{_type}&quot; not found in schema&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        graphene_type = graphene_type.graphene_type</span>
<span class="gi">+</span>
<span class="gi">+        if only_type:</span>
<span class="gi">+            assert (</span>
<span class="gi">+                graphene_type == only_type</span>
<span class="gi">+            ), f&quot;Must receive a {only_type._meta.name} id.&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # We make sure the ObjectType implements the &quot;Node&quot; interface</span>
<span class="gi">+        if cls not in graphene_type._meta.interfaces:</span>
<span class="gi">+            raise Exception(</span>
<span class="gi">+                f&#39;ObjectType &quot;{_type}&quot; does not implement the &quot;{cls}&quot; interface.&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        get_node = getattr(graphene_type, &quot;get_node&quot;, None)</span>
<span class="gi">+        if get_node:</span>
<span class="gi">+            return get_node(info, _id)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def to_global_id(cls, type_, id):</span>
<span class="gi">+        return cls._meta.global_id_type.to_global_id(type_, id)</span>
<span class="gh">diff --git a/graphene/types/argument.py b/graphene/types/argument.py</span>
<span class="gh">index 4e25b9c..d9283c4 100644</span>
<span class="gd">--- a/graphene/types/argument.py</span>
<span class="gi">+++ b/graphene/types/argument.py</span>
<span class="gu">@@ -1,5 +1,6 @@</span>
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from graphql import Undefined
<span class="gi">+</span>
<span class="w"> </span>from .dynamic import Dynamic
<span class="w"> </span>from .mountedtype import MountedType
<span class="w"> </span>from .structures import NonNull
<span class="gu">@@ -41,21 +42,79 @@ class Argument(MountedType):</span>
<span class="w"> </span>            set if the argument is required (see spec).
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, type_, default_value=Undefined, deprecation_reason=</span>
<span class="gd">-        None, description=None, name=None, required=False,</span>
<span class="gd">-        _creation_counter=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        type_,</span>
<span class="gi">+        default_value=Undefined,</span>
<span class="gi">+        deprecation_reason=None,</span>
<span class="gi">+        description=None,</span>
<span class="gi">+        name=None,</span>
<span class="gi">+        required=False,</span>
<span class="gi">+        _creation_counter=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super(Argument, self).__init__(_creation_counter=_creation_counter)
<span class="gi">+</span>
<span class="w"> </span>        if required:
<span class="gd">-            assert deprecation_reason is None, f&#39;Argument {name} is required, cannot deprecate it.&#39;</span>
<span class="gi">+            assert (</span>
<span class="gi">+                deprecation_reason is None</span>
<span class="gi">+            ), f&quot;Argument {name} is required, cannot deprecate it.&quot;</span>
<span class="w"> </span>            type_ = NonNull(type_)
<span class="gi">+</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self._type = type_
<span class="w"> </span>        self.default_value = default_value
<span class="w"> </span>        self.description = description
<span class="w"> </span>        self.deprecation_reason = deprecation_reason

<span class="gi">+    @property</span>
<span class="gi">+    def type(self):</span>
<span class="gi">+        return get_type(self._type)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __eq__(self, other):
<span class="gd">-        return isinstance(other, Argument) and (self.name == other.name and</span>
<span class="gd">-            self.type == other.type and self.default_value == other.</span>
<span class="gd">-            default_value and self.description == other.description and </span>
<span class="gd">-            self.deprecation_reason == other.deprecation_reason)</span>
<span class="gi">+        return isinstance(other, Argument) and (</span>
<span class="gi">+            self.name == other.name</span>
<span class="gi">+            and self.type == other.type</span>
<span class="gi">+            and self.default_value == other.default_value</span>
<span class="gi">+            and self.description == other.description</span>
<span class="gi">+            and self.deprecation_reason == other.deprecation_reason</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_arguments(args, extra_args=None):</span>
<span class="gi">+    from .unmountedtype import UnmountedType</span>
<span class="gi">+    from .field import Field</span>
<span class="gi">+    from .inputfield import InputField</span>
<span class="gi">+</span>
<span class="gi">+    if extra_args:</span>
<span class="gi">+        extra_args = sorted(extra_args.items(), key=lambda f: f[1])</span>
<span class="gi">+    else:</span>
<span class="gi">+        extra_args = []</span>
<span class="gi">+    iter_arguments = chain(args.items(), extra_args)</span>
<span class="gi">+    arguments = {}</span>
<span class="gi">+    for default_name, arg in iter_arguments:</span>
<span class="gi">+        if isinstance(arg, Dynamic):</span>
<span class="gi">+            arg = arg.get_type()</span>
<span class="gi">+            if arg is None:</span>
<span class="gi">+                # If the Dynamic type returned None</span>
<span class="gi">+                # then we skip the Argument</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(arg, UnmountedType):</span>
<span class="gi">+            arg = Argument.mounted(arg)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(arg, (InputField, Field)):</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                f&quot;Expected {default_name} to be Argument, &quot;</span>
<span class="gi">+                f&quot;but received {type(arg).__name__}. Try using Argument({arg.type}).&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(arg, Argument):</span>
<span class="gi">+            raise ValueError(f&#39;Unknown argument &quot;{default_name}&quot;.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        arg_name = default_name or arg.name</span>
<span class="gi">+        assert (</span>
<span class="gi">+            arg_name not in arguments</span>
<span class="gi">+        ), f&#39;More than one Argument have same name &quot;{arg_name}&quot;.&#39;</span>
<span class="gi">+        arguments[arg_name] = arg</span>
<span class="gi">+</span>
<span class="gi">+    return arguments</span>
<span class="gh">diff --git a/graphene/types/base.py b/graphene/types/base.py</span>
<span class="gh">index 6483a0d..84cb377 100644</span>
<span class="gd">--- a/graphene/types/base.py</span>
<span class="gi">+++ b/graphene/types/base.py</span>
<span class="gu">@@ -1,15 +1,20 @@</span>
<span class="w"> </span>from typing import Type
<span class="gi">+</span>
<span class="w"> </span>from ..utils.subclass_with_meta import SubclassWithMeta, SubclassWithMeta_Meta
<span class="w"> </span>from ..utils.trim_docstring import trim_docstring


<span class="w"> </span>class BaseOptions:
<span class="gd">-    name = None</span>
<span class="gd">-    description = None</span>
<span class="gd">-    _frozen = False</span>
<span class="gi">+    name = None  # type: str</span>
<span class="gi">+    description = None  # type: str</span>
<span class="gi">+</span>
<span class="gi">+    _frozen = False  # type: bool</span>

<span class="w"> </span>    def __init__(self, class_type):
<span class="gd">-        self.class_type = class_type</span>
<span class="gi">+        self.class_type = class_type  # type: Type</span>
<span class="gi">+</span>
<span class="gi">+    def freeze(self):</span>
<span class="gi">+        self._frozen = True</span>

<span class="w"> </span>    def __setattr__(self, name, value):
<span class="w"> </span>        if not self._frozen:
<span class="gu">@@ -18,18 +23,22 @@ class BaseOptions:</span>
<span class="w"> </span>            raise Exception(f&quot;Can&#39;t modify frozen Options {self}&quot;)

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;&lt;{self.__class__.__name__} name={repr(self.name)}&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;{self.__class__.__name__} name={repr(self.name)}&gt;&quot;</span>


<span class="w"> </span>BaseTypeMeta = SubclassWithMeta_Meta


<span class="w"> </span>class BaseType(SubclassWithMeta):
<span class="gi">+    @classmethod</span>
<span class="gi">+    def create_type(cls, class_name, **options):</span>
<span class="gi">+        return type(class_name, (cls,), {&quot;Meta&quot;: options})</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __init_subclass_with_meta__(cls, name=None, description=None, _meta</span>
<span class="gd">-        =None, **_kwargs):</span>
<span class="gd">-        assert &#39;_meta&#39; not in cls.__dict__, &quot;Can&#39;t assign meta directly&quot;</span>
<span class="gi">+    def __init_subclass_with_meta__(</span>
<span class="gi">+        cls, name=None, description=None, _meta=None, **_kwargs</span>
<span class="gi">+    ):</span>
<span class="gi">+        assert &quot;_meta&quot; not in cls.__dict__, &quot;Can&#39;t assign meta directly&quot;</span>
<span class="w"> </span>        if not _meta:
<span class="w"> </span>            return
<span class="w"> </span>        _meta.name = name or cls.__name__
<span class="gh">diff --git a/graphene/types/base64.py b/graphene/types/base64.py</span>
<span class="gh">index 4f5949a..69bb338 100644</span>
<span class="gd">--- a/graphene/types/base64.py</span>
<span class="gi">+++ b/graphene/types/base64.py</span>
<span class="gu">@@ -1,7 +1,9 @@</span>
<span class="w"> </span>from binascii import Error as _Error
<span class="w"> </span>from base64 import b64decode, b64encode
<span class="gi">+</span>
<span class="w"> </span>from graphql.error import GraphQLError
<span class="w"> </span>from graphql.language import StringValueNode, print_ast
<span class="gi">+</span>
<span class="w"> </span>from .scalars import Scalar


<span class="gu">@@ -9,3 +11,33 @@ class Base64(Scalar):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The `Base64` scalar type represents a base64-encoded String.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def serialize(value):</span>
<span class="gi">+        if not isinstance(value, bytes):</span>
<span class="gi">+            if isinstance(value, str):</span>
<span class="gi">+                value = value.encode(&quot;utf-8&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                value = str(value).encode(&quot;utf-8&quot;)</span>
<span class="gi">+        return b64encode(value).decode(&quot;utf-8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def parse_literal(cls, node, _variables=None):</span>
<span class="gi">+        if not isinstance(node, StringValueNode):</span>
<span class="gi">+            raise GraphQLError(</span>
<span class="gi">+                f&quot;Base64 cannot represent non-string value: {print_ast(node)}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        return cls.parse_value(node.value)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_value(value):</span>
<span class="gi">+        if not isinstance(value, bytes):</span>
<span class="gi">+            if not isinstance(value, str):</span>
<span class="gi">+                raise GraphQLError(</span>
<span class="gi">+                    f&quot;Base64 cannot represent non-string value: {repr(value)}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            value = value.encode(&quot;utf-8&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return b64decode(value, validate=True).decode(&quot;utf-8&quot;)</span>
<span class="gi">+        except _Error:</span>
<span class="gi">+            raise GraphQLError(f&quot;Base64 cannot decode value: {repr(value)}&quot;)</span>
<span class="gh">diff --git a/graphene/types/datetime.py b/graphene/types/datetime.py</span>
<span class="gh">index a473f89..d4f7447 100644</span>
<span class="gd">--- a/graphene/types/datetime.py</span>
<span class="gi">+++ b/graphene/types/datetime.py</span>
<span class="gu">@@ -1,8 +1,11 @@</span>
<span class="w"> </span>from __future__ import absolute_import
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="gi">+</span>
<span class="w"> </span>from aniso8601 import parse_date, parse_datetime, parse_time
<span class="w"> </span>from graphql.error import GraphQLError
<span class="w"> </span>from graphql.language import StringValueNode, print_ast
<span class="gi">+</span>
<span class="w"> </span>from .scalars import Scalar


<span class="gu">@@ -13,6 +16,33 @@ class Date(Scalar):</span>
<span class="w"> </span>    [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def serialize(date):</span>
<span class="gi">+        if isinstance(date, datetime.datetime):</span>
<span class="gi">+            date = date.date()</span>
<span class="gi">+        if not isinstance(date, datetime.date):</span>
<span class="gi">+            raise GraphQLError(f&quot;Date cannot represent value: {repr(date)}&quot;)</span>
<span class="gi">+        return date.isoformat()</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def parse_literal(cls, node, _variables=None):</span>
<span class="gi">+        if not isinstance(node, StringValueNode):</span>
<span class="gi">+            raise GraphQLError(</span>
<span class="gi">+                f&quot;Date cannot represent non-string value: {print_ast(node)}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        return cls.parse_value(node.value)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_value(value):</span>
<span class="gi">+        if isinstance(value, datetime.date):</span>
<span class="gi">+            return value</span>
<span class="gi">+        if not isinstance(value, str):</span>
<span class="gi">+            raise GraphQLError(f&quot;Date cannot represent non-string value: {repr(value)}&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return parse_date(value)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise GraphQLError(f&quot;Date cannot represent value: {repr(value)}&quot;)</span>
<span class="gi">+</span>

<span class="w"> </span>class DateTime(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -21,6 +51,33 @@ class DateTime(Scalar):</span>
<span class="w"> </span>    [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def serialize(dt):</span>
<span class="gi">+        if not isinstance(dt, (datetime.datetime, datetime.date)):</span>
<span class="gi">+            raise GraphQLError(f&quot;DateTime cannot represent value: {repr(dt)}&quot;)</span>
<span class="gi">+        return dt.isoformat()</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def parse_literal(cls, node, _variables=None):</span>
<span class="gi">+        if not isinstance(node, StringValueNode):</span>
<span class="gi">+            raise GraphQLError(</span>
<span class="gi">+                f&quot;DateTime cannot represent non-string value: {print_ast(node)}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        return cls.parse_value(node.value)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_value(value):</span>
<span class="gi">+        if isinstance(value, datetime.datetime):</span>
<span class="gi">+            return value</span>
<span class="gi">+        if not isinstance(value, str):</span>
<span class="gi">+            raise GraphQLError(</span>
<span class="gi">+                f&quot;DateTime cannot represent non-string value: {repr(value)}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        try:</span>
<span class="gi">+            return parse_datetime(value)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise GraphQLError(f&quot;DateTime cannot represent value: {repr(value)}&quot;)</span>
<span class="gi">+</span>

<span class="w"> </span>class Time(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -28,3 +85,28 @@ class Time(Scalar):</span>
<span class="w"> </span>    specified by
<span class="w"> </span>    [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def serialize(time):</span>
<span class="gi">+        if not isinstance(time, datetime.time):</span>
<span class="gi">+            raise GraphQLError(f&quot;Time cannot represent value: {repr(time)}&quot;)</span>
<span class="gi">+        return time.isoformat()</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def parse_literal(cls, node, _variables=None):</span>
<span class="gi">+        if not isinstance(node, StringValueNode):</span>
<span class="gi">+            raise GraphQLError(</span>
<span class="gi">+                f&quot;Time cannot represent non-string value: {print_ast(node)}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        return cls.parse_value(node.value)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def parse_value(cls, value):</span>
<span class="gi">+        if isinstance(value, datetime.time):</span>
<span class="gi">+            return value</span>
<span class="gi">+        if not isinstance(value, str):</span>
<span class="gi">+            raise GraphQLError(f&quot;Time cannot represent non-string value: {repr(value)}&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return parse_time(value)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise GraphQLError(f&quot;Time cannot represent value: {repr(value)}&quot;)</span>
<span class="gh">diff --git a/graphene/types/decimal.py b/graphene/types/decimal.py</span>
<span class="gh">index 5607802..0c6ccc9 100644</span>
<span class="gd">--- a/graphene/types/decimal.py</span>
<span class="gi">+++ b/graphene/types/decimal.py</span>
<span class="gu">@@ -1,7 +1,10 @@</span>
<span class="w"> </span>from __future__ import absolute_import
<span class="gi">+</span>
<span class="w"> </span>from decimal import Decimal as _Decimal
<span class="gi">+</span>
<span class="w"> </span>from graphql import Undefined
<span class="w"> </span>from graphql.language.ast import StringValueNode, IntValueNode
<span class="gi">+</span>
<span class="w"> </span>from .scalars import Scalar


<span class="gu">@@ -9,3 +12,25 @@ class Decimal(Scalar):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The `Decimal` scalar type represents a python Decimal.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def serialize(dec):</span>
<span class="gi">+        if isinstance(dec, str):</span>
<span class="gi">+            dec = _Decimal(dec)</span>
<span class="gi">+        assert isinstance(</span>
<span class="gi">+            dec, _Decimal</span>
<span class="gi">+        ), f&#39;Received not compatible Decimal &quot;{repr(dec)}&quot;&#39;</span>
<span class="gi">+        return str(dec)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def parse_literal(cls, node, _variables=None):</span>
<span class="gi">+        if isinstance(node, (StringValueNode, IntValueNode)):</span>
<span class="gi">+            return cls.parse_value(node.value)</span>
<span class="gi">+        return Undefined</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_value(value):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return _Decimal(value)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return Undefined</span>
<span class="gh">diff --git a/graphene/types/definitions.py b/graphene/types/definitions.py</span>
<span class="gh">index 12b2a86..ac574be 100644</span>
<span class="gd">--- a/graphene/types/definitions.py</span>
<span class="gi">+++ b/graphene/types/definitions.py</span>
<span class="gu">@@ -1,5 +1,13 @@</span>
<span class="w"> </span>from enum import Enum as PyEnum
<span class="gd">-from graphql import GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLObjectType, GraphQLScalarType, GraphQLUnionType</span>
<span class="gi">+</span>
<span class="gi">+from graphql import (</span>
<span class="gi">+    GraphQLEnumType,</span>
<span class="gi">+    GraphQLInputObjectType,</span>
<span class="gi">+    GraphQLInterfaceType,</span>
<span class="gi">+    GraphQLObjectType,</span>
<span class="gi">+    GraphQLScalarType,</span>
<span class="gi">+    GraphQLUnionType,</span>
<span class="gi">+)</span>


<span class="w"> </span>class GrapheneGraphQLType:
<span class="gu">@@ -9,7 +17,7 @@ class GrapheneGraphQLType:</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="gd">-        self.graphene_type = kwargs.pop(&#39;graphene_type&#39;)</span>
<span class="gi">+        self.graphene_type = kwargs.pop(&quot;graphene_type&quot;)</span>
<span class="w"> </span>        super(GrapheneGraphQLType, self).__init__(*args, **kwargs)

<span class="w"> </span>    def __copy__(self):
<span class="gu">@@ -35,7 +43,19 @@ class GrapheneScalarType(GrapheneGraphQLType, GraphQLScalarType):</span>


<span class="w"> </span>class GrapheneEnumType(GrapheneGraphQLType, GraphQLEnumType):
<span class="gd">-    pass</span>
<span class="gi">+    def serialize(self, value):</span>
<span class="gi">+        if not isinstance(value, PyEnum):</span>
<span class="gi">+            enum = self.graphene_type._meta.enum</span>
<span class="gi">+            try:</span>
<span class="gi">+                # Try and get enum by value</span>
<span class="gi">+                value = enum(value)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                # Try and get enum by name</span>
<span class="gi">+                try:</span>
<span class="gi">+                    value = enum[value]</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+        return super(GrapheneEnumType, self).serialize(value)</span>


<span class="w"> </span>class GrapheneInputObjectType(GrapheneGraphQLType, GraphQLInputObjectType):
<span class="gh">diff --git a/graphene/types/dynamic.py b/graphene/types/dynamic.py</span>
<span class="gh">index 4818d92..3bb2b0f 100644</span>
<span class="gd">--- a/graphene/types/dynamic.py</span>
<span class="gi">+++ b/graphene/types/dynamic.py</span>
<span class="gu">@@ -1,5 +1,6 @@</span>
<span class="w"> </span>import inspect
<span class="w"> </span>from functools import partial
<span class="gi">+</span>
<span class="w"> </span>from .mountedtype import MountedType


<span class="gu">@@ -14,3 +15,8 @@ class Dynamic(MountedType):</span>
<span class="w"> </span>        assert inspect.isfunction(type_) or isinstance(type_, partial)
<span class="w"> </span>        self.type = type_
<span class="w"> </span>        self.with_schema = with_schema
<span class="gi">+</span>
<span class="gi">+    def get_type(self, schema=None):</span>
<span class="gi">+        if schema and self.with_schema:</span>
<span class="gi">+            return self.type(schema=schema)</span>
<span class="gi">+        return self.type()</span>
<span class="gh">diff --git a/graphene/types/enum.py b/graphene/types/enum.py</span>
<span class="gh">index cce1873..d3469a1 100644</span>
<span class="gd">--- a/graphene/types/enum.py</span>
<span class="gi">+++ b/graphene/types/enum.py</span>
<span class="gu">@@ -1,43 +1,79 @@</span>
<span class="w"> </span>from enum import Enum as PyEnum
<span class="gi">+</span>
<span class="w"> </span>from graphene.utils.subclass_with_meta import SubclassWithMeta_Meta
<span class="gi">+</span>
<span class="w"> </span>from .base import BaseOptions, BaseType
<span class="w"> </span>from .unmountedtype import UnmountedType
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def eq_enum(self, other):</span>
<span class="gi">+    if isinstance(other, self.__class__):</span>
<span class="gi">+        return self is other</span>
<span class="gi">+    return self.value is other</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def hash_enum(self):</span>
<span class="gi">+    return hash(self.name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>EnumType = type(PyEnum)


<span class="w"> </span>class EnumOptions(BaseOptions):
<span class="gd">-    enum = None</span>
<span class="gi">+    enum = None  # type: Enum</span>
<span class="w"> </span>    deprecation_reason = None


<span class="w"> </span>class EnumMeta(SubclassWithMeta_Meta):
<span class="gd">-</span>
<span class="w"> </span>    def __new__(cls, name_, bases, classdict, **options):
<span class="w"> </span>        enum_members = dict(classdict, __eq__=eq_enum, __hash__=hash_enum)
<span class="gd">-        enum_members.pop(&#39;Meta&#39;, None)</span>
<span class="gi">+        # We remove the Meta attribute from the class to not collide</span>
<span class="gi">+        # with the enum values.</span>
<span class="gi">+        enum_members.pop(&quot;Meta&quot;, None)</span>
<span class="w"> </span>        enum = PyEnum(cls.__name__, enum_members)
<span class="gd">-        obj = SubclassWithMeta_Meta.__new__(cls, name_, bases, dict(</span>
<span class="gd">-            classdict, __enum__=enum), **options)</span>
<span class="gi">+        obj = SubclassWithMeta_Meta.__new__(</span>
<span class="gi">+            cls, name_, bases, dict(classdict, __enum__=enum), **options</span>
<span class="gi">+        )</span>
<span class="w"> </span>        globals()[name_] = obj.__enum__
<span class="w"> </span>        return obj

<span class="gi">+    def get(cls, value):</span>
<span class="gi">+        return cls._meta.enum(value)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __getitem__(cls, value):
<span class="w"> </span>        return cls._meta.enum[value]

<span class="gd">-    def __prepare__(name, bases, **kwargs):</span>
<span class="gi">+    def __prepare__(name, bases, **kwargs):  # noqa: N805</span>
<span class="w"> </span>        return {}

<span class="gd">-    def __call__(cls, *args, **kwargs):</span>
<span class="gi">+    def __call__(cls, *args, **kwargs):  # noqa: N805</span>
<span class="w"> </span>        if cls is Enum:
<span class="gd">-            description = kwargs.pop(&#39;description&#39;, None)</span>
<span class="gd">-            deprecation_reason = kwargs.pop(&#39;deprecation_reason&#39;, None)</span>
<span class="gd">-            return cls.from_enum(PyEnum(*args, **kwargs), description=</span>
<span class="gd">-                description, deprecation_reason=deprecation_reason)</span>
<span class="gi">+            description = kwargs.pop(&quot;description&quot;, None)</span>
<span class="gi">+            deprecation_reason = kwargs.pop(&quot;deprecation_reason&quot;, None)</span>
<span class="gi">+            return cls.from_enum(</span>
<span class="gi">+                PyEnum(*args, **kwargs),</span>
<span class="gi">+                description=description,</span>
<span class="gi">+                deprecation_reason=deprecation_reason,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        return super(EnumMeta, cls).__call__(*args, **kwargs)
<span class="gi">+        # return cls._meta.enum(*args, **kwargs)</span>

<span class="w"> </span>    def __iter__(cls):
<span class="w"> </span>        return cls._meta.enum.__iter__()

<span class="gi">+    def from_enum(</span>
<span class="gi">+        cls, enum, name=None, description=None, deprecation_reason=None</span>
<span class="gi">+    ):  # noqa: N805</span>
<span class="gi">+        name = name or enum.__name__</span>
<span class="gi">+        description = description or enum.__doc__ or &quot;An enumeration.&quot;</span>
<span class="gi">+        meta_dict = {</span>
<span class="gi">+            &quot;enum&quot;: enum,</span>
<span class="gi">+            &quot;description&quot;: description,</span>
<span class="gi">+            &quot;deprecation_reason&quot;: deprecation_reason,</span>
<span class="gi">+        }</span>
<span class="gi">+        meta_class = type(&quot;Meta&quot;, (object,), meta_dict)</span>
<span class="gi">+        return type(name, (Enum,), {&quot;Meta&quot;: meta_class})</span>
<span class="gi">+</span>

<span class="w"> </span>class Enum(UnmountedType, BaseType, metaclass=EnumMeta):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -69,9 +105,10 @@ class Enum(UnmountedType, BaseType, metaclass=EnumMeta):</span>
<span class="w"> </span>        if not _meta:
<span class="w"> </span>            _meta = EnumOptions(cls)
<span class="w"> </span>        _meta.enum = enum or cls.__enum__
<span class="gd">-        _meta.deprecation_reason = options.pop(&#39;deprecation_reason&#39;, None)</span>
<span class="gi">+        _meta.deprecation_reason = options.pop(&quot;deprecation_reason&quot;, None)</span>
<span class="w"> </span>        for key, value in _meta.enum.__members__.items():
<span class="w"> </span>            setattr(cls, key, value)
<span class="gi">+</span>
<span class="w"> </span>        super(Enum, cls).__init_subclass_with_meta__(_meta=_meta, **options)

<span class="w"> </span>    @classmethod
<span class="gu">@@ -80,4 +117,4 @@ class Enum(UnmountedType, BaseType, metaclass=EnumMeta):</span>
<span class="w"> </span>        This function is called when the unmounted type (Enum instance)
<span class="w"> </span>        is mounted (as a Field, InputField or Argument)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls</span>
<span class="gh">diff --git a/graphene/types/field.py b/graphene/types/field.py</span>
<span class="gh">index a23e927..dafb04b 100644</span>
<span class="gd">--- a/graphene/types/field.py</span>
<span class="gi">+++ b/graphene/types/field.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>import inspect
<span class="w"> </span>from collections.abc import Mapping
<span class="w"> </span>from functools import partial
<span class="gi">+</span>
<span class="w"> </span>from .argument import Argument, to_arguments
<span class="w"> </span>from .mountedtype import MountedType
<span class="w"> </span>from .resolver import default_resolver
<span class="gu">@@ -8,9 +9,17 @@ from .structures import NonNull</span>
<span class="w"> </span>from .unmountedtype import UnmountedType
<span class="w"> </span>from .utils import get_type
<span class="w"> </span>from ..utils.deprecated import warn_deprecation
<span class="gi">+</span>
<span class="w"> </span>base_type = type


<span class="gi">+def source_resolver(source, root, info, **args):</span>
<span class="gi">+    resolved = default_resolver(source, None, root, info, **args)</span>
<span class="gi">+    if inspect.isfunction(resolved) or inspect.ismethod(resolved):</span>
<span class="gi">+        return resolved()</span>
<span class="gi">+    return resolved</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Field(MountedType):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Makes a field available on an ObjectType in the GraphQL schema. Any type can be mounted as a
<span class="gu">@@ -54,24 +63,44 @@ class Field(MountedType):</span>
<span class="w"> </span>            additional arguments to mount on the field.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, type_, args=None, resolver=None, source=None,</span>
<span class="gd">-        deprecation_reason=None, name=None, description=None, required=</span>
<span class="gd">-        False, _creation_counter=None, default_value=None, **extra_args):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        type_,</span>
<span class="gi">+        args=None,</span>
<span class="gi">+        resolver=None,</span>
<span class="gi">+        source=None,</span>
<span class="gi">+        deprecation_reason=None,</span>
<span class="gi">+        name=None,</span>
<span class="gi">+        description=None,</span>
<span class="gi">+        required=False,</span>
<span class="gi">+        _creation_counter=None,</span>
<span class="gi">+        default_value=None,</span>
<span class="gi">+        **extra_args,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super(Field, self).__init__(_creation_counter=_creation_counter)
<span class="gd">-        assert not args or isinstance(args, Mapping</span>
<span class="gd">-            ), f&#39;Arguments in a field have to be a mapping, received &quot;{args}&quot;.&#39;</span>
<span class="gd">-        assert not (source and resolver</span>
<span class="gd">-            ), &#39;A Field cannot have a source and a resolver in at the same time.&#39;</span>
<span class="gd">-        assert not callable(default_value</span>
<span class="gd">-            ), f&#39;The default value can not be a function but received &quot;{base_type(default_value)}&quot;.&#39;</span>
<span class="gi">+        assert not args or isinstance(</span>
<span class="gi">+            args, Mapping</span>
<span class="gi">+        ), f&#39;Arguments in a field have to be a mapping, received &quot;{args}&quot;.&#39;</span>
<span class="gi">+        assert not (</span>
<span class="gi">+            source and resolver</span>
<span class="gi">+        ), &quot;A Field cannot have a source and a resolver in at the same time.&quot;</span>
<span class="gi">+        assert not callable(</span>
<span class="gi">+            default_value</span>
<span class="gi">+        ), f&#39;The default value can not be a function but received &quot;{base_type(default_value)}&quot;.&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>        if required:
<span class="w"> </span>            type_ = NonNull(type_)
<span class="gi">+</span>
<span class="gi">+        # Check if name is actually an argument of the field</span>
<span class="w"> </span>        if isinstance(name, (Argument, UnmountedType)):
<span class="gd">-            extra_args[&#39;name&#39;] = name</span>
<span class="gi">+            extra_args[&quot;name&quot;] = name</span>
<span class="w"> </span>            name = None
<span class="gi">+</span>
<span class="gi">+        # Check if source is actually an argument of the field</span>
<span class="w"> </span>        if isinstance(source, (Argument, UnmountedType)):
<span class="gd">-            extra_args[&#39;source&#39;] = source</span>
<span class="gi">+            extra_args[&quot;source&quot;] = source</span>
<span class="w"> </span>            source = None
<span class="gi">+</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self._type = type_
<span class="w"> </span>        self.args = to_arguments(args or {}, extra_args)
<span class="gu">@@ -81,6 +110,11 @@ class Field(MountedType):</span>
<span class="w"> </span>        self.deprecation_reason = deprecation_reason
<span class="w"> </span>        self.description = description
<span class="w"> </span>        self.default_value = default_value
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def type(self):</span>
<span class="gi">+        return get_type(self._type)</span>
<span class="gi">+</span>
<span class="w"> </span>    get_resolver = None

<span class="w"> </span>    def wrap_resolve(self, parent_resolver):
<span class="gu">@@ -88,11 +122,17 @@ class Field(MountedType):</span>
<span class="w"> </span>        Wraps a function resolver, using the ObjectType resolve_{FIELD_NAME}
<span class="w"> </span>        (parent_resolver) if the Field definition has no resolver.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.get_resolver is not None:</span>
<span class="gi">+            warn_deprecation(</span>
<span class="gi">+                &quot;The get_resolver method is being deprecated, please rename it to wrap_resolve.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            return self.get_resolver(parent_resolver)</span>
<span class="gi">+</span>
<span class="gi">+        return self.resolver or parent_resolver</span>

<span class="w"> </span>    def wrap_subscribe(self, parent_subscribe):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Wraps a function subscribe, using the ObjectType subscribe_{FIELD_NAME}
<span class="w"> </span>        (parent_subscribe) if the Field definition has no subscribe.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return parent_subscribe</span>
<span class="gh">diff --git a/graphene/types/generic.py b/graphene/types/generic.py</span>
<span class="gh">index fc0488e..2a3c8d5 100644</span>
<span class="gd">--- a/graphene/types/generic.py</span>
<span class="gi">+++ b/graphene/types/generic.py</span>
<span class="gu">@@ -1,6 +1,16 @@</span>
<span class="w"> </span>from __future__ import unicode_literals
<span class="gd">-from graphql.language.ast import BooleanValueNode, FloatValueNode, IntValueNode, ListValueNode, ObjectValueNode, StringValueNode</span>
<span class="gi">+</span>
<span class="gi">+from graphql.language.ast import (</span>
<span class="gi">+    BooleanValueNode,</span>
<span class="gi">+    FloatValueNode,</span>
<span class="gi">+    IntValueNode,</span>
<span class="gi">+    ListValueNode,</span>
<span class="gi">+    ObjectValueNode,</span>
<span class="gi">+    StringValueNode,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from graphene.types.scalars import MAX_INT, MIN_INT
<span class="gi">+</span>
<span class="w"> </span>from .scalars import Scalar


<span class="gu">@@ -10,5 +20,30 @@ class GenericScalar(Scalar):</span>
<span class="w"> </span>    GraphQL scalar value that could be:
<span class="w"> </span>    String, Boolean, Int, Float, List or Object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def identity(value):</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="w"> </span>    serialize = identity
<span class="w"> </span>    parse_value = identity
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_literal(ast, _variables=None):</span>
<span class="gi">+        if isinstance(ast, (StringValueNode, BooleanValueNode)):</span>
<span class="gi">+            return ast.value</span>
<span class="gi">+        elif isinstance(ast, IntValueNode):</span>
<span class="gi">+            num = int(ast.value)</span>
<span class="gi">+            if MIN_INT &lt;= num &lt;= MAX_INT:</span>
<span class="gi">+                return num</span>
<span class="gi">+        elif isinstance(ast, FloatValueNode):</span>
<span class="gi">+            return float(ast.value)</span>
<span class="gi">+        elif isinstance(ast, ListValueNode):</span>
<span class="gi">+            return [GenericScalar.parse_literal(value) for value in ast.values]</span>
<span class="gi">+        elif isinstance(ast, ObjectValueNode):</span>
<span class="gi">+            return {</span>
<span class="gi">+                field.name.value: GenericScalar.parse_literal(field.value)</span>
<span class="gi">+                for field in ast.fields</span>
<span class="gi">+            }</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gh">diff --git a/graphene/types/inputfield.py b/graphene/types/inputfield.py</span>
<span class="gh">index a1bc6a6..e7ededb 100644</span>
<span class="gd">--- a/graphene/types/inputfield.py</span>
<span class="gi">+++ b/graphene/types/inputfield.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from graphql import Undefined
<span class="gi">+</span>
<span class="w"> </span>from .mountedtype import MountedType
<span class="w"> </span>from .structures import NonNull
<span class="w"> </span>from .utils import get_type
<span class="gu">@@ -45,15 +46,29 @@ class InputField(MountedType):</span>
<span class="w"> </span>        **extra_args (optional, Dict): Not used.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, type_, name=None, default_value=Undefined,</span>
<span class="gd">-        deprecation_reason=None, description=None, required=False,</span>
<span class="gd">-        _creation_counter=None, **extra_args):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        type_,</span>
<span class="gi">+        name=None,</span>
<span class="gi">+        default_value=Undefined,</span>
<span class="gi">+        deprecation_reason=None,</span>
<span class="gi">+        description=None,</span>
<span class="gi">+        required=False,</span>
<span class="gi">+        _creation_counter=None,</span>
<span class="gi">+        **extra_args,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super(InputField, self).__init__(_creation_counter=_creation_counter)
<span class="w"> </span>        self.name = name
<span class="w"> </span>        if required:
<span class="gd">-            assert deprecation_reason is None, f&#39;InputField {name} is required, cannot deprecate it.&#39;</span>
<span class="gi">+            assert (</span>
<span class="gi">+                deprecation_reason is None</span>
<span class="gi">+            ), f&quot;InputField {name} is required, cannot deprecate it.&quot;</span>
<span class="w"> </span>            type_ = NonNull(type_)
<span class="w"> </span>        self._type = type_
<span class="w"> </span>        self.deprecation_reason = deprecation_reason
<span class="w"> </span>        self.default_value = default_value
<span class="w"> </span>        self.description = description
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def type(self):</span>
<span class="gi">+        return get_type(self._type)</span>
<span class="gh">diff --git a/graphene/types/inputobjecttype.py b/graphene/types/inputobjecttype.py</span>
<span class="gh">index f99e2c1..257f48b 100644</span>
<span class="gd">--- a/graphene/types/inputobjecttype.py</span>
<span class="gi">+++ b/graphene/types/inputobjecttype.py</span>
<span class="gu">@@ -1,19 +1,31 @@</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from .base import BaseOptions, BaseType
<span class="w"> </span>from .inputfield import InputField
<span class="w"> </span>from .unmountedtype import UnmountedType
<span class="w"> </span>from .utils import yank_fields_from_attrs
<span class="gi">+</span>
<span class="gi">+# For static type checking with type checker</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gd">-    from typing import Dict, Callable</span>
<span class="gi">+    from typing import Dict, Callable  # NOQA</span>


<span class="w"> </span>class InputObjectTypeOptions(BaseOptions):
<span class="gd">-    fields = None</span>
<span class="gd">-    container = None</span>
<span class="gi">+    fields = None  # type: Dict[str, InputField]</span>
<span class="gi">+    container = None  # type: InputObjectTypeContainer</span>


<span class="gi">+# Currently in Graphene, we get a `None` whenever we access an (optional) field that was not set in an InputObjectType</span>
<span class="gi">+# using the InputObjectType.&lt;attribute&gt; dot access syntax. This is ambiguous, because in this current (Graphene</span>
<span class="gi">+# historical) arrangement, we cannot distinguish between a field not being set and a field being set to None.</span>
<span class="gi">+# At the same time, we shouldn&#39;t break existing code that expects a `None` when accessing a field that was not set.</span>
<span class="w"> </span>_INPUT_OBJECT_TYPE_DEFAULT_VALUE = None

<span class="gi">+# To mitigate this, we provide the function `set_input_object_type_default_value` to allow users to change the default</span>
<span class="gi">+# value returned in non-specified fields in InputObjectType to another meaningful sentinel value (e.g. Undefined)</span>
<span class="gi">+# if they want to. This way, we can keep code that expects a `None` working while we figure out a better solution (or</span>
<span class="gi">+# a well-documented breaking change) for this issue.</span>
<span class="gi">+</span>

<span class="w"> </span>def set_input_object_type_default_value(default_value):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -24,12 +36,11 @@ def set_input_object_type_default_value(default_value):</span>
<span class="w"> </span>    This function should be called at the beginning of the app or in some other place where it is guaranteed to
<span class="w"> </span>    be called before any InputObjectType is defined.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-class InputObjectTypeContainer(dict, BaseType):</span>
<span class="gi">+    global _INPUT_OBJECT_TYPE_DEFAULT_VALUE</span>
<span class="gi">+    _INPUT_OBJECT_TYPE_DEFAULT_VALUE = default_value</span>


<span class="gi">+class InputObjectTypeContainer(dict, BaseType):  # type: ignore</span>
<span class="w"> </span>    class Meta:
<span class="w"> </span>        abstract = True

<span class="gu">@@ -79,14 +90,14 @@ class InputObjectType(UnmountedType, BaseType):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @classmethod
<span class="gd">-    def __init_subclass_with_meta__(cls, container=None, _meta=None, **options</span>
<span class="gd">-        ):</span>
<span class="gi">+    def __init_subclass_with_meta__(cls, container=None, _meta=None, **options):</span>
<span class="w"> </span>        if not _meta:
<span class="w"> </span>            _meta = InputObjectTypeOptions(cls)
<span class="gi">+</span>
<span class="w"> </span>        fields = {}
<span class="w"> </span>        for base in reversed(cls.__mro__):
<span class="gd">-            fields.update(yank_fields_from_attrs(base.__dict__, _as=InputField)</span>
<span class="gd">-                )</span>
<span class="gi">+            fields.update(yank_fields_from_attrs(base.__dict__, _as=InputField))</span>
<span class="gi">+</span>
<span class="w"> </span>        if _meta.fields:
<span class="w"> </span>            _meta.fields.update(fields)
<span class="w"> </span>        else:
<span class="gu">@@ -94,8 +105,7 @@ class InputObjectType(UnmountedType, BaseType):</span>
<span class="w"> </span>        if container is None:
<span class="w"> </span>            container = type(cls.__name__, (InputObjectTypeContainer, cls), {})
<span class="w"> </span>        _meta.container = container
<span class="gd">-        super(InputObjectType, cls).__init_subclass_with_meta__(_meta=_meta,</span>
<span class="gd">-            **options)</span>
<span class="gi">+        super(InputObjectType, cls).__init_subclass_with_meta__(_meta=_meta, **options)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def get_type(cls):
<span class="gu">@@ -103,4 +113,4 @@ class InputObjectType(UnmountedType, BaseType):</span>
<span class="w"> </span>        This function is called when the unmounted type (InputObjectType instance)
<span class="w"> </span>        is mounted (as a Field, InputField or Argument)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls</span>
<span class="gh">diff --git a/graphene/types/interface.py b/graphene/types/interface.py</span>
<span class="gh">index 733a6f1..31bcc7f 100644</span>
<span class="gd">--- a/graphene/types/interface.py</span>
<span class="gi">+++ b/graphene/types/interface.py</span>
<span class="gu">@@ -1,14 +1,17 @@</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from .base import BaseOptions, BaseType
<span class="w"> </span>from .field import Field
<span class="w"> </span>from .utils import yank_fields_from_attrs
<span class="gi">+</span>
<span class="gi">+# For static type checking with type checker</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gd">-    from typing import Dict, Iterable, Type</span>
<span class="gi">+    from typing import Dict, Iterable, Type  # NOQA</span>


<span class="w"> </span>class InterfaceOptions(BaseOptions):
<span class="gd">-    fields = None</span>
<span class="gd">-    interfaces = ()</span>
<span class="gi">+    fields = None  # type: Dict[str, Field]</span>
<span class="gi">+    interfaces = ()  # type: Iterable[Type[Interface]]</span>


<span class="w"> </span>class Interface(BaseType):
<span class="gu">@@ -47,17 +50,27 @@ class Interface(BaseType):</span>
<span class="w"> </span>    def __init_subclass_with_meta__(cls, _meta=None, interfaces=(), **options):
<span class="w"> </span>        if not _meta:
<span class="w"> </span>            _meta = InterfaceOptions(cls)
<span class="gi">+</span>
<span class="w"> </span>        fields = {}
<span class="w"> </span>        for base in reversed(cls.__mro__):
<span class="w"> </span>            fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
<span class="gi">+</span>
<span class="w"> </span>        if _meta.fields:
<span class="w"> </span>            _meta.fields.update(fields)
<span class="w"> </span>        else:
<span class="w"> </span>            _meta.fields = fields
<span class="gi">+</span>
<span class="w"> </span>        if not _meta.interfaces:
<span class="w"> </span>            _meta.interfaces = interfaces
<span class="gd">-        super(Interface, cls).__init_subclass_with_meta__(_meta=_meta, **</span>
<span class="gd">-            options)</span>
<span class="gi">+</span>
<span class="gi">+        super(Interface, cls).__init_subclass_with_meta__(_meta=_meta, **options)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def resolve_type(cls, instance, info):</span>
<span class="gi">+        from .objecttype import ObjectType</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(instance, ObjectType):</span>
<span class="gi">+            return type(instance)</span>

<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="gd">-        raise Exception(&#39;An Interface cannot be initialized&#39;)</span>
<span class="gi">+        raise Exception(&quot;An Interface cannot be initialized&quot;)</span>
<span class="gh">diff --git a/graphene/types/json.py b/graphene/types/json.py</span>
<span class="gh">index a4f8f8d..ca55836 100644</span>
<span class="gd">--- a/graphene/types/json.py</span>
<span class="gi">+++ b/graphene/types/json.py</span>
<span class="gu">@@ -1,7 +1,10 @@</span>
<span class="w"> </span>from __future__ import absolute_import
<span class="gi">+</span>
<span class="w"> </span>import json
<span class="gi">+</span>
<span class="w"> </span>from graphql import Undefined
<span class="w"> </span>from graphql.language.ast import StringValueNode
<span class="gi">+</span>
<span class="w"> </span>from .scalars import Scalar


<span class="gu">@@ -12,3 +15,20 @@ class JSONString(Scalar):</span>
<span class="w"> </span>    Use of this type is *not recommended* as you lose the benefits of having a defined, static
<span class="w"> </span>    schema (one of the key benefits of GraphQL).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def serialize(dt):</span>
<span class="gi">+        return json.dumps(dt)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_literal(node, _variables=None):</span>
<span class="gi">+        if isinstance(node, StringValueNode):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return json.loads(node.value)</span>
<span class="gi">+            except Exception as error:</span>
<span class="gi">+                raise ValueError(f&quot;Badly formed JSONString: {str(error)}&quot;)</span>
<span class="gi">+        return Undefined</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_value(value):</span>
<span class="gi">+        return json.loads(value)</span>
<span class="gh">diff --git a/graphene/types/mountedtype.py b/graphene/types/mountedtype.py</span>
<span class="gh">index ac4f6e7..c42383e 100644</span>
<span class="gd">--- a/graphene/types/mountedtype.py</span>
<span class="gi">+++ b/graphene/types/mountedtype.py</span>
<span class="gu">@@ -3,10 +3,18 @@ from .unmountedtype import UnmountedType</span>


<span class="w"> </span>class MountedType(OrderedType):
<span class="gd">-</span>
<span class="w"> </span>    @classmethod
<span class="gd">-    def mounted(cls, unmounted):</span>
<span class="gi">+    def mounted(cls, unmounted):  # noqa: N802</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Mount the UnmountedType instance
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert isinstance(</span>
<span class="gi">+            unmounted, UnmountedType</span>
<span class="gi">+        ), f&quot;{cls.__name__} can&#39;t mount {repr(unmounted)}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            unmounted.get_type(),</span>
<span class="gi">+            *unmounted.args,</span>
<span class="gi">+            _creation_counter=unmounted.creation_counter,</span>
<span class="gi">+            **unmounted.kwargs,</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/graphene/types/mutation.py b/graphene/types/mutation.py</span>
<span class="gh">index 1e5c548..2de21b3 100644</span>
<span class="gd">--- a/graphene/types/mutation.py</span>
<span class="gi">+++ b/graphene/types/mutation.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from ..utils.deprecated import warn_deprecation
<span class="w"> </span>from ..utils.get_unbound_function import get_unbound_function
<span class="w"> </span>from ..utils.props import props
<span class="gu">@@ -6,16 +7,18 @@ from .field import Field</span>
<span class="w"> </span>from .objecttype import ObjectType, ObjectTypeOptions
<span class="w"> </span>from .utils import yank_fields_from_attrs
<span class="w"> </span>from .interface import Interface
<span class="gi">+</span>
<span class="gi">+# For static type checking with type checker</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gd">-    from .argument import Argument</span>
<span class="gd">-    from typing import Dict, Type, Callable, Iterable</span>
<span class="gi">+    from .argument import Argument  # NOQA</span>
<span class="gi">+    from typing import Dict, Type, Callable, Iterable  # NOQA</span>


<span class="w"> </span>class MutationOptions(ObjectTypeOptions):
<span class="gd">-    arguments = None</span>
<span class="gd">-    output = None</span>
<span class="gd">-    resolver = None</span>
<span class="gd">-    interfaces = ()</span>
<span class="gi">+    arguments = None  # type: Dict[str, Argument]</span>
<span class="gi">+    output = None  # type: Type[ObjectType]</span>
<span class="gi">+    resolver = None  # type: Callable</span>
<span class="gi">+    interfaces = ()  # type: Iterable[Type[Interface]]</span>


<span class="w"> </span>class Mutation(ObjectType):
<span class="gu">@@ -63,34 +66,46 @@ class Mutation(ObjectType):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @classmethod
<span class="gd">-    def __init_subclass_with_meta__(cls, interfaces=(), resolver=None,</span>
<span class="gd">-        output=None, arguments=None, _meta=None, **options):</span>
<span class="gi">+    def __init_subclass_with_meta__(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        interfaces=(),</span>
<span class="gi">+        resolver=None,</span>
<span class="gi">+        output=None,</span>
<span class="gi">+        arguments=None,</span>
<span class="gi">+        _meta=None,</span>
<span class="gi">+        **options,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        if not _meta:
<span class="w"> </span>            _meta = MutationOptions(cls)
<span class="gd">-        output = output or getattr(cls, &#39;Output&#39;, None)</span>
<span class="gi">+        output = output or getattr(cls, &quot;Output&quot;, None)</span>
<span class="w"> </span>        fields = {}
<span class="gi">+</span>
<span class="w"> </span>        for interface in interfaces:
<span class="gd">-            assert issubclass(interface, Interface</span>
<span class="gd">-                ), f&#39;All interfaces of {cls.__name__} must be a subclass of Interface. Received &quot;{interface}&quot;.&#39;</span>
<span class="gi">+            assert issubclass(</span>
<span class="gi">+                interface, Interface</span>
<span class="gi">+            ), f&#39;All interfaces of {cls.__name__} must be a subclass of Interface. Received &quot;{interface}&quot;.&#39;</span>
<span class="w"> </span>            fields.update(interface._meta.fields)
<span class="w"> </span>        if not output:
<span class="gi">+            # If output is defined, we don&#39;t need to get the fields</span>
<span class="w"> </span>            fields = {}
<span class="w"> </span>            for base in reversed(cls.__mro__):
<span class="w"> </span>                fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
<span class="w"> </span>            output = cls
<span class="w"> </span>        if not arguments:
<span class="gd">-            input_class = getattr(cls, &#39;Arguments&#39;, None)</span>
<span class="gi">+            input_class = getattr(cls, &quot;Arguments&quot;, None)</span>
<span class="w"> </span>            if not input_class:
<span class="gd">-                input_class = getattr(cls, &#39;Input&#39;, None)</span>
<span class="gi">+                input_class = getattr(cls, &quot;Input&quot;, None)</span>
<span class="w"> </span>                if input_class:
<span class="w"> </span>                    warn_deprecation(
<span class="gd">-                        f&quot;&quot;&quot;Please use {cls.__name__}.Arguments instead of {cls.__name__}.Input. Input is now only used in ClientMutationID.</span>
<span class="gd">-Read more: https://github.com/graphql-python/graphene/blob/v2.0.0/UPGRADE-v2.0.md#mutation-input&quot;&quot;&quot;</span>
<span class="gd">-                        )</span>
<span class="gi">+                        f&quot;Please use {cls.__name__}.Arguments instead of {cls.__name__}.Input.&quot;</span>
<span class="gi">+                        &quot; Input is now only used in ClientMutationID.\n&quot;</span>
<span class="gi">+                        &quot;Read more:&quot;</span>
<span class="gi">+                        &quot; https://github.com/graphql-python/graphene/blob/v2.0.0/UPGRADE-v2.0.md#mutation-input&quot;</span>
<span class="gi">+                    )</span>
<span class="w"> </span>            arguments = props(input_class) if input_class else {}
<span class="w"> </span>        if not resolver:
<span class="gd">-            mutate = getattr(cls, &#39;mutate&#39;, None)</span>
<span class="gd">-            assert mutate, &#39;All mutations must define a mutate method in it&#39;</span>
<span class="gi">+            mutate = getattr(cls, &quot;mutate&quot;, None)</span>
<span class="gi">+            assert mutate, &quot;All mutations must define a mutate method in it&quot;</span>
<span class="w"> </span>            resolver = get_unbound_function(mutate)
<span class="w"> </span>        if _meta.fields:
<span class="w"> </span>            _meta.fields.update(fields)
<span class="gu">@@ -100,11 +115,20 @@ Read more: https://github.com/graphql-python/graphene/blob/v2.0.0/UPGRADE-v2.0.m</span>
<span class="w"> </span>        _meta.output = output
<span class="w"> </span>        _meta.resolver = resolver
<span class="w"> </span>        _meta.arguments = arguments
<span class="gd">-        super(Mutation, cls).__init_subclass_with_meta__(_meta=_meta, **options</span>
<span class="gd">-            )</span>
<span class="gi">+</span>
<span class="gi">+        super(Mutation, cls).__init_subclass_with_meta__(_meta=_meta, **options)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def Field(cls, name=None, description=None, deprecation_reason=None,</span>
<span class="gd">-        required=False):</span>
<span class="gi">+    def Field(</span>
<span class="gi">+        cls, name=None, description=None, deprecation_reason=None, required=False</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Mount instance of mutation Field.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Field(</span>
<span class="gi">+            cls._meta.output,</span>
<span class="gi">+            args=cls._meta.arguments,</span>
<span class="gi">+            resolver=cls._meta.resolver,</span>
<span class="gi">+            name=name,</span>
<span class="gi">+            description=description or cls._meta.description,</span>
<span class="gi">+            deprecation_reason=deprecation_reason,</span>
<span class="gi">+            required=required,</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/graphene/types/objecttype.py b/graphene/types/objecttype.py</span>
<span class="gh">index 0f31ada..b3b829f 100644</span>
<span class="gd">--- a/graphene/types/objecttype.py</span>
<span class="gi">+++ b/graphene/types/objecttype.py</span>
<span class="gu">@@ -1,34 +1,48 @@</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from .base import BaseOptions, BaseType, BaseTypeMeta
<span class="w"> </span>from .field import Field
<span class="w"> </span>from .interface import Interface
<span class="w"> </span>from .utils import yank_fields_from_attrs
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from dataclasses import make_dataclass, field
<span class="w"> </span>except ImportError:
<span class="gd">-    from ..pyutils.dataclasses import make_dataclass, field</span>
<span class="gi">+    from ..pyutils.dataclasses import make_dataclass, field  # type: ignore</span>
<span class="gi">+# For static type checking with type checker</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gd">-    from typing import Dict, Iterable, Type</span>
<span class="gi">+    from typing import Dict, Iterable, Type  # NOQA</span>


<span class="w"> </span>class ObjectTypeOptions(BaseOptions):
<span class="gd">-    fields = None</span>
<span class="gd">-    interfaces = ()</span>
<span class="gi">+    fields = None  # type: Dict[str, Field]</span>
<span class="gi">+    interfaces = ()  # type: Iterable[Type[Interface]]</span>


<span class="w"> </span>class ObjectTypeMeta(BaseTypeMeta):
<span class="gd">-</span>
<span class="w"> </span>    def __new__(cls, name_, bases, namespace, **options):
<span class="gi">+        # Note: it&#39;s safe to pass options as keyword arguments as they are still type-checked by ObjectTypeOptions.</span>

<span class="gd">-</span>
<span class="gi">+        # We create this type, to then overload it with the dataclass attrs</span>
<span class="w"> </span>        class InterObjectType:
<span class="w"> </span>            pass
<span class="gd">-        base_cls = super().__new__(cls, name_, (InterObjectType,) + bases,</span>
<span class="gd">-            namespace, **options)</span>
<span class="gi">+</span>
<span class="gi">+        base_cls = super().__new__(</span>
<span class="gi">+            cls, name_, (InterObjectType,) + bases, namespace, **options</span>
<span class="gi">+        )</span>
<span class="w"> </span>        if base_cls._meta:
<span class="gd">-            fields = [(key, &#39;typing.Any&#39;, field(default=field_value.</span>
<span class="gd">-                default_value if isinstance(field_value, Field) else None)) for</span>
<span class="gd">-                key, field_value in base_cls._meta.fields.items()]</span>
<span class="gi">+            fields = [</span>
<span class="gi">+                (</span>
<span class="gi">+                    key,</span>
<span class="gi">+                    &quot;typing.Any&quot;,</span>
<span class="gi">+                    field(</span>
<span class="gi">+                        default=field_value.default_value</span>
<span class="gi">+                        if isinstance(field_value, Field)</span>
<span class="gi">+                        else None</span>
<span class="gi">+                    ),</span>
<span class="gi">+                )</span>
<span class="gi">+                for key, field_value in base_cls._meta.fields.items()</span>
<span class="gi">+            ]</span>
<span class="w"> </span>            dataclass = make_dataclass(name_, fields, bases=())
<span class="w"> </span>            InterObjectType.__init__ = dataclass.__init__
<span class="w"> </span>            InterObjectType.__eq__ = dataclass.__eq__
<span class="gu">@@ -109,19 +123,30 @@ class ObjectType(BaseType, metaclass=ObjectTypeMeta):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @classmethod
<span class="gd">-    def __init_subclass_with_meta__(cls, interfaces=(), possible_types=(),</span>
<span class="gd">-        default_resolver=None, _meta=None, **options):</span>
<span class="gi">+    def __init_subclass_with_meta__(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        interfaces=(),</span>
<span class="gi">+        possible_types=(),</span>
<span class="gi">+        default_resolver=None,</span>
<span class="gi">+        _meta=None,</span>
<span class="gi">+        **options,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        if not _meta:
<span class="w"> </span>            _meta = ObjectTypeOptions(cls)
<span class="w"> </span>        fields = {}
<span class="gi">+</span>
<span class="w"> </span>        for interface in interfaces:
<span class="gd">-            assert issubclass(interface, Interface</span>
<span class="gd">-                ), f&#39;All interfaces of {cls.__name__} must be a subclass of Interface. Received &quot;{interface}&quot;.&#39;</span>
<span class="gi">+            assert issubclass(</span>
<span class="gi">+                interface, Interface</span>
<span class="gi">+            ), f&#39;All interfaces of {cls.__name__} must be a subclass of Interface. Received &quot;{interface}&quot;.&#39;</span>
<span class="w"> </span>            fields.update(interface._meta.fields)
<span class="w"> </span>        for base in reversed(cls.__mro__):
<span class="w"> </span>            fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
<span class="gd">-        assert not (possible_types and cls.is_type_of</span>
<span class="gd">-            ), f&#39;{cls.__name__}.Meta.possible_types will cause type collision with {cls.__name__}.is_type_of. Please use one or other.&#39;</span>
<span class="gi">+        assert not (possible_types and cls.is_type_of), (</span>
<span class="gi">+            f&quot;{cls.__name__}.Meta.possible_types will cause type collision with {cls.__name__}.is_type_of. &quot;</span>
<span class="gi">+            &quot;Please use one or other.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        if _meta.fields:
<span class="w"> </span>            _meta.fields.update(fields)
<span class="w"> </span>        else:
<span class="gu">@@ -130,6 +155,7 @@ class ObjectType(BaseType, metaclass=ObjectTypeMeta):</span>
<span class="w"> </span>            _meta.interfaces = interfaces
<span class="w"> </span>        _meta.possible_types = possible_types
<span class="w"> </span>        _meta.default_resolver = default_resolver
<span class="gd">-        super(ObjectType, cls).__init_subclass_with_meta__(_meta=_meta, **</span>
<span class="gd">-            options)</span>
<span class="gi">+</span>
<span class="gi">+        super(ObjectType, cls).__init_subclass_with_meta__(_meta=_meta, **options)</span>
<span class="gi">+</span>
<span class="w"> </span>    is_type_of = None
<span class="gh">diff --git a/graphene/types/resolver.py b/graphene/types/resolver.py</span>
<span class="gh">index f9a1c6e..72d2edb 100644</span>
<span class="gd">--- a/graphene/types/resolver.py</span>
<span class="gi">+++ b/graphene/types/resolver.py</span>
<span class="gu">@@ -1 +1,24 @@</span>
<span class="gi">+def attr_resolver(attname, default_value, root, info, **args):</span>
<span class="gi">+    return getattr(root, attname, default_value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def dict_resolver(attname, default_value, root, info, **args):</span>
<span class="gi">+    return root.get(attname, default_value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def dict_or_attr_resolver(attname, default_value, root, info, **args):</span>
<span class="gi">+    resolver = dict_resolver if isinstance(root, dict) else attr_resolver</span>
<span class="gi">+    return resolver(attname, default_value, root, info, **args)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>default_resolver = dict_or_attr_resolver
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def set_default_resolver(resolver):</span>
<span class="gi">+    global default_resolver</span>
<span class="gi">+    assert callable(resolver), &quot;Received non-callable resolver.&quot;</span>
<span class="gi">+    default_resolver = resolver</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_default_resolver():</span>
<span class="gi">+    return default_resolver</span>
<span class="gh">diff --git a/graphene/types/scalars.py b/graphene/types/scalars.py</span>
<span class="gh">index b1a7427..a468bb3 100644</span>
<span class="gd">--- a/graphene/types/scalars.py</span>
<span class="gi">+++ b/graphene/types/scalars.py</span>
<span class="gu">@@ -1,6 +1,13 @@</span>
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>from graphql import Undefined
<span class="gd">-from graphql.language.ast import BooleanValueNode, FloatValueNode, IntValueNode, StringValueNode</span>
<span class="gi">+from graphql.language.ast import (</span>
<span class="gi">+    BooleanValueNode,</span>
<span class="gi">+    FloatValueNode,</span>
<span class="gi">+    IntValueNode,</span>
<span class="gi">+    StringValueNode,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from .base import BaseOptions, BaseType
<span class="w"> </span>from .unmountedtype import UnmountedType

<span class="gu">@@ -22,6 +29,7 @@ class Scalar(UnmountedType, BaseType):</span>
<span class="w"> </span>    def __init_subclass_with_meta__(cls, **options):
<span class="w"> </span>        _meta = ScalarOptions(cls)
<span class="w"> </span>        super(Scalar, cls).__init_subclass_with_meta__(_meta=_meta, **options)
<span class="gi">+</span>
<span class="w"> </span>    serialize = None
<span class="w"> </span>    parse_value = None
<span class="w"> </span>    parse_literal = None
<span class="gu">@@ -32,9 +40,14 @@ class Scalar(UnmountedType, BaseType):</span>
<span class="w"> </span>        This function is called when the unmounted type (Scalar instance)
<span class="w"> </span>        is mounted (as a Field, InputField or Argument)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls</span>


<span class="gi">+# As per the GraphQL Spec, Integers are only treated as valid when a valid</span>
<span class="gi">+# 32-bit signed integer, providing the broadest support across platforms.</span>
<span class="gi">+#</span>
<span class="gi">+# n.b. JavaScript&#39;s integers are safe between -(2^53 - 1) and 2^53 - 1 because</span>
<span class="gi">+# they are internally represented as IEEE 754 doubles.</span>
<span class="w"> </span>MAX_INT = 2147483647
<span class="w"> </span>MIN_INT = -2147483648

<span class="gu">@@ -46,9 +59,31 @@ class Int(Scalar):</span>
<span class="w"> </span>    represented in JSON as double-precision floating point numbers specified
<span class="w"> </span>    by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def coerce_int(value):</span>
<span class="gi">+        try:</span>
<span class="gi">+            num = int(value)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            try:</span>
<span class="gi">+                num = int(float(value))</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                return Undefined</span>
<span class="gi">+        if MIN_INT &lt;= num &lt;= MAX_INT:</span>
<span class="gi">+            return num</span>
<span class="gi">+        return Undefined</span>
<span class="gi">+</span>
<span class="w"> </span>    serialize = coerce_int
<span class="w"> </span>    parse_value = coerce_int

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_literal(ast, _variables=None):</span>
<span class="gi">+        if isinstance(ast, IntValueNode):</span>
<span class="gi">+            num = int(ast.value)</span>
<span class="gi">+            if MIN_INT &lt;= num &lt;= MAX_INT:</span>
<span class="gi">+                return num</span>
<span class="gi">+        return Undefined</span>
<span class="gi">+</span>

<span class="w"> </span>class BigInt(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -56,9 +91,27 @@ class BigInt(Scalar):</span>
<span class="w"> </span>    `BigInt` is not constrained to 32-bit like the `Int` type and thus is a less
<span class="w"> </span>    compatible type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def coerce_int(value):</span>
<span class="gi">+        try:</span>
<span class="gi">+            num = int(value)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            try:</span>
<span class="gi">+                num = int(float(value))</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                return Undefined</span>
<span class="gi">+        return num</span>
<span class="gi">+</span>
<span class="w"> </span>    serialize = coerce_int
<span class="w"> </span>    parse_value = coerce_int

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_literal(ast, _variables=None):</span>
<span class="gi">+        if isinstance(ast, IntValueNode):</span>
<span class="gi">+            return int(ast.value)</span>
<span class="gi">+        return Undefined</span>
<span class="gi">+</span>

<span class="w"> </span>class Float(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -66,9 +119,24 @@ class Float(Scalar):</span>
<span class="w"> </span>    values as specified by
<span class="w"> </span>    [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def coerce_float(value):</span>
<span class="gi">+        # type: (Any) -&gt; float</span>
<span class="gi">+        try:</span>
<span class="gi">+            return float(value)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            return Undefined</span>
<span class="gi">+</span>
<span class="w"> </span>    serialize = coerce_float
<span class="w"> </span>    parse_value = coerce_float

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_literal(ast, _variables=None):</span>
<span class="gi">+        if isinstance(ast, (FloatValueNode, IntValueNode)):</span>
<span class="gi">+            return float(ast.value)</span>
<span class="gi">+        return Undefined</span>
<span class="gi">+</span>

<span class="w"> </span>class String(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -76,17 +144,37 @@ class String(Scalar):</span>
<span class="w"> </span>    character sequences. The String type is most often used by GraphQL to
<span class="w"> </span>    represent free-form human-readable text.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def coerce_string(value):</span>
<span class="gi">+        if isinstance(value, bool):</span>
<span class="gi">+            return &quot;true&quot; if value else &quot;false&quot;</span>
<span class="gi">+        return str(value)</span>
<span class="gi">+</span>
<span class="w"> </span>    serialize = coerce_string
<span class="w"> </span>    parse_value = coerce_string

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_literal(ast, _variables=None):</span>
<span class="gi">+        if isinstance(ast, StringValueNode):</span>
<span class="gi">+            return ast.value</span>
<span class="gi">+        return Undefined</span>
<span class="gi">+</span>

<span class="w"> </span>class Boolean(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The `Boolean` scalar type represents `true` or `false`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    serialize = bool
<span class="w"> </span>    parse_value = bool

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_literal(ast, _variables=None):</span>
<span class="gi">+        if isinstance(ast, BooleanValueNode):</span>
<span class="gi">+            return ast.value</span>
<span class="gi">+        return Undefined</span>
<span class="gi">+</span>

<span class="w"> </span>class ID(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -96,5 +184,12 @@ class ID(Scalar):</span>
<span class="w"> </span>    When expected as an input type, any string (such as `&quot;4&quot;`) or integer
<span class="w"> </span>    (such as `4`) input value will be accepted as an ID.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    serialize = str
<span class="w"> </span>    parse_value = str
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_literal(ast, _variables=None):</span>
<span class="gi">+        if isinstance(ast, (StringValueNode, IntValueNode)):</span>
<span class="gi">+            return ast.value</span>
<span class="gi">+        return Undefined</span>
<span class="gh">diff --git a/graphene/types/schema.py b/graphene/types/schema.py</span>
<span class="gh">index 1227a4c..bceede6 100644</span>
<span class="gd">--- a/graphene/types/schema.py</span>
<span class="gi">+++ b/graphene/types/schema.py</span>
<span class="gu">@@ -1,10 +1,45 @@</span>
<span class="w"> </span>from enum import Enum as PyEnum
<span class="w"> </span>import inspect
<span class="w"> </span>from functools import partial
<span class="gd">-from graphql import default_type_resolver, get_introspection_query, graphql, graphql_sync, introspection_types, parse, print_schema, subscribe, validate, ExecutionResult, GraphQLArgument, GraphQLBoolean, GraphQLError, GraphQLEnumValue, GraphQLField, GraphQLFloat, GraphQLID, GraphQLInputField, GraphQLInt, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLSchema, GraphQLString</span>
<span class="gi">+</span>
<span class="gi">+from graphql import (</span>
<span class="gi">+    default_type_resolver,</span>
<span class="gi">+    get_introspection_query,</span>
<span class="gi">+    graphql,</span>
<span class="gi">+    graphql_sync,</span>
<span class="gi">+    introspection_types,</span>
<span class="gi">+    parse,</span>
<span class="gi">+    print_schema,</span>
<span class="gi">+    subscribe,</span>
<span class="gi">+    validate,</span>
<span class="gi">+    ExecutionResult,</span>
<span class="gi">+    GraphQLArgument,</span>
<span class="gi">+    GraphQLBoolean,</span>
<span class="gi">+    GraphQLError,</span>
<span class="gi">+    GraphQLEnumValue,</span>
<span class="gi">+    GraphQLField,</span>
<span class="gi">+    GraphQLFloat,</span>
<span class="gi">+    GraphQLID,</span>
<span class="gi">+    GraphQLInputField,</span>
<span class="gi">+    GraphQLInt,</span>
<span class="gi">+    GraphQLList,</span>
<span class="gi">+    GraphQLNonNull,</span>
<span class="gi">+    GraphQLObjectType,</span>
<span class="gi">+    GraphQLSchema,</span>
<span class="gi">+    GraphQLString,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from ..utils.str_converters import to_camel_case
<span class="w"> </span>from ..utils.get_unbound_function import get_unbound_function
<span class="gd">-from .definitions import GrapheneEnumType, GrapheneGraphQLType, GrapheneInputObjectType, GrapheneInterfaceType, GrapheneObjectType, GrapheneScalarType, GrapheneUnionType</span>
<span class="gi">+from .definitions import (</span>
<span class="gi">+    GrapheneEnumType,</span>
<span class="gi">+    GrapheneGraphQLType,</span>
<span class="gi">+    GrapheneInputObjectType,</span>
<span class="gi">+    GrapheneInterfaceType,</span>
<span class="gi">+    GrapheneObjectType,</span>
<span class="gi">+    GrapheneScalarType,</span>
<span class="gi">+    GrapheneUnionType,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .dynamic import Dynamic
<span class="w"> </span>from .enum import Enum
<span class="w"> </span>from .field import Field
<span class="gu">@@ -16,14 +51,48 @@ from .scalars import ID, Boolean, Float, Int, Scalar, String</span>
<span class="w"> </span>from .structures import List, NonNull
<span class="w"> </span>from .union import Union
<span class="w"> </span>from .utils import get_field_as
<span class="gi">+</span>
<span class="w"> </span>introspection_query = get_introspection_query()
<span class="gd">-IntrospectionSchema = introspection_types[&#39;__Schema&#39;]</span>
<span class="gi">+IntrospectionSchema = introspection_types[&quot;__Schema&quot;]</span>


<span class="gd">-class TypeMap(dict):</span>
<span class="gi">+def assert_valid_root_type(type_):</span>
<span class="gi">+    if type_ is None:</span>
<span class="gi">+        return</span>
<span class="gi">+    is_graphene_objecttype = inspect.isclass(type_) and issubclass(type_, ObjectType)</span>
<span class="gi">+    is_graphql_objecttype = isinstance(type_, GraphQLObjectType)</span>
<span class="gi">+    assert (</span>
<span class="gi">+        is_graphene_objecttype or is_graphql_objecttype</span>
<span class="gi">+    ), f&quot;Type {type_} is not a valid ObjectType.&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_graphene_type(type_):</span>
<span class="gi">+    if isinstance(type_, (List, NonNull)):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if inspect.isclass(type_) and issubclass(</span>
<span class="gi">+        type_, (ObjectType, InputObjectType, Scalar, Interface, Union, Enum)</span>
<span class="gi">+    ):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>

<span class="gd">-    def __init__(self, query=None, mutation=None, subscription=None, types=</span>
<span class="gd">-        None, auto_camelcase=True):</span>
<span class="gi">+def is_type_of_from_possible_types(possible_types, root, _info):</span>
<span class="gi">+    return isinstance(root, possible_types)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# We use this resolver for subscriptions</span>
<span class="gi">+def identity_resolve(root, info, **arguments):</span>
<span class="gi">+    return root</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class TypeMap(dict):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        query=None,</span>
<span class="gi">+        mutation=None,</span>
<span class="gi">+        subscription=None,</span>
<span class="gi">+        types=None,</span>
<span class="gi">+        auto_camelcase=True,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        assert_valid_root_type(query)
<span class="w"> </span>        assert_valid_root_type(mutation)
<span class="w"> </span>        assert_valid_root_type(subscription)
<span class="gu">@@ -31,19 +100,305 @@ class TypeMap(dict):</span>
<span class="w"> </span>            types = []
<span class="w"> </span>        for type_ in types:
<span class="w"> </span>            assert is_graphene_type(type_)
<span class="gi">+</span>
<span class="w"> </span>        self.auto_camelcase = auto_camelcase
<span class="gi">+</span>
<span class="w"> </span>        create_graphql_type = self.add_type
<span class="gi">+</span>
<span class="w"> </span>        self.query = create_graphql_type(query) if query else None
<span class="w"> </span>        self.mutation = create_graphql_type(mutation) if mutation else None
<span class="gd">-        self.subscription = create_graphql_type(subscription</span>
<span class="gd">-            ) if subscription else None</span>
<span class="gd">-        self.types = [create_graphql_type(graphene_type) for graphene_type in</span>
<span class="gd">-            types]</span>
<span class="gi">+        self.subscription = create_graphql_type(subscription) if subscription else None</span>
<span class="gi">+</span>
<span class="gi">+        self.types = [create_graphql_type(graphene_type) for graphene_type in types]</span>
<span class="gi">+</span>
<span class="gi">+    def add_type(self, graphene_type):</span>
<span class="gi">+        if inspect.isfunction(graphene_type):</span>
<span class="gi">+            graphene_type = graphene_type()</span>
<span class="gi">+        if isinstance(graphene_type, List):</span>
<span class="gi">+            return GraphQLList(self.add_type(graphene_type.of_type))</span>
<span class="gi">+        if isinstance(graphene_type, NonNull):</span>
<span class="gi">+            return GraphQLNonNull(self.add_type(graphene_type.of_type))</span>
<span class="gi">+        try:</span>
<span class="gi">+            name = graphene_type._meta.name</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            raise TypeError(f&quot;Expected Graphene type, but received: {graphene_type}.&quot;)</span>
<span class="gi">+        graphql_type = self.get(name)</span>
<span class="gi">+        if graphql_type:</span>
<span class="gi">+            return graphql_type</span>
<span class="gi">+        if issubclass(graphene_type, ObjectType):</span>
<span class="gi">+            graphql_type = self.create_objecttype(graphene_type)</span>
<span class="gi">+        elif issubclass(graphene_type, InputObjectType):</span>
<span class="gi">+            graphql_type = self.create_inputobjecttype(graphene_type)</span>
<span class="gi">+        elif issubclass(graphene_type, Interface):</span>
<span class="gi">+            graphql_type = self.create_interface(graphene_type)</span>
<span class="gi">+        elif issubclass(graphene_type, Scalar):</span>
<span class="gi">+            graphql_type = self.create_scalar(graphene_type)</span>
<span class="gi">+        elif issubclass(graphene_type, Enum):</span>
<span class="gi">+            graphql_type = self.create_enum(graphene_type)</span>
<span class="gi">+        elif issubclass(graphene_type, Union):</span>
<span class="gi">+            graphql_type = self.construct_union(graphene_type)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(f&quot;Expected Graphene type, but received: {graphene_type}.&quot;)</span>
<span class="gi">+        self[name] = graphql_type</span>
<span class="gi">+        return graphql_type</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def create_scalar(graphene_type):</span>
<span class="gi">+        # We have a mapping to the original GraphQL types</span>
<span class="gi">+        # so there are no collisions.</span>
<span class="gi">+        _scalars = {</span>
<span class="gi">+            String: GraphQLString,</span>
<span class="gi">+            Int: GraphQLInt,</span>
<span class="gi">+            Float: GraphQLFloat,</span>
<span class="gi">+            Boolean: GraphQLBoolean,</span>
<span class="gi">+            ID: GraphQLID,</span>
<span class="gi">+        }</span>
<span class="gi">+        if graphene_type in _scalars:</span>
<span class="gi">+            return _scalars[graphene_type]</span>
<span class="gi">+</span>
<span class="gi">+        return GrapheneScalarType(</span>
<span class="gi">+            graphene_type=graphene_type,</span>
<span class="gi">+            name=graphene_type._meta.name,</span>
<span class="gi">+            description=graphene_type._meta.description,</span>
<span class="gi">+            serialize=getattr(graphene_type, &quot;serialize&quot;, None),</span>
<span class="gi">+            parse_value=getattr(graphene_type, &quot;parse_value&quot;, None),</span>
<span class="gi">+            parse_literal=getattr(graphene_type, &quot;parse_literal&quot;, None),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def create_enum(graphene_type):</span>
<span class="gi">+        values = {}</span>
<span class="gi">+        for name, value in graphene_type._meta.enum.__members__.items():</span>
<span class="gi">+            description = getattr(value, &quot;description&quot;, None)</span>
<span class="gi">+            # if the &quot;description&quot; attribute is an Enum, it is likely an enum member</span>
<span class="gi">+            # called description, not a description property</span>
<span class="gi">+            if isinstance(description, PyEnum):</span>
<span class="gi">+                description = None</span>
<span class="gi">+            if not description and callable(graphene_type._meta.description):</span>
<span class="gi">+                description = graphene_type._meta.description(value)</span>
<span class="gi">+</span>
<span class="gi">+            deprecation_reason = getattr(value, &quot;deprecation_reason&quot;, None)</span>
<span class="gi">+            if isinstance(deprecation_reason, PyEnum):</span>
<span class="gi">+                deprecation_reason = None</span>
<span class="gi">+            if not deprecation_reason and callable(</span>
<span class="gi">+                graphene_type._meta.deprecation_reason</span>
<span class="gi">+            ):</span>
<span class="gi">+                deprecation_reason = graphene_type._meta.deprecation_reason(value)</span>
<span class="gi">+</span>
<span class="gi">+            values[name] = GraphQLEnumValue(</span>
<span class="gi">+                value=value,</span>
<span class="gi">+                description=description,</span>
<span class="gi">+                deprecation_reason=deprecation_reason,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        type_description = (</span>
<span class="gi">+            graphene_type._meta.description(None)</span>
<span class="gi">+            if callable(graphene_type._meta.description)</span>
<span class="gi">+            else graphene_type._meta.description</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return GrapheneEnumType(</span>
<span class="gi">+            graphene_type=graphene_type,</span>
<span class="gi">+            values=values,</span>
<span class="gi">+            name=graphene_type._meta.name,</span>
<span class="gi">+            description=type_description,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def create_objecttype(self, graphene_type):</span>
<span class="gi">+        create_graphql_type = self.add_type</span>
<span class="gi">+</span>
<span class="gi">+        def interfaces():</span>
<span class="gi">+            interfaces = []</span>
<span class="gi">+            for graphene_interface in graphene_type._meta.interfaces:</span>
<span class="gi">+                interface = create_graphql_type(graphene_interface)</span>
<span class="gi">+                assert interface.graphene_type == graphene_interface</span>
<span class="gi">+                interfaces.append(interface)</span>
<span class="gi">+            return interfaces</span>

<span class="gd">-    def get_function_for_type(self, graphene_type, func_name, name,</span>
<span class="gd">-        default_value):</span>
<span class="gi">+        if graphene_type._meta.possible_types:</span>
<span class="gi">+            is_type_of = partial(</span>
<span class="gi">+                is_type_of_from_possible_types, graphene_type._meta.possible_types</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            is_type_of = graphene_type.is_type_of</span>
<span class="gi">+</span>
<span class="gi">+        return GrapheneObjectType(</span>
<span class="gi">+            graphene_type=graphene_type,</span>
<span class="gi">+            name=graphene_type._meta.name,</span>
<span class="gi">+            description=graphene_type._meta.description,</span>
<span class="gi">+            fields=partial(self.create_fields_for_type, graphene_type),</span>
<span class="gi">+            is_type_of=is_type_of,</span>
<span class="gi">+            interfaces=interfaces,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def create_interface(self, graphene_type):</span>
<span class="gi">+        resolve_type = (</span>
<span class="gi">+            partial(</span>
<span class="gi">+                self.resolve_type, graphene_type.resolve_type, graphene_type._meta.name</span>
<span class="gi">+            )</span>
<span class="gi">+            if graphene_type.resolve_type</span>
<span class="gi">+            else None</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        def interfaces():</span>
<span class="gi">+            interfaces = []</span>
<span class="gi">+            for graphene_interface in graphene_type._meta.interfaces:</span>
<span class="gi">+                interface = self.add_type(graphene_interface)</span>
<span class="gi">+                assert interface.graphene_type == graphene_interface</span>
<span class="gi">+                interfaces.append(interface)</span>
<span class="gi">+            return interfaces</span>
<span class="gi">+</span>
<span class="gi">+        return GrapheneInterfaceType(</span>
<span class="gi">+            graphene_type=graphene_type,</span>
<span class="gi">+            name=graphene_type._meta.name,</span>
<span class="gi">+            description=graphene_type._meta.description,</span>
<span class="gi">+            fields=partial(self.create_fields_for_type, graphene_type),</span>
<span class="gi">+            interfaces=interfaces,</span>
<span class="gi">+            resolve_type=resolve_type,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def create_inputobjecttype(self, graphene_type):</span>
<span class="gi">+        return GrapheneInputObjectType(</span>
<span class="gi">+            graphene_type=graphene_type,</span>
<span class="gi">+            name=graphene_type._meta.name,</span>
<span class="gi">+            description=graphene_type._meta.description,</span>
<span class="gi">+            out_type=graphene_type._meta.container,</span>
<span class="gi">+            fields=partial(</span>
<span class="gi">+                self.create_fields_for_type, graphene_type, is_input_type=True</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def construct_union(self, graphene_type):</span>
<span class="gi">+        create_graphql_type = self.add_type</span>
<span class="gi">+</span>
<span class="gi">+        def types():</span>
<span class="gi">+            union_types = []</span>
<span class="gi">+            for graphene_objecttype in graphene_type._meta.types:</span>
<span class="gi">+                object_type = create_graphql_type(graphene_objecttype)</span>
<span class="gi">+                assert object_type.graphene_type == graphene_objecttype</span>
<span class="gi">+                union_types.append(object_type)</span>
<span class="gi">+            return union_types</span>
<span class="gi">+</span>
<span class="gi">+        resolve_type = (</span>
<span class="gi">+            partial(</span>
<span class="gi">+                self.resolve_type, graphene_type.resolve_type, graphene_type._meta.name</span>
<span class="gi">+            )</span>
<span class="gi">+            if graphene_type.resolve_type</span>
<span class="gi">+            else None</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return GrapheneUnionType(</span>
<span class="gi">+            graphene_type=graphene_type,</span>
<span class="gi">+            name=graphene_type._meta.name,</span>
<span class="gi">+            description=graphene_type._meta.description,</span>
<span class="gi">+            types=types,</span>
<span class="gi">+            resolve_type=resolve_type,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_name(self, name):</span>
<span class="gi">+        if self.auto_camelcase:</span>
<span class="gi">+            return to_camel_case(name)</span>
<span class="gi">+        return name</span>
<span class="gi">+</span>
<span class="gi">+    def create_fields_for_type(self, graphene_type, is_input_type=False):</span>
<span class="gi">+        create_graphql_type = self.add_type</span>
<span class="gi">+</span>
<span class="gi">+        fields = {}</span>
<span class="gi">+        for name, field in graphene_type._meta.fields.items():</span>
<span class="gi">+            if isinstance(field, Dynamic):</span>
<span class="gi">+                field = get_field_as(field.get_type(self), _as=Field)</span>
<span class="gi">+                if not field:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            field_type = create_graphql_type(field.type)</span>
<span class="gi">+            if is_input_type:</span>
<span class="gi">+                _field = GraphQLInputField(</span>
<span class="gi">+                    field_type,</span>
<span class="gi">+                    default_value=field.default_value,</span>
<span class="gi">+                    out_name=name,</span>
<span class="gi">+                    description=field.description,</span>
<span class="gi">+                    deprecation_reason=field.deprecation_reason,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                args = {}</span>
<span class="gi">+                for arg_name, arg in field.args.items():</span>
<span class="gi">+                    arg_type = create_graphql_type(arg.type)</span>
<span class="gi">+                    processed_arg_name = arg.name or self.get_name(arg_name)</span>
<span class="gi">+                    args[processed_arg_name] = GraphQLArgument(</span>
<span class="gi">+                        arg_type,</span>
<span class="gi">+                        out_name=arg_name,</span>
<span class="gi">+                        description=arg.description,</span>
<span class="gi">+                        default_value=arg.default_value,</span>
<span class="gi">+                        deprecation_reason=arg.deprecation_reason,</span>
<span class="gi">+                    )</span>
<span class="gi">+                subscribe = field.wrap_subscribe(</span>
<span class="gi">+                    self.get_function_for_type(</span>
<span class="gi">+                        graphene_type, f&quot;subscribe_{name}&quot;, name, field.default_value</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                # If we are in a subscription, we use (by default) an</span>
<span class="gi">+                # identity-based resolver for the root, rather than the</span>
<span class="gi">+                # default resolver for objects/dicts.</span>
<span class="gi">+                if subscribe:</span>
<span class="gi">+                    field_default_resolver = identity_resolve</span>
<span class="gi">+                elif issubclass(graphene_type, ObjectType):</span>
<span class="gi">+                    default_resolver = (</span>
<span class="gi">+                        graphene_type._meta.default_resolver or get_default_resolver()</span>
<span class="gi">+                    )</span>
<span class="gi">+                    field_default_resolver = partial(</span>
<span class="gi">+                        default_resolver, name, field.default_value</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    field_default_resolver = None</span>
<span class="gi">+</span>
<span class="gi">+                resolve = field.wrap_resolve(</span>
<span class="gi">+                    self.get_function_for_type(</span>
<span class="gi">+                        graphene_type, f&quot;resolve_{name}&quot;, name, field.default_value</span>
<span class="gi">+                    )</span>
<span class="gi">+                    or field_default_resolver</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                _field = GraphQLField(</span>
<span class="gi">+                    field_type,</span>
<span class="gi">+                    args=args,</span>
<span class="gi">+                    resolve=resolve,</span>
<span class="gi">+                    subscribe=subscribe,</span>
<span class="gi">+                    deprecation_reason=field.deprecation_reason,</span>
<span class="gi">+                    description=field.description,</span>
<span class="gi">+                )</span>
<span class="gi">+            field_name = field.name or self.get_name(name)</span>
<span class="gi">+            fields[field_name] = _field</span>
<span class="gi">+        return fields</span>
<span class="gi">+</span>
<span class="gi">+    def get_function_for_type(self, graphene_type, func_name, name, default_value):</span>
<span class="w"> </span>        &quot;&quot;&quot;Gets a resolve or subscribe function for a given ObjectType&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not issubclass(graphene_type, ObjectType):</span>
<span class="gi">+            return</span>
<span class="gi">+        resolver = getattr(graphene_type, func_name, None)</span>
<span class="gi">+        if not resolver:</span>
<span class="gi">+            # If we don&#39;t find the resolver in the ObjectType class, then try to</span>
<span class="gi">+            # find it in each of the interfaces</span>
<span class="gi">+            interface_resolver = None</span>
<span class="gi">+            for interface in graphene_type._meta.interfaces:</span>
<span class="gi">+                if name not in interface._meta.fields:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                interface_resolver = getattr(interface, func_name, None)</span>
<span class="gi">+                if interface_resolver:</span>
<span class="gi">+                    break</span>
<span class="gi">+            resolver = interface_resolver</span>
<span class="gi">+</span>
<span class="gi">+        # Only if is not decorated with classmethod</span>
<span class="gi">+        if resolver:</span>
<span class="gi">+            return get_unbound_function(resolver)</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_type(self, resolve_type_func, type_name, root, info, _type):</span>
<span class="gi">+        type_ = resolve_type_func(root, info)</span>
<span class="gi">+</span>
<span class="gi">+        if inspect.isclass(type_) and issubclass(type_, ObjectType):</span>
<span class="gi">+            return type_._meta.name</span>
<span class="gi">+</span>
<span class="gi">+        return_type = self[type_name]</span>
<span class="gi">+        return default_type_resolver(root, info, return_type)</span>


<span class="w"> </span>class Schema:
<span class="gu">@@ -67,15 +422,28 @@ class Schema:</span>
<span class="w"> </span>            to camelCase (preferred by GraphQL standard). Default True.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, query=None, mutation=None, subscription=None, types=</span>
<span class="gd">-        None, directives=None, auto_camelcase=True):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        query=None,</span>
<span class="gi">+        mutation=None,</span>
<span class="gi">+        subscription=None,</span>
<span class="gi">+        types=None,</span>
<span class="gi">+        directives=None,</span>
<span class="gi">+        auto_camelcase=True,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.query = query
<span class="w"> </span>        self.mutation = mutation
<span class="w"> </span>        self.subscription = subscription
<span class="gd">-        type_map = TypeMap(query, mutation, subscription, types,</span>
<span class="gd">-            auto_camelcase=auto_camelcase)</span>
<span class="gd">-        self.graphql_schema = GraphQLSchema(type_map.query, type_map.</span>
<span class="gd">-            mutation, type_map.subscription, type_map.types, directives)</span>
<span class="gi">+        type_map = TypeMap(</span>
<span class="gi">+            query, mutation, subscription, types, auto_camelcase=auto_camelcase</span>
<span class="gi">+        )</span>
<span class="gi">+        self.graphql_schema = GraphQLSchema(</span>
<span class="gi">+            type_map.query,</span>
<span class="gi">+            type_map.mutation,</span>
<span class="gi">+            type_map.subscription,</span>
<span class="gi">+            type_map.types,</span>
<span class="gi">+            directives,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return print_schema(self.graphql_schema)
<span class="gu">@@ -93,6 +461,9 @@ class Schema:</span>
<span class="w"> </span>            return _type.graphene_type
<span class="w"> </span>        return _type

<span class="gi">+    def lazy(self, _type):</span>
<span class="gi">+        return lambda: self.get_type(_type)</span>
<span class="gi">+</span>
<span class="w"> </span>    def execute(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Execute a GraphQL query on the schema.
<span class="w"> </span>        Use the `graphql_sync` function from `graphql-core` to provide the result
<span class="gu">@@ -117,19 +488,48 @@ class Schema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            :obj:`ExecutionResult` containing any data and errors for the operation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs = normalize_execute_kwargs(kwargs)</span>
<span class="gi">+        return graphql_sync(self.graphql_schema, *args, **kwargs)</span>

<span class="w"> </span>    async def execute_async(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Execute a GraphQL query on the schema asynchronously.
<span class="w"> </span>        Same as `execute`, but uses `graphql` instead of `graphql_sync`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs = normalize_execute_kwargs(kwargs)</span>
<span class="gi">+        return await graphql(self.graphql_schema, *args, **kwargs)</span>

<span class="w"> </span>    async def subscribe(self, query, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Execute a GraphQL subscription on the schema asynchronously.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Do parsing</span>
<span class="gi">+        try:</span>
<span class="gi">+            document = parse(query)</span>
<span class="gi">+        except GraphQLError as error:</span>
<span class="gi">+            return ExecutionResult(data=None, errors=[error])</span>
<span class="gi">+</span>
<span class="gi">+        # Do validation</span>
<span class="gi">+        validation_errors = validate(self.graphql_schema, document)</span>
<span class="gi">+        if validation_errors:</span>
<span class="gi">+            return ExecutionResult(data=None, errors=validation_errors)</span>
<span class="gi">+</span>
<span class="gi">+        # Execute the query</span>
<span class="gi">+        kwargs = normalize_execute_kwargs(kwargs)</span>
<span class="gi">+        return await subscribe(self.graphql_schema, document, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def introspect(self):</span>
<span class="gi">+        introspection = self.execute(introspection_query)</span>
<span class="gi">+        if introspection.errors:</span>
<span class="gi">+            raise introspection.errors[0]</span>
<span class="gi">+        return introspection.data</span>


<span class="w"> </span>def normalize_execute_kwargs(kwargs):
<span class="w"> </span>    &quot;&quot;&quot;Replace alias names in keyword arguments for graphql()&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &quot;root&quot; in kwargs and &quot;root_value&quot; not in kwargs:</span>
<span class="gi">+        kwargs[&quot;root_value&quot;] = kwargs.pop(&quot;root&quot;)</span>
<span class="gi">+    if &quot;context&quot; in kwargs and &quot;context_value&quot; not in kwargs:</span>
<span class="gi">+        kwargs[&quot;context_value&quot;] = kwargs.pop(&quot;context&quot;)</span>
<span class="gi">+    if &quot;variables&quot; in kwargs and &quot;variable_values&quot; not in kwargs:</span>
<span class="gi">+        kwargs[&quot;variable_values&quot;] = kwargs.pop(&quot;variables&quot;)</span>
<span class="gi">+    if &quot;operation&quot; in kwargs and &quot;operation_name&quot; not in kwargs:</span>
<span class="gi">+        kwargs[&quot;operation_name&quot;] = kwargs.pop(&quot;operation&quot;)</span>
<span class="gi">+    return kwargs</span>
<span class="gh">diff --git a/graphene/types/structures.py b/graphene/types/structures.py</span>
<span class="gh">index 155e1c0..a676397 100644</span>
<span class="gd">--- a/graphene/types/structures.py</span>
<span class="gi">+++ b/graphene/types/structures.py</span>
<span class="gu">@@ -10,21 +10,25 @@ class Structure(UnmountedType):</span>

<span class="w"> </span>    def __init__(self, of_type, *args, **kwargs):
<span class="w"> </span>        super(Structure, self).__init__(*args, **kwargs)
<span class="gd">-        if not isinstance(of_type, Structure) and isinstance(of_type,</span>
<span class="gd">-            UnmountedType):</span>
<span class="gi">+        if not isinstance(of_type, Structure) and isinstance(of_type, UnmountedType):</span>
<span class="w"> </span>            cls_name = type(self).__name__
<span class="w"> </span>            of_type_name = type(of_type).__name__
<span class="w"> </span>            raise Exception(
<span class="gd">-                f&#39;{cls_name} could not have a mounted {of_type_name}() as inner type. Try with {cls_name}({of_type_name}).&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                f&quot;{cls_name} could not have a mounted {of_type_name}()&quot;</span>
<span class="gi">+                f&quot; as inner type. Try with {cls_name}({of_type_name}).&quot;</span>
<span class="gi">+            )</span>
<span class="w"> </span>        self._of_type = of_type

<span class="gi">+    @property</span>
<span class="gi">+    def of_type(self):</span>
<span class="gi">+        return get_type(self._of_type)</span>
<span class="gi">+</span>
<span class="w"> </span>    def get_type(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        This function is called when the unmounted type (List or NonNull instance)
<span class="w"> </span>        is mounted (as a Field, InputField or Argument)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class List(Structure):
<span class="gu">@@ -45,11 +49,14 @@ class List(Structure):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __str__(self):
<span class="gd">-        return f&#39;[{self.of_type}]&#39;</span>
<span class="gi">+        return f&quot;[{self.of_type}]&quot;</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="gd">-        return isinstance(other, List) and (self.of_type == other.of_type and</span>
<span class="gd">-            self.args == other.args and self.kwargs == other.kwargs)</span>
<span class="gi">+        return isinstance(other, List) and (</span>
<span class="gi">+            self.of_type == other.of_type</span>
<span class="gi">+            and self.args == other.args</span>
<span class="gi">+            and self.kwargs == other.kwargs</span>
<span class="gi">+        )</span>


<span class="w"> </span>class NonNull(Structure):
<span class="gu">@@ -77,13 +84,16 @@ class NonNull(Structure):</span>

<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="w"> </span>        super(NonNull, self).__init__(*args, **kwargs)
<span class="gd">-        assert not isinstance(self._of_type, NonNull</span>
<span class="gd">-            ), f&#39;Can only create NonNull of a Nullable GraphQLType but got: {self._of_type}.&#39;</span>
<span class="gi">+        assert not isinstance(</span>
<span class="gi">+            self._of_type, NonNull</span>
<span class="gi">+        ), f&quot;Can only create NonNull of a Nullable GraphQLType but got: {self._of_type}.&quot;</span>

<span class="w"> </span>    def __str__(self):
<span class="gd">-        return f&#39;{self.of_type}!&#39;</span>
<span class="gi">+        return f&quot;{self.of_type}!&quot;</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="gd">-        return isinstance(other, NonNull) and (self.of_type == other.</span>
<span class="gd">-            of_type and self.args == other.args and self.kwargs == other.kwargs</span>
<span class="gd">-            )</span>
<span class="gi">+        return isinstance(other, NonNull) and (</span>
<span class="gi">+            self.of_type == other.of_type</span>
<span class="gi">+            and self.args == other.args</span>
<span class="gi">+            and self.kwargs == other.kwargs</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/graphene/types/union.py b/graphene/types/union.py</span>
<span class="gh">index cabc8df..b7c5dc6 100644</span>
<span class="gd">--- a/graphene/types/union.py</span>
<span class="gi">+++ b/graphene/types/union.py</span>
<span class="gu">@@ -1,13 +1,16 @@</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from .base import BaseOptions, BaseType
<span class="w"> </span>from .unmountedtype import UnmountedType
<span class="gi">+</span>
<span class="gi">+# For static type checking with type checker</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gd">-    from .objecttype import ObjectType</span>
<span class="gd">-    from typing import Iterable, Type</span>
<span class="gi">+    from .objecttype import ObjectType  # NOQA</span>
<span class="gi">+    from typing import Iterable, Type  # NOQA</span>


<span class="w"> </span>class UnionOptions(BaseOptions):
<span class="gd">-    types = ()</span>
<span class="gi">+    types = ()  # type: Iterable[Type[ObjectType]]</span>


<span class="w"> </span>class Union(UnmountedType, BaseType):
<span class="gu">@@ -49,8 +52,10 @@ class Union(UnmountedType, BaseType):</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def __init_subclass_with_meta__(cls, types=None, **options):
<span class="gd">-        assert isinstance(types, (list, tuple)) and len(types</span>
<span class="gd">-            ) &gt; 0, f&#39;Must provide types for Union {cls.__name__}.&#39;</span>
<span class="gi">+        assert (</span>
<span class="gi">+            isinstance(types, (list, tuple)) and len(types) &gt; 0</span>
<span class="gi">+        ), f&quot;Must provide types for Union {cls.__name__}.&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        _meta = UnionOptions(cls)
<span class="w"> </span>        _meta.types = types
<span class="w"> </span>        super(Union, cls).__init_subclass_with_meta__(_meta=_meta, **options)
<span class="gu">@@ -61,4 +66,11 @@ class Union(UnmountedType, BaseType):</span>
<span class="w"> </span>        This function is called when the unmounted type (Union instance)
<span class="w"> </span>        is mounted (as a Field, InputField or Argument)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def resolve_type(cls, instance, info):</span>
<span class="gi">+        from .objecttype import ObjectType  # NOQA</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(instance, ObjectType):</span>
<span class="gi">+            return type(instance)</span>
<span class="gh">diff --git a/graphene/types/unmountedtype.py b/graphene/types/unmountedtype.py</span>
<span class="gh">index 5ca42ce..83a6afe 100644</span>
<span class="gd">--- a/graphene/types/unmountedtype.py</span>
<span class="gi">+++ b/graphene/types/unmountedtype.py</span>
<span class="gu">@@ -49,27 +49,39 @@ class UnmountedType(OrderedType):</span>
<span class="w"> </span>        This function is called when the UnmountedType instance
<span class="w"> </span>        is mounted (as a Field, InputField or Argument)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(f&quot;get_type not implemented in {self}&quot;)</span>

<span class="gd">-    def Field(self):</span>
<span class="gi">+    def mount_as(self, _as):</span>
<span class="gi">+        return _as.mounted(self)</span>
<span class="gi">+</span>
<span class="gi">+    def Field(self):  # noqa: N802</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Mount the UnmountedType as Field
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .field import Field</span>
<span class="gi">+</span>
<span class="gi">+        return self.mount_as(Field)</span>

<span class="gd">-    def InputField(self):</span>
<span class="gi">+    def InputField(self):  # noqa: N802</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Mount the UnmountedType as InputField
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .inputfield import InputField</span>

<span class="gd">-    def Argument(self):</span>
<span class="gi">+        return self.mount_as(InputField)</span>
<span class="gi">+</span>
<span class="gi">+    def Argument(self):  # noqa: N802</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Mount the UnmountedType as Argument
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .argument import Argument</span>
<span class="gi">+</span>
<span class="gi">+        return self.mount_as(Argument)</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="gd">-        return self is other or isinstance(other, UnmountedType</span>
<span class="gd">-            ) and self.get_type() == other.get_type(</span>
<span class="gd">-            ) and self.args == other.args and self.kwargs == other.kwargs</span>
<span class="gi">+        return self is other or (</span>
<span class="gi">+            isinstance(other, UnmountedType)</span>
<span class="gi">+            and self.get_type() == other.get_type()</span>
<span class="gi">+            and self.args == other.args</span>
<span class="gi">+            and self.kwargs == other.kwargs</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/graphene/types/utils.py b/graphene/types/utils.py</span>
<span class="gh">index 4c05498..1976448 100644</span>
<span class="gd">--- a/graphene/types/utils.py</span>
<span class="gi">+++ b/graphene/types/utils.py</span>
<span class="gu">@@ -1,5 +1,6 @@</span>
<span class="w"> </span>import inspect
<span class="w"> </span>from functools import partial
<span class="gi">+</span>
<span class="w"> </span>from ..utils.module_loading import import_string
<span class="w"> </span>from .mountedtype import MountedType
<span class="w"> </span>from .unmountedtype import UnmountedType
<span class="gu">@@ -9,7 +10,12 @@ def get_field_as(value, _as=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get type mounted
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, MountedType):</span>
<span class="gi">+        return value</span>
<span class="gi">+    elif isinstance(value, UnmountedType):</span>
<span class="gi">+        if _as is None:</span>
<span class="gi">+            return value</span>
<span class="gi">+        return _as.mounted(value)</span>


<span class="w"> </span>def yank_fields_from_attrs(attrs, _as=None, sort=True):
<span class="gu">@@ -17,9 +23,28 @@ def yank_fields_from_attrs(attrs, _as=None, sort=True):</span>
<span class="w"> </span>    Extract all the fields in given attributes (dict)
<span class="w"> </span>    and return them ordered
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fields_with_names = []</span>
<span class="gi">+    for attname, value in list(attrs.items()):</span>
<span class="gi">+        field = get_field_as(value, _as)</span>
<span class="gi">+        if not field:</span>
<span class="gi">+            continue</span>
<span class="gi">+        fields_with_names.append((attname, field))</span>
<span class="gi">+</span>
<span class="gi">+    if sort:</span>
<span class="gi">+        fields_with_names = sorted(fields_with_names, key=lambda f: f[1])</span>
<span class="gi">+    return dict(fields_with_names)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_type(_type):</span>
<span class="gi">+    if isinstance(_type, str):</span>
<span class="gi">+        return import_string(_type)</span>
<span class="gi">+    if inspect.isfunction(_type) or isinstance(_type, partial):</span>
<span class="gi">+        return _type()</span>
<span class="gi">+    return _type</span>


<span class="w"> </span>def get_underlying_type(_type):
<span class="w"> </span>    &quot;&quot;&quot;Get the underlying type even if it is wrapped in structures like NonNull&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while hasattr(_type, &quot;of_type&quot;):</span>
<span class="gi">+        _type = _type.of_type</span>
<span class="gi">+    return _type</span>
<span class="gh">diff --git a/graphene/types/uuid.py b/graphene/types/uuid.py</span>
<span class="gh">index bcfe611..f2ba1fc 100644</span>
<span class="gd">--- a/graphene/types/uuid.py</span>
<span class="gi">+++ b/graphene/types/uuid.py</span>
<span class="gu">@@ -1,7 +1,9 @@</span>
<span class="w"> </span>from __future__ import absolute_import
<span class="w"> </span>from uuid import UUID as _UUID
<span class="gi">+</span>
<span class="w"> </span>from graphql.language.ast import StringValueNode
<span class="w"> </span>from graphql import Undefined
<span class="gi">+</span>
<span class="w"> </span>from .scalars import Scalar


<span class="gu">@@ -10,3 +12,21 @@ class UUID(Scalar):</span>
<span class="w"> </span>    Leverages the internal Python implementation of UUID (uuid.UUID) to provide native UUID objects
<span class="w"> </span>    in fields, resolvers and input.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def serialize(uuid):</span>
<span class="gi">+        if isinstance(uuid, str):</span>
<span class="gi">+            uuid = _UUID(uuid)</span>
<span class="gi">+</span>
<span class="gi">+        assert isinstance(uuid, _UUID), f&quot;Expected UUID instance, received {uuid}&quot;</span>
<span class="gi">+        return str(uuid)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_literal(node, _variables=None):</span>
<span class="gi">+        if isinstance(node, StringValueNode):</span>
<span class="gi">+            return _UUID(node.value)</span>
<span class="gi">+        return Undefined</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_value(value):</span>
<span class="gi">+        return _UUID(value)</span>
<span class="gh">diff --git a/graphene/utils/crunch.py b/graphene/utils/crunch.py</span>
<span class="gh">index b20feef..b27d371 100644</span>
<span class="gd">--- a/graphene/utils/crunch.py</span>
<span class="gi">+++ b/graphene/utils/crunch.py</span>
<span class="gu">@@ -1,2 +1,35 @@</span>
<span class="w"> </span>import json
<span class="w"> </span>from collections.abc import Mapping
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_key(value):</span>
<span class="gi">+    return json.dumps(value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def insert(value, index, values):</span>
<span class="gi">+    key = to_key(value)</span>
<span class="gi">+</span>
<span class="gi">+    if key not in index:</span>
<span class="gi">+        index[key] = len(values)</span>
<span class="gi">+        values.append(value)</span>
<span class="gi">+        return len(values) - 1</span>
<span class="gi">+</span>
<span class="gi">+    return index.get(key)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def flatten(data, index, values):</span>
<span class="gi">+    if isinstance(data, (list, tuple)):</span>
<span class="gi">+        flattened = [flatten(child, index, values) for child in data]</span>
<span class="gi">+    elif isinstance(data, Mapping):</span>
<span class="gi">+        flattened = {key: flatten(child, index, values) for key, child in data.items()}</span>
<span class="gi">+    else:</span>
<span class="gi">+        flattened = data</span>
<span class="gi">+    return insert(flattened, index, values)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def crunch(data):</span>
<span class="gi">+    index = {}</span>
<span class="gi">+    values = []</span>
<span class="gi">+</span>
<span class="gi">+    flatten(data, index, values)</span>
<span class="gi">+    return values</span>
<span class="gh">diff --git a/graphene/utils/dataloader.py b/graphene/utils/dataloader.py</span>
<span class="gh">index a7136e2..143558a 100644</span>
<span class="gd">--- a/graphene/utils/dataloader.py</span>
<span class="gi">+++ b/graphene/utils/dataloader.py</span>
<span class="gu">@@ -1,43 +1,119 @@</span>
<span class="gd">-from asyncio import gather, ensure_future, get_event_loop, iscoroutine, iscoroutinefunction</span>
<span class="gi">+from asyncio import (</span>
<span class="gi">+    gather,</span>
<span class="gi">+    ensure_future,</span>
<span class="gi">+    get_event_loop,</span>
<span class="gi">+    iscoroutine,</span>
<span class="gi">+    iscoroutinefunction,</span>
<span class="gi">+)</span>
<span class="w"> </span>from collections import namedtuple
<span class="w"> </span>from collections.abc import Iterable
<span class="w"> </span>from functools import partial
<span class="gd">-from typing import List</span>
<span class="gd">-Loader = namedtuple(&#39;Loader&#39;, &#39;key,future&#39;)</span>
<span class="gi">+</span>
<span class="gi">+from typing import List  # flake8: noqa</span>
<span class="gi">+</span>
<span class="gi">+Loader = namedtuple(&quot;Loader&quot;, &quot;key,future&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def iscoroutinefunctionorpartial(fn):</span>
<span class="gi">+    return iscoroutinefunction(fn.func if isinstance(fn, partial) else fn)</span>


<span class="w"> </span>class DataLoader(object):
<span class="w"> </span>    batch = True
<span class="gd">-    max_batch_size = None</span>
<span class="gi">+    max_batch_size = None  # type: int</span>
<span class="w"> </span>    cache = True

<span class="gd">-    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None,</span>
<span class="gd">-        cache=None, get_cache_key=None, cache_map=None, loop=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        batch_load_fn=None,</span>
<span class="gi">+        batch=None,</span>
<span class="gi">+        max_batch_size=None,</span>
<span class="gi">+        cache=None,</span>
<span class="gi">+        get_cache_key=None,</span>
<span class="gi">+        cache_map=None,</span>
<span class="gi">+        loop=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="w"> </span>        self._loop = loop
<span class="gi">+</span>
<span class="w"> </span>        if batch_load_fn is not None:
<span class="w"> </span>            self.batch_load_fn = batch_load_fn
<span class="gd">-        assert iscoroutinefunctionorpartial(self.batch_load_fn</span>
<span class="gd">-            ), &#39;batch_load_fn must be coroutine. Received: {}&#39;.format(self.</span>
<span class="gd">-            batch_load_fn)</span>
<span class="gi">+</span>
<span class="gi">+        assert iscoroutinefunctionorpartial(</span>
<span class="gi">+            self.batch_load_fn</span>
<span class="gi">+        ), &quot;batch_load_fn must be coroutine. Received: {}&quot;.format(self.batch_load_fn)</span>
<span class="gi">+</span>
<span class="w"> </span>        if not callable(self.batch_load_fn):
<span class="gd">-            raise TypeError(</span>
<span class="gd">-                &#39;DataLoader must be have a batch_load_fn which accepts Iterable&lt;key&gt; and returns Future&lt;Iterable&lt;value&gt;&gt;, but got: {}.&#39;</span>
<span class="gd">-                .format(batch_load_fn))</span>
<span class="gi">+            raise TypeError(  # pragma: no cover</span>
<span class="gi">+                (</span>
<span class="gi">+                    &quot;DataLoader must be have a batch_load_fn which accepts &quot;</span>
<span class="gi">+                    &quot;Iterable&lt;key&gt; and returns Future&lt;Iterable&lt;value&gt;&gt;, but got: {}.&quot;</span>
<span class="gi">+                ).format(batch_load_fn)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        if batch is not None:
<span class="gd">-            self.batch = batch</span>
<span class="gi">+            self.batch = batch  # pragma: no cover</span>
<span class="gi">+</span>
<span class="w"> </span>        if max_batch_size is not None:
<span class="w"> </span>            self.max_batch_size = max_batch_size
<span class="gi">+</span>
<span class="w"> </span>        if cache is not None:
<span class="gd">-            self.cache = cache</span>
<span class="gi">+            self.cache = cache  # pragma: no cover</span>
<span class="gi">+</span>
<span class="w"> </span>        self.get_cache_key = get_cache_key or (lambda x: x)
<span class="gi">+</span>
<span class="w"> </span>        self._cache = cache_map if cache_map is not None else {}
<span class="gd">-        self._queue = []</span>
<span class="gi">+        self._queue = []  # type: List[Loader]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def loop(self):</span>
<span class="gi">+        if not self._loop:</span>
<span class="gi">+            self._loop = get_event_loop()</span>
<span class="gi">+</span>
<span class="gi">+        return self._loop</span>

<span class="w"> </span>    def load(self, key=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Loads a key, returning a `Future` for the value represented by that key.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if key is None:</span>
<span class="gi">+            raise TypeError(  # pragma: no cover</span>
<span class="gi">+                (</span>
<span class="gi">+                    &quot;The loader.load() function must be called with a value, &quot;</span>
<span class="gi">+                    &quot;but got: {}.&quot;</span>
<span class="gi">+                ).format(key)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        cache_key = self.get_cache_key(key)</span>
<span class="gi">+</span>
<span class="gi">+        # If caching and there is a cache-hit, return cached Future.</span>
<span class="gi">+        if self.cache:</span>
<span class="gi">+            cached_result = self._cache.get(cache_key)</span>
<span class="gi">+            if cached_result:</span>
<span class="gi">+                return cached_result</span>
<span class="gi">+</span>
<span class="gi">+        # Otherwise, produce a new Future for this value.</span>
<span class="gi">+        future = self.loop.create_future()</span>
<span class="gi">+        # If caching, cache this Future.</span>
<span class="gi">+        if self.cache:</span>
<span class="gi">+            self._cache[cache_key] = future</span>
<span class="gi">+</span>
<span class="gi">+        self.do_resolve_reject(key, future)</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    def do_resolve_reject(self, key, future):</span>
<span class="gi">+        # Enqueue this Future to be dispatched.</span>
<span class="gi">+        self._queue.append(Loader(key=key, future=future))</span>
<span class="gi">+        # Determine if a dispatch of this queue should be scheduled.</span>
<span class="gi">+        # A single dispatch should be scheduled per queue at the time when the</span>
<span class="gi">+        # queue changes from &quot;empty&quot; to &quot;full&quot;.</span>
<span class="gi">+        if len(self._queue) == 1:</span>
<span class="gi">+            if self.batch:</span>
<span class="gi">+                # If batching, schedule a task to dispatch the queue.</span>
<span class="gi">+                enqueue_post_future_job(self.loop, self)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Otherwise dispatch the (queue of one) immediately.</span>
<span class="gi">+                dispatch_queue(self)  # pragma: no cover</span>

<span class="w"> </span>    def load_many(self, keys):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -52,14 +128,24 @@ class DataLoader(object):</span>
<span class="w"> </span>        &gt;&gt;&gt;    my_loader.load(&#39;b&#39;)
<span class="w"> </span>        &gt;&gt;&gt; )
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(keys, Iterable):</span>
<span class="gi">+            raise TypeError(  # pragma: no cover</span>
<span class="gi">+                (</span>
<span class="gi">+                    &quot;The loader.load_many() function must be called with Iterable&lt;key&gt; &quot;</span>
<span class="gi">+                    &quot;but got: {}.&quot;</span>
<span class="gi">+                ).format(keys)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return gather(*[self.load(key) for key in keys])</span>

<span class="w"> </span>    def clear(self, key):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Clears the value at `key` from the cache, if it exists. Returns itself for
<span class="w"> </span>        method chaining.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cache_key = self.get_cache_key(key)</span>
<span class="gi">+        self._cache.pop(cache_key, None)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def clear_all(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -67,14 +153,44 @@ class DataLoader(object):</span>
<span class="w"> </span>        invalidations across this particular `DataLoader`. Returns itself for
<span class="w"> </span>        method chaining.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._cache.clear()</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def prime(self, key, value):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Adds the provied key and value to the cache. If the key already exists, no
<span class="w"> </span>        change is made. Returns itself for method chaining.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cache_key = self.get_cache_key(key)</span>
<span class="gi">+</span>
<span class="gi">+        # Only add the key if it does not already exist.</span>
<span class="gi">+        if cache_key not in self._cache:</span>
<span class="gi">+            # Cache a rejected future if the value is an Error, in order to match</span>
<span class="gi">+            # the behavior of load(key).</span>
<span class="gi">+            future = self.loop.create_future()</span>
<span class="gi">+            if isinstance(value, Exception):</span>
<span class="gi">+                future.set_exception(value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                future.set_result(value)</span>
<span class="gi">+</span>
<span class="gi">+            self._cache[cache_key] = future</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def enqueue_post_future_job(loop, loader):</span>
<span class="gi">+    async def dispatch():</span>
<span class="gi">+        dispatch_queue(loader)</span>
<span class="gi">+</span>
<span class="gi">+    loop.call_soon(ensure_future, dispatch())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_chunks(iterable_obj, chunk_size=1):</span>
<span class="gi">+    chunk_size = max(1, chunk_size)</span>
<span class="gi">+    return (</span>
<span class="gi">+        iterable_obj[i : i + chunk_size]</span>
<span class="gi">+        for i in range(0, len(iterable_obj), chunk_size)</span>
<span class="gi">+    )</span>


<span class="w"> </span>def dispatch_queue(loader):
<span class="gu">@@ -82,7 +198,77 @@ def dispatch_queue(loader):</span>
<span class="w"> </span>    Given the current state of a Loader instance, perform a batch load
<span class="w"> </span>    from its current queue.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Take the current loader queue, replacing it with an empty queue.</span>
<span class="gi">+    queue = loader._queue</span>
<span class="gi">+    loader._queue = []</span>
<span class="gi">+</span>
<span class="gi">+    # If a max_batch_size was provided and the queue is longer, then segment the</span>
<span class="gi">+    # queue into multiple batches, otherwise treat the queue as a single batch.</span>
<span class="gi">+    max_batch_size = loader.max_batch_size</span>
<span class="gi">+</span>
<span class="gi">+    if max_batch_size and max_batch_size &lt; len(queue):</span>
<span class="gi">+        chunks = get_chunks(queue, max_batch_size)</span>
<span class="gi">+        for chunk in chunks:</span>
<span class="gi">+            ensure_future(dispatch_queue_batch(loader, chunk))</span>
<span class="gi">+    else:</span>
<span class="gi">+        ensure_future(dispatch_queue_batch(loader, queue))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def dispatch_queue_batch(loader, queue):</span>
<span class="gi">+    # Collect all keys to be loaded in this dispatch</span>
<span class="gi">+    keys = [loaded.key for loaded in queue]</span>
<span class="gi">+</span>
<span class="gi">+    # Call the provided batch_load_fn for this loader with the loader queue&#39;s keys.</span>
<span class="gi">+    batch_future = loader.batch_load_fn(keys)</span>
<span class="gi">+</span>
<span class="gi">+    # Assert the expected response from batch_load_fn</span>
<span class="gi">+    if not batch_future or not iscoroutine(batch_future):</span>
<span class="gi">+        return failed_dispatch(  # pragma: no cover</span>
<span class="gi">+            loader,</span>
<span class="gi">+            queue,</span>
<span class="gi">+            TypeError(</span>
<span class="gi">+                (</span>
<span class="gi">+                    &quot;DataLoader must be constructed with a function which accepts &quot;</span>
<span class="gi">+                    &quot;Iterable&lt;key&gt; and returns Future&lt;Iterable&lt;value&gt;&gt;, but the function did &quot;</span>
<span class="gi">+                    &quot;not return a Coroutine: {}.&quot;</span>
<span class="gi">+                ).format(batch_future)</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        values = await batch_future</span>
<span class="gi">+        if not isinstance(values, Iterable):</span>
<span class="gi">+            raise TypeError(  # pragma: no cover</span>
<span class="gi">+                (</span>
<span class="gi">+                    &quot;DataLoader must be constructed with a function which accepts &quot;</span>
<span class="gi">+                    &quot;Iterable&lt;key&gt; and returns Future&lt;Iterable&lt;value&gt;&gt;, but the function did &quot;</span>
<span class="gi">+                    &quot;not return a Future of a Iterable: {}.&quot;</span>
<span class="gi">+                ).format(values)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        values = list(values)</span>
<span class="gi">+        if len(values) != len(keys):</span>
<span class="gi">+            raise TypeError(  # pragma: no cover</span>
<span class="gi">+                (</span>
<span class="gi">+                    &quot;DataLoader must be constructed with a function which accepts &quot;</span>
<span class="gi">+                    &quot;Iterable&lt;key&gt; and returns Future&lt;Iterable&lt;value&gt;&gt;, but the function did &quot;</span>
<span class="gi">+                    &quot;not return a Future of a Iterable with the same length as the Iterable &quot;</span>
<span class="gi">+                    &quot;of keys.&quot;</span>
<span class="gi">+                    &quot;\n\nKeys:\n{}&quot;</span>
<span class="gi">+                    &quot;\n\nValues:\n{}&quot;</span>
<span class="gi">+                ).format(keys, values)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Step through the values, resolving or rejecting each Future in the</span>
<span class="gi">+        # loaded queue.</span>
<span class="gi">+        for loaded, value in zip(queue, values):</span>
<span class="gi">+            if isinstance(value, Exception):</span>
<span class="gi">+                loaded.future.set_exception(value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                loaded.future.set_result(value)</span>
<span class="gi">+</span>
<span class="gi">+    except Exception as e:</span>
<span class="gi">+        return failed_dispatch(loader, queue, e)</span>


<span class="w"> </span>def failed_dispatch(loader, queue, error):
<span class="gu">@@ -90,4 +276,6 @@ def failed_dispatch(loader, queue, error):</span>
<span class="w"> </span>    Do not cache individual loads if the entire batch dispatch fails,
<span class="w"> </span>    but still reject each request so they do not hang.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for loaded in queue:</span>
<span class="gi">+        loader.clear(loaded.key)</span>
<span class="gi">+        loaded.future.set_exception(error)</span>
<span class="gh">diff --git a/graphene/utils/deduplicator.py b/graphene/utils/deduplicator.py</span>
<span class="gh">index 26f5d8e..3fbf139 100644</span>
<span class="gd">--- a/graphene/utils/deduplicator.py</span>
<span class="gi">+++ b/graphene/utils/deduplicator.py</span>
<span class="gu">@@ -1 +1,32 @@</span>
<span class="w"> </span>from collections.abc import Mapping
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def deflate(node, index=None, path=None):</span>
<span class="gi">+    if index is None:</span>
<span class="gi">+        index = {}</span>
<span class="gi">+    if path is None:</span>
<span class="gi">+        path = []</span>
<span class="gi">+</span>
<span class="gi">+    if node and &quot;id&quot; in node and &quot;__typename&quot; in node:</span>
<span class="gi">+        route = &quot;,&quot;.join(path)</span>
<span class="gi">+        cache_key = &quot;:&quot;.join([route, str(node[&quot;__typename&quot;]), str(node[&quot;id&quot;])])</span>
<span class="gi">+</span>
<span class="gi">+        if index.get(cache_key) is True:</span>
<span class="gi">+            return {&quot;__typename&quot;: node[&quot;__typename&quot;], &quot;id&quot;: node[&quot;id&quot;]}</span>
<span class="gi">+        else:</span>
<span class="gi">+            index[cache_key] = True</span>
<span class="gi">+</span>
<span class="gi">+    result = {}</span>
<span class="gi">+</span>
<span class="gi">+    for field_name in node:</span>
<span class="gi">+        value = node[field_name]</span>
<span class="gi">+</span>
<span class="gi">+        new_path = path + [field_name]</span>
<span class="gi">+        if isinstance(value, (list, tuple)):</span>
<span class="gi">+            result[field_name] = [deflate(child, index, new_path) for child in value]</span>
<span class="gi">+        elif isinstance(value, Mapping):</span>
<span class="gi">+            result[field_name] = deflate(value, index, new_path)</span>
<span class="gi">+        else:</span>
<span class="gi">+            result[field_name] = value</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>
<span class="gh">diff --git a/graphene/utils/deprecated.py b/graphene/utils/deprecated.py</span>
<span class="gh">index d561393..71a5bb4 100644</span>
<span class="gd">--- a/graphene/utils/deprecated.py</span>
<span class="gi">+++ b/graphene/utils/deprecated.py</span>
<span class="gu">@@ -1,7 +1,12 @@</span>
<span class="w"> </span>import functools
<span class="w"> </span>import inspect
<span class="w"> </span>import warnings
<span class="gd">-string_types = type(b&#39;&#39;), type(&#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+string_types = (type(b&quot;&quot;), type(&quot;&quot;))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def warn_deprecation(text):</span>
<span class="gi">+    warnings.warn(text, category=DeprecationWarning, stacklevel=2)</span>


<span class="w"> </span>def deprecated(reason):
<span class="gu">@@ -10,4 +15,56 @@ def deprecated(reason):</span>
<span class="w"> </span>    as deprecated. It will result in a warning being emitted
<span class="w"> </span>    when the function is used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(reason, string_types):</span>
<span class="gi">+</span>
<span class="gi">+        # The @deprecated is used with a &#39;reason&#39;.</span>
<span class="gi">+        #</span>
<span class="gi">+        # .. code-block:: python</span>
<span class="gi">+        #</span>
<span class="gi">+        #    @deprecated(&quot;please, use another function&quot;)</span>
<span class="gi">+        #    def old_function(x, y):</span>
<span class="gi">+        #      pass</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(func1):</span>
<span class="gi">+</span>
<span class="gi">+            if inspect.isclass(func1):</span>
<span class="gi">+                fmt1 = f&quot;Call to deprecated class {func1.__name__} ({reason}).&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                fmt1 = f&quot;Call to deprecated function {func1.__name__} ({reason}).&quot;</span>
<span class="gi">+</span>
<span class="gi">+            @functools.wraps(func1)</span>
<span class="gi">+            def new_func1(*args, **kwargs):</span>
<span class="gi">+                warn_deprecation(fmt1)</span>
<span class="gi">+                return func1(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            return new_func1</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>
<span class="gi">+</span>
<span class="gi">+    elif inspect.isclass(reason) or inspect.isfunction(reason):</span>
<span class="gi">+</span>
<span class="gi">+        # The @deprecated is used without any &#39;reason&#39;.</span>
<span class="gi">+        #</span>
<span class="gi">+        # .. code-block:: python</span>
<span class="gi">+        #</span>
<span class="gi">+        #    @deprecated</span>
<span class="gi">+        #    def old_function(x, y):</span>
<span class="gi">+        #      pass</span>
<span class="gi">+</span>
<span class="gi">+        func2 = reason</span>
<span class="gi">+</span>
<span class="gi">+        if inspect.isclass(func2):</span>
<span class="gi">+            fmt2 = f&quot;Call to deprecated class {func2.__name__}.&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            fmt2 = f&quot;Call to deprecated function {func2.__name__}.&quot;</span>
<span class="gi">+</span>
<span class="gi">+        @functools.wraps(func2)</span>
<span class="gi">+        def new_func2(*args, **kwargs):</span>
<span class="gi">+            warn_deprecation(fmt2)</span>
<span class="gi">+            return func2(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        return new_func2</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(repr(type(reason)))</span>
<span class="gh">diff --git a/graphene/utils/get_unbound_function.py b/graphene/utils/get_unbound_function.py</span>
<span class="gh">index e69de29..bd311e3 100644</span>
<span class="gd">--- a/graphene/utils/get_unbound_function.py</span>
<span class="gi">+++ b/graphene/utils/get_unbound_function.py</span>
<span class="gu">@@ -0,0 +1,4 @@</span>
<span class="gi">+def get_unbound_function(func):</span>
<span class="gi">+    if not getattr(func, &quot;__self__&quot;, True):</span>
<span class="gi">+        return func.__func__</span>
<span class="gi">+    return func</span>
<span class="gh">diff --git a/graphene/utils/is_introspection_key.py b/graphene/utils/is_introspection_key.py</span>
<span class="gh">index e69de29..59d72b2 100644</span>
<span class="gd">--- a/graphene/utils/is_introspection_key.py</span>
<span class="gi">+++ b/graphene/utils/is_introspection_key.py</span>
<span class="gu">@@ -0,0 +1,6 @@</span>
<span class="gi">+def is_introspection_key(key):</span>
<span class="gi">+    # from: https://spec.graphql.org/June2018/#sec-Schema</span>
<span class="gi">+    # &gt; All types and directives defined within a schema must not have a name which</span>
<span class="gi">+    # &gt; begins with &quot;__&quot; (two underscores), as this is used exclusively</span>
<span class="gi">+    # &gt; by GraphQLs introspection system.</span>
<span class="gi">+    return str(key).startswith(&quot;__&quot;)</span>
<span class="gh">diff --git a/graphene/utils/module_loading.py b/graphene/utils/module_loading.py</span>
<span class="gh">index 21e42a9..d9095d0 100644</span>
<span class="gd">--- a/graphene/utils/module_loading.py</span>
<span class="gi">+++ b/graphene/utils/module_loading.py</span>
<span class="gu">@@ -10,4 +10,36 @@ def import_string(dotted_path, dotted_attributes=None):</span>
<span class="w"> </span>    the first step, and return the corresponding value designated by the
<span class="w"> </span>    attribute path. Raise ImportError if the import failed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        module_path, class_name = dotted_path.rsplit(&quot;.&quot;, 1)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise ImportError(&quot;%s doesn&#39;t look like a module path&quot; % dotted_path)</span>
<span class="gi">+</span>
<span class="gi">+    module = import_module(module_path)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        result = getattr(module, class_name)</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        raise ImportError(</span>
<span class="gi">+            &#39;Module &quot;%s&quot; does not define a &quot;%s&quot; attribute/class&#39;</span>
<span class="gi">+            % (module_path, class_name)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if not dotted_attributes:</span>
<span class="gi">+        return result</span>
<span class="gi">+    attributes = dotted_attributes.split(&quot;.&quot;)</span>
<span class="gi">+    traveled_attributes = []</span>
<span class="gi">+    try:</span>
<span class="gi">+        for attribute in attributes:</span>
<span class="gi">+            traveled_attributes.append(attribute)</span>
<span class="gi">+            result = getattr(result, attribute)</span>
<span class="gi">+        return result</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        raise ImportError(</span>
<span class="gi">+            &#39;Module &quot;%s&quot; does not define a &quot;%s&quot; attribute inside attribute/class &quot;%s&quot;&#39;</span>
<span class="gi">+            % (module_path, &quot;.&quot;.join(traveled_attributes), class_name)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def lazy_import(dotted_path, dotted_attributes=None):</span>
<span class="gi">+    return partial(import_string, dotted_path, dotted_attributes)</span>
<span class="gh">diff --git a/graphene/utils/orderedtype.py b/graphene/utils/orderedtype.py</span>
<span class="gh">index e97396d..294ad54 100644</span>
<span class="gd">--- a/graphene/utils/orderedtype.py</span>
<span class="gi">+++ b/graphene/utils/orderedtype.py</span>
<span class="gu">@@ -8,17 +8,29 @@ class OrderedType:</span>
<span class="w"> </span>    def __init__(self, _creation_counter=None):
<span class="w"> </span>        self.creation_counter = _creation_counter or self.gen_counter()

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def gen_counter():</span>
<span class="gi">+        counter = OrderedType.creation_counter</span>
<span class="gi">+        OrderedType.creation_counter += 1</span>
<span class="gi">+        return counter</span>
<span class="gi">+</span>
<span class="gi">+    def reset_counter(self):</span>
<span class="gi">+        self.creation_counter = self.gen_counter()</span>
<span class="gi">+</span>
<span class="w"> </span>    def __eq__(self, other):
<span class="gi">+        # Needed for @total_ordering</span>
<span class="w"> </span>        if isinstance(self, type(other)):
<span class="w"> </span>            return self.creation_counter == other.creation_counter
<span class="w"> </span>        return NotImplemented

<span class="w"> </span>    def __lt__(self, other):
<span class="gi">+        # This is needed because bisect does not take a comparison function.</span>
<span class="w"> </span>        if isinstance(other, OrderedType):
<span class="w"> </span>            return self.creation_counter &lt; other.creation_counter
<span class="w"> </span>        return NotImplemented

<span class="w"> </span>    def __gt__(self, other):
<span class="gi">+        # This is needed because bisect does not take a comparison function.</span>
<span class="w"> </span>        if isinstance(other, OrderedType):
<span class="w"> </span>            return self.creation_counter &gt; other.creation_counter
<span class="w"> </span>        return NotImplemented
<span class="gh">diff --git a/graphene/utils/props.py b/graphene/utils/props.py</span>
<span class="gh">index 114245a..26c697e 100644</span>
<span class="gd">--- a/graphene/utils/props.py</span>
<span class="gi">+++ b/graphene/utils/props.py</span>
<span class="gu">@@ -7,3 +7,9 @@ class _NewClass:</span>


<span class="w"> </span>_all_vars = set(dir(_OldClass) + dir(_NewClass))
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def props(x):</span>
<span class="gi">+    return {</span>
<span class="gi">+        key: vars(x).get(key, getattr(x, key)) for key in dir(x) if key not in _all_vars</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/graphene/utils/resolve_only_args.py b/graphene/utils/resolve_only_args.py</span>
<span class="gh">index 0f0ddd2..5efff2e 100644</span>
<span class="gd">--- a/graphene/utils/resolve_only_args.py</span>
<span class="gi">+++ b/graphene/utils/resolve_only_args.py</span>
<span class="gu">@@ -1,2 +1,12 @@</span>
<span class="w"> </span>from functools import wraps
<span class="gi">+</span>
<span class="w"> </span>from .deprecated import deprecated
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@deprecated(&quot;This function is deprecated&quot;)</span>
<span class="gi">+def resolve_only_args(func):</span>
<span class="gi">+    @wraps(func)</span>
<span class="gi">+    def wrapped_func(root, info, **args):</span>
<span class="gi">+        return func(root, **args)</span>
<span class="gi">+</span>
<span class="gi">+    return wrapped_func</span>
<span class="gh">diff --git a/graphene/utils/str_converters.py b/graphene/utils/str_converters.py</span>
<span class="gh">index b199df5..2a214f0 100644</span>
<span class="gd">--- a/graphene/utils/str_converters.py</span>
<span class="gi">+++ b/graphene/utils/str_converters.py</span>
<span class="gu">@@ -1 +1,17 @@</span>
<span class="w"> </span>import re
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Adapted from this response in Stackoverflow</span>
<span class="gi">+# http://stackoverflow.com/a/19053800/1072990</span>
<span class="gi">+def to_camel_case(snake_str):</span>
<span class="gi">+    components = snake_str.split(&quot;_&quot;)</span>
<span class="gi">+    # We capitalize the first letter of each component except the first one</span>
<span class="gi">+    # with the &#39;capitalize&#39; method and join them together.</span>
<span class="gi">+    return components[0] + &quot;&quot;.join(x.capitalize() if x else &quot;_&quot; for x in components[1:])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# From this response in Stackoverflow</span>
<span class="gi">+# http://stackoverflow.com/a/1176023/1072990</span>
<span class="gi">+def to_snake_case(name):</span>
<span class="gi">+    s1 = re.sub(&quot;(.)([A-Z][a-z]+)&quot;, r&quot;\1_\2&quot;, name)</span>
<span class="gi">+    return re.sub(&quot;([a-z0-9])([A-Z])&quot;, r&quot;\1_\2&quot;, s1).lower()</span>
<span class="gh">diff --git a/graphene/utils/subclass_with_meta.py b/graphene/utils/subclass_with_meta.py</span>
<span class="gh">index 78666c9..c4ee11d 100644</span>
<span class="gd">--- a/graphene/utils/subclass_with_meta.py</span>
<span class="gi">+++ b/graphene/utils/subclass_with_meta.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from inspect import isclass
<span class="gi">+</span>
<span class="w"> </span>from .props import props


<span class="gu">@@ -11,7 +12,7 @@ class SubclassWithMeta_Meta(type):</span>
<span class="w"> </span>        return cls.__name__

<span class="w"> </span>    def __repr__(cls):
<span class="gd">-        return f&#39;&lt;{cls.__name__} meta={repr(cls._meta)}&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;{cls.__name__} meta={repr(cls._meta)}&gt;&quot;</span>


<span class="w"> </span>class SubclassWithMeta(metaclass=SubclassWithMeta_Meta):
<span class="gu">@@ -19,7 +20,7 @@ class SubclassWithMeta(metaclass=SubclassWithMeta_Meta):</span>

<span class="w"> </span>    def __init_subclass__(cls, **meta_options):
<span class="w"> </span>        &quot;&quot;&quot;This method just terminates the super() chain&quot;&quot;&quot;
<span class="gd">-        _Meta = getattr(cls, &#39;Meta&#39;, None)</span>
<span class="gi">+        _Meta = getattr(cls, &quot;Meta&quot;, None)</span>
<span class="w"> </span>        _meta_props = {}
<span class="w"> </span>        if _Meta:
<span class="w"> </span>            if isinstance(_Meta, dict):
<span class="gu">@@ -28,16 +29,20 @@ class SubclassWithMeta(metaclass=SubclassWithMeta_Meta):</span>
<span class="w"> </span>                _meta_props = props(_Meta)
<span class="w"> </span>            else:
<span class="w"> </span>                raise Exception(
<span class="gd">-                    f&#39;Meta have to be either a class or a dict. Received {_Meta}&#39;</span>
<span class="gd">-                    )</span>
<span class="gd">-            delattr(cls, &#39;Meta&#39;)</span>
<span class="gi">+                    f&quot;Meta have to be either a class or a dict. Received {_Meta}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            delattr(cls, &quot;Meta&quot;)</span>
<span class="w"> </span>        options = dict(meta_options, **_meta_props)
<span class="gd">-        abstract = options.pop(&#39;abstract&#39;, False)</span>
<span class="gi">+</span>
<span class="gi">+        abstract = options.pop(&quot;abstract&quot;, False)</span>
<span class="w"> </span>        if abstract:
<span class="gd">-            assert not options, f&quot;Abstract types can only contain the abstract attribute. Received: abstract, {&#39;, &#39;.join(options)}&quot;</span>
<span class="gi">+            assert not options, (</span>
<span class="gi">+                &quot;Abstract types can only contain the abstract attribute. &quot;</span>
<span class="gi">+                f&quot;Received: abstract, {&#39;, &#39;.join(options)}&quot;</span>
<span class="gi">+            )</span>
<span class="w"> </span>        else:
<span class="w"> </span>            super_class = super(cls, cls)
<span class="gd">-            if hasattr(super_class, &#39;__init_subclass_with_meta__&#39;):</span>
<span class="gi">+            if hasattr(super_class, &quot;__init_subclass_with_meta__&quot;):</span>
<span class="w"> </span>                super_class.__init_subclass_with_meta__(**options)

<span class="w"> </span>    @classmethod
<span class="gh">diff --git a/graphene/utils/thenables.py b/graphene/utils/thenables.py</span>
<span class="gh">index 0ad5e44..9628699 100644</span>
<span class="gd">--- a/graphene/utils/thenables.py</span>
<span class="gi">+++ b/graphene/utils/thenables.py</span>
<span class="gu">@@ -1,13 +1,25 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>This file is used mainly as a bridge for thenable abstractions.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from inspect import isawaitable


<span class="gi">+def await_and_execute(obj, on_resolve):</span>
<span class="gi">+    async def build_resolve_async():</span>
<span class="gi">+        return on_resolve(await obj)</span>
<span class="gi">+</span>
<span class="gi">+    return build_resolve_async()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def maybe_thenable(obj, on_resolve):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Execute a on_resolve function once the thenable is resolved,
<span class="w"> </span>    returning the same type of object inputed.
<span class="w"> </span>    If the object is not thenable, it should return on_resolve(obj)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isawaitable(obj):</span>
<span class="gi">+        return await_and_execute(obj, on_resolve)</span>
<span class="gi">+</span>
<span class="gi">+    # If it&#39;s not awaitable, return the function executed over the object</span>
<span class="gi">+    return on_resolve(obj)</span>
<span class="gh">diff --git a/graphene/utils/trim_docstring.py b/graphene/utils/trim_docstring.py</span>
<span class="gh">index 1f137a2..a23c7e7 100644</span>
<span class="gd">--- a/graphene/utils/trim_docstring.py</span>
<span class="gi">+++ b/graphene/utils/trim_docstring.py</span>
<span class="gu">@@ -1 +1,9 @@</span>
<span class="w"> </span>import inspect
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def trim_docstring(docstring):</span>
<span class="gi">+    # Cleans up whitespaces from an indented docstring</span>
<span class="gi">+    #</span>
<span class="gi">+    # See https://www.python.org/dev/peps/pep-0257/</span>
<span class="gi">+    # and https://docs.python.org/2/library/inspect.html#inspect.cleandoc</span>
<span class="gi">+    return inspect.cleandoc(docstring) if docstring else None</span>
<span class="gh">diff --git a/graphene/validation/depth_limit.py b/graphene/validation/depth_limit.py</span>
<span class="gh">index d55fcf7..e0f2866 100644</span>
<span class="gd">--- a/graphene/validation/depth_limit.py</span>
<span class="gi">+++ b/graphene/validation/depth_limit.py</span>
<span class="gu">@@ -1,10 +1,195 @@</span>
<span class="gi">+# This is a Python port of https://github.com/stems/graphql-depth-limit</span>
<span class="gi">+# which is licensed under the terms of the MIT license, reproduced below.</span>
<span class="gi">+#</span>
<span class="gi">+# -----------</span>
<span class="gi">+#</span>
<span class="gi">+# MIT License</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright (c) 2017 Stem</span>
<span class="gi">+#</span>
<span class="gi">+# Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="gi">+# of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="gi">+# in the Software without restriction, including without limitation the rights</span>
<span class="gi">+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="gi">+# copies of the Software, and to permit persons to whom the Software is</span>
<span class="gi">+# furnished to do so, subject to the following conditions:</span>
<span class="gi">+#</span>
<span class="gi">+# The above copyright notice and this permission notice shall be included in all</span>
<span class="gi">+# copies or substantial portions of the Software.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="gi">+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="gi">+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="gi">+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="gi">+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="gi">+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="gi">+# SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from re import Pattern
<span class="w"> </span>except ImportError:
<span class="gi">+    # backwards compatibility for v3.6</span>
<span class="w"> </span>    from typing import Pattern
<span class="w"> </span>from typing import Callable, Dict, List, Optional, Union, Tuple
<span class="gi">+</span>
<span class="w"> </span>from graphql import GraphQLError
<span class="w"> </span>from graphql.validation import ValidationContext, ValidationRule
<span class="gd">-from graphql.language import DefinitionNode, FieldNode, FragmentDefinitionNode, FragmentSpreadNode, InlineFragmentNode, Node, OperationDefinitionNode</span>
<span class="gi">+from graphql.language import (</span>
<span class="gi">+    DefinitionNode,</span>
<span class="gi">+    FieldNode,</span>
<span class="gi">+    FragmentDefinitionNode,</span>
<span class="gi">+    FragmentSpreadNode,</span>
<span class="gi">+    InlineFragmentNode,</span>
<span class="gi">+    Node,</span>
<span class="gi">+    OperationDefinitionNode,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from ..utils.is_introspection_key import is_introspection_key
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>IgnoreType = Union[Callable[[str], bool], Pattern, str]
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def depth_limit_validator(</span>
<span class="gi">+    max_depth: int,</span>
<span class="gi">+    ignore: Optional[List[IgnoreType]] = None,</span>
<span class="gi">+    callback: Optional[Callable[[Dict[str, int]], None]] = None,</span>
<span class="gi">+):</span>
<span class="gi">+    class DepthLimitValidator(ValidationRule):</span>
<span class="gi">+        def __init__(self, validation_context: ValidationContext):</span>
<span class="gi">+            document = validation_context.document</span>
<span class="gi">+            definitions = document.definitions</span>
<span class="gi">+</span>
<span class="gi">+            fragments = get_fragments(definitions)</span>
<span class="gi">+            queries = get_queries_and_mutations(definitions)</span>
<span class="gi">+            query_depths = {}</span>
<span class="gi">+</span>
<span class="gi">+            for name in queries:</span>
<span class="gi">+                query_depths[name] = determine_depth(</span>
<span class="gi">+                    node=queries[name],</span>
<span class="gi">+                    fragments=fragments,</span>
<span class="gi">+                    depth_so_far=0,</span>
<span class="gi">+                    max_depth=max_depth,</span>
<span class="gi">+                    context=validation_context,</span>
<span class="gi">+                    operation_name=name,</span>
<span class="gi">+                    ignore=ignore,</span>
<span class="gi">+                )</span>
<span class="gi">+            if callable(callback):</span>
<span class="gi">+                callback(query_depths)</span>
<span class="gi">+            super().__init__(validation_context)</span>
<span class="gi">+</span>
<span class="gi">+    return DepthLimitValidator</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_fragments(</span>
<span class="gi">+    definitions: Tuple[DefinitionNode, ...],</span>
<span class="gi">+) -&gt; Dict[str, FragmentDefinitionNode]:</span>
<span class="gi">+    fragments = {}</span>
<span class="gi">+    for definition in definitions:</span>
<span class="gi">+        if isinstance(definition, FragmentDefinitionNode):</span>
<span class="gi">+            fragments[definition.name.value] = definition</span>
<span class="gi">+    return fragments</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# This will actually get both queries and mutations.</span>
<span class="gi">+# We can basically treat those the same</span>
<span class="gi">+def get_queries_and_mutations(</span>
<span class="gi">+    definitions: Tuple[DefinitionNode, ...],</span>
<span class="gi">+) -&gt; Dict[str, OperationDefinitionNode]:</span>
<span class="gi">+    operations = {}</span>
<span class="gi">+</span>
<span class="gi">+    for definition in definitions:</span>
<span class="gi">+        if isinstance(definition, OperationDefinitionNode):</span>
<span class="gi">+            operation = definition.name.value if definition.name else &quot;anonymous&quot;</span>
<span class="gi">+            operations[operation] = definition</span>
<span class="gi">+    return operations</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def determine_depth(</span>
<span class="gi">+    node: Node,</span>
<span class="gi">+    fragments: Dict[str, FragmentDefinitionNode],</span>
<span class="gi">+    depth_so_far: int,</span>
<span class="gi">+    max_depth: int,</span>
<span class="gi">+    context: ValidationContext,</span>
<span class="gi">+    operation_name: str,</span>
<span class="gi">+    ignore: Optional[List[IgnoreType]] = None,</span>
<span class="gi">+) -&gt; int:</span>
<span class="gi">+    if depth_so_far &gt; max_depth:</span>
<span class="gi">+        context.report_error(</span>
<span class="gi">+            GraphQLError(</span>
<span class="gi">+                f&quot;&#39;{operation_name}&#39; exceeds maximum operation depth of {max_depth}.&quot;,</span>
<span class="gi">+                [node],</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        return depth_so_far</span>
<span class="gi">+    if isinstance(node, FieldNode):</span>
<span class="gi">+        should_ignore = is_introspection_key(node.name.value) or is_ignored(</span>
<span class="gi">+            node, ignore</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if should_ignore or not node.selection_set:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        return 1 + max(</span>
<span class="gi">+            map(</span>
<span class="gi">+                lambda selection: determine_depth(</span>
<span class="gi">+                    node=selection,</span>
<span class="gi">+                    fragments=fragments,</span>
<span class="gi">+                    depth_so_far=depth_so_far + 1,</span>
<span class="gi">+                    max_depth=max_depth,</span>
<span class="gi">+                    context=context,</span>
<span class="gi">+                    operation_name=operation_name,</span>
<span class="gi">+                    ignore=ignore,</span>
<span class="gi">+                ),</span>
<span class="gi">+                node.selection_set.selections,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+    elif isinstance(node, FragmentSpreadNode):</span>
<span class="gi">+        return determine_depth(</span>
<span class="gi">+            node=fragments[node.name.value],</span>
<span class="gi">+            fragments=fragments,</span>
<span class="gi">+            depth_so_far=depth_so_far,</span>
<span class="gi">+            max_depth=max_depth,</span>
<span class="gi">+            context=context,</span>
<span class="gi">+            operation_name=operation_name,</span>
<span class="gi">+            ignore=ignore,</span>
<span class="gi">+        )</span>
<span class="gi">+    elif isinstance(</span>
<span class="gi">+        node, (InlineFragmentNode, FragmentDefinitionNode, OperationDefinitionNode)</span>
<span class="gi">+    ):</span>
<span class="gi">+        return max(</span>
<span class="gi">+            map(</span>
<span class="gi">+                lambda selection: determine_depth(</span>
<span class="gi">+                    node=selection,</span>
<span class="gi">+                    fragments=fragments,</span>
<span class="gi">+                    depth_so_far=depth_so_far,</span>
<span class="gi">+                    max_depth=max_depth,</span>
<span class="gi">+                    context=context,</span>
<span class="gi">+                    operation_name=operation_name,</span>
<span class="gi">+                    ignore=ignore,</span>
<span class="gi">+                ),</span>
<span class="gi">+                node.selection_set.selections,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise Exception(</span>
<span class="gi">+            f&quot;Depth crawler cannot handle: {node.kind}.&quot;</span>
<span class="gi">+        )  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_ignored(node: FieldNode, ignore: Optional[List[IgnoreType]] = None) -&gt; bool:</span>
<span class="gi">+    if ignore is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+    for rule in ignore:</span>
<span class="gi">+        field_name = node.name.value</span>
<span class="gi">+        if isinstance(rule, str):</span>
<span class="gi">+            if field_name == rule:</span>
<span class="gi">+                return True</span>
<span class="gi">+        elif isinstance(rule, Pattern):</span>
<span class="gi">+            if rule.match(field_name):</span>
<span class="gi">+                return True</span>
<span class="gi">+        elif callable(rule):</span>
<span class="gi">+            if rule(field_name):</span>
<span class="gi">+                return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid ignore option: {rule}.&quot;)</span>
<span class="gi">+    return False</span>
<span class="gh">diff --git a/graphene/validation/disable_introspection.py b/graphene/validation/disable_introspection.py</span>
<span class="gh">index d18720b..49a7d60 100644</span>
<span class="gd">--- a/graphene/validation/disable_introspection.py</span>
<span class="gi">+++ b/graphene/validation/disable_introspection.py</span>
<span class="gu">@@ -1,8 +1,16 @@</span>
<span class="w"> </span>from graphql import GraphQLError
<span class="w"> </span>from graphql.language import FieldNode
<span class="w"> </span>from graphql.validation import ValidationRule
<span class="gi">+</span>
<span class="w"> </span>from ..utils.is_introspection_key import is_introspection_key


<span class="w"> </span>class DisableIntrospection(ValidationRule):
<span class="gd">-    pass</span>
<span class="gi">+    def enter_field(self, node: FieldNode, *_args):</span>
<span class="gi">+        field_name = node.name.value</span>
<span class="gi">+        if is_introspection_key(field_name):</span>
<span class="gi">+            self.report_error(</span>
<span class="gi">+                GraphQLError(</span>
<span class="gi">+                    f&quot;Cannot query &#39;{field_name}&#39;: introspection is disabled.&quot;, node</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>