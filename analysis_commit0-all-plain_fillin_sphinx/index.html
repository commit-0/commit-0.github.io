
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin sphinx - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-sphinx" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin sphinx
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-sphinx"><strong>Claude Sonnet 3.5 - Fill-in</strong>: sphinx</h1>
<h2 id="failed-to-run-pytests-for-test-tests">Failed to run pytests for test <code>tests</code></h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/conftest.py:15: in &lt;module&gt;
    import sphinx.pycode
sphinx/pycode/__init__.py:11: in &lt;module&gt;
    from sphinx.pycode.parser import Parser
sphinx/pycode/parser.py:15: in &lt;module&gt;
    from sphinx.pycode.ast import unparse as ast_unparse
sphinx/pycode/ast.py:20: in &lt;module&gt;
    class _UnparseVisitor(ast.NodeVisitor):
sphinx/pycode/ast.py:25: in _UnparseVisitor
    locals()[f&#39;visit_{_op.__name__}&#39;] = _visit_op
E   NameError: name &#39;_visit_op&#39; is not defined
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/sphinx/_cli/util/colour.py b/sphinx/_cli/util/colour.py</span>
<span class="gh">index 4ae735270..3b24eadc0 100644</span>
<span class="gd">--- a/sphinx/_cli/util/colour.py</span>
<span class="gi">+++ b/sphinx/_cli/util/colour.py</span>
<span class="gu">@@ -10,7 +10,13 @@ _COLOURING_DISABLED = True</span>

<span class="w"> </span>def terminal_supports_colour() -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return True if coloured terminal output is supported.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _COLOURING_DISABLED:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+        return True  # Assuming colorama is properly initialized</span>
<span class="gi">+    if hasattr(sys.stdout, &#39;isatty&#39;) and sys.stdout.isatty():</span>
<span class="gi">+        return True</span>
<span class="gi">+    return &#39;COLORTERM&#39; in os.environ</span>


<span class="w"> </span>if sys.platform == &#39;win32&#39;:
<span class="gh">diff --git a/sphinx/_cli/util/errors.py b/sphinx/_cli/util/errors.py</span>
<span class="gh">index c3e0cc08b..470a6e43d 100644</span>
<span class="gd">--- a/sphinx/_cli/util/errors.py</span>
<span class="gi">+++ b/sphinx/_cli/util/errors.py</span>
<span class="gu">@@ -11,9 +11,17 @@ _ANSI_COLOUR_CODES: re.Pattern[str] = re.compile(&#39;\x1b.*?m&#39;)</span>

<span class="w"> </span>def terminal_safe(s: str, /) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Safely encode a string for printing to the terminal.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _ANSI_COLOUR_CODES.sub(&#39;&#39;, s).encode(&#39;ascii&#39;, &#39;replace&#39;).decode(&#39;ascii&#39;)</span>


<span class="w"> </span>def save_traceback(app: (Sphinx | None), exc: BaseException) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Save the given exception&#39;s traceback in a temporary file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import traceback</span>
<span class="gi">+    </span>
<span class="gi">+    with tempfile.NamedTemporaryFile(&#39;w&#39;, delete=False, suffix=&#39;.log&#39;) as f:</span>
<span class="gi">+        traceback.print_exc(file=f)</span>
<span class="gi">+        if isinstance(exc, SphinxParallelError):</span>
<span class="gi">+            for cause in exc.causes:</span>
<span class="gi">+                f.write(&#39;\n&#39;)</span>
<span class="gi">+                traceback.print_exception(*cause, file=f)</span>
<span class="gi">+        return f.name</span>
<span class="gh">diff --git a/sphinx/addnodes.py b/sphinx/addnodes.py</span>
<span class="gh">index a277c8408..2ce6410c9 100644</span>
<span class="gd">--- a/sphinx/addnodes.py</span>
<span class="gi">+++ b/sphinx/addnodes.py</span>
<span class="gu">@@ -34,21 +34,27 @@ class translatable(nodes.Node):</span>
<span class="w"> </span>    Because they are used at final step; extraction.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def __init__(self, *args, **kwargs):</span>
<span class="gi">+        super().__init__(*args, **kwargs)</span>
<span class="gi">+        self.original_messages = []</span>
<span class="gi">+</span>
<span class="w"> </span>    def preserve_original_messages(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Preserve original translatable messages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.original_messages = [child.astext() for child in self.children if isinstance(child, nodes.TextElement)]</span>

<span class="w"> </span>    def apply_translated_message(self, original_message: str,
<span class="w"> </span>        translated_message: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Apply translated message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for i, child in enumerate(self.children):</span>
<span class="gi">+            if isinstance(child, nodes.TextElement) and child.astext() == original_message:</span>
<span class="gi">+                self.children[i] = nodes.Text(translated_message)</span>

<span class="w"> </span>    def extract_original_messages(self) -&gt;Sequence[str]:
<span class="w"> </span>        &quot;&quot;&quot;Extract translation messages.

<span class="w"> </span>        :returns: list of extracted messages or messages generator
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.original_messages</span>


<span class="w"> </span>class not_smartquotable:
<span class="gh">diff --git a/sphinx/application.py b/sphinx/application.py</span>
<span class="gh">index c0830a77e..b9387588a 100644</span>
<span class="gd">--- a/sphinx/application.py</span>
<span class="gi">+++ b/sphinx/application.py</span>
<span class="gu">@@ -206,29 +206,54 @@ class Sphinx:</span>
<span class="w"> </span>        self._init_builder()

<span class="w"> </span>    @property
<span class="gd">-    def fresh_env_used(self) -&gt;(bool | None):</span>
<span class="gi">+    @property</span>
<span class="gi">+    def fresh_env_used(self) -&gt; bool | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;True/False as to whether a new environment was created for this build,
<span class="w"> </span>        or None if the environment has not been initialised yet.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._fresh_env_used</span>

<span class="gd">-    def _init_i18n(self) -&gt;None:</span>
<span class="gi">+    def _init_i18n(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Load translated strings from the configured localedirs if enabled in
<span class="w"> </span>        the configuration.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.config.language is not None:</span>
<span class="gi">+            self.translator = locale.init([self.confdir], self.config.language)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.translator = locale.NullTranslations()</span>

<span class="gd">-    def setup_extension(self, extname: str) -&gt;None:</span>
<span class="gi">+    def setup_extension(self, extname: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Import and setup a Sphinx extension module.

<span class="w"> </span>        Load the extension given by the module *name*.  Use this if your
<span class="w"> </span>        extension needs the features provided by another extension.  No-op if
<span class="w"> </span>        called twice.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if extname in self.extensions:</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            mod = __import__(extname, None, None, [&#39;setup&#39;])</span>
<span class="gi">+        except ImportError as err:</span>
<span class="gi">+            logger.warning(__(&#39;Failed to import extension %s&#39;), extname)</span>
<span class="gi">+            logger.warning(__(&#39;The error was: %s&#39;), err)</span>
<span class="gi">+            return</span>
<span class="gi">+        if not hasattr(mod, &#39;setup&#39;):</span>
<span class="gi">+            logger.warning(__(&#39;Extension %s has no setup() function; is it really &#39;</span>
<span class="gi">+                              &#39;a Sphinx extension module?&#39;), extname)</span>
<span class="gi">+            return</span>
<span class="gi">+        if extname in self.extensions:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            mod.setup(self)</span>
<span class="gi">+        except Exception as err:</span>
<span class="gi">+            logger.error(__(&#39;Failed to setup extension: %s&#39;), extname)</span>
<span class="gi">+            logger.error(__(&#39;The error was: %s&#39;), err)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.extensions[extname] = mod</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def require_sphinx(version: (tuple[int, int] | str)) -&gt;None:</span>
<span class="gi">+    def require_sphinx(version: tuple[int, int] | str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check the Sphinx version if requested.

<span class="w"> </span>        Compare *version* with the version of the running Sphinx, and abort the
<span class="gu">@@ -241,9 +266,17 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 7.1
<span class="w"> </span>           Type of *version* now allows ``(major, minor)`` form.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(version, str):</span>
<span class="gi">+            version = tuple(int(x) for x in version.split(&#39;.&#39;))</span>
<span class="gi">+        elif not isinstance(version, tuple):</span>
<span class="gi">+            raise TypeError(&#39;version must be a string or a tuple&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if version &gt; sphinx.__display_version__[:2]:</span>
<span class="gi">+            raise VersionRequirementError(</span>
<span class="gi">+                __(&#39;This project needs at least Sphinx v%s and therefore cannot &#39;</span>
<span class="gi">+                   &#39;be built with this version.&#39;) % &#39;.&#39;.join(map(str, version)))</span>

<span class="gd">-    def connect(self, event: str, callback: Callable, priority: int=500) -&gt;int:</span>
<span class="gi">+    def connect(self, event: str, callback: Callable, priority: int = 500) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register *callback* to be called when *event* is emitted.

<span class="w"> </span>        For details on available core events and the arguments of callback
<span class="gu">@@ -259,17 +292,16 @@ class Sphinx:</span>

<span class="w"> </span>           Support *priority*
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.events.connect(event, callback, priority)</span>

<span class="gd">-    def disconnect(self, listener_id: int) -&gt;None:</span>
<span class="gi">+    def disconnect(self, listener_id: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Unregister callback by *listener_id*.

<span class="w"> </span>        :param listener_id: A listener_id that :meth:`connect` returns
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.events.disconnect(listener_id)</span>

<span class="gd">-    def emit(self, event: str, *args: Any, allowed_exceptions: tuple[type[</span>
<span class="gd">-        Exception], ...]=()) -&gt;list:</span>
<span class="gi">+    def emit(self, event: str, *args: Any, allowed_exceptions: tuple[type[Exception], ...] = ()) -&gt; list:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit *event* and pass *arguments* to the callback functions.

<span class="w"> </span>        Return the return values of all callbacks as a list.  Do not emit core
<span class="gu">@@ -283,10 +315,9 @@ class Sphinx:</span>

<span class="w"> </span>           Added *allowed_exceptions* to specify path-through exceptions
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.events.emit(event, *args, allowed_exceptions=allowed_exceptions)</span>

<span class="gd">-    def emit_firstresult(self, event: str, *args: Any, allowed_exceptions:</span>
<span class="gd">-        tuple[type[Exception], ...]=()) -&gt;Any:</span>
<span class="gi">+    def emit_firstresult(self, event: str, *args: Any, allowed_exceptions: tuple[type[Exception], ...] = ()) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit *event* and pass *arguments* to the callback functions.

<span class="w"> </span>        Return the result of the first callback that doesn&#39;t return ``None``.
<span class="gu">@@ -300,7 +331,7 @@ class Sphinx:</span>

<span class="w"> </span>           Added *allowed_exceptions* to specify path-through exceptions
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.events.emit_firstresult(event, *args, allowed_exceptions=allowed_exceptions)</span>

<span class="w"> </span>    def add_builder(self, builder: type[Builder], override: bool=False) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Register a new builder.
<span class="gh">diff --git a/sphinx/builders/_epub_base.py b/sphinx/builders/_epub_base.py</span>
<span class="gh">index aa543c3e3..972f8461f 100644</span>
<span class="gd">--- a/sphinx/builders/_epub_base.py</span>
<span class="gi">+++ b/sphinx/builders/_epub_base.py</span>
<span class="gu">@@ -99,27 +99,55 @@ class EpubBuilder(StandaloneHTMLBuilder):</span>

<span class="w"> </span>    def make_id(self, name: str) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return a unique id for name.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.make_id_from_string(name)</span>

<span class="w"> </span>    def get_refnodes(self, doctree: Node, result: list[dict[str, Any]]) -&gt;list[
<span class="w"> </span>        dict[str, Any]]:
<span class="w"> </span>        &quot;&quot;&quot;Collect section titles, their depth in the toc and the refuri.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for node in doctree.traverse(nodes.section):</span>
<span class="gi">+            nodetext = node.astext().strip()</span>
<span class="gi">+            if not nodetext:</span>
<span class="gi">+                continue</span>
<span class="gi">+            result.append({</span>
<span class="gi">+                &#39;level&#39;: int(node[&#39;ids&#39;][0].split(&#39;-&#39;)[1]),</span>
<span class="gi">+                &#39;refuri&#39;: node[&#39;ids&#39;][0],</span>
<span class="gi">+                &#39;title&#39;: nodetext,</span>
<span class="gi">+            })</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def get_toc(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Get the total table of contents, containing the root_doc
<span class="w"> </span>        and pre and post files not managed by sphinx.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        doctree = self.env.get_and_resolve_doctree(self.config.root_doc, self)</span>
<span class="gi">+        refnodes = self.get_refnodes(doctree, [])</span>
<span class="gi">+        self.toc_add_files(refnodes)</span>
<span class="gi">+        self.toc = refnodes</span>

<span class="w"> </span>    def toc_add_files(self, refnodes: list[dict[str, Any]]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add the root_doc, pre and post files to a list of refnodes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        refnodes.insert(0, {</span>
<span class="gi">+            &#39;level&#39;: 1,</span>
<span class="gi">+            &#39;refuri&#39;: self.config.root_doc,</span>
<span class="gi">+            &#39;title&#39;: self.config.project,</span>
<span class="gi">+        })</span>
<span class="gi">+        for docname in self.config.epub_pre_files:</span>
<span class="gi">+            refnodes.append({</span>
<span class="gi">+                &#39;level&#39;: 1,</span>
<span class="gi">+                &#39;refuri&#39;: docname,</span>
<span class="gi">+                &#39;title&#39;: self.env.titles[docname].astext(),</span>
<span class="gi">+            })</span>
<span class="gi">+        for docname in self.config.epub_post_files:</span>
<span class="gi">+            refnodes.append({</span>
<span class="gi">+                &#39;level&#39;: 1,</span>
<span class="gi">+                &#39;refuri&#39;: docname,</span>
<span class="gi">+                &#39;title&#39;: self.env.titles[docname].astext(),</span>
<span class="gi">+            })</span>

<span class="w"> </span>    def fix_fragment(self, prefix: str, fragment: str) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return a href/id attribute with colons replaced by hyphens.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return prefix + fragment.replace(&#39;:&#39;, &#39;-&#39;)</span>

<span class="w"> </span>    def fix_ids(self, tree: nodes.document) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Replace colons with hyphens in href and id attributes.
<span class="gu">@@ -127,12 +155,38 @@ class EpubBuilder(StandaloneHTMLBuilder):</span>
<span class="w"> </span>        Some readers crash because they interpret the part as a
<span class="w"> </span>        transport protocol specification.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for node in tree.traverse(nodes.reference):</span>
<span class="gi">+            if &#39;refuri&#39; in node:</span>
<span class="gi">+                m = self.refuri_re.match(node[&#39;refuri&#39;])</span>
<span class="gi">+                if m:</span>
<span class="gi">+                    node[&#39;refuri&#39;] = self.fix_fragment(m.group(1), m.group(2))</span>
<span class="gi">+            if &#39;refid&#39; in node:</span>
<span class="gi">+                node[&#39;refid&#39;] = self.fix_fragment(&#39;&#39;, node[&#39;refid&#39;])</span>
<span class="gi">+        for node in tree.traverse(addnodes.desc_signature):</span>
<span class="gi">+            ids = node.attributes[&#39;ids&#39;]</span>
<span class="gi">+            newids = []</span>
<span class="gi">+            for id in ids:</span>
<span class="gi">+                newids.append(self.fix_fragment(&#39;&#39;, id))</span>
<span class="gi">+            node.attributes[&#39;ids&#39;] = newids</span>

<span class="w"> </span>    def add_visible_links(self, tree: nodes.document, show_urls: str=&#39;inline&#39;
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add visible link targets for external links&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for node in tree.traverse(nodes.reference):</span>
<span class="gi">+            uri = node.get(&#39;refuri&#39;, &#39;&#39;)</span>
<span class="gi">+            if uri.startswith(&#39;http:&#39;) or uri.startswith(&#39;https:&#39;) or uri.startswith(&#39;ftp:&#39;):</span>
<span class="gi">+                if uri == node.astext():</span>
<span class="gi">+                    continue</span>
<span class="gi">+                idx = node.parent.index(node)</span>
<span class="gi">+                if show_urls == &#39;inline&#39;:</span>
<span class="gi">+                    uri_node = nodes.inline(uri, &#39; (%s)&#39; % uri, classes=[&#39;link-target&#39;])</span>
<span class="gi">+                    node.parent.insert(idx + 1, uri_node)</span>
<span class="gi">+                elif show_urls == &#39;footnote&#39;:</span>
<span class="gi">+                    uri_node = nodes.footnote_reference(&#39;[#]_&#39;, refname=uri)</span>
<span class="gi">+                    node.parent.insert(idx + 1, uri_node)</span>
<span class="gi">+                    footnote = nodes.footnote(&#39;&#39;, nodes.paragraph(&#39;&#39;, uri))</span>
<span class="gi">+                    footnote.insert(0, nodes.label(&#39;&#39;, &#39;#&#39;))</span>
<span class="gi">+                    tree.append(footnote)</span>

<span class="w"> </span>    def write_doc(self, docname: str, doctree: nodes.document) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Write one document file.
<span class="gu">@@ -140,29 +194,49 @@ class EpubBuilder(StandaloneHTMLBuilder):</span>
<span class="w"> </span>        This method is overwritten in order to fix fragment identifiers
<span class="w"> </span>        and to add visible external links.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.fix_ids(doctree)</span>
<span class="gi">+        self.add_visible_links(doctree, self.config.epub_show_urls)</span>
<span class="gi">+        super().write_doc(docname, doctree)</span>

<span class="w"> </span>    def fix_genindex(self, tree: list[tuple[str, list[tuple[str, Any]]]]
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Fix href attributes for genindex pages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for _, entries in tree:</span>
<span class="gi">+            for entry in entries:</span>
<span class="gi">+                if isinstance(entry, tuple):</span>
<span class="gi">+                    for idx, href in enumerate(entry[1]):</span>
<span class="gi">+                        if href:</span>
<span class="gi">+                            entry[1][idx] = self.fix_fragment(&#39;&#39;, href)</span>

<span class="w"> </span>    def is_vector_graphics(self, filename: str) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Does the filename extension indicate a vector graphic format?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return any(filename.endswith(ext) for ext in VECTOR_GRAPHICS_EXTENSIONS)</span>

<span class="w"> </span>    def copy_image_files_pil(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Copy images using Pillow, the Python Imaging Library.
<span class="w"> </span>        The method tries to read and write the files with Pillow, converting
<span class="w"> </span>        the format and resizing the image if necessary/possible.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not PILLOW_AVAILABLE:</span>
<span class="gi">+            return</span>
<span class="gi">+        for src in status_iterator(self.images, __(&#39;copying images... &#39;), &quot;brown&quot;,</span>
<span class="gi">+                                   len(self.images), self.app.verbosity):</span>
<span class="gi">+            dest = path.join(self.outdir, self.images[src])</span>
<span class="gi">+            try:</span>
<span class="gi">+                img = Image.open(path.join(self.srcdir, src))</span>
<span class="gi">+                img.save(dest)</span>
<span class="gi">+            except Exception as err:</span>
<span class="gi">+                logger.warning(__(&#39;cannot read image file %r: %s&#39;), src, err)</span>
<span class="gi">+                copyfile(path.join(self.srcdir, src), dest)</span>

<span class="w"> </span>    def copy_image_files(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Copy image files to destination directory.
<span class="w"> </span>        This overwritten method can use Pillow to convert image files.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if PILLOW_AVAILABLE:</span>
<span class="gi">+            self.copy_image_files_pil()</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().copy_image_files()</span>

<span class="w"> </span>    def handle_page(self, pagename: str, addctx: dict[str, Any],
<span class="w"> </span>        templatename: str=&#39;page.html&#39;, outfilename: (str | None)=None,
<span class="gu">@@ -172,15 +246,29 @@ class EpubBuilder(StandaloneHTMLBuilder):</span>
<span class="w"> </span>        This method is overwritten for genindex pages in order to fix href link
<span class="w"> </span>        attributes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if pagename.startswith(&#39;genindex&#39;):</span>
<span class="gi">+            self.fix_genindex(addctx[&#39;genindexentries&#39;])</span>
<span class="gi">+        super().handle_page(pagename, addctx, templatename, outfilename, event_arg)</span>

<span class="w"> </span>    def build_mimetype(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Write the metainfo file mimetype.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(path.join(self.outdir, &#39;mimetype&#39;), &#39;w&#39;, encoding=&#39;ascii&#39;) as f:</span>
<span class="gi">+            f.write(&#39;application/epub+zip&#39;)</span>

<span class="w"> </span>    def build_container(self, outname: str=&#39;META-INF/container.xml&#39;) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Write the metainfo file META-INF/container.xml.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        container_path = path.join(self.outdir, &#39;META-INF&#39;)</span>
<span class="gi">+        ensuredir(container_path)</span>
<span class="gi">+        container = path.join(container_path, &#39;container.xml&#39;)</span>
<span class="gi">+        with open(container, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+            f.write(&#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&#39;)</span>
<span class="gi">+            f.write(&#39;&lt;container version=&quot;1.0&quot;\n&#39;)</span>
<span class="gi">+            f.write(&#39;      xmlns=&quot;urn:oasis:names:tc:opendocument:xmlns:container&quot;&gt;\n&#39;)</span>
<span class="gi">+            f.write(&#39;  &lt;rootfiles&gt;\n&#39;)</span>
<span class="gi">+            f.write(&#39;    &lt;rootfile full-path=&quot;content.opf&quot;\n&#39;)</span>
<span class="gi">+            f.write(&#39;      media-type=&quot;application/oebps-package+xml&quot;/&gt;\n&#39;)</span>
<span class="gi">+            f.write(&#39;  &lt;/rootfiles&gt;\n&#39;)</span>
<span class="gi">+            f.write(&#39;&lt;/container&gt;\n&#39;)</span>

<span class="w"> </span>    def content_metadata(self) -&gt;dict[str, Any]:
<span class="w"> </span>        &quot;&quot;&quot;Create a dictionary with all metadata for the content.opf
<span class="gh">diff --git a/sphinx/builders/epub3.py b/sphinx/builders/epub3.py</span>
<span class="gh">index aecaf3dbc..c34f6a5bd 100644</span>
<span class="gd">--- a/sphinx/builders/epub3.py</span>
<span class="gi">+++ b/sphinx/builders/epub3.py</span>
<span class="gu">@@ -61,13 +61,27 @@ class Epub3Builder(_epub_base.EpubBuilder):</span>

<span class="w"> </span>    def handle_finish(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Create the metainfo files and finally the epub.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.get_toc()</span>
<span class="gi">+        self.build_mimetype()</span>
<span class="gi">+        self.build_container()</span>
<span class="gi">+        self.build_content()</span>
<span class="gi">+        self.build_navigation_doc()</span>
<span class="gi">+        self.build_toc()</span>
<span class="gi">+        self.build_epub()</span>

<span class="w"> </span>    def content_metadata(self) -&gt;dict[str, Any]:
<span class="w"> </span>        &quot;&quot;&quot;Create a dictionary with all metadata for the content.opf
<span class="w"> </span>        file properly escaped.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        metadata = super().content_metadata()</span>
<span class="gi">+        metadata[&#39;epub_version&#39;] = &#39;3.0&#39;</span>
<span class="gi">+        metadata[&#39;page_progression_direction&#39;] = PAGE_PROGRESSION_DIRECTIONS.get(</span>
<span class="gi">+            self.config.epub_writing_mode, &#39;default&#39;)</span>
<span class="gi">+        metadata[&#39;ibook_scroll_axis&#39;] = IBOOK_SCROLL_AXIS.get(</span>
<span class="gi">+            self.config.epub_writing_mode, &#39;default&#39;)</span>
<span class="gi">+        metadata[&#39;writing_mode&#39;] = THEME_WRITING_MODES.get(</span>
<span class="gi">+            self.config.epub_writing_mode, &#39;horizontal-tb&#39;)</span>
<span class="gi">+        return metadata</span>

<span class="w"> </span>    def build_navlist(self, navnodes: list[dict[str, Any]]) -&gt;list[NavPoint]:
<span class="w"> </span>        &quot;&quot;&quot;Create the toc navigation structure.
<span class="gu">@@ -79,20 +93,45 @@ class Epub3Builder(_epub_base.EpubBuilder):</span>
<span class="w"> </span>        The difference from build_navpoints method is templates which are used
<span class="w"> </span>        when generating navigation documents.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def build_navpoint(node: dict[str, Any]) -&gt;NavPoint:</span>
<span class="gi">+            text = html.escape(node[&#39;text&#39;])</span>
<span class="gi">+            refuri = node[&#39;refuri&#39;]</span>
<span class="gi">+            children = [build_navpoint(child) for child in node.get(&#39;children&#39;, [])]</span>
<span class="gi">+            return NavPoint(text=text, refuri=refuri, children=children)</span>

<span class="gd">-    def navigation_doc_metadata(self, navlist: list[NavPoint]) -&gt;dict[str, Any</span>
<span class="gd">-        ]:</span>
<span class="gi">+        return [build_navpoint(node) for node in navnodes]</span>
<span class="gi">+</span>
<span class="gi">+    def navigation_doc_metadata(self, navlist: list[NavPoint]) -&gt;dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a dictionary with all metadata for the nav.xhtml file
<span class="w"> </span>        properly escaped.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        metadata = {}</span>
<span class="gi">+        metadata[&#39;lang&#39;] = self.config.language</span>
<span class="gi">+        metadata[&#39;toc_locale&#39;] = self.guide_titles[&#39;toc&#39;]</span>
<span class="gi">+        metadata[&#39;navlist&#39;] = navlist</span>
<span class="gi">+        return metadata</span>

<span class="w"> </span>    def build_navigation_doc(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Write the metainfo file nav.xhtml.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.info(__(&#39;writing nav.xhtml file...&#39;))</span>
<span class="gi">+        navlist = self.build_navlist(self.refnodes)</span>
<span class="gi">+        metadata = self.navigation_doc_metadata(navlist)</span>
<span class="gi">+        navigation = self.render_template(&#39;nav.xhtml&#39;, metadata)</span>
<span class="gi">+        with open(path.join(self.outdir, &#39;nav.xhtml&#39;), &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+            f.write(navigation)</span>


<span class="w"> </span>def convert_epub_css_files(app: Sphinx, config: Config) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Convert string styled epub_css_files to tuple styled one.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    epub_css_files = []</span>
<span class="gi">+    for entry in config.epub_css_files:</span>
<span class="gi">+        if isinstance(entry, str):</span>
<span class="gi">+            epub_css_files.append((entry, {}))</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                filename, attrs = entry</span>
<span class="gi">+                epub_css_files.append((filename, attrs))</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                logger.warning(__(&#39;invalid css_file: %r, ignored&#39;), entry)</span>
<span class="gi">+                continue</span>
<span class="gi">+    config.epub_css_files = epub_css_files</span>
<span class="gh">diff --git a/sphinx/builders/gettext.py b/sphinx/builders/gettext.py</span>
<span class="gh">index 4b4b24de7..df6453c5e 100644</span>
<span class="gd">--- a/sphinx/builders/gettext.py</span>
<span class="gi">+++ b/sphinx/builders/gettext.py</span>
<span class="gu">@@ -113,7 +113,12 @@ ctime = time.strftime(&#39;%Y-%m-%d %H:%M%z&#39;, timestamp)</span>

<span class="w"> </span>def _is_node_in_substitution_definition(node: nodes.Node) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check &quot;node&quot; to test if it is in a substitution definition.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parent = node.parent</span>
<span class="gi">+    while parent:</span>
<span class="gi">+        if isinstance(parent, nodes.substitution_definition):</span>
<span class="gi">+            return True</span>
<span class="gi">+        parent = parent.parent</span>
<span class="gi">+    return False</span>


<span class="w"> </span>class MessageCatalogBuilder(I18nBuilder):
<span class="gh">diff --git a/sphinx/builders/html/_build_info.py b/sphinx/builders/html/_build_info.py</span>
<span class="gh">index 124c16e83..9c320213a 100644</span>
<span class="gd">--- a/sphinx/builders/html/_build_info.py</span>
<span class="gi">+++ b/sphinx/builders/html/_build_info.py</span>
<span class="gu">@@ -41,4 +41,17 @@ def _stable_hash(obj: Any) -&gt;str:</span>
<span class="w"> </span>    We can&#39;t just use the md5 of str(obj) as the order of collections
<span class="w"> </span>    may be random.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def _hash_helper(o):</span>
<span class="gi">+        if isinstance(o, (str, int, float, bool, type(None))):</span>
<span class="gi">+            return str(o)</span>
<span class="gi">+        elif isinstance(o, (list, tuple)):</span>
<span class="gi">+            return &#39;[&#39; + &#39;,&#39;.join(_hash_helper(i) for i in o) + &#39;]&#39;</span>
<span class="gi">+        elif isinstance(o, dict):</span>
<span class="gi">+            return &#39;{&#39; + &#39;,&#39;.join(f&#39;{_hash_helper(k)}:{_hash_helper(v)}&#39; for k, v in sorted(o.items())) + &#39;}&#39;</span>
<span class="gi">+        elif isinstance(o, set):</span>
<span class="gi">+            return &#39;{&#39; + &#39;,&#39;.join(_hash_helper(i) for i in sorted(o)) + &#39;}&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Unhashable type: {type(o)}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    stable_str = _hash_helper(obj)</span>
<span class="gi">+    return hashlib.md5(stable_str.encode(&#39;utf-8&#39;)).hexdigest()</span>
<span class="gh">diff --git a/sphinx/builders/latex/nodes.py b/sphinx/builders/latex/nodes.py</span>
<span class="gh">index cdf9949a3..73a483b07 100644</span>
<span class="gd">--- a/sphinx/builders/latex/nodes.py</span>
<span class="gi">+++ b/sphinx/builders/latex/nodes.py</span>
<span class="gu">@@ -4,27 +4,39 @@ from docutils import nodes</span>

<span class="w"> </span>class captioned_literal_block(nodes.container):
<span class="w"> </span>    &quot;&quot;&quot;A node for a container of literal_block having a caption.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    def __init__(self, rawsource=&#39;&#39;, *children, **attributes):</span>
<span class="gi">+        super().__init__(rawsource, *children, **attributes)</span>
<span class="gi">+        self.caption = None</span>


<span class="w"> </span>class footnotemark(nodes.Inline, nodes.Referential, nodes.TextElement):
<span class="w"> </span>    &quot;&quot;&quot;A node represents ``\\footnotemark``.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    def __init__(self, rawsource=&#39;&#39;, text=&#39;&#39;, *children, **attributes):</span>
<span class="gi">+        super().__init__(rawsource, text, *children, **attributes)</span>


<span class="gd">-class footnotetext(nodes.General, nodes.BackLinkable, nodes.Element, nodes.</span>
<span class="gd">-    Labeled, nodes.Targetable):</span>
<span class="gi">+class footnotetext(nodes.General, nodes.BackLinkable, nodes.Element, nodes.Labeled, nodes.Targetable):</span>
<span class="w"> </span>    &quot;&quot;&quot;A node represents ``\\footnotetext``.&quot;&quot;&quot;
<span class="gi">+    </span>
<span class="gi">+    def __init__(self, rawsource=&#39;&#39;, *children, **attributes):</span>
<span class="gi">+        super().__init__(rawsource, *children, **attributes)</span>


<span class="w"> </span>class math_reference(nodes.Inline, nodes.Referential, nodes.TextElement):
<span class="w"> </span>    &quot;&quot;&quot;A node for a reference for equation.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    def __init__(self, rawsource=&#39;&#39;, text=&#39;&#39;, *children, **attributes):</span>
<span class="gi">+        super().__init__(rawsource, text, *children, **attributes)</span>
<span class="gi">+        self.equation_number = None</span>


<span class="w"> </span>class thebibliography(nodes.container):
<span class="w"> </span>    &quot;&quot;&quot;A node for wrapping bibliographies.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    def __init__(self, rawsource=&#39;&#39;, *children, **attributes):</span>
<span class="gi">+        super().__init__(rawsource, *children, **attributes)</span>


<span class="w"> </span>HYPERLINK_SUPPORT_NODES = (nodes.figure, nodes.literal_block, nodes.table,
<span class="gh">diff --git a/sphinx/builders/latex/theming.py b/sphinx/builders/latex/theming.py</span>
<span class="gh">index 671dc8ff2..7caa70864 100644</span>
<span class="gd">--- a/sphinx/builders/latex/theming.py</span>
<span class="gi">+++ b/sphinx/builders/latex/theming.py</span>
<span class="gu">@@ -88,12 +88,22 @@ class ThemeFactory:</span>

<span class="w"> </span>    def load_builtin_themes(self, config: Config) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Load built-in themes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name in (&#39;manual&#39;, &#39;howto&#39;):</span>
<span class="gi">+            self.themes[name] = BuiltInTheme(name, config)</span>

<span class="w"> </span>    def get(self, name: str) -&gt;Theme:
<span class="w"> </span>        &quot;&quot;&quot;Get a theme for given *name*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name not in self.themes:</span>
<span class="gi">+            theme = self.find_user_theme(name)</span>
<span class="gi">+            if theme is None:</span>
<span class="gi">+                raise ThemeError(__(&#39;LaTeX theme %r not found&#39;) % name)</span>
<span class="gi">+            self.themes[name] = theme</span>
<span class="gi">+        return self.themes[name]</span>

<span class="w"> </span>    def find_user_theme(self, name: str) -&gt;(Theme | None):
<span class="w"> </span>        &quot;&quot;&quot;Find a theme named as *name* from latex_theme_path.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for theme_path in self.theme_paths:</span>
<span class="gi">+            theme_file = path.join(theme_path, name + &#39;.ini&#39;)</span>
<span class="gi">+            if path.exists(theme_file):</span>
<span class="gi">+                return UserTheme(name, theme_file)</span>
<span class="gi">+        return None</span>
<span class="gh">diff --git a/sphinx/builders/latex/util.py b/sphinx/builders/latex/util.py</span>
<span class="gh">index b909a8426..b896b2e9e 100644</span>
<span class="gd">--- a/sphinx/builders/latex/util.py</span>
<span class="gi">+++ b/sphinx/builders/latex/util.py</span>
<span class="gu">@@ -13,6 +13,18 @@ class ExtBabel(Babel):</span>
<span class="w"> </span>        self.supported = True
<span class="w"> </span>        super().__init__(language_code)

<span class="gd">-    def get_mainlanguage_options(self) -&gt;(str | None):</span>
<span class="gi">+    def get_mainlanguage_options(self) -&gt; (str | None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Return options for polyglossia&#39;s ``\\setmainlanguage``.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.use_polyglossia:</span>
<span class="gi">+            return None</span>
<span class="gi">+        </span>
<span class="gi">+        if self.language_code == &#39;english&#39;:</span>
<span class="gi">+            return &#39;variant=american&#39;</span>
<span class="gi">+        elif self.language_code in self.cyrillic_languages:</span>
<span class="gi">+            return &#39;babelshorthands=true&#39;</span>
<span class="gi">+        elif self.language_code == &#39;greek&#39;:</span>
<span class="gi">+            return &#39;variant=poly&#39;</span>
<span class="gi">+        elif self.language_code == &#39;sanskrit&#39;:</span>
<span class="gi">+            return &#39;script=Devanagari&#39;</span>
<span class="gi">+        </span>
<span class="gi">+        return None</span>
<span class="gh">diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py</span>
<span class="gh">index 14686b733..a54821f1f 100644</span>
<span class="gd">--- a/sphinx/builders/linkcheck.py</span>
<span class="gi">+++ b/sphinx/builders/linkcheck.py</span>
<span class="gu">@@ -64,7 +64,11 @@ class HyperlinkCollector(SphinxPostTransform):</span>
<span class="w"> </span>        :param node: A node class
<span class="w"> </span>        :returns: URI of the node
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node, nodes.reference):</span>
<span class="gi">+            return node.get(&#39;refuri&#39;)</span>
<span class="gi">+        elif isinstance(node, nodes.image):</span>
<span class="gi">+            return node.get(&#39;uri&#39;)</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def _add_uri(self, uri: str, node: nodes.Element) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Registers a node&#39;s URI into a builder&#39;s collection of hyperlinks.
<span class="gu">@@ -77,7 +81,17 @@ class HyperlinkCollector(SphinxPostTransform):</span>
<span class="w"> </span>        :param uri: URI to add
<span class="w"> </span>        :param node: A node class where the URI was found
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if uri is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        docname = self.env.docname</span>
<span class="gi">+        docpath = self.env.doc2path(docname)</span>
<span class="gi">+        lineno = get_node_line(node)</span>
<span class="gi">+</span>
<span class="gi">+        self.app.emit(&#39;linkcheck-process-uri&#39;, uri)</span>
<span class="gi">+</span>
<span class="gi">+        if uri not in self.builder.hyperlinks:</span>
<span class="gi">+            self.builder.hyperlinks[uri] = Hyperlink(uri, docname, docpath, lineno)</span>


<span class="w"> </span>class Hyperlink(NamedTuple):
<span class="gu">@@ -152,7 +166,9 @@ class HyperlinkAvailabilityCheckWorker(Thread):</span>

<span class="w"> </span>def contains_anchor(response: Response, anchor: str) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Determine if an anchor is contained within an HTTP response.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parser = AnchorCheckParser(anchor)</span>
<span class="gi">+    parser.feed(response.text)</span>
<span class="gi">+    return parser.found</span>


<span class="w"> </span>class AnchorCheckParser(HTMLParser):
<span class="gu">@@ -175,9 +191,35 @@ def rewrite_github_anchor(app: Sphinx, uri: str) -&gt;(str | None):</span>
<span class="w"> </span>    The hyperlink anchors in github.com are dynamically generated.  This rewrites
<span class="w"> </span>    them before checking and makes them comparable.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parsed = urlparse(uri)</span>
<span class="gi">+    if parsed.hostname != &#39;github.com&#39;:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    path = parsed.path</span>
<span class="gi">+    fragment = unquote(parsed.fragment)</span>
<span class="gi">+    if not fragment:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    # rewrite anchor</span>
<span class="gi">+    if fragment.isdigit():</span>
<span class="gi">+        # for headings like: #L10</span>
<span class="gi">+        fragment = &#39;L&#39; + fragment</span>
<span class="gi">+    elif fragment.startswith(&#39;L&#39;):</span>
<span class="gi">+        # for headings like: #L10-L20</span>
<span class="gi">+        fragment = fragment.upper()</span>
<span class="gi">+    else:</span>
<span class="gi">+        # for headings like: #heading-1</span>
<span class="gi">+        fragment = fragment.lower()</span>
<span class="gi">+        fragment = re.sub(r&#39;[^\w\- ]&#39;, &#39;&#39;, fragment)</span>
<span class="gi">+        fragment = re.sub(r&#39;\s+&#39;, &#39;-&#39;, fragment)</span>
<span class="gi">+</span>
<span class="gi">+    result = urlunparse(parsed._replace(fragment=quote(fragment)))</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def compile_linkcheck_allowed_redirects(app: Sphinx, config: Config) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Compile patterns in linkcheck_allowed_redirects to the regexp objects.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    allowed_redirects = {}</span>
<span class="gi">+    for pattern, allowed_pattern in config.linkcheck_allowed_redirects.items():</span>
<span class="gi">+        allowed_redirects[re.compile(pattern)] = re.compile(allowed_pattern)</span>
<span class="gi">+    config.linkcheck_allowed_redirects = allowed_redirects</span>
<span class="gh">diff --git a/sphinx/builders/manpage.py b/sphinx/builders/manpage.py</span>
<span class="gh">index 20bdcc04a..f573e83fb 100644</span>
<span class="gd">--- a/sphinx/builders/manpage.py</span>
<span class="gi">+++ b/sphinx/builders/manpage.py</span>
<span class="gu">@@ -32,7 +32,8 @@ class ManualPageBuilder(Builder):</span>
<span class="w"> </span>    supported_image_types: list[str] = []


<span class="gd">-def default_man_pages(config: Config) -&gt;list[tuple[str, str, str, list[str],</span>
<span class="gd">-    int]]:</span>
<span class="gi">+def default_man_pages(config: Config) -&gt; list[tuple[str, str, str, list[str], int]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Better default man_pages settings.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    project_name = make_filename_from_project(config.project)</span>
<span class="gi">+    return [(project_name, project_name, config.project,</span>
<span class="gi">+             [config.author], 1)]</span>
<span class="gh">diff --git a/sphinx/builders/texinfo.py b/sphinx/builders/texinfo.py</span>
<span class="gh">index e7442b2f8..3aafb28db 100644</span>
<span class="gd">--- a/sphinx/builders/texinfo.py</span>
<span class="gi">+++ b/sphinx/builders/texinfo.py</span>
<span class="gu">@@ -49,4 +49,13 @@ Run &#39;make&#39; in that directory to run these through makeinfo</span>
<span class="w"> </span>def default_texinfo_documents(config: Config) -&gt;list[tuple[str, str, str,
<span class="w"> </span>    str, str, str, str]]:
<span class="w"> </span>    &quot;&quot;&quot;Better default texinfo_documents settings.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [</span>
<span class="gi">+        (config.root_doc,  # startdocname</span>
<span class="gi">+         make_filename_from_project(config.project),  # targetname</span>
<span class="gi">+         config.project,  # title</span>
<span class="gi">+         config.author,  # author</span>
<span class="gi">+         config.project,  # dir_entry</span>
<span class="gi">+         &#39;&#39;,  # description</span>
<span class="gi">+         config.release or config.version,  # category</span>
<span class="gi">+         )</span>
<span class="gi">+    ]</span>
<span class="gh">diff --git a/sphinx/cmd/build.py b/sphinx/cmd/build.py</span>
<span class="gh">index a2aa5c5f4..403bea517 100644</span>
<span class="gd">--- a/sphinx/cmd/build.py</span>
<span class="gi">+++ b/sphinx/cmd/build.py</span>
<span class="gu">@@ -37,17 +37,57 @@ def jobs_argument(value: str) -&gt;int:</span>
<span class="w"> </span>    be expanded to handle other special scaling requests, such as setting job count
<span class="w"> </span>    to cpu_count.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value.lower() == &#39;auto&#39;:</span>
<span class="gi">+        return multiprocessing.cpu_count()</span>
<span class="gi">+    try:</span>
<span class="gi">+        jobs = int(value)</span>
<span class="gi">+        if jobs &lt;= 0:</span>
<span class="gi">+            raise ValueError</span>
<span class="gi">+        return jobs</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise argparse.ArgumentTypeError(f&quot;&#39;{value}&#39; is not a positive integer or &#39;auto&#39;&quot;)</span>


<span class="w"> </span>def make_main(argv: Sequence[str]) -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Sphinx build &quot;make mode&quot; entry.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not argv:</span>
<span class="gi">+        print(&quot;Usage: sphinx-build -M &lt;builder&gt; &lt;sourcedir&gt; &lt;outputdir&gt; [options]&quot;)</span>
<span class="gi">+        return 1</span>
<span class="gi">+    </span>
<span class="gi">+    builder = argv[0]</span>
<span class="gi">+    sourcedir = argv[1] if len(argv) &gt; 1 else &#39;.&#39;</span>
<span class="gi">+    outputdir = argv[2] if len(argv) &gt; 2 else &#39;build&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    try:</span>
<span class="gi">+        with docutils_namespace():</span>
<span class="gi">+            app = Sphinx(sourcedir, sourcedir, outputdir, outputdir, builder)</span>
<span class="gi">+            app.build()</span>
<span class="gi">+        return 0</span>
<span class="gi">+    except Exception as exc:</span>
<span class="gi">+        print(f&quot;Error: {exc}&quot;)</span>
<span class="gi">+        return 1</span>


<span class="w"> </span>def build_main(argv: Sequence[str]) -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Sphinx build &quot;main&quot; command-line entry.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parser = argparse.ArgumentParser(description=&quot;Sphinx documentation builder&quot;)</span>
<span class="gi">+    parser.add_argument(&#39;sourcedir&#39;, help=&quot;Source directory&quot;)</span>
<span class="gi">+    parser.add_argument(&#39;outputdir&#39;, help=&quot;Output directory&quot;)</span>
<span class="gi">+    parser.add_argument(&#39;-b&#39;, &#39;--builder&#39;, default=&#39;html&#39;, help=&quot;Builder to use (default: html)&quot;)</span>
<span class="gi">+    parser.add_argument(&#39;-j&#39;, &#39;--jobs&#39;, type=jobs_argument, default=1, help=&quot;Number of parallel jobs&quot;)</span>
<span class="gi">+    parser.add_argument(&#39;-v&#39;, &#39;--verbose&#39;, action=&#39;store_true&#39;, help=&quot;Increase verbosity&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    args = parser.parse_args(argv)</span>
<span class="gi">+    </span>
<span class="gi">+    try:</span>
<span class="gi">+        with docutils_namespace():</span>
<span class="gi">+            app = Sphinx(args.sourcedir, args.sourcedir, args.outputdir, args.outputdir, args.builder,</span>
<span class="gi">+                         parallel=args.jobs, verbosity=2 if args.verbose else 1)</span>
<span class="gi">+            app.build()</span>
<span class="gi">+        return 0</span>
<span class="gi">+    except Exception as exc:</span>
<span class="gi">+        print(f&quot;Error: {exc}&quot;)</span>
<span class="gi">+        return 1</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/sphinx/cmd/quickstart.py b/sphinx/cmd/quickstart.py</span>
<span class="gh">index c9bb73784..64a16258a 100644</span>
<span class="gd">--- a/sphinx/cmd/quickstart.py</span>
<span class="gi">+++ b/sphinx/cmd/quickstart.py</span>
<span class="gu">@@ -67,7 +67,8 @@ class QuickstartRenderer(SphinxRenderer):</span>
<span class="w"> </span>        Note: Please don&#39;t use this function from extensions.
<span class="w"> </span>              It will be removed in the future without deprecation period.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        custom_template = path.join(self.templatedir, template_name)</span>
<span class="gi">+        return path.exists(custom_template)</span>


<span class="w"> </span>def ask_user(d: dict[str, Any]) -&gt;None:
<span class="gu">@@ -89,13 +90,127 @@ def ask_user(d: dict[str, Any]) -&gt;None:</span>
<span class="w"> </span>    * makefile:  make Makefile
<span class="w"> </span>    * batchfile: make command file
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    print(bold(__(&#39;Welcome to the Sphinx %s quickstart utility.&#39;)) % __display_version__)</span>
<span class="gi">+    print(__(&#39;&#39;&#39;</span>
<span class="gi">+Please enter values for the following settings (just press Enter to</span>
<span class="gi">+accept a default value, if one is given in brackets).&#39;&#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;path&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        d[&#39;path&#39;] = do_prompt(__(&#39;Enter the root path for documentation.&#39;), DEFAULTS[&#39;path&#39;])</span>
<span class="gi">+    if &#39;sep&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        d[&#39;sep&#39;] = do_prompt(__(&#39;Separate source and build directories (y/n)&#39;), &#39;n&#39;) == &#39;y&#39;</span>
<span class="gi">+    if &#39;project&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        d[&#39;project&#39;] = do_prompt(__(&#39;Project name:&#39;))</span>
<span class="gi">+    if &#39;author&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        d[&#39;author&#39;] = do_prompt(__(&#39;Author name(s):&#39;))</span>
<span class="gi">+    if &#39;version&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        d[&#39;version&#39;] = do_prompt(__(&#39;Project version:&#39;), &#39;0.1&#39;)</span>
<span class="gi">+    if &#39;release&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        d[&#39;release&#39;] = do_prompt(__(&#39;Project release:&#39;), d[&#39;version&#39;])</span>
<span class="gi">+    if &#39;language&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        d[&#39;language&#39;] = do_prompt(__(&#39;Project language:&#39;), DEFAULTS[&#39;language&#39;])</span>
<span class="gi">+    if &#39;suffix&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        d[&#39;suffix&#39;] = do_prompt(__(&#39;Source file suffix:&#39;), DEFAULTS[&#39;suffix&#39;])</span>
<span class="gi">+    if &#39;master&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        d[&#39;master&#39;] = do_prompt(__(&#39;Name of your master document (without suffix):&#39;), DEFAULTS[&#39;master&#39;])</span>
<span class="gi">+    if &#39;extensions&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        print(__(&#39;Indicate which of the following Sphinx extensions should be enabled:&#39;))</span>
<span class="gi">+        d[&#39;extensions&#39;] = []</span>
<span class="gi">+        for name, description in EXTENSIONS.items():</span>
<span class="gi">+            if do_prompt(&#39;%s: %s (y/n)&#39; % (name, description), &#39;n&#39;) == &#39;y&#39;:</span>
<span class="gi">+                d[&#39;extensions&#39;].append(name)</span>
<span class="gi">+    if &#39;makefile&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        d[&#39;makefile&#39;] = do_prompt(__(&#39;Create Makefile? (y/n)&#39;), &#39;y&#39;) == &#39;y&#39;</span>
<span class="gi">+    if &#39;batchfile&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        d[&#39;batchfile&#39;] = do_prompt(__(&#39;Create Windows command file? (y/n)&#39;), &#39;y&#39;) == &#39;y&#39;</span>
<span class="gi">+</span>
<span class="gi">+    print()</span>


<span class="w"> </span>def generate(d: dict[str, Any], overwrite: bool=True, silent: bool=False,
<span class="w"> </span>    templatedir: (str | None)=None) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Generate project based on values in *d*.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    renderer = QuickstartRenderer(templatedir=templatedir)</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;mastertoctree&#39; not in d:</span>
<span class="gi">+        d[&#39;mastertoctree&#39;] = &#39;&#39;</span>
<span class="gi">+    if &#39;mastertocmaxdepth&#39; not in d:</span>
<span class="gi">+        d[&#39;mastertocmaxdepth&#39;] = 2</span>
<span class="gi">+</span>
<span class="gi">+    d[&#39;now&#39;] = time.asctime()</span>
<span class="gi">+    d[&#39;project_underline&#39;] = column_width(d[&#39;project&#39;]) * &#39;=&#39;</span>
<span class="gi">+    d[&#39;extensions&#39;] = &#39;, &#39;.join(repr(ext) for ext in d.get(&#39;extensions&#39;, []))</span>
<span class="gi">+    d[&#39;copyright&#39;] = time.strftime(&#39;%Y&#39;) + &#39;, &#39; + d[&#39;author&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    ensuredir(d[&#39;path&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    srcdir = d[&#39;sep&#39;] and path.join(d[&#39;path&#39;], &#39;source&#39;) or d[&#39;path&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    ensuredir(srcdir)</span>
<span class="gi">+    if d[&#39;sep&#39;]:</span>
<span class="gi">+        builddir = path.join(d[&#39;path&#39;], &#39;build&#39;)</span>
<span class="gi">+        d[&#39;exclude_patterns&#39;] = &#39;&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        builddir = path.join(srcdir, &#39;_build&#39;)</span>
<span class="gi">+        exclude_patterns = [&#39;_build&#39;, &#39;Thumbs.db&#39;, &#39;.DS_Store&#39;]</span>
<span class="gi">+        d[&#39;exclude_patterns&#39;] = &#39;, &#39;.join(repr(p) for p in exclude_patterns)</span>
<span class="gi">+    ensuredir(builddir)</span>
<span class="gi">+    ensuredir(path.join(srcdir, &#39;_templates&#39;))</span>
<span class="gi">+    ensuredir(path.join(srcdir, &#39;_static&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def write_file(fpath: str, content: str, newline: str=&#39;\n&#39;) -&gt;None:</span>
<span class="gi">+        if overwrite or not path.isfile(fpath):</span>
<span class="gi">+            print(__(&#39;Creating file %s.&#39;) % fpath)</span>
<span class="gi">+            with open(fpath, &#39;w&#39;, encoding=&#39;utf-8&#39;, newline=newline) as f:</span>
<span class="gi">+                f.write(content)</span>
<span class="gi">+        else:</span>
<span class="gi">+            print(__(&#39;File %s already exists, skipping.&#39;) % fpath)</span>
<span class="gi">+</span>
<span class="gi">+    conf_text = renderer.render(&#39;conf.py_t&#39;, d)</span>
<span class="gi">+    write_file(path.join(srcdir, &#39;conf.py&#39;), conf_text)</span>
<span class="gi">+</span>
<span class="gi">+    masterfile = path.join(srcdir, d[&#39;master&#39;] + d[&#39;suffix&#39;])</span>
<span class="gi">+    write_file(masterfile, renderer.render(&#39;master_doc.rst_t&#39;, d))</span>
<span class="gi">+</span>
<span class="gi">+    if d.get(&#39;make_mode&#39;) is True:</span>
<span class="gi">+        makefile_template = &#39;Makefile.new_t&#39;</span>
<span class="gi">+        batchfile_template = &#39;make.bat.new_t&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        makefile_template = &#39;Makefile_t&#39;</span>
<span class="gi">+        batchfile_template = &#39;make.bat_t&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if d[&#39;makefile&#39;] is True:</span>
<span class="gi">+        write_file(path.join(d[&#39;path&#39;], &#39;Makefile&#39;),</span>
<span class="gi">+                   renderer.render(makefile_template, d))</span>
<span class="gi">+</span>
<span class="gi">+    if d[&#39;batchfile&#39;] is True:</span>
<span class="gi">+        write_file(path.join(d[&#39;path&#39;], &#39;make.bat&#39;),</span>
<span class="gi">+                   renderer.render(batchfile_template, d), &#39;\r\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if silent:</span>
<span class="gi">+        return</span>
<span class="gi">+    print()</span>
<span class="gi">+    print(bold(__(&#39;Finished: An initial directory structure has been created.&#39;)))</span>
<span class="gi">+    print()</span>
<span class="gi">+    print(__(&#39;You should now populate your master file %s and create other documentation\n&#39;</span>
<span class="gi">+             &#39;source files. &#39;) % masterfile, end=&#39;&#39;)</span>
<span class="gi">+    print(__(&#39;Use the Makefile to build the docs, like so:\n&#39;</span>
<span class="gi">+             &#39;   make builder&#39;))</span>
<span class="gi">+    print(__(&#39;where &quot;builder&quot; is one of the supported builders, e.g. html, latex &#39;</span>
<span class="gi">+             &#39;or linkcheck.&#39;))</span>
<span class="gi">+    print()</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/sphinx/config.py b/sphinx/config.py</span>
<span class="gh">index 035734a48..efb3b5d00 100644</span>
<span class="gd">--- a/sphinx/config.py</span>
<span class="gi">+++ b/sphinx/config.py</span>
<span class="gu">@@ -39,7 +39,21 @@ class ConfigValue(NamedTuple):</span>

<span class="w"> </span>def is_serializable(obj: object, *, _seen: frozenset[int]=frozenset()) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check if an object is serializable or not.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if id(obj) in _seen:</span>
<span class="gi">+        return False</span>
<span class="gi">+    </span>
<span class="gi">+    new_seen = _seen | {id(obj)}</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(obj, (str, int, float, bool, type(None))):</span>
<span class="gi">+        return True</span>
<span class="gi">+    elif isinstance(obj, (list, tuple)):</span>
<span class="gi">+        return all(is_serializable(item, _seen=new_seen) for item in obj)</span>
<span class="gi">+    elif isinstance(obj, dict):</span>
<span class="gi">+        return all(is_serializable(key, _seen=new_seen) and is_serializable(value, _seen=new_seen) for key, value in obj.items())</span>
<span class="gi">+    elif isinstance(obj, set):</span>
<span class="gi">+        return all(is_serializable(item, _seen=new_seen) for item in obj)</span>
<span class="gi">+    </span>
<span class="gi">+    return False</span>


<span class="w"> </span>class ENUM:
<span class="gu">@@ -229,7 +243,15 @@ class Config:</span>
<span class="w"> </span>    def read(cls: type[Config], confdir: (str | os.PathLike[str]),
<span class="w"> </span>        overrides: (dict | None)=None, tags: (Tags | None)=None) -&gt;Config:
<span class="w"> </span>        &quot;&quot;&quot;Create a Config object from configuration file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        conffile = path.join(confdir, CONFIG_FILENAME)</span>
<span class="gi">+        if not path.isfile(conffile):</span>
<span class="gi">+            raise ConfigError(__(&quot;config directory doesn&#39;t contain a conf.py file (%s)&quot;) % conffile)</span>
<span class="gi">+</span>
<span class="gi">+        with chdir(confdir):</span>
<span class="gi">+            namespace = eval_config_file(conffile, tags)</span>
<span class="gi">+</span>
<span class="gi">+        config = cls(namespace, overrides)</span>
<span class="gi">+        return config</span>

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        values = []
<span class="gu">@@ -328,7 +350,15 @@ class Config:</span>

<span class="w"> </span>def eval_config_file(filename: str, tags: (Tags | None)) -&gt;dict[str, Any]:
<span class="w"> </span>    &quot;&quot;&quot;Evaluate a config file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    namespace: dict[str, Any] = {}</span>
<span class="gi">+    with open(filename, &#39;rb&#39;) as f:</span>
<span class="gi">+        code = compile(f.read(), filename, &#39;exec&#39;)</span>
<span class="gi">+    exec(code, namespace)</span>
<span class="gi">+    </span>
<span class="gi">+    if tags is not None:</span>
<span class="gi">+        namespace[&#39;tags&#39;] = tags</span>
<span class="gi">+</span>
<span class="gi">+    return {k: v for k, v in namespace.items() if not k.startswith(&#39;__&#39;)}</span>


<span class="w"> </span>def convert_source_suffix(app: Sphinx, config: Config) -&gt;None:
<span class="gu">@@ -337,7 +367,15 @@ def convert_source_suffix(app: Sphinx, config: Config) -&gt;None:</span>
<span class="w"> </span>    * old style: str or list
<span class="w"> </span>    * new style: a dict which maps from fileext to filetype
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    source_suffix = config.source_suffix</span>
<span class="gi">+    if isinstance(source_suffix, str):</span>
<span class="gi">+        config.source_suffix = {source_suffix: &#39;restructuredtext&#39;}</span>
<span class="gi">+    elif isinstance(source_suffix, (list, tuple)):</span>
<span class="gi">+        config.source_suffix = {suffix: &#39;restructuredtext&#39; for suffix in source_suffix}</span>
<span class="gi">+    elif not isinstance(source_suffix, dict):</span>
<span class="gi">+        logger.warning(__(&#39;The source_suffix config value should be either &#39;</span>
<span class="gi">+                          &#39;a string, list, or dictionary. But now it is %r&#39;),</span>
<span class="gi">+                       type(source_suffix))</span>


<span class="w"> </span>def convert_highlight_options(app: Sphinx, config: Config) -&gt;None:
<span class="gu">@@ -346,12 +384,23 @@ def convert_highlight_options(app: Sphinx, config: Config) -&gt;None:</span>
<span class="w"> </span>    * old style: options
<span class="w"> </span>    * new style: a dict which maps from language name to options
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    highlight_options = config.highlight_options</span>
<span class="gi">+    if isinstance(highlight_options, dict):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    config.highlight_options = {config.highlight_language: highlight_options}</span>


<span class="w"> </span>def init_numfig_format(app: Sphinx, config: Config) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Initialize :confval:`numfig_format`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    numfig_format = {&#39;section&#39;: _(&#39;Section %s&#39;),</span>
<span class="gi">+                     &#39;figure&#39;: _(&#39;Fig. %s&#39;),</span>
<span class="gi">+                     &#39;table&#39;: _(&#39;Table %s&#39;),</span>
<span class="gi">+                     &#39;code-block&#39;: _(&#39;Listing %s&#39;)}</span>
<span class="gi">+</span>
<span class="gi">+    # override default labels by configuration</span>
<span class="gi">+    numfig_format.update(config.numfig_format)</span>
<span class="gi">+    config.numfig_format = numfig_format</span>


<span class="w"> </span>def correct_copyright_year(_app: Sphinx, config: Config) -&gt;None:
<span class="gu">@@ -376,7 +425,16 @@ def _substitute_copyright_year(copyright_line: str, replace_year: str) -&gt;str:</span>

<span class="w"> </span>    The final year in the string is replaced with ``replace_year``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import re</span>
<span class="gi">+    </span>
<span class="gi">+    year_pattern = r&#39;(\d{4})(?:-\d{4})?(?:[,\s]|$)&#39;</span>
<span class="gi">+    match = re.search(year_pattern, copyright_line)</span>
<span class="gi">+    </span>
<span class="gi">+    if match:</span>
<span class="gi">+        start, end = match.span()</span>
<span class="gi">+        return copyright_line[:start] + replace_year + copyright_line[end:]</span>
<span class="gi">+    </span>
<span class="gi">+    return copyright_line</span>


<span class="w"> </span>def check_confval_types(app: (Sphinx | None), config: Config) -&gt;None:
<span class="gu">@@ -391,4 +449,10 @@ def check_root_doc(app: Sphinx, env: BuildEnvironment, added: Set[str],</span>
<span class="w"> </span>    &quot;&quot;&quot;Adjust root_doc to &#39;contents&#39; to support an old project which does not have
<span class="w"> </span>    any root_doc setting.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if app.config.root_doc == &#39;index&#39; and &#39;index&#39; not in env.found_docs:</span>
<span class="gi">+        if &#39;contents&#39; in env.found_docs:</span>
<span class="gi">+            app.config.root_doc = &quot;contents&quot;</span>
<span class="gi">+            logger.warning(__(&#39;Since there is no index.rst file, changing &#39;</span>
<span class="gi">+                              &#39;root_doc to contents&#39;))</span>
<span class="gi">+            return [&#39;contents&#39;]</span>
<span class="gi">+    return []</span>
<span class="gh">diff --git a/sphinx/deprecation.py b/sphinx/deprecation.py</span>
<span class="gh">index ee68dfa87..ec212e615 100644</span>
<span class="gd">--- a/sphinx/deprecation.py</span>
<span class="gi">+++ b/sphinx/deprecation.py</span>
<span class="gu">@@ -51,4 +51,21 @@ def _deprecation_warning(module: str, attribute: str, canonical_name: str=</span>
<span class="w"> </span>           _deprecation_warning(__name__, name, canonical_name, remove=remove)
<span class="w"> </span>           return deprecated_object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    major, minor = remove</span>
<span class="gi">+    version = f&quot;{major}.{minor}&quot;</span>
<span class="gi">+    </span>
<span class="gi">+    if canonical_name:</span>
<span class="gi">+        message = f&quot;{module}.{attribute} is deprecated and will be removed in Sphinx {version}. &quot; \</span>
<span class="gi">+                  f&quot;Please use {canonical_name} instead.&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        message = f&quot;{module}.{attribute} is deprecated and will be removed in Sphinx {version}.&quot;</span>
<span class="gi">+    </span>
<span class="gi">+    if raises:</span>
<span class="gi">+        raise AttributeError(message)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if major == 9:</span>
<span class="gi">+            warnings.warn(message, RemovedInSphinx90Warning, stacklevel=3)</span>
<span class="gi">+        elif major == 10:</span>
<span class="gi">+            warnings.warn(message, RemovedInSphinx10Warning, stacklevel=3)</span>
<span class="gi">+        else:</span>
<span class="gi">+            warnings.warn(message, DeprecationWarning, stacklevel=3)</span>
<span class="gh">diff --git a/sphinx/directives/other.py b/sphinx/directives/other.py</span>
<span class="gh">index 1a6198deb..5c6df965b 100644</span>
<span class="gd">--- a/sphinx/directives/other.py</span>
<span class="gi">+++ b/sphinx/directives/other.py</span>
<span class="gu">@@ -44,7 +44,40 @@ class TocTree(SphinxDirective):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Populate ``toctree[&#39;entries&#39;]`` and ``toctree[&#39;includefiles&#39;]`` from content.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        suffixes = self.config.source_suffix</span>
<span class="gi">+        glob = &#39;glob&#39; in self.options</span>
<span class="gi">+        entries = []</span>
<span class="gi">+        includefiles = []</span>
<span class="gi">+</span>
<span class="gi">+        for entry in self.content:</span>
<span class="gi">+            if not entry:</span>
<span class="gi">+                continue</span>
<span class="gi">+            # look for explicit titles (&quot;Some Title &lt;document&gt;&quot;)</span>
<span class="gi">+            explicit = explicit_title_re.match(entry)</span>
<span class="gi">+            if explicit:</span>
<span class="gi">+                ref = explicit.group(2)</span>
<span class="gi">+                title = explicit.group(1)</span>
<span class="gi">+            else:</span>
<span class="gi">+                ref = entry</span>
<span class="gi">+                title = None</span>
<span class="gi">+            </span>
<span class="gi">+            if glob and glob_re.match(ref):</span>
<span class="gi">+                patname = ref</span>
<span class="gi">+                docnames = sorted(self.env.found_docs)</span>
<span class="gi">+                for docname in patfilter(docnames, patname):</span>
<span class="gi">+                    entries.append((title, docname))</span>
<span class="gi">+                    includefiles.append(docname)</span>
<span class="gi">+            else:</span>
<span class="gi">+                docname = ref</span>
<span class="gi">+                if docname not in self.env.found_docs:</span>
<span class="gi">+                    logger.warning(__(&#39;toctree contains reference to nonexisting document %r&#39;), docname)</span>
<span class="gi">+                    self.env.note_reread()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    entries.append((title, docname))</span>
<span class="gi">+                    includefiles.append(docname)</span>
<span class="gi">+        </span>
<span class="gi">+        toctree[&#39;entries&#39;] = entries</span>
<span class="gi">+        toctree[&#39;includefiles&#39;] = includefiles</span>


<span class="w"> </span>class Author(SphinxDirective):
<span class="gu">@@ -58,6 +91,16 @@ class Author(SphinxDirective):</span>
<span class="w"> </span>    final_argument_whitespace = True
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {}

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        if not self.config.show_authors:</span>
<span class="gi">+            return []</span>
<span class="gi">+        para = nodes.paragraph(translatable=False)</span>
<span class="gi">+        emph = nodes.emphasis()</span>
<span class="gi">+        para += emph</span>
<span class="gi">+        text = self.arguments[0]</span>
<span class="gi">+        emph += nodes.Text(text, text)</span>
<span class="gi">+        return [para]</span>
<span class="gi">+</span>

<span class="w"> </span>class SeeAlso(BaseAdmonition):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -76,6 +119,12 @@ class TabularColumns(SphinxDirective):</span>
<span class="w"> </span>    final_argument_whitespace = True
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {}

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        node = addnodes.tabular_col_spec()</span>
<span class="gi">+        node[&#39;spec&#39;] = self.arguments[0]</span>
<span class="gi">+        set_source_info(self, node)</span>
<span class="gi">+        return [node]</span>
<span class="gi">+</span>

<span class="w"> </span>class Centered(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -87,6 +136,13 @@ class Centered(SphinxDirective):</span>
<span class="w"> </span>    final_argument_whitespace = True
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {}

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        text = self.arguments[0]</span>
<span class="gi">+        para = nodes.paragraph(text, classes=[&#39;centered&#39;])</span>
<span class="gi">+        strong = nodes.strong(text, text)</span>
<span class="gi">+        para += strong</span>
<span class="gi">+        return [para]</span>
<span class="gi">+</span>

<span class="w"> </span>class Acks(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -98,6 +154,16 @@ class Acks(SphinxDirective):</span>
<span class="w"> </span>    final_argument_whitespace = False
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {}

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        node = addnodes.acks()</span>
<span class="gi">+        node.document = self.state.document</span>
<span class="gi">+        self.state.nested_parse(self.content, self.content_offset, node)</span>
<span class="gi">+        if len(node.children) != 1 or not isinstance(node.children[0], nodes.bullet_list):</span>
<span class="gi">+            return [self.state.document.reporter.warning(</span>
<span class="gi">+                &#39;Acknowledgement list must contain a single bullet list&#39;,</span>
<span class="gi">+                line=self.lineno)]</span>
<span class="gi">+        return [node]</span>
<span class="gi">+</span>

<span class="w"> </span>class HList(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -109,6 +175,23 @@ class HList(SphinxDirective):</span>
<span class="w"> </span>    final_argument_whitespace = False
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {&#39;columns&#39;: int}

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        ncolumns = self.options.get(&#39;columns&#39;, 2)</span>
<span class="gi">+        node = nodes.paragraph()</span>
<span class="gi">+        node.document = self.state.document</span>
<span class="gi">+        self.state.nested_parse(self.content, self.content_offset, node)</span>
<span class="gi">+        if len(node.children) != 1 or not isinstance(node.children[0], nodes.bullet_list):</span>
<span class="gi">+            return [self.state.document.reporter.warning(</span>
<span class="gi">+                &#39;hlist content is not a single bullet list&#39;,</span>
<span class="gi">+                line=self.lineno)]</span>
<span class="gi">+        bullet_list = node.children[0]</span>
<span class="gi">+        list_items = bullet_list.children</span>
<span class="gi">+        for i, item in enumerate(list_items):</span>
<span class="gi">+            item[&#39;classes&#39;].append(&#39;hlist-item&#39;)</span>
<span class="gi">+            item[&#39;classes&#39;].append(f&#39;hlist-col-{i % ncolumns + 1}&#39;)</span>
<span class="gi">+        bullet_list[&#39;classes&#39;].append(&#39;hlist&#39;)</span>
<span class="gi">+        return [bullet_list]</span>
<span class="gi">+</span>

<span class="w"> </span>class Only(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -120,6 +203,15 @@ class Only(SphinxDirective):</span>
<span class="w"> </span>    final_argument_whitespace = True
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {}

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        node = addnodes.only()</span>
<span class="gi">+        node.document = self.state.document</span>
<span class="gi">+        set_source_info(self, node)</span>
<span class="gi">+        node[&#39;expr&#39;] = self.arguments[0]</span>
<span class="gi">+        self.state.nested_parse(self.content, self.content_offset, node,</span>
<span class="gi">+                                match_titles=True)</span>
<span class="gi">+        return [node]</span>
<span class="gi">+</span>

<span class="w"> </span>class Include(BaseInclude, SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gh">diff --git a/sphinx/domains/_index.py b/sphinx/domains/_index.py</span>
<span class="gh">index ef50b53cd..cba997097 100644</span>
<span class="gd">--- a/sphinx/domains/_index.py</span>
<span class="gi">+++ b/sphinx/domains/_index.py</span>
<span class="gu">@@ -104,4 +104,4 @@ class Index(ABC):</span>
<span class="w"> </span>        Qualifier and description are not rendered for some output formats such
<span class="w"> </span>        as LaTeX.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;Subclasses must implement the generate method&quot;)</span>
<span class="gh">diff --git a/sphinx/domains/c/_parser.py b/sphinx/domains/c/_parser.py</span>
<span class="gh">index c92013687..4e0a2d164 100644</span>
<span class="gd">--- a/sphinx/domains/c/_parser.py</span>
<span class="gi">+++ b/sphinx/domains/c/_parser.py</span>
<span class="gu">@@ -13,7 +13,31 @@ class DefinitionParser(BaseParser):</span>
<span class="w"> </span>    def _parse_decl_specs_simple(self, outer: (str | None), typed: bool
<span class="w"> </span>        ) -&gt;ASTDeclSpecsSimple:
<span class="w"> </span>        &quot;&quot;&quot;Just parse the simple ones.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        specs = []</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if len(self.tokens) == 0:</span>
<span class="gi">+                break</span>
<span class="gi">+            token = self.tokens[0]</span>
<span class="gi">+            if token.kind == &#39;keyword&#39;:</span>
<span class="gi">+                if token.value in _simple_type_specifiers_re:</span>
<span class="gi">+                    specs.append(token.value)</span>
<span class="gi">+                    self.tokens.pop(0)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+            elif token.kind == &#39;identifier&#39;:</span>
<span class="gi">+                if _simple_type_specifiers_re.match(token.value):</span>
<span class="gi">+                    specs.append(token.value)</span>
<span class="gi">+                    self.tokens.pop(0)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        if len(specs) == 0:</span>
<span class="gi">+            if typed:</span>
<span class="gi">+                self.fail(&quot;Expected type specifier in declaration.&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return None</span>
<span class="gi">+        return ASTDeclSpecsSimple(specs)</span>

<span class="w"> </span>    def _parse_type(self, named: (bool | str), outer: (str | None)=None
<span class="w"> </span>        ) -&gt;ASTType:
<span class="gu">@@ -21,4 +45,13 @@ class DefinitionParser(BaseParser):</span>
<span class="w"> </span>        named=False|&#39;single&#39;|True: &#39;single&#39; is e.g., for function objects which
<span class="w"> </span>        doesn&#39;t need to name the arguments, but otherwise is a single name
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        declSpecs = self._parse_decl_specs_simple(outer, typed=True)</span>
<span class="gi">+        if declSpecs is None:</span>
<span class="gi">+            self.fail(&quot;Expected type&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        decl = self._parse_declarator(named=named, typed=False)</span>
<span class="gi">+        </span>
<span class="gi">+        if decl is None:</span>
<span class="gi">+            return ASTType(declSpecs, None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ASTType(declSpecs, decl)</span>
<span class="gh">diff --git a/sphinx/domains/cpp/_parser.py b/sphinx/domains/cpp/_parser.py</span>
<span class="gh">index f09b4224d..50e139e4f 100644</span>
<span class="gd">--- a/sphinx/domains/cpp/_parser.py</span>
<span class="gi">+++ b/sphinx/domains/cpp/_parser.py</span>
<span class="gu">@@ -15,7 +15,55 @@ class DefinitionParser(BaseParser):</span>
<span class="w"> </span>    def _parse_decl_specs_simple(self, outer: str, typed: bool
<span class="w"> </span>        ) -&gt;ASTDeclSpecsSimple:
<span class="w"> </span>        &quot;&quot;&quot;Just parse the simple ones.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        storage = None</span>
<span class="gi">+        threadLocal = None</span>
<span class="gi">+        inline = None</span>
<span class="gi">+        virtual = None</span>
<span class="gi">+        explicit = None</span>
<span class="gi">+        constexpr = None</span>
<span class="gi">+        volatile = None</span>
<span class="gi">+        const = None</span>
<span class="gi">+        friend = None</span>
<span class="gi">+        attrs = None</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            pos = self.pos</span>
<span class="gi">+            try:</span>
<span class="gi">+                # Check for simple type specifiers</span>
<span class="gi">+                if self.match(_simple_type_specifiers_re):</span>
<span class="gi">+                    self.skip_ws()</span>
<span class="gi">+                    continue</span>
<span class="gi">+                # Check for storage class specifiers</span>
<span class="gi">+                elif self.match(r&#39;static|extern|register|mutable&#39;):</span>
<span class="gi">+                    if storage is not None:</span>
<span class="gi">+                        self.fail(&quot;Multiple storage class specifiers&quot;)</span>
<span class="gi">+                    storage = self.matched_text</span>
<span class="gi">+                elif self.match(&#39;thread_local&#39;):</span>
<span class="gi">+                    threadLocal = True</span>
<span class="gi">+                elif self.match(&#39;inline&#39;):</span>
<span class="gi">+                    inline = True</span>
<span class="gi">+                elif self.match(&#39;virtual&#39;):</span>
<span class="gi">+                    virtual = True</span>
<span class="gi">+                elif self.match(&#39;explicit&#39;):</span>
<span class="gi">+                    explicit = True</span>
<span class="gi">+                elif self.match(&#39;constexpr&#39;):</span>
<span class="gi">+                    constexpr = True</span>
<span class="gi">+                elif self.match(&#39;volatile&#39;):</span>
<span class="gi">+                    volatile = True</span>
<span class="gi">+                elif self.match(&#39;const&#39;):</span>
<span class="gi">+                    const = True</span>
<span class="gi">+                elif self.match(&#39;friend&#39;):</span>
<span class="gi">+                    friend = True</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+            except DefinitionError:</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        return ASTDeclSpecsSimple(storage, threadLocal, inline, virtual,</span>
<span class="gi">+                                  explicit, constexpr, volatile, const,</span>
<span class="gi">+                                  friend, attrs)</span>

<span class="w"> </span>    def _parse_type(self, named: (bool | str), outer: (str | None)=None
<span class="w"> </span>        ) -&gt;ASTType:
<span class="gu">@@ -25,4 +73,19 @@ class DefinitionParser(BaseParser):</span>

<span class="w"> </span>        outer == operatorCast: annoying case, we should not take the params
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if outer == &#39;operatorCast&#39;:</span>
<span class="gi">+            # Special case for cast operators</span>
<span class="gi">+            declSpecs = self._parse_decl_specs_simple(&#39;operatorCast&#39;, typed=True)</span>
<span class="gi">+            decl = self._parse_declarator(named=True, paramMode=&#39;operatorCast&#39;)</span>
<span class="gi">+            return ASTType(declSpecs, decl)</span>
<span class="gi">+</span>
<span class="gi">+        declSpecs = self._parse_decl_specs_simple(outer, typed=True)</span>
<span class="gi">+</span>
<span class="gi">+        if self.skip_string(&#39;...&#39;):</span>
<span class="gi">+            # Parameter pack</span>
<span class="gi">+            if not named:</span>
<span class="gi">+                self.fail(&quot;Unnamed parameter pack.&quot;)</span>
<span class="gi">+            return ASTType(declSpecs, ASTDeclaratorParamPack())</span>
<span class="gi">+</span>
<span class="gi">+        decl = self._parse_declarator(named=named, paramMode=outer)</span>
<span class="gi">+        return ASTType(declSpecs, decl)</span>
<span class="gh">diff --git a/sphinx/domains/index.py b/sphinx/domains/index.py</span>
<span class="gh">index 312617719..e0f70ad38 100644</span>
<span class="gd">--- a/sphinx/domains/index.py</span>
<span class="gi">+++ b/sphinx/domains/index.py</span>
<span class="gu">@@ -26,7 +26,12 @@ class IndexDomain(Domain):</span>
<span class="w"> </span>    def process_doc(self, env: BuildEnvironment, docname: str, document: Node
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Process a document after it is read by the environment.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for node in document.traverse(addnodes.index):</span>
<span class="gi">+            entries = node[&#39;entries&#39;]</span>
<span class="gi">+            for entry in entries:</span>
<span class="gi">+                split_entries = split_index_msg(entry[1])</span>
<span class="gi">+                for (type, value, target, main, key_) in split_entries:</span>
<span class="gi">+                    self.add_entry(type, value, target, main, docname)</span>


<span class="w"> </span>class IndexDirective(SphinxDirective):
<span class="gu">@@ -39,6 +44,26 @@ class IndexDirective(SphinxDirective):</span>
<span class="w"> </span>    final_argument_whitespace = True
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {&#39;name&#39;: directives.unchanged}

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        arguments = self.arguments[0].split(&#39;\n&#39;)</span>
<span class="gi">+        targetid = &#39;index-%s&#39; % self.env.new_serialno(&#39;index&#39;)</span>
<span class="gi">+        targetnode = nodes.target(&#39;&#39;, &#39;&#39;, ids=[targetid])</span>
<span class="gi">+        self.state.document.note_explicit_target(targetnode)</span>
<span class="gi">+        indexnode = addnodes.index()</span>
<span class="gi">+        indexnode[&#39;entries&#39;] = []</span>
<span class="gi">+        for entry in arguments:</span>
<span class="gi">+            indexnode[&#39;entries&#39;].extend(process_index_entry(entry, targetid))</span>
<span class="gi">+        return [indexnode, targetnode]</span>
<span class="gi">+</span>

<span class="w"> </span>class IndexRole(ReferenceRole):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        target = self.target</span>
<span class="gi">+        title = self.title</span>
<span class="gi">+        index = addnodes.index(entries=[(&#39;single&#39;, target, &#39;&#39;, &#39;&#39;, None)])</span>
<span class="gi">+        target_id = &#39;index-%s&#39; % self.env.new_serialno(&#39;index&#39;)</span>
<span class="gi">+        target = nodes.target(&#39;&#39;, &#39;&#39;, ids=[target_id])</span>
<span class="gi">+        reference = nodes.reference(&#39;&#39;, &#39;&#39;, internal=True, refid=target_id,</span>
<span class="gi">+                                    classes=[&#39;index&#39;])</span>
<span class="gi">+        reference += nodes.Text(title, title)</span>
<span class="gi">+        return [index, target, reference], []</span>
<span class="gh">diff --git a/sphinx/domains/javascript.py b/sphinx/domains/javascript.py</span>
<span class="gh">index 760e3b217..5dcd3094d 100644</span>
<span class="gd">--- a/sphinx/domains/javascript.py</span>
<span class="gi">+++ b/sphinx/domains/javascript.py</span>
<span class="gu">@@ -45,7 +45,48 @@ class JSObject(ObjectDescription[tuple[str, str]]):</span>
<span class="w"> </span>        namespace and class will be determined by the nesting of domain
<span class="w"> </span>        directives.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sig = sig.strip()</span>
<span class="gi">+        if &#39;(&#39; in sig and sig[-1:] == &#39;)&#39;:</span>
<span class="gi">+            prefix, arglist = sig.split(&#39;(&#39;, 1)</span>
<span class="gi">+            prefix = prefix.strip()</span>
<span class="gi">+            arglist = arglist[:-1].strip()</span>
<span class="gi">+        else:</span>
<span class="gi">+            prefix = sig</span>
<span class="gi">+            arglist = None</span>
<span class="gi">+        </span>
<span class="gi">+        modname = self.options.get(&#39;module&#39;, self.env.ref_context.get(&#39;js:module&#39;))</span>
<span class="gi">+        classname = self.env.ref_context.get(&#39;js:class&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        if classname:</span>
<span class="gi">+            add_module = False</span>
<span class="gi">+            if prefix and prefix != classname:</span>
<span class="gi">+                fullname = classname + &#39;.&#39; + prefix</span>
<span class="gi">+            else:</span>
<span class="gi">+                fullname = classname</span>
<span class="gi">+        else:</span>
<span class="gi">+            add_module = True</span>
<span class="gi">+            fullname = prefix</span>
<span class="gi">+</span>
<span class="gi">+        if modname and add_module:</span>
<span class="gi">+            fullname = modname + &#39;.&#39; + fullname</span>
<span class="gi">+</span>
<span class="gi">+        signode[&#39;module&#39;] = modname</span>
<span class="gi">+        signode[&#39;class&#39;] = classname</span>
<span class="gi">+        signode[&#39;fullname&#39;] = fullname</span>
<span class="gi">+        </span>
<span class="gi">+        sig_prefix = self.get_signature_prefix(sig)</span>
<span class="gi">+        if sig_prefix:</span>
<span class="gi">+            signode += addnodes.desc_annotation(sig_prefix, sig_prefix)</span>
<span class="gi">+        </span>
<span class="gi">+        if prefix:</span>
<span class="gi">+            signode += addnodes.desc_name(prefix, prefix)</span>
<span class="gi">+        if self.has_arguments:</span>
<span class="gi">+            if not arglist:</span>
<span class="gi">+                signode += addnodes.desc_parameterlist()</span>
<span class="gi">+            else:</span>
<span class="gi">+                _pseudo_parse_arglist(signode, arglist)</span>
<span class="gi">+        </span>
<span class="gi">+        return fullname, prefix</span>

<span class="w"> </span>    def before_content(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Handle object nesting before content
<span class="gu">@@ -71,7 +112,12 @@ class JSObject(ObjectDescription[tuple[str, str]]):</span>
<span class="w"> </span>                Current object prefix. This should generally reflect the last
<span class="w"> </span>                element in the prefix history
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.names:</span>
<span class="gi">+            fullname = self.names[0][0]</span>
<span class="gi">+            if self.allow_nesting:</span>
<span class="gi">+                objects = self.env.ref_context.setdefault(&#39;js:objects&#39;, [])</span>
<span class="gi">+                objects.append(fullname)</span>
<span class="gi">+            self.env.ref_context[&#39;js:object&#39;] = fullname</span>

<span class="w"> </span>    def after_content(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Handle object de-nesting after content
<span class="gu">@@ -83,7 +129,11 @@ class JSObject(ObjectDescription[tuple[str, str]]):</span>
<span class="w"> </span>        be altered as we didn&#39;t affect the nesting levels in
<span class="w"> </span>        :py:meth:`before_content`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.allow_nesting:</span>
<span class="gi">+            objects = self.env.ref_context.setdefault(&#39;js:objects&#39;, [])</span>
<span class="gi">+            if objects:</span>
<span class="gi">+                objects.pop()</span>
<span class="gi">+        self.env.ref_context[&#39;js:object&#39;] = None</span>


<span class="w"> </span>class JSCallable(JSObject):
<span class="gh">diff --git a/sphinx/domains/math.py b/sphinx/domains/math.py</span>
<span class="gh">index 18f76a695..68c5efab2 100644</span>
<span class="gd">--- a/sphinx/domains/math.py</span>
<span class="gi">+++ b/sphinx/domains/math.py</span>
<span class="gu">@@ -19,7 +19,10 @@ logger = logging.getLogger(__name__)</span>


<span class="w"> </span>class MathReferenceRole(XRefRole):
<span class="gd">-    pass</span>
<span class="gi">+    def result_nodes(self, document: Node, env: BuildEnvironment, node: Element,</span>
<span class="gi">+                     is_ref: bool) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        node[&#39;refdomain&#39;] = &#39;math&#39;</span>
<span class="gi">+        return [node], []</span>


<span class="w"> </span>class MathDomain(Domain):
<span class="gu">@@ -30,3 +33,48 @@ class MathDomain(Domain):</span>
<span class="w"> </span>    dangling_warnings = {&#39;eq&#39;: &#39;equation not found: %(target)s&#39;}
<span class="w"> </span>    enumerable_nodes = {nodes.math_block: (&#39;displaymath&#39;, None)}
<span class="w"> </span>    roles = {&#39;numref&#39;: MathReferenceRole()}
<span class="gi">+</span>
<span class="gi">+    def get_objects(self) -&gt; Iterable[tuple[str, str, str, str, str, int]]:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,</span>
<span class="gi">+                     typ: str, target: str, node: pending_xref, contnode: Element</span>
<span class="gi">+                     ) -&gt; Element | None:</span>
<span class="gi">+        if typ == &#39;eq&#39;:</span>
<span class="gi">+            try:</span>
<span class="gi">+                docname, labelid = self.data[&#39;objects&#39;][target]</span>
<span class="gi">+                return make_refnode(builder, fromdocname, docname, labelid, contnode)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                return None</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def add_equation(self, env: BuildEnvironment, docname: str, labelid: str, node: Element) -&gt; None:</span>
<span class="gi">+        if not hasattr(env, &#39;math_equations&#39;):</span>
<span class="gi">+            env.math_equations = {}</span>
<span class="gi">+        env.math_equations[labelid] = {</span>
<span class="gi">+            &#39;docname&#39;: docname,</span>
<span class="gi">+            &#39;equation&#39;: node[&#39;latex&#39;],</span>
<span class="gi">+            &#39;lineno&#39;: node.line,</span>
<span class="gi">+            &#39;target&#39;: f&#39;equation-{labelid}&#39;</span>
<span class="gi">+        }</span>
<span class="gi">+        self.data[&#39;objects&#39;][labelid] = (docname, labelid)</span>
<span class="gi">+        self.data[&#39;has_equations&#39;][docname] = True</span>
<span class="gi">+</span>
<span class="gi">+    def process_doc(self, env: BuildEnvironment, docname: str, document: Node) -&gt; None:</span>
<span class="gi">+        for node in document.traverse(nodes.math_block):</span>
<span class="gi">+            if node[&#39;label&#39;]:</span>
<span class="gi">+                self.add_equation(env, docname, node[&#39;label&#39;], node)</span>
<span class="gi">+</span>
<span class="gi">+    def merge_domaindata(self, docnames: list[str], otherdata: dict) -&gt; None:</span>
<span class="gi">+        for labelid, (fn, _) in otherdata[&#39;objects&#39;].items():</span>
<span class="gi">+            if fn in docnames:</span>
<span class="gi">+                self.data[&#39;objects&#39;][labelid] = otherdata[&#39;objects&#39;][labelid]</span>
<span class="gi">+        for docname in docnames:</span>
<span class="gi">+            if docname in otherdata[&#39;has_equations&#39;]:</span>
<span class="gi">+                self.data[&#39;has_equations&#39;][docname] = True</span>
<span class="gi">+</span>
<span class="gi">+    def clear_doc(self, docname: str) -&gt; None:</span>
<span class="gi">+        for labelid, (fn, _) in list(self.data[&#39;objects&#39;].items()):</span>
<span class="gi">+            if fn == docname:</span>
<span class="gi">+                del self.data[&#39;objects&#39;][labelid]</span>
<span class="gi">+        self.data[&#39;has_equations&#39;].pop(docname, None)</span>
<span class="gh">diff --git a/sphinx/domains/python/_annotations.py b/sphinx/domains/python/_annotations.py</span>
<span class="gh">index bc2418143..30e05f681 100644</span>
<span class="gd">--- a/sphinx/domains/python/_annotations.py</span>
<span class="gi">+++ b/sphinx/domains/python/_annotations.py</span>
<span class="gu">@@ -20,18 +20,64 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>def parse_reftarget(reftarget: str, suppress_prefix: bool=False) -&gt;tuple[
<span class="w"> </span>    str, str, str, bool]:
<span class="w"> </span>    &quot;&quot;&quot;Parse a type string and return (reftype, reftarget, title, refspecific flag)&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    reftype = &#39;&#39;</span>
<span class="gi">+    title = reftarget</span>
<span class="gi">+    refspecific = False</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;.&#39; in reftarget:</span>
<span class="gi">+        module, name = reftarget.rsplit(&#39;.&#39;, 1)</span>
<span class="gi">+        if not suppress_prefix:</span>
<span class="gi">+            reftype = &#39;obj&#39;</span>
<span class="gi">+        reftarget = name</span>
<span class="gi">+        title = module + &#39;.&#39; + name</span>
<span class="gi">+        refspecific = True</span>
<span class="gi">+    elif reftarget.startswith(&#39;~&#39;):</span>
<span class="gi">+        reftarget = reftarget[1:]</span>
<span class="gi">+        dot = reftarget.rfind(&#39;.&#39;)</span>
<span class="gi">+        if dot != -1:</span>
<span class="gi">+            title = reftarget[dot + 1:]</span>
<span class="gi">+    </span>
<span class="gi">+    return reftype, reftarget, title, refspecific</span>


<span class="w"> </span>def type_to_xref(target: str, env: BuildEnvironment, *, suppress_prefix:
<span class="w"> </span>    bool=False) -&gt;addnodes.pending_xref:
<span class="w"> </span>    &quot;&quot;&quot;Convert a type string to a cross reference node.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    reftype, reftarget, title, refspecific = parse_reftarget(target, suppress_prefix)</span>
<span class="gi">+    </span>
<span class="gi">+    if reftype:</span>
<span class="gi">+        domain = &#39;py&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        domain = &#39;py&#39;</span>
<span class="gi">+        reftype = &#39;obj&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    return addnodes.pending_xref(</span>
<span class="gi">+        &#39;&#39;, nodes.Text(title),</span>
<span class="gi">+        refdomain=domain, reftype=reftype, reftarget=reftarget,</span>
<span class="gi">+        refspecific=refspecific,</span>
<span class="gi">+        py_module=env.ref_context.get(&#39;py:module&#39;),</span>
<span class="gi">+        py_class=env.ref_context.get(&#39;py:class&#39;)</span>
<span class="gi">+    )</span>


<span class="w"> </span>def _parse_annotation(annotation: str, env: BuildEnvironment) -&gt;list[Node]:
<span class="w"> </span>    &quot;&quot;&quot;Parse type annotation.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for token in ast.parse(annotation).body[0].value.elts:</span>
<span class="gi">+        if isinstance(token, ast.Str):</span>
<span class="gi">+            result.append(nodes.Text(token.s))</span>
<span class="gi">+        elif isinstance(token, ast.Name):</span>
<span class="gi">+            result.append(type_to_xref(token.id, env))</span>
<span class="gi">+        elif isinstance(token, ast.Attribute):</span>
<span class="gi">+            attrs = []</span>
<span class="gi">+            node = token</span>
<span class="gi">+            while isinstance(node, ast.Attribute):</span>
<span class="gi">+                attrs.insert(0, node.attr)</span>
<span class="gi">+                node = node.value</span>
<span class="gi">+            if isinstance(node, ast.Name):</span>
<span class="gi">+                attrs.insert(0, node.id)</span>
<span class="gi">+            result.append(type_to_xref(&#39;.&#39;.join(attrs), env))</span>
<span class="gi">+    return result</span>


<span class="w"> </span>class _TypeParameterListParser(TokenProcessor):
<span class="gu">@@ -45,13 +91,61 @@ class _TypeParameterListParser(TokenProcessor):</span>
<span class="w"> </span>def _parse_type_list(tp_list: str, env: BuildEnvironment,
<span class="w"> </span>    multi_line_parameter_list: bool=False) -&gt;addnodes.desc_type_parameter_list:
<span class="w"> </span>    &quot;&quot;&quot;Parse a list of type parameters according to PEP 695.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parser = _TypeParameterListParser(tp_list)</span>
<span class="gi">+    params = parser.type_params</span>
<span class="gi">+    </span>
<span class="gi">+    paramlist = addnodes.desc_type_parameter_list()</span>
<span class="gi">+    for name, pos, bound, default in params:</span>
<span class="gi">+        param = addnodes.desc_type_parameter()</span>
<span class="gi">+        param += nodes.Text(name)</span>
<span class="gi">+        if bound:</span>
<span class="gi">+            param += nodes.Text(&#39;: &#39;)</span>
<span class="gi">+            param += _parse_annotation(bound, env)</span>
<span class="gi">+        if default:</span>
<span class="gi">+            param += nodes.Text(&#39; = &#39;)</span>
<span class="gi">+            param += _parse_annotation(default, env)</span>
<span class="gi">+        paramlist += param</span>
<span class="gi">+    </span>
<span class="gi">+    if multi_line_parameter_list:</span>
<span class="gi">+        paramlist[&#39;multi_line_parameter_list&#39;] = True</span>
<span class="gi">+    </span>
<span class="gi">+    return paramlist</span>


<span class="w"> </span>def _parse_arglist(arglist: str, env: BuildEnvironment,
<span class="w"> </span>    multi_line_parameter_list: bool=False) -&gt;addnodes.desc_parameterlist:
<span class="w"> </span>    &quot;&quot;&quot;Parse a list of arguments using AST parser&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    params = ast.parse(f&#39;def func({arglist}): pass&#39;).body[0].args</span>
<span class="gi">+    </span>
<span class="gi">+    paramlist = addnodes.desc_parameterlist()</span>
<span class="gi">+    for param in params.args + params.kwonlyargs:</span>
<span class="gi">+        param_node = addnodes.desc_parameter()</span>
<span class="gi">+        param_node += nodes.Text(param.arg)</span>
<span class="gi">+        if param.annotation:</span>
<span class="gi">+            param_node += nodes.Text(&#39;: &#39;)</span>
<span class="gi">+            param_node += _parse_annotation(ast.unparse(param.annotation), env)</span>
<span class="gi">+        paramlist += param_node</span>
<span class="gi">+    </span>
<span class="gi">+    if params.vararg:</span>
<span class="gi">+        param_node = addnodes.desc_parameter()</span>
<span class="gi">+        param_node += nodes.Text(f&#39;*{params.vararg.arg}&#39;)</span>
<span class="gi">+        if params.vararg.annotation:</span>
<span class="gi">+            param_node += nodes.Text(&#39;: &#39;)</span>
<span class="gi">+            param_node += _parse_annotation(ast.unparse(params.vararg.annotation), env)</span>
<span class="gi">+        paramlist += param_node</span>
<span class="gi">+    </span>
<span class="gi">+    if params.kwarg:</span>
<span class="gi">+        param_node = addnodes.desc_parameter()</span>
<span class="gi">+        param_node += nodes.Text(f&#39;**{params.kwarg.arg}&#39;)</span>
<span class="gi">+        if params.kwarg.annotation:</span>
<span class="gi">+            param_node += nodes.Text(&#39;: &#39;)</span>
<span class="gi">+            param_node += _parse_annotation(ast.unparse(params.kwarg.annotation), env)</span>
<span class="gi">+        paramlist += param_node</span>
<span class="gi">+    </span>
<span class="gi">+    if multi_line_parameter_list:</span>
<span class="gi">+        paramlist[&#39;multi_line_parameter_list&#39;] = True</span>
<span class="gi">+    </span>
<span class="gi">+    return paramlist</span>


<span class="w"> </span>def _pseudo_parse_arglist(signode: desc_signature, arglist: str,
<span class="gh">diff --git a/sphinx/domains/python/_object.py b/sphinx/domains/python/_object.py</span>
<span class="gh">index 317998cba..69477ad8b 100644</span>
<span class="gd">--- a/sphinx/domains/python/_object.py</span>
<span class="gi">+++ b/sphinx/domains/python/_object.py</span>
<span class="gu">@@ -79,13 +79,13 @@ class PyObject(ObjectDescription[tuple[str, str]]):</span>
<span class="w"> </span>        &quot;&quot;&quot;May return a prefix to put before the object name in the
<span class="w"> </span>        signature.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>

<span class="w"> </span>    def needs_arglist(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;May return true if an empty argument list is to be generated even if
<span class="w"> </span>        the document contains none.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def handle_signature(self, sig: str, signode: desc_signature) -&gt;tuple[
<span class="w"> </span>        str, str]:
<span class="gu">@@ -97,11 +97,72 @@ class PyObject(ObjectDescription[tuple[str, str]]):</span>
<span class="w"> </span>        * it is stripped from the displayed name if present
<span class="w"> </span>        * it is added to the full name (return value) if not present
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = py_sig_re.match(sig)</span>
<span class="gi">+        if m is None:</span>
<span class="gi">+            raise ValueError</span>
<span class="gi">+        </span>
<span class="gi">+        name_prefix, name, arglist, retann = m.groups()</span>
<span class="gi">+</span>
<span class="gi">+        # determine module and class name (if applicable), as well as full name</span>
<span class="gi">+        modname = self.options.get(&#39;module&#39;, self.env.ref_context.get(&#39;py:module&#39;))</span>
<span class="gi">+        classname = self.env.ref_context.get(&#39;py:class&#39;)</span>
<span class="gi">+        if classname:</span>
<span class="gi">+            add_module = False</span>
<span class="gi">+            if name_prefix and name_prefix.startswith(classname):</span>
<span class="gi">+                fullname = name_prefix + name</span>
<span class="gi">+                # class name is given again in the signature</span>
<span class="gi">+                name_prefix = name_prefix[len(classname):].lstrip(&#39;.&#39;)</span>
<span class="gi">+            elif name_prefix:</span>
<span class="gi">+                # class name is given in the signature, but different</span>
<span class="gi">+                # (shouldn&#39;t happen)</span>
<span class="gi">+                fullname = classname + &#39;.&#39; + name_prefix + name</span>
<span class="gi">+            else:</span>
<span class="gi">+                # class name is not given in the signature</span>
<span class="gi">+                fullname = classname + &#39;.&#39; + name</span>
<span class="gi">+        else:</span>
<span class="gi">+            add_module = True</span>
<span class="gi">+            if name_prefix:</span>
<span class="gi">+                classname = name_prefix.rstrip(&#39;.&#39;)</span>
<span class="gi">+                fullname = name_prefix + name</span>
<span class="gi">+            else:</span>
<span class="gi">+                classname = &#39;&#39;</span>
<span class="gi">+                fullname = name</span>
<span class="gi">+</span>
<span class="gi">+        signode[&#39;module&#39;] = modname</span>
<span class="gi">+        signode[&#39;class&#39;] = classname</span>
<span class="gi">+        signode[&#39;fullname&#39;] = fullname</span>
<span class="gi">+</span>
<span class="gi">+        sig_prefix = self.get_signature_prefix(sig)</span>
<span class="gi">+        if sig_prefix:</span>
<span class="gi">+            signode += sig_prefix</span>
<span class="gi">+</span>
<span class="gi">+        if name_prefix:</span>
<span class="gi">+            signode += addnodes.desc_addname(name_prefix, name_prefix)</span>
<span class="gi">+        # exceptions are a special case, since they are documented in the</span>
<span class="gi">+        # &#39;exceptions&#39; module.</span>
<span class="gi">+        elif add_module and self.env.config.add_module_names:</span>
<span class="gi">+            modname = self.options.get(&#39;module&#39;, self.env.ref_context.get(&#39;py:module&#39;))</span>
<span class="gi">+            if modname and modname != &#39;exceptions&#39;:</span>
<span class="gi">+                nodetext = modname + &#39;.&#39;</span>
<span class="gi">+                signode += addnodes.desc_addname(nodetext, nodetext)</span>
<span class="gi">+</span>
<span class="gi">+        signode += addnodes.desc_name(name, name)</span>
<span class="gi">+        if arglist:</span>
<span class="gi">+            try:</span>
<span class="gi">+                signode += _parse_arglist(arglist, self.env)</span>
<span class="gi">+            except SyntaxError:</span>
<span class="gi">+                # fallback to parse arglist original string</span>
<span class="gi">+                signode += addnodes.desc_parameterlist(arglist, arglist)</span>
<span class="gi">+</span>
<span class="gi">+        if retann:</span>
<span class="gi">+            children = _parse_annotation(retann, self.env)</span>
<span class="gi">+            signode += addnodes.desc_returns(retann, &#39;&#39;, *children)</span>
<span class="gi">+</span>
<span class="gi">+        return fullname, name_prefix</span>

<span class="w"> </span>    def get_index_text(self, modname: str, name: tuple[str, str]) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return the text for the index entry of the object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&quot;{name[0]} ({modname})&quot;</span>

<span class="w"> </span>    def before_content(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Handle object nesting before content
<span class="gu">@@ -115,7 +176,15 @@ class PyObject(ObjectDescription[tuple[str, str]]):</span>
<span class="w"> </span>        only the most recent object is tracked. This object prefix name will be
<span class="w"> </span>        removed with :py:meth:`after_content`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.names:</span>
<span class="gi">+            fullname = self.names[-1][0]</span>
<span class="gi">+            if self.allow_nesting:</span>
<span class="gi">+                prefix = fullname + &#39;.&#39;</span>
<span class="gi">+                self.env.ref_context[&#39;py:class&#39;] = fullname</span>
<span class="gi">+                if prefix not in self.env.temp_data.get(&#39;py:class_stack&#39;, []):</span>
<span class="gi">+                    self.env.temp_data.setdefault(&#39;py:class_stack&#39;, []).append(prefix)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.env.temp_data[&#39;py:last_class&#39;] = fullname</span>

<span class="w"> </span>    def after_content(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Handle object de-nesting after content
<span class="gu">@@ -127,4 +196,13 @@ class PyObject(ObjectDescription[tuple[str, str]]):</span>
<span class="w"> </span>        be altered as we didn&#39;t affect the nesting levels in
<span class="w"> </span>        :py:meth:`before_content`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.allow_nesting:</span>
<span class="gi">+            class_stack = self.env.temp_data.get(&#39;py:class_stack&#39;, [])</span>
<span class="gi">+            if class_stack:</span>
<span class="gi">+                class_stack.pop()</span>
<span class="gi">+            if class_stack:</span>
<span class="gi">+                self.env.ref_context[&#39;py:class&#39;] = class_stack[-1].rstrip(&#39;.&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.env.ref_context.pop(&#39;py:class&#39;, None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.env.temp_data.pop(&#39;py:last_class&#39;, None)</span>
<span class="gh">diff --git a/sphinx/domains/rst.py b/sphinx/domains/rst.py</span>
<span class="gh">index fb22cbab5..cd06103e3 100644</span>
<span class="gd">--- a/sphinx/domains/rst.py</span>
<span class="gi">+++ b/sphinx/domains/rst.py</span>
<span class="gu">@@ -38,7 +38,12 @@ def parse_directive(d: str) -&gt;tuple[str, str]:</span>
<span class="w"> </span>    Returns (directive, arguments) string tuple.  If no arguments are given,
<span class="w"> </span>    returns (directive, &#39;&#39;).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = dir_sig_re.match(d.strip())</span>
<span class="gi">+    if match:</span>
<span class="gi">+        directive = match.group(1).strip()</span>
<span class="gi">+        arguments = match.group(2).strip()</span>
<span class="gi">+        return directive, arguments</span>
<span class="gi">+    return d.strip(), &#39;&#39;</span>


<span class="w"> </span>class ReSTDirective(ReSTMarkup):
<span class="gh">diff --git a/sphinx/environment/adapters/asset.py b/sphinx/environment/adapters/asset.py</span>
<span class="gh">index 524c29ad4..72c34f69e 100644</span>
<span class="gd">--- a/sphinx/environment/adapters/asset.py</span>
<span class="gi">+++ b/sphinx/environment/adapters/asset.py</span>
<span class="gu">@@ -10,4 +10,6 @@ class ImageAdapter:</span>

<span class="w"> </span>    def get_original_image_uri(self, name: str) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Get the original image URI.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name in self.env.images:</span>
<span class="gi">+            return self.env.images[name][0]</span>
<span class="gi">+        return name</span>
<span class="gh">diff --git a/sphinx/environment/adapters/indexentries.py b/sphinx/environment/adapters/indexentries.py</span>
<span class="gh">index bb2768a33..a1cd79603 100644</span>
<span class="gd">--- a/sphinx/environment/adapters/indexentries.py</span>
<span class="gi">+++ b/sphinx/environment/adapters/indexentries.py</span>
<span class="gu">@@ -35,24 +35,90 @@ class IndexEntries:</span>
<span class="w"> </span>    def create_index(self, builder: Builder, group_entries: bool=True,
<span class="w"> </span>        _fixre: re.Pattern[str]=re.compile(&#39;(.*) ([(][^()]*[)])&#39;)) -&gt;_Index:
<span class="w"> </span>        &quot;&quot;&quot;Create the real index from the collected index entries.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.builder = builder</span>
<span class="gi">+</span>
<span class="gi">+        content = {}</span>
<span class="gi">+</span>
<span class="gi">+        # collect all entries</span>
<span class="gi">+        for docname in self.env.found_docs:</span>
<span class="gi">+            if docname not in self.env.indexentries:</span>
<span class="gi">+                continue</span>
<span class="gi">+            for entry in self.env.indexentries[docname]:</span>
<span class="gi">+                entry_type = entry[2]</span>
<span class="gi">+                if entry_type == &#39;main&#39;:</span>
<span class="gi">+                    key, targets = entry[1], [(docname, entry[3])]</span>
<span class="gi">+                elif entry_type == &#39;pair&#39;:</span>
<span class="gi">+                    key, targets = entry[1], [(docname, entry[3])]</span>
<span class="gi">+                    key2, targets2 = entry[4], [(docname, entry[5])]</span>
<span class="gi">+                    content.setdefault(key2, ([], {}, None))[0].extend(targets2)</span>
<span class="gi">+                elif entry_type == &#39;triple&#39;:</span>
<span class="gi">+                    key, targets = entry[1], [(docname, entry[3])]</span>
<span class="gi">+                    key2, targets2 = entry[4], [(docname, entry[5])]</span>
<span class="gi">+                    key3, targets3 = entry[6], [(docname, entry[7])]</span>
<span class="gi">+                    content.setdefault(key2, ([], {}, None))[0].extend(targets2)</span>
<span class="gi">+                    content.setdefault(key3, ([], {}, None))[0].extend(targets3)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # if there is a parenthesis in the key, put the parenthesized</span>
<span class="gi">+                # part before the main part</span>
<span class="gi">+                match = _fixre.match(key)</span>
<span class="gi">+                if match:</span>
<span class="gi">+                    key = match.group(2) + &#39; &#39; + match.group(1)</span>
<span class="gi">+                content.setdefault(key, ([], {}, entry[0]))[0].extend(targets)</span>
<span class="gi">+</span>
<span class="gi">+        # sort and group the entries</span>
<span class="gi">+        result = sorted(content.items(), key=_key_func_1)</span>
<span class="gi">+</span>
<span class="gi">+        if group_entries:</span>
<span class="gi">+            # group the entries by letter or category key</span>
<span class="gi">+            grouped_result = []</span>
<span class="gi">+            for group_key, group_items in groupby(result, key=_group_by_func):</span>
<span class="gi">+                grouped_result.append((group_key, list(group_items)))</span>
<span class="gi">+            result = grouped_result</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>


<span class="w"> </span>def _key_func_0(entry: _IndexEntryTarget) -&gt;tuple[bool, str | Literal[False]]:
<span class="w"> </span>    &quot;&quot;&quot;Sort the index entries for same keyword.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Sort by document name (second element of the tuple)</span>
<span class="gi">+    # If it&#39;s a string, return (True, document_name)</span>
<span class="gi">+    # If it&#39;s False, return (False, False)</span>
<span class="gi">+    return (isinstance(entry[1], str), entry[1])</span>


<span class="w"> </span>def _key_func_1(entry: tuple[str, _IndexEntry]) -&gt;tuple[tuple[int, str], str]:
<span class="w"> </span>    &quot;&quot;&quot;Sort the index entries&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    key = entry[0].lower()</span>
<span class="gi">+    # Extract the first character and its Unicode category</span>
<span class="gi">+    first_char = key[0] if key else &#39;&#39;</span>
<span class="gi">+    category = unicodedata.category(first_char)</span>
<span class="gi">+</span>
<span class="gi">+    # Determine the sort key</span>
<span class="gi">+    if category.startswith(&#39;L&#39;):  # Letter</span>
<span class="gi">+        sort_key = (0, key)</span>
<span class="gi">+    elif category.startswith(&#39;N&#39;):  # Number</span>
<span class="gi">+        sort_key = (1, key)</span>
<span class="gi">+    else:  # Symbol or punctuation</span>
<span class="gi">+        sort_key = (2, key)</span>
<span class="gi">+</span>
<span class="gi">+    return (sort_key, key)</span>


<span class="w"> </span>def _key_func_2(entry: tuple[str, _IndexEntryTargets]) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Sort the sub-index entries&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return entry[0].lower()</span>


<span class="w"> </span>def _group_by_func(entry: tuple[str, _IndexEntry]) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Group the entries by letter or category key.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    key = entry[0].lower()</span>
<span class="gi">+    if key.startswith(&#39;_&#39;):</span>
<span class="gi">+        return &#39;_&#39;</span>
<span class="gi">+    elif key[0].isalpha():</span>
<span class="gi">+        return key[0].upper()</span>
<span class="gi">+    elif key[0].isdigit():</span>
<span class="gi">+        return &#39;0 - 9&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return &#39;Symbols&#39;</span>
<span class="gh">diff --git a/sphinx/environment/adapters/toctree.py b/sphinx/environment/adapters/toctree.py</span>
<span class="gh">index e3afbc450..a866fa218 100644</span>
<span class="gd">--- a/sphinx/environment/adapters/toctree.py</span>
<span class="gi">+++ b/sphinx/environment/adapters/toctree.py</span>
<span class="gu">@@ -21,7 +21,14 @@ def note_toctree(env: BuildEnvironment, docname: str, toctreenode: addnodes</span>
<span class="w"> </span>    &quot;&quot;&quot;Note a TOC tree directive in a document and gather information about
<span class="w"> </span>    file relations from it.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for title, ref in toctreenode[&#39;entries&#39;]:</span>
<span class="gi">+        if url_re.match(ref) or ref == &#39;self&#39;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if ref in env.toctree_includes:</span>
<span class="gi">+            env.toctree_includes[ref].add(docname)</span>
<span class="gi">+        else:</span>
<span class="gi">+            env.toctree_includes[ref] = {docname}</span>
<span class="gi">+    env.tocs[docname] = toctreenode</span>


<span class="w"> </span>def document_toc(env: BuildEnvironment, docname: str, tags: Tags) -&gt;Node:
<span class="gu">@@ -31,7 +38,14 @@ def document_toc(env: BuildEnvironment, docname: str, tags: Tags) -&gt;Node:</span>
<span class="w"> </span>    For a ToC tree that shows the document&#39;s place in the
<span class="w"> </span>    ToC structure, use `get_toctree_for`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    doctree = env.get_doctree(docname)</span>
<span class="gi">+    toc = env.get_toc_for(docname, doctree)</span>
<span class="gi">+    </span>
<span class="gi">+    for node in toc.traverse(nodes.reference):</span>
<span class="gi">+        node[&#39;refuri&#39;] = node[&#39;anchorname&#39;]</span>
<span class="gi">+    </span>
<span class="gi">+    _only_node_keep_children(toc, tags)</span>
<span class="gi">+    return toc</span>


<span class="w"> </span>def global_toctree_for_doc(env: BuildEnvironment, docname: str, builder:
<span class="gu">@@ -41,7 +55,24 @@ def global_toctree_for_doc(env: BuildEnvironment, docname: str, builder:</span>

<span class="w"> </span>    This gives the global ToC, with all ancestors and their siblings.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    doctree = env.get_doctree(env.config.master_doc)</span>
<span class="gi">+    toctrees = []</span>
<span class="gi">+    for toctreenode in doctree.traverse(addnodes.toctree):</span>
<span class="gi">+        toctree = _resolve_toctree(env, docname, builder, toctreenode,</span>
<span class="gi">+                                   prune=False, maxdepth=maxdepth,</span>
<span class="gi">+                                   titles_only=titles_only, collapse=collapse,</span>
<span class="gi">+                                   includehidden=includehidden)</span>
<span class="gi">+        if toctree:</span>
<span class="gi">+            toctrees.append(toctree)</span>
<span class="gi">+    </span>
<span class="gi">+    if not toctrees:</span>
<span class="gi">+        return None</span>
<span class="gi">+    </span>
<span class="gi">+    result = toctrees[0]</span>
<span class="gi">+    for toctree in toctrees[1:]:</span>
<span class="gi">+        result.extend(toctree.children)</span>
<span class="gi">+    </span>
<span class="gi">+    return result</span>


<span class="w"> </span>def _resolve_toctree(env: BuildEnvironment, docname: str, builder: Builder,
<span class="gu">@@ -59,7 +90,31 @@ def _resolve_toctree(env: BuildEnvironment, docname: str, builder: Builder,</span>
<span class="w"> </span>    If *collapse* is True, all branches not containing docname will
<span class="w"> </span>    be collapsed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not toctree.get(&#39;entries&#39;):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    maxdepth = maxdepth or toctree.get(&#39;maxdepth&#39;, -1)</span>
<span class="gi">+    toctree_ancestors = set(env.toctree_includes.get(docname, []))</span>
<span class="gi">+    included = Matcher(toctree.get(&#39;includefiles&#39;, []))</span>
<span class="gi">+    excluded = Matcher(toctree.get(&#39;excludefiles&#39;, []))</span>
<span class="gi">+</span>
<span class="gi">+    entries = _entries_from_toctree(</span>
<span class="gi">+        env, prune, titles_only, collapse, includehidden,</span>
<span class="gi">+        builder.tags, toctree_ancestors, included, excluded,</span>
<span class="gi">+        toctree, [docname]</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if not entries:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    wrapper = nodes.bullet_list()</span>
<span class="gi">+    for entry in entries:</span>
<span class="gi">+        wrapper += entry</span>
<span class="gi">+</span>
<span class="gi">+    if prune:</span>
<span class="gi">+        wrapper = _toctree_copy(wrapper, 1, maxdepth, collapse, builder.tags)</span>
<span class="gi">+</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>def _entries_from_toctree(env: BuildEnvironment, prune: bool, titles_only:
<span class="gu">@@ -68,7 +123,48 @@ def _entries_from_toctree(env: BuildEnvironment, prune: bool, titles_only:</span>
<span class="w"> </span>    toctreenode: addnodes.toctree, parents: list[str], subtree: bool=False
<span class="w"> </span>    ) -&gt;list[Element]:
<span class="w"> </span>    &quot;&quot;&quot;Return TOC entries for a toctree node.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    entries = []</span>
<span class="gi">+    for (title, ref) in toctreenode[&#39;entries&#39;]:</span>
<span class="gi">+        if url_re.match(ref) or ref == &#39;self&#39;:</span>
<span class="gi">+            entries.append(nodes.reference(ref, title, refuri=ref))</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if ref in parents:</span>
<span class="gi">+            logger.warning(__(&#39;circular toctree references detected, ignoring: %s&#39;),</span>
<span class="gi">+                           &#39; -&gt; &#39;.join(parents))</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if not included(ref) or excluded(ref):</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if ref not in env.tocs:</span>
<span class="gi">+            logger.warning(__(&#39;toctree contains reference to nonexisting document %r&#39;),</span>
<span class="gi">+                           ref, location=toctreenode)</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        toc = env.tocs[ref]</span>
<span class="gi">+        if not toc.traverse(nodes.section):</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        entry = _toctree_copy(toc, 1, 1, collapse, tags)</span>
<span class="gi">+        if title and title != clean_astext(toc[0]):</span>
<span class="gi">+            entry[0].insert(0, nodes.Text(title))</span>
<span class="gi">+</span>
<span class="gi">+        if not subtree and ref in toctree_ancestors:</span>
<span class="gi">+            _toctree_add_classes(entry[0], 1, ref)</span>
<span class="gi">+</span>
<span class="gi">+        entries.append(entry)</span>
<span class="gi">+</span>
<span class="gi">+        if includehidden:</span>
<span class="gi">+            for subnode in toc.traverse(addnodes.toctree):</span>
<span class="gi">+                subentries = _entries_from_toctree(</span>
<span class="gi">+                    env, prune, titles_only, collapse, includehidden,</span>
<span class="gi">+                    tags, toctree_ancestors, included, excluded,</span>
<span class="gi">+                    subnode, parents + [ref], subtree=True</span>
<span class="gi">+                )</span>
<span class="gi">+                entries.extend(subentries)</span>
<span class="gi">+</span>
<span class="gi">+    return entries</span>


<span class="w"> </span>def _toctree_add_classes(node: Element, depth: int, docname: str) -&gt;None:
<span class="gh">diff --git a/sphinx/environment/collectors/asset.py b/sphinx/environment/collectors/asset.py</span>
<span class="gh">index 7fe3a334b..c3bac6dbb 100644</span>
<span class="gd">--- a/sphinx/environment/collectors/asset.py</span>
<span class="gi">+++ b/sphinx/environment/collectors/asset.py</span>
<span class="gu">@@ -25,7 +25,27 @@ class ImageCollector(EnvironmentCollector):</span>

<span class="w"> </span>    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Process and rewrite image URIs.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        env = app.env</span>
<span class="gi">+        for node in doctree.traverse(nodes.image):</span>
<span class="gi">+            uri = node[&#39;uri&#39;]</span>
<span class="gi">+            if uri.startswith(&#39;data:&#39;):</span>
<span class="gi">+                continue  # Skip data URIs</span>
<span class="gi">+</span>
<span class="gi">+            # Handle language-specific images</span>
<span class="gi">+            if env.config.language:</span>
<span class="gi">+                new_uri = get_image_filename_for_language(uri, env)</span>
<span class="gi">+                if new_uri:</span>
<span class="gi">+                    node[&#39;uri&#39;] = new_uri</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+            # Rewrite relative URIs</span>
<span class="gi">+            if &#39;://&#39; not in uri and not uri.startswith(&#39;/&#39;):</span>
<span class="gi">+                node[&#39;uri&#39;] = path.join(env.docname, uri)</span>
<span class="gi">+                node[&#39;candidates&#39;] = {&#39;*&#39;: node[&#39;uri&#39;]}</span>
<span class="gi">+</span>
<span class="gi">+            # Add to environment&#39;s image list</span>
<span class="gi">+            if node[&#39;uri&#39;] not in env.images:</span>
<span class="gi">+                env.images[node[&#39;uri&#39;]] = (env.docname, node[&#39;uri&#39;])</span>


<span class="w"> </span>class DownloadFileCollector(EnvironmentCollector):
<span class="gu">@@ -33,4 +53,21 @@ class DownloadFileCollector(EnvironmentCollector):</span>

<span class="w"> </span>    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Process downloadable file paths.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        env = app.env</span>
<span class="gi">+        for node in doctree.traverse(addnodes.download_reference):</span>
<span class="gi">+            if &#39;filename&#39; not in node:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            filename = node[&#39;filename&#39;]</span>
<span class="gi">+            if &#39;://&#39; in filename or filename.startswith(&#39;/&#39;):</span>
<span class="gi">+                continue  # Skip absolute URIs or external links</span>
<span class="gi">+</span>
<span class="gi">+            # Rewrite relative paths</span>
<span class="gi">+            docdir = path.dirname(env.doc2path(env.docname, base=None))</span>
<span class="gi">+            filepath = path.normpath(path.join(docdir, filename))</span>
<span class="gi">+            if path.isfile(path.join(env.srcdir, filepath)):</span>
<span class="gi">+                node[&#39;filename&#39;] = filepath</span>
<span class="gi">+                env.dependencies[env.docname].add(filepath)</span>
<span class="gi">+            else:</span>
<span class="gi">+                logger.warning(__(&#39;download file not found: %s&#39;) % filename,</span>
<span class="gi">+                               location=node)</span>
<span class="gh">diff --git a/sphinx/environment/collectors/dependencies.py b/sphinx/environment/collectors/dependencies.py</span>
<span class="gh">index 25637aa67..92e74dc01 100644</span>
<span class="gd">--- a/sphinx/environment/collectors/dependencies.py</span>
<span class="gi">+++ b/sphinx/environment/collectors/dependencies.py</span>
<span class="gu">@@ -18,4 +18,23 @@ class DependenciesCollector(EnvironmentCollector):</span>

<span class="w"> </span>    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Process docutils-generated dependency info.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        env = app.env</span>
<span class="gi">+        docname = env.docname</span>
<span class="gi">+</span>
<span class="gi">+        # Get the current file&#39;s directory</span>
<span class="gi">+        base_dir = path.dirname(env.doc2path(docname, base=None))</span>
<span class="gi">+</span>
<span class="gi">+        for node in doctree.traverse(nodes.dependent):</span>
<span class="gi">+            dep = node[&#39;name&#39;]</span>
<span class="gi">+            if path.isabs(dep):</span>
<span class="gi">+                env.note_dependency(dep)</span>
<span class="gi">+            else:</span>
<span class="gi">+                rel_filename = relative_path(base_dir, dep)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    # Try to decode the filename using the filesystem encoding</span>
<span class="gi">+                    filename = rel_filename.encode(fs_encoding).decode(&#39;utf-8&#39;)</span>
<span class="gi">+                except UnicodeDecodeError:</span>
<span class="gi">+                    # If decoding fails, use the original filename</span>
<span class="gi">+                    filename = rel_filename</span>
<span class="gi">+</span>
<span class="gi">+                env.note_dependency(path.normpath(path.join(base_dir, filename)))</span>
<span class="gh">diff --git a/sphinx/environment/collectors/metadata.py b/sphinx/environment/collectors/metadata.py</span>
<span class="gh">index 199b4eb5e..7995bfe4e 100644</span>
<span class="gd">--- a/sphinx/environment/collectors/metadata.py</span>
<span class="gi">+++ b/sphinx/environment/collectors/metadata.py</span>
<span class="gu">@@ -17,4 +17,14 @@ class MetadataCollector(EnvironmentCollector):</span>

<span class="w"> </span>        Keep processing minimal -- just return what docutils says.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        metadata = {}</span>
<span class="gi">+        for node in doctree.traverse(nodes.docinfo):</span>
<span class="gi">+            for child in node.children:</span>
<span class="gi">+                if isinstance(child, nodes.field):</span>
<span class="gi">+                    field_name = child.children[0].astext()</span>
<span class="gi">+                    field_body = child.children[1].astext()</span>
<span class="gi">+                    metadata[field_name] = field_body</span>
<span class="gi">+                elif isinstance(child, nodes.TextElement):</span>
<span class="gi">+                    metadata[child.__class__.__name__] = child.astext()</span>
<span class="gi">+        </span>
<span class="gi">+        doctree.settings.env.metadata[doctree.get(&#39;source&#39;)] = metadata</span>
<span class="gh">diff --git a/sphinx/environment/collectors/title.py b/sphinx/environment/collectors/title.py</span>
<span class="gh">index 640a7a3a2..16cc5fbbd 100644</span>
<span class="gd">--- a/sphinx/environment/collectors/title.py</span>
<span class="gi">+++ b/sphinx/environment/collectors/title.py</span>
<span class="gu">@@ -13,8 +13,24 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>class TitleCollector(EnvironmentCollector):
<span class="w"> </span>    &quot;&quot;&quot;title collector for sphinx.environment.&quot;&quot;&quot;

<span class="gd">-    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt;None:</span>
<span class="gi">+    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a title node to the document (just copy the first section title),
<span class="w"> </span>        and store that title in the environment.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        titlenode = nodes.title()</span>
<span class="gi">+        visitor = SphinxContentsFilter(doctree)</span>
<span class="gi">+        doctree.walkabout(visitor)</span>
<span class="gi">+        if visitor.title:</span>
<span class="gi">+            titlenode += visitor.title</span>
<span class="gi">+        else:</span>
<span class="gi">+            # if no title exists, use the document&#39;s first heading as the title</span>
<span class="gi">+            for node in doctree.traverse(nodes.section):</span>
<span class="gi">+                if node.children and isinstance(node.children[0], nodes.title):</span>
<span class="gi">+                    titlenode += node.children[0].deepcopy()</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+        if titlenode:</span>
<span class="gi">+            doctree.insert(0, titlenode)</span>
<span class="gi">+            app.env.titles[app.env.docname] = titlenode</span>
<span class="gi">+        else:</span>
<span class="gi">+            app.env.titles[app.env.docname] = None</span>
<span class="gh">diff --git a/sphinx/environment/collectors/toctree.py b/sphinx/environment/collectors/toctree.py</span>
<span class="gh">index c429eda00..0ecb02280 100644</span>
<span class="gd">--- a/sphinx/environment/collectors/toctree.py</span>
<span class="gi">+++ b/sphinx/environment/collectors/toctree.py</span>
<span class="gu">@@ -22,12 +22,173 @@ class TocTreeCollector(EnvironmentCollector):</span>

<span class="w"> </span>    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Build a TOC from the doctree and store it in the inventory.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        docname = app.env.docname</span>
<span class="gi">+        numentries = [0]  # nonlocal again...</span>
<span class="gi">+</span>
<span class="gi">+        def traverse_in_section(node: Element, cls: type[N]) -&gt;list[N]:</span>
<span class="gi">+            result = []</span>
<span class="gi">+            if isinstance(node, cls):</span>
<span class="gi">+                result.append(node)</span>
<span class="gi">+            for child in node.children:</span>
<span class="gi">+                if isinstance(child, nodes.section):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                result.extend(traverse_in_section(child, cls))</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        def build_toc(node: Element, depth: int = 1) -&gt;None:</span>
<span class="gi">+            entries = []</span>
<span class="gi">+            for sectionnode in node:</span>
<span class="gi">+                if not isinstance(sectionnode, nodes.section):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                title = sectionnode.next_node(nodes.title)</span>
<span class="gi">+                if not title:</span>
<span class="gi">+                    # empty section</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if depth &gt; app.config.toc_maxdepth:</span>
<span class="gi">+                    # don&#39;t go deeper than toc_maxdepth</span>
<span class="gi">+                    continue</span>
<span class="gi">+                reference = nodes.reference(&#39;&#39;, &#39;&#39;, internal=True,</span>
<span class="gi">+                                            refuri=app.builder.get_relative_uri(docname, docname),</span>
<span class="gi">+                                            anchorname=title[&#39;ids&#39;][0],</span>
<span class="gi">+                                            *title.children)</span>
<span class="gi">+                para = addnodes.compact_paragraph(&#39;&#39;, &#39;&#39;, reference)</span>
<span class="gi">+                item = nodes.list_item(&#39;&#39;, para)</span>
<span class="gi">+                sub_item = build_toc(sectionnode, depth + 1)</span>
<span class="gi">+                item += sub_item</span>
<span class="gi">+                entries.append(item)</span>
<span class="gi">+                numentries[0] += 1</span>
<span class="gi">+            if entries:</span>
<span class="gi">+                return nodes.bullet_list(&#39;&#39;, *entries)</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        toc = build_toc(doctree)</span>
<span class="gi">+        if toc:</span>
<span class="gi">+            app.env.tocs[docname] = toc</span>
<span class="gi">+        else:</span>
<span class="gi">+            app.env.tocs[docname] = nodes.bullet_list(&#39;&#39;)</span>
<span class="gi">+        app.env.toc_num_entries[docname] = numentries[0]</span>
<span class="gi">+</span>
<span class="gi">+        # store labels of this doc to environment</span>
<span class="gi">+        for labelid, labelnode in doctree.nametypes.items():</span>
<span class="gi">+            if not isinstance(labelnode, nodes.Element):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if labelid not in doctree.ids:</span>
<span class="gi">+                continue</span>
<span class="gi">+            node = doctree.ids[labelid]</span>
<span class="gi">+            if isinstance(node, nodes.target):</span>
<span class="gi">+                node = node.parent</span>
<span class="gi">+            if isinstance(node, (nodes.section, nodes.table, nodes.figure)):</span>
<span class="gi">+                sectname = node.next_node(nodes.title).astext() if isinstance(node, nodes.section) else &#39;&#39;</span>
<span class="gi">+                app.env.labels[labelid] = app.env.docname, node[&#39;ids&#39;][0], sectname</span>
<span class="gi">+                app.env.anonlabels[labelid] = app.env.docname, node[&#39;ids&#39;][0]</span>
<span class="gi">+</span>
<span class="gi">+        # add labels from the &quot;label&quot; directive</span>
<span class="gi">+        for name, explicit in list(doctree.nametypes.items()):</span>
<span class="gi">+            if not explicit:</span>
<span class="gi">+                continue</span>
<span class="gi">+            labelid = doctree.nameids[name]</span>
<span class="gi">+            if labelid is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            node = doctree.ids[labelid]</span>
<span class="gi">+            if isinstance(node, nodes.target):</span>
<span class="gi">+                node = node.parent</span>
<span class="gi">+            if isinstance(node, (nodes.section, nodes.table, nodes.figure)):</span>
<span class="gi">+                sectname = node.next_node(nodes.title).astext() if isinstance(node, nodes.section) else &#39;&#39;</span>
<span class="gi">+                app.env.labels[name] = app.env.docname, node[&#39;ids&#39;][0], sectname</span>
<span class="gi">+                app.env.anonlabels[name] = app.env.docname, node[&#39;ids&#39;][0]</span>

<span class="w"> </span>    def assign_section_numbers(self, env: BuildEnvironment) -&gt;list[str]:
<span class="w"> </span>        &quot;&quot;&quot;Assign a section number to each heading under a numbered toctree.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def _walk_toc(node: Element, secnums: dict[str, tuple[int, ...]], depth: int, titlenode: Element | None = None) -&gt;None:</span>
<span class="gi">+            # titlenode is the title of the document, it will get assigned a</span>
<span class="gi">+            # secnumber too, so that it shows up in next/prev/parent rellinks</span>
<span class="gi">+            for subnode in node.children:</span>
<span class="gi">+                if isinstance(subnode, nodes.bullet_list):</span>
<span class="gi">+                    numstack.append(0)</span>
<span class="gi">+                    _walk_toc(subnode, secnums, depth - 1, titlenode)</span>
<span class="gi">+                    numstack.pop()</span>
<span class="gi">+                    titlenode = None</span>
<span class="gi">+                elif isinstance(subnode, nodes.list_item):</span>
<span class="gi">+                    _walk_toc(subnode, secnums, depth, titlenode)</span>
<span class="gi">+                    titlenode = None</span>
<span class="gi">+                elif isinstance(subnode, addnodes.compact_paragraph):</span>
<span class="gi">+                    numstack[-1] += 1</span>
<span class="gi">+                    if depth &gt; 0:</span>
<span class="gi">+                        number = tuple(numstack)</span>
<span class="gi">+                        secnums[subnode[0][&#39;anchorname&#39;]] = number</span>
<span class="gi">+                        for refnode in subnode[0][&#39;refuri&#39;]:</span>
<span class="gi">+                            if refnode.hasattr(&#39;secnumber&#39;):</span>
<span class="gi">+                                refnode[&#39;secnumber&#39;] = number</span>
<span class="gi">+                        if titlenode:</span>
<span class="gi">+                            titlenode[&#39;secnumber&#39;] = number</span>
<span class="gi">+                            titlenode = None</span>
<span class="gi">+                elif isinstance(subnode, addnodes.toctree):</span>
<span class="gi">+                    _walk_toctree(subnode)</span>
<span class="gi">+</span>
<span class="gi">+        def _walk_toctree(toctreenode: addnodes.toctree) -&gt;None:</span>
<span class="gi">+            if &#39;numbered&#39; in toctreenode:</span>
<span class="gi">+                numstack.append(0)</span>
<span class="gi">+                for title, ref in toctreenode[&#39;entries&#39;]:</span>
<span class="gi">+                    if url_re.match(ref) or ref == &#39;self&#39;:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if ref in env.tocs:</span>
<span class="gi">+                        _walk_toc(env.tocs[ref], secnums, depth,</span>
<span class="gi">+                                  env.titles.get(ref))</span>
<span class="gi">+                    numstack[-1] += 1</span>
<span class="gi">+                numstack.pop()</span>
<span class="gi">+</span>
<span class="gi">+        secnums: dict[str, tuple[int, ...]] = {}</span>
<span class="gi">+        depth = env.config.toc_secnumber_depth</span>
<span class="gi">+        numstack: list[int] = []</span>
<span class="gi">+        for docname in env.toctree_includes:</span>
<span class="gi">+            if docname not in env.tocs:</span>
<span class="gi">+                continue</span>
<span class="gi">+            _walk_toc(env.tocs[docname], secnums, depth,</span>
<span class="gi">+                      env.titles.get(docname))</span>
<span class="gi">+</span>
<span class="gi">+        for docname, secnum in secnums.items():</span>
<span class="gi">+            env.toc_secnumbers[docname] = secnum</span>
<span class="gi">+</span>
<span class="gi">+        return list(secnums.keys())</span>

<span class="w"> </span>    def assign_figure_numbers(self, env: BuildEnvironment) -&gt;list[str]:
<span class="w"> </span>        &quot;&quot;&quot;Assign a figure number to each figure under a numbered toctree.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fignum_builders = {</span>
<span class="gi">+            &#39;arabic&#39;: lambda x: str(x),</span>
<span class="gi">+            &#39;loweralpha&#39;: lambda x: chr(ord(&#39;a&#39;) + x - 1),</span>
<span class="gi">+            &#39;upperalpha&#39;: lambda x: chr(ord(&#39;A&#39;) + x - 1),</span>
<span class="gi">+            &#39;lowerroman&#39;: lambda x: int_to_roman(x).lower(),</span>
<span class="gi">+            &#39;upperroman&#39;: lambda x: int_to_roman(x),</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        def get_figtype(node: Element) -&gt;str | None:</span>
<span class="gi">+            for figtype in env.config.numfig_format:</span>
<span class="gi">+                if node.get(&#39;figtype&#39;) == figtype:</span>
<span class="gi">+                    return figtype</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        def get_next_fignumber(figtype: str) -&gt;int:</span>
<span class="gi">+            fignumber = env.toc_fignumbers.get(env.docname, {})</span>
<span class="gi">+            figure_id = fignumber.get(figtype, 0) + 1</span>
<span class="gi">+            fignumber[figtype] = figure_id</span>
<span class="gi">+            env.toc_fignumbers[env.docname] = fignumber</span>
<span class="gi">+            return figure_id</span>
<span class="gi">+</span>
<span class="gi">+        def get_fignumber(figtype: str, fignumber: int) -&gt;str:</span>
<span class="gi">+            builder = fignum_builders[env.config.numfig_format.get(figtype, &#39;arabic&#39;)]</span>
<span class="gi">+            return builder(fignumber)</span>
<span class="gi">+</span>
<span class="gi">+        numbered: list[str] = []</span>
<span class="gi">+        for docname, toc in env.tocs.items():</span>
<span class="gi">+            secnumber = env.toc_secnumbers.get(docname, ())</span>
<span class="gi">+            env.docname = docname</span>
<span class="gi">+            for node in toc.traverse(nodes.reference):</span>
<span class="gi">+                if node.get(&#39;refuri&#39;) in env.tocs:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                figtype = get_figtype(node)</span>
<span class="gi">+                if figtype:</span>
<span class="gi">+                    fignumber = get_next_fignumber(figtype)</span>
<span class="gi">+                    node[&#39;fignumber&#39;] = get_fignumber(figtype, fignumber)</span>
<span class="gi">+                    numbered.append(node[&#39;refuri&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        return numbered</span>
<span class="gh">diff --git a/sphinx/ext/apidoc.py b/sphinx/ext/apidoc.py</span>
<span class="gh">index 255a1c96b..350e2b7f7 100644</span>
<span class="gd">--- a/sphinx/ext/apidoc.py</span>
<span class="gi">+++ b/sphinx/ext/apidoc.py</span>
<span class="gu">@@ -41,29 +41,49 @@ template_dir = path.join(package_dir, &#39;templates&#39;, &#39;apidoc&#39;)</span>

<span class="w"> </span>def is_initpy(filename: (str | Path)) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check *filename* is __init__ file or not.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Path(filename).name == &#39;__init__.py&#39;</span>


<span class="w"> </span>def module_join(*modnames: (str | None)) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Join module names with dots.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &#39;.&#39;.join(filter(None, modnames))</span>


<span class="w"> </span>def is_packagedir(dirname: (str | None)=None, files: (list[str] | None)=None
<span class="w"> </span>    ) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check given *files* contains __init__ file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if dirname is not None:</span>
<span class="gi">+        files = os.listdir(dirname)</span>
<span class="gi">+    return &#39;__init__.py&#39; in (files or [])</span>


<span class="w"> </span>def write_file(name: str, text: str, opts: CliOptions) -&gt;Path:
<span class="w"> </span>    &quot;&quot;&quot;Write the output file for module/package &lt;name&gt;.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fname = Path(opts.destdir) / f&quot;{name}.{opts.suffix}&quot;</span>
<span class="gi">+    if opts.dryrun:</span>
<span class="gi">+        logger.info(__(&#39;[dry run] Would create file %s&#39;), fname)</span>
<span class="gi">+        return fname</span>
<span class="gi">+    logger.info(__(&#39;Creating file %s.&#39;), fname)</span>
<span class="gi">+    with FileAvoidWrite(fname) as f:</span>
<span class="gi">+        f.write(text)</span>
<span class="gi">+    return fname</span>


<span class="w"> </span>def create_module_file(package: (str | None), basename: str, opts:
<span class="w"> </span>    CliOptions, user_template_dir: (str | None)=None) -&gt;Path:
<span class="w"> </span>    &quot;&quot;&quot;Build the text of the file and write the file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    qualname = module_join(package, basename)</span>
<span class="gi">+    context = {</span>
<span class="gi">+        &#39;show_headings&#39;: not opts.noheadings,</span>
<span class="gi">+        &#39;basename&#39;: basename,</span>
<span class="gi">+        &#39;qualname&#39;: qualname,</span>
<span class="gi">+        &#39;automodule_options&#39;: OPTIONS,</span>
<span class="gi">+        &#39;modulefirst&#39;: opts.modulefirst,</span>
<span class="gi">+        &#39;includeprivate&#39;: opts.includeprivate,</span>
<span class="gi">+        &#39;fullname&#39;: opts.full and qualname or basename,</span>
<span class="gi">+    }</span>
<span class="gi">+    text = ReSTRenderer(user_template_dir or template_dir).render(&#39;module.rst_t&#39;, context)</span>
<span class="gi">+    return write_file(qualname, text, opts)</span>


<span class="w"> </span>def create_package_file(root: str, master_package: (str | None), subroot:
<span class="gu">@@ -76,7 +96,35 @@ def create_package_file(root: str, master_package: (str | None), subroot:</span>

<span class="w"> </span>    :returns: list of written files
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    text = []</span>
<span class="gi">+    written = []</span>
<span class="gi">+</span>
<span class="gi">+    package = module_join(master_package, subroot)</span>
<span class="gi">+    basename = path.basename(root)</span>
<span class="gi">+</span>
<span class="gi">+    context = {</span>
<span class="gi">+        &#39;show_headings&#39;: not opts.noheadings,</span>
<span class="gi">+        &#39;basename&#39;: basename,</span>
<span class="gi">+        &#39;package&#39;: package,</span>
<span class="gi">+        &#39;subpackage&#39;: subroot,</span>
<span class="gi">+        &#39;automodule_options&#39;: OPTIONS,</span>
<span class="gi">+        &#39;modulefirst&#39;: opts.modulefirst,</span>
<span class="gi">+        &#39;includeprivate&#39;: opts.includeprivate,</span>
<span class="gi">+        &#39;fullname&#39;: opts.full and package or subroot,</span>
<span class="gi">+        &#39;members&#39;: sorted(py_files),</span>
<span class="gi">+        &#39;subpackages&#39;: sorted(subs),</span>
<span class="gi">+        &#39;is_namespace&#39;: is_namespace,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    text = ReSTRenderer(user_template_dir or template_dir).render(&#39;package.rst_t&#39;, context)</span>
<span class="gi">+    written.append(write_file(package, text, opts))</span>
<span class="gi">+</span>
<span class="gi">+    if opts.separatemodules:</span>
<span class="gi">+        for py_file in py_files:</span>
<span class="gi">+            if not is_skipped_module(py_file, opts, excludes):</span>
<span class="gi">+                written.append(create_module_file(package, py_file, opts, user_template_dir))</span>
<span class="gi">+</span>
<span class="gi">+    return written</span>


<span class="w"> </span>def create_modules_toc_file(modules: list[str], opts: CliOptions, name: str
<span class="gh">diff --git a/sphinx/ext/autodoc/directive.py b/sphinx/ext/autodoc/directive.py</span>
<span class="gh">index cbc59b16f..3869994ae 100644</span>
<span class="gd">--- a/sphinx/ext/autodoc/directive.py</span>
<span class="gi">+++ b/sphinx/ext/autodoc/directive.py</span>
<span class="gu">@@ -50,13 +50,39 @@ class DocumenterBridge:</span>
<span class="w"> </span>def process_documenter_options(documenter: type[Documenter], config: Config,
<span class="w"> </span>    options: dict[str, str]) -&gt;Options:
<span class="w"> </span>    &quot;&quot;&quot;Recognize options of Documenter from user input.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for name in AUTODOC_DEFAULT_OPTIONS:</span>
<span class="gi">+        if name not in documenter.option_spec:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if name in config.autodoc_default_options and name not in options:</span>
<span class="gi">+            options[name] = config.autodoc_default_options[name]</span>
<span class="gi">+</span>
<span class="gi">+    final_options = Options()</span>
<span class="gi">+    for arg, value in options.items():</span>
<span class="gi">+        if arg in documenter.option_spec:</span>
<span class="gi">+            final_options[arg] = documenter.option_spec[arg](value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            final_options[arg] = value</span>
<span class="gi">+</span>
<span class="gi">+    # handle special options</span>
<span class="gi">+    for name in AUTODOC_EXTENDABLE_OPTIONS:</span>
<span class="gi">+        if name in final_options:</span>
<span class="gi">+            final_options[name] = [x.strip() for x in final_options[name].split(&#39;,&#39;)]</span>
<span class="gi">+</span>
<span class="gi">+    return final_options</span>


<span class="w"> </span>def parse_generated_content(state: RSTState, content: StringList,
<span class="w"> </span>    documenter: Documenter) -&gt;list[Node]:
<span class="w"> </span>    &quot;&quot;&quot;Parse an item of content generated by Documenter.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with switch_source_input(state, content):</span>
<span class="gi">+        if documenter.titles_allowed:</span>
<span class="gi">+            node = nodes.section()</span>
<span class="gi">+            # necessary so that the child nodes get the right source/line set</span>
<span class="gi">+            node.document = state.document</span>
<span class="gi">+            nested_parse_to_nodes(state, content, node)</span>
<span class="gi">+            return node.children</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [nodes.paragraph(text=text) for text in content]</span>


<span class="w"> </span>class AutodocDirective(SphinxDirective):
<span class="gh">diff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py</span>
<span class="gh">index efb94f8f3..0df884543 100644</span>
<span class="gd">--- a/sphinx/ext/autodoc/importer.py</span>
<span class="gi">+++ b/sphinx/ext/autodoc/importer.py</span>
<span class="gu">@@ -31,29 +31,46 @@ def _filter_enum_dict(enum_class: type[Enum], attrgetter: Callable[[Any,</span>
<span class="w"> </span>    but with different defining class. The order of occurrence is guided by
<span class="w"> </span>    the MRO of *enum_class*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for cls in getmro(enum_class):</span>
<span class="gi">+        for name, value in cls.__dict__.items():</span>
<span class="gi">+            if name in enum_class_dict:</span>
<span class="gi">+                yield name, cls, attrgetter(enum_class, name, value)</span>


<span class="w"> </span>def mangle(subject: Any, name: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Mangle the given name.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if name.startswith(&#39;__&#39;) and not name.endswith(&#39;__&#39;):</span>
<span class="gi">+        cls_name = subject.__class__.__name__.lstrip(&#39;_&#39;)</span>
<span class="gi">+        return f&#39;_{cls_name}{name}&#39;</span>
<span class="gi">+    return name</span>


<span class="w"> </span>def unmangle(subject: Any, name: str) -&gt;(str | None):
<span class="w"> </span>    &quot;&quot;&quot;Unmangle the given name.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if name.startswith(&#39;_&#39;):</span>
<span class="gi">+        cls_name = subject.__class__.__name__.lstrip(&#39;_&#39;)</span>
<span class="gi">+        prefix = f&#39;_{cls_name}__&#39;</span>
<span class="gi">+        if name.startswith(prefix) and not name.endswith(&#39;__&#39;):</span>
<span class="gi">+            return name[len(prefix):]</span>
<span class="gi">+    return name</span>


<span class="w"> </span>def import_module(modname: str) -&gt;Any:
<span class="w"> </span>    &quot;&quot;&quot;Call importlib.import_module(modname), convert exceptions to ImportError.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return importlib.import_module(modname)</span>
<span class="gi">+    except Exception as exc:</span>
<span class="gi">+        raise ImportError(f&#39;Could not import module {modname}: {exc}&#39;) from exc</span>


<span class="w"> </span>def _reload_module(module: ModuleType) -&gt;Any:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Call importlib.reload(module), convert exceptions to ImportError
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return importlib.reload(module)</span>
<span class="gi">+    except Exception as exc:</span>
<span class="gi">+        raise ImportError(f&#39;Could not reload module {module.__name__}: {exc}&#39;) from exc</span>


<span class="w"> </span>class Attribute(NamedTuple):
<span class="gu">@@ -65,10 +82,45 @@ class Attribute(NamedTuple):</span>
<span class="w"> </span>def get_object_members(subject: Any, objpath: list[str], attrgetter:
<span class="w"> </span>    Callable, analyzer: (ModuleAnalyzer | None)=None) -&gt;dict[str, Attribute]:
<span class="w"> </span>    &quot;&quot;&quot;Get members and attributes of target object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    members = {}</span>
<span class="gi">+    for name in dir(subject):</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = attrgetter(subject, name, None)</span>
<span class="gi">+            directly_defined = hasattr(subject, name)</span>
<span class="gi">+            members[name] = Attribute(name, directly_defined, value)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+    if analyzer:</span>
<span class="gi">+        namespace = &#39;.&#39;.join(objpath)</span>
<span class="gi">+        for (ns, name), docstring in analyzer.find_attr_docs().items():</span>
<span class="gi">+            if ns == namespace and name not in members:</span>
<span class="gi">+                members[name] = Attribute(name, True, None)</span>
<span class="gi">+</span>
<span class="gi">+    return members</span>


<span class="w"> </span>def get_class_members(subject: Any, objpath: Any, attrgetter: Callable,
<span class="w"> </span>    inherit_docstrings: bool=True) -&gt;dict[str, ObjectMember]:
<span class="w"> </span>    &quot;&quot;&quot;Get members and attributes of target class.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from sphinx.ext.autodoc import ObjectMember  # Import here to avoid circular import</span>
<span class="gi">+</span>
<span class="gi">+    members = {}</span>
<span class="gi">+</span>
<span class="gi">+    # Get all members from the class and its bases</span>
<span class="gi">+    for cls in getmro(subject):</span>
<span class="gi">+        for name in dir(cls):</span>
<span class="gi">+            if name not in members:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    value = attrgetter(subject, name, None)</span>
<span class="gi">+                    if inherit_docstrings:</span>
<span class="gi">+                        docstring = getattr(value, &#39;__doc__&#39;, None)</span>
<span class="gi">+                        if docstring is None:</span>
<span class="gi">+                            docstring = getattr(cls.__dict__.get(name), &#39;__doc__&#39;, None)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        docstring = None</span>
<span class="gi">+                    members[name] = ObjectMember(name, value, cls, docstring)</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+    return members</span>
<span class="gh">diff --git a/sphinx/ext/autodoc/mock.py b/sphinx/ext/autodoc/mock.py</span>
<span class="gh">index 2a6922a24..5638b501e 100644</span>
<span class="gd">--- a/sphinx/ext/autodoc/mock.py</span>
<span class="gi">+++ b/sphinx/ext/autodoc/mock.py</span>
<span class="gu">@@ -109,17 +109,26 @@ def mock(modnames: list[str]) -&gt;Iterator[None]:</span>
<span class="w"> </span>        # mock modules are enabled here
<span class="w"> </span>        ...
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    finder = MockFinder(modnames)</span>
<span class="gi">+    sys.meta_path.insert(0, finder)</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        sys.meta_path.remove(finder)</span>
<span class="gi">+        for modname in finder.mocked_modules:</span>
<span class="gi">+            sys.modules.pop(modname, None)</span>


<span class="w"> </span>def ismockmodule(subject: Any) -&gt;TypeIs[_MockModule]:
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is a mocked module.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(subject, _MockModule)</span>


<span class="w"> </span>def ismock(subject: Any) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is mocked.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (ismockmodule(subject) or</span>
<span class="gi">+            (isinstance(subject, type) and issubclass(subject, _MockObject)) or</span>
<span class="gi">+            isinstance(subject, _MockObject))</span>


<span class="w"> </span>def undecorate(subject: _MockObject) -&gt;Any:
<span class="gu">@@ -127,4 +136,6 @@ def undecorate(subject: _MockObject) -&gt;Any:</span>

<span class="w"> </span>    If not decorated, returns given *subject* itself.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if ismock(subject) and subject.__sphinx_decorator_args__:</span>
<span class="gi">+        return subject.__sphinx_decorator_args__[0]</span>
<span class="gi">+    return subject</span>
<span class="gh">diff --git a/sphinx/ext/autodoc/preserve_defaults.py b/sphinx/ext/autodoc/preserve_defaults.py</span>
<span class="gh">index fc27cde55..01feacea3 100644</span>
<span class="gd">--- a/sphinx/ext/autodoc/preserve_defaults.py</span>
<span class="gi">+++ b/sphinx/ext/autodoc/preserve_defaults.py</span>
<span class="gu">@@ -37,7 +37,12 @@ def get_function_def(obj: Any) -&gt;(ast.FunctionDef | None):</span>
<span class="w"> </span>    This tries to parse original code for living object and returns
<span class="w"> </span>    AST node for given *obj*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        source = inspect.getsource(obj)</span>
<span class="gi">+        module = ast.parse(source)</span>
<span class="gi">+        return next((node for node in ast.walk(module) if isinstance(node, ast.FunctionDef)), None)</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return None</span>


<span class="w"> </span>def _get_arguments(obj: Any, /) -&gt;(ast.arguments | None):
<span class="gu">@@ -46,9 +51,33 @@ def _get_arguments(obj: Any, /) -&gt;(ast.arguments | None):</span>
<span class="w"> </span>    This tries to parse the original code for an object and returns
<span class="w"> </span>    an &#39;ast.arguments&#39; node.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    func_def = get_function_def(obj)</span>
<span class="gi">+    return func_def.args if func_def else None</span>


<span class="w"> </span>def update_defvalue(app: Sphinx, obj: Any, bound_method: bool) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Update defvalue info of *obj* using type_comments.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not callable(obj):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        args = _get_arguments(obj)</span>
<span class="gi">+        if args is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        signature = inspect.signature(obj)</span>
<span class="gi">+        parameters = list(signature.parameters.values())</span>
<span class="gi">+</span>
<span class="gi">+        if bound_method:</span>
<span class="gi">+            parameters = parameters[1:]  # Skip &#39;self&#39; parameter for bound methods</span>
<span class="gi">+</span>
<span class="gi">+        for param, arg in zip(parameters, args.args + args.kwonlyargs):</span>
<span class="gi">+            if param.default is not param.empty:</span>
<span class="gi">+                if isinstance(arg, ast.arg) and arg.annotation:</span>
<span class="gi">+                    default_value = DefaultValue(ast_unparse(arg.annotation))</span>
<span class="gi">+                    param._default = default_value</span>
<span class="gi">+</span>
<span class="gi">+        # Update the signature of the object</span>
<span class="gi">+        obj.__signature__ = signature.replace(parameters=parameters)</span>
<span class="gi">+    except Exception as exc:</span>
<span class="gi">+        logger.warning(__(&#39;Failed to update defvalue of %r: %s&#39;), obj, exc)</span>
<span class="gh">diff --git a/sphinx/ext/autodoc/type_comment.py b/sphinx/ext/autodoc/type_comment.py</span>
<span class="gh">index 545663871..132a5b577 100644</span>
<span class="gd">--- a/sphinx/ext/autodoc/type_comment.py</span>
<span class="gi">+++ b/sphinx/ext/autodoc/type_comment.py</span>
<span class="gu">@@ -16,7 +16,7 @@ logger = logging.getLogger(__name__)</span>

<span class="w"> </span>def not_suppressed(argtypes: Sequence[ast.expr]=()) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check given *argtypes* is suppressed type_comment or not.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return len(argtypes) != 1 or not isinstance(argtypes[0], ast.Ellipsis)</span>


<span class="w"> </span>def signature_from_ast(node: ast.FunctionDef, bound_method: bool,
<span class="gu">@@ -25,7 +25,43 @@ def signature_from_ast(node: ast.FunctionDef, bound_method: bool,</span>

<span class="w"> </span>    :param bound_method: Specify *node* is a bound method or not
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    args = []</span>
<span class="gi">+    defaults = []</span>
<span class="gi">+    kwonlyargs = []</span>
<span class="gi">+    kwonlydefaults = []</span>
<span class="gi">+    vararg = None</span>
<span class="gi">+    kwarg = None</span>
<span class="gi">+</span>
<span class="gi">+    def get_param(arg: ast.arg, default: Any = Parameter.empty) -&gt; Parameter:</span>
<span class="gi">+        annotation = ast.unparse(arg.annotation) if arg.annotation else Parameter.empty</span>
<span class="gi">+        return Parameter(arg.arg, Parameter.POSITIONAL_OR_KEYWORD, default=default, annotation=annotation)</span>
<span class="gi">+</span>
<span class="gi">+    for i, arg in enumerate(node.args.args):</span>
<span class="gi">+        if i == 0 and bound_method:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if i &gt;= len(node.args.args) - len(node.args.defaults):</span>
<span class="gi">+            default = ast_unparse(node.args.defaults[i - (len(node.args.args) - len(node.args.defaults))])</span>
<span class="gi">+            args.append(get_param(arg, default))</span>
<span class="gi">+        else:</span>
<span class="gi">+            args.append(get_param(arg))</span>
<span class="gi">+</span>
<span class="gi">+    if node.args.vararg:</span>
<span class="gi">+        vararg = Parameter(node.args.vararg.arg, Parameter.VAR_POSITIONAL)</span>
<span class="gi">+</span>
<span class="gi">+    for i, arg in enumerate(node.args.kwonlyargs):</span>
<span class="gi">+        if i &lt; len(node.args.kw_defaults) and node.args.kw_defaults[i] is not None:</span>
<span class="gi">+            default = ast_unparse(node.args.kw_defaults[i])</span>
<span class="gi">+            kwonlyargs.append(get_param(arg, default))</span>
<span class="gi">+        else:</span>
<span class="gi">+            kwonlyargs.append(get_param(arg))</span>
<span class="gi">+</span>
<span class="gi">+    if node.args.kwarg:</span>
<span class="gi">+        kwarg = Parameter(node.args.kwarg.arg, Parameter.VAR_KEYWORD)</span>
<span class="gi">+</span>
<span class="gi">+    return_annotation = ast.unparse(node.returns) if node.returns else Signature.empty</span>
<span class="gi">+</span>
<span class="gi">+    return Signature(args + kwonlyargs, return_annotation=return_annotation,</span>
<span class="gi">+                     vararg=vararg, kwarg=kwarg)</span>


<span class="w"> </span>def get_type_comment(obj: Any, bound_method: bool=False) -&gt;(Signature | None):
<span class="gu">@@ -34,7 +70,17 @@ def get_type_comment(obj: Any, bound_method: bool=False) -&gt;(Signature | None):</span>
<span class="w"> </span>    This tries to parse original code for living object and returns
<span class="w"> </span>    Signature for given *obj*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        source = getsource(obj)</span>
<span class="gi">+        tree = ast.parse(source)</span>
<span class="gi">+        for node in ast.walk(tree):</span>
<span class="gi">+            if isinstance(node, ast.FunctionDef) and node.name == obj.__name__:</span>
<span class="gi">+                if node.type_comment:</span>
<span class="gi">+                    type_comment = ast.parse(f&quot;def f{node.type_comment}: pass&quot;).body[0]</span>
<span class="gi">+                    return signature_from_ast(type_comment, bound_method, type_comment)</span>
<span class="gi">+    except Exception as exc:</span>
<span class="gi">+        logger.debug(__(&#39;Failed to parse type_comment for %r: %s&#39;), obj, exc)</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def update_annotations_using_type_comments(app: Sphinx, obj: Any,
<span class="gh">diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py</span>
<span class="gh">index 97ed01df9..021372d42 100644</span>
<span class="gd">--- a/sphinx/ext/autodoc/typehints.py</span>
<span class="gi">+++ b/sphinx/ext/autodoc/typehints.py</span>
<span class="gu">@@ -17,4 +17,25 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,
<span class="w"> </span>    options: Options, args: str, retann: str) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Record type hints to env object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if app.config.autodoc_typehints != &#39;none&#39;:</span>
<span class="gi">+        # Get the environment</span>
<span class="gi">+        env = app.env</span>
<span class="gi">+        if not hasattr(env, &#39;autodoc_typehints&#39;):</span>
<span class="gi">+            env.autodoc_typehints = {}</span>
<span class="gi">+</span>
<span class="gi">+        # Record the type hints</span>
<span class="gi">+        full_name = f&quot;{objtype}.{name}&quot;</span>
<span class="gi">+        env.autodoc_typehints[full_name] = {</span>
<span class="gi">+            &#39;args&#39;: args,</span>
<span class="gi">+            &#39;return&#39;: retann</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        # If it&#39;s a method, also record the class name</span>
<span class="gi">+        if objtype == &#39;method&#39;:</span>
<span class="gi">+            class_name = name.rsplit(&#39;.&#39;, 1)[0]</span>
<span class="gi">+            if class_name not in env.autodoc_typehints:</span>
<span class="gi">+                env.autodoc_typehints[class_name] = {}</span>
<span class="gi">+            env.autodoc_typehints[class_name][name.rsplit(&#39;.&#39;, 1)[1]] = {</span>
<span class="gi">+                &#39;args&#39;: args,</span>
<span class="gi">+                &#39;return&#39;: retann</span>
<span class="gi">+            }</span>
<span class="gh">diff --git a/sphinx/ext/autosummary/generate.py b/sphinx/ext/autosummary/generate.py</span>
<span class="gh">index eb7b16602..dbabb15a2 100644</span>
<span class="gd">--- a/sphinx/ext/autosummary/generate.py</span>
<span class="gi">+++ b/sphinx/ext/autosummary/generate.py</span>
<span class="gu">@@ -93,7 +93,12 @@ class AutosummaryRenderer:</span>

<span class="w"> </span>    def render(self, template_name: str, context: dict[str, Any]) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Render a template file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            template = self.env.get_template(template_name)</span>
<span class="gi">+            return template.render(context)</span>
<span class="gi">+        except TemplateNotFound:</span>
<span class="gi">+            logger.warning(__(&#39;template not found: %s&#39;), template_name)</span>
<span class="gi">+            return &#39;&#39;</span>


<span class="w"> </span>def _split_full_qualified_name(name: str) -&gt;tuple[str | None, str]:
<span class="gu">@@ -110,7 +115,15 @@ def _split_full_qualified_name(name: str) -&gt;tuple[str | None, str]:</span>
<span class="w"> </span>              Therefore you need to mock 3rd party modules if needed before
<span class="w"> </span>              calling this function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = name.rsplit(&#39;.&#39;, 1)</span>
<span class="gi">+    if len(parts) == 2:</span>
<span class="gi">+        modname, qualname = parts</span>
<span class="gi">+        try:</span>
<span class="gi">+            import_module(modname)</span>
<span class="gi">+            return modname, qualname</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            pass</span>
<span class="gi">+    return None, name</span>


<span class="w"> </span>class ModuleScanner:
<span class="gu">@@ -125,12 +138,28 @@ def members_of(obj: Any, conf: Config) -&gt;Sequence[str]:</span>

<span class="w"> </span>    Follows the ``conf.autosummary_ignore_module_all`` setting.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if conf.autosummary_ignore_module_all:</span>
<span class="gi">+        return getall(obj)</span>
<span class="gi">+    elif hasattr(obj, &#39;__all__&#39;):</span>
<span class="gi">+        return obj.__all__</span>
<span class="gi">+    else:</span>
<span class="gi">+        return getall(obj)</span>


<span class="w"> </span>def _get_module_attrs(name: str, members: Any) -&gt;tuple[list[str], list[str]]:
<span class="w"> </span>    &quot;&quot;&quot;Find module attributes with docstrings.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    attrs, public = [], []</span>
<span class="gi">+    try:</span>
<span class="gi">+        analyzer = ModuleAnalyzer.for_module(name)</span>
<span class="gi">+        attr_docs = analyzer.find_attr_docs()</span>
<span class="gi">+        for namespace, attr_name in attr_docs:</span>
<span class="gi">+            if namespace == &#39;&#39; and attr_name in members:</span>
<span class="gi">+                attrs.append(attr_name)</span>
<span class="gi">+                if not attr_name.startswith(&#39;_&#39;):</span>
<span class="gi">+                    public.append(attr_name)</span>
<span class="gi">+    except PycodeError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    return attrs, public</span>


<span class="w"> </span>def generate_autosummary_docs(sources: list[str], output_dir: (str | os.
<span class="gu">@@ -141,7 +170,78 @@ def generate_autosummary_docs(sources: list[str], output_dir: (str | os.</span>

<span class="w"> </span>    :returns: list of generated files (both new and existing ones)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if app:</span>
<span class="gi">+        translator = app.translator</span>
<span class="gi">+    else:</span>
<span class="gi">+        translator = sphinx.locale.init([sphinx.locale.__dir__], &#39;sphinx&#39;)</span>
<span class="gi">+        app = DummyApplication(translator)</span>
<span class="gi">+</span>
<span class="gi">+    showed_sources = list(sorted(sources))</span>
<span class="gi">+    if len(showed_sources) &gt; 20:</span>
<span class="gi">+        showed_sources = showed_sources[:10] + [&#39;...&#39;] + showed_sources[-10:]</span>
<span class="gi">+    logger.info(__(&#39;[autosummary] generating autosummary for: %s&#39;) %</span>
<span class="gi">+                &#39;, &#39;.join(showed_sources))</span>
<span class="gi">+</span>
<span class="gi">+    if output_dir:</span>
<span class="gi">+        output_dir = Path(output_dir).resolve()</span>
<span class="gi">+        ensuredir(output_dir)</span>
<span class="gi">+</span>
<span class="gi">+    if base_path is not None:</span>
<span class="gi">+        base_path = Path(base_path).resolve()</span>
<span class="gi">+</span>
<span class="gi">+    generated_files = []</span>
<span class="gi">+</span>
<span class="gi">+    for source in sources:</span>
<span class="gi">+        package_dir = None</span>
<span class="gi">+        if base_path:</span>
<span class="gi">+            source_file = os.path.join(base_path, source)</span>
<span class="gi">+            # Find the package directory, using the source filename</span>
<span class="gi">+            package_dir = Path(source_file).resolve().parent</span>
<span class="gi">+</span>
<span class="gi">+        logger.info(__(&#39;[autosummary] reading files...&#39;))</span>
<span class="gi">+        documented = find_autosummary_in_files(sources)</span>
<span class="gi">+</span>
<span class="gi">+        logger.info(__(&#39;[autosummary] generating...&#39;))</span>
<span class="gi">+        for entry in documented:</span>
<span class="gi">+            try:</span>
<span class="gi">+                obj, name = import_by_name(entry.name, package_dir=package_dir)</span>
<span class="gi">+            except ImportExceptionGroup as exc:</span>
<span class="gi">+                logger.warning(__(&#39;[autosummary] failed to import %r: %s&#39;) % (entry.name, exc))</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            fn = os.path.join(output_dir, name + suffix)</span>
<span class="gi">+            if os.path.isfile(fn):</span>
<span class="gi">+                with open(fn, encoding=encoding) as f:</span>
<span class="gi">+                    generated = f.read()</span>
<span class="gi">+                if generated.strip() == entry.name.strip():</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+            logger.info(__(&#39;[autosummary] generating %s&#39;) % fn)</span>
<span class="gi">+            with open(fn, &#39;w&#39;, encoding=encoding) as f:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    import_members = imported_members or entry.recursive</span>
<span class="gi">+                    renderer = AutosummaryRenderer(app)</span>
<span class="gi">+                    context = app.config.autosummary_context.copy()</span>
<span class="gi">+                    context.update({</span>
<span class="gi">+                        &#39;name&#39;: name,</span>
<span class="gi">+                        &#39;obj&#39;: obj,</span>
<span class="gi">+                        &#39;members&#39;: members_of(obj, app.config),</span>
<span class="gi">+                        &#39;imported_members&#39;: import_members,</span>
<span class="gi">+                        &#39;autosummary&#39;: True,</span>
<span class="gi">+                        &#39;module&#39;: sys.modules.get(obj.__module__),</span>
<span class="gi">+                        &#39;app&#39;: app,</span>
<span class="gi">+                        &#39;doc&#39;: pydoc.getdoc(obj),</span>
<span class="gi">+                        &#39;fullname&#39;: name,</span>
<span class="gi">+                    })</span>
<span class="gi">+                    rendered = renderer.render(entry.template, context)</span>
<span class="gi">+                    f.write(rendered)</span>
<span class="gi">+                except Exception as e:</span>
<span class="gi">+                    logger.warning(__(&#39;[autosummary] failed to generate %s&#39;) % fn)</span>
<span class="gi">+                    logger.warning(str(e))</span>
<span class="gi">+</span>
<span class="gi">+            generated_files.append(Path(fn).resolve())</span>
<span class="gi">+</span>
<span class="gi">+    return generated_files</span>


<span class="w"> </span>def find_autosummary_in_files(filenames: list[str]) -&gt;list[AutosummaryEntry]:
<span class="gu">@@ -149,7 +249,12 @@ def find_autosummary_in_files(filenames: list[str]) -&gt;list[AutosummaryEntry]:</span>

<span class="w"> </span>    See `find_autosummary_in_lines`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    documented = []</span>
<span class="gi">+    for filename in filenames:</span>
<span class="gi">+        with open(filename, encoding=&#39;utf-8&#39;, errors=&#39;ignore&#39;) as f:</span>
<span class="gi">+            lines = f.read().splitlines()</span>
<span class="gi">+            documented.extend(find_autosummary_in_lines(lines, filename=filename))</span>
<span class="gi">+    return documented</span>


<span class="w"> </span>def find_autosummary_in_docstring(name: str, filename: (str | None)=None
<span class="gu">@@ -158,7 +263,18 @@ def find_autosummary_in_docstring(name: str, filename: (str | None)=None</span>

<span class="w"> </span>    See `find_autosummary_in_lines`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        real_name, obj, parent, modname = import_by_name(name)</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        logger.warning(__(&#39;[autosummary] failed to import %r&#39;) % name)</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    doc = pydoc.getdoc(obj)</span>
<span class="gi">+    if not doc:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    lines = doc.splitlines()</span>
<span class="gi">+    return find_autosummary_in_lines(lines, module=name, filename=filename)</span>


<span class="w"> </span>def find_autosummary_in_lines(lines: list[str], module: (str | None)=None,
<span class="gu">@@ -173,7 +289,86 @@ def find_autosummary_in_lines(lines: list[str], module: (str | None)=None,</span>
<span class="w"> </span>    *template* ``None`` if the directive does not have the
<span class="w"> </span>    corresponding options set.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    autosummary_re = re.compile(r&#39;^(\s*)\.\.\s+autosummary::\s*&#39;)</span>
<span class="gi">+    automodule_re = re.compile(</span>
<span class="gi">+        r&#39;^\s*\.\.\s+automodule::\s*([A-Za-z0-9_.]+)\s*$&#39;)</span>
<span class="gi">+    module_re = re.compile(</span>
<span class="gi">+        r&#39;^\s*\.\.\s+(current)?module::\s*([a-zA-Z0-9_.]+)\s*$&#39;)</span>
<span class="gi">+    autosummary_item_re = re.compile(r&#39;^\s+(~?[_a-zA-Z][a-zA-Z0-9_.]*)\s*.*?&#39;)</span>
<span class="gi">+    toctree_arg_re = re.compile(r&#39;^\s+:toctree:\s*(.*?)\s*$&#39;)</span>
<span class="gi">+    template_arg_re = re.compile(r&#39;^\s+:template:\s*(.*?)\s*$&#39;)</span>
<span class="gi">+    recursive_arg_re = re.compile(r&#39;^\s+:recursive:\s*$&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    documented = []</span>
<span class="gi">+</span>
<span class="gi">+    toctree = None</span>
<span class="gi">+    template = None</span>
<span class="gi">+    recursive = False</span>
<span class="gi">+    current_module = module</span>
<span class="gi">+    in_autosummary = False</span>
<span class="gi">+    base_indent = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    for line in lines:</span>
<span class="gi">+        if in_autosummary:</span>
<span class="gi">+            m = toctree_arg_re.match(line)</span>
<span class="gi">+            if m:</span>
<span class="gi">+                toctree = m.group(1)</span>
<span class="gi">+                if filename:</span>
<span class="gi">+                    toctree = os.path.join(os.path.dirname(filename),</span>
<span class="gi">+                                           toctree)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            m = template_arg_re.match(line)</span>
<span class="gi">+            if m:</span>
<span class="gi">+                template = m.group(1).strip()</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            m = recursive_arg_re.match(line)</span>
<span class="gi">+            if m:</span>
<span class="gi">+                recursive = True</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if line.strip().startswith(&#39;:&#39;):</span>
<span class="gi">+                continue  # skip options</span>
<span class="gi">+</span>
<span class="gi">+            m = autosummary_item_re.match(line)</span>
<span class="gi">+            if m:</span>
<span class="gi">+                name = m.group(1).strip()</span>
<span class="gi">+                if name.startswith(&#39;~&#39;):</span>
<span class="gi">+                    name = name[1:]</span>
<span class="gi">+                if current_module and not name.startswith(current_module + &#39;.&#39;):</span>
<span class="gi">+                    name = f&quot;{current_module}.{name}&quot;</span>
<span class="gi">+                documented.append(AutosummaryEntry(name, toctree, template, recursive))</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if not line.strip() or line.startswith(base_indent + &quot; &quot;):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            in_autosummary = False</span>
<span class="gi">+</span>
<span class="gi">+        m = autosummary_re.match(line)</span>
<span class="gi">+        if m:</span>
<span class="gi">+            in_autosummary = True</span>
<span class="gi">+            base_indent = m.group(1)</span>
<span class="gi">+            toctree = None</span>
<span class="gi">+            template = None</span>
<span class="gi">+            recursive = False</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        m = automodule_re.match(line)</span>
<span class="gi">+        if m:</span>
<span class="gi">+            current_module = m.group(1).strip()</span>
<span class="gi">+            # recurse into the automodule docstring</span>
<span class="gi">+            documented.extend(find_autosummary_in_docstring(</span>
<span class="gi">+                current_module, filename=filename))</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        m = module_re.match(line)</span>
<span class="gi">+        if m:</span>
<span class="gi">+            current_module = m.group(2)</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+    return documented</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/sphinx/ext/coverage.py b/sphinx/ext/coverage.py</span>
<span class="gh">index 9e50f8dea..eee1cd669 100644</span>
<span class="gd">--- a/sphinx/ext/coverage.py</span>
<span class="gi">+++ b/sphinx/ext/coverage.py</span>
<span class="gu">@@ -37,7 +37,23 @@ def _load_modules(mod_name: str, ignored_module_exps: Iterable[re.Pattern[str]]</span>
<span class="w"> </span>    :raises ImportError: If the module indicated by ``mod_name`` could not be
<span class="w"> </span>        loaded.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    modules = {mod_name}</span>
<span class="gi">+    try:</span>
<span class="gi">+        mod = import_module(mod_name)</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        raise</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(mod, &#39;__path__&#39;):</span>
<span class="gi">+        for _, name, ispkg in pkgutil.iter_modules(mod.__path__):</span>
<span class="gi">+            fullname = f&quot;{mod_name}.{name}&quot;</span>
<span class="gi">+            if any(exp.match(fullname) for exp in ignored_module_exps):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if ispkg:</span>
<span class="gi">+                modules.update(_load_modules(fullname, ignored_module_exps))</span>
<span class="gi">+            else:</span>
<span class="gi">+                modules.add(fullname)</span>
<span class="gi">+</span>
<span class="gi">+    return modules</span>


<span class="w"> </span>def _determine_py_coverage_modules(coverage_modules: Sequence[str],
<span class="gu">@@ -58,7 +74,19 @@ def _determine_py_coverage_modules(coverage_modules: Sequence[str],</span>
<span class="w"> </span>      modules that are documented will be noted. This will therefore identify both
<span class="w"> </span>      missing modules and missing objects, but it requires manual configuration.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if coverage_modules:</span>
<span class="gi">+        modules_to_check = set()</span>
<span class="gi">+        for mod_name in coverage_modules:</span>
<span class="gi">+            modules_to_check.update(_load_modules(mod_name, ignored_module_exps))</span>
<span class="gi">+        </span>
<span class="gi">+        # Add documented modules that are not in coverage_modules</span>
<span class="gi">+        for mod_name in seen_modules:</span>
<span class="gi">+            if mod_name not in modules_to_check:</span>
<span class="gi">+                py_undoc[mod_name] = {}</span>
<span class="gi">+    else:</span>
<span class="gi">+        modules_to_check = seen_modules</span>
<span class="gi">+</span>
<span class="gi">+    return sorted(modules_to_check)</span>


<span class="w"> </span>class CoverageBuilder(Builder):
<span class="gu">@@ -72,4 +100,26 @@ class CoverageBuilder(Builder):</span>

<span class="w"> </span>    def _write_py_statistics(self, op: TextIO) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Outputs the table of ``op``.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        total_objs = 0</span>
<span class="gi">+        total_undoc = 0</span>
<span class="gi">+        op.write(&#39;Undocumented Python objects\n&#39;)</span>
<span class="gi">+        op.write(&#39;===========================\n\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        for mod_name in sorted(self.py_undoc):</span>
<span class="gi">+            undoc = self.py_undoc[mod_name]</span>
<span class="gi">+            if not undoc:</span>
<span class="gi">+                continue</span>
<span class="gi">+            op.write(mod_name + &#39;\n&#39;)</span>
<span class="gi">+            op.write(&#39;-&#39; * len(mod_name) + &#39;\n&#39;)</span>
<span class="gi">+            for name, typ in sorted(undoc.items()):</span>
<span class="gi">+                op.write(f&#39;* {name} ({typ})\n&#39;)</span>
<span class="gi">+                total_undoc += 1</span>
<span class="gi">+            op.write(&#39;\n&#39;)</span>
<span class="gi">+            total_objs += len(undoc)</span>
<span class="gi">+</span>
<span class="gi">+        op.write(&#39;\n&#39;)</span>
<span class="gi">+        op.write(&#39;Documented Python objects\n&#39;)</span>
<span class="gi">+        op.write(&#39;=========================\n&#39;)</span>
<span class="gi">+        op.write(f&#39;Total found: {self.total_py}\n&#39;)</span>
<span class="gi">+        op.write(f&#39;Undocumented: {total_undoc}\n&#39;)</span>
<span class="gi">+        op.write(f&#39;Coverage: {100 * (self.total_py - total_undoc) / self.total_py:.0f}%\n&#39;)</span>
<span class="gh">diff --git a/sphinx/ext/doctest.py b/sphinx/ext/doctest.py</span>
<span class="gh">index 46e4ad53d..0ae25abef 100644</span>
<span class="gd">--- a/sphinx/ext/doctest.py</span>
<span class="gi">+++ b/sphinx/ext/doctest.py</span>
<span class="gu">@@ -46,7 +46,10 @@ def is_allowed_version(spec: str, version: str) -&gt;bool:</span>
<span class="w"> </span>        &gt;&gt;&gt; is_allowed_version(&#39;&gt;3.2, &lt;4.0&#39;, &#39;3.3&#39;)
<span class="w"> </span>        True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return Version(version) in SpecifierSet(spec)</span>
<span class="gi">+    except InvalidSpecifier:</span>
<span class="gi">+        return False</span>


<span class="w"> </span>class TestDirective(SphinxDirective):
<span class="gu">@@ -144,9 +147,21 @@ class DocTestBuilder(Builder):</span>
<span class="w"> </span>        &quot;&quot;&quot;Try to get the file which actually contains the doctest, not the
<span class="w"> </span>        filename of the document it&#39;s included in.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            filename = node.get(&#39;source&#39;)</span>
<span class="gi">+            if filename is None:</span>
<span class="gi">+                return self.env.doc2path(docname)</span>
<span class="gi">+            return path.normpath(path.join(self.env.srcdir, filename))</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return self.env.doc2path(docname)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def get_line_number(node: Node) -&gt;(int | None):
<span class="w"> </span>        &quot;&quot;&quot;Get the real line number or admit we don&#39;t know.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lineno = node.line</span>
<span class="gi">+        if lineno is None:</span>
<span class="gi">+            # Some nodes don&#39;t have a line number, use the parent&#39;s line number</span>
<span class="gi">+            while lineno is None and node.parent:</span>
<span class="gi">+                node = node.parent</span>
<span class="gi">+                lineno = node.line</span>
<span class="gi">+        return lineno</span>
<span class="gh">diff --git a/sphinx/ext/duration.py b/sphinx/ext/duration.py</span>
<span class="gh">index 9080b706a..8b9ec36e6 100644</span>
<span class="gd">--- a/sphinx/ext/duration.py</span>
<span class="gi">+++ b/sphinx/ext/duration.py</span>
<span class="gu">@@ -29,19 +29,51 @@ def on_builder_inited(app: Sphinx) -&gt;None:</span>

<span class="w"> </span>    This clears the results of the last build.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app.env.domains[&#39;duration&#39;] = DurationDomain(app.env)</span>
<span class="gi">+    app.env.domains[&#39;duration&#39;].data[&#39;reading_durations&#39;] = {}</span>


<span class="w"> </span>def on_source_read(app: Sphinx, docname: str, content: list[str]) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Start to measure reading duration.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app.env.temp_data[&#39;reading_start_time&#39;] = time.time()</span>


<span class="w"> </span>def on_doctree_read(app: Sphinx, doctree: nodes.document) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Record a reading duration.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    start_time = app.env.temp_data.get(&#39;reading_start_time&#39;)</span>
<span class="gi">+    if start_time is not None:</span>
<span class="gi">+        duration = time.time() - start_time</span>
<span class="gi">+        docname = app.env.docname</span>
<span class="gi">+        app.env.domains[&#39;duration&#39;].data[&#39;reading_durations&#39;][docname] = duration</span>


<span class="w"> </span>def on_build_finished(app: Sphinx, error: Exception) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Display duration ranking on the current build.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if error:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    durations = app.env.domains[&#39;duration&#39;].data[&#39;reading_durations&#39;]</span>
<span class="gi">+    if not durations:</span>
<span class="gi">+        logger.info(__(&#39;No reading duration data available.&#39;))</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    sorted_durations = sorted(durations.items(), key=itemgetter(1), reverse=True)</span>
<span class="gi">+    top_10 = list(islice(sorted_durations, 10))</span>
<span class="gi">+</span>
<span class="gi">+    logger.info(__(&#39;Top 10 slowest read documents:&#39;))</span>
<span class="gi">+    for docname, duration in top_10:</span>
<span class="gi">+        logger.info(f&#39;{docname}: {duration:.2f} seconds&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; dict[str, bool]:</span>
<span class="gi">+    app.add_domain(DurationDomain)</span>
<span class="gi">+    app.connect(&#39;builder-inited&#39;, on_builder_inited)</span>
<span class="gi">+    app.connect(&#39;source-read&#39;, on_source_read)</span>
<span class="gi">+    app.connect(&#39;doctree-read&#39;, on_doctree_read)</span>
<span class="gi">+    app.connect(&#39;build-finished&#39;, on_build_finished)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: sphinx.__display_version__,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/ext/extlinks.py b/sphinx/ext/extlinks.py</span>
<span class="gh">index beb4a5e4b..8210f26af 100644</span>
<span class="gd">--- a/sphinx/ext/extlinks.py</span>
<span class="gi">+++ b/sphinx/ext/extlinks.py</span>
<span class="gu">@@ -47,4 +47,22 @@ class ExternalLinksChecker(SphinxPostTransform):</span>
<span class="w"> </span>        If the URI in ``refnode`` has a replacement in ``extlinks``,
<span class="w"> </span>        emit a warning with a replacement suggestion.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        uri = refnode.get(&#39;refuri&#39;, &#39;&#39;)</span>
<span class="gi">+        if not uri:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for name, (base_url, caption) in self.app.config.extlinks.items():</span>
<span class="gi">+            if uri.startswith(base_url):</span>
<span class="gi">+                # Extract the part of the URI that matches the extlink pattern</span>
<span class="gi">+                suffix = uri[len(base_url):]</span>
<span class="gi">+                if suffix.endswith(&#39;.html&#39;):</span>
<span class="gi">+                    suffix = suffix[:-5]  # Remove &#39;.html&#39; if present</span>
<span class="gi">+</span>
<span class="gi">+                # Construct the suggested replacement</span>
<span class="gi">+                if caption is None:</span>
<span class="gi">+                    suggested_text = f&#39;:{name}:`{suffix}`&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    suggested_text = f&#39;:{name}:`{caption % suffix}`&#39;</span>
<span class="gi">+</span>
<span class="gi">+                logger.warning(__(&#39;Extlink %r could be replaced by %s&#39;), uri, suggested_text,</span>
<span class="gi">+                               location=refnode)</span>
<span class="gh">diff --git a/sphinx/ext/githubpages.py b/sphinx/ext/githubpages.py</span>
<span class="gh">index 67d37a5bc..079983b91 100644</span>
<span class="gd">--- a/sphinx/ext/githubpages.py</span>
<span class="gi">+++ b/sphinx/ext/githubpages.py</span>
<span class="gu">@@ -13,7 +13,8 @@ if TYPE_CHECKING:</span>

<span class="w"> </span>def _get_domain_from_url(url: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Get the domain from a URL.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parsed_url = urllib.parse.urlparse(url)</span>
<span class="gi">+    return parsed_url.netloc</span>


<span class="w"> </span>def create_nojekyll_and_cname(app: Sphinx, env: BuildEnvironment) -&gt;None:
<span class="gu">@@ -31,4 +32,26 @@ def create_nojekyll_and_cname(app: Sphinx, env: BuildEnvironment) -&gt;None:</span>
<span class="w"> </span>    requires a CNAME file, we remove any existing ``CNAME`` files from the
<span class="w"> </span>    output directory.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if app.builder.format == &#39;html&#39;:</span>
<span class="gi">+        # Create .nojekyll file</span>
<span class="gi">+        nojekyll_path = os.path.join(app.outdir, &#39;.nojekyll&#39;)</span>
<span class="gi">+        with contextlib.suppress(OSError):</span>
<span class="gi">+            open(nojekyll_path, &#39;wt&#39;).close()</span>
<span class="gi">+</span>
<span class="gi">+        # Handle CNAME file</span>
<span class="gi">+        cname_path = os.path.join(app.outdir, &#39;CNAME&#39;)</span>
<span class="gi">+        html_baseurl = app.config.html_baseurl</span>
<span class="gi">+</span>
<span class="gi">+        if html_baseurl:</span>
<span class="gi">+            domain = _get_domain_from_url(html_baseurl)</span>
<span class="gi">+            if domain and not domain.endswith(&#39;github.io&#39;):</span>
<span class="gi">+                with open(cname_path, &#39;wt&#39;) as f:</span>
<span class="gi">+                    f.write(domain)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Remove CNAME if it exists and is not needed</span>
<span class="gi">+                with contextlib.suppress(FileNotFoundError):</span>
<span class="gi">+                    os.remove(cname_path)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Remove CNAME if html_baseurl is not set</span>
<span class="gi">+            with contextlib.suppress(FileNotFoundError):</span>
<span class="gi">+                os.remove(cname_path)</span>
<span class="gh">diff --git a/sphinx/ext/graphviz.py b/sphinx/ext/graphviz.py</span>
<span class="gh">index 5333534bf..7c79429b3 100644</span>
<span class="gd">--- a/sphinx/ext/graphviz.py</span>
<span class="gi">+++ b/sphinx/ext/graphviz.py</span>
<span class="gu">@@ -55,7 +55,14 @@ class ClickableMapDefinition:</span>

<span class="w"> </span>        If not exists, this only returns empty string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.clickable:</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+        </span>
<span class="gi">+        map_tag = f&#39;&lt;map id=&quot;{self.id}&quot;&gt;\n&#39;</span>
<span class="gi">+        for item in self.clickable:</span>
<span class="gi">+            map_tag += item + &#39;\n&#39;</span>
<span class="gi">+        map_tag += &#39;&lt;/map&gt;&#39;</span>
<span class="gi">+        return map_tag</span>


<span class="w"> </span>class graphviz(nodes.General, nodes.Inline, nodes.Element):
<span class="gu">@@ -93,11 +100,72 @@ class GraphvizSimple(SphinxDirective):</span>
<span class="w"> </span>def fix_svg_relative_paths(self: (HTML5Translator | LaTeXTranslator |
<span class="w"> </span>    TexinfoTranslator), filepath: str) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Change relative links in generated svg files to be relative to imgpath.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tree = ET.parse(filepath)</span>
<span class="gi">+    root = tree.getroot()</span>
<span class="gi">+    </span>
<span class="gi">+    imgpath = self.builder.imgpath</span>
<span class="gi">+    if imgpath:</span>
<span class="gi">+        for element in root.iter():</span>
<span class="gi">+            if &#39;href&#39; in element.attrib:</span>
<span class="gi">+                href = element.attrib[&#39;href&#39;]</span>
<span class="gi">+                if not urlsplit(href).scheme:</span>
<span class="gi">+                    new_href = posixpath.join(imgpath, href)</span>
<span class="gi">+                    element.attrib[&#39;href&#39;] = new_href</span>
<span class="gi">+    </span>
<span class="gi">+    tree.write(filepath)</span>


<span class="w"> </span>def render_dot(self: (HTML5Translator | LaTeXTranslator | TexinfoTranslator
<span class="w"> </span>    ), code: str, options: dict, format: str, prefix: str=&#39;graphviz&#39;,
<span class="w"> </span>    filename: (str | None)=None) -&gt;tuple[str | None, str | None]:
<span class="w"> </span>    &quot;&quot;&quot;Render graphviz code into a PNG or PDF output file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if filename is None:</span>
<span class="gi">+        fname = f&quot;{sha1(code.encode()).hexdigest()}.{format}&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        fname = filename</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(self.builder, &#39;imgpath&#39;):</span>
<span class="gi">+        outfn = path.join(self.builder.outdir, self.builder.imgpath, fname)</span>
<span class="gi">+    else:</span>
<span class="gi">+        outfn = path.join(self.builder.outdir, fname)</span>
<span class="gi">+</span>
<span class="gi">+    if path.isfile(outfn):</span>
<span class="gi">+        return fname, outfn</span>
<span class="gi">+</span>
<span class="gi">+    ensuredir(path.dirname(outfn))</span>
<span class="gi">+</span>
<span class="gi">+    dot_args = [options.get(&#39;graphviz_dot&#39;, &#39;dot&#39;)]</span>
<span class="gi">+    dot_args.extend(options.get(&#39;graphviz_dot_args&#39;, []))</span>
<span class="gi">+    dot_args.extend([&#39;-T&#39; + format, &#39;-o&#39; + outfn])</span>
<span class="gi">+</span>
<span class="gi">+    if format == &#39;png&#39;:</span>
<span class="gi">+        dot_args.extend([&#39;-Tcmapx&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        p = subprocess.Popen(dot_args, stdout=subprocess.PIPE, stdin=subprocess.PIPE,</span>
<span class="gi">+                             stderr=subprocess.PIPE, universal_newlines=True)</span>
<span class="gi">+    except OSError as err:</span>
<span class="gi">+        if err.errno != 2:    # No such file or directory</span>
<span class="gi">+            raise</span>
<span class="gi">+        logger.warning(__(&#39;dot command %r cannot be run (needed for graphviz &#39;</span>
<span class="gi">+                          &#39;output), check the graphviz_dot setting&#39;), dot_args[0])</span>
<span class="gi">+        return None, None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Graphviz may close standard input when an error occurs,</span>
<span class="gi">+        # resulting in a broken pipe on communicate()</span>
<span class="gi">+        stdout, stderr = p.communicate(code)</span>
<span class="gi">+    except OSError as err:</span>
<span class="gi">+        if err.errno != 32:    # Broken pipe</span>
<span class="gi">+            raise</span>
<span class="gi">+        # in this case, read the standard output and standard error streams</span>
<span class="gi">+        # directly, to get the error message(s)</span>
<span class="gi">+        stdout, stderr = p.stdout.read(), p.stderr.read()</span>
<span class="gi">+        p.wait()</span>
<span class="gi">+    if p.returncode != 0:</span>
<span class="gi">+        raise GraphvizError(&#39;dot exited with error:\n[stderr]\n%s\n&#39;</span>
<span class="gi">+                            &#39;[stdout]\n%s&#39; % (stderr, stdout))</span>
<span class="gi">+    if not path.isfile(outfn):</span>
<span class="gi">+        raise GraphvizError(&#39;dot did not produce an output file:\n[stderr]\n%s\n&#39;</span>
<span class="gi">+                            &#39;[stdout]\n%s&#39; % (stderr, stdout))</span>
<span class="gi">+    return fname, outfn</span>
<span class="gh">diff --git a/sphinx/ext/ifconfig.py b/sphinx/ext/ifconfig.py</span>
<span class="gh">index 97b3f6272..d41661ba5 100644</span>
<span class="gd">--- a/sphinx/ext/ifconfig.py</span>
<span class="gi">+++ b/sphinx/ext/ifconfig.py</span>
<span class="gu">@@ -34,3 +34,18 @@ class IfConfig(SphinxDirective):</span>
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = True
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {}
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        node = ifconfig()</span>
<span class="gi">+        node.document = self.state.document</span>
<span class="gi">+        self.set_source_info(node)</span>
<span class="gi">+        node[&#39;expr&#39;] = self.arguments[0]</span>
<span class="gi">+        </span>
<span class="gi">+        env = self.state.document.settings.env</span>
<span class="gi">+        if self.content:</span>
<span class="gi">+            self.state.nested_parse(self.content, self.content_offset, node)</span>
<span class="gi">+            if isinstance(node[0], nodes.paragraph):</span>
<span class="gi">+                content = node[0].children</span>
<span class="gi">+                node[0].replace_self(content)</span>
<span class="gi">+        </span>
<span class="gi">+        return [node]</span>
<span class="gh">diff --git a/sphinx/ext/imgconverter.py b/sphinx/ext/imgconverter.py</span>
<span class="gh">index 9c69dd116..71a2d7829 100644</span>
<span class="gd">--- a/sphinx/ext/imgconverter.py</span>
<span class="gi">+++ b/sphinx/ext/imgconverter.py</span>
<span class="gu">@@ -22,8 +22,17 @@ class ImagemagickConverter(ImageConverter):</span>

<span class="w"> </span>    def is_available(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Confirms the converter is available or not.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            subprocess.run([&#39;convert&#39;, &#39;-version&#39;], check=True, capture_output=True)</span>
<span class="gi">+            return True</span>
<span class="gi">+        except (CalledProcessError, FileNotFoundError):</span>
<span class="gi">+            return False</span>

<span class="w"> </span>    def convert(self, _from: str, _to: str) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Converts the image to expected one.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            subprocess.run([&#39;convert&#39;, _from, _to], check=True, capture_output=True)</span>
<span class="gi">+            return True</span>
<span class="gi">+        except CalledProcessError:</span>
<span class="gi">+            logger.warning(__(&#39;imagemagick convert file &quot;%s&quot; to &quot;%s&quot; failed.&#39;), _from, _to)</span>
<span class="gi">+            return False</span>
<span class="gh">diff --git a/sphinx/ext/imgmath.py b/sphinx/ext/imgmath.py</span>
<span class="gh">index 666d084f5..b17229cad 100644</span>
<span class="gd">--- a/sphinx/ext/imgmath.py</span>
<span class="gi">+++ b/sphinx/ext/imgmath.py</span>
<span class="gu">@@ -58,19 +58,39 @@ depthsvgcomment_re = re.compile(&#39;&lt;!-- DEPTH=(-?\\d+) --&gt;&#39;)</span>
<span class="w"> </span>def read_svg_depth(filename: str) -&gt;(int | None):
<span class="w"> </span>    &quot;&quot;&quot;Read the depth from comment at last line of SVG file
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open(filename, &#39;r&#39;) as f:</span>
<span class="gi">+        for line in f:</span>
<span class="gi">+            pass  # Read until the last line</span>
<span class="gi">+        last_line = line.strip()</span>
<span class="gi">+    </span>
<span class="gi">+    match = depthsvgcomment_re.match(last_line)</span>
<span class="gi">+    if match:</span>
<span class="gi">+        return int(match.group(1))</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def write_svg_depth(filename: str, depth: int) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Write the depth to SVG file as a comment at end of file
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open(filename, &#39;a&#39;) as f:</span>
<span class="gi">+        f.write(f&#39;\n&lt;!-- DEPTH={depth} --&gt;\n&#39;)</span>


<span class="w"> </span>def generate_latex_macro(image_format: str, math: str, config: Config,
<span class="w"> </span>    confdir: (str | os.PathLike[str])=&#39;&#39;) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Generate LaTeX macro.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    latex = LaTeXRenderer(config.imgmath_latex_preamble, config.imgmath_latex_closing).render(</span>
<span class="gi">+        config.imgmath_latex_template,</span>
<span class="gi">+        image_format=image_format,</span>
<span class="gi">+        math=math,</span>
<span class="gi">+        preamble=config.imgmath_use_preview and &#39;\\usepackage[active,tightpage,displaymath]{preview}&#39; or &#39;&#39;,</span>
<span class="gi">+        fontsize=config.imgmath_font_size,</span>
<span class="gi">+        baselineskip=config.imgmath_latex_baselineskip,</span>
<span class="gi">+        fontset=config.imgmath_latex_fontset,</span>
<span class="gi">+        fontspec=config.imgmath_latex_fontspec,</span>
<span class="gi">+        commands=config.imgmath_latex_commands,</span>
<span class="gi">+    )</span>
<span class="gi">+    return latex</span>


<span class="w"> </span>def ensure_tempdir(builder: Builder) -&gt;str:
<span class="gu">@@ -80,29 +100,66 @@ def ensure_tempdir(builder: Builder) -&gt;str:</span>
<span class="w"> </span>    than using temporary files, since we can clean up everything at once
<span class="w"> </span>    just removing the whole directory (see cleanup_tempdir)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not hasattr(builder, &#39;_imgmath_tempdir&#39;):</span>
<span class="gi">+        builder._imgmath_tempdir = tempfile.mkdtemp()</span>
<span class="gi">+    return builder._imgmath_tempdir</span>


<span class="w"> </span>def compile_math(latex: str, builder: Builder) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Compile LaTeX macros for math to DVI.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tempdir = ensure_tempdir(builder)</span>
<span class="gi">+    filename = os.path.join(tempdir, &#39;math.tex&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+        f.write(latex)</span>
<span class="gi">+    </span>
<span class="gi">+    cwd = os.getcwd()</span>
<span class="gi">+    os.chdir(tempdir)</span>
<span class="gi">+    </span>
<span class="gi">+    try:</span>
<span class="gi">+        cmd = [builder.config.imgmath_latex, &#39;--interaction=nonstopmode&#39;, &#39;math.tex&#39;]</span>
<span class="gi">+        subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span>
<span class="gi">+    except CalledProcessError as exc:</span>
<span class="gi">+        raise MathExtError(&#39;latex exited with error&#39;, exc.stderr, exc.stdout)</span>
<span class="gi">+    finally:</span>
<span class="gi">+        os.chdir(cwd)</span>
<span class="gi">+    </span>
<span class="gi">+    return os.path.join(tempdir, &#39;math.dvi&#39;)</span>


<span class="w"> </span>def convert_dvi_to_image(command: list[str], name: str) -&gt;tuple[str, str]:
<span class="w"> </span>    &quot;&quot;&quot;Convert DVI file to specific image format.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        result = subprocess.run(command, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span>
<span class="gi">+        return (name, &#39;&#39;)</span>
<span class="gi">+    except CalledProcessError as exc:</span>
<span class="gi">+        raise MathExtError(&#39;dvipng/dvisvgm exited with error&#39;, exc.stderr, exc.stdout)</span>


<span class="w"> </span>def convert_dvi_to_png(dvipath: str, builder: Builder, out_path: str) -&gt;(int |
<span class="w"> </span>    None):
<span class="w"> </span>    &quot;&quot;&quot;Convert DVI file to PNG image.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cmd = [builder.config.imgmath_dvipng, &#39;-o&#39;, out_path, &#39;-T&#39;, &#39;tight&#39;, &#39;-z9&#39;]</span>
<span class="gi">+    cmd.extend(builder.config.imgmath_dvipng_args)</span>
<span class="gi">+    cmd.append(dvipath)</span>
<span class="gi">+    </span>
<span class="gi">+    convert_dvi_to_image(cmd, out_path)</span>
<span class="gi">+    </span>
<span class="gi">+    depth = read_png_depth(out_path)</span>
<span class="gi">+    return depth</span>


<span class="w"> </span>def convert_dvi_to_svg(dvipath: str, builder: Builder, out_path: str) -&gt;(int |
<span class="w"> </span>    None):
<span class="w"> </span>    &quot;&quot;&quot;Convert DVI file to SVG image.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cmd = [builder.config.imgmath_dvisvgm, &#39;-o&#39;, out_path]</span>
<span class="gi">+    cmd.extend(builder.config.imgmath_dvisvgm_args)</span>
<span class="gi">+    cmd.append(dvipath)</span>
<span class="gi">+    </span>
<span class="gi">+    convert_dvi_to_image(cmd, out_path)</span>
<span class="gi">+    </span>
<span class="gi">+    depth = read_svg_depth(out_path)</span>
<span class="gi">+    return depth</span>


<span class="w"> </span>def render_math(self: HTML5Translator, math: str) -&gt;tuple[str | None, int |
<span class="gu">@@ -120,4 +177,32 @@ def render_math(self: HTML5Translator, math: str) -&gt;tuple[str | None, int |</span>
<span class="w"> </span>    docs successfully).  If the programs are there, however, they may not fail
<span class="w"> </span>    since that indicates a problem in the math source.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    builder = self.builder</span>
<span class="gi">+    config = builder.config</span>
<span class="gi">+    </span>
<span class="gi">+    if config.imgmath_image_format not in SUPPORT_FORMAT:</span>
<span class="gi">+        raise MathExtError(f&#39;imgmath_image_format must be either &quot;png&quot; or &quot;svg&quot;, not &quot;{config.imgmath_image_format}&quot;&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    latex = generate_latex_macro(config.imgmath_image_format, math, config, builder.confdir)</span>
<span class="gi">+    </span>
<span class="gi">+    name = f&quot;math-{sha1(latex.encode()).hexdigest()}.{config.imgmath_image_format}&quot;</span>
<span class="gi">+    imgpath = path.join(builder.outdir, builder.imagedir, &#39;math&#39;, name)</span>
<span class="gi">+    if path.isfile(imgpath):</span>
<span class="gi">+        depth = read_png_depth(imgpath) if config.imgmath_image_format == &#39;png&#39; else read_svg_depth(imgpath)</span>
<span class="gi">+        return imgpath, depth</span>
<span class="gi">+    </span>
<span class="gi">+    ensuredir(path.dirname(imgpath))</span>
<span class="gi">+    </span>
<span class="gi">+    # Build latex command; old versions of latex don&#39;t have the</span>
<span class="gi">+    # --output-directory option, so we have to manually chdir to the</span>
<span class="gi">+    # temp dir to run it.</span>
<span class="gi">+    dvipath = compile_math(latex, builder)</span>
<span class="gi">+    </span>
<span class="gi">+    if config.imgmath_image_format == &#39;png&#39;:</span>
<span class="gi">+        depth = convert_dvi_to_png(dvipath, builder, imgpath)</span>
<span class="gi">+    elif config.imgmath_image_format == &#39;svg&#39;:</span>
<span class="gi">+        depth = convert_dvi_to_svg(dvipath, builder, imgpath)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise MathExtError(f&#39;imgmath_image_format must be either &quot;png&quot; or &quot;svg&quot;, not &quot;{config.imgmath_image_format}&quot;&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    return imgpath, depth</span>
<span class="gh">diff --git a/sphinx/ext/inheritance_diagram.py b/sphinx/ext/inheritance_diagram.py</span>
<span class="gh">index 2bd75f19c..fca683f55 100644</span>
<span class="gd">--- a/sphinx/ext/inheritance_diagram.py</span>
<span class="gi">+++ b/sphinx/ext/inheritance_diagram.py</span>
<span class="gu">@@ -65,12 +65,33 @@ def try_import(objname: str) -&gt;Any:</span>

<span class="w"> </span>    Returns imported object or module.  If failed, returns None value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return import_module(objname)</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        try:</span>
<span class="gi">+            module_name, class_name = objname.rsplit(&#39;.&#39;, 1)</span>
<span class="gi">+            module = import_module(module_name)</span>
<span class="gi">+            return getattr(module, class_name)</span>
<span class="gi">+        except (ImportError, AttributeError, ValueError):</span>
<span class="gi">+            return None</span>


<span class="w"> </span>def import_classes(name: str, currmodule: str) -&gt;Any:
<span class="w"> </span>    &quot;&quot;&quot;Import a class using its fully-qualified *name*.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if name.startswith(&#39;.&#39;):</span>
<span class="gi">+        name = currmodule + name</span>
<span class="gi">+    </span>
<span class="gi">+    obj = try_import(name)</span>
<span class="gi">+    if obj is None:</span>
<span class="gi">+        raise ImportError(f&#39;Could not import class or module {name}&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    if inspect.isclass(obj):</span>
<span class="gi">+        return [obj]</span>
<span class="gi">+    elif inspect.ismodule(obj):</span>
<span class="gi">+        return [cls for name, cls in inspect.getmembers(obj, inspect.isclass)</span>
<span class="gi">+                if cls.__module__ == obj.__name__]</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ImportError(f&#39;{name} is neither a class nor a module&#39;)</span>


<span class="w"> </span>class InheritanceException(Exception):
<span class="gu">@@ -101,10 +122,12 @@ class InheritanceGraph:</span>
<span class="w"> </span>            msg = &#39;No classes found for inheritance diagram&#39;
<span class="w"> </span>            raise InheritanceException(msg)

<span class="gd">-    def _import_classes(self, class_names: list[str], currmodule: str) -&gt;list[</span>
<span class="gd">-        Any]:</span>
<span class="gi">+    def _import_classes(self, class_names: list[str], currmodule: str) -&gt;list[Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Import a list of classes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        classes = []</span>
<span class="gi">+        for name in class_names:</span>
<span class="gi">+            classes.extend(import_classes(name, currmodule))</span>
<span class="gi">+        return classes</span>

<span class="w"> </span>    def _class_info(self, classes: list[Any], show_builtins: bool,
<span class="w"> </span>        private_bases: bool, parts: int, aliases: (dict[str, str] | None),
<span class="gu">@@ -124,7 +147,34 @@ class InheritanceGraph:</span>
<span class="w"> </span>        *top_classes* gives the name(s) of the top most ancestor class to
<span class="w"> </span>        traverse to. Multiple names can be specified separated by comma.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        all_classes = {}</span>
<span class="gi">+        top_classes = [cls for cls in top_classes if isinstance(cls, type)]</span>
<span class="gi">+</span>
<span class="gi">+        def recurse(cls):</span>
<span class="gi">+            if cls in all_classes:</span>
<span class="gi">+                return</span>
<span class="gi">+            if not show_builtins and cls in py_builtins:</span>
<span class="gi">+                return</span>
<span class="gi">+            if not private_bases and cls.__name__.startswith(&#39;_&#39;):</span>
<span class="gi">+                return</span>
<span class="gi">+            if top_classes and cls in top_classes:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            name = self.class_name(cls, parts, aliases)</span>
<span class="gi">+            if cls.__module__ == &#39;__builtin__&#39; or cls.__module__ == &#39;builtins&#39;:</span>
<span class="gi">+                module = &#39;builtins&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                module = cls.__module__</span>
<span class="gi">+            bases = [base for base in cls.__bases__ if show_builtins or base not in py_builtins]</span>
<span class="gi">+            all_classes[cls] = (name, module, bases, cls.__module__)</span>
<span class="gi">+</span>
<span class="gi">+            for base in bases:</span>
<span class="gi">+                recurse(base)</span>
<span class="gi">+</span>
<span class="gi">+        for cls in classes:</span>
<span class="gi">+            recurse(cls)</span>
<span class="gi">+</span>
<span class="gi">+        return list(all_classes.values())</span>

<span class="w"> </span>    def class_name(self, cls: Any, parts: int=0, aliases: (dict[str, str] |
<span class="w"> </span>        None)=None) -&gt;str:
<span class="gu">@@ -133,11 +183,27 @@ class InheritanceGraph:</span>
<span class="w"> </span>        This works for things I&#39;ve tested in matplotlib so far, but may not be
<span class="w"> </span>        completely general.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        module = cls.__module__</span>
<span class="gi">+        name = cls.__qualname__</span>
<span class="gi">+        if module == &#39;builtins&#39;:</span>
<span class="gi">+            return name</span>
<span class="gi">+        </span>
<span class="gi">+        if aliases is not None and name in aliases:</span>
<span class="gi">+            return aliases[name]</span>
<span class="gi">+        </span>
<span class="gi">+        full_name = f&quot;{module}.{name}&quot;</span>
<span class="gi">+        if parts == 0:</span>
<span class="gi">+            return full_name</span>
<span class="gi">+        </span>
<span class="gi">+        name_parts = full_name.split(&#39;.&#39;)</span>
<span class="gi">+        if parts &gt; 0:</span>
<span class="gi">+            return &#39;.&#39;.join(name_parts[-parts:])</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;.&#39;.join(name_parts[abs(parts):])</span>

<span class="w"> </span>    def get_all_class_names(self) -&gt;list[str]:
<span class="w"> </span>        &quot;&quot;&quot;Get all of the class names involved in the graph.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [name for (name, _, _, _) in self.class_info]</span>
<span class="w"> </span>    default_graph_attrs = {&#39;rankdir&#39;: &#39;LR&#39;, &#39;size&#39;: &#39;&quot;8.0, 12.0&quot;&#39;,
<span class="w"> </span>        &#39;bgcolor&#39;: &#39;transparent&#39;}
<span class="w"> </span>    default_node_attrs = {&#39;shape&#39;: &#39;box&#39;, &#39;fontsize&#39;: 10, &#39;height&#39;: 0.25,
<span class="gu">@@ -160,7 +226,37 @@ class InheritanceGraph:</span>
<span class="w"> </span>        *graph_attrs*, *node_attrs*, *edge_attrs* are dictionaries containing
<span class="w"> </span>        key/value pairs to pass on as graphviz properties.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        g_attrs = self.default_graph_attrs.copy()</span>
<span class="gi">+        n_attrs = self.default_node_attrs.copy()</span>
<span class="gi">+        e_attrs = self.default_edge_attrs.copy()</span>
<span class="gi">+        if graph_attrs:</span>
<span class="gi">+            g_attrs.update(graph_attrs)</span>
<span class="gi">+        if node_attrs:</span>
<span class="gi">+            n_attrs.update(node_attrs)</span>
<span class="gi">+        if edge_attrs:</span>
<span class="gi">+            e_attrs.update(edge_attrs)</span>
<span class="gi">+</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(f&#39;digraph {name} {{&#39;)</span>
<span class="gi">+        res.append(&#39;    rankdir = &quot;LR&quot;&#39;)</span>
<span class="gi">+        res.append(&#39;    bgcolor = &quot;transparent&quot;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        for name, _, bases, module in self.class_info:</span>
<span class="gi">+            # Write the node</span>
<span class="gi">+            this_node_attrs = n_attrs.copy()</span>
<span class="gi">+            url = urls and urls.get(name)</span>
<span class="gi">+            if url is not None:</span>
<span class="gi">+                this_node_attrs[&#39;URL&#39;] = f&#39;&quot;{url}&quot;&#39;</span>
<span class="gi">+                this_node_attrs[&#39;target&#39;] = &#39;&quot;_top&quot;&#39;</span>
<span class="gi">+            node = &#39;    %s [%s]&#39; % (name, &#39;,&#39;.join(&#39;%s=%s&#39; % x for x in this_node_attrs.items()))</span>
<span class="gi">+            res.append(node)</span>
<span class="gi">+</span>
<span class="gi">+            # Write the edges</span>
<span class="gi">+            for base_name in bases:</span>
<span class="gi">+                res.append(f&#39;    {base_name} -&gt; {name} [arrowhead=&quot;none&quot;, arrowtail=&quot;normal&quot;]&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        res.append(&#39;}&#39;)</span>
<span class="gi">+        return &#39;\n&#39;.join(res)</span>


<span class="w"> </span>class inheritance_diagram(graphviz):
<span class="gh">diff --git a/sphinx/ext/intersphinx/_cli.py b/sphinx/ext/intersphinx/_cli.py</span>
<span class="gh">index 65410871f..c07f6f4ac 100644</span>
<span class="gd">--- a/sphinx/ext/intersphinx/_cli.py</span>
<span class="gi">+++ b/sphinx/ext/intersphinx/_cli.py</span>
<span class="gu">@@ -6,4 +6,18 @@ from sphinx.ext.intersphinx._load import _fetch_inventory</span>

<span class="w"> </span>def inspect_main(argv: list[str], /) -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Debug functionality to print out an inventory&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(argv) &lt; 2:</span>
<span class="gi">+        print(&quot;Usage: python -m sphinx.ext.intersphinx &lt;URI&gt;&quot;, file=sys.stderr)</span>
<span class="gi">+        return 1</span>
<span class="gi">+</span>
<span class="gi">+    uri = argv[1]</span>
<span class="gi">+    try:</span>
<span class="gi">+        inventory = _fetch_inventory(None, uri, uri)</span>
<span class="gi">+        for type_name, items in inventory.items():</span>
<span class="gi">+            print(f&quot;{type_name}:&quot;)</span>
<span class="gi">+            for name, (project, version, location, _) in items.items():</span>
<span class="gi">+                print(f&quot;  {name:&lt;30} {project:&lt;20} {version:&lt;10} {location}&quot;)</span>
<span class="gi">+        return 0</span>
<span class="gi">+    except Exception as e:</span>
<span class="gi">+        print(f&quot;Error fetching inventory: {e}&quot;, file=sys.stderr)</span>
<span class="gi">+        return 1</span>
<span class="gh">diff --git a/sphinx/ext/intersphinx/_load.py b/sphinx/ext/intersphinx/_load.py</span>
<span class="gh">index 021469d71..22fb9aa7e 100644</span>
<span class="gd">--- a/sphinx/ext/intersphinx/_load.py</span>
<span class="gi">+++ b/sphinx/ext/intersphinx/_load.py</span>
<span class="gu">@@ -35,7 +35,31 @@ def validate_intersphinx_mapping(app: Sphinx, config: Config) -&gt;None:</span>
<span class="w"> </span>    * The second element of each value pair (inventory locations)
<span class="w"> </span>      is a tuple of non-empty strings or None.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    intersphinx_mapping = config.intersphinx_mapping</span>
<span class="gi">+    if not isinstance(intersphinx_mapping, dict):</span>
<span class="gi">+        raise ConfigError(&#39;intersphinx_mapping must be a dictionary&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    for key, value in list(intersphinx_mapping.items()):</span>
<span class="gi">+        if not isinstance(key, str) or not key:</span>
<span class="gi">+            raise ConfigError(&#39;intersphinx_mapping key must be a non-empty string&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        if not isinstance(value, (list, tuple)) or len(value) != 2:</span>
<span class="gi">+            raise ConfigError(&#39;intersphinx_mapping value must be a two-element list or tuple&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        target_uri, inventory_locations = value</span>
<span class="gi">+        if not isinstance(target_uri, str) or not target_uri:</span>
<span class="gi">+            raise ConfigError(&#39;first element of intersphinx_mapping value must be a non-empty string&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        if inventory_locations is not None:</span>
<span class="gi">+            if not isinstance(inventory_locations, (list, tuple)):</span>
<span class="gi">+                inventory_locations = (inventory_locations,)</span>
<span class="gi">+            for loc in inventory_locations:</span>
<span class="gi">+                if not isinstance(loc, str) or not loc:</span>
<span class="gi">+                    raise ConfigError(&#39;second element of intersphinx_mapping value must be None or a tuple of non-empty strings&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        intersphinx_mapping[key] = (target_uri, inventory_locations)</span>
<span class="gi">+    </span>
<span class="gi">+    config.intersphinx_mapping = intersphinx_mapping</span>


<span class="w"> </span>def load_mappings(app: Sphinx) -&gt;None:
<span class="gu">@@ -43,18 +67,59 @@ def load_mappings(app: Sphinx) -&gt;None:</span>

<span class="w"> </span>    The intersphinx mappings are expected to be normalized.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    env = app.env</span>
<span class="gi">+    config = app.config</span>
<span class="gi">+</span>
<span class="gi">+    if not hasattr(env, &#39;intersphinx_projects&#39;):</span>
<span class="gi">+        env.intersphinx_projects = {}</span>
<span class="gi">+    if not hasattr(env, &#39;intersphinx_cache&#39;):</span>
<span class="gi">+        env.intersphinx_cache = {}</span>
<span class="gi">+</span>
<span class="gi">+    for name, (uri, locations) in config.intersphinx_mapping.items():</span>
<span class="gi">+        env.intersphinx_projects[name] = _IntersphinxProject(</span>
<span class="gi">+            name=name,</span>
<span class="gi">+            uri=uri,</span>
<span class="gi">+            locations=locations or (None,),</span>
<span class="gi">+            inventory=None,</span>
<span class="gi">+        )</span>


<span class="w"> </span>def fetch_inventory(app: Sphinx, uri: InventoryURI, inv: str) -&gt;Inventory:
<span class="w"> </span>    &quot;&quot;&quot;Fetch, parse and return an intersphinx inventory file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    config = app.config</span>
<span class="gi">+    srcdir = app.srcdir</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        inventory = _fetch_inventory(</span>
<span class="gi">+            target_uri=uri,</span>
<span class="gi">+            inv_location=inv,</span>
<span class="gi">+            config=config,</span>
<span class="gi">+            srcdir=srcdir,</span>
<span class="gi">+        )</span>
<span class="gi">+    except Exception as exc:</span>
<span class="gi">+        LOGGER.warning(__(&#39;intersphinx inventory %r not fetchable due to %s: %s&#39;),</span>
<span class="gi">+                       inv, type(exc).__name__, exc)</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>
<span class="gi">+    return inventory</span>


<span class="w"> </span>def _fetch_inventory(*, target_uri: InventoryURI, inv_location: str, config:
<span class="w"> </span>    Config, srcdir: Path) -&gt;Inventory:
<span class="w"> </span>    &quot;&quot;&quot;Fetch, parse and return an intersphinx inventory file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if inv_location is None:</span>
<span class="gi">+        inv_location = posixpath.join(target_uri, INVENTORY_FILENAME)</span>
<span class="gi">+</span>
<span class="gi">+    if inv_location.startswith((&#39;http:&#39;, &#39;https:&#39;)):</span>
<span class="gi">+        f = _read_from_url(inv_location, config=config)</span>
<span class="gi">+    else:</span>
<span class="gi">+        f = path.join(srcdir, inv_location)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        with InventoryFile.load(f, uri=target_uri) as invdata:</span>
<span class="gi">+            return invdata.load()</span>
<span class="gi">+    except Exception as exc:</span>
<span class="gi">+        raise ValueError(__(&#39;Failed to read inventory file %r: %s&#39;) % (inv_location, exc))</span>


<span class="w"> </span>def _get_safe_url(url: str) -&gt;str:
<span class="gu">@@ -69,7 +134,13 @@ def _get_safe_url(url: str) -&gt;str:</span>
<span class="w"> </span>    :return: *url* with password removed
<span class="w"> </span>    :rtype: ``str``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = urlsplit(url)</span>
<span class="gi">+    if parts.username:</span>
<span class="gi">+        netloc = f&#39;{parts.username}@{parts.hostname}&#39;</span>
<span class="gi">+        if parts.port:</span>
<span class="gi">+            netloc += f&#39;:{parts.port}&#39;</span>
<span class="gi">+        return urlunsplit((parts.scheme, netloc, parts.path, parts.query, parts.fragment))</span>
<span class="gi">+    return url</span>


<span class="w"> </span>def _strip_basic_auth(url: str) -&gt;str:
<span class="gu">@@ -86,7 +157,13 @@ def _strip_basic_auth(url: str) -&gt;str:</span>
<span class="w"> </span>    :return: *url* with any basic auth creds removed
<span class="w"> </span>    :rtype: ``str``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = urlsplit(url)</span>
<span class="gi">+    if parts.username or parts.password:</span>
<span class="gi">+        netloc = parts.hostname</span>
<span class="gi">+        if parts.port:</span>
<span class="gi">+            netloc += f&#39;:{parts.port}&#39;</span>
<span class="gi">+        return urlunsplit((parts.scheme, netloc, parts.path, parts.query, parts.fragment))</span>
<span class="gi">+    return url</span>


<span class="w"> </span>def _read_from_url(url: str, *, config: Config) -&gt;IO:
<span class="gu">@@ -105,4 +182,9 @@ def _read_from_url(url: str, *, config: Config) -&gt;IO:</span>
<span class="w"> </span>    :return: data read from resource described by *url*
<span class="w"> </span>    :rtype: ``file``-like object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        with requests.get(url, stream=True, config=config, timeout=config.intersphinx_timeout) as r:</span>
<span class="gi">+            r.raise_for_status()</span>
<span class="gi">+            return r.raw</span>
<span class="gi">+    except requests.exceptions.RequestException as exc:</span>
<span class="gi">+        raise ValueError(__(&#39;Could not fetch remote inventory %r: %s&#39;) % (url, exc))</span>
<span class="gh">diff --git a/sphinx/ext/intersphinx/_resolve.py b/sphinx/ext/intersphinx/_resolve.py</span>
<span class="gh">index 37f1281fc..d7e9ea944 100644</span>
<span class="gd">--- a/sphinx/ext/intersphinx/_resolve.py</span>
<span class="gi">+++ b/sphinx/ext/intersphinx/_resolve.py</span>
<span class="gu">@@ -34,7 +34,15 @@ def resolve_reference_in_inventory(env: BuildEnvironment, inv_name:</span>

<span class="w"> </span>    Requires ``inventory_exists(env, inv_name)``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    inventory = InventoryAdapter(env).load(inv_name)</span>
<span class="gi">+    reftarget = node[&#39;reftarget&#39;]</span>
<span class="gi">+    if reftarget in inventory:</span>
<span class="gi">+        newnode = nodes.reference(&#39;&#39;, &#39;&#39;, internal=False)</span>
<span class="gi">+        newnode[&#39;refuri&#39;] = inventory[reftarget][2]</span>
<span class="gi">+        newnode[&#39;reftitle&#39;] = inventory[reftarget][3]</span>
<span class="gi">+        newnode.append(contnode)</span>
<span class="gi">+        return newnode</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def resolve_reference_any_inventory(env: BuildEnvironment,
<span class="gu">@@ -44,7 +52,19 @@ def resolve_reference_any_inventory(env: BuildEnvironment,</span>

<span class="w"> </span>    Resolution is tried with the target as is in any inventory.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    reftarget = node[&#39;reftarget&#39;]</span>
<span class="gi">+    inventory_adapter = InventoryAdapter(env)</span>
<span class="gi">+    for inv_name in inventory_adapter.named_inventories:</span>
<span class="gi">+        if honor_disabled_refs and inv_name in env.config.intersphinx_disabled_reftypes:</span>
<span class="gi">+            continue</span>
<span class="gi">+        inventory = inventory_adapter.load(inv_name)</span>
<span class="gi">+        if reftarget in inventory:</span>
<span class="gi">+            newnode = nodes.reference(&#39;&#39;, &#39;&#39;, internal=False)</span>
<span class="gi">+            newnode[&#39;refuri&#39;] = inventory[reftarget][2]</span>
<span class="gi">+            newnode[&#39;reftitle&#39;] = inventory[reftarget][3]</span>
<span class="gi">+            newnode.append(contnode)</span>
<span class="gi">+            return newnode</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def resolve_reference_detect_inventory(env: BuildEnvironment, node:
<span class="gu">@@ -56,13 +76,30 @@ def resolve_reference_detect_inventory(env: BuildEnvironment, node:</span>
<span class="w"> </span>    to form ``inv_name:newtarget``. If ``inv_name`` is a named inventory, then resolution
<span class="w"> </span>    is tried in that inventory with the new target.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    reftarget = node[&#39;reftarget&#39;]</span>
<span class="gi">+    result = resolve_reference_any_inventory(env, True, node, contnode)</span>
<span class="gi">+    if result:</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;:&#39; in reftarget:</span>
<span class="gi">+        inv_name, newtarget = reftarget.split(&#39;:&#39;, 1)</span>
<span class="gi">+        inventory_adapter = InventoryAdapter(env)</span>
<span class="gi">+        if inv_name in inventory_adapter.named_inventories:</span>
<span class="gi">+            node = node.copy()</span>
<span class="gi">+            node[&#39;reftarget&#39;] = newtarget</span>
<span class="gi">+            return resolve_reference_in_inventory(env, inv_name, node, contnode)</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def missing_reference(app: Sphinx, env: BuildEnvironment, node:
<span class="w"> </span>    pending_xref, contnode: TextElement) -&gt;(nodes.reference | None):
<span class="w"> </span>    &quot;&quot;&quot;Attempt to resolve a missing reference via intersphinx references.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if node.get(&#39;refdomain&#39;):</span>
<span class="gi">+        domain = env.get_domain(node[&#39;refdomain&#39;])</span>
<span class="gi">+        if domain.name != &#39;std&#39;:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    return resolve_reference_detect_inventory(env, node, contnode)</span>


<span class="w"> </span>class IntersphinxDispatcher(CustomReSTDispatcher):
<span class="gu">@@ -90,7 +127,12 @@ class IntersphinxRole(SphinxRole):</span>
<span class="w"> </span>        - ``external:name`` -- any inventory and domain, explicit name.
<span class="w"> </span>        - ``external:domain:name`` -- any inventory, explicit domain and name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        match = self._re_inv_ref.match(name)</span>
<span class="gi">+        if match:</span>
<span class="gi">+            inv_name = match.group(2)</span>
<span class="gi">+            suffix = match.group(3)</span>
<span class="gi">+            return inv_name, suffix</span>
<span class="gi">+        return None, name</span>

<span class="w"> </span>    def _get_domain_role(self, name: str) -&gt;tuple[str | None, str | None]:
<span class="w"> </span>        &quot;&quot;&quot;Convert the *name* string into a domain and a role name.
<span class="gu">@@ -99,12 +141,33 @@ class IntersphinxRole(SphinxRole):</span>
<span class="w"> </span>        - If *name* contains a single ``:``, the domain/role is split on this.
<span class="w"> </span>        - If *name* contains multiple ``:``, return ``(None, None)``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parts = name.split(&#39;:&#39;)</span>
<span class="gi">+        if len(parts) == 1:</span>
<span class="gi">+            return None, name</span>
<span class="gi">+        elif len(parts) == 2:</span>
<span class="gi">+            return parts[0], parts[1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None, None</span>

<span class="w"> </span>    def invoke_role(self, role: tuple[str, str]) -&gt;tuple[list[Node], list[
<span class="w"> </span>        system_message]]:
<span class="w"> </span>        &quot;&quot;&quot;Invoke the role described by a ``(domain, role name)`` pair.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        domain_name, role_name = role</span>
<span class="gi">+        if domain_name:</span>
<span class="gi">+            domain = self.env.get_domain(domain_name)</span>
<span class="gi">+            role_fn = domain.roles.get(role_name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            role_fn = self.env.roles.get(role_name)</span>
<span class="gi">+</span>
<span class="gi">+        if role_fn is None:</span>
<span class="gi">+            msg = self.inliner.reporter.error(</span>
<span class="gi">+                f&#39;Unknown interpreted text role &quot;{role_name}&quot;.&#39;,</span>
<span class="gi">+                line=self.lineno)</span>
<span class="gi">+            prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)</span>
<span class="gi">+            return [prb], [msg]</span>
<span class="gi">+</span>
<span class="gi">+        return role_fn(self.name, self.rawtext, self.text, self.lineno,</span>
<span class="gi">+                       self.inliner, self.options, self.content)</span>


<span class="w"> </span>class IntersphinxRoleResolver(ReferencesResolver):
<span class="gu">@@ -121,4 +184,7 @@ def install_dispatcher(app: Sphinx, docname: str, source: list[str]) -&gt;None:</span>
<span class="w"> </span>    .. note:: The installed dispatcher will be uninstalled on disabling sphinx_domain
<span class="w"> </span>              automatically.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dispatcher = IntersphinxDispatcher()</span>
<span class="gi">+    app.add_rst_parser(dispatcher)</span>
<span class="gi">+    app.connect(&#39;source-read&#39;, lambda app, docname, source: dispatcher.enable())</span>
<span class="gi">+    app.connect(&#39;doctree-read&#39;, lambda app, doctree: dispatcher.disable())</span>
<span class="gh">diff --git a/sphinx/ext/intersphinx/_shared.py b/sphinx/ext/intersphinx/_shared.py</span>
<span class="gh">index 56a5986a5..06e77b0e3 100644</span>
<span class="gd">--- a/sphinx/ext/intersphinx/_shared.py</span>
<span class="gi">+++ b/sphinx/ext/intersphinx/_shared.py</span>
<span class="gu">@@ -90,4 +90,4 @@ class InventoryAdapter:</span>
<span class="w"> </span>        - Element two is a time value for cache invalidation, an integer.
<span class="w"> </span>        - Element three is the loaded remote inventory of type :class:`!Inventory`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.env.intersphinx_cache</span>
<span class="gh">diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py</span>
<span class="gh">index 9ee30cfc5..8d4e4b7da 100644</span>
<span class="gd">--- a/sphinx/ext/napoleon/docstring.py</span>
<span class="gi">+++ b/sphinx/ext/napoleon/docstring.py</span>
<span class="gu">@@ -49,13 +49,32 @@ class Deque(collections.deque):</span>
<span class="w"> </span>        Return the nth element of the stack, or ``self.sentinel`` if n is
<span class="w"> </span>        greater than the stack size.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self[n]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            return self.sentinel</span>


<span class="w"> </span>def _convert_type_spec(_type: str, translations: (dict[str, str] | None)=None
<span class="w"> </span>    ) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Convert type specification to reference in reST.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if translations is None:</span>
<span class="gi">+        translations = {}</span>
<span class="gi">+    </span>
<span class="gi">+    # Remove any whitespace and split by &#39;|&#39; for union types</span>
<span class="gi">+    types = [t.strip() for t in _type.split(&#39;|&#39;)]</span>
<span class="gi">+    </span>
<span class="gi">+    converted_types = []</span>
<span class="gi">+    for t in types:</span>
<span class="gi">+        # Check if the type is in the translations dictionary</span>
<span class="gi">+        if t in translations:</span>
<span class="gi">+            converted_types.append(f&#39;:py:class:`{translations[t]}`&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # If not in translations, assume it&#39;s a valid Python type</span>
<span class="gi">+            converted_types.append(f&#39;:py:class:`{t}`&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    # Join the converted types back together</span>
<span class="gi">+    return &#39; | &#39;.join(converted_types)</span>


<span class="w"> </span>class GoogleDocstring:
<span class="gu">@@ -215,7 +234,7 @@ class GoogleDocstring:</span>
<span class="w"> </span>            The lines of the docstring in a list.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._parsed_lines</span>


<span class="w"> </span>class NumpyDocstring(GoogleDocstring):
<span class="gu">@@ -330,4 +349,44 @@ class NumpyDocstring(GoogleDocstring):</span>
<span class="w"> </span>        func_name1, func_name2, :meth:`func_name`, func_name3

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = []</span>
<span class="gi">+        current_func = None</span>
<span class="gi">+        current_desc = []</span>
<span class="gi">+</span>
<span class="gi">+        for line in content:</span>
<span class="gi">+            line = line.strip()</span>
<span class="gi">+            if &#39;:&#39; in line:</span>
<span class="gi">+                if current_func:</span>
<span class="gi">+                    result.extend(self._format_see_also_item(current_func, current_desc))</span>
<span class="gi">+                current_func, desc = line.split(&#39;:&#39;, 1)</span>
<span class="gi">+                current_desc = [desc.strip()]</span>
<span class="gi">+            elif line:</span>
<span class="gi">+                if current_func:</span>
<span class="gi">+                    current_desc.append(line)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    result.append(self._format_admonition(&#39;seealso&#39;, [line]))</span>
<span class="gi">+            else:</span>
<span class="gi">+                if current_func:</span>
<span class="gi">+                    result.extend(self._format_see_also_item(current_func, current_desc))</span>
<span class="gi">+                    current_func = None</span>
<span class="gi">+                    current_desc = []</span>
<span class="gi">+</span>
<span class="gi">+        if current_func:</span>
<span class="gi">+            result.extend(self._format_see_also_item(current_func, current_desc))</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def _format_see_also_item(self, func: str, desc: list[str]) -&gt;list[str]:</span>
<span class="gi">+        &quot;&quot;&quot;Helper method to format individual See Also items.&quot;&quot;&quot;</span>
<span class="gi">+        func_parts = func.split(&#39;,&#39;)</span>
<span class="gi">+        formatted_funcs = []</span>
<span class="gi">+        for part in func_parts:</span>
<span class="gi">+            part = part.strip()</span>
<span class="gi">+            if part.startswith(&#39;:&#39;):</span>
<span class="gi">+                formatted_funcs.append(part)</span>
<span class="gi">+            else:</span>
<span class="gi">+                formatted_funcs.append(f&#39;:obj:`{part}`&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        item = [&#39;, &#39;.join(formatted_funcs)]</span>
<span class="gi">+        item.extend(&#39;    &#39; + line for line in desc)</span>
<span class="gi">+        return item</span>
<span class="gh">diff --git a/sphinx/ext/todo.py b/sphinx/ext/todo.py</span>
<span class="gh">index 423cd2039..496775285 100644</span>
<span class="gd">--- a/sphinx/ext/todo.py</span>
<span class="gi">+++ b/sphinx/ext/todo.py</span>
<span class="gu">@@ -48,6 +48,29 @@ class Todo(BaseAdmonition, SphinxDirective):</span>
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {&#39;class&#39;: directives.class_option,
<span class="w"> </span>        &#39;name&#39;: directives.unchanged}

<span class="gi">+    def run(self) -&gt;list[Node]:</span>
<span class="gi">+        if not self.config.todo_include_todos:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        content = self.content</span>
<span class="gi">+        todo_entry = todo_node(content, **self.options)</span>
<span class="gi">+        todo_entry += nodes.title(_(&#39;Todo&#39;), _(&#39;Todo&#39;))</span>
<span class="gi">+        self.set_source_info(todo_entry)</span>
<span class="gi">+</span>
<span class="gi">+        targetid = &#39;todo-%d&#39; % self.env.new_serialno(&#39;todo&#39;)</span>
<span class="gi">+        targetnode = nodes.target(&#39;&#39;, &#39;&#39;, ids=[targetid])</span>
<span class="gi">+        self.state.document.note_explicit_target(targetnode)</span>
<span class="gi">+</span>
<span class="gi">+        todo_entry[&#39;ids&#39;].append(targetid)</span>
<span class="gi">+        self.env.get_domain(&#39;todo&#39;).add_todo(targetid, {</span>
<span class="gi">+            &#39;docname&#39;: self.env.docname,</span>
<span class="gi">+            &#39;lineno&#39;: self.lineno,</span>
<span class="gi">+            &#39;todo&#39;: todo_entry.deepcopy(),</span>
<span class="gi">+            &#39;target&#39;: targetnode,</span>
<span class="gi">+        })</span>
<span class="gi">+</span>
<span class="gi">+        return [targetnode, todo_entry]</span>
<span class="gi">+</span>

<span class="w"> </span>class TodoDomain(Domain):
<span class="w"> </span>    name = &#39;todo&#39;
<span class="gu">@@ -64,6 +87,10 @@ class TodoList(SphinxDirective):</span>
<span class="w"> </span>    final_argument_whitespace = False
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {}

<span class="gi">+    def run(self) -&gt;list[Node]:</span>
<span class="gi">+        # Simply create a todolist node which will be processed later</span>
<span class="gi">+        return [todolist(&#39;&#39;)]</span>
<span class="gi">+</span>

<span class="w"> </span>class TodoListProcessor:

<span class="gu">@@ -78,4 +105,48 @@ class TodoListProcessor:</span>

<span class="w"> </span>    def resolve_reference(self, todo: todo_node, docname: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Resolve references in the todo content.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for node in todo.traverse(addnodes.pending_xref):</span>
<span class="gi">+            contnode = node[0].deepcopy()</span>
<span class="gi">+            newnode = None</span>
<span class="gi">+            try:</span>
<span class="gi">+                newnode = self.domain.resolve_xref(self.env, docname, self.builder,</span>
<span class="gi">+                                                   node[&#39;reftype&#39;], node[&#39;reftarget&#39;],</span>
<span class="gi">+                                                   node, contnode)</span>
<span class="gi">+            except NoUri:</span>
<span class="gi">+                pass</span>
<span class="gi">+            if newnode is None:</span>
<span class="gi">+                logger.warning(__(&#39;Failed to resolve %s: %s&#39;) % (node[&#39;reftype&#39;], node[&#39;reftarget&#39;]),</span>
<span class="gi">+                               location=node)</span>
<span class="gi">+            else:</span>
<span class="gi">+                node.replace_self(newnode)</span>
<span class="gi">+</span>
<span class="gi">+    def process(self, doctree: nodes.document, docname: str) -&gt;None:</span>
<span class="gi">+        for node in doctree.traverse(todolist):</span>
<span class="gi">+            if not self.config.todo_include_todos:</span>
<span class="gi">+                node.parent.remove(node)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            content = []</span>
<span class="gi">+            for todo_info in self.domain.get_todos():</span>
<span class="gi">+                para = nodes.paragraph(classes=[&#39;todo-source&#39;])</span>
<span class="gi">+                description = _(&#39;(The original entry is located in %s, line %d.)&#39;) % \</span>
<span class="gi">+                              (todo_info[&#39;docname&#39;], todo_info[&#39;lineno&#39;])</span>
<span class="gi">+                para += nodes.Text(description)</span>
<span class="gi">+</span>
<span class="gi">+                ref = nodes.reference(&#39;&#39;, &#39;&#39;)</span>
<span class="gi">+                ref[&#39;refdocname&#39;] = todo_info[&#39;docname&#39;]</span>
<span class="gi">+                ref[&#39;refuri&#39;] = self.builder.get_relative_uri(docname, todo_info[&#39;docname&#39;])</span>
<span class="gi">+                ref[&#39;refuri&#39;] += &#39;#&#39; + todo_info[&#39;target&#39;][&#39;refid&#39;]</span>
<span class="gi">+                ref.append(nodes.Text(todo_info[&#39;docname&#39;]))</span>
<span class="gi">+</span>
<span class="gi">+                para += nodes.Text(&#39; (&#39;)</span>
<span class="gi">+                para += ref</span>
<span class="gi">+                para += nodes.Text(&#39;)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+                item = nodes.list_item(&#39;&#39;, para)</span>
<span class="gi">+                todo_entry = todo_info[&#39;todo&#39;]</span>
<span class="gi">+                self.resolve_reference(todo_entry, docname)</span>
<span class="gi">+                item += todo_entry</span>
<span class="gi">+                content.append(item)</span>
<span class="gi">+</span>
<span class="gi">+            node.replace_self(nodes.bullet_list(&#39;&#39;, *content))</span>
<span class="gh">diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py</span>
<span class="gh">index 2fc49bef8..7fa4289fb 100644</span>
<span class="gd">--- a/sphinx/ext/viewcode.py</span>
<span class="gi">+++ b/sphinx/ext/viewcode.py</span>
<span class="gu">@@ -44,9 +44,21 @@ class ViewcodeAnchorTransform(SphinxPostTransform):</span>

<span class="w"> </span>def get_module_filename(app: Sphinx, modname: str) -&gt;(str | None):
<span class="w"> </span>    &quot;&quot;&quot;Get module filename for *modname*.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        module = import_module(modname)</span>
<span class="gi">+        return module.__file__</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        logger.warning(__(&#39;Failed to import %s&#39;), modname)</span>
<span class="gi">+        return None</span>


<span class="w"> </span>def should_generate_module_page(app: Sphinx, modname: str) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check generation of module page is needed.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        module = import_module(modname)</span>
<span class="gi">+        # Check if the module has any public attributes or functions</span>
<span class="gi">+        public_members = [name for name in dir(module) if not name.startswith(&#39;_&#39;)]</span>
<span class="gi">+        return len(public_members) &gt; 0</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        logger.warning(__(&#39;Failed to import %s&#39;), modname)</span>
<span class="gi">+        return False</span>
<span class="gh">diff --git a/sphinx/extension.py b/sphinx/extension.py</span>
<span class="gh">index 816225dad..df757e581 100644</span>
<span class="gd">--- a/sphinx/extension.py</span>
<span class="gi">+++ b/sphinx/extension.py</span>
<span class="gu">@@ -32,4 +32,26 @@ def verify_needs_extensions(app: Sphinx, config: Config) -&gt;None:</span>
<span class="w"> </span>    :raises VersionRequirementError: if the version of an extension in
<span class="w"> </span>    :confval:`needs_extension` is unknown or older than the required version.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not hasattr(config, &#39;needs_extensions&#39;):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    for name, version in config.needs_extensions.items():</span>
<span class="gi">+        if name not in app.extensions:</span>
<span class="gi">+            logger.warning(__(&#39;The extension %r was not loaded yet, but is required for this project.&#39;), name)</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        ext = app.extensions[name]</span>
<span class="gi">+        if ext.version == &#39;unknown version&#39;:</span>
<span class="gi">+            logger.warning(__(&#39;The extension %r has an unknown version&#39;), name)</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            required = Version(version)</span>
<span class="gi">+            actual = Version(ext.version)</span>
<span class="gi">+            if actual &lt; required:</span>
<span class="gi">+                raise VersionRequirementError(</span>
<span class="gi">+                    __(&#39;This project needs the extension %r at least in version %s, &#39;</span>
<span class="gi">+                       &#39;but you have version %s.&#39;) % (name, version, ext.version)</span>
<span class="gi">+                )</span>
<span class="gi">+        except InvalidVersion:</span>
<span class="gi">+            logger.warning(__(&#39;The version of %r is invalid.&#39;), name)</span>
<span class="gh">diff --git a/sphinx/io.py b/sphinx/io.py</span>
<span class="gh">index 5f18053ac..da117b837 100644</span>
<span class="gd">--- a/sphinx/io.py</span>
<span class="gi">+++ b/sphinx/io.py</span>
<span class="gu">@@ -44,7 +44,10 @@ class SphinxBaseReader(standalone.Reader):</span>
<span class="w"> </span>        Creates a new document object which has a special reporter object good
<span class="w"> </span>        for logging.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        document = super().new_document()</span>
<span class="gi">+        reporter = LoggingReporter.from_reporter(document.reporter)</span>
<span class="gi">+        document.reporter = reporter</span>
<span class="gi">+        return document</span>


<span class="w"> </span>class SphinxStandaloneReader(SphinxBaseReader):
<span class="gu">@@ -54,7 +57,10 @@ class SphinxStandaloneReader(SphinxBaseReader):</span>

<span class="w"> </span>    def read_source(self, env: BuildEnvironment) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Read content from source and do post-process.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        content = super().read()</span>
<span class="gi">+        if isinstance(self.source, str):</span>
<span class="gi">+            content = env.preprocess_source(self.source, content)</span>
<span class="gi">+        return content</span>


<span class="w"> </span>class SphinxI18nReader(SphinxBaseReader):
<span class="gu">@@ -74,7 +80,7 @@ class SphinxDummyWriter(UnfilteredWriter):</span>

<span class="w"> </span>def SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -&gt;Any:
<span class="w"> </span>    &quot;&quot;&quot;Bypass source object as is to cheat Publisher.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return source</span>


<span class="w"> </span>class SphinxFileInput(FileInput):
<span class="gh">diff --git a/sphinx/jinja2glue.py b/sphinx/jinja2glue.py</span>
<span class="gh">index 6b3cabe75..f6a146e29 100644</span>
<span class="gd">--- a/sphinx/jinja2glue.py</span>
<span class="gi">+++ b/sphinx/jinja2glue.py</span>
<span class="gu">@@ -28,12 +28,23 @@ def _todim(val: (int | str)) -&gt;str:</span>

<span class="w"> </span>    Everything else is returned unchanged.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if val is None:</span>
<span class="gi">+        return &#39;initial&#39;</span>
<span class="gi">+    if val == 0 or val == &#39;0&#39;:</span>
<span class="gi">+        return &#39;0&#39;</span>
<span class="gi">+    if isinstance(val, int) or (isinstance(val, str) and val.isdigit()):</span>
<span class="gi">+        return f&#39;{val}px&#39;</span>
<span class="gi">+    return str(val)</span>


<span class="w"> </span>def accesskey(context: Any, key: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Helper to output each access key only once.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;accesskeys&#39; not in context:</span>
<span class="gi">+        context[&#39;accesskeys&#39;] = set()</span>
<span class="gi">+    if key not in context[&#39;accesskeys&#39;]:</span>
<span class="gi">+        context[&#39;accesskeys&#39;].add(key)</span>
<span class="gi">+        return &#39; accesskey=&quot;%s&quot;&#39; % key</span>
<span class="gi">+    return &#39;&#39;</span>


<span class="w"> </span>class idgen:
<span class="gu">@@ -46,6 +57,9 @@ class idgen:</span>
<span class="w"> </span>        return self.id
<span class="w"> </span>    next = __next__

<span class="gi">+    def __iter__(self):</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>

<span class="w"> </span>class SphinxFileSystemLoader(FileSystemLoader):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -53,8 +67,56 @@ class SphinxFileSystemLoader(FileSystemLoader):</span>
<span class="w"> </span>    template names.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def get_source(self, environment: Environment, template: str) -&gt; tuple[str, str | None, Callable[[], bool] | None]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return super().get_source(environment, template)</span>
<span class="gi">+        except TemplateNotFound:</span>
<span class="gi">+            # Try to load the template by joining it with the search path</span>
<span class="gi">+            for searchpath in self.searchpath:</span>
<span class="gi">+                filename = path.join(searchpath, template)</span>
<span class="gi">+                if path.exists(filename):</span>
<span class="gi">+                    with open(filename, &#39;r&#39;, encoding=self.encoding) as f:</span>
<span class="gi">+                        contents = f.read()</span>
<span class="gi">+                    mtime = path.getmtime(filename)</span>
<span class="gi">+                    def uptodate():</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            return path.getmtime(filename) == mtime</span>
<span class="gi">+                        except OSError:</span>
<span class="gi">+                            return False</span>
<span class="gi">+                    return contents, filename, uptodate</span>
<span class="gi">+            raise TemplateNotFound(template)</span>
<span class="gi">+</span>

<span class="w"> </span>class BuiltinTemplateLoader(TemplateBridge, BaseLoader):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Interfaces the rendering environment of jinja2 for use in Sphinx.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        self.loaders: dict[str, SphinxFileSystemLoader] = {}</span>
<span class="gi">+        self.templates: dict[str, str] = {}</span>
<span class="gi">+        self.environment = SandboxedEnvironment(loader=self)</span>
<span class="gi">+</span>
<span class="gi">+    def init(self, builder: Builder, theme: Theme | None = None, dirs: list[str] | None = None) -&gt; None:</span>
<span class="gi">+        self.loaders = {}</span>
<span class="gi">+        self.templates = {}</span>
<span class="gi">+        if theme:</span>
<span class="gi">+            self.loaders[&#39;theme&#39;] = SphinxFileSystemLoader(theme.get_theme_dirs())</span>
<span class="gi">+        if dirs:</span>
<span class="gi">+            self.loaders[&#39;searchpath&#39;] = SphinxFileSystemLoader(dirs)</span>
<span class="gi">+        if builder.config.template_path:</span>
<span class="gi">+            self.loaders[&#39;template_path&#39;] = SphinxFileSystemLoader(builder.config.template_path)</span>
<span class="gi">+</span>
<span class="gi">+    def get_source(self, environment: Environment, template: str) -&gt; tuple[str, str | None, Callable[[], bool] | None]:</span>
<span class="gi">+        for loadername, loader in self.loaders.items():</span>
<span class="gi">+            try:</span>
<span class="gi">+                return loader.get_source(environment, template)</span>
<span class="gi">+            except TemplateNotFound:</span>
<span class="gi">+                pass</span>
<span class="gi">+        raise TemplateNotFound(template)</span>
<span class="gi">+</span>
<span class="gi">+    def render(self, template: str, context: dict) -&gt; str:</span>
<span class="gi">+        return self.environment.get_template(template).render(context)</span>
<span class="gi">+</span>
<span class="gi">+    def render_string(self, source: str, context: dict) -&gt; str:</span>
<span class="gi">+        return self.environment.from_string(source).render(context)</span>
<span class="gh">diff --git a/sphinx/parsers.py b/sphinx/parsers.py</span>
<span class="gh">index a9686d339..4d0f211fd 100644</span>
<span class="gd">--- a/sphinx/parsers.py</span>
<span class="gi">+++ b/sphinx/parsers.py</span>
<span class="gu">@@ -32,7 +32,9 @@ class Parser(docutils.parsers.Parser):</span>

<span class="w"> </span>        :param sphinx.application.Sphinx app: Sphinx application object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.app = app</span>
<span class="gi">+        self.config = app.config</span>
<span class="gi">+        self.env = app.env</span>


<span class="w"> </span>class RSTParser(docutils.parsers.rst.Parser, Parser):
<span class="gu">@@ -44,13 +46,19 @@ class RSTParser(docutils.parsers.rst.Parser, Parser):</span>

<span class="w"> </span>        refs: sphinx.io.SphinxStandaloneReader
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        transforms = super().get_transforms()</span>
<span class="gi">+        transforms.remove(SmartQuotes)</span>
<span class="gi">+        return transforms</span>

<span class="w"> </span>    def parse(self, inputstring: (str | StringList), document: nodes.document
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Parse text and generate a document tree.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(inputstring, str):</span>
<span class="gi">+            inputstring = StringList(inputstring.splitlines(), document.current_source)</span>
<span class="gi">+        self.decorate(inputstring)</span>
<span class="gi">+        super().parse(inputstring, document)</span>

<span class="w"> </span>    def decorate(self, content: StringList) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Preprocess reST content before parsing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        prepend_prolog(content, self.config.rst_prolog)</span>
<span class="gi">+        append_epilog(content, self.config.rst_epilog)</span>
<span class="gh">diff --git a/sphinx/project.py b/sphinx/project.py</span>
<span class="gh">index 7075b88a1..0b6a51895 100644</span>
<span class="gd">--- a/sphinx/project.py</span>
<span class="gi">+++ b/sphinx/project.py</span>
<span class="gu">@@ -29,21 +29,53 @@ class Project:</span>

<span class="w"> </span>    def restore(self, other: Project) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Take over a result of last build.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.docnames = other.docnames</span>
<span class="gi">+        self._path_to_docname = other._path_to_docname</span>
<span class="gi">+        self._docname_to_path = other._docname_to_path</span>

<span class="w"> </span>    def discover(self, exclude_paths: Iterable[str]=(), include_paths:
<span class="w"> </span>        Iterable[str]=(&#39;**&#39;,)) -&gt;set[str]:
<span class="w"> </span>        &quot;&quot;&quot;Find all document files in the source directory and put them in
<span class="w"> </span>        :attr:`docnames`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.docnames = set()</span>
<span class="gi">+        self._path_to_docname.clear()</span>
<span class="gi">+        self._docname_to_path.clear()</span>
<span class="gi">+</span>
<span class="gi">+        for filename in get_matching_files(self.srcdir, include_patterns=include_paths,</span>
<span class="gi">+                                           exclude_patterns=list(exclude_paths) + EXCLUDE_PATHS):</span>
<span class="gi">+            if os.path.splitext(filename)[1] in self.source_suffix:</span>
<span class="gi">+                docname = self.path2doc(filename)</span>
<span class="gi">+                if docname:</span>
<span class="gi">+                    self.docnames.add(docname)</span>
<span class="gi">+</span>
<span class="gi">+        return self.docnames</span>

<span class="w"> </span>    def path2doc(self, filename: (str | os.PathLike[str])) -&gt;(str | None):
<span class="w"> </span>        &quot;&quot;&quot;Return the docname for the filename if the file is a document.

<span class="w"> </span>        *filename* should be absolute or relative to the source directory.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        filename = Path(filename).resolve()</span>
<span class="gi">+        try:</span>
<span class="gi">+            rel_path = filename.relative_to(self.srcdir)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        for suffix in self.source_suffix:</span>
<span class="gi">+            if rel_path.name.endswith(suffix):</span>
<span class="gi">+                rel_path = rel_path.with_suffix(&#39;&#39;)</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        docname = str(rel_path).replace(os.path.sep, &#39;/&#39;)</span>
<span class="gi">+        if docname in self._path_to_docname:</span>
<span class="gi">+            return self._path_to_docname[filename]</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._path_to_docname[filename] = docname</span>
<span class="gi">+            self._docname_to_path[docname] = filename</span>
<span class="gi">+            return docname</span>

<span class="w"> </span>    def doc2path(self, docname: str, absolute: bool) -&gt;_StrPath:
<span class="w"> </span>        &quot;&quot;&quot;Return the filename for the document name.
<span class="gu">@@ -51,4 +83,17 @@ class Project:</span>
<span class="w"> </span>        If *absolute* is True, return as an absolute path.
<span class="w"> </span>        Else, return as a relative path to the source directory.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if docname in self._docname_to_path:</span>
<span class="gi">+            path = self._docname_to_path[docname]</span>
<span class="gi">+        else:</span>
<span class="gi">+            path = Path(docname.replace(&#39;/&#39;, os.path.sep))</span>
<span class="gi">+            if not path.suffix:</span>
<span class="gi">+                path = path.with_suffix(self._first_source_suffix)</span>
<span class="gi">+            path = Path(self.srcdir) / path</span>
<span class="gi">+            self._docname_to_path[docname] = path</span>
<span class="gi">+            self._path_to_docname[path] = docname</span>
<span class="gi">+</span>
<span class="gi">+        if absolute:</span>
<span class="gi">+            return path_stabilize(path)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return _StrPath(path.relative_to(self.srcdir))</span>
<span class="gh">diff --git a/sphinx/pycode/ast.py b/sphinx/pycode/ast.py</span>
<span class="gh">index f7da51a16..e7d9e4009 100644</span>
<span class="gd">--- a/sphinx/pycode/ast.py</span>
<span class="gi">+++ b/sphinx/pycode/ast.py</span>
<span class="gu">@@ -11,7 +11,10 @@ OPERATORS: dict[type[ast.AST], str] = {ast.Add: &#39;+&#39;, ast.And: &#39;and&#39;, ast.</span>

<span class="w"> </span>def unparse(node: (ast.AST | None), code: str=&#39;&#39;) -&gt;(str | None):
<span class="w"> </span>    &quot;&quot;&quot;Unparse an AST to string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if node is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    visitor = _UnparseVisitor(code)</span>
<span class="gi">+    return visitor.visit(node)</span>


<span class="w"> </span>class _UnparseVisitor(ast.NodeVisitor):
<span class="gu">@@ -24,4 +27,9 @@ class _UnparseVisitor(ast.NodeVisitor):</span>
<span class="w"> </span>    def _visit_arg_with_default(self, arg: ast.arg, default: (ast.AST | None)
<span class="w"> </span>        ) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Unparse a single argument to a string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = arg.arg</span>
<span class="gi">+        if arg.annotation:</span>
<span class="gi">+            result += &#39;: &#39; + self.visit(arg.annotation)</span>
<span class="gi">+        if default:</span>
<span class="gi">+            result += &#39; = &#39; + self.visit(default)</span>
<span class="gi">+        return result</span>
<span class="gh">diff --git a/sphinx/pycode/parser.py b/sphinx/pycode/parser.py</span>
<span class="gh">index 54e6b77c5..0f263c6a3 100644</span>
<span class="gd">--- a/sphinx/pycode/parser.py</span>
<span class="gi">+++ b/sphinx/pycode/parser.py</span>
<span class="gu">@@ -20,7 +20,12 @@ emptyline_re = re.compile(&#39;^\\s*(#.*)?$&#39;)</span>

<span class="w"> </span>def get_assign_targets(node: ast.AST) -&gt;list[ast.expr]:
<span class="w"> </span>    &quot;&quot;&quot;Get list of targets from Assign and AnnAssign node.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(node, ast.Assign):</span>
<span class="gi">+        return node.targets</span>
<span class="gi">+    elif isinstance(node, ast.AnnAssign):</span>
<span class="gi">+        return [node.target]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return []</span>


<span class="w"> </span>def get_lvar_names(node: ast.AST, self: (ast.arg | None)=None) -&gt;list[str]:
<span class="gu">@@ -32,12 +37,24 @@ def get_lvar_names(node: ast.AST, self: (ast.arg | None)=None) -&gt;list[str]:</span>
<span class="w"> </span>        dic[&quot;bar&quot;] = &#39;baz&#39;
<span class="w"> </span>        # =&gt; TypeError
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(node, ast.Name):</span>
<span class="gi">+        return [node.id]</span>
<span class="gi">+    elif isinstance(node, ast.Tuple) or isinstance(node, ast.List):</span>
<span class="gi">+        return sum((get_lvar_names(elt, self) for elt in node.elts), [])</span>
<span class="gi">+    elif isinstance(node, ast.Attribute):</span>
<span class="gi">+        if isinstance(node.value, ast.Name) and node.value.id == &#39;self&#39;:</span>
<span class="gi">+            return [f&#39;self.{node.attr}&#39;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(&#39;The assignment is not a variable&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&#39;The assignment is not a variable&#39;)</span>


<span class="w"> </span>def dedent_docstring(s: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Remove common leading indentation from docstring.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def dummy(): pass</span>
<span class="gi">+    dummy.__doc__ = s</span>
<span class="gi">+    return inspect.getdoc(dummy)</span>


<span class="w"> </span>class Token:
<span class="gu">@@ -56,7 +73,7 @@ class Token:</span>
<span class="w"> </span>            return self.kind == other
<span class="w"> </span>        elif isinstance(other, str):
<span class="w"> </span>            return self.value == other
<span class="gd">-        elif isinstance(other, list | tuple):</span>
<span class="gi">+        elif isinstance(other, (list, tuple)):</span>
<span class="w"> </span>            return [self.kind, self.value] == list(other)
<span class="w"> </span>        elif other is None:
<span class="w"> </span>            return False
<span class="gu">@@ -80,21 +97,39 @@ class TokenProcessor:</span>

<span class="w"> </span>    def get_line(self, lineno: int) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Returns specified line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.buffers[lineno - 1]</span>

<span class="w"> </span>    def fetch_token(self) -&gt;(Token | None):
<span class="w"> </span>        &quot;&quot;&quot;Fetch the next token from source code.

<span class="w"> </span>        Returns ``None`` if sequence finished.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            token = next(self.tokens)</span>
<span class="gi">+            self.previous = self.current</span>
<span class="gi">+            self.current = Token(*token)</span>
<span class="gi">+            return self.current</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    def fetch_until(self, condition: Any) -&gt;list[Token]:
<span class="w"> </span>        &quot;&quot;&quot;Fetch tokens until specified token appeared.

<span class="w"> </span>        .. note:: This also handles parenthesis well.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        tokens = []</span>
<span class="gi">+        depth = 0</span>
<span class="gi">+        while True:</span>
<span class="gi">+            token = self.fetch_token()</span>
<span class="gi">+            if token is None:</span>
<span class="gi">+                return tokens</span>
<span class="gi">+            tokens.append(token)</span>
<span class="gi">+            if token == &#39;(&#39;:</span>
<span class="gi">+                depth += 1</span>
<span class="gi">+            elif token == &#39;)&#39;:</span>
<span class="gi">+                depth -= 1</span>
<span class="gi">+            elif depth == 0 and token == condition:</span>
<span class="gi">+                return tokens</span>


<span class="w"> </span>class AfterCommentParser(TokenProcessor):
<span class="gh">diff --git a/sphinx/registry.py b/sphinx/registry.py</span>
<span class="gh">index dac389ea8..85a88c86b 100644</span>
<span class="gd">--- a/sphinx/registry.py</span>
<span class="gi">+++ b/sphinx/registry.py</span>
<span class="gu">@@ -69,9 +69,26 @@ class SphinxComponentRegistry:</span>

<span class="w"> </span>    def load_extension(self, app: Sphinx, extname: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Load a Sphinx extension.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            module = import_module(extname)</span>
<span class="gi">+            setup_func = getattr(module, &#39;setup&#39;, None)</span>
<span class="gi">+            if setup_func is None:</span>
<span class="gi">+                raise ExtensionError(f&quot;Extension {extname} has no setup() function&quot;)</span>
<span class="gi">+            </span>
<span class="gi">+            if callable(setup_func):</span>
<span class="gi">+                setup_func(app)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ExtensionError(f&quot;Extension {extname}&#39;s setup() function is not callable&quot;)</span>
<span class="gi">+            </span>
<span class="gi">+            app.extensions[extname] = Extension(extname, module.__file__)</span>
<span class="gi">+        except ImportError as exc:</span>
<span class="gi">+            raise ExtensionError(f&quot;Could not import extension {extname}&quot;, exc) from exc</span>
<span class="gi">+        except Exception as exc:</span>
<span class="gi">+            raise ExtensionError(f&quot;Error occurred while setting up extension {extname}&quot;, exc) from exc</span>


<span class="w"> </span>def merge_source_suffix(app: Sphinx, config: Config) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Merge any user-specified source_suffix with any added by extensions.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for suffix, filetype in app.registry.source_suffix.items():</span>
<span class="gi">+        if suffix not in config.source_suffix:</span>
<span class="gi">+            config.source_suffix[suffix] = filetype</span>
<span class="gh">diff --git a/sphinx/roles.py b/sphinx/roles.py</span>
<span class="gh">index 8173b137a..50ddde675 100644</span>
<span class="gd">--- a/sphinx/roles.py</span>
<span class="gi">+++ b/sphinx/roles.py</span>
<span class="gu">@@ -68,7 +68,16 @@ class XRefRole(ReferenceRole):</span>
<span class="w"> </span>        reference node and must return a new (or the same) ``(title, target)``
<span class="w"> </span>        tuple.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.fix_parens:</span>
<span class="gi">+            if not has_explicit_title:</span>
<span class="gi">+                title = utils.unescape(title)</span>
<span class="gi">+            if target.endswith(&#39;()&#39;):</span>
<span class="gi">+                target = target[:-2]</span>
<span class="gi">+            if not has_explicit_title:</span>
<span class="gi">+                title += &#39;()&#39;</span>
<span class="gi">+        if self.lowercase:</span>
<span class="gi">+            target = target.lower()</span>
<span class="gi">+        return title, target</span>

<span class="w"> </span>    def result_nodes(self, document: nodes.document, env: BuildEnvironment,
<span class="w"> </span>        node: Element, is_ref: bool) -&gt;tuple[list[Node], list[system_message]]:
<span class="gu">@@ -77,7 +86,7 @@ class XRefRole(ReferenceRole):</span>
<span class="w"> </span>        This method can add other nodes and must return a ``(nodes, messages)``
<span class="w"> </span>        tuple (the usual return value of a role function).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [node], []</span>


<span class="w"> </span>class AnyXRefRole(XRefRole):
<span class="gh">diff --git a/sphinx/search/ja.py b/sphinx/search/ja.py</span>
<span class="gh">index 703d7260b..d9001fc49 100644</span>
<span class="gd">--- a/sphinx/search/ja.py</span>
<span class="gi">+++ b/sphinx/search/ja.py</span>
<span class="gu">@@ -49,6 +49,53 @@ class MecabSplitter(BaseSplitter):</span>
<span class="w"> </span>        if self.ctypes_libmecab:
<span class="w"> </span>            self.ctypes_libmecab.mecab_destroy(self.ctypes_mecab)

<span class="gi">+    def init_native(self, options):</span>
<span class="gi">+        self.mecab = MeCab.Tagger(options.get(&#39;mecab_args&#39;, &#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def init_ctypes(self, options):</span>
<span class="gi">+        import ctypes</span>
<span class="gi">+        import ctypes.util</span>
<span class="gi">+</span>
<span class="gi">+        libmecab = ctypes.util.find_library(&#39;mecab&#39;)</span>
<span class="gi">+        if libmecab is None:</span>
<span class="gi">+            raise RuntimeError(&#39;libmecab not found&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        self.ctypes_libmecab = ctypes.CDLL(libmecab)</span>
<span class="gi">+        self.ctypes_libmecab.mecab_new.restype = ctypes.c_void_p</span>
<span class="gi">+        self.ctypes_libmecab.mecab_new.argtypes = (ctypes.c_int, ctypes.POINTER(ctypes.c_char_p))</span>
<span class="gi">+        self.ctypes_libmecab.mecab_sparse_tostr.restype = ctypes.c_char_p</span>
<span class="gi">+        self.ctypes_libmecab.mecab_sparse_tostr.argtypes = (ctypes.c_void_p, ctypes.c_char_p)</span>
<span class="gi">+        self.ctypes_libmecab.mecab_destroy.argtypes = (ctypes.c_void_p,)</span>
<span class="gi">+</span>
<span class="gi">+        mecab_args = options.get(&#39;mecab_args&#39;, &#39;&#39;).encode(&#39;utf-8&#39;)</span>
<span class="gi">+        argc = 1</span>
<span class="gi">+        argv = (ctypes.c_char_p * 2)(b&#39;mecab&#39;, mecab_args)</span>
<span class="gi">+        self.ctypes_mecab = self.ctypes_libmecab.mecab_new(argc, argv)</span>
<span class="gi">+        if self.ctypes_mecab is None:</span>
<span class="gi">+            raise RuntimeError(&#39;mecab_new failed&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def split(self, input: str) -&gt;list[str]:</span>
<span class="gi">+        if native_module:</span>
<span class="gi">+            return self.split_native(input)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.split_ctypes(input)</span>
<span class="gi">+</span>
<span class="gi">+    def split_native(self, input: str) -&gt;list[str]:</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for node in self.mecab.parse(input).split(&#39;\n&#39;):</span>
<span class="gi">+            if node == &#39;EOS&#39;:</span>
<span class="gi">+                break</span>
<span class="gi">+            surface = node.split(&#39;\t&#39;)[0]</span>
<span class="gi">+            if surface:</span>
<span class="gi">+                result.append(surface)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def split_ctypes(self, input: str) -&gt;list[str]:</span>
<span class="gi">+        input_bytes = input.encode(self.dict_encode)</span>
<span class="gi">+        result_bytes = self.ctypes_libmecab.mecab_sparse_tostr(self.ctypes_mecab, input_bytes)</span>
<span class="gi">+        result_string = result_bytes.decode(self.dict_encode)</span>
<span class="gi">+        return [line.split(&#39;\t&#39;)[0] for line in result_string.splitlines() if line != &#39;EOS&#39;]</span>
<span class="gi">+</span>

<span class="w"> </span>class JanomeSplitter(BaseSplitter):

<span class="gu">@@ -58,6 +105,14 @@ class JanomeSplitter(BaseSplitter):</span>
<span class="w"> </span>        self.user_dict_enc = options.get(&#39;user_dic_enc&#39;, &#39;utf8&#39;)
<span class="w"> </span>        self.init_tokenizer()

<span class="gi">+    def init_tokenizer(self):</span>
<span class="gi">+        if not janome_module:</span>
<span class="gi">+            raise ImportError(&#39;Janome is not installed&#39;)</span>
<span class="gi">+        self.tokenizer = janome.tokenizer.Tokenizer(udic=self.user_dict, udic_enc=self.user_dict_enc)</span>
<span class="gi">+</span>
<span class="gi">+    def split(self, input: str) -&gt;list[str]:</span>
<span class="gi">+        return [token.surface for token in self.tokenizer.tokenize(input)]</span>
<span class="gi">+</span>

<span class="w"> </span>class DefaultSplitter(BaseSplitter):
<span class="w"> </span>    patterns_ = {re.compile(pattern): value for pattern, value in {
<span class="gu">@@ -330,3 +385,16 @@ class SearchJapanese(SearchLanguage):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    lang = &#39;ja&#39;
<span class="w"> </span>    language_name = &#39;Japanese&#39;
<span class="gi">+</span>
<span class="gi">+    def __init__(self, options):</span>
<span class="gi">+        super().__init__(options)</span>
<span class="gi">+        self.splitter = DefaultSplitter(options)</span>
<span class="gi">+</span>
<span class="gi">+    def split(self, input):</span>
<span class="gi">+        return self.splitter.split(input)</span>
<span class="gi">+</span>
<span class="gi">+    def word_filter(self, stemmed_word):</span>
<span class="gi">+        return len(stemmed_word) &gt; 1</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word):</span>
<span class="gi">+        return word</span>
<span class="gh">diff --git a/sphinx/testing/fixtures.py b/sphinx/testing/fixtures.py</span>
<span class="gh">index 354a465af..7ab094149 100644</span>
<span class="gd">--- a/sphinx/testing/fixtures.py</span>
<span class="gi">+++ b/sphinx/testing/fixtures.py</span>
<span class="gu">@@ -19,7 +19,8 @@ DEFAULT_ENABLED_MARKERS = [</span>

<span class="w"> </span>def pytest_configure(config: pytest.Config) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Register custom markers&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for marker in DEFAULT_ENABLED_MARKERS:</span>
<span class="gi">+        config.addinivalue_line(&#39;markers&#39;, marker)</span>


<span class="w"> </span>class SharedResult:
<span class="gu">@@ -33,7 +34,18 @@ def app_params(request: Any, test_params: dict[str, Any], shared_result:</span>
<span class="w"> </span>    Parameters that are specified by &#39;pytest.mark.sphinx&#39; for
<span class="w"> </span>    sphinx.application.Sphinx initialization
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    markers = request.node.iter_markers(&#39;sphinx&#39;)</span>
<span class="gi">+    pargs = {}</span>
<span class="gi">+    kwargs = {}</span>
<span class="gi">+</span>
<span class="gi">+    if markers:</span>
<span class="gi">+        # use last args if multiple &#39;sphinx&#39; markers are specified</span>
<span class="gi">+        args, kwargs = list(markers)[-1].args, list(markers)[-1].kwargs</span>
<span class="gi">+</span>
<span class="gi">+    kwargs.setdefault(&#39;srcdir&#39;, sphinx_test_tempdir)</span>
<span class="gi">+    kwargs.setdefault(&#39;builddir&#39;, os.path.join(sphinx_test_tempdir, &#39;_build&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    return _app_params(args, kwargs)</span>


<span class="w"> </span>_app_params = namedtuple(&#39;_app_params&#39;, &#39;args,kwargs&#39;)
<span class="gu">@@ -50,7 +62,10 @@ def test_params(request: Any) -&gt;dict[str, Any]:</span>
<span class="w"> </span>       have same &#39;shared_result&#39; value.
<span class="w"> </span>       **NOTE**: You can not specify both shared_result and srcdir.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    markers = request.node.iter_markers(&#39;test_params&#39;)</span>
<span class="gi">+    if markers:</span>
<span class="gi">+        return list(markers)[-1].kwargs</span>
<span class="gi">+    return {}</span>


<span class="w"> </span>@pytest.fixture
<span class="gu">@@ -60,7 +75,9 @@ def app(test_params: dict[str, Any], app_params: _app_params, make_app:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Provides the &#39;sphinx.application.Sphinx&#39; object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app = make_app()</span>
<span class="gi">+    yield app</span>
<span class="gi">+    app.cleanup()</span>


<span class="w"> </span>@pytest.fixture
<span class="gu">@@ -68,7 +85,7 @@ def status(app: SphinxTestApp) -&gt;StringIO:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Back-compatibility for testing with previous @with_app decorator
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return app._status</span>


<span class="w"> </span>@pytest.fixture
<span class="gu">@@ -76,7 +93,7 @@ def warning(app: SphinxTestApp) -&gt;StringIO:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Back-compatibility for testing with previous @with_app decorator
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return app._warning</span>


<span class="w"> </span>@pytest.fixture
<span class="gu">@@ -87,7 +104,10 @@ def make_app(test_params: dict[str, Any]) -&gt;Iterator[Callable[[],</span>
<span class="w"> </span>    if you want to initialize &#39;app&#39; in your test function. please use this
<span class="w"> </span>    instead of using SphinxTestApp class directory.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def _make_app():</span>
<span class="gi">+        app = SphinxTestApp(**test_params)</span>
<span class="gi">+        return app</span>
<span class="gi">+    yield _make_app</span>


<span class="w"> </span>@pytest.fixture
<span class="gu">@@ -96,13 +116,14 @@ def if_graphviz_found(app: SphinxTestApp) -&gt;None:</span>
<span class="w"> </span>    The test will be skipped when using &#39;if_graphviz_found&#39; fixture and graphviz
<span class="w"> </span>    dot command is not found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if shutil.which(&#39;dot&#39;) is None:</span>
<span class="gi">+        pytest.skip(&#39;graphviz &quot;dot&quot; command is not available&#39;)</span>


<span class="w"> </span>@pytest.fixture(scope=&#39;session&#39;)
<span class="w"> </span>def sphinx_test_tempdir(tmp_path_factory: pytest.TempPathFactory) -&gt;Path:
<span class="w"> </span>    &quot;&quot;&quot;Temporary directory.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return tmp_path_factory.getbasetemp() / &quot;sphinx-test&quot;</span>


<span class="w"> </span>@pytest.fixture
<span class="gu">@@ -114,4 +135,7 @@ def rollback_sysmodules() -&gt;Iterator[None]:</span>
<span class="w"> </span>    For example, used in test_ext_autosummary.py to permit unloading the
<span class="w"> </span>    target module to clear its cache.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    modules = sys.modules.copy()</span>
<span class="gi">+    yield</span>
<span class="gi">+    sys.modules.clear()</span>
<span class="gi">+    sys.modules.update(modules)</span>
<span class="gh">diff --git a/sphinx/testing/path.py b/sphinx/testing/path.py</span>
<span class="gh">index 6aa6b7bf7..f26454965 100644</span>
<span class="gd">--- a/sphinx/testing/path.py</span>
<span class="gi">+++ b/sphinx/testing/path.py</span>
<span class="gu">@@ -16,7 +16,7 @@ FILESYSTEMENCODING = sys.getfilesystemencoding() or sys.getdefaultencoding()</span>

<span class="w"> </span>def getumask() -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Get current umask value&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return os.umask(0)</span>


<span class="w"> </span>UMASK = getumask()
<span class="gu">@@ -33,43 +33,43 @@ class path(str):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The name of the directory the file or directory is in.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return path(os.path.dirname(self))</span>

<span class="w"> </span>    def abspath(self) -&gt;path:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns the absolute path.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return path(os.path.abspath(self))</span>

<span class="w"> </span>    def isabs(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns ``True`` if the path is absolute.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.path.isabs(self)</span>

<span class="w"> </span>    def isdir(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns ``True`` if the path is a directory.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.path.isdir(self)</span>

<span class="w"> </span>    def isfile(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns ``True`` if the path is a file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.path.isfile(self)</span>

<span class="w"> </span>    def islink(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns ``True`` if the path is a symbolic link.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.path.islink(self)</span>

<span class="w"> </span>    def ismount(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns ``True`` if the path is a mount point.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.path.ismount(self)</span>

<span class="w"> </span>    def rmtree(self, ignore_errors: bool=False, onerror: (Callable[[
<span class="w"> </span>        Callable[..., Any], str, Any], object] | None)=None) -&gt;None:
<span class="gu">@@ -88,7 +88,7 @@ class path(str):</span>
<span class="w"> </span>            caused it to fail and `exc_info` is a tuple as returned by
<span class="w"> </span>            :func:`sys.exc_info`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        shutil.rmtree(self, ignore_errors=ignore_errors, onerror=onerror)</span>

<span class="w"> </span>    def copytree(self, destination: str, symlinks: bool=False) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -100,7 +100,7 @@ class path(str):</span>
<span class="w"> </span>            links in the destination tree otherwise the contents of the files
<span class="w"> </span>            pointed to by the symbolic links are copied.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        shutil.copytree(self, destination, symlinks=symlinks)</span>

<span class="w"> </span>    def movetree(self, destination: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -110,39 +110,42 @@ class path(str):</span>
<span class="w"> </span>        If the `destination` is a file it may be overwritten depending on the
<span class="w"> </span>        :func:`os.rename` semantics.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        shutil.move(self, destination)</span>
<span class="w"> </span>    move = movetree

<span class="w"> </span>    def unlink(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Removes a file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        os.unlink(self)</span>

<span class="w"> </span>    def stat(self) -&gt;Any:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns a stat of the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.stat(self)</span>

<span class="w"> </span>    def write_text(self, text: str, encoding: str=&#39;utf-8&#39;, **kwargs: Any
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Writes the given `text` to the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(self, &#39;w&#39;, encoding=encoding, **kwargs) as f:</span>
<span class="gi">+            f.write(text)</span>

<span class="w"> </span>    def read_text(self, encoding: str=&#39;utf-8&#39;, **kwargs: Any) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns the text in the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(self, &#39;r&#39;, encoding=encoding, **kwargs) as f:</span>
<span class="gi">+            return f.read()</span>

<span class="w"> </span>    def read_bytes(self) -&gt;builtins.bytes:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns the bytes in the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(self, &#39;rb&#39;) as f:</span>
<span class="gi">+            return f.read()</span>

<span class="w"> </span>    def write_bytes(self, bytes: bytes, append: bool=False) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -151,32 +154,34 @@ class path(str):</span>
<span class="w"> </span>        :param append:
<span class="w"> </span>            If ``True`` given `bytes` are added at the end of the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mode = &#39;ab&#39; if append else &#39;wb&#39;</span>
<span class="gi">+        with open(self, mode) as f:</span>
<span class="gi">+            f.write(bytes)</span>

<span class="w"> </span>    def exists(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns ``True`` if the path exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.path.exists(self)</span>

<span class="w"> </span>    def lexists(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns ``True`` if the path exists unless it is a broken symbolic
<span class="w"> </span>        link.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.path.lexists(self)</span>

<span class="w"> </span>    def makedirs(self, mode: int=511, exist_ok: bool=False) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Recursively create directories.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        os.makedirs(self, mode=mode, exist_ok=exist_ok)</span>

<span class="w"> </span>    def joinpath(self, *args: Any) -&gt;path:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Joins the path with the argument given and returns the result.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return path(os.path.join(self, *args))</span>
<span class="w"> </span>    __div__ = __truediv__ = joinpath

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="gh">diff --git a/sphinx/testing/restructuredtext.py b/sphinx/testing/restructuredtext.py</span>
<span class="gh">index f8e53bc18..19f7ecbdb 100644</span>
<span class="gd">--- a/sphinx/testing/restructuredtext.py</span>
<span class="gi">+++ b/sphinx/testing/restructuredtext.py</span>
<span class="gu">@@ -9,4 +9,21 @@ from sphinx.util.docutils import sphinx_domains</span>

<span class="w"> </span>def parse(app: Sphinx, text: str, docname: str=&#39;index&#39;) -&gt;nodes.document:
<span class="w"> </span>    &quot;&quot;&quot;Parse a string as reStructuredText with Sphinx application.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    reader = SphinxStandaloneReader()</span>
<span class="gi">+    parser = RSTParser()</span>
<span class="gi">+    parser.set_application(app)</span>
<span class="gi">+    </span>
<span class="gi">+    settings = app.env.settings.copy()</span>
<span class="gi">+    settings[&#39;initial_header_level&#39;] = 1</span>
<span class="gi">+    settings[&#39;docname&#39;] = docname</span>
<span class="gi">+    </span>
<span class="gi">+    with sphinx_domains(app.env):</span>
<span class="gi">+        document = publish_doctree(</span>
<span class="gi">+            source=text,</span>
<span class="gi">+            source_path=path.join(app.srcdir, docname + &#39;.rst&#39;),</span>
<span class="gi">+            reader=reader,</span>
<span class="gi">+            parser=parser,</span>
<span class="gi">+            settings_overrides=settings,</span>
<span class="gi">+        )</span>
<span class="gi">+    </span>
<span class="gi">+    return document</span>
<span class="gh">diff --git a/sphinx/testing/util.py b/sphinx/testing/util.py</span>
<span class="gh">index 6b9e7daa2..0f8542855 100644</span>
<span class="gd">--- a/sphinx/testing/util.py</span>
<span class="gi">+++ b/sphinx/testing/util.py</span>
<span class="gu">@@ -24,7 +24,9 @@ if TYPE_CHECKING:</span>

<span class="w"> </span>def etree_parse(path: (str | os.PathLike[str])) -&gt;ElementTree:
<span class="w"> </span>    &quot;&quot;&quot;Parse a file into a (safe) XML element tree.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from xml.etree import ElementTree as ET</span>
<span class="gi">+    parser = ET.XMLParser(resolve_entities=False)</span>
<span class="gi">+    return ET.parse(path, parser=parser)</span>


<span class="w"> </span>class SphinxTestApp(sphinx.application.Sphinx):
<span class="gu">@@ -102,12 +104,12 @@ class SphinxTestApp(sphinx.application.Sphinx):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def status(self) -&gt;StringIO:
<span class="w"> </span>        &quot;&quot;&quot;The in-memory text I/O for the application status messages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._status</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def warning(self) -&gt;StringIO:
<span class="w"> </span>        &quot;&quot;&quot;The in-memory text I/O for the application warning messages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._warning</span>

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        return f&#39;&lt;{self.__class__.__name__} buildername={self.builder.name!r}&gt;&#39;
<span class="gh">diff --git a/sphinx/texinputs/sphinxlatextables.sty b/sphinx/texinputs/sphinxlatextables.sty</span>
<span class="gh">index 4114955e0..f52692fc7 100644</span>
<span class="gd">--- a/sphinx/texinputs/sphinxlatextables.sty</span>
<span class="gi">+++ b/sphinx/texinputs/sphinxlatextables.sty</span>
<span class="gu">@@ -412,12 +412,50 @@</span>
<span class="w"> </span>   \fi
<span class="w"> </span>  \fi
<span class="w"> </span>}%
<span class="gi">+</span>
<span class="gi">+% Implementation of is_longtable()</span>
<span class="gi">+\def\is@longtable{%</span>
<span class="gi">+  \ifx\longtable\undefined</span>
<span class="gi">+    \@false</span>
<span class="gi">+  \else</span>
<span class="gi">+    \ifx\sphinxtablecolumns\undefined</span>
<span class="gi">+      \@false</span>
<span class="gi">+    \else</span>
<span class="gi">+      \ifnum\sphinxtablecolumns&gt;\z@</span>
<span class="gi">+        \@true</span>
<span class="gi">+      \else</span>
<span class="gi">+        \@false</span>
<span class="gi">+      \fi</span>
<span class="gi">+    \fi</span>
<span class="gi">+  \fi</span>
<span class="gi">+}</span>
<span class="w"> </span>% fallback default in case user has set latex_use_latex_multicolumn to True:
<span class="w"> </span>% \sphinxcolwidth will use this only inside LaTeX&#39;s standard \multicolumn
<span class="w"> </span>\def\sphinx@multiwidth #1#2{\dimexpr % #1 to gobble the \@gobble (!)
<span class="w"> </span>    (\ifx\TY@final\@undefined\linewidth\else\sphinx@TY@tablewidth\fi
<span class="w"> </span>     -\spx@arrayrulewidth)*#2-\tw@\tabcolsep-\spx@arrayrulewidth\relax}%

<span class="gi">+% Implementation of get_table_type()</span>
<span class="gi">+\def\get@table@type{%</span>
<span class="gi">+  \ifx\longtable\undefined</span>
<span class="gi">+    \ifx\tabulary\undefined</span>
<span class="gi">+      tabular%</span>
<span class="gi">+    \else</span>
<span class="gi">+      tabulary%</span>
<span class="gi">+    \fi</span>
<span class="gi">+  \else</span>
<span class="gi">+    \ifnum\sphinxtablecolumns&gt;\z@</span>
<span class="gi">+      longtable%</span>
<span class="gi">+    \else</span>
<span class="gi">+      \ifx\tabulary\undefined</span>
<span class="gi">+        tabular%</span>
<span class="gi">+      \else</span>
<span class="gi">+        tabulary%</span>
<span class="gi">+      \fi</span>
<span class="gi">+    \fi</span>
<span class="gi">+  \fi</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="w"> </span>% \spx@table@hackCT@inhibitvline
<span class="w"> </span>% packages like colortbl add group levels, we need to &quot;climb back up&quot; to be
<span class="w"> </span>% able to hack the \vline and also the colortbl inserted tokens.  The hack
<span class="gu">@@ -455,6 +493,19 @@</span>
<span class="w"> </span>    % hence also \spx@arrayrulewidth...
<span class="w"> </span>         {\sphinxcolorpanelextraoverhang+\the\spx@arrayrulewidth}%
<span class="w"> </span>    \else\aftergroup\spx@table@hackCT@fixcolorpanel\fi}%
<span class="gi">+</span>
<span class="gi">+% Implementation of get_colspec()</span>
<span class="gi">+\def\get@colspec{%</span>
<span class="gi">+  \ifx\sphinxtablecolspec\undefined</span>
<span class="gi">+    \ifx\sphinxtablecolwidths\undefined</span>
<span class="gi">+      l% Default to left-aligned if no column spec is provided</span>
<span class="gi">+    \else</span>
<span class="gi">+      \sphinxtablecolwidths</span>
<span class="gi">+    \fi</span>
<span class="gi">+  \else</span>
<span class="gi">+    \sphinxtablecolspec</span>
<span class="gi">+  \fi</span>
<span class="gi">+}</span>
<span class="w"> </span>%
<span class="w"> </span>% inmergedcell
<span class="w"> </span>% \spx@table@hackCT@inmergedcell will be locally set to either this
<span class="gu">@@ -1200,6 +1251,25 @@ local use of booktabs table style}%</span>
<span class="w"> </span>% header row colours are fixed, not alternating, so there is at least no
<span class="w"> </span>% coherence issue there.

<span class="gi">+% Implementation of add_cell()</span>
<span class="gi">+\def\add@cell#1#2{%</span>
<span class="gi">+  \global\advance\sphinxtablecellid by 1\relax</span>
<span class="gi">+  \count@=#1\relax</span>
<span class="gi">+  \@whilenum\count@&gt;\z@\do{%</span>
<span class="gi">+    \advance\count@\m@ne</span>
<span class="gi">+    \count@@=#2\relax</span>
<span class="gi">+    \@whilenum\count@@&gt;\z@\do{%</span>
<span class="gi">+      \advance\count@@\m@ne</span>
<span class="gi">+      \expandafter\gdef\csname sphinxtablecell@\the\sphinxtablerow @\the\sphinxtablecol\endcsname{\the\sphinxtablecellid}%</span>
<span class="gi">+      \global\advance\sphinxtablecol by 1\relax</span>
<span class="gi">+    }%</span>
<span class="gi">+    \global\sphinxtablecol=\sphinxtablestartcol\relax</span>
<span class="gi">+    \global\advance\sphinxtablerow by 1\relax</span>
<span class="gi">+  }%</span>
<span class="gi">+  \global\sphinxtablerow=\sphinxtablestartrow\relax</span>
<span class="gi">+  \global\advance\sphinxtablecol by #2\relax</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="w"> </span>% The \spx@arrayrulewidth is used for some complex matters of merged
<span class="w"> </span>% cells size computations.
<span class="w"> </span>% tabularcolumns argument will override any global or local style and
<span class="gu">@@ -1237,5 +1307,23 @@ local use of booktabs table style}%</span>
<span class="w"> </span>    }
<span class="w"> </span>\fi

<span class="gi">+% Implementation of cell()</span>
<span class="gi">+\def\get@cell#1#2{%</span>
<span class="gi">+  \ifx#1\relax</span>
<span class="gi">+    \def\sphinxtablecurrentrow{\the\sphinxtablerow}%</span>
<span class="gi">+  \else</span>
<span class="gi">+    \def\sphinxtablecurrentrow{#1}%</span>
<span class="gi">+  \fi</span>
<span class="gi">+  \ifx#2\relax</span>
<span class="gi">+    \def\sphinxtablecurrentcol{\the\sphinxtablecol}%</span>
<span class="gi">+  \else</span>
<span class="gi">+    \def\sphinxtablecurrentcol{#2}%</span>
<span class="gi">+  \fi</span>
<span class="gi">+  \expandafter\ifx\csname sphinxtablecell@\sphinxtablecurrentrow @\sphinxtablecurrentcol\endcsname\relax</span>
<span class="gi">+    \PackageError{sphinxlatextables}{Cell (\sphinxtablecurrentrow,\sphinxtablecurrentcol) does not exist}{}%</span>
<span class="gi">+  \else</span>
<span class="gi">+    \csname sphinxtablecell@\sphinxtablecurrentrow @\sphinxtablecurrentcol\endcsname</span>
<span class="gi">+  \fi</span>
<span class="gi">+}</span>

<span class="w"> </span>\endinput
<span class="gh">diff --git a/sphinx/theming.py b/sphinx/theming.py</span>
<span class="gh">index 43bb6bd9b..969ccd265 100644</span>
<span class="gd">--- a/sphinx/theming.py</span>
<span class="gi">+++ b/sphinx/theming.py</span>
<span class="gu">@@ -81,23 +81,32 @@ class Theme:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of theme directories, beginning with this theme&#39;s,
<span class="w"> </span>        then the base theme&#39;s, then that one&#39;s base theme&#39;s, etc.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return list(self._dirs)</span>

<span class="w"> </span>    def get_config(self, section: str, name: str, default: Any=_NO_DEFAULT
<span class="w"> </span>        ) -&gt;Any:
<span class="w"> </span>        &quot;&quot;&quot;Return the value for a theme configuration setting, searching the
<span class="w"> </span>        base theme chain.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if section == &#39;theme&#39; and name in self._options:</span>
<span class="gi">+            return self._options[name]</span>
<span class="gi">+        if default is _NO_DEFAULT:</span>
<span class="gi">+            raise ThemeError(f&#39;setting not found: {section}.{name}&#39;)</span>
<span class="gi">+        return default</span>

<span class="w"> </span>    def get_options(self, overrides: (dict[str, Any] | None)=None) -&gt;dict[
<span class="w"> </span>        str, Any]:
<span class="w"> </span>        &quot;&quot;&quot;Return a dictionary of theme options and their values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        options = self._options.copy()</span>
<span class="gi">+        if overrides:</span>
<span class="gi">+            options.update(overrides)</span>
<span class="gi">+        return options</span>

<span class="w"> </span>    def _cleanup(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Remove temporary directories.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for tmp_dir in self._tmp_dirs:</span>
<span class="gi">+            shutil.rmtree(tmp_dir, ignore_errors=True)</span>
<span class="gi">+        self._tmp_dirs.clear()</span>


<span class="w"> </span>class HTMLThemeFactory:
<span class="gu">@@ -114,37 +123,103 @@ class HTMLThemeFactory:</span>

<span class="w"> </span>    def _load_builtin_themes(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Load built-in themes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        themes = self._find_themes(path.join(package_dir, &#39;themes&#39;))</span>
<span class="gi">+        self._themes.update(themes)</span>

<span class="w"> </span>    def _load_additional_themes(self, theme_paths: list[str]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Load additional themes placed at specified directories.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for theme_path in theme_paths:</span>
<span class="gi">+            themes = self._find_themes(theme_path)</span>
<span class="gi">+            self._themes.update(themes)</span>

<span class="w"> </span>    def _load_entry_point_themes(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Try to load a theme with the specified name.

<span class="w"> </span>        This uses the ``sphinx.html_themes`` entry point from package metadata.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for entry_point in entry_points(group=&#39;sphinx.html_themes&#39;):</span>
<span class="gi">+            self._entry_point_themes[entry_point.name] = entry_point.load</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _find_themes(theme_path: str) -&gt;dict[str, str]:
<span class="w"> </span>        &quot;&quot;&quot;Search themes from specified directory.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        themes = {}</span>
<span class="gi">+        if not path.isdir(theme_path):</span>
<span class="gi">+            return themes</span>
<span class="gi">+</span>
<span class="gi">+        for entry in os.listdir(theme_path):</span>
<span class="gi">+            full_path = path.join(theme_path, entry)</span>
<span class="gi">+            if path.isdir(full_path):</span>
<span class="gi">+                if path.isfile(path.join(full_path, _THEME_CONF)) or path.isfile(path.join(full_path, _THEME_TOML)):</span>
<span class="gi">+                    themes[entry] = full_path</span>
<span class="gi">+            elif _is_archived_theme(full_path):</span>
<span class="gi">+                themes[entry[:-4]] = full_path  # remove &#39;.zip&#39; from name</span>
<span class="gi">+</span>
<span class="gi">+        return themes</span>

<span class="w"> </span>    def create(self, name: str) -&gt;Theme:
<span class="w"> </span>        &quot;&quot;&quot;Create an instance of theme.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name not in self._themes and name in self._entry_point_themes:</span>
<span class="gi">+            self._entry_point_themes[name]()</span>
<span class="gi">+</span>
<span class="gi">+        if name not in self._themes:</span>
<span class="gi">+            raise ThemeError(__(&#39;no theme named %r found&#39;) % name)</span>
<span class="gi">+</span>
<span class="gi">+        theme_path = self._themes[name]</span>
<span class="gi">+        configs = {}</span>
<span class="gi">+        tmp_dirs = []</span>
<span class="gi">+</span>
<span class="gi">+        if _is_archived_theme(theme_path):</span>
<span class="gi">+            tmp_dir = tempfile.mkdtemp()</span>
<span class="gi">+            _extract_zip(theme_path, tmp_dir)</span>
<span class="gi">+            theme_path = tmp_dir</span>
<span class="gi">+            tmp_dirs.append(tmp_dir)</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            config_file = path.join(theme_path, _THEME_TOML)</span>
<span class="gi">+            if path.exists(config_file):</span>
<span class="gi">+                config = self._load_theme_toml(config_file)</span>
<span class="gi">+            else:</span>
<span class="gi">+                config_file = path.join(theme_path, _THEME_CONF)</span>
<span class="gi">+                if not path.exists(config_file):</span>
<span class="gi">+                    break</span>
<span class="gi">+                config = self._load_theme_conf(config_file)</span>
<span class="gi">+</span>
<span class="gi">+            configs[theme_path] = config</span>
<span class="gi">+</span>
<span class="gi">+            parent = config.options.get(&#39;inherit&#39;)</span>
<span class="gi">+            if parent is None:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            theme_path = self._themes.get(parent)</span>
<span class="gi">+            if not theme_path:</span>
<span class="gi">+                raise ThemeError(__(&#39;no theme named %r found, inherited by %r&#39;) % (parent, name))</span>
<span class="gi">+</span>
<span class="gi">+            if _is_archived_theme(theme_path):</span>
<span class="gi">+                tmp_dir = tempfile.mkdtemp()</span>
<span class="gi">+                _extract_zip(theme_path, tmp_dir)</span>
<span class="gi">+                theme_path = tmp_dir</span>
<span class="gi">+                tmp_dirs.append(tmp_dir)</span>
<span class="gi">+</span>
<span class="gi">+        return Theme(name, configs=configs, paths=list(configs.keys()), tmp_dirs=tmp_dirs)</span>


<span class="w"> </span>def _is_archived_theme(filename: str, /) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check whether the specified file is an archived theme file or not.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return filename.endswith(&#39;.zip&#39;) and path.isfile(filename)</span>


<span class="w"> </span>def _extract_zip(filename: str, target_dir: str, /) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Extract zip file to target directory.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with ZipFile(filename) as archive:</span>
<span class="gi">+        for name in archive.namelist():</span>
<span class="gi">+            if name.endswith(&#39;/&#39;):</span>
<span class="gi">+                continue</span>
<span class="gi">+            # convert filename to system dependent path</span>
<span class="gi">+            target = path.join(target_dir, *name.split(&#39;/&#39;))</span>
<span class="gi">+            ensuredir(path.dirname(target))</span>
<span class="gi">+            with open(target, &#39;wb&#39;) as fp:</span>
<span class="gi">+                fp.write(archive.read(name))</span>


<span class="w"> </span>class _ConfigFile:
<span class="gh">diff --git a/sphinx/transforms/compact_bullet_list.py b/sphinx/transforms/compact_bullet_list.py</span>
<span class="gh">index 54ebc5311..744ffb98b 100644</span>
<span class="gd">--- a/sphinx/transforms/compact_bullet_list.py</span>
<span class="gi">+++ b/sphinx/transforms/compact_bullet_list.py</span>
<span class="gu">@@ -21,6 +21,20 @@ class RefOnlyListChecker(nodes.GenericNodeVisitor):</span>
<span class="w"> </span>        &quot;&quot;&quot;Invisible nodes should be ignored.&quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gi">+    def visit_paragraph(self, node: nodes.paragraph) -&gt; None:</span>
<span class="gi">+        if len(node.children) != 1 or not isinstance(node.children[0], nodes.reference):</span>
<span class="gi">+            raise nodes.NodeFound</span>
<span class="gi">+</span>
<span class="gi">+    def visit_bullet_list(self, node: nodes.bullet_list) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_list_item(self, node: nodes.list_item) -&gt; None:</span>
<span class="gi">+        if len(node.children) != 1 or not isinstance(node.children[0], nodes.paragraph):</span>
<span class="gi">+            raise nodes.NodeFound</span>
<span class="gi">+</span>
<span class="gi">+    def default_visit(self, node: Node) -&gt; None:</span>
<span class="gi">+        raise nodes.NodeFound</span>
<span class="gi">+</span>

<span class="w"> </span>class RefOnlyBulletListTransform(SphinxTransform):
<span class="w"> </span>    &quot;&quot;&quot;Change refonly bullet lists to use compact_paragraphs.
<span class="gu">@@ -29,3 +43,24 @@ class RefOnlyBulletListTransform(SphinxTransform):</span>
<span class="w"> </span>    odd when html_compact_lists is false.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    default_priority = 100
<span class="gi">+</span>
<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        checker = RefOnlyListChecker(self.document)</span>
<span class="gi">+        for node in self.document.traverse(nodes.bullet_list):</span>
<span class="gi">+            if not node.get(&#39;compact_bullet_list&#39;):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    node.walk(checker)</span>
<span class="gi">+                except nodes.NodeFound:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                for child in node.children:</span>
<span class="gi">+                    child[0].__class__ = addnodes.compact_paragraph</span>
<span class="gi">+                node[&#39;compact_bullet_list&#39;] = True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_transform(RefOnlyBulletListTransform)</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;1.0&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/transforms/i18n.py b/sphinx/transforms/i18n.py</span>
<span class="gh">index 7d4cc25e7..d90d2357e 100644</span>
<span class="gd">--- a/sphinx/transforms/i18n.py</span>
<span class="gi">+++ b/sphinx/transforms/i18n.py</span>
<span class="gu">@@ -40,7 +40,22 @@ def publish_msgstr(app: Sphinx, source: str, source_path: str, source_line:</span>
<span class="w"> </span>    :return: document
<span class="w"> </span>    :rtype: docutils.nodes.document
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from docutils.core import publish_doctree</span>
<span class="gi">+    </span>
<span class="gi">+    # Create a new document with the given source</span>
<span class="gi">+    document = publish_doctree(source=source,</span>
<span class="gi">+                               source_path=source_path,</span>
<span class="gi">+                               reader=None,</span>
<span class="gi">+                               parser=app.registry.create_source_parser(app, &#39;restructuredtext&#39;),</span>
<span class="gi">+                               settings_overrides=settings,</span>
<span class="gi">+                               config=config)</span>
<span class="gi">+    </span>
<span class="gi">+    # Set the source information</span>
<span class="gi">+    for node in document.traverse():</span>
<span class="gi">+        node.source = source_path</span>
<span class="gi">+        node.line = source_line</span>
<span class="gi">+    </span>
<span class="gi">+    return document</span>


<span class="w"> </span>class PreserveTranslatableMessages(SphinxTransform):
<span class="gu">@@ -63,7 +78,14 @@ class _NodeUpdater:</span>
<span class="w"> </span>    def compare_references(self, old_refs: Sequence[nodes.Element],
<span class="w"> </span>        new_refs: Sequence[nodes.Element], warning_msg: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Warn about mismatches between references in original and translated content.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(old_refs) != len(new_refs):</span>
<span class="gi">+            logger.warning(warning_msg, location=self.node)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for old, new in zip(old_refs, new_refs):</span>
<span class="gi">+            if old[&#39;reftype&#39;] != new[&#39;reftype&#39;] or old[&#39;reftarget&#39;] != new[&#39;reftarget&#39;]:</span>
<span class="gi">+                logger.warning(warning_msg, location=self.node)</span>
<span class="gi">+                return</span>


<span class="w"> </span>class Locale(SphinxTransform):
<span class="gh">diff --git a/sphinx/transforms/post_transforms/images.py b/sphinx/transforms/post_transforms/images.py</span>
<span class="gh">index 76d5727d2..480991b38 100644</span>
<span class="gd">--- a/sphinx/transforms/post_transforms/images.py</span>
<span class="gi">+++ b/sphinx/transforms/post_transforms/images.py</span>
<span class="gu">@@ -61,7 +61,14 @@ class ImageConverter(BaseImageConverter):</span>

<span class="w"> </span>    def is_available(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Return the image converter is available or not.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.available is None:</span>
<span class="gi">+            self.available = self._check_availability()</span>
<span class="gi">+        return self.available</span>
<span class="gi">+</span>
<span class="gi">+    def _check_availability(self) -&gt;bool:</span>
<span class="gi">+        &quot;&quot;&quot;Check if the converter is available.&quot;&quot;&quot;</span>
<span class="gi">+        # This method should be implemented by subclasses</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def convert(self, _from: str, _to: str) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Convert an image file to the expected format.
<span class="gu">@@ -69,4 +76,16 @@ class ImageConverter(BaseImageConverter):</span>
<span class="w"> </span>        *_from* is a path of the source image file, and *_to* is a path
<span class="w"> </span>        of the destination file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.is_available():</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        for source_ext, dest_ext in self.conversion_rules:</span>
<span class="gi">+            if _from.lower().endswith(source_ext) and _to.lower().endswith(dest_ext):</span>
<span class="gi">+                return self._do_convert(_from, _to)</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _do_convert(self, source: str, destination: str) -&gt;bool:</span>
<span class="gi">+        &quot;&quot;&quot;Perform the actual conversion.&quot;&quot;&quot;</span>
<span class="gi">+        # This method should be implemented by subclasses</span>
<span class="gi">+        return False</span>
<span class="gh">diff --git a/sphinx/util/_importer.py b/sphinx/util/_importer.py</span>
<span class="gh">index 6f88b541b..37b5c234e 100644</span>
<span class="gd">--- a/sphinx/util/_importer.py</span>
<span class="gi">+++ b/sphinx/util/_importer.py</span>
<span class="gu">@@ -6,4 +6,15 @@ from sphinx.errors import ExtensionError</span>

<span class="w"> </span>def import_object(object_name: str, /, source: str=&#39;&#39;) -&gt;Any:
<span class="w"> </span>    &quot;&quot;&quot;Import python object by qualname.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        module_name, object_name = object_name.rsplit(&#39;.&#39;, 1)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise ExtensionError(f&quot;Invalid object name: {object_name}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        module = import_module(module_name)</span>
<span class="gi">+        return getattr(module, object_name)</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        raise ExtensionError(f&quot;Could not import {module_name}&quot;)</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        raise ExtensionError(f&quot;Could not find {object_name} in {module_name}&quot;)</span>
<span class="gh">diff --git a/sphinx/util/_io.py b/sphinx/util/_io.py</span>
<span class="gh">index 47a4e10e9..920f70f91 100644</span>
<span class="gd">--- a/sphinx/util/_io.py</span>
<span class="gi">+++ b/sphinx/util/_io.py</span>
<span class="gu">@@ -16,3 +16,13 @@ class TeeStripANSI:</span>
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        self.stream_term = stream_term
<span class="w"> </span>        self.stream_file = stream_file
<span class="gi">+</span>
<span class="gi">+    def write(self, text: str) -&gt;None:</span>
<span class="gi">+        self.stream_term.write(text)</span>
<span class="gi">+        self.stream_file.write(strip_escape_sequences(text))</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self) -&gt;None:</span>
<span class="gi">+        if hasattr(self.stream_term, &#39;flush&#39;):</span>
<span class="gi">+            self.stream_term.flush()</span>
<span class="gi">+        if hasattr(self.stream_file, &#39;flush&#39;):</span>
<span class="gi">+            self.stream_file.flush()</span>
<span class="gh">diff --git a/sphinx/util/_timestamps.py b/sphinx/util/_timestamps.py</span>
<span class="gh">index 9804211d8..720ec32f1 100644</span>
<span class="gd">--- a/sphinx/util/_timestamps.py</span>
<span class="gi">+++ b/sphinx/util/_timestamps.py</span>
<span class="gu">@@ -7,4 +7,7 @@ def _format_rfc3339_microseconds(timestamp: int, /) -&gt;str:</span>

<span class="w"> </span>    :param timestamp: The timestamp to format, in microseconds.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    seconds, microseconds = divmod(timestamp, 1_000_000)</span>
<span class="gi">+    dt = time.gmtime(seconds)</span>
<span class="gi">+    return (f&quot;{dt.tm_year:04d}-{dt.tm_mon:02d}-{dt.tm_mday:02d}T&quot;</span>
<span class="gi">+            f&quot;{dt.tm_hour:02d}:{dt.tm_min:02d}:{dt.tm_sec:02d}.{microseconds:06d}Z&quot;)</span>
<span class="gh">diff --git a/sphinx/util/console.py b/sphinx/util/console.py</span>
<span class="gh">index 1da057880..7510138ae 100644</span>
<span class="gd">--- a/sphinx/util/console.py</span>
<span class="gi">+++ b/sphinx/util/console.py</span>
<span class="gu">@@ -32,12 +32,15 @@ codes: dict[str, str] = {}</span>

<span class="w"> </span>def terminal_safe(s: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Safely encode a string for printing to the terminal.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return s.encode(&#39;ascii&#39;, &#39;replace&#39;).decode(&#39;ascii&#39;)</span>


<span class="w"> </span>def get_terminal_width() -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Return the width of the terminal in columns.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return shutil.get_terminal_size().columns</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        return 80  # fallback value</span>


<span class="w"> </span>_tw: int = get_terminal_width()
<span class="gu">@@ -53,7 +56,7 @@ def strip_colors(s: str) -&gt;str:</span>

<span class="w"> </span>    .. seealso:: :func:`strip_escape_sequences`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _ansi_color_re.sub(&#39;&#39;, s)</span>


<span class="w"> </span>def strip_escape_sequences(text: str, /) -&gt;str:
<span class="gu">@@ -76,7 +79,7 @@ def strip_escape_sequences(text: str, /) -&gt;str:</span>

<span class="w"> </span>    __ https://en.wikipedia.org/wiki/ANSI_escape_code
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _ansi_re.sub(&#39;&#39;, text)</span>


<span class="w"> </span>_attrs = {&#39;reset&#39;: &#39;39;49;00m&#39;, &#39;bold&#39;: &#39;01m&#39;, &#39;faint&#39;: &#39;02m&#39;, &#39;standout&#39;:
<span class="gh">diff --git a/sphinx/util/docfields.py b/sphinx/util/docfields.py</span>
<span class="gh">index 71ce35c34..92ba41fae 100644</span>
<span class="gd">--- a/sphinx/util/docfields.py</span>
<span class="gi">+++ b/sphinx/util/docfields.py</span>
<span class="gu">@@ -22,7 +22,12 @@ logger = logging.getLogger(__name__)</span>

<span class="w"> </span>def _is_single_paragraph(node: nodes.field_body) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;True if the node only contains one paragraph (and system messages).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        len(node.children) == 1 and</span>
<span class="gi">+        isinstance(node.children[0], nodes.paragraph) or</span>
<span class="gi">+        (len(node.children) == 0 and all(isinstance(child, nodes.system_message)</span>
<span class="gi">+                                         for child in node.children))</span>
<span class="gi">+    )</span>


<span class="w"> </span>class Field:
<span class="gu">@@ -115,8 +120,54 @@ class DocFieldTransformer:</span>

<span class="w"> </span>    def transform_all(self, node: addnodes.desc_content) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Transform all field list children of a node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for field_list in node.traverse(nodes.field_list):</span>
<span class="gi">+            self.transform(field_list)</span>

<span class="w"> </span>    def transform(self, node: nodes.field_list) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Transform a single field list *node*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        typemap = self.typemap</span>
<span class="gi">+</span>
<span class="gi">+        entries: list[nodes.field] = []</span>
<span class="gi">+        groupindices: dict[str, int] = {}</span>
<span class="gi">+</span>
<span class="gi">+        def handle_field(field: nodes.field, name: str, sig: str, signode: TextlikeNode | None) -&gt; None:</span>
<span class="gi">+            fieldtype, is_grouped = typemap.get(name, (None, False))</span>
<span class="gi">+            if fieldtype is None:</span>
<span class="gi">+                # Unknown field type, keep it as-is</span>
<span class="gi">+                entries.append(field)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            typename = fieldtype.name</span>
<span class="gi">+</span>
<span class="gi">+            if is_grouped:</span>
<span class="gi">+                if typename in groupindices:</span>
<span class="gi">+                    group = entries[groupindices[typename]]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    group = self.create_grouped_field(fieldtype, sig)</span>
<span class="gi">+                    entries.append(group)</span>
<span class="gi">+                    groupindices[typename] = len(entries) - 1</span>
<span class="gi">+</span>
<span class="gi">+                if fieldtype.is_typed:</span>
<span class="gi">+                    arg, type_ = self.split_type_and_arg(sig)</span>
<span class="gi">+                    self.add_field_arg_to_group(group, fieldtype, arg, type_)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.add_field_to_group(group, fieldtype, sig)</span>
<span class="gi">+            else:</span>
<span class="gi">+                field = self.create_field(fieldtype, sig)</span>
<span class="gi">+                entries.append(field)</span>
<span class="gi">+</span>
<span class="gi">+        for field in node:</span>
<span class="gi">+            assert isinstance(field, nodes.field)</span>
<span class="gi">+            field_name = field[0].astext()</span>
<span class="gi">+            field_body = field[1]</span>
<span class="gi">+</span>
<span class="gi">+            if field_name in typemap:</span>
<span class="gi">+                handle_field(field, field_name, field_body.astext(), field_body)</span>
<span class="gi">+            elif &#39;:&#39; in field_name:</span>
<span class="gi">+                name, _, sig = field_name.partition(&#39;:&#39;)</span>
<span class="gi">+                handle_field(field, name.strip(), sig.strip(), field_body)</span>
<span class="gi">+            else:</span>
<span class="gi">+                entries.append(field)</span>
<span class="gi">+</span>
<span class="gi">+        node.clear()</span>
<span class="gi">+        node.extend(entries)</span>
<span class="gh">diff --git a/sphinx/util/docstrings.py b/sphinx/util/docstrings.py</span>
<span class="gh">index 8e3c68d14..dbefab875 100644</span>
<span class="gd">--- a/sphinx/util/docstrings.py</span>
<span class="gi">+++ b/sphinx/util/docstrings.py</span>
<span class="gu">@@ -8,7 +8,23 @@ field_list_item_re = re.compile(Body.patterns[&#39;field_marker&#39;])</span>

<span class="w"> </span>def separate_metadata(s: (str | None)) -&gt;tuple[str | None, dict[str, str]]:
<span class="w"> </span>    &quot;&quot;&quot;Separate docstring into metadata and others.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if s is None:</span>
<span class="gi">+        return None, {}</span>
<span class="gi">+    </span>
<span class="gi">+    metadata = {}</span>
<span class="gi">+    lines = s.split(&#39;\n&#39;)</span>
<span class="gi">+    content_lines = []</span>
<span class="gi">+    </span>
<span class="gi">+    for line in lines:</span>
<span class="gi">+        match = field_list_item_re.match(line)</span>
<span class="gi">+        if match:</span>
<span class="gi">+            field, _, value = line.partition(&#39;:&#39;)</span>
<span class="gi">+            metadata[field.strip()] = value.strip()</span>
<span class="gi">+        else:</span>
<span class="gi">+            content_lines.append(line)</span>
<span class="gi">+    </span>
<span class="gi">+    content = &#39;\n&#39;.join(content_lines).strip()</span>
<span class="gi">+    return content if content else None, metadata</span>


<span class="w"> </span>def prepare_docstring(s: str, tabsize: int=8) -&gt;list[str]:
<span class="gu">@@ -19,11 +35,43 @@ def prepare_docstring(s: str, tabsize: int=8) -&gt;list[str]:</span>
<span class="w"> </span>    ViewList (used as argument of nested_parse().)  An empty line is added to
<span class="w"> </span>    act as a separator between this docstring and following content.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not s:</span>
<span class="gi">+        return []</span>
<span class="gi">+    </span>
<span class="gi">+    lines = s.expandtabs(tabsize).split(&#39;\n&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    # Find minimum indentation (first line doesn&#39;t count)</span>
<span class="gi">+    indent = sys.maxsize</span>
<span class="gi">+    for line in lines[1:]:</span>
<span class="gi">+        stripped = line.lstrip()</span>
<span class="gi">+        if stripped:</span>
<span class="gi">+            indent = min(indent, len(line) - len(stripped))</span>
<span class="gi">+    </span>
<span class="gi">+    # Remove indentation (first line is special)</span>
<span class="gi">+    trimmed = [lines[0].strip()]</span>
<span class="gi">+    if indent &lt; sys.maxsize:</span>
<span class="gi">+        for line in lines[1:]:</span>
<span class="gi">+            trimmed.append(line[indent:].rstrip())</span>
<span class="gi">+    </span>
<span class="gi">+    # Strip off trailing and leading blank lines:</span>
<span class="gi">+    while trimmed and not trimmed[-1]:</span>
<span class="gi">+        trimmed.pop()</span>
<span class="gi">+    while trimmed and not trimmed[0]:</span>
<span class="gi">+        trimmed.pop(0)</span>
<span class="gi">+    </span>
<span class="gi">+    # Add an empty line to act as a separator</span>
<span class="gi">+    trimmed.append(&#39;&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    return trimmed</span>


<span class="w"> </span>def prepare_commentdoc(s: str) -&gt;list[str]:
<span class="w"> </span>    &quot;&quot;&quot;Extract documentation comment lines (starting with #:) and return them
<span class="w"> </span>    as a list of lines.  Returns an empty list if there is no documentation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for line in s.split(&#39;\n&#39;):</span>
<span class="gi">+        line = line.strip()</span>
<span class="gi">+        if line.startswith(&#39;#:&#39;):</span>
<span class="gi">+            result.append(line[2:].strip())</span>
<span class="gi">+    return result</span>
<span class="gh">diff --git a/sphinx/util/docutils.py b/sphinx/util/docutils.py</span>
<span class="gh">index d4889e254..c6fb8cc38 100644</span>
<span class="gd">--- a/sphinx/util/docutils.py</span>
<span class="gi">+++ b/sphinx/util/docutils.py</span>
<span class="gu">@@ -36,12 +36,15 @@ additional_nodes: set[type[Element]] = set()</span>
<span class="w"> </span>@contextmanager
<span class="w"> </span>def docutils_namespace() -&gt;Iterator[None]:
<span class="w"> </span>    &quot;&quot;&quot;Create namespace for reST parsers.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        pass</span>


<span class="w"> </span>def is_directive_registered(name: str) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check the *name* directive is already registered.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return name in directives._directives</span>


<span class="w"> </span>def register_directive(name: str, directive: type[Directive]) -&gt;None:
<span class="gu">@@ -50,12 +53,12 @@ def register_directive(name: str, directive: type[Directive]) -&gt;None:</span>
<span class="w"> </span>    This modifies global state of docutils.  So it is better to use this
<span class="w"> </span>    inside ``docutils_namespace()`` to prevent side-effects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    directives.register_directive(name, directive)</span>


<span class="w"> </span>def is_role_registered(name: str) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check the *name* role is already registered.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return name in roles._roles</span>


<span class="w"> </span>def register_role(name: str, role: RoleFunction) -&gt;None:
<span class="gu">@@ -64,17 +67,18 @@ def register_role(name: str, role: RoleFunction) -&gt;None:</span>
<span class="w"> </span>    This modifies global state of docutils.  So it is better to use this
<span class="w"> </span>    inside ``docutils_namespace()`` to prevent side-effects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    roles.register_local_role(name, role)</span>


<span class="w"> </span>def unregister_role(name: str) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Unregister a role from docutils.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if name in roles._roles:</span>
<span class="gi">+        del roles._roles[name]</span>


<span class="w"> </span>def is_node_registered(node: type[Element]) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check the *node* is already registered.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return node in additional_nodes</span>


<span class="w"> </span>def register_node(node: type[Element]) -&gt;None:
<span class="gu">@@ -83,7 +87,7 @@ def register_node(node: type[Element]) -&gt;None:</span>
<span class="w"> </span>    This modifies global state of some visitors.  So it is better to use this
<span class="w"> </span>    inside ``docutils_namespace()`` to prevent side-effects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    additional_nodes.add(node)</span>


<span class="w"> </span>def unregister_node(node: type[Element]) -&gt;None:
<span class="gu">@@ -91,7 +95,8 @@ def unregister_node(node: type[Element]) -&gt;None:</span>

<span class="w"> </span>    This is inverse of ``nodes._add_nodes_class_names()``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if node in additional_nodes:</span>
<span class="gi">+        additional_nodes.remove(node)</span>


<span class="w"> </span>@contextmanager
<span class="gu">@@ -101,7 +106,16 @@ def patched_get_language() -&gt;Iterator[None]:</span>
<span class="w"> </span>    This ignores the second argument ``reporter`` to suppress warnings.
<span class="w"> </span>    refs: https://github.com/sphinx-doc/sphinx/issues/3788
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from docutils.languages import get_language as original_get_language</span>
<span class="gi">+</span>
<span class="gi">+    def patched_get_language(language_code, reporter=None):</span>
<span class="gi">+        return original_get_language(language_code)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        docutils.languages.get_language = patched_get_language</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        docutils.languages.get_language = original_get_language</span>


<span class="w"> </span>@contextmanager
<span class="gu">@@ -115,19 +129,41 @@ def patched_rst_get_language() -&gt;Iterator[None]:</span>

<span class="w"> </span>    refs: https://github.com/sphinx-doc/sphinx/issues/10179
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from docutils.parsers.rst.languages import get_language as original_get_language</span>
<span class="gi">+</span>
<span class="gi">+    def patched_get_language(language_code, reporter=None):</span>
<span class="gi">+        return original_get_language(language_code)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        docutils.parsers.rst.languages.get_language = patched_get_language</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        docutils.parsers.rst.languages.get_language = original_get_language</span>


<span class="w"> </span>@contextmanager
<span class="w"> </span>def using_user_docutils_conf(confdir: (str | None)) -&gt;Iterator[None]:
<span class="w"> </span>    &quot;&quot;&quot;Let docutils know the location of ``docutils.conf`` for Sphinx.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        if confdir:</span>
<span class="gi">+            docutilsconfig = os.environ.get(&#39;DOCUTILSCONFIG&#39;, None)</span>
<span class="gi">+            os.environ[&#39;DOCUTILSCONFIG&#39;] = path.join(confdir, &#39;docutils.conf&#39;)</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        if confdir:</span>
<span class="gi">+            if docutilsconfig is None:</span>
<span class="gi">+                os.environ.pop(&#39;DOCUTILSCONFIG&#39;, None)</span>
<span class="gi">+            else:</span>
<span class="gi">+                os.environ[&#39;DOCUTILSCONFIG&#39;] = docutilsconfig</span>


<span class="w"> </span>@contextmanager
<span class="w"> </span>def patch_docutils(confdir: (str | None)=None) -&gt;Iterator[None]:
<span class="w"> </span>    &quot;&quot;&quot;Patch to docutils temporarily.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with patched_get_language(), \</span>
<span class="gi">+         patched_rst_get_language(), \</span>
<span class="gi">+         using_user_docutils_conf(confdir):</span>
<span class="gi">+        yield</span>


<span class="w"> </span>class CustomReSTDispatcher:
<span class="gh">diff --git a/sphinx/util/exceptions.py b/sphinx/util/exceptions.py</span>
<span class="gh">index 53e2b545f..f52afced5 100644</span>
<span class="gd">--- a/sphinx/util/exceptions.py</span>
<span class="gi">+++ b/sphinx/util/exceptions.py</span>
<span class="gu">@@ -11,9 +11,24 @@ if TYPE_CHECKING:</span>

<span class="w"> </span>def save_traceback(app: (Sphinx | None), exc: BaseException) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Save the given exception&#39;s traceback in a temporary file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with NamedTemporaryFile(&#39;w&#39;, delete=False, suffix=&#39;.log&#39;) as f:</span>
<span class="gi">+        traceback.print_exc(file=f)</span>
<span class="gi">+        if isinstance(exc, SphinxParallelError):</span>
<span class="gi">+            f.write(&#39;\n&#39;)</span>
<span class="gi">+            f.write(exc.orig_exc_str)</span>
<span class="gi">+</span>
<span class="gi">+    return f.name</span>


<span class="w"> </span>def format_exception_cut_frames(x: int=1) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Format an exception with traceback, but only the last x frames.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    type_, value, tb = sys.exc_info()</span>
<span class="gi">+    if tb:</span>
<span class="gi">+        tb_list = traceback.extract_tb(tb)</span>
<span class="gi">+        if len(tb_list) &gt; x:</span>
<span class="gi">+            tb_list = tb_list[-x:]</span>
<span class="gi">+        formatted = traceback.format_list(tb_list)</span>
<span class="gi">+        formatted.extend(traceback.format_exception_only(type_, value))</span>
<span class="gi">+    else:</span>
<span class="gi">+        formatted = traceback.format_exception_only(type_, value)</span>
<span class="gi">+    return &#39;&#39;.join(strip_escape_sequences(line) for line in formatted)</span>
<span class="gh">diff --git a/sphinx/util/fileutil.py b/sphinx/util/fileutil.py</span>
<span class="gh">index fa4bab77f..01b620f1b 100644</span>
<span class="gd">--- a/sphinx/util/fileutil.py</span>
<span class="gi">+++ b/sphinx/util/fileutil.py</span>
<span class="gu">@@ -19,7 +19,10 @@ def _template_basename(filename: (str | os.PathLike[str])) -&gt;(str | None):</span>
<span class="w"> </span>    If the input looks like a template, then return the filename output should
<span class="w"> </span>    be written to.  Otherwise, return no result (None).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    basename = os.path.basename(filename)</span>
<span class="gi">+    if basename.endswith(&#39;_t&#39;) or basename.endswith(&#39;.template&#39;):</span>
<span class="gi">+        return basename[:-2] if basename.endswith(&#39;_t&#39;) else basename[:-9]</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def copy_asset_file(source: (str | os.PathLike[str]), destination: (str |
<span class="gu">@@ -36,7 +39,23 @@ def copy_asset_file(source: (str | os.PathLike[str]), destination: (str |</span>
<span class="w"> </span>    :param renderer: The template engine.  If not given, SphinxRenderer is used by default
<span class="w"> </span>    :param bool force: Overwrite the destination file even if it exists.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if os.path.isdir(destination):</span>
<span class="gi">+        destination = os.path.join(destination, os.path.basename(source))</span>
<span class="gi">+</span>
<span class="gi">+    if os.path.exists(destination) and not force:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if context is not None and _template_basename(source):</span>
<span class="gi">+        if renderer is None:</span>
<span class="gi">+            from sphinx.util.template import SphinxRenderer</span>
<span class="gi">+            renderer = SphinxRenderer()</span>
<span class="gi">+        with open(source, &#39;r&#39;) as f:</span>
<span class="gi">+            template = f.read()</span>
<span class="gi">+        rendered = renderer.render_string(template, context)</span>
<span class="gi">+        with open(destination, &#39;w&#39;) as f:</span>
<span class="gi">+            f.write(rendered)</span>
<span class="gi">+    else:</span>
<span class="gi">+        copyfile(source, destination)</span>


<span class="w"> </span>def copy_asset(source: (str | os.PathLike[str]), destination: (str | os.
<span class="gu">@@ -59,4 +78,32 @@ def copy_asset(source: (str | os.PathLike[str]), destination: (str | os.</span>
<span class="w"> </span>    :param onerror: The error handler.
<span class="w"> </span>    :param bool force: Overwrite the destination file even if it exists.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not os.path.exists(source):</span>
<span class="gi">+        logger.warning(__(&#39;Cannot find asset file: %s&#39;), source)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if os.path.isfile(source):</span>
<span class="gi">+        copy_asset_file(source, destination, context, renderer, force=force)</span>
<span class="gi">+    else:</span>
<span class="gi">+        ensuredir(destination)</span>
<span class="gi">+        for root, dirs, files in os.walk(source):</span>
<span class="gi">+            for dir_name in dirs[:]:</span>
<span class="gi">+                if excluded(os.path.join(root, dir_name)):</span>
<span class="gi">+                    dirs.remove(dir_name)</span>
<span class="gi">+</span>
<span class="gi">+            for filename in files:</span>
<span class="gi">+                if excluded(os.path.join(root, filename)):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                source_path = os.path.join(root, filename)</span>
<span class="gi">+                relative_path = os.path.relpath(source_path, source)</span>
<span class="gi">+                dest_path = os.path.join(destination, relative_path)</span>
<span class="gi">+</span>
<span class="gi">+                try:</span>
<span class="gi">+                    ensuredir(os.path.dirname(dest_path))</span>
<span class="gi">+                    copy_asset_file(source_path, dest_path, context, renderer, force=force)</span>
<span class="gi">+                except Exception as exc:</span>
<span class="gi">+                    if onerror:</span>
<span class="gi">+                        onerror(source_path, exc)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        raise</span>
<span class="gh">diff --git a/sphinx/util/http_date.py b/sphinx/util/http_date.py</span>
<span class="gh">index 0a1f2f186..2fb017e7d 100644</span>
<span class="gd">--- a/sphinx/util/http_date.py</span>
<span class="gi">+++ b/sphinx/util/http_date.py</span>
<span class="gu">@@ -14,9 +14,17 @@ _GMT_OFFSET = float(time.localtime().tm_gmtoff)</span>

<span class="w"> </span>def epoch_to_rfc1123(epoch: float) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Return HTTP-date string from epoch offset.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    t = time.gmtime(epoch)</span>
<span class="gi">+    return f&quot;{_WEEKDAY_NAME[t.tm_wday]}, {t.tm_mday:02d} {_MONTH_NAME[t.tm_mon]} {t.tm_year} {t.tm_hour:02d}:{t.tm_min:02d}:{t.tm_sec:02d} GMT&quot;</span>


<span class="w"> </span>def rfc1123_to_epoch(rfc1123: str) -&gt;float:
<span class="w"> </span>    &quot;&quot;&quot;Return epoch offset from HTTP-date string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        t = parsedate_tz(rfc1123)</span>
<span class="gi">+        if t is None:</span>
<span class="gi">+            raise ValueError(&quot;Invalid RFC 1123 date format&quot;)</span>
<span class="gi">+        return time.mktime(t[:9]) - _GMT_OFFSET</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        warnings.warn(&quot;Invalid date format (expected RFC 1123)&quot;, RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+        return 0</span>
<span class="gh">diff --git a/sphinx/util/i18n.py b/sphinx/util/i18n.py</span>
<span class="gh">index c493eb2cf..b0ca00411 100644</span>
<span class="gd">--- a/sphinx/util/i18n.py</span>
<span class="gi">+++ b/sphinx/util/i18n.py</span>
<span class="gu">@@ -65,10 +65,44 @@ class CatalogRepository:</span>
<span class="w"> </span>        self.language = language
<span class="w"> </span>        self.encoding = encoding

<span class="gi">+    def get_catalog_files(self) -&gt; Iterator[CatalogInfo]:</span>
<span class="gi">+        for locale_dir in self._locale_dirs:</span>
<span class="gi">+            catalog_dir = path.join(self.basedir, locale_dir, self.language, &#39;LC_MESSAGES&#39;)</span>
<span class="gi">+            if not path.exists(catalog_dir):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            for domain in os.listdir(catalog_dir):</span>
<span class="gi">+                if domain.endswith(&#39;.po&#39;):</span>
<span class="gi">+                    domain = domain[:-3]</span>
<span class="gi">+                    yield CatalogInfo(catalog_dir, domain, self.encoding)</span>
<span class="gi">+</span>
<span class="gi">+    def write_mo(self, catalog: CatalogInfo) -&gt; None:</span>
<span class="gi">+        po_file = path.join(catalog.base_dir, catalog.domain + &#39;.po&#39;)</span>
<span class="gi">+        mo_file = path.join(catalog.base_dir, catalog.domain + &#39;.mo&#39;)</span>
<span class="gi">+        with open(po_file, &#39;rb&#39;) as infile:</span>
<span class="gi">+            try:</span>
<span class="gi">+                po = read_po(infile, catalog.charset)</span>
<span class="gi">+            except Exception as exc:</span>
<span class="gi">+                logger.warning(__(&#39;reading error: %s, %s&#39;), po_file, exc)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        with open(mo_file, &#39;wb&#39;) as outfile:</span>
<span class="gi">+            try:</span>
<span class="gi">+                write_mo(outfile, po)</span>
<span class="gi">+            except Exception as exc:</span>
<span class="gi">+                logger.warning(__(&#39;writing error: %s, %s&#39;), mo_file, exc)</span>
<span class="gi">+</span>
<span class="gi">+    def compile_catalogs(self) -&gt; None:</span>
<span class="gi">+        for catalog in self.get_catalog_files():</span>
<span class="gi">+            self.write_mo(catalog)</span>
<span class="gi">+</span>

<span class="w"> </span>def docname_to_domain(docname: str, compaction: (bool | str)) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Convert docname to domain for catalogs.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if compaction:</span>
<span class="gi">+        return docname.split(SEP, 1)[0]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return docname.replace(SEP, &#39;_&#39;)</span>


<span class="w"> </span>date_format_mappings = {&#39;%a&#39;: &#39;EEE&#39;, &#39;%A&#39;: &#39;EEEE&#39;, &#39;%b&#39;: &#39;MMM&#39;, &#39;%B&#39;:
<span class="gh">diff --git a/sphinx/util/index_entries.py b/sphinx/util/index_entries.py</span>
<span class="gh">index 56ebb9a85..124a006cd 100644</span>
<span class="gd">--- a/sphinx/util/index_entries.py</span>
<span class="gi">+++ b/sphinx/util/index_entries.py</span>
<span class="gu">@@ -3,4 +3,10 @@ from __future__ import annotations</span>

<span class="w"> </span>def _split_into(n: int, type: str, value: str) -&gt;list[str]:
<span class="w"> </span>    &quot;&quot;&quot;Split an index entry into a given number of parts at semicolons.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = value.split(&#39;;&#39;, n - 1)</span>
<span class="gi">+    if len(parts) &lt; n:</span>
<span class="gi">+        parts.extend([&#39;&#39;] * (n - len(parts)))</span>
<span class="gi">+    elif len(parts) &gt; n:</span>
<span class="gi">+        parts[n-1] = &#39;;&#39;.join(parts[n-1:])</span>
<span class="gi">+        parts = parts[:n]</span>
<span class="gi">+    return parts</span>
<span class="gh">diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py</span>
<span class="gh">index 5e7c1ae78..e279ff3b1 100644</span>
<span class="gd">--- a/sphinx/util/inspect.py</span>
<span class="gi">+++ b/sphinx/util/inspect.py</span>
<span class="gu">@@ -62,7 +62,9 @@ def unwrap(obj: Any) -&gt;Any:</span>

<span class="w"> </span>    Mocked objects are returned as is.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(obj, &#39;__wrapped__&#39;):</span>
<span class="gi">+        return unwrap(obj.__wrapped__)</span>
<span class="gi">+    return obj</span>


<span class="w"> </span>def unwrap_all(obj: Any, *, stop: (Callable[[Any], bool] | None)=None) -&gt;Any:
<span class="gu">@@ -74,7 +76,17 @@ def unwrap_all(obj: Any, *, stop: (Callable[[Any], bool] | None)=None) -&gt;Any:</span>
<span class="w"> </span>    When specified, *stop* is a predicate indicating whether an object should
<span class="w"> </span>    be unwrapped or not.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while True:</span>
<span class="gi">+        if stop and stop(obj):</span>
<span class="gi">+            return obj</span>
<span class="gi">+        if hasattr(obj, &#39;__wrapped__&#39;):</span>
<span class="gi">+            obj = obj.__wrapped__</span>
<span class="gi">+        elif isinstance(obj, (partial, partialmethod)):</span>
<span class="gi">+            obj = obj.func</span>
<span class="gi">+        elif isinstance(obj, (classmethod, staticmethod)):</span>
<span class="gi">+            obj = obj.__func__</span>
<span class="gi">+        else:</span>
<span class="gi">+            return obj</span>


<span class="w"> </span>def getall(obj: Any) -&gt;(Sequence[str] | None):
<span class="gu">@@ -84,22 +96,29 @@ def getall(obj: Any) -&gt;(Sequence[str] | None):</span>
<span class="w"> </span>    raises :exc:`ValueError` if ``obj.__all__`` is not a list or tuple of
<span class="w"> </span>    strings.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not hasattr(obj, &#39;__all__&#39;):</span>
<span class="gi">+        return None</span>
<span class="gi">+    all_attr = getattr(obj, &#39;__all__&#39;)</span>
<span class="gi">+    if not isinstance(all_attr, (list, tuple)):</span>
<span class="gi">+        raise ValueError(&#39;__all__ must be a list or tuple of strings&#39;)</span>
<span class="gi">+    if not all(isinstance(item, str) for item in all_attr):</span>
<span class="gi">+        raise ValueError(&#39;__all__ must contain only strings&#39;)</span>
<span class="gi">+    return all_attr</span>


<span class="w"> </span>def getannotations(obj: Any) -&gt;Mapping[str, Any]:
<span class="w"> </span>    &quot;&quot;&quot;Safely get the ``__annotations__`` attribute of an object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return getattr(obj, &#39;__annotations__&#39;, {})</span>


<span class="w"> </span>def getglobals(obj: Any) -&gt;Mapping[str, Any]:
<span class="w"> </span>    &quot;&quot;&quot;Safely get :attr:`obj.__globals__ &lt;function.__globals__&gt;`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return getattr(obj, &#39;__globals__&#39;, {})</span>


<span class="w"> </span>def getmro(obj: Any) -&gt;tuple[type, ...]:
<span class="w"> </span>    &quot;&quot;&quot;Safely get :attr:`obj.__mro__ &lt;class.__mro__&gt;`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return getattr(obj, &#39;__mro__&#39;, ())</span>


<span class="w"> </span>def getorigbases(obj: Any) -&gt;(tuple[Any, ...] | None):
<span class="gu">@@ -108,7 +127,12 @@ def getorigbases(obj: Any) -&gt;(tuple[Any, ...] | None):</span>
<span class="w"> </span>    This returns ``None`` if the object is not a class or if ``__orig_bases__``
<span class="w"> </span>    is not well-defined (e.g., a non-tuple object or an empty sequence).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(obj, type):</span>
<span class="gi">+        return None</span>
<span class="gi">+    orig_bases = getattr(obj, &#39;__orig_bases__&#39;, None)</span>
<span class="gi">+    if not isinstance(orig_bases, tuple) or len(orig_bases) == 0:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return orig_bases</span>


<span class="w"> </span>def getslots(obj: Any) -&gt;(dict[str, Any] | dict[str, None] | None):
<span class="gu">@@ -118,7 +142,19 @@ def getslots(obj: Any) -&gt;(dict[str, Any] | dict[str, None] | None):</span>
<span class="w"> </span>    - This raises a :exc:`TypeError` if *obj* is not a class.
<span class="w"> </span>    - This raises a :exc:`ValueError` if ``obj.__slots__`` is invalid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(obj, type):</span>
<span class="gi">+        raise TypeError(&quot;Expected a class object&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    slots = getattr(obj, &#39;__slots__&#39;, None)</span>
<span class="gi">+    if slots is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(slots, str):</span>
<span class="gi">+        return {slots: None}</span>
<span class="gi">+    elif isinstance(slots, (list, tuple)):</span>
<span class="gi">+        return {slot: None for slot in slots}</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;Invalid __slots__ attribute&quot;)</span>


<span class="w"> </span>def isenumclass(x: Any) -&gt;TypeIs[type[enum.Enum]]:
<span class="gh">diff --git a/sphinx/util/inventory.py b/sphinx/util/inventory.py</span>
<span class="gh">index 5648e43b1..d2ac4aa2b 100644</span>
<span class="gd">--- a/sphinx/util/inventory.py</span>
<span class="gi">+++ b/sphinx/util/inventory.py</span>
<span class="gu">@@ -25,7 +25,103 @@ class InventoryFileReader:</span>
<span class="w"> </span>        self.stream = stream
<span class="w"> </span>        self.buffer = b&#39;&#39;
<span class="w"> </span>        self.eof = False
<span class="gi">+        self.decompressor = None</span>
<span class="gi">+</span>
<span class="gi">+    def read_buffer(self) -&gt;None:</span>
<span class="gi">+        chunk = self.stream.read(BUFSIZE)</span>
<span class="gi">+        if not chunk:</span>
<span class="gi">+            self.eof = True</span>
<span class="gi">+            return</span>
<span class="gi">+        if self.decompressor:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.buffer += self.decompressor.decompress(chunk)</span>
<span class="gi">+            except zlib.error:</span>
<span class="gi">+                # If decompression fails, treat the chunk as uncompressed</span>
<span class="gi">+                self.buffer += chunk</span>
<span class="gi">+                self.decompressor = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.buffer += chunk</span>
<span class="gi">+</span>
<span class="gi">+    def readline(self) -&gt;str:</span>
<span class="gi">+        while b&#39;\n&#39; not in self.buffer:</span>
<span class="gi">+            if self.eof:</span>
<span class="gi">+                break</span>
<span class="gi">+            self.read_buffer()</span>
<span class="gi">+        if b&#39;\n&#39; in self.buffer:</span>
<span class="gi">+            line, self.buffer = self.buffer.split(b&#39;\n&#39;, 1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            line = self.buffer</span>
<span class="gi">+            self.buffer = b&#39;&#39;</span>
<span class="gi">+        return line.decode(&#39;utf-8&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def read_compressed_chunks(self) -&gt;Iterator[bytes]:</span>
<span class="gi">+        self.decompressor = zlib.decompressobj()</span>
<span class="gi">+        while not self.eof:</span>
<span class="gi">+            self.read_buffer()</span>
<span class="gi">+            yield self.buffer</span>
<span class="gi">+            self.buffer = b&#39;&#39;</span>
<span class="gi">+        if self.decompressor.unused_data:</span>
<span class="gi">+            yield self.decompressor.unused_data</span>


<span class="w"> </span>class InventoryFile:
<span class="gd">-    pass</span>
<span class="gi">+    def __init__(self) -&gt;None:</span>
<span class="gi">+        self.projects: dict[str, Inventory] = {}</span>
<span class="gi">+</span>
<span class="gi">+    def load(self, stream: IO[bytes], uri: str, joinfunc: Callable[[str, str], str]) -&gt;None:</span>
<span class="gi">+        reader = InventoryFileReader(stream)</span>
<span class="gi">+        line = reader.readline().rstrip()</span>
<span class="gi">+        if line == &#39;# Sphinx inventory version 1&#39;:</span>
<span class="gi">+            self.load_v1(reader, uri, joinfunc)</span>
<span class="gi">+        elif line == &#39;# Sphinx inventory version 2&#39;:</span>
<span class="gi">+            self.load_v2(reader, uri, joinfunc)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&#39;invalid inventory header: %s&#39; % line)</span>
<span class="gi">+</span>
<span class="gi">+    def load_v1(self, reader: InventoryFileReader, uri: str, joinfunc: Callable[[str, str], str]) -&gt;None:</span>
<span class="gi">+        projname = reader.readline().rstrip()[11:]</span>
<span class="gi">+        for line in reader.read_compressed_chunks():</span>
<span class="gi">+            name, type, location = line.decode().rstrip().split(None, 2)</span>
<span class="gi">+            self.projects.setdefault(projname, {})[name] = (type, location)</span>
<span class="gi">+</span>
<span class="gi">+    def load_v2(self, reader: InventoryFileReader, uri: str, joinfunc: Callable[[str, str], str]) -&gt;None:</span>
<span class="gi">+        projname = reader.readline().rstrip()[11:]</span>
<span class="gi">+        version = reader.readline().rstrip()[11:]</span>
<span class="gi">+        reader.readline()  # skip the &quot;zlib&quot; line</span>
<span class="gi">+        for line in reader.read_compressed_chunks():</span>
<span class="gi">+            name, type, prio, location, dispname = line.decode().rstrip().split(None, 4)</span>
<span class="gi">+            if location.endswith(&#39;$&#39;):</span>
<span class="gi">+                location = location[:-1] + name</span>
<span class="gi">+            location = joinfunc(uri, location)</span>
<span class="gi">+            self.projects.setdefault(projname, {})[name] = (type, prio, location, dispname)</span>
<span class="gi">+</span>
<span class="gi">+    def dump(self, f: IO[str]) -&gt;None:</span>
<span class="gi">+        f.write(&#39;# Sphinx inventory version 2\n&#39;)</span>
<span class="gi">+        for (projname, items) in self.projects.items():</span>
<span class="gi">+            f.write(&#39;# Project: %s\n&#39; % projname)</span>
<span class="gi">+            f.write(&#39;# Version: \n&#39;)</span>
<span class="gi">+            f.write(&#39;# The remainder of this file is compressed using zlib.\n&#39;)</span>
<span class="gi">+            compressor = zlib.compressobj(9)</span>
<span class="gi">+            for name, info in sorted(items.items()):</span>
<span class="gi">+                type, prio, location, dispname = info</span>
<span class="gi">+                if dispname == name:</span>
<span class="gi">+                    dispname = &#39;-&#39;</span>
<span class="gi">+                f.write(compressor.compress(</span>
<span class="gi">+                    f&#39;{name} {type} {prio} {location} {dispname}\n&#39;.encode()))</span>
<span class="gi">+            f.write(compressor.flush())</span>
<span class="gi">+</span>
<span class="gi">+    def __contains__(self, name: str) -&gt;bool:</span>
<span class="gi">+        for project in self.projects.values():</span>
<span class="gi">+            if name in project:</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def __getitem__(self, name: str) -&gt;InventoryItem:</span>
<span class="gi">+        for project in self.projects.values():</span>
<span class="gi">+            if name in project:</span>
<span class="gi">+                return project[name]</span>
<span class="gi">+        raise KeyError(name)</span>
<span class="gi">+</span>
<span class="gi">+    def __iter__(self) -&gt;Iterator[tuple[str, InventoryItem]]:</span>
<span class="gi">+        for project in self.projects.values():</span>
<span class="gi">+            yield from project.items()</span>
<span class="gh">diff --git a/sphinx/util/logging.py b/sphinx/util/logging.py</span>
<span class="gh">index 00c940a4c..c69e94e92 100644</span>
<span class="gd">--- a/sphinx/util/logging.py</span>
<span class="gi">+++ b/sphinx/util/logging.py</span>
<span class="gu">@@ -41,12 +41,16 @@ def getLogger(name: str) -&gt;SphinxLoggerAdapter:</span>
<span class="w"> </span>        &gt;&gt;&gt; logger.info(&#39;Hello, this is an extension!&#39;)
<span class="w"> </span>        Hello, this is an extension!
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = logging.getLogger(NAMESPACE + &#39;.&#39; + name)</span>
<span class="gi">+    return SphinxLoggerAdapter(logger, {})</span>


<span class="w"> </span>def convert_serializable(records: list[logging.LogRecord]) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Convert LogRecord serializable.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for record in records:</span>
<span class="gi">+        record.args = tuple(arg for arg in record.args if isinstance(arg, (str, int, float, bool, type(None))))</span>
<span class="gi">+        record.exc_info = None</span>
<span class="gi">+        record.exc_text = None</span>


<span class="w"> </span>class SphinxLogRecord(logging.LogRecord):
<span class="gu">@@ -94,7 +98,15 @@ class SphinxLoggerAdapter(logging.LoggerAdapter):</span>
<span class="w"> </span>        :param once: Do not log this warning,
<span class="w"> </span>            if a previous warning already has same ``msg``, ``args`` and ``once=True``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs.update({</span>
<span class="gi">+            &#39;type&#39;: type,</span>
<span class="gi">+            &#39;subtype&#39;: subtype,</span>
<span class="gi">+            &#39;location&#39;: location,</span>
<span class="gi">+            &#39;nonl&#39;: nonl,</span>
<span class="gi">+            &#39;color&#39;: color,</span>
<span class="gi">+            &#39;once&#39;: once</span>
<span class="gi">+        })</span>
<span class="gi">+        self.logger.warning(msg, *args, **kwargs)</span>


<span class="w"> </span>class WarningStreamHandler(logging.StreamHandler):
<span class="gu">@@ -120,7 +132,15 @@ def pending_warnings() -&gt;Iterator[logging.Handler]:</span>

<span class="w"> </span>    Similar to :func:`pending_logging`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = logging.getLogger(NAMESPACE)</span>
<span class="gi">+    memhandler = MemoryHandler()</span>
<span class="gi">+    memhandler.setLevel(logging.WARNING)</span>
<span class="gi">+    logger.addHandler(memhandler)</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield memhandler</span>
<span class="gi">+    finally:</span>
<span class="gi">+        logger.removeHandler(memhandler)</span>
<span class="gi">+        memhandler.flushTo(logger)</span>


<span class="w"> </span>@contextmanager
<span class="gu">@@ -134,7 +154,14 @@ def suppress_logging() -&gt;Iterator[MemoryHandler]:</span>
<span class="w"> </span>        &gt;&gt;&gt;     some_long_process()
<span class="w"> </span>        &gt;&gt;&gt;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = logging.getLogger(NAMESPACE)</span>
<span class="gi">+    memhandler = MemoryHandler()</span>
<span class="gi">+    memhandler.setLevel(logging.DEBUG)</span>
<span class="gi">+    logger.addHandler(memhandler)</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield memhandler</span>
<span class="gi">+    finally:</span>
<span class="gi">+        logger.removeHandler(memhandler)</span>


<span class="w"> </span>@contextmanager
<span class="gu">@@ -149,7 +176,15 @@ def pending_logging() -&gt;Iterator[MemoryHandler]:</span>
<span class="w"> </span>        &gt;&gt;&gt;
<span class="w"> </span>        Warning message!  # the warning is flushed here
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = logging.getLogger(NAMESPACE)</span>
<span class="gi">+    memhandler = MemoryHandler()</span>
<span class="gi">+    memhandler.setLevel(logging.DEBUG)</span>
<span class="gi">+    logger.addHandler(memhandler)</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield memhandler</span>
<span class="gi">+    finally:</span>
<span class="gi">+        logger.removeHandler(memhandler)</span>
<span class="gi">+        memhandler.flushTo(logger)</span>


<span class="w"> </span>skip_warningiserror = nullcontext
<span class="gu">@@ -166,7 +201,13 @@ def prefixed_warnings(prefix: str) -&gt;Iterator[None]:</span>

<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = logging.getLogger(NAMESPACE)</span>
<span class="gi">+    prefix_filter = MessagePrefixFilter(prefix)</span>
<span class="gi">+    logger.addFilter(prefix_filter)</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        logger.removeFilter(prefix_filter)</span>


<span class="w"> </span>class LogCollector:
<span class="gu">@@ -186,7 +227,18 @@ class _RaiseOnWarningFilter(logging.Filter):</span>
<span class="w"> </span>def is_suppressed_warning(warning_type: str, sub_type: str,
<span class="w"> </span>    suppress_warnings: (Set[str] | Sequence[str])) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check whether the warning is suppressed or not.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if warning_type is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    for warning in suppress_warnings:</span>
<span class="gi">+        if warning == warning_type:</span>
<span class="gi">+            return True</span>
<span class="gi">+        if warning.endswith(&#39;*&#39;) and warning_type.startswith(warning[:-1]):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if sub_type and warning == f&quot;{warning_type}.{sub_type}&quot;:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>


<span class="w"> </span>class WarningSuppressor(logging.Filter):
<span class="gh">diff --git a/sphinx/util/matching.py b/sphinx/util/matching.py</span>
<span class="gh">index de4967a6a..e2d5f53aa 100644</span>
<span class="gd">--- a/sphinx/util/matching.py</span>
<span class="gi">+++ b/sphinx/util/matching.py</span>
<span class="gu">@@ -14,7 +14,40 @@ def _translate_pattern(pat: str) -&gt;str:</span>
<span class="w"> </span>    Adapted from the fnmatch module, but enhanced so that single stars don&#39;t
<span class="w"> </span>    match slashes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    i, n = 0, len(pat)</span>
<span class="gi">+    res = []</span>
<span class="gi">+    while i &lt; n:</span>
<span class="gi">+        c = pat[i]</span>
<span class="gi">+        i = i + 1</span>
<span class="gi">+        if c == &#39;*&#39;:</span>
<span class="gi">+            if i &lt; n and pat[i] == &#39;*&#39;:</span>
<span class="gi">+                res.append(&#39;.*&#39;)</span>
<span class="gi">+                i = i + 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                res.append(&#39;[^/]*&#39;)</span>
<span class="gi">+        elif c == &#39;?&#39;:</span>
<span class="gi">+            res.append(&#39;[^/]&#39;)</span>
<span class="gi">+        elif c == &#39;[&#39;:</span>
<span class="gi">+            j = i</span>
<span class="gi">+            if j &lt; n and pat[j] == &#39;!&#39;:</span>
<span class="gi">+                j = j + 1</span>
<span class="gi">+            if j &lt; n and pat[j] == &#39;]&#39;:</span>
<span class="gi">+                j = j + 1</span>
<span class="gi">+            while j &lt; n and pat[j] != &#39;]&#39;:</span>
<span class="gi">+                j = j + 1</span>
<span class="gi">+            if j &gt;= n:</span>
<span class="gi">+                res.append(&#39;\\[&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                stuff = pat[i:j].replace(&#39;\\&#39;, &#39;\\\\&#39;)</span>
<span class="gi">+                i = j + 1</span>
<span class="gi">+                if stuff[0] == &#39;!&#39;:</span>
<span class="gi">+                    stuff = &#39;^&#39; + stuff[1:]</span>
<span class="gi">+                elif stuff[0] == &#39;^&#39;:</span>
<span class="gi">+                    stuff = &#39;\\&#39; + stuff</span>
<span class="gi">+                res.append(&#39;[%s]&#39; % stuff)</span>
<span class="gi">+        else:</span>
<span class="gi">+            res.append(re.escape(c))</span>
<span class="gi">+    return &#39;&#39;.join(res) + r&#39;\Z(?ms)&#39;</span>


<span class="w"> </span>class Matcher:
<span class="gu">@@ -41,7 +74,9 @@ def patmatch(name: str, pat: str) -&gt;(re.Match[str] | None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Return if name matches the regular expression (pattern)
<span class="w"> </span>    ``pat```. Adapted from fnmatch module.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if pat not in _pat_cache:</span>
<span class="gi">+        _pat_cache[pat] = re.compile(_translate_pattern(pat))</span>
<span class="gi">+    return _pat_cache[pat].match(name)</span>


<span class="w"> </span>def patfilter(names: Iterable[str], pat: str) -&gt;list[str]:
<span class="gu">@@ -50,7 +85,7 @@ def patfilter(names: Iterable[str], pat: str) -&gt;list[str]:</span>

<span class="w"> </span>    Adapted from fnmatch module.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [name for name in names if patmatch(name, pat)]</span>


<span class="w"> </span>def get_matching_files(dirname: (str | os.PathLike[str]), include_patterns:
<span class="gu">@@ -64,4 +99,14 @@ def get_matching_files(dirname: (str | os.PathLike[str]), include_patterns:</span>
<span class="w"> </span>    exclusions from *exclude_patterns* take priority over inclusions.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dirname = os.path.abspath(dirname)</span>
<span class="gi">+    include_matcher = Matcher(include_patterns)</span>
<span class="gi">+    exclude_matcher = Matcher(exclude_patterns)</span>
<span class="gi">+</span>
<span class="gi">+    for root, _, files in os.walk(dirname):</span>
<span class="gi">+        for filename in files:</span>
<span class="gi">+            path = os.path.join(root, filename)</span>
<span class="gi">+            rel_path = os.path.relpath(path, dirname)</span>
<span class="gi">+            rel_path = path_stabilize(rel_path)</span>
<span class="gi">+            if include_matcher(rel_path) and not exclude_matcher(rel_path):</span>
<span class="gi">+                yield canon_path(rel_path)</span>
<span class="gh">diff --git a/sphinx/util/nodes.py b/sphinx/util/nodes.py</span>
<span class="gh">index c491cf3fb..d9fa4da0e 100644</span>
<span class="gd">--- a/sphinx/util/nodes.py</span>
<span class="gi">+++ b/sphinx/util/nodes.py</span>
<span class="gu">@@ -59,7 +59,8 @@ class NodeMatcher(Generic[N]):</span>
<span class="w"> </span>        While the `NodeMatcher` object can be used as an argument to `Node.findall`, doing so
<span class="w"> </span>        confounds type checkers&#39; ability to determine the return type of the iterator.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for child in node.findall(self):</span>
<span class="gi">+            yield cast(N, child)</span>


<span class="w"> </span>def get_full_module_name(node: Node) -&gt;str:
<span class="gu">@@ -69,7 +70,9 @@ def get_full_module_name(node: Node) -&gt;str:</span>
<span class="w"> </span>    :param nodes.Node node: target node
<span class="w"> </span>    :return: full module dotted path
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    module = node.__class__.__module__</span>
<span class="gi">+    class_name = node.__class__.__name__</span>
<span class="gi">+    return f&quot;{module}.{class_name}&quot;</span>


<span class="w"> </span>def repr_domxml(node: Node, length: int=80) -&gt;str:
<span class="gu">@@ -83,7 +86,14 @@ def repr_domxml(node: Node, length: int=80) -&gt;str:</span>
<span class="w"> </span>       returns full of DOM XML representation.
<span class="w"> </span>    :return: DOM XML representation
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from xml.dom import minidom</span>
<span class="gi">+    document = minidom.parseString(node.asdom().toxml())</span>
<span class="gi">+    dom_string = document.documentElement.toxml()</span>
<span class="gi">+    </span>
<span class="gi">+    if length:</span>
<span class="gi">+        return dom_string[:length] + &#39;...&#39; if len(dom_string) &gt; length else dom_string</span>
<span class="gi">+    else:</span>
<span class="gi">+        return dom_string</span>


<span class="w"> </span>IGNORED_NODES = (nodes.Invisible, nodes.literal_block, nodes.doctest_block,
<span class="gu">@@ -95,13 +105,23 @@ IMAGE_TYPE_NODES = nodes.image,</span>

<span class="w"> </span>def extract_messages(doctree: Element) -&gt;Iterable[tuple[Element, str]]:
<span class="w"> </span>    &quot;&quot;&quot;Extract translatable messages from a document tree.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for node in doctree.traverse(nodes.TextElement):</span>
<span class="gi">+        if not isinstance(node, IGNORED_NODES) and node.get(&#39;translatable&#39;, True):</span>
<span class="gi">+            if isinstance(node, LITERAL_TYPE_NODES):</span>
<span class="gi">+                msg = node.rawsource</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg = node.astext()</span>
<span class="gi">+            </span>
<span class="gi">+            if msg:</span>
<span class="gi">+                yield (node, msg)</span>


<span class="w"> </span>def traverse_translatable_index(doctree: Element) -&gt;Iterable[tuple[Element,
<span class="w"> </span>    list[tuple[str, str, str, str, str | None]]]]:
<span class="w"> </span>    &quot;&quot;&quot;Traverse translatable index node from a document tree.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for node in doctree.traverse(addnodes.index):</span>
<span class="gi">+        if &#39;entries&#39; in node:</span>
<span class="gi">+            yield (node, node[&#39;entries&#39;])</span>


<span class="w"> </span>def nested_parse_with_titles(state: RSTState, content: StringList, node:
<span class="gu">@@ -115,7 +135,9 @@ def nested_parse_with_titles(state: RSTState, content: StringList, node:</span>
<span class="w"> </span>    This function is retained for compatibility and will be deprecated in
<span class="w"> </span>    Sphinx 8. Prefer ``nested_parse_to_nodes()``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with _fresh_title_style_context():</span>
<span class="gi">+        state.nested_parse(content, content_offset, node, match_titles=True)</span>
<span class="gi">+    return node.astext()</span>


<span class="w"> </span>def clean_astext(node: Element) -&gt;str:
<span class="gh">diff --git a/sphinx/util/osutil.py b/sphinx/util/osutil.py</span>
<span class="gh">index 83ada565b..ec61ddd1c 100644</span>
<span class="gd">--- a/sphinx/util/osutil.py</span>
<span class="gi">+++ b/sphinx/util/osutil.py</span>
<span class="gu">@@ -20,22 +20,31 @@ SEP = &#39;/&#39;</span>

<span class="w"> </span>def canon_path(native_path: (str | os.PathLike[str]), /) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Return path in OS-independent form&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return str(Path(native_path).as_posix())</span>


<span class="w"> </span>def path_stabilize(filepath: (str | os.PathLike[str]), /) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Normalize path separator and unicode string&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return unicodedata.normalize(&#39;NFC&#39;, str(Path(filepath).as_posix()))</span>


<span class="w"> </span>def relative_uri(base: str, to: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Return a relative URL from ``base`` to ``to``.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    b = canon_path(base)</span>
<span class="gi">+    t = canon_path(to)</span>
<span class="gi">+    if b == t:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+    b_dir = path.dirname(b)</span>
<span class="gi">+    common_prefix = path.commonprefix([b_dir, t])</span>
<span class="gi">+    if common_prefix == b_dir:</span>
<span class="gi">+        return t[len(common_prefix):].lstrip(SEP)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return &#39;../&#39; * (b_dir.count(SEP) - common_prefix.count(SEP)) + t[len(common_prefix):].lstrip(SEP)</span>


<span class="w"> </span>def ensuredir(file: (str | os.PathLike[str])) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Ensure that a path exists.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    Path(file).mkdir(parents=True, exist_ok=True)</span>


<span class="w"> </span>def _last_modified_time(source: (str | os.PathLike[str]), /) -&gt;int:
<span class="gu">@@ -48,13 +57,15 @@ def _last_modified_time(source: (str | os.PathLike[str]), /) -&gt;int:</span>
<span class="w"> </span>    We prefer to err on the side of re-rendering a file,
<span class="w"> </span>    so we round up to the nearest microsecond.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    mtime = os.stat(source).st_mtime</span>
<span class="gi">+    return int(mtime * 1_000_000 + 1)</span>


<span class="w"> </span>def _copy_times(source: (str | os.PathLike[str]), dest: (str | os.PathLike[
<span class="w"> </span>    str])) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Copy a file&#39;s modification times.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    st = os.stat(source)</span>
<span class="gi">+    os.utime(dest, (st.st_atime, st.st_mtime))</span>


<span class="w"> </span>def copyfile(source: (str | os.PathLike[str]), dest: (str | os.PathLike[str
<span class="gu">@@ -68,7 +79,16 @@ def copyfile(source: (str | os.PathLike[str]), dest: (str | os.PathLike[str</span>

<span class="w"> </span>    .. note:: :func:`copyfile` is a no-op if *source* and *dest* are identical.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not os.path.exists(source):</span>
<span class="gi">+        raise FileNotFoundError(f&quot;Source file &#39;{source}&#39; does not exist&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if os.path.samefile(source, dest):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if os.path.exists(dest) and not force:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    shutil.copy2(source, dest)</span>


<span class="w"> </span>_no_fn_re = re.compile(&#39;[^a-zA-Z0-9_-]&#39;)
<span class="gu">@@ -82,7 +102,11 @@ def relpath(path: (str | os.PathLike[str]), start: (str | os.PathLike[str] |</span>
<span class="w"> </span>    This is an alternative of ``os.path.relpath()``.  This returns original path
<span class="w"> </span>    if *path* and *start* are on different drives (for Windows platform).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return os.path.relpath(path, start)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        # If path and start are on different drives (Windows)</span>
<span class="gi">+        return str(path)</span>


<span class="w"> </span>safe_relpath = relpath
<span class="gh">diff --git a/sphinx/util/parallel.py b/sphinx/util/parallel.py</span>
<span class="gh">index d4b1bfccb..a6ea00da0 100644</span>
<span class="gd">--- a/sphinx/util/parallel.py</span>
<span class="gi">+++ b/sphinx/util/parallel.py</span>
<span class="gu">@@ -22,7 +22,18 @@ class SerialTasks:</span>
<span class="w"> </span>    &quot;&quot;&quot;Has the same interface as ParallelTasks, but executes tasks directly.&quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, nproc: int=1) -&gt;None:
<span class="gd">-        pass</span>
<span class="gi">+        self.nproc = nproc</span>
<span class="gi">+        self.tasks = []</span>
<span class="gi">+</span>
<span class="gi">+    def add_task(self, task_func: Callable, arg: Any=None, result_func: Callable | None=None) -&gt; None:</span>
<span class="gi">+        self.tasks.append((task_func, arg, result_func))</span>
<span class="gi">+</span>
<span class="gi">+    def join(self) -&gt; None:</span>
<span class="gi">+        for task_func, arg, result_func in self.tasks:</span>
<span class="gi">+            result = task_func(arg)</span>
<span class="gi">+            if result_func:</span>
<span class="gi">+                result_func(result)</span>
<span class="gi">+        self.tasks.clear()</span>


<span class="w"> </span>class ParallelTasks:
<span class="gu">@@ -37,3 +48,64 @@ class ParallelTasks:</span>
<span class="w"> </span>        self._precvsWaiting: dict[int, Any] = {}
<span class="w"> </span>        self._pworking = 0
<span class="w"> </span>        self._taskid = 0
<span class="gi">+</span>
<span class="gi">+    def add_task(self, task_func: Callable, arg: Any=None, result_func: Callable | None=None) -&gt; None:</span>
<span class="gi">+        self._taskid += 1</span>
<span class="gi">+        self._result_funcs[self._taskid] = result_func</span>
<span class="gi">+        self._args[self._taskid] = [arg]</span>
<span class="gi">+</span>
<span class="gi">+        if self._pworking &lt; self.nproc:</span>
<span class="gi">+            self._start_task(self._taskid, task_func)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._precvsWaiting[self._taskid] = task_func</span>
<span class="gi">+</span>
<span class="gi">+    def _start_task(self, taskid: int, task_func: Callable) -&gt; None:</span>
<span class="gi">+        precv, psend = multiprocessing.Pipe(False)</span>
<span class="gi">+        proc = multiprocessing.Process(target=self._process_task,</span>
<span class="gi">+                                       args=(taskid, task_func, psend, self._args[taskid]))</span>
<span class="gi">+        proc.start()</span>
<span class="gi">+        self._procs[taskid] = proc</span>
<span class="gi">+        self._precvs[taskid] = precv</span>
<span class="gi">+        self._pworking += 1</span>
<span class="gi">+</span>
<span class="gi">+    def _process_task(self, taskid: int, task_func: Callable, psend: Any, args: list[Any]) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if args:</span>
<span class="gi">+                ret = task_func(*args)</span>
<span class="gi">+            else:</span>
<span class="gi">+                ret = task_func()</span>
<span class="gi">+            psend.send((taskid, ret, None))</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            psend.send((taskid, None, e))</span>
<span class="gi">+</span>
<span class="gi">+    def join(self) -&gt; None:</span>
<span class="gi">+        while self._pworking:</span>
<span class="gi">+            for taskid, precv in list(self._precvs.items()):</span>
<span class="gi">+                if precv.poll():</span>
<span class="gi">+                    res = precv.recv()</span>
<span class="gi">+                    self._finish_task(res)</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                time.sleep(0.02)</span>
<span class="gi">+</span>
<span class="gi">+    def _finish_task(self, res: tuple[int, Any, Exception | None]) -&gt; None:</span>
<span class="gi">+        taskid, result, exc = res</span>
<span class="gi">+        if taskid in self._procs:</span>
<span class="gi">+            self._procs[taskid].join()</span>
<span class="gi">+            del self._procs[taskid]</span>
<span class="gi">+        del self._precvs[taskid]</span>
<span class="gi">+        self._pworking -= 1</span>
<span class="gi">+</span>
<span class="gi">+        if exc:</span>
<span class="gi">+            raise SphinxParallelError(exc)</span>
<span class="gi">+</span>
<span class="gi">+        result_func = self._result_funcs.get(taskid)</span>
<span class="gi">+        if result_func:</span>
<span class="gi">+            result_func(result)</span>
<span class="gi">+</span>
<span class="gi">+        if self._precvsWaiting:</span>
<span class="gi">+            newtaskid, task_func = self._precvsWaiting.popitem()</span>
<span class="gi">+            self._start_task(newtaskid, task_func)</span>
<span class="gi">+</span>
<span class="gi">+        del self._result_funcs[taskid]</span>
<span class="gi">+        del self._args[taskid]</span>
<span class="gh">diff --git a/sphinx/util/parsing.py b/sphinx/util/parsing.py</span>
<span class="gh">index cc99e270e..7d0c7e5ef 100644</span>
<span class="gd">--- a/sphinx/util/parsing.py</span>
<span class="gi">+++ b/sphinx/util/parsing.py</span>
<span class="gu">@@ -40,4 +40,27 @@ def nested_parse_to_nodes(state: RSTState, text: (str | StringList), *,</span>

<span class="w"> </span>    .. versionadded:: 7.4
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(text, str):</span>
<span class="gi">+        text = StringList(string2lines(text), source=source)</span>
<span class="gi">+    elif isinstance(text, StringList):</span>
<span class="gi">+        text = text.copy()</span>
<span class="gi">+        text.source = source</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&quot;text must be a string or StringList&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    memo = state.memo</span>
<span class="gi">+    memo.title_styles = []</span>
<span class="gi">+    memo.section_level = 0</span>
<span class="gi">+    memo.section_bubble_up_kludge = False</span>
<span class="gi">+    memo.allow_section_headings = allow_section_headings</span>
<span class="gi">+    memo.keep_title_context = keep_title_context</span>
<span class="gi">+</span>
<span class="gi">+    node = Element()</span>
<span class="gi">+    node.document = state.document</span>
<span class="gi">+    node.source = source</span>
<span class="gi">+    node.line = offset + 1</span>
<span class="gi">+</span>
<span class="gi">+    with contextlib.suppress(state.nested_parse_with_titles):</span>
<span class="gi">+        state.nested_parse(text, offset, node, match_titles=True)</span>
<span class="gi">+</span>
<span class="gi">+    return node.children</span>
<span class="gh">diff --git a/sphinx/util/png.py b/sphinx/util/png.py</span>
<span class="gh">index fb20e2105..699ebdec2 100644</span>
<span class="gd">--- a/sphinx/util/png.py</span>
<span class="gi">+++ b/sphinx/util/png.py</span>
<span class="gu">@@ -11,7 +11,25 @@ IEND_CHUNK = b&#39;\x00\x00\x00\x00IEND\xaeB`\x82&#39;</span>

<span class="w"> </span>def read_png_depth(filename: str) -&gt;(int | None):
<span class="w"> </span>    &quot;&quot;&quot;Read the special tEXt chunk indicating the depth from a PNG file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open(filename, &#39;rb&#39;) as f:</span>
<span class="gi">+        data = f.read()</span>
<span class="gi">+    </span>
<span class="gi">+    if len(data) &lt; LEN_DEPTH:</span>
<span class="gi">+        return None</span>
<span class="gi">+    </span>
<span class="gi">+    pos = data.rfind(IEND_CHUNK)</span>
<span class="gi">+    if pos == -1:</span>
<span class="gi">+        return None</span>
<span class="gi">+    </span>
<span class="gi">+    chunk_start = data.rfind(DEPTH_CHUNK_START, 0, pos)</span>
<span class="gi">+    if chunk_start == -1:</span>
<span class="gi">+        return None</span>
<span class="gi">+    </span>
<span class="gi">+    depth_str = data[chunk_start + len(DEPTH_CHUNK_START):pos].split(b&#39;\0&#39;, 1)[0]</span>
<span class="gi">+    try:</span>
<span class="gi">+        return int(depth_str)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return None</span>


<span class="w"> </span>def write_png_depth(filename: str, depth: int) -&gt;None:
<span class="gu">@@ -19,4 +37,22 @@ def write_png_depth(filename: str, depth: int) -&gt;None:</span>

<span class="w"> </span>    The chunk is placed immediately before the special IEND chunk.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open(filename, &#39;rb&#39;) as f:</span>
<span class="gi">+        data = f.read()</span>
<span class="gi">+    </span>
<span class="gi">+    pos = data.rfind(IEND_CHUNK)</span>
<span class="gi">+    if pos == -1:</span>
<span class="gi">+        raise ValueError(&quot;Invalid PNG file: IEND chunk not found&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    depth_chunk = (</span>
<span class="gi">+        DEPTH_CHUNK_LEN +</span>
<span class="gi">+        DEPTH_CHUNK_START +</span>
<span class="gi">+        str(depth).encode(&#39;ascii&#39;) +</span>
<span class="gi">+        b&#39;\0&#39; +</span>
<span class="gi">+        struct.pack(&#39;!I&#39;, binascii.crc32(DEPTH_CHUNK_START + str(depth).encode(&#39;ascii&#39;) + b&#39;\0&#39;))</span>
<span class="gi">+    )</span>
<span class="gi">+    </span>
<span class="gi">+    new_data = data[:pos] + depth_chunk + data[pos:]</span>
<span class="gi">+    </span>
<span class="gi">+    with open(filename, &#39;wb&#39;) as f:</span>
<span class="gi">+        f.write(new_data)</span>
<span class="gh">diff --git a/sphinx/util/requests.py b/sphinx/util/requests.py</span>
<span class="gh">index c1ee76baa..58a818df9 100644</span>
<span class="gd">--- a/sphinx/util/requests.py</span>
<span class="gi">+++ b/sphinx/util/requests.py</span>
<span class="gu">@@ -14,7 +14,15 @@ _USER_AGENT = (</span>
<span class="w"> </span>def _get_tls_cacert(url: str, certs: (str | dict[str, str] | None)) -&gt;(str |
<span class="w"> </span>    bool):
<span class="w"> </span>    &quot;&quot;&quot;Get additional CA cert for a specific URL.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if certs is None:</span>
<span class="gi">+        return True</span>
<span class="gi">+    elif isinstance(certs, str):</span>
<span class="gi">+        return certs</span>
<span class="gi">+    else:</span>
<span class="gi">+        hostname = urlsplit(url).hostname</span>
<span class="gi">+        if hostname:</span>
<span class="gi">+            return certs.get(hostname, True)</span>
<span class="gi">+        return True</span>


<span class="w"> </span>def get(url: str, **kwargs: Any) -&gt;requests.Response:
<span class="gu">@@ -22,7 +30,11 @@ def get(url: str, **kwargs: Any) -&gt;requests.Response:</span>

<span class="w"> </span>    This sets up User-Agent header and TLS verification automatically.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kwargs.setdefault(&#39;headers&#39;, {}).setdefault(&#39;User-Agent&#39;, _USER_AGENT)</span>
<span class="gi">+    kwargs.setdefault(&#39;verify&#39;, _get_tls_cacert(url, kwargs.pop(&#39;certs&#39;, None)))</span>
<span class="gi">+    with warnings.catch_warnings():</span>
<span class="gi">+        warnings.filterwarnings(&#39;ignore&#39;, category=InsecureRequestWarning)</span>
<span class="gi">+        return requests.get(url, **kwargs)</span>


<span class="w"> </span>def head(url: str, **kwargs: Any) -&gt;requests.Response:
<span class="gu">@@ -30,7 +42,11 @@ def head(url: str, **kwargs: Any) -&gt;requests.Response:</span>

<span class="w"> </span>    This sets up User-Agent header and TLS verification automatically.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kwargs.setdefault(&#39;headers&#39;, {}).setdefault(&#39;User-Agent&#39;, _USER_AGENT)</span>
<span class="gi">+    kwargs.setdefault(&#39;verify&#39;, _get_tls_cacert(url, kwargs.pop(&#39;certs&#39;, None)))</span>
<span class="gi">+    with warnings.catch_warnings():</span>
<span class="gi">+        warnings.filterwarnings(&#39;ignore&#39;, category=InsecureRequestWarning)</span>
<span class="gi">+        return requests.head(url, **kwargs)</span>


<span class="w"> </span>class _Session(requests.Session):
<span class="gu">@@ -42,4 +58,13 @@ class _Session(requests.Session):</span>

<span class="w"> </span>        This sets up User-Agent header and TLS verification automatically.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs.setdefault(&#39;headers&#39;, {}).setdefault(&#39;User-Agent&#39;, _user_agent or _USER_AGENT)</span>
<span class="gi">+        if _tls_info:</span>
<span class="gi">+            kwargs[&#39;verify&#39;] = _tls_info[0]</span>
<span class="gi">+            if len(_tls_info) &gt; 1:</span>
<span class="gi">+                kwargs[&#39;cert&#39;] = _tls_info[1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            kwargs.setdefault(&#39;verify&#39;, _get_tls_cacert(url, kwargs.pop(&#39;certs&#39;, None)))</span>
<span class="gi">+        with warnings.catch_warnings():</span>
<span class="gi">+            warnings.filterwarnings(&#39;ignore&#39;, category=InsecureRequestWarning)</span>
<span class="gi">+            return super().request(method, url, **kwargs)</span>
<span class="gh">diff --git a/sphinx/util/rst.py b/sphinx/util/rst.py</span>
<span class="gh">index 21fe03367..c6e4e22f2 100644</span>
<span class="gd">--- a/sphinx/util/rst.py</span>
<span class="gi">+++ b/sphinx/util/rst.py</span>
<span class="gu">@@ -25,20 +25,43 @@ WIDECHARS[&#39;ja&#39;] = &#39;WFA&#39;</span>

<span class="w"> </span>def textwidth(text: str, widechars: str=&#39;WF&#39;) -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Get width of text.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    width = 0</span>
<span class="gi">+    for char in text:</span>
<span class="gi">+        if east_asian_width(char) in WIDECHARS[widechars]:</span>
<span class="gi">+            width += 2</span>
<span class="gi">+        else:</span>
<span class="gi">+            width += 1</span>
<span class="gi">+    return width</span>


<span class="w"> </span>@pass_environment
<span class="w"> </span>def heading(env: Environment, text: str, level: int=1) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Create a heading for *level*.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if level &lt;= 0:</span>
<span class="gi">+        raise ValueError(&quot;Heading level must be positive&quot;)</span>
<span class="gi">+    if level &gt; len(SECTIONING_CHARS):</span>
<span class="gi">+        char = SECTIONING_CHARS[-1]</span>
<span class="gi">+    else:</span>
<span class="gi">+        char = SECTIONING_CHARS[level - 1]</span>
<span class="gi">+    width = textwidth(text)</span>
<span class="gi">+    return f&quot;{text}\n{char * width}&quot;</span>


<span class="w"> </span>def prepend_prolog(content: StringList, prolog: str) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Prepend a string to content body as prolog.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not prolog:</span>
<span class="gi">+        return</span>
<span class="gi">+    # Insert a blank line between the prolog and the existing content</span>
<span class="gi">+    content.insert(0, &#39;&#39;)</span>
<span class="gi">+    # Insert the prolog at the beginning of the content</span>
<span class="gi">+    content.insert(0, prolog)</span>


<span class="w"> </span>def append_epilog(content: StringList, epilog: str) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Append a string to content body as epilog.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not epilog:</span>
<span class="gi">+        return</span>
<span class="gi">+    # Insert a blank line between the existing content and the epilog</span>
<span class="gi">+    content.append(&#39;&#39;)</span>
<span class="gi">+    # Append the epilog to the end of the content</span>
<span class="gi">+    content.append(epilog)</span>
<span class="gh">diff --git a/sphinx/util/tags.py b/sphinx/util/tags.py</span>
<span class="gh">index 808df44b6..77515cd95 100644</span>
<span class="gd">--- a/sphinx/util/tags.py</span>
<span class="gi">+++ b/sphinx/util/tags.py</span>
<span class="gu">@@ -40,4 +40,28 @@ class Tags:</span>
<span class="w"> </span>        are permitted, and operate on tag names, where truthy values mean
<span class="w"> </span>        the tag is present and vice versa.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if condition in self._condition_cache:</span>
<span class="gi">+            return self._condition_cache[condition]</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            parser = BooleanParser(_ENV.parse(condition))</span>
<span class="gi">+            ast = parser.parse_expression()</span>
<span class="gi">+            result = self._eval_node(ast)</span>
<span class="gi">+            self._condition_cache[condition] = result</span>
<span class="gi">+            return result</span>
<span class="gi">+        except jinja2.exceptions.TemplateSyntaxError as exc:</span>
<span class="gi">+            raise ValueError(f&#39;Invalid boolean expression: {condition}&#39;) from exc</span>
<span class="gi">+</span>
<span class="gi">+    def _eval_node(self, node: jinja2.nodes.Node) -&gt; bool:</span>
<span class="gi">+        if isinstance(node, jinja2.nodes.Name):</span>
<span class="gi">+            return node.name in self._tags</span>
<span class="gi">+        elif isinstance(node, jinja2.nodes.Not):</span>
<span class="gi">+            return not self._eval_node(node.node)</span>
<span class="gi">+        elif isinstance(node, jinja2.nodes.And):</span>
<span class="gi">+            return self._eval_node(node.left) and self._eval_node(node.right)</span>
<span class="gi">+        elif isinstance(node, jinja2.nodes.Or):</span>
<span class="gi">+            return self._eval_node(node.left) or self._eval_node(node.right)</span>
<span class="gi">+        elif isinstance(node, jinja2.nodes.Const):</span>
<span class="gi">+            return bool(node.value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&#39;Invalid node type: {type(node)}&#39;)</span>
<span class="gh">diff --git a/sphinx/util/texescape.py b/sphinx/util/texescape.py</span>
<span class="gh">index 2ed1eb943..0e0da9b4c 100644</span>
<span class="gd">--- a/sphinx/util/texescape.py</span>
<span class="gi">+++ b/sphinx/util/texescape.py</span>
<span class="gu">@@ -34,14 +34,36 @@ _tex_hlescape_map_without_unicode: dict[int, str] = {}</span>

<span class="w"> </span>def escape(s: str, latex_engine: (str | None)=None) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Escape text for LaTeX output.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if latex_engine == &#39;platex&#39;:</span>
<span class="gi">+        # for Japanese environment</span>
<span class="gi">+        s = s.replace(&#39;\\&#39;, &#39;\\textbackslash{}&#39;)</span>
<span class="gi">+        s = s.replace(&#39;{&#39;, &#39;\\{&#39;)</span>
<span class="gi">+        s = s.replace(&#39;}&#39;, &#39;\\}&#39;)</span>
<span class="gi">+        s = s.replace(&#39;$&#39;, &#39;\\$&#39;)</span>
<span class="gi">+        s = s.replace(&#39;%&#39;, &#39;\\%&#39;)</span>
<span class="gi">+        s = s.replace(&#39;&amp;&#39;, &#39;\\&amp;&#39;)</span>
<span class="gi">+        s = s.replace(&#39;#&#39;, &#39;\\#&#39;)</span>
<span class="gi">+        s = s.replace(&#39;_&#39;, &#39;\\_&#39;)</span>
<span class="gi">+        s = s.replace(&#39;~&#39;, &#39;\\textasciitilde{}&#39;)</span>
<span class="gi">+        s = s.replace(&#39;^&#39;, &#39;\\textasciicircum{}&#39;)</span>
<span class="gi">+        return s</span>
<span class="gi">+    else:</span>
<span class="gi">+        return &#39;&#39;.join(_tex_escape_map.get(ord(c), c) for c in s)</span>


<span class="w"> </span>def hlescape(s: str, latex_engine: (str | None)=None) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Escape text for LaTeX highlighter.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if latex_engine == &#39;platex&#39;:</span>
<span class="gi">+        # for Japanese environment</span>
<span class="gi">+        s = s.replace(&#39;\\&#39;, &#39;\\textbackslash{}&#39;)</span>
<span class="gi">+        s = s.replace(&#39;{&#39;, &#39;\\{&#39;)</span>
<span class="gi">+        s = s.replace(&#39;}&#39;, &#39;\\}&#39;)</span>
<span class="gi">+        s = s.replace(&#39;$&#39;, &#39;\\$&#39;)</span>
<span class="gi">+        return s</span>
<span class="gi">+    else:</span>
<span class="gi">+        return &#39;&#39;.join(_tex_hlescape_map.get(ord(c), c) for c in s)</span>


<span class="w"> </span>def escape_abbr(text: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Adjust spacing after abbreviations. Works with @ letter or other.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return re.sub(r&#39;\.(?=\w)&#39;, r&#39;.\@&#39;, text)</span>
<span class="gh">diff --git a/sphinx/util/typing.py b/sphinx/util/typing.py</span>
<span class="gh">index e0151d793..d24685be4 100644</span>
<span class="gd">--- a/sphinx/util/typing.py</span>
<span class="gi">+++ b/sphinx/util/typing.py</span>
<span class="gu">@@ -42,7 +42,7 @@ _INVALID_BUILTIN_CLASSES: Final[Mapping[object, str]] = {Context:</span>

<span class="w"> </span>def is_invalid_builtin_class(obj: Any) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check *obj* is an invalid built-in class.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return obj in _INVALID_BUILTIN_CLASSES</span>


<span class="w"> </span>TextlikeNode: TypeAlias = nodes.Text | nodes.TextElement
<span class="gu">@@ -99,22 +99,27 @@ def get_type_hints(obj: Any, globalns: (dict[str, Any] | None)=None,</span>
<span class="w"> </span>    This is a simple wrapper of `typing.get_type_hints()` that does not raise an error on
<span class="w"> </span>    runtime.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return typing.get_type_hints(obj, globalns, localns, include_extras)</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        logger.warning(&#39;Failed to get type hints for %r&#39;, obj)</span>
<span class="gi">+        return {}</span>


<span class="w"> </span>def is_system_TypeVar(typ: Any) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check *typ* is system defined TypeVar.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(typ, TypeVar) and typ.__module__ == &#39;typing&#39;</span>


<span class="w"> </span>def _is_annotated_form(obj: Any) -&gt;TypeIs[Annotated[Any, ...]]:
<span class="w"> </span>    &quot;&quot;&quot;Check if *obj* is an annotated type.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(obj, type(Annotated)) and obj.__origin__ is Annotated</span>


<span class="w"> </span>def _is_unpack_form(obj: Any) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is :class:`typing.Unpack` or equivalent.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (hasattr(typing, &#39;Unpack&#39;) and isinstance(obj, type(typing.Unpack))</span>
<span class="gi">+            or getattr(obj, &#39;__origin__&#39;, None) is getattr(typing, &#39;Unpack&#39;, None))</span>


<span class="w"> </span>def restify(cls: Any, mode: _RestifyMode=&#39;fully-qualified-except-typing&#39;
<span class="gu">@@ -129,7 +134,21 @@ def restify(cls: Any, mode: _RestifyMode=&#39;fully-qualified-except-typing&#39;</span>
<span class="w"> </span>                 &#39;smart&#39;
<span class="w"> </span>                     Show the name of the annotation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(cls, str):</span>
<span class="gi">+        return cls</span>
<span class="gi">+    elif isinstance(cls, type):</span>
<span class="gi">+        if mode == &#39;smart&#39;:</span>
<span class="gi">+            return cls.__name__</span>
<span class="gi">+        else:</span>
<span class="gi">+            module = cls.__module__</span>
<span class="gi">+            name = cls.__qualname__</span>
<span class="gi">+            if module == &#39;typing&#39; or module == &#39;builtins&#39;:</span>
<span class="gi">+                return name</span>
<span class="gi">+            return f&#39;{module}.{name}&#39;</span>
<span class="gi">+    elif isinstance(cls, TypeVar):</span>
<span class="gi">+        return cls.__name__</span>
<span class="gi">+    else:</span>
<span class="gi">+        return str(cls)</span>


<span class="w"> </span>def stringify_annotation(annotation: Any, /, mode: _StringifyMode=
<span class="gu">@@ -147,7 +166,23 @@ def stringify_annotation(annotation: Any, /, mode: _StringifyMode=</span>
<span class="w"> </span>                 &#39;fully-qualified&#39;
<span class="w"> </span>                     Show the module name and qualified name of the annotation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(annotation, str):</span>
<span class="gi">+        return annotation</span>
<span class="gi">+    elif isinstance(annotation, type):</span>
<span class="gi">+        if mode == &#39;smart&#39;:</span>
<span class="gi">+            return annotation.__name__</span>
<span class="gi">+        elif mode == &#39;fully-qualified&#39;:</span>
<span class="gi">+            return f&#39;{annotation.__module__}.{annotation.__qualname__}&#39;</span>
<span class="gi">+        else:  # fully-qualified-except-typing</span>
<span class="gi">+            module = annotation.__module__</span>
<span class="gi">+            name = annotation.__qualname__</span>
<span class="gi">+            if module == &#39;typing&#39; or module == &#39;builtins&#39;:</span>
<span class="gi">+                return name</span>
<span class="gi">+            return f&#39;{module}.{name}&#39;</span>
<span class="gi">+    elif isinstance(annotation, TypeVar):</span>
<span class="gi">+        return annotation.__name__</span>
<span class="gi">+    else:</span>
<span class="gi">+        return str(annotation)</span>


<span class="w"> </span>_DEPRECATED_OBJECTS: dict[str, tuple[Any, str, tuple[int, int]]] = {}
<span class="gh">diff --git a/sphinx/versioning.py b/sphinx/versioning.py</span>
<span class="gh">index e75880d9e..bcea28225 100644</span>
<span class="gd">--- a/sphinx/versioning.py</span>
<span class="gi">+++ b/sphinx/versioning.py</span>
<span class="gu">@@ -31,7 +31,10 @@ def add_uids(doctree: Node, condition: Callable[[Node], bool]) -&gt;Iterator[Node</span>
<span class="w"> </span>    :param condition:
<span class="w"> </span>        A callable which returns either ``True`` or ``False`` for a given node.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for node in doctree.traverse(condition):</span>
<span class="gi">+        if &#39;uid&#39; not in node:</span>
<span class="gi">+            node[&#39;uid&#39;] = uuid4().hex</span>
<span class="gi">+        yield node</span>


<span class="w"> </span>def merge_doctrees(old: Node, new: Node, condition: Callable[[Node], bool]
<span class="gu">@@ -45,19 +48,48 @@ def merge_doctrees(old: Node, new: Node, condition: Callable[[Node], bool]</span>
<span class="w"> </span>    :param condition:
<span class="w"> </span>        A callable which returns either ``True`` or ``False`` for a given node.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    old_iter = old.traverse(condition)</span>
<span class="gi">+    new_iter = new.traverse(condition)</span>
<span class="gi">+    old_nodes = {node[&#39;uid&#39;]: node for node in old_iter if &#39;uid&#39; in node}</span>
<span class="gi">+</span>
<span class="gi">+    for new_node in new_iter:</span>
<span class="gi">+        if &#39;uid&#39; not in new_node:</span>
<span class="gi">+            yield new_node</span>
<span class="gi">+        elif new_node[&#39;uid&#39;] not in old_nodes:</span>
<span class="gi">+            yield new_node</span>
<span class="gi">+        elif new_node != old_nodes[new_node[&#39;uid&#39;]]:</span>
<span class="gi">+            yield new_node</span>


<span class="w"> </span>def get_ratio(old: str, new: str) -&gt;float:
<span class="w"> </span>    &quot;&quot;&quot;Return a &quot;similarity ratio&quot; (in percent) representing the similarity
<span class="w"> </span>    between the two strings where 0 is equal and anything above less than equal.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if IS_SPEEDUP:</span>
<span class="gi">+        return Levenshtein.ratio(old, new) * 100</span>
<span class="gi">+    else:</span>
<span class="gi">+        distance = levenshtein_distance(old, new)</span>
<span class="gi">+        return (1 - (distance / max(len(old), len(new)))) * 100</span>


<span class="w"> </span>def levenshtein_distance(a: str, b: str) -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Return the Levenshtein edit distance between two strings *a* and *b*.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(a) &lt; len(b):</span>
<span class="gi">+        a, b = b, a</span>
<span class="gi">+    if not b:</span>
<span class="gi">+        return len(a)</span>
<span class="gi">+</span>
<span class="gi">+    previous_row = range(len(b) + 1)</span>
<span class="gi">+    for i, column1 in enumerate(a):</span>
<span class="gi">+        current_row = [i + 1]</span>
<span class="gi">+        for j, column2 in enumerate(b):</span>
<span class="gi">+            insertions = previous_row[j + 1] + 1</span>
<span class="gi">+            deletions = current_row[j] + 1</span>
<span class="gi">+            substitutions = previous_row[j] + (column1 != column2)</span>
<span class="gi">+            current_row.append(min(insertions, deletions, substitutions))</span>
<span class="gi">+        previous_row = current_row</span>
<span class="gi">+</span>
<span class="gi">+    return previous_row[-1]</span>


<span class="w"> </span>class UIDTransform(SphinxTransform):
<span class="gh">diff --git a/sphinx/writers/html5.py b/sphinx/writers/html5.py</span>
<span class="gh">index 761abb855..2e5157d93 100644</span>
<span class="gd">--- a/sphinx/writers/html5.py</span>
<span class="gi">+++ b/sphinx/writers/html5.py</span>
<span class="gu">@@ -22,7 +22,11 @@ logger = logging.getLogger(__name__)</span>

<span class="w"> </span>def multiply_length(length: str, scale: int) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Multiply *length* (width or height) by *scale*.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = re.match(r&#39;^(\d+(?:\.\d+)?)(px|em|rem|%)$&#39;, length)</span>
<span class="gi">+    if match:</span>
<span class="gi">+        value, unit = match.groups()</span>
<span class="gi">+        return f&quot;{float(value) * scale}{unit}&quot;</span>
<span class="gi">+    return length</span>


<span class="w"> </span>class HTML5Translator(SphinxTranslator, BaseTranslator):
<span class="gu">@@ -51,4 +55,21 @@ class HTML5Translator(SphinxTranslator, BaseTranslator):</span>
<span class="w"> </span>        The *parameter_group* value is the type of child nodes acting as required parameters
<span class="w"> </span>        or as a set of contiguous optional parameters.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.body.append(sig_open_paren)</span>
<span class="gi">+        self.required_params_left = sum(isinstance(c, parameter_group) for c in node.children)</span>
<span class="gi">+        self.param_separator = node.child_text_separator</span>
<span class="gi">+        self.optional_param_level = 0</span>
<span class="gi">+        for child in node:</span>
<span class="gi">+            if isinstance(child, parameter_group):</span>
<span class="gi">+                self.required_params_left -= 1</span>
<span class="gi">+                if self.optional_param_level:</span>
<span class="gi">+                    self.body.append(&#39;]&#39;)</span>
<span class="gi">+                    self.optional_param_level -= 1</span>
<span class="gi">+            elif isinstance(child, addnodes.optional):</span>
<span class="gi">+                self.optional_param_level += 1</span>
<span class="gi">+                self.body.append(&#39;[&#39;)</span>
<span class="gi">+            self.visit(child)</span>
<span class="gi">+        while self.optional_param_level:</span>
<span class="gi">+            self.body.append(&#39;]&#39;)</span>
<span class="gi">+            self.optional_param_level -= 1</span>
<span class="gi">+        self.body.append(sig_close_paren)</span>
<span class="gh">diff --git a/sphinx/writers/latex.py b/sphinx/writers/latex.py</span>
<span class="gh">index c0c3fff2d..50dae1b53 100644</span>
<span class="gd">--- a/sphinx/writers/latex.py</span>
<span class="gi">+++ b/sphinx/writers/latex.py</span>
<span class="gu">@@ -102,7 +102,7 @@ class Table:</span>

<span class="w"> </span>    def is_longtable(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;True if and only if table uses longtable environment.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &#39;longtable&#39; in self.styles or self.caption</span>

<span class="w"> </span>    def get_table_type(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Returns the LaTeX environment name for the table.
<span class="gu">@@ -113,7 +113,12 @@ class Table:</span>
<span class="w"> </span>        * tabular
<span class="w"> </span>        * tabulary
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.is_longtable():</span>
<span class="gi">+            return &#39;longtable&#39;</span>
<span class="gi">+        elif self.colspec:</span>
<span class="gi">+            return &#39;tabulary&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;tabular&#39;</span>

<span class="w"> </span>    def get_colspec(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Returns a column spec of table.
<span class="gu">@@ -125,14 +130,23 @@ class Table:</span>
<span class="w"> </span>           The ``\\\\X`` and ``T`` column type specifiers are defined in
<span class="w"> </span>           ``sphinxlatextables.sty``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.colspec:</span>
<span class="gi">+            return self.colspec</span>
<span class="gi">+        elif self.colwidths and len(self.colwidths) == self.colcount:</span>
<span class="gi">+            return &#39;&#39;.join(&#39;p{%.2f\\linewidth}&#39; % width for width in self.colwidths)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;l&#39; * self.colcount</span>

<span class="w"> </span>    def add_cell(self, height: int, width: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Adds a new cell to a table.

<span class="w"> </span>        It will be located at current position: (``self.row``, ``self.col``).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.cell_id += 1</span>
<span class="gi">+        for i in range(height):</span>
<span class="gi">+            for j in range(width):</span>
<span class="gi">+                self.cells[self.row + i, self.col + j] = self.cell_id</span>
<span class="gi">+        self.col += width</span>

<span class="w"> </span>    def cell(self, row: (int | None)=None, col: (int | None)=None) -&gt;(TableCell
<span class="w"> </span>         | None):
<span class="gu">@@ -141,7 +155,12 @@ class Table:</span>
<span class="w"> </span>        If no option arguments: ``row`` or ``col`` are given, the current position;
<span class="w"> </span>        ``self.row`` and ``self.col`` are used to get a cell object by default.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        row = self.row if row is None else row</span>
<span class="gi">+        col = self.col if col is None else col</span>
<span class="gi">+        try:</span>
<span class="gi">+            return TableCell(self, row, col)</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            return None</span>


<span class="w"> </span>class TableCell:
<span class="gu">@@ -162,22 +181,39 @@ class TableCell:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def width(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Returns the cell width.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sum(1 for col in range(self.col, self.table.colcount)</span>
<span class="gi">+                   if self.table.cells[self.row, col] == self.cell_id)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def height(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Returns the cell height.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sum(1 for row in range(self.row, self.table.row + 1)</span>
<span class="gi">+                   if self.table.cells[row, self.col] == self.cell_id)</span>


<span class="w"> </span>def escape_abbr(text: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Adjust spacing after abbreviations.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return re.sub(r&#39;\.(?=\w)&#39;, r&#39;.\@&#39;, text)</span>


<span class="w"> </span>def rstdim_to_latexdim(width_str: str, scale: int=100) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Convert `width_str` with rst length to LaTeX length.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = re.match(r&#39;^(\d*\.?\d*)(\S*)$&#39;, width_str)</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        return None</span>
<span class="gi">+    res = float(match.group(1))</span>
<span class="gi">+    unit = match.group(2)</span>
<span class="gi">+    if not unit or unit == &quot;px&quot;:</span>
<span class="gi">+        res = f&quot;{res * scale / 100:.2f}\\sphinxpxdimen&quot;</span>
<span class="gi">+    elif unit == &quot;%&quot;:</span>
<span class="gi">+        res = f&quot;{res * scale / 100:.2f}\\linewidth&quot;</span>
<span class="gi">+    elif unit == &#39;em&#39;:</span>
<span class="gi">+        res = f&quot;{res:.2f}em&quot;</span>
<span class="gi">+    elif unit in (&#39;\\textwidth&#39;, &#39;\\linewidth&#39;, &#39;\\paperwidth&#39;):</span>
<span class="gi">+        res = f&quot;{res:.2f}{unit}&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        res = f&quot;{res:.2f}{unit}&quot;</span>
<span class="gi">+    return res</span>


<span class="w"> </span>class LaTeXTranslator(SphinxTranslator):
<span class="gu">@@ -293,7 +329,7 @@ class LaTeXTranslator(SphinxTranslator):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def table(self) -&gt;(Table | None):
<span class="w"> </span>        &quot;&quot;&quot;Get current table.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.tables[-1] if self.tables else None</span>
<span class="w"> </span>    depart_sidebar = depart_topic

<span class="w"> </span>    def _visit_sig_parameter_list(self, node: Element, parameter_group:
<span class="gu">@@ -306,7 +342,19 @@ class LaTeXTranslator(SphinxTranslator):</span>
<span class="w"> </span>        The caller is responsible for closing adding surrounding LaTeX macro argument start
<span class="w"> </span>        and stop tokens.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        params = []</span>
<span class="gi">+        optional_params = []</span>
<span class="gi">+        for child in node.children:</span>
<span class="gi">+            if isinstance(child, parameter_group):</span>
<span class="gi">+                if child.get(&#39;optional&#39;):</span>
<span class="gi">+                    optional_params.append(child.astext())</span>
<span class="gi">+                else:</span>
<span class="gi">+                    params.append(child.astext())</span>
<span class="gi">+        </span>
<span class="gi">+        if params:</span>
<span class="gi">+            self.body.append(&#39;, &#39;.join(params))</span>
<span class="gi">+        if optional_params:</span>
<span class="gi">+            self.body.append(&#39;[&#39; + &#39;, &#39;.join(optional_params) + &#39;]&#39;)</span>
<span class="w"> </span>    visit_field_name = visit_term
<span class="w"> </span>    depart_field_name = depart_term
<span class="w"> </span>    visit_field_body = visit_definition
<span class="gu">@@ -314,7 +362,7 @@ class LaTeXTranslator(SphinxTranslator):</span>

<span class="w"> </span>    def is_inline(self, node: Element) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Check whether a node represents an inline element.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return isinstance(node, (nodes.inline, nodes.literal, nodes.reference))</span>
<span class="w"> </span>    visit_attention = _visit_named_admonition
<span class="w"> </span>    depart_attention = _depart_named_admonition
<span class="w"> </span>    visit_caution = _visit_named_admonition
<span class="gu">@@ -338,7 +386,7 @@ class LaTeXTranslator(SphinxTranslator):</span>

<span class="w"> </span>    def visit_option_argument(self, node: Element) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;The delimiter between an option and its argument.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.body.append(&#39;=&#39;)</span>


<span class="w"> </span>from sphinx.builders.latex.nodes import HYPERLINK_SUPPORT_NODES, captioned_literal_block, footnotetext
<span class="gh">diff --git a/sphinx/writers/texinfo.py b/sphinx/writers/texinfo.py</span>
<span class="gh">index ff82196df..a3a293868 100644</span>
<span class="gd">--- a/sphinx/writers/texinfo.py</span>
<span class="gi">+++ b/sphinx/writers/texinfo.py</span>
<span class="gu">@@ -71,14 +71,16 @@ TEMPLATE = &quot;&quot;&quot;\\input texinfo   @c -*-texinfo-*-</span>

<span class="w"> </span>def find_subsections(section: Element) -&gt;list[nodes.section]:
<span class="w"> </span>    &quot;&quot;&quot;Return a list of subsections for the given ``section``.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [node for node in section.children if isinstance(node, nodes.section)]</span>


<span class="w"> </span>def smart_capwords(s: str, sep: (str | None)=None) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Like string.capwords() but does not capitalize words that already
<span class="w"> </span>    contain a capital letter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    words = s.split(sep) if sep else s.split()</span>
<span class="gi">+    capitalized = [word.capitalize() if word.islower() else word for word in words]</span>
<span class="gi">+    return (sep or &#39; &#39;).join(capitalized)</span>


<span class="w"> </span>class TexinfoWriter(writers.Writer):
<span class="gu">@@ -144,41 +146,75 @@ class TexinfoTranslator(SphinxTranslator):</span>

<span class="w"> </span>        Assigns the attribute ``node_name`` to each section.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for section in self.document.traverse(nodes.section):</span>
<span class="gi">+            if &#39;ids&#39; in section:</span>
<span class="gi">+                node_id = section[&#39;ids&#39;][0]</span>
<span class="gi">+                node_name = self.escape_id(node_id)</span>
<span class="gi">+                section[&#39;node_name&#39;] = node_name</span>
<span class="gi">+                self.node_names[node_id] = node_name</span>

<span class="w"> </span>    def collect_node_menus(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Collect the menu entries for each &quot;node&quot; section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for section in self.document.traverse(nodes.section):</span>
<span class="gi">+            if &#39;node_name&#39; not in section:</span>
<span class="gi">+                continue</span>
<span class="gi">+            entries = []</span>
<span class="gi">+            for subsection in find_subsections(section):</span>
<span class="gi">+                if &#39;node_name&#39; in subsection:</span>
<span class="gi">+                    title = self.escape_menu(subsection.next_node(nodes.title).astext())</span>
<span class="gi">+                    entries.append((subsection[&#39;node_name&#39;], title))</span>
<span class="gi">+            self.node_menus[section[&#39;node_name&#39;]] = entries</span>

<span class="w"> </span>    def collect_rellinks(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Collect the relative links (next, previous, up) for each &quot;node&quot;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def process_section(section, parent=None):</span>
<span class="gi">+            if &#39;node_name&#39; not in section:</span>
<span class="gi">+                return</span>
<span class="gi">+            node_name = section[&#39;node_name&#39;]</span>
<span class="gi">+            links = [&#39;&#39;, &#39;&#39;, &#39;&#39;]  # next, previous, up</span>
<span class="gi">+            if parent and &#39;node_name&#39; in parent:</span>
<span class="gi">+                links[2] = parent[&#39;node_name&#39;]</span>
<span class="gi">+            subsections = find_subsections(section)</span>
<span class="gi">+            if subsections:</span>
<span class="gi">+                links[0] = subsections[0][&#39;node_name&#39;]</span>
<span class="gi">+            for i, subsection in enumerate(subsections):</span>
<span class="gi">+                if i &gt; 0:</span>
<span class="gi">+                    process_section(subsection, section)</span>
<span class="gi">+                    self.rellinks[subsection[&#39;node_name&#39;]][1] = node_name</span>
<span class="gi">+                if i &lt; len(subsections) - 1:</span>
<span class="gi">+                    self.rellinks[subsection[&#39;node_name&#39;]][0] = subsections[i + 1][&#39;node_name&#39;]</span>
<span class="gi">+            self.rellinks[node_name] = links</span>
<span class="gi">+</span>
<span class="gi">+        process_section(self.document)</span>

<span class="w"> </span>    def escape(self, s: str) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return a string with Texinfo command characters escaped.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return s.replace(&#39;@&#39;, &#39;@@&#39;).replace(&#39;{&#39;, &#39;@{&#39;).replace(&#39;}&#39;, &#39;@}&#39;)</span>

<span class="w"> </span>    def escape_arg(self, s: str) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return an escaped string suitable for use as an argument
<span class="w"> </span>        to a Texinfo command.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return s.replace(&#39;,&#39;, &#39;@comma{}&#39;).replace(&#39;:&#39;, &#39;@colon{}&#39;)</span>

<span class="w"> </span>    def escape_id(self, s: str) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return an escaped string suitable for node names and anchors.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return re.sub(r&#39;[^\w.+-]&#39;, &#39;-&#39;, s)</span>

<span class="w"> </span>    def escape_menu(self, s: str) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return an escaped string suitable for menu entries.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return s.replace(&#39;:&#39;, &#39;@:&#39;).replace(&#39;*&#39;, &#39;@*&#39;).replace(&#39; &#39;, &#39;@w{ }&#39;)</span>

<span class="w"> </span>    def ensure_eol(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Ensure the last line in body is terminated by new line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.body and not self.body[-1].endswith(&#39;\n&#39;):</span>
<span class="gi">+            self.body[-1] += &#39;\n&#39;</span>

<span class="w"> </span>    def get_short_id(self, id: str) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return a shorter &#39;id&#39; associated with ``id``.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if id not in self.short_ids:</span>
<span class="gi">+            self.short_ids[id] = str(len(self.short_ids))</span>
<span class="gi">+        return self.short_ids[id]</span>
<span class="w"> </span>    headings = (&#39;@unnumbered&#39;, &#39;@chapter&#39;, &#39;@section&#39;, &#39;@subsection&#39;,
<span class="w"> </span>        &#39;@subsubsection&#39;)
<span class="w"> </span>    rubrics = &#39;@heading&#39;, &#39;@subheading&#39;, &#39;@subsubheading&#39;
<span class="gh">diff --git a/sphinx/writers/text.py b/sphinx/writers/text.py</span>
<span class="gh">index 2e3317450..6732d2f5e 100644</span>
<span class="gd">--- a/sphinx/writers/text.py</span>
<span class="gi">+++ b/sphinx/writers/text.py</span>
<span class="gu">@@ -101,11 +101,13 @@ class Table:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a row to the table, to use with ``add_cell()``.  It is not needed
<span class="w"> </span>        to call ``add_row()`` before the first ``add_cell()``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.lines.append([])</span>
<span class="gi">+        self.current_line = len(self.lines) - 1</span>
<span class="gi">+        self.current_col = 0</span>

<span class="w"> </span>    def set_separator(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Sets the separator below the current line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.separator = len(self.lines)</span>

<span class="w"> </span>    def add_cell(self, cell: Cell) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add a cell to the current line, to use with ``add_row()``.  To add
<span class="gu">@@ -113,7 +115,10 @@ class Table:</span>
<span class="w"> </span>        ``cell.colspan`` or ``cell.rowspan`` BEFORE inserting it into
<span class="w"> </span>        the table.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while self.current_col &lt; len(self.lines[self.current_line]) and self.lines[self.current_line][self.current_col]:</span>
<span class="gi">+            self.current_col += 1</span>
<span class="gi">+        self[self.current_line, self.current_col] = cell</span>
<span class="gi">+        self.current_col += cell.colspan</span>

<span class="w"> </span>    def __getitem__(self, pos: tuple[int, int]) -&gt;Cell:
<span class="w"> </span>        line, col = pos
<span class="gu">@@ -139,19 +144,27 @@ class Table:</span>
<span class="w"> </span>        ``self.colwidth`` or ``self.measured_widths``).
<span class="w"> </span>        This takes into account cells spanning multiple columns.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        width = sum(source[cell.col:cell.col + cell.colspan])</span>
<span class="gi">+        return width + (cell.colspan - 1) * 3  # Add space for separators</span>

<span class="w"> </span>    def rewrap(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Call ``cell.wrap()`` on all cells, and measure each column width
<span class="w"> </span>        after wrapping (result written in ``self.measured_widths``).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.measured_widths = self.colwidth[:]</span>
<span class="gi">+        for line in self.lines:</span>
<span class="gi">+            for cell in line:</span>
<span class="gi">+                if cell.col == cell.col:  # Only process each cell once</span>
<span class="gi">+                    wrapped = textwrap.wrap(cell.text, width=self.cell_width(cell, self.measured_widths))</span>
<span class="gi">+                    cell.wrapped = wrapped</span>
<span class="gi">+                    if cell.colspan == 1:</span>
<span class="gi">+                        self.measured_widths[cell.col] = max(self.measured_widths[cell.col], max(map(len, wrapped)) if wrapped else 0)</span>

<span class="w"> </span>    def physical_lines_for_line(self, line: list[Cell]) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;For a given line, compute the number of physical lines it spans
<span class="w"> </span>        due to text wrapping.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return max(len(cell.wrapped) for cell in line if cell.row == line.index(cell))</span>

<span class="w"> </span>    def __str__(self) -&gt;str:
<span class="w"> </span>        out = []
<span class="gu">@@ -212,23 +225,78 @@ class TextWrapper(textwrap.TextWrapper):</span>

<span class="w"> </span>        This method respects wide/fullwidth characters for width adjustment.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lines = []</span>
<span class="gi">+        if self.width &lt;= 0:</span>
<span class="gi">+            raise ValueError(&quot;invalid width %r (must be &gt; 0)&quot; % self.width)</span>
<span class="gi">+</span>
<span class="gi">+        chunks.reverse()</span>
<span class="gi">+        while chunks:</span>
<span class="gi">+            cur_line = []</span>
<span class="gi">+            cur_len = 0</span>
<span class="gi">+</span>
<span class="gi">+            if lines:</span>
<span class="gi">+                indent = self.subsequent_indent</span>
<span class="gi">+            else:</span>
<span class="gi">+                indent = self.initial_indent</span>
<span class="gi">+</span>
<span class="gi">+            width = self.width - len(indent)</span>
<span class="gi">+</span>
<span class="gi">+            if self.drop_whitespace and chunks[-1].strip() == &#39;&#39; and lines:</span>
<span class="gi">+                del chunks[-1]</span>
<span class="gi">+</span>
<span class="gi">+            while chunks:</span>
<span class="gi">+                l = column_width(chunks[-1])</span>
<span class="gi">+</span>
<span class="gi">+                if cur_len + l &lt;= width:</span>
<span class="gi">+                    cur_line.append(chunks.pop())</span>
<span class="gi">+                    cur_len += l</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            if chunks and column_width(chunks[-1]) &gt; width:</span>
<span class="gi">+                self._handle_long_word(chunks, cur_line, cur_len, width)</span>
<span class="gi">+</span>
<span class="gi">+            if self.drop_whitespace and cur_line and cur_line[-1].strip() == &#39;&#39;:</span>
<span class="gi">+                del cur_line[-1]</span>
<span class="gi">+</span>
<span class="gi">+            if cur_line:</span>
<span class="gi">+                lines.append(indent + &#39;&#39;.join(cur_line))</span>
<span class="gi">+</span>
<span class="gi">+        return lines</span>

<span class="w"> </span>    def _break_word(self, word: str, space_left: int) -&gt;tuple[str, str]:
<span class="w"> </span>        &quot;&quot;&quot;Break line by unicode width instead of len(word).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        total_width = 0</span>
<span class="gi">+        for i, char in enumerate(word):</span>
<span class="gi">+            char_width = column_width(char)</span>
<span class="gi">+            if total_width + char_width &gt; space_left:</span>
<span class="gi">+                return word[:i], word[i:]</span>
<span class="gi">+            total_width += char_width</span>
<span class="gi">+        return word, &#39;&#39;</span>

<span class="w"> </span>    def _split(self, text: str) -&gt;list[str]:
<span class="w"> </span>        &quot;&quot;&quot;Override original method that only split by &#39;wordsep_re&#39;.

<span class="w"> </span>        This &#39;_split&#39; splits wide-characters into chunks by one character.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        chunks = []</span>
<span class="gi">+        for chunk in self.wordsep_re.split(text):</span>
<span class="gi">+            if column_width(chunk) &gt; 1:</span>
<span class="gi">+                chunks.extend(list(chunk))</span>
<span class="gi">+            else:</span>
<span class="gi">+                chunks.append(chunk)</span>
<span class="gi">+        return [c for c in chunks if c]</span>

<span class="gd">-    def _handle_long_word(self, reversed_chunks: list[str], cur_line: list[</span>
<span class="gd">-        str], cur_len: int, width: int) -&gt;None:</span>
<span class="gi">+    def _handle_long_word(self, reversed_chunks: list[str], cur_line: list[str], cur_len: int, width: int) -&gt;None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override original method for using self._break_word() instead of slice.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        space_left = max(width - cur_len, 1)</span>
<span class="gi">+        if self.break_long_words:</span>
<span class="gi">+            chunk = reversed_chunks[-1]</span>
<span class="gi">+            word_part, remainder = self._break_word(chunk, space_left)</span>
<span class="gi">+            reversed_chunks[-1] = remainder</span>
<span class="gi">+            cur_line.append(word_part)</span>
<span class="gi">+        elif not cur_line:</span>
<span class="gi">+            cur_line.append(reversed_chunks.pop())</span>


<span class="w"> </span>MAXWIDTH = 70
<span class="gh">diff --git a/sphinx/writers/xml.py b/sphinx/writers/xml.py</span>
<span class="gh">index 47b7357a7..4281a5c02 100644</span>
<span class="gd">--- a/sphinx/writers/xml.py</span>
<span class="gi">+++ b/sphinx/writers/xml.py</span>
<span class="gu">@@ -30,4 +30,4 @@ class PseudoXMLWriter(BaseXMLWriter):</span>

<span class="w"> </span>    def supports(self, format: str) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;All format-specific elements are supported.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return format in self.supported</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>