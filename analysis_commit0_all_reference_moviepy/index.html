
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference moviepy - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-moviepy" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference moviepy
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_prpytest_pr_424" class="md-nav__link">
    <span class="md-ellipsis">
      test_PR.py::test_PR_424
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_toolspytest_sys_write_flush" class="md-nav__link">
    <span class="md-ellipsis">
      test_tools.py::test_sys_write_flush
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-moviepy"><strong>Reference (Gold)</strong>: moviepy</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">108</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">110</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">110</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_prpytest_pr_424">test_PR.py::test_PR_424</h3>
<details><summary> <pre>test_PR.py::test_PR_424</pre></summary><pre>
def test_PR_424():
        """Ensure deprecation and user warnings are triggered."""
        import warnings
        warnings.simplefilter('always') # Alert us of deprecation warnings.

        # Recommended use
        ColorClip([1000, 600], color=(60, 60, 60), duration=10).close()

        with pytest.warns(DeprecationWarning):
            # Uses `col` so should work the same as above, but give warning.
            ColorClip([1000, 600], col=(60, 60, 60), duration=10).close()

        # Catch all warnings as record.
>       with pytest.warns(None) as record:

tests/test_PR.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = WarningsChecker(record=True), expected_warning = None, match_expr = None

    def __init__(
        self,
        expected_warning: type[Warning] | tuple[type[Warning], ...] = Warning,
        match_expr: str | Pattern[str] | None = None,
        *,
        _ispytest: bool = False,
    ) -> None:
        check_ispytest(_ispytest)
        super().__init__(_ispytest=True)

        msg = "exceptions must be derived from Warning, not %s"
        if isinstance(expected_warning, tuple):
            for exc in expected_warning:
                if not issubclass(exc, Warning):
                    raise TypeError(msg % type(exc))
            expected_warning_tup = expected_warning
        elif isinstance(expected_warning, type) and issubclass(
            expected_warning, Warning
        ):
            expected_warning_tup = (expected_warning,)
        else:
>           raise TypeError(msg % type(expected_warning))
E           TypeError: exceptions must be derived from Warning, not <class 'NoneType'>

.venv/lib/python3.10/site-packages/_pytest/recwarn.py:280: TypeError
</pre>
</details>
<h3 id="test_toolspytest_sys_write_flush">test_tools.py::test_sys_write_flush</h3>
<details><summary> <pre>test_tools.py::test_sys_write_flush</pre></summary><pre>
def test_sys_write_flush():
        """Test for sys_write-flush function. Check that stdout has no content after flushing."""
        tools.sys_write_flush("hello world")

        file = sys.stdout.read()
>       assert file == b""
E       AssertionError: assert '' == b''

tests/test_tools.py:62: AssertionError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/moviepy/Clip.py b/moviepy/Clip.py</span>
<span class="gh">index 8d3e1b0..24bc3b2 100644</span>
<span class="gd">--- a/moviepy/Clip.py</span>
<span class="gi">+++ b/moviepy/Clip.py</span>
<span class="gu">@@ -3,14 +3,20 @@ This module implements the central object of MoviePy, the Clip, and</span>
<span class="w"> </span>all the methods that are common to the two subclasses of Clip, VideoClip
<span class="w"> </span>and AudioClip.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from copy import copy
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import proglog
<span class="w"> </span>from tqdm import tqdm
<span class="gd">-from moviepy.decorators import apply_to_audio, apply_to_mask, convert_to_seconds, outplace, requires_duration, use_clip_fps_by_default</span>
<span class="gi">+</span>
<span class="gi">+from moviepy.decorators import (apply_to_audio, apply_to_mask,</span>
<span class="gi">+                                convert_to_seconds, outplace,</span>
<span class="gi">+                                requires_duration, use_clip_fps_by_default)</span>


<span class="w"> </span>class Clip:
<span class="gi">+</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>     Base class of all clips (VideoClips and AudioClips).
<span class="gu">@@ -32,12 +38,19 @@ class Clip:</span>
<span class="w"> </span>       this case their duration will be ``None``.

<span class="w"> </span>     &quot;&quot;&quot;
<span class="gi">+   </span>
<span class="gi">+    # prefix for all temporary video and audio files.</span>
<span class="gi">+    # You can overwrite it with </span>
<span class="gi">+    # &gt;&gt;&gt; Clip._TEMP_FILES_PREFIX = &quot;temp_&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>    _TEMP_FILES_PREFIX = &#39;TEMP_MPY_&#39;

<span class="w"> </span>    def __init__(self):
<span class="gi">+</span>
<span class="w"> </span>        self.start = 0
<span class="w"> </span>        self.end = None
<span class="w"> </span>        self.duration = None
<span class="gi">+</span>
<span class="w"> </span>        self.memoize = False
<span class="w"> </span>        self.memoized_t = None
<span class="w"> </span>        self.memoize_frame = None
<span class="gu">@@ -52,7 +65,14 @@ class Clip:</span>
<span class="w"> </span>        there is an outplace transformation of the clip (clip.resize,
<span class="w"> </span>        clip.subclip, etc.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        newclip = copy(self)</span>
<span class="gi">+        if hasattr(self, &#39;audio&#39;):</span>
<span class="gi">+            newclip.audio = copy(self.audio)</span>
<span class="gi">+        if hasattr(self, &#39;mask&#39;):</span>
<span class="gi">+            newclip.mask = copy(self.mask)</span>
<span class="gi">+            </span>
<span class="gi">+        return newclip</span>

<span class="w"> </span>    @convert_to_seconds([&#39;t&#39;])
<span class="w"> </span>    def get_frame(self, t):
<span class="gu">@@ -60,7 +80,17 @@ class Clip:</span>
<span class="w"> </span>        Gets a numpy array representing the RGB picture of the clip at time t
<span class="w"> </span>        or (mono or stereo) value for a sound clip
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Coming soon: smart error handling for debugging at this point</span>
<span class="gi">+        if self.memoize:</span>
<span class="gi">+            if t == self.memoized_t:</span>
<span class="gi">+                return self.memoized_frame</span>
<span class="gi">+            else:</span>
<span class="gi">+                frame = self.make_frame(t)</span>
<span class="gi">+                self.memoized_t = t</span>
<span class="gi">+                self.memoized_frame = frame</span>
<span class="gi">+                return frame</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.make_frame(t)</span>

<span class="w"> </span>    def fl(self, fun, apply_to=None, keep_duration=True):
<span class="w"> </span>        &quot;&quot;&quot; General processing of a clip.
<span class="gu">@@ -99,7 +129,26 @@ class Clip:</span>
<span class="w"> </span>        &gt;&gt;&gt; newclip = clip.fl(fl, apply_to=&#39;mask&#39;)

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if apply_to is None:</span>
<span class="gi">+            apply_to = []</span>
<span class="gi">+</span>
<span class="gi">+        #mf = copy(self.make_frame)</span>
<span class="gi">+        newclip = self.set_make_frame(lambda t: fun(self.get_frame, t))</span>
<span class="gi">+</span>
<span class="gi">+        if not keep_duration:</span>
<span class="gi">+            newclip.duration = None</span>
<span class="gi">+            newclip.end = None</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(apply_to, str):</span>
<span class="gi">+            apply_to = [apply_to]</span>
<span class="gi">+</span>
<span class="gi">+        for attr in apply_to:</span>
<span class="gi">+            a = getattr(newclip, attr, None) </span>
<span class="gi">+            if a is not None:    </span>
<span class="gi">+                new_a = a.fl(fun, keep_duration=keep_duration)</span>
<span class="gi">+                setattr(newclip, attr, new_a)</span>
<span class="gi">+</span>
<span class="gi">+        return newclip</span>

<span class="w"> </span>    def fl_time(self, t_func, apply_to=None, keep_duration=False):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -132,7 +181,11 @@ class Clip:</span>
<span class="w"> </span>        &gt;&gt;&gt; newclip = clip.fl_time(lambda: 3-t)

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if apply_to is None:</span>
<span class="gi">+            apply_to = []</span>
<span class="gi">+</span>
<span class="gi">+        return self.fl(lambda gf, t: gf(t_func(t)), apply_to,</span>
<span class="gi">+                       keep_duration=keep_duration)</span>

<span class="w"> </span>    def fx(self, func, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -155,7 +208,10 @@ class Clip:</span>
<span class="w"> </span>        &gt;&gt;&gt; resize( volumex( mirrorx( clip ), 0.5), 0.3)

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        return func(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+</span>

<span class="w"> </span>    @apply_to_mask
<span class="w"> </span>    @apply_to_audio
<span class="gu">@@ -179,7 +235,14 @@ class Clip:</span>
<span class="w"> </span>        These changes are also applied to the ``audio`` and ``mask``
<span class="w"> </span>        clips of the current clip, if they exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self.start = t</span>
<span class="gi">+        if (self.duration is not None) and change_end:</span>
<span class="gi">+            self.end = t + self.duration</span>
<span class="gi">+        elif self.end is not None:</span>
<span class="gi">+            self.duration = self.end - self.start</span>
<span class="gi">+</span>
<span class="gi">+</span>

<span class="w"> </span>    @apply_to_mask
<span class="w"> </span>    @apply_to_audio
<span class="gu">@@ -193,7 +256,15 @@ class Clip:</span>
<span class="w"> </span>        Also sets the duration of the mask and audio, if any,
<span class="w"> </span>        of the returned clip.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.end = t</span>
<span class="gi">+        if self.end is None: return</span>
<span class="gi">+        if self.start is None:</span>
<span class="gi">+            if self.duration is not None:</span>
<span class="gi">+                self.start = max(0, t - newclip.duration)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.duration = self.end - self.start</span>
<span class="gi">+</span>
<span class="gi">+</span>

<span class="w"> </span>    @apply_to_mask
<span class="w"> </span>    @apply_to_audio
<span class="gu">@@ -210,7 +281,16 @@ class Clip:</span>
<span class="w"> </span>        be modified in function of the duration and the preset end
<span class="w"> </span>        of the clip.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.duration = t</span>
<span class="gi">+</span>
<span class="gi">+        if change_end:</span>
<span class="gi">+            self.end = None if (t is None) else (self.start + t)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.duration is None:</span>
<span class="gi">+                raise Exception(&quot;Cannot change clip start when new&quot;</span>
<span class="gi">+                                &quot;duration is None&quot;)</span>
<span class="gi">+            self.start = self.end - t</span>
<span class="gi">+</span>

<span class="w"> </span>    @outplace
<span class="w"> </span>    def set_make_frame(self, make_frame):
<span class="gu">@@ -218,23 +298,24 @@ class Clip:</span>
<span class="w"> </span>        Sets a ``make_frame`` attribute for the clip. Useful for setting
<span class="w"> </span>        arbitrary/complicated videoclips.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.make_frame = make_frame</span>

<span class="w"> </span>    @outplace
<span class="w"> </span>    def set_fps(self, fps):
<span class="w"> </span>        &quot;&quot;&quot; Returns a copy of the clip with a new default fps for functions like
<span class="w"> </span>        write_videofile, iterframe, etc. &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.fps = fps</span>
<span class="gi">+</span>

<span class="w"> </span>    @outplace
<span class="w"> </span>    def set_ismask(self, ismask):
<span class="w"> </span>        &quot;&quot;&quot; Says wheter the clip is a mask or not (ismask is a boolean)&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.ismask = ismask</span>

<span class="w"> </span>    @outplace
<span class="w"> </span>    def set_memoize(self, memoize):
<span class="w"> </span>        &quot;&quot;&quot; Sets wheter the clip should keep the last frame read in memory &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.memoize = memoize</span>

<span class="w"> </span>    @convert_to_seconds([&#39;t&#39;])
<span class="w"> </span>    def is_playing(self, t):
<span class="gu">@@ -247,7 +328,28 @@ class Clip:</span>
<span class="w"> </span>        theclip, else returns a vector [b_1, b_2, b_3...] where b_i
<span class="w"> </span>        is true iff tti is in the clip.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(t, np.ndarray):</span>
<span class="gi">+            # is the whole list of t outside the clip ?</span>
<span class="gi">+            tmin, tmax = t.min(), t.max()</span>
<span class="gi">+</span>
<span class="gi">+            if (self.end is not None) and (tmin &gt;= self.end):</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+            if tmax &lt; self.start:</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+            # If we arrive here, a part of t falls in the clip</span>
<span class="gi">+            result = 1 * (t &gt;= self.start)</span>
<span class="gi">+            if self.end is not None:</span>
<span class="gi">+                result *= (t &lt;= self.end)</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            return((t &gt;= self.start) and</span>
<span class="gi">+                   ((self.end is None) or (t &lt; self.end)))</span>
<span class="gi">+</span>

<span class="w"> </span>    @convert_to_seconds([&#39;t_start&#39;, &#39;t_end&#39;])
<span class="w"> </span>    @apply_to_mask
<span class="gu">@@ -273,7 +375,41 @@ class Clip:</span>
<span class="w"> </span>        subclips of ``mask`` and ``audio`` the original clip, if
<span class="w"> </span>        they exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if t_start &lt; 0:</span>
<span class="gi">+            # Make this more Python-like, a negative value means to move</span>
<span class="gi">+            # backward from the end of the clip</span>
<span class="gi">+            t_start = self.duration + t_start   # Remember t_start is negative</span>
<span class="gi">+</span>
<span class="gi">+        if (self.duration is not None) and (t_start &gt; self.duration):</span>
<span class="gi">+            raise ValueError(&quot;t_start (%.02f) &quot; % t_start +</span>
<span class="gi">+                             &quot;should be smaller than the clip&#39;s &quot; +</span>
<span class="gi">+                             &quot;duration (%.02f).&quot; % self.duration)</span>
<span class="gi">+</span>
<span class="gi">+        newclip = self.fl_time(lambda t: t + t_start, apply_to=[])</span>
<span class="gi">+</span>
<span class="gi">+        if (t_end is None) and (self.duration is not None):</span>
<span class="gi">+</span>
<span class="gi">+            t_end = self.duration</span>
<span class="gi">+</span>
<span class="gi">+        elif (t_end is not None) and (t_end &lt; 0):</span>
<span class="gi">+</span>
<span class="gi">+            if self.duration is None:</span>
<span class="gi">+</span>
<span class="gi">+                print(&quot;Error: subclip with negative times (here %s)&quot; % (str((t_start, t_end)))</span>
<span class="gi">+                      + &quot; can only be extracted from clips with a ``duration``&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+</span>
<span class="gi">+                t_end = self.duration + t_end</span>
<span class="gi">+</span>
<span class="gi">+        if t_end is not None:</span>
<span class="gi">+</span>
<span class="gi">+            newclip.duration = t_end - t_start</span>
<span class="gi">+            newclip.end = newclip.start + newclip.duration</span>
<span class="gi">+</span>
<span class="gi">+        return newclip</span>
<span class="gi">+</span>

<span class="w"> </span>    @apply_to_mask
<span class="w"> </span>    @apply_to_audio
<span class="gu">@@ -291,11 +427,22 @@ class Clip:</span>
<span class="w"> </span>        The resulting clip&#39;s ``audio`` and ``mask`` will also be cutout
<span class="w"> </span>        if they exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        fl = lambda t: t + (t &gt;= ta)*(tb - ta)</span>
<span class="gi">+        newclip = self.fl_time(fl)</span>
<span class="gi">+</span>
<span class="gi">+        if self.duration is not None:</span>
<span class="gi">+</span>
<span class="gi">+            return newclip.set_duration(self.duration - (tb - ta))</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            return newclip</span>

<span class="w"> </span>    @requires_duration
<span class="w"> </span>    @use_clip_fps_by_default
<span class="gd">-    def iter_frames(self, fps=None, with_times=False, logger=None, dtype=None):</span>
<span class="gi">+    def iter_frames(self, fps=None, with_times = False, logger=None,</span>
<span class="gi">+                    dtype=None):</span>
<span class="w"> </span>        &quot;&quot;&quot; Iterates over all the frames of the clip.

<span class="w"> </span>        Returns each frame of the clip as a HxWxN np.array,
<span class="gu">@@ -320,14 +467,33 @@ class Clip:</span>
<span class="w"> </span>        &gt;&gt;&gt; print ( [frame[0,:,0].max()
<span class="w"> </span>                     for frame in myclip.iter_frames()])
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+        for t in logger.iter_bar(t=np.arange(0, self.duration, 1.0/fps)):</span>
<span class="gi">+            frame = self.get_frame(t)</span>
<span class="gi">+            if (dtype is not None) and (frame.dtype != dtype):</span>
<span class="gi">+                frame = frame.astype(dtype)</span>
<span class="gi">+            if with_times:</span>
<span class="gi">+                yield t, frame</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield frame</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot; 
<span class="w"> </span>            Release any resources that are in use.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+        #    Implementation note for subclasses:</span>
<span class="gi">+        #</span>
<span class="gi">+        #    * Memory-based resources can be left to the garbage-collector.</span>
<span class="gi">+        #    * However, any open files should be closed, and subprocesses</span>
<span class="gi">+        #      should be terminated.</span>
<span class="gi">+        #    * Be wary that shallow copies are frequently used.</span>
<span class="gi">+        #      Closing a Clip may affect its copies.</span>
<span class="gi">+        #    * Therefore, should NOT be called by __del__().</span>
<span class="w"> </span>        pass

<span class="gi">+    # Support the Context Manager protocol, to ensure that resources are cleaned up.</span>
<span class="gi">+</span>
<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self

<span class="gh">diff --git a/moviepy/audio/AudioClip.py b/moviepy/audio/AudioClip.py</span>
<span class="gh">index 350c197..122d9b2 100644</span>
<span class="gd">--- a/moviepy/audio/AudioClip.py</span>
<span class="gi">+++ b/moviepy/audio/AudioClip.py</span>
<span class="gu">@@ -1,7 +1,9 @@</span>
<span class="w"> </span>import os
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import proglog
<span class="w"> </span>from tqdm import tqdm
<span class="gi">+</span>
<span class="w"> </span>from moviepy.audio.io.ffmpeg_audiowriter import ffmpeg_audiowrite
<span class="w"> </span>from moviepy.Clip import Clip
<span class="w"> </span>from moviepy.decorators import requires_duration
<span class="gu">@@ -41,11 +43,13 @@ class AudioClip(Clip):</span>
<span class="w"> </span>    &gt;&gt;&gt; clip.preview()

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="gi">+    </span>
<span class="w"> </span>    def __init__(self, make_frame=None, duration=None, fps=None):
<span class="w"> </span>        Clip.__init__(self)
<span class="gi">+</span>
<span class="w"> </span>        if fps is not None:
<span class="w"> </span>            self.fps = fps
<span class="gi">+</span>
<span class="w"> </span>        if make_frame is not None:
<span class="w"> </span>            self.make_frame = make_frame
<span class="w"> </span>            frame0 = self.get_frame(0)
<span class="gu">@@ -56,17 +60,33 @@ class AudioClip(Clip):</span>
<span class="w"> </span>        if duration is not None:
<span class="w"> </span>            self.duration = duration
<span class="w"> </span>            self.end = duration
<span class="gd">-</span>
<span class="gi">+    </span>
<span class="w"> </span>    @requires_duration
<span class="w"> </span>    def iter_chunks(self, chunksize=None, chunk_duration=None, fps=None,
<span class="gd">-        quantize=False, nbytes=2, logger=None):</span>
<span class="gi">+                    quantize=False, nbytes=2, logger=None):</span>
<span class="w"> </span>        &quot;&quot;&quot; Iterator that returns the whole sound array of the clip by chunks
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fps is None:</span>
<span class="gi">+            fps = self.fps</span>
<span class="gi">+        logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+        if chunk_duration is not None:</span>
<span class="gi">+            chunksize = int(chunk_duration*fps)</span>
<span class="gi">+        </span>
<span class="gi">+        totalsize = int(fps*self.duration)</span>
<span class="gi">+</span>
<span class="gi">+        nchunks = totalsize // chunksize + 1</span>
<span class="gi">+</span>
<span class="gi">+        pospos = np.linspace(0, totalsize, nchunks + 1, endpoint=True, dtype=int)</span>
<span class="gi">+        </span>
<span class="gi">+        for i in logger.iter_bar(chunk=list(range(nchunks))):</span>
<span class="gi">+            size = pospos[i+1] - pospos[i]</span>
<span class="gi">+            assert(size &lt;= chunksize)</span>
<span class="gi">+            tt = (1.0/fps)*np.arange(pospos[i], pospos[i+1])</span>
<span class="gi">+            yield self.to_soundarray(tt, nbytes=nbytes, quantize=quantize,</span>
<span class="gi">+                                        fps=fps, buffersize=chunksize)</span>

<span class="w"> </span>    @requires_duration
<span class="gd">-    def to_soundarray(self, tt=None, fps=None, quantize=False, nbytes=2,</span>
<span class="gd">-        buffersize=50000):</span>
<span class="gi">+    def to_soundarray(self, tt=None, fps=None, quantize=False, nbytes=2, buffersize=50000):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Transforms the sound into an array that can be played by pygame
<span class="w"> </span>        or written in a wav file. See ``AudioClip.preview``.
<span class="gu">@@ -83,12 +103,49 @@ class AudioClip(Clip):</span>
<span class="w"> </span>          2 for 16bit, 4 for 32bit sound.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fps is None:</span>
<span class="gi">+            fps = self.fps</span>
<span class="gi">+       </span>
<span class="gi">+        stacker = np.vstack if self.nchannels == 2 else np.hstack</span>
<span class="gi">+        max_duration = 1.0 * buffersize / fps</span>
<span class="gi">+        if tt is None:</span>
<span class="gi">+            if self.duration &gt; max_duration:</span>
<span class="gi">+                return stacker(self.iter_chunks(fps=fps, quantize=quantize,</span>
<span class="gi">+                                                nbytes=2, chunksize=buffersize))</span>
<span class="gi">+            else:</span>
<span class="gi">+                tt = np.arange(0, self.duration, 1.0/fps)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        elif len(tt)&gt; 1.5*buffersize:</span>
<span class="gi">+            nchunks = int(len(tt)/buffersize+1)</span>
<span class="gi">+            tt_chunks = np.array_split(tt, nchunks)</span>
<span class="gi">+            return stacker([self.to_soundarray(tt=ttc, buffersize=buffersize, fps=fps,</span>
<span class="gi">+                                        quantize=quantize, nbytes=nbytes)</span>
<span class="gi">+                              for ttc in tt_chunks])</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        #print tt.max() - tt.min(), tt.min(), tt.max()</span>
<span class="gi">+        </span>
<span class="gi">+        snd_array = self.get_frame(tt)</span>
<span class="gi">+</span>
<span class="gi">+        if quantize:</span>
<span class="gi">+            snd_array = np.maximum(-0.99, np.minimum(0.99, snd_array))</span>
<span class="gi">+            inttype = {1: &#39;int8&#39;, 2: &#39;int16&#39;, 4: &#39;int32&#39;}[nbytes]</span>
<span class="gi">+            snd_array = (2**(8*nbytes-1)*snd_array).astype(inttype)</span>
<span class="gi">+        </span>
<span class="gi">+        return snd_array</span>
<span class="gi">+</span>
<span class="gi">+    def max_volume(self, stereo=False, chunksize=50000, logger=None):</span>
<span class="gi">+        </span>
<span class="gi">+        stereo = stereo and (self.nchannels == 2)</span>
<span class="gi">+</span>
<span class="gi">+        maxi = np.array([0, 0]) if stereo else 0</span>
<span class="gi">+        for chunk in self.iter_chunks(chunksize=chunksize,logger=logger):</span>
<span class="gi">+            maxi = np.maximum(maxi, abs(chunk).max(axis=0)) if stereo else max(maxi, abs(chunk).max())</span>
<span class="gi">+        return maxi</span>

<span class="w"> </span>    @requires_duration
<span class="w"> </span>    def write_audiofile(self, filename, fps=None, nbytes=2, buffersize=2000,
<span class="gd">-        codec=None, bitrate=None, ffmpeg_params=None, write_logfile=False,</span>
<span class="gd">-        verbose=True, logger=&#39;bar&#39;):</span>
<span class="gi">+                        codec=None, bitrate=None, ffmpeg_params=None,</span>
<span class="gi">+                        write_logfile=False, verbose=True, logger=&#39;bar&#39;):</span>
<span class="w"> </span>        &quot;&quot;&quot; Writes an audio file from the AudioClip.


<span class="gu">@@ -131,11 +188,32 @@ class AudioClip(Clip):</span>
<span class="w"> </span>          Either &#39;bar&#39; or None or any Proglog logger

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not fps:</span>
<span class="gi">+            if not self.fps:</span>
<span class="gi">+                fps = 44100</span>
<span class="gi">+            else:</span>
<span class="gi">+                fps = self.fps</span>
<span class="gi">+</span>
<span class="gi">+        if codec is None:</span>
<span class="gi">+            name, ext = os.path.splitext(os.path.basename(filename))</span>
<span class="gi">+            try:</span>
<span class="gi">+                codec = extensions_dict[ext[1:]][&#39;codec&#39;][0]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                raise ValueError(&quot;MoviePy couldn&#39;t find the codec associated &quot;</span>
<span class="gi">+                                 &quot;with the filename. Provide the &#39;codec&#39; &quot;</span>
<span class="gi">+                                 &quot;parameter in write_audiofile.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return ffmpeg_audiowrite(self, filename, fps, nbytes, buffersize,</span>
<span class="gi">+                                 codec=codec, bitrate=bitrate,</span>
<span class="gi">+                                 write_logfile=write_logfile, verbose=verbose,</span>
<span class="gi">+                                 ffmpeg_params=ffmpeg_params,</span>
<span class="gi">+                                 logger=logger)</span>


<span class="gi">+# The to_audiofile method is replaced by the more explicit write_audiofile.</span>
<span class="w"> </span>AudioClip.to_audiofile = deprecated_version_of(AudioClip.write_audiofile,
<span class="gd">-    &#39;to_audiofile&#39;)</span>
<span class="gi">+                                               &#39;to_audiofile&#39;)</span>
<span class="gi">+###</span>


<span class="w"> </span>class AudioArrayClip(AudioClip):
<span class="gu">@@ -155,8 +233,9 @@ class AudioArrayClip(AudioClip):</span>
<span class="w"> </span>      played.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="gi">+    </span>
<span class="w"> </span>    def __init__(self, array, fps):
<span class="gi">+        </span>
<span class="w"> </span>        Clip.__init__(self)
<span class="w"> </span>        self.array = array
<span class="w"> </span>        self.fps = fps
<span class="gu">@@ -165,8 +244,9 @@ class AudioArrayClip(AudioClip):</span>
<span class="w"> </span>        def make_frame(t):
<span class="w"> </span>            &quot;&quot;&quot; complicated, but must be able to handle the case where t
<span class="w"> </span>            is a list of the form sin(t) &quot;&quot;&quot;
<span class="gi">+            </span>
<span class="w"> </span>            if isinstance(t, np.ndarray):
<span class="gd">-                array_inds = (self.fps * t).astype(int)</span>
<span class="gi">+                array_inds = (self.fps*t).astype(int)</span>
<span class="w"> </span>                in_array = (array_inds &gt; 0) &amp; (array_inds &lt; len(self.array))
<span class="w"> </span>                result = np.zeros((len(t), 2))
<span class="w"> </span>                result[in_array] = self.array[array_inds[in_array]]
<span class="gu">@@ -174,14 +254,16 @@ class AudioArrayClip(AudioClip):</span>
<span class="w"> </span>            else:
<span class="w"> </span>                i = int(self.fps * t)
<span class="w"> </span>                if i &lt; 0 or i &gt;= len(self.array):
<span class="gd">-                    return 0 * self.array[0]</span>
<span class="gi">+                    return 0*self.array[0]</span>
<span class="w"> </span>                else:
<span class="w"> </span>                    return self.array[i]
<span class="gi">+</span>
<span class="w"> </span>        self.make_frame = make_frame
<span class="w"> </span>        self.nchannels = len(list(self.get_frame(0)))
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+        </span>
<span class="gi">+        </span>
<span class="w"> </span>class CompositeAudioClip(AudioClip):
<span class="gi">+</span>
<span class="w"> </span>    &quot;&quot;&quot; Clip made by composing several AudioClips.

<span class="w"> </span>    An audio clip made by putting together several audio clips.
<span class="gu">@@ -197,8 +279,10 @@ class CompositeAudioClip(AudioClip):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, clips):
<span class="gi">+</span>
<span class="w"> </span>        Clip.__init__(self)
<span class="w"> </span>        self.clips = clips
<span class="gi">+        </span>
<span class="w"> </span>        ends = [c.end for c in self.clips]
<span class="w"> </span>        self.nchannels = max([c.nchannels for c in self.clips])
<span class="w"> </span>        if not any([(e is None) for e in ends]):
<span class="gu">@@ -206,14 +290,21 @@ class CompositeAudioClip(AudioClip):</span>
<span class="w"> </span>            self.end = max(ends)

<span class="w"> </span>        def make_frame(t):
<span class="gi">+            </span>
<span class="w"> </span>            played_parts = [c.is_playing(t) for c in self.clips]
<span class="gd">-            sounds = [(c.get_frame(t - c.start) * np.array([part]).T) for c,</span>
<span class="gd">-                part in zip(self.clips, played_parts) if part is not False]</span>
<span class="gi">+            </span>
<span class="gi">+            sounds = [c.get_frame(t - c.start)*np.array([part]).T</span>
<span class="gi">+                      for c, part in zip(self.clips, played_parts)</span>
<span class="gi">+                      if (part is not False)]</span>
<span class="gi">+                     </span>
<span class="w"> </span>            if isinstance(t, np.ndarray):
<span class="w"> </span>                zero = np.zeros((len(t), self.nchannels))
<span class="gi">+                </span>
<span class="w"> </span>            else:
<span class="w"> </span>                zero = np.zeros(self.nchannels)
<span class="gi">+                </span>
<span class="w"> </span>            return zero + sum(sounds)
<span class="gi">+</span>
<span class="w"> </span>        self.make_frame = make_frame


<span class="gu">@@ -221,4 +312,12 @@ def concatenate_audioclips(clips):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The clip with the highest FPS will be the FPS of the result clip.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    durations = [c.duration for c in clips]</span>
<span class="gi">+    tt = np.cumsum([0]+durations)  # start times, and end time.</span>
<span class="gi">+    newclips = [c.set_start(t) for c, t in zip(clips, tt)]</span>
<span class="gi">+</span>
<span class="gi">+    result = CompositeAudioClip(newclips).set_duration(tt[-1])</span>
<span class="gi">+</span>
<span class="gi">+    fpss = [c.fps for c in clips if getattr(c, &#39;fps&#39;, None)]</span>
<span class="gi">+    result.fps = max(fpss) if fpss else None</span>
<span class="gi">+    return result</span>
<span class="gh">diff --git a/moviepy/audio/fx/audio_fadein.py b/moviepy/audio/fx/audio_fadein.py</span>
<span class="gh">index d7d564e..20b1eed 100644</span>
<span class="gd">--- a/moviepy/audio/fx/audio_fadein.py</span>
<span class="gi">+++ b/moviepy/audio/fx/audio_fadein.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>from moviepy.decorators import audio_video_fx


<span class="gu">@@ -6,4 +7,15 @@ from moviepy.decorators import audio_video_fx</span>
<span class="w"> </span>def audio_fadein(clip, duration):
<span class="w"> </span>    &quot;&quot;&quot; Return an audio (or video) clip that is first mute, then the
<span class="w"> </span>        sound arrives progressively over ``duration`` seconds. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+        </span>
<span class="gi">+    def fading(gf,t):</span>
<span class="gi">+        gft = gf(t)</span>
<span class="gi">+        </span>
<span class="gi">+        if np.isscalar(t):</span>
<span class="gi">+            factor = min(1.0 * t / duration, 1)</span>
<span class="gi">+            factor = np.array([factor,factor])</span>
<span class="gi">+        else:</span>
<span class="gi">+            factor = np.minimum(1.0 * t / duration, 1)</span>
<span class="gi">+            factor = np.vstack([factor,factor]).T</span>
<span class="gi">+        return factor * gft</span>
<span class="gi">+    return clip.fl(fading, keep_duration = True)</span>
<span class="gh">diff --git a/moviepy/audio/fx/audio_fadeout.py b/moviepy/audio/fx/audio_fadeout.py</span>
<span class="gh">index 557d1aa..ab6f40e 100644</span>
<span class="gd">--- a/moviepy/audio/fx/audio_fadeout.py</span>
<span class="gi">+++ b/moviepy/audio/fx/audio_fadeout.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>from moviepy.decorators import audio_video_fx, requires_duration


<span class="gu">@@ -7,4 +8,16 @@ from moviepy.decorators import audio_video_fx, requires_duration</span>
<span class="w"> </span>def audio_fadeout(clip, duration):
<span class="w"> </span>    &quot;&quot;&quot; Return a sound clip where the sound fades out progressively
<span class="w"> </span>        over ``duration`` seconds at the end of the clip. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    def fading(gf,t):</span>
<span class="gi">+        gft = gf(t)</span>
<span class="gi">+        </span>
<span class="gi">+        if np.isscalar(t):</span>
<span class="gi">+            factor = min(1.0 * (clip.duration - t) / duration, 1)</span>
<span class="gi">+            factor = np.array([factor,factor])</span>
<span class="gi">+        else:</span>
<span class="gi">+            factor = np.minimum( 1.0 * (clip.duration - t) / duration, 1)</span>
<span class="gi">+            factor = np.vstack([factor,factor]).T</span>
<span class="gi">+        return factor * gft</span>
<span class="gi">+    </span>
<span class="gi">+    return clip.fl(fading, keep_duration = True)</span>
<span class="gh">diff --git a/moviepy/audio/fx/audio_left_right.py b/moviepy/audio/fx/audio_left_right.py</span>
<span class="gh">index b09d9cc..c98abcc 100644</span>
<span class="gd">--- a/moviepy/audio/fx/audio_left_right.py</span>
<span class="gi">+++ b/moviepy/audio/fx/audio_left_right.py</span>
<span class="gu">@@ -11,4 +11,5 @@ def audio_left_right(audioclip, left=1, right=1, merge=False):</span>
<span class="w"> </span>    Makes a stereo audio clip in which the volume of left and right
<span class="w"> </span>    is controllable
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    funleft = (lambda t: left) if np.isscalar(left) else left</span>
<span class="gi">+    funright = (lambda t: right) if np.isscalar(right) else right</span>
<span class="gh">diff --git a/moviepy/audio/fx/audio_loop.py b/moviepy/audio/fx/audio_loop.py</span>
<span class="gh">index cb07e52..7e309b7 100644</span>
<span class="gd">--- a/moviepy/audio/fx/audio_loop.py</span>
<span class="gi">+++ b/moviepy/audio/fx/audio_loop.py</span>
<span class="gu">@@ -17,4 +17,12 @@ def audio_loop(audioclip, nloops=None, duration=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; videoclip.set_audio(audio)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if duration is not None:</span>
<span class="gi">+</span>
<span class="gi">+        nloops = int( duration/ audioclip.duration)+1</span>
<span class="gi">+        return concatenate_audioclips(nloops*[audioclip]).set_duration(duration)</span>
<span class="gi">+    </span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        return concatenate_audioclips(nloops*[audioclip])</span>
<span class="gh">diff --git a/moviepy/audio/fx/audio_normalize.py b/moviepy/audio/fx/audio_normalize.py</span>
<span class="gh">index 7849aa6..0c4daff 100644</span>
<span class="gd">--- a/moviepy/audio/fx/audio_normalize.py</span>
<span class="gi">+++ b/moviepy/audio/fx/audio_normalize.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from moviepy.decorators import audio_video_fx
<span class="gi">+</span>
<span class="w"> </span>from .volumex import volumex


<span class="gu">@@ -16,4 +17,7 @@ def audio_normalize(clip):</span>
<span class="w"> </span>    &gt;&gt;&gt; videoclip = VideoFileClip(&#39;myvideo.mp4&#39;).fx(afx.audio_normalize)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    mv = clip.max_volume()</span>
<span class="gi">+    return volumex(clip, 1 / mv)</span>
<span class="gh">diff --git a/moviepy/audio/fx/volumex.py b/moviepy/audio/fx/volumex.py</span>
<span class="gh">index 573b48a..6ec84ad 100644</span>
<span class="gd">--- a/moviepy/audio/fx/volumex.py</span>
<span class="gi">+++ b/moviepy/audio/fx/volumex.py</span>
<span class="gu">@@ -16,4 +16,5 @@ def volumex(clip, factor):</span>
<span class="w"> </span>    &gt;&gt;&gt; newclip = clip.fx( volumex, 0.5) # half audio, use with fx
<span class="w"> </span>    &gt;&gt;&gt; newclip = clip.volumex(2) # only if you used &quot;moviepy.editor&quot;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return clip.fl(lambda gf, t: factor * gf(t),</span>
<span class="gi">+                   keep_duration=True)</span>
<span class="gh">diff --git a/moviepy/audio/io/AudioFileClip.py b/moviepy/audio/io/AudioFileClip.py</span>
<span class="gh">index 4c0ca37..b79ab23 100644</span>
<span class="gd">--- a/moviepy/audio/io/AudioFileClip.py</span>
<span class="gi">+++ b/moviepy/audio/io/AudioFileClip.py</span>
<span class="gu">@@ -1,9 +1,11 @@</span>
<span class="w"> </span>from __future__ import division
<span class="gi">+</span>
<span class="w"> </span>from moviepy.audio.AudioClip import AudioClip
<span class="w"> </span>from moviepy.audio.io.readers import FFMPEG_AudioReader


<span class="w"> </span>class AudioFileClip(AudioClip):
<span class="gi">+</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    An audio clip read from a sound file, or an array.
<span class="w"> </span>    The whole file is not loaded in memory. Instead, only a portion is
<span class="gu">@@ -61,14 +63,17 @@ class AudioFileClip(AudioClip):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, filename, buffersize=200000, nbytes=2, fps=44100):
<span class="gi">+</span>
<span class="w"> </span>        AudioClip.__init__(self)
<span class="gi">+</span>
<span class="w"> </span>        self.filename = filename
<span class="w"> </span>        self.reader = FFMPEG_AudioReader(filename, fps=fps, nbytes=nbytes,
<span class="gd">-            buffersize=buffersize)</span>
<span class="gi">+                                         buffersize=buffersize)</span>
<span class="w"> </span>        self.fps = fps
<span class="w"> </span>        self.duration = self.reader.duration
<span class="w"> </span>        self.end = self.reader.duration
<span class="w"> </span>        self.buffersize = self.reader.buffersize
<span class="gi">+</span>
<span class="w"> </span>        self.make_frame = lambda t: self.reader.get_frame(t)
<span class="w"> </span>        self.nchannels = self.reader.nchannels

<span class="gu">@@ -76,8 +81,10 @@ class AudioFileClip(AudioClip):</span>
<span class="w"> </span>        &quot;&quot;&quot; Returns a copy of the AudioFileClip, i.e. a new entrance point
<span class="w"> </span>            to the audio file. Use copy when you have different clips
<span class="w"> </span>            watching the audio file at different times. &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AudioFileClip(self.filename, self.buffersize)</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot; Close the internal reader. &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.reader:</span>
<span class="gi">+            self.reader.close_proc()</span>
<span class="gi">+            self.reader = None</span>
<span class="gh">diff --git a/moviepy/audio/io/ffmpeg_audiowriter.py b/moviepy/audio/io/ffmpeg_audiowriter.py</span>
<span class="gh">index 9501306..d02649f 100644</span>
<span class="gd">--- a/moviepy/audio/io/ffmpeg_audiowriter.py</span>
<span class="gi">+++ b/moviepy/audio/io/ffmpeg_audiowriter.py</span>
<span class="gu">@@ -1,6 +1,8 @@</span>
<span class="w"> </span>import os
<span class="w"> </span>import subprocess as sp
<span class="gi">+</span>
<span class="w"> </span>import proglog
<span class="gi">+</span>
<span class="w"> </span>from moviepy.compat import DEVNULL
<span class="w"> </span>from moviepy.config import get_setting
<span class="w"> </span>from moviepy.decorators import requires_duration
<span class="gu">@@ -32,29 +34,105 @@ class FFMPEG_AudioWriter:</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, filename, fps_input, nbytes=2, nchannels=2, codec=</span>
<span class="gd">-        &#39;libfdk_aac&#39;, bitrate=None, input_video=None, logfile=None,</span>
<span class="gd">-        ffmpeg_params=None):</span>
<span class="gi">+    def __init__(self, filename, fps_input, nbytes=2,</span>
<span class="gi">+                 nchannels=2, codec=&#39;libfdk_aac&#39;, bitrate=None,</span>
<span class="gi">+                 input_video=None, logfile=None, ffmpeg_params=None):</span>
<span class="gi">+</span>
<span class="w"> </span>        self.filename = filename
<span class="w"> </span>        self.codec = codec
<span class="gi">+</span>
<span class="w"> </span>        if logfile is None:
<span class="w"> </span>            logfile = sp.PIPE
<span class="gd">-        cmd = [get_setting(&#39;FFMPEG_BINARY&#39;), &#39;-y&#39;, &#39;-loglevel&#39;, &#39;error&#39; if </span>
<span class="gd">-            logfile == sp.PIPE else &#39;info&#39;, &#39;-f&#39;, &#39;s%dle&#39; % (8 * nbytes),</span>
<span class="gd">-            &#39;-acodec&#39;, &#39;pcm_s%dle&#39; % (8 * nbytes), &#39;-ar&#39;, &#39;%d&#39; % fps_input,</span>
<span class="gd">-            &#39;-ac&#39;, &#39;%d&#39; % nchannels, &#39;-i&#39;, &#39;-&#39;] + ([&#39;-vn&#39;] if input_video is</span>
<span class="gd">-            None else [&#39;-i&#39;, input_video, &#39;-vcodec&#39;, &#39;copy&#39;]) + [&#39;-acodec&#39;,</span>
<span class="gd">-            codec] + [&#39;-ar&#39;, &#39;%d&#39; % fps_input] + [&#39;-strict&#39;, &#39;-2&#39;] + ([</span>
<span class="gd">-            &#39;-ab&#39;, bitrate] if bitrate is not None else []) + (ffmpeg_params if</span>
<span class="gd">-            ffmpeg_params else []) + [filename]</span>
<span class="gd">-        popen_params = {&#39;stdout&#39;: DEVNULL, &#39;stderr&#39;: logfile, &#39;stdin&#39;: sp.PIPE}</span>
<span class="gd">-        if os.name == &#39;nt&#39;:</span>
<span class="gd">-            popen_params[&#39;creationflags&#39;] = 134217728</span>
<span class="gi">+</span>
<span class="gi">+        cmd = ([get_setting(&quot;FFMPEG_BINARY&quot;), &#39;-y&#39;,</span>
<span class="gi">+                &quot;-loglevel&quot;, &quot;error&quot; if logfile == sp.PIPE else &quot;info&quot;,</span>
<span class="gi">+                &quot;-f&quot;, &#39;s%dle&#39; % (8*nbytes),</span>
<span class="gi">+                &quot;-acodec&quot;,&#39;pcm_s%dle&#39; % (8*nbytes),</span>
<span class="gi">+                &#39;-ar&#39;, &quot;%d&quot; % fps_input,</span>
<span class="gi">+                &#39;-ac&#39;, &quot;%d&quot; % nchannels,</span>
<span class="gi">+                &#39;-i&#39;, &#39;-&#39;]</span>
<span class="gi">+               + ([&#39;-vn&#39;] if input_video is None else [&quot;-i&quot;, input_video, &#39;-vcodec&#39;, &#39;copy&#39;])</span>
<span class="gi">+               + [&#39;-acodec&#39;, codec]</span>
<span class="gi">+               + [&#39;-ar&#39;, &quot;%d&quot; % fps_input]</span>
<span class="gi">+               + [&#39;-strict&#39;, &#39;-2&#39;]  # needed to support codec &#39;aac&#39;</span>
<span class="gi">+               + ([&#39;-ab&#39;, bitrate] if (bitrate is not None) else [])</span>
<span class="gi">+               + (ffmpeg_params if ffmpeg_params else [])</span>
<span class="gi">+               + [filename])</span>
<span class="gi">+</span>
<span class="gi">+        popen_params = {&quot;stdout&quot;: DEVNULL,</span>
<span class="gi">+                        &quot;stderr&quot;: logfile,</span>
<span class="gi">+                        &quot;stdin&quot;: sp.PIPE}</span>
<span class="gi">+</span>
<span class="gi">+        if os.name == &quot;nt&quot;:</span>
<span class="gi">+            popen_params[&quot;creationflags&quot;] = 0x08000000</span>
<span class="gi">+</span>
<span class="w"> </span>        self.proc = sp.Popen(cmd, **popen_params)

<span class="gi">+    def write_frames(self, frames_array):</span>
<span class="gi">+        try:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.proc.stdin.write(frames_array.tobytes())</span>
<span class="gi">+            except NameError:</span>
<span class="gi">+                self.proc.stdin.write(frames_array.tostring())</span>
<span class="gi">+        except IOError as err:</span>
<span class="gi">+            ffmpeg_error = self.proc.stderr.read()</span>
<span class="gi">+            error = (str(err) + (&quot;\n\nMoviePy error: FFMPEG encountered &quot;</span>
<span class="gi">+                                 &quot;the following error while writing file %s:&quot; % self.filename</span>
<span class="gi">+                                 + &quot;\n\n&quot; + str(ffmpeg_error)))</span>
<span class="gi">+</span>
<span class="gi">+            if b&quot;Unknown encoder&quot; in ffmpeg_error:</span>
<span class="gi">+</span>
<span class="gi">+                error = (error +</span>
<span class="gi">+                         (&quot;\n\nThe audio export failed because FFMPEG didn&#39;t &quot;</span>
<span class="gi">+                          &quot;find the specified codec for audio encoding (%s). &quot;</span>
<span class="gi">+                          &quot;Please install this codec or change the codec when &quot;</span>
<span class="gi">+                          &quot;calling to_videofile or to_audiofile. For instance &quot;</span>
<span class="gi">+                          &quot;for mp3:\n&quot;</span>
<span class="gi">+                          &quot;   &gt;&gt;&gt; to_videofile(&#39;myvid.mp4&#39;, audio_codec=&#39;libmp3lame&#39;)&quot;</span>
<span class="gi">+                          ) % (self.codec))</span>
<span class="gi">+</span>
<span class="gi">+            elif b&quot;incorrect codec parameters ?&quot; in ffmpeg_error:</span>
<span class="gi">+</span>
<span class="gi">+                error = (error +</span>
<span class="gi">+                         (&quot;\n\nThe audio export failed, possibly because the &quot;</span>
<span class="gi">+                          &quot;codec specified for the video (%s) is not compatible&quot;</span>
<span class="gi">+                          &quot; with the given extension (%s). Please specify a &quot;</span>
<span class="gi">+                          &quot;valid &#39;codec&#39; argument in to_videofile. This would &quot;</span>
<span class="gi">+                          &quot;be &#39;libmp3lame&#39; for mp3, &#39;libvorbis&#39; for ogg...&quot;)</span>
<span class="gi">+                         % (self.codec, self.ext))</span>
<span class="gi">+</span>
<span class="gi">+            elif b&quot;encoder setup failed&quot; in ffmpeg_error:</span>
<span class="gi">+</span>
<span class="gi">+                error = (error +</span>
<span class="gi">+                         (&quot;\n\nThe audio export failed, possily because the &quot;</span>
<span class="gi">+                          &quot;bitrate you specified was two high or too low for &quot;</span>
<span class="gi">+                          &quot;the video codec.&quot;))</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+                error = (error +</span>
<span class="gi">+                         (&quot;\n\nIn case it helps, make sure you are using a &quot;</span>
<span class="gi">+                          &quot;recent version of FFMPEG (the versions in the &quot;</span>
<span class="gi">+                          &quot;Ubuntu/Debian repos are deprecated).&quot;))</span>
<span class="gi">+</span>
<span class="gi">+            raise IOError(error)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        if hasattr(self, &#39;proc&#39;) and self.proc:</span>
<span class="gi">+            self.proc.stdin.close()</span>
<span class="gi">+            self.proc.stdin = None</span>
<span class="gi">+            if self.proc.stderr is not None:</span>
<span class="gi">+                self.proc.stderr.close()</span>
<span class="gi">+                self.proc.stdee = None</span>
<span class="gi">+            # If this causes deadlocks, consider terminating instead.</span>
<span class="gi">+            self.proc.wait()</span>
<span class="gi">+            self.proc = None</span>
<span class="gi">+</span>
<span class="w"> </span>    def __del__(self):
<span class="gi">+        # If the garbage collector comes, make sure the subprocess is terminated.</span>
<span class="w"> </span>        self.close()

<span class="gi">+    # Support the Context Manager protocol, to ensure that resources are cleaned up.</span>
<span class="gi">+</span>
<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self

<span class="gu">@@ -63,13 +141,36 @@ class FFMPEG_AudioWriter:</span>


<span class="w"> </span>@requires_duration
<span class="gd">-def ffmpeg_audiowrite(clip, filename, fps, nbytes, buffersize, codec=</span>
<span class="gd">-    &#39;libvorbis&#39;, bitrate=None, write_logfile=False, verbose=True,</span>
<span class="gd">-    ffmpeg_params=None, logger=&#39;bar&#39;):</span>
<span class="gi">+def ffmpeg_audiowrite(clip, filename, fps, nbytes, buffersize,</span>
<span class="gi">+                      codec=&#39;libvorbis&#39;, bitrate=None,</span>
<span class="gi">+                      write_logfile=False, verbose=True,</span>
<span class="gi">+                      ffmpeg_params=None, logger=&#39;bar&#39;):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    A function that wraps the FFMPEG_AudioWriter to write an AudioClip
<span class="w"> </span>    to a file.

<span class="w"> </span>    NOTE: verbose is deprecated.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if write_logfile:</span>
<span class="gi">+        logfile = open(filename + &quot;.log&quot;, &#39;w+&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        logfile = None</span>
<span class="gi">+    logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+    logger(message=&quot;MoviePy - Writing audio in %s&quot; % filename)</span>
<span class="gi">+    writer = FFMPEG_AudioWriter(filename, fps, nbytes, clip.nchannels,</span>
<span class="gi">+                                codec=codec, bitrate=bitrate,</span>
<span class="gi">+                                logfile=logfile,</span>
<span class="gi">+                                ffmpeg_params=ffmpeg_params)</span>
<span class="gi">+</span>
<span class="gi">+    for chunk in clip.iter_chunks(chunksize=buffersize,</span>
<span class="gi">+                                  quantize=True,</span>
<span class="gi">+                                  nbytes=nbytes, fps=fps,</span>
<span class="gi">+                                  logger=logger):</span>
<span class="gi">+        writer.write_frames(chunk)</span>
<span class="gi">+</span>
<span class="gi">+    writer.close()</span>
<span class="gi">+</span>
<span class="gi">+    if write_logfile:</span>
<span class="gi">+        logfile.close()</span>
<span class="gi">+    logger(message=&quot;MoviePy - Done.&quot;)</span>
<span class="gh">diff --git a/moviepy/audio/io/preview.py b/moviepy/audio/io/preview.py</span>
<span class="gh">index d8a5730..e321b29 100644</span>
<span class="gd">--- a/moviepy/audio/io/preview.py</span>
<span class="gi">+++ b/moviepy/audio/io/preview.py</span>
<span class="gu">@@ -1,14 +1,17 @@</span>
<span class="w"> </span>import time
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>import pygame as pg
<span class="w"> </span>from moviepy.decorators import requires_duration
<span class="gi">+</span>
<span class="w"> </span>pg.init()
<span class="w"> </span>pg.display.set_caption(&#39;MoviePy&#39;)


<span class="w"> </span>@requires_duration
<span class="gd">-def preview(clip, fps=22050, buffersize=4000, nbytes=2, audioFlag=None,</span>
<span class="gd">-    videoFlag=None):</span>
<span class="gi">+def preview(clip, fps=22050,  buffersize=4000, nbytes=2, audioFlag=None,</span>
<span class="gi">+            videoFlag=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Plays the sound clip with pygame.

<span class="gu">@@ -36,4 +39,30 @@ def preview(clip, fps=22050, buffersize=4000, nbytes=2, audioFlag=None,</span>
<span class="w"> </span>      video and audio during ``VideoClip.preview()``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+                 </span>
<span class="gi">+    pg.mixer.quit()</span>
<span class="gi">+    </span>
<span class="gi">+    pg.mixer.init(fps, -8 * nbytes, clip.nchannels, 1024)</span>
<span class="gi">+    totalsize = int(fps*clip.duration)</span>
<span class="gi">+    pospos = np.array(list(range(0, totalsize,  buffersize))+[totalsize])</span>
<span class="gi">+    tt = (1.0/fps)*np.arange(pospos[0], pospos[1])</span>
<span class="gi">+    sndarray = clip.to_soundarray(tt, nbytes=nbytes, quantize=True)</span>
<span class="gi">+    chunk = pg.sndarray.make_sound(sndarray)</span>
<span class="gi">+    </span>
<span class="gi">+    if (audioFlag is not None) and (videoFlag is not None):</span>
<span class="gi">+        audioFlag.set()</span>
<span class="gi">+        videoFlag.wait()</span>
<span class="gi">+        </span>
<span class="gi">+    channel = chunk.play()</span>
<span class="gi">+    for i in range(1, len(pospos)-1):</span>
<span class="gi">+        tt = (1.0/fps)*np.arange(pospos[i], pospos[i+1])</span>
<span class="gi">+        sndarray = clip.to_soundarray(tt, nbytes=nbytes, quantize=True)</span>
<span class="gi">+        chunk = pg.sndarray.make_sound(sndarray)</span>
<span class="gi">+        while channel.get_queue():</span>
<span class="gi">+            time.sleep(0.003)</span>
<span class="gi">+            if videoFlag is not None:</span>
<span class="gi">+                if not videoFlag.is_set():</span>
<span class="gi">+                    channel.stop()</span>
<span class="gi">+                    del channel</span>
<span class="gi">+                    return</span>
<span class="gi">+        channel.queue(chunk)</span>
<span class="gh">diff --git a/moviepy/audio/io/readers.py b/moviepy/audio/io/readers.py</span>
<span class="gh">index 2e9cb30..991e60b 100644</span>
<span class="gd">--- a/moviepy/audio/io/readers.py</span>
<span class="gi">+++ b/moviepy/audio/io/readers.py</span>
<span class="gu">@@ -1,7 +1,9 @@</span>
<span class="w"> </span>import os
<span class="w"> </span>import subprocess as sp
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>from moviepy.compat import DEVNULL, PY3
<span class="w"> </span>from moviepy.config import get_setting
<span class="w"> </span>from moviepy.video.io.ffmpeg_reader import ffmpeg_parse_infos
<span class="gu">@@ -37,13 +39,14 @@ class FFMPEG_AudioReader:</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, filename, buffersize, print_infos=False, fps=44100,</span>
<span class="gd">-        nbytes=2, nchannels=2):</span>
<span class="gi">+    def __init__(self, filename, buffersize, print_infos=False,</span>
<span class="gi">+                 fps=44100, nbytes=2, nchannels=2):</span>
<span class="gi">+</span>
<span class="w"> </span>        self.filename = filename
<span class="w"> </span>        self.nbytes = nbytes
<span class="w"> </span>        self.fps = fps
<span class="gd">-        self.f = &#39;s%dle&#39; % (8 * nbytes)</span>
<span class="gd">-        self.acodec = &#39;pcm_s%dle&#39; % (8 * nbytes)</span>
<span class="gi">+        self.f = &#39;s%dle&#39;%(8*nbytes)</span>
<span class="gi">+        self.acodec = &#39;pcm_s%dle&#39;%(8*nbytes)</span>
<span class="w"> </span>        self.nchannels = nchannels
<span class="w"> </span>        infos = ffmpeg_parse_infos(filename)
<span class="w"> </span>        self.duration = infos[&#39;duration&#39;]
<span class="gu">@@ -53,18 +56,76 @@ class FFMPEG_AudioReader:</span>
<span class="w"> </span>            self.duration = infos[&#39;duration&#39;]
<span class="w"> </span>        self.infos = infos
<span class="w"> </span>        self.proc = None
<span class="gi">+</span>
<span class="w"> </span>        self.nframes = int(self.fps * self.duration)
<span class="gd">-        self.buffersize = min(self.nframes + 1, buffersize)</span>
<span class="gd">-        self.buffer = None</span>
<span class="gi">+        self.buffersize= min( self.nframes+1, buffersize )</span>
<span class="gi">+        self.buffer= None</span>
<span class="w"> </span>        self.buffer_startframe = 1
<span class="w"> </span>        self.initialize()
<span class="w"> </span>        self.buffer_around(1)

<span class="gd">-    def initialize(self, starttime=0):</span>
<span class="gi">+    def initialize(self, starttime = 0):</span>
<span class="w"> </span>        &quot;&quot;&quot; Opens the file, creates the pipe. &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def seek(self, pos):</span>
<span class="gi">+        self.close_proc() # if any</span>
<span class="gi">+</span>
<span class="gi">+        if starttime !=0 :</span>
<span class="gi">+            offset = min(1,starttime)</span>
<span class="gi">+            i_arg = [&quot;-ss&quot;, &quot;%.05f&quot;%(starttime-offset),</span>
<span class="gi">+                    &#39;-i&#39;, self.filename, &#39;-vn&#39;,</span>
<span class="gi">+                    &quot;-ss&quot;, &quot;%.05f&quot;%offset]</span>
<span class="gi">+        else:</span>
<span class="gi">+            i_arg = [ &#39;-i&#39;, self.filename,  &#39;-vn&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+        cmd = ([get_setting(&quot;FFMPEG_BINARY&quot;)] + i_arg +</span>
<span class="gi">+               [ &#39;-loglevel&#39;, &#39;error&#39;,</span>
<span class="gi">+                 &#39;-f&#39;, self.f,</span>
<span class="gi">+                &#39;-acodec&#39;, self.acodec,</span>
<span class="gi">+                &#39;-ar&#39;, &quot;%d&quot;%self.fps,</span>
<span class="gi">+                &#39;-ac&#39;, &#39;%d&#39;%self.nchannels, &#39;-&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        popen_params = {&quot;bufsize&quot;: self.buffersize,</span>
<span class="gi">+                        &quot;stdout&quot;: sp.PIPE,</span>
<span class="gi">+                        &quot;stderr&quot;: sp.PIPE,</span>
<span class="gi">+                        &quot;stdin&quot;: DEVNULL}</span>
<span class="gi">+</span>
<span class="gi">+        if os.name == &quot;nt&quot;:</span>
<span class="gi">+            popen_params[&quot;creationflags&quot;] = 0x08000000</span>
<span class="gi">+</span>
<span class="gi">+        self.proc = sp.Popen( cmd, **popen_params)</span>
<span class="gi">+</span>
<span class="gi">+        self.pos = np.round(self.fps*starttime)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def skip_chunk(self,chunksize):</span>
<span class="gi">+        s = self.proc.stdout.read(self.nchannels*chunksize*self.nbytes)</span>
<span class="gi">+        self.proc.stdout.flush()</span>
<span class="gi">+        self.pos = self.pos+chunksize</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def read_chunk(self,chunksize):</span>
<span class="gi">+        # chunksize is not being autoconverted from float to int</span>
<span class="gi">+        chunksize = int(round(chunksize))</span>
<span class="gi">+        L = self.nchannels*chunksize*self.nbytes</span>
<span class="gi">+        s = self.proc.stdout.read(L)</span>
<span class="gi">+        dt = {1: &#39;int8&#39;,2:&#39;int16&#39;,4:&#39;int32&#39;}[self.nbytes]</span>
<span class="gi">+        if hasattr(np, &#39;frombuffer&#39;):</span>
<span class="gi">+            result = np.frombuffer(s, dtype=dt)</span>
<span class="gi">+        else:</span>
<span class="gi">+            result = np.fromstring(s, dtype=dt)</span>
<span class="gi">+        result = (1.0*result / 2**(8*self.nbytes-1)).\</span>
<span class="gi">+                                 reshape((int(len(result)/self.nchannels),</span>
<span class="gi">+                                          self.nchannels))</span>
<span class="gi">+        #self.proc.stdout.flush()</span>
<span class="gi">+        self.pos = self.pos+chunksize</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def seek(self,pos):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Reads a frame at time t. Note for coders: getting an arbitrary
<span class="w"> </span>        frame in the video with ffmpeg can be painfully slow if some
<span class="gu">@@ -72,14 +133,122 @@ class FFMPEG_AudioReader:</span>
<span class="w"> </span>        arbitrary frames whenever possible, by moving between adjacent
<span class="w"> </span>        frames.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (pos &lt; self.pos) or (pos&gt; (self.pos+1000000)):</span>
<span class="gi">+            t = 1.0*pos/self.fps</span>
<span class="gi">+            self.initialize(t)</span>
<span class="gi">+        elif pos &gt; self.pos:</span>
<span class="gi">+            #print pos</span>
<span class="gi">+            self.skip_chunk(pos-self.pos)</span>
<span class="gi">+        # last case standing: pos = current pos</span>
<span class="gi">+        self.pos = pos</span>
<span class="gi">+</span>
<span class="gi">+</span>

<span class="gd">-    def buffer_around(self, framenumber):</span>
<span class="gi">+    def close_proc(self):</span>
<span class="gi">+        if hasattr(self, &#39;proc&#39;) and self.proc is not None:</span>
<span class="gi">+            self.proc.terminate()</span>
<span class="gi">+            for std in [ self.proc.stdout,</span>
<span class="gi">+                         self.proc.stderr]:</span>
<span class="gi">+                std.close()</span>
<span class="gi">+            self.proc.wait()</span>
<span class="gi">+            self.proc = None</span>
<span class="gi">+</span>
<span class="gi">+    def get_frame(self, tt):</span>
<span class="gi">+</span>
<span class="gi">+        buffersize = self.buffersize</span>
<span class="gi">+        if isinstance(tt,np.ndarray):</span>
<span class="gi">+            # lazy implementation, but should not cause problems in</span>
<span class="gi">+            # 99.99 %  of the cases</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+            # elements of t that are actually in the range of the</span>
<span class="gi">+            # audio file.</span>
<span class="gi">+            in_time = (tt&gt;=0) &amp; (tt &lt; self.duration)</span>
<span class="gi">+</span>
<span class="gi">+        # Check that the requested time is in the valid range</span>
<span class="gi">+            if not in_time.any():</span>
<span class="gi">+                raise IOError(&quot;Error in file %s, &quot;%(self.filename)+</span>
<span class="gi">+                       &quot;Accessing time t=%.02f-%.02f seconds, &quot;%(tt[0], tt[-1])+</span>
<span class="gi">+                       &quot;with clip duration=%d seconds, &quot;%self.duration)</span>
<span class="gi">+</span>
<span class="gi">+            # The np.round in the next line is super-important.</span>
<span class="gi">+            # Removing it results in artifacts in the noise.</span>
<span class="gi">+            frames = np.round((self.fps*tt)).astype(int)[in_time]</span>
<span class="gi">+            fr_min, fr_max = frames.min(), frames.max()</span>
<span class="gi">+</span>
<span class="gi">+            if not (0 &lt;=</span>
<span class="gi">+                     (fr_min - self.buffer_startframe)</span>
<span class="gi">+                          &lt; len(self.buffer)):</span>
<span class="gi">+                self.buffer_around(fr_min)</span>
<span class="gi">+            elif not (0 &lt;=</span>
<span class="gi">+                        (fr_max - self.buffer_startframe)</span>
<span class="gi">+                             &lt; len(self.buffer)):</span>
<span class="gi">+                self.buffer_around(fr_max)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                result = np.zeros((len(tt),self.nchannels))</span>
<span class="gi">+                indices = frames - self.buffer_startframe</span>
<span class="gi">+                if len(self.buffer) &lt; self.buffersize // 2:</span>
<span class="gi">+                    indices = indices - (self.buffersize // 2 - len(self.buffer) + 1)</span>
<span class="gi">+                result[in_time] = self.buffer[indices]</span>
<span class="gi">+                return result</span>
<span class="gi">+</span>
<span class="gi">+            except IndexError as error:</span>
<span class="gi">+                warnings.warn(&quot;Error in file %s, &quot;%(self.filename)+</span>
<span class="gi">+                       &quot;At time t=%.02f-%.02f seconds, &quot;%(tt[0], tt[-1])+</span>
<span class="gi">+                       &quot;indices wanted: %d-%d, &quot;%(indices.min(), indices.max())+</span>
<span class="gi">+                       &quot;but len(buffer)=%d\n&quot;%(len(self.buffer))+ str(error),</span>
<span class="gi">+                   UserWarning)</span>
<span class="gi">+</span>
<span class="gi">+                # repeat the last frame instead</span>
<span class="gi">+                indices[indices&gt;=len(self.buffer)] = len(self.buffer) -1</span>
<span class="gi">+                result[in_time] = self.buffer[indices]</span>
<span class="gi">+                return result</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            ind = int(self.fps*tt)</span>
<span class="gi">+            if ind&lt;0 or ind&gt; self.nframes: # out of time: return 0</span>
<span class="gi">+                return np.zeros(self.nchannels)</span>
<span class="gi">+</span>
<span class="gi">+            if not (0 &lt;= (ind - self.buffer_startframe) &lt;len(self.buffer)):</span>
<span class="gi">+                # out of the buffer: recenter the buffer</span>
<span class="gi">+                self.buffer_around(ind)</span>
<span class="gi">+</span>
<span class="gi">+            # read the frame in the buffer</span>
<span class="gi">+            return self.buffer[ind - self.buffer_startframe]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def buffer_around(self,framenumber):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Fills the buffer with frames, centered on ``framenumber``
<span class="w"> </span>        if possible
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # start-frame for the buffer</span>
<span class="gi">+        new_bufferstart = max(0,  framenumber - self.buffersize // 2)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+        if (self.buffer is not None):</span>
<span class="gi">+            current_f_end  = self.buffer_startframe + self.buffersize</span>
<span class="gi">+            if (new_bufferstart &lt;</span>
<span class="gi">+                        current_f_end  &lt;</span>
<span class="gi">+                               new_bufferstart + self.buffersize):</span>
<span class="gi">+                # We already have one bit of what must be read</span>
<span class="gi">+                conserved = current_f_end - new_bufferstart + 1</span>
<span class="gi">+                chunksize = self.buffersize-conserved</span>
<span class="gi">+                array = self.read_chunk(chunksize)</span>
<span class="gi">+                self.buffer = np.vstack([self.buffer[-conserved:], array])</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.seek(new_bufferstart)</span>
<span class="gi">+                self.buffer =  self.read_chunk(self.buffersize)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.seek(new_bufferstart)</span>
<span class="gi">+            self.buffer =  self.read_chunk(self.buffersize)</span>
<span class="gi">+</span>
<span class="gi">+        self.buffer_startframe = new_bufferstart</span>
<span class="gi">+</span>

<span class="w"> </span>    def __del__(self):
<span class="gi">+        # If the garbage collector comes, make sure the subprocess is terminated.</span>
<span class="w"> </span>        self.close_proc()
<span class="gh">diff --git a/moviepy/audio/tools/cuts.py b/moviepy/audio/tools/cuts.py</span>
<span class="gh">index e057157..3adedbb 100644</span>
<span class="gd">--- a/moviepy/audio/tools/cuts.py</span>
<span class="gi">+++ b/moviepy/audio/tools/cuts.py</span>
<span class="gu">@@ -1,7 +1,8 @@</span>
<span class="gi">+</span>
<span class="w"> </span>import numpy as np


<span class="gd">-def find_audio_period(aclip, t_min=0.1, t_max=2, t_res=0.01):</span>
<span class="gi">+def find_audio_period(aclip, t_min=.1, t_max=2, t_res=.01):</span>
<span class="w"> </span>    &quot;&quot;&quot; Finds the period, in seconds of an audioclip.

<span class="w"> </span>    The beat is then given by bpm = 60/T
<span class="gu">@@ -9,4 +10,13 @@ def find_audio_period(aclip, t_min=0.1, t_max=2, t_res=0.01):</span>
<span class="w"> </span>    t_min and _tmax are bounds for the returned value, t_res
<span class="w"> </span>    is the numerical precision
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    chunksize = int(t_res*aclip.fps)</span>
<span class="gi">+    chunk_duration = 1.0*chunksize/aclip.fps</span>
<span class="gi">+    # v denotes the list of volumes</span>
<span class="gi">+    v = np.array([(c**2).sum() for c in</span>
<span class="gi">+                aclip.iter_chunks(chunksize)])</span>
<span class="gi">+    v = v-v.mean()</span>
<span class="gi">+    corrs = np.correlate(v, v, mode = &#39;full&#39;)[-len(v):]</span>
<span class="gi">+    corrs[:int(t_min/chunk_duration)]=0</span>
<span class="gi">+    corrs[int(t_max/chunk_duration):]=0</span>
<span class="gi">+    return chunk_duration*np.argmax(corrs)</span>
<span class="gh">diff --git a/moviepy/compat.py b/moviepy/compat.py</span>
<span class="gh">index 961bc9f..e97b11b 100644</span>
<span class="gd">--- a/moviepy/compat.py</span>
<span class="gi">+++ b/moviepy/compat.py</span>
<span class="gu">@@ -1,11 +1,14 @@</span>
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="gd">-PY3 = sys.version_info.major &gt;= 3</span>
<span class="gi">+</span>
<span class="gi">+PY3=sys.version_info.major &gt;= 3</span>
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    string_types = str, unicode</span>
<span class="gi">+    string_types = (str, unicode)     # Python 2</span>
<span class="w"> </span>except NameError:
<span class="gd">-    string_types = str</span>
<span class="gi">+    string_types = (str)              # Python 3</span>
<span class="gi">+   </span>
<span class="w"> </span>try:
<span class="gd">-    from subprocess import DEVNULL</span>
<span class="gi">+    from subprocess import DEVNULL    # Python 3</span>
<span class="w"> </span>except ImportError:
<span class="gd">-    DEVNULL = open(os.devnull, &#39;wb&#39;)</span>
<span class="gi">+    DEVNULL = open(os.devnull, &#39;wb&#39;)  # Python 2</span>
<span class="gh">diff --git a/moviepy/config.py b/moviepy/config.py</span>
<span class="gh">index 09fa2fe..b1ce2f8 100644</span>
<span class="gd">--- a/moviepy/config.py</span>
<span class="gi">+++ b/moviepy/config.py</span>
<span class="gu">@@ -1,16 +1,42 @@</span>
<span class="w"> </span>import os
<span class="w"> </span>import subprocess as sp
<span class="gi">+</span>
<span class="w"> </span>from .compat import DEVNULL
<span class="w"> </span>from .config_defaults import FFMPEG_BINARY, IMAGEMAGICK_BINARY
<span class="gi">+</span>
<span class="w"> </span>if os.name == &#39;nt&#39;:
<span class="w"> </span>    try:
<span class="gd">-        import winreg as wr</span>
<span class="gi">+        import winreg as wr # py3k</span>
<span class="w"> </span>    except ImportError:
<span class="gd">-        import _winreg as wr</span>
<span class="gd">-if FFMPEG_BINARY == &#39;ffmpeg-imageio&#39;:</span>
<span class="gi">+        import _winreg as wr # py2k</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def try_cmd(cmd):</span>
<span class="gi">+    try:</span>
<span class="gi">+        popen_params = {</span>
<span class="gi">+            &quot;stdout&quot;: sp.PIPE,</span>
<span class="gi">+            &quot;stderr&quot;: sp.PIPE,</span>
<span class="gi">+            &quot;stdin&quot;: DEVNULL</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        # This was added so that no extra unwanted window opens on windows</span>
<span class="gi">+        # when the child process is created</span>
<span class="gi">+        if os.name == &quot;nt&quot;:</span>
<span class="gi">+            popen_params[&quot;creationflags&quot;] = 0x08000000</span>
<span class="gi">+</span>
<span class="gi">+        proc = sp.Popen(cmd, **popen_params)</span>
<span class="gi">+        proc.communicate()</span>
<span class="gi">+    except Exception as err:</span>
<span class="gi">+        return False, err</span>
<span class="gi">+    else:</span>
<span class="gi">+        return True, None</span>
<span class="gi">+</span>
<span class="gi">+if FFMPEG_BINARY==&#39;ffmpeg-imageio&#39;:</span>
<span class="w"> </span>    from imageio.plugins.ffmpeg import get_exe
<span class="w"> </span>    FFMPEG_BINARY = get_exe()
<span class="gd">-elif FFMPEG_BINARY == &#39;auto-detect&#39;:</span>
<span class="gi">+</span>
<span class="gi">+elif FFMPEG_BINARY==&#39;auto-detect&#39;:</span>
<span class="gi">+</span>
<span class="w"> </span>    if try_cmd([&#39;ffmpeg&#39;])[0]:
<span class="w"> </span>        FFMPEG_BINARY = &#39;ffmpeg&#39;
<span class="w"> </span>    elif try_cmd([&#39;ffmpeg.exe&#39;])[0]:
<span class="gu">@@ -20,15 +46,15 @@ elif FFMPEG_BINARY == &#39;auto-detect&#39;:</span>
<span class="w"> </span>else:
<span class="w"> </span>    success, err = try_cmd([FFMPEG_BINARY])
<span class="w"> </span>    if not success:
<span class="gd">-        raise IOError(str(err) +</span>
<span class="gd">-            &#39; - The path specified for the ffmpeg binary might be wrong&#39;)</span>
<span class="gd">-if IMAGEMAGICK_BINARY == &#39;auto-detect&#39;:</span>
<span class="gi">+        raise IOError(</span>
<span class="gi">+            str(err) +</span>
<span class="gi">+            &quot; - The path specified for the ffmpeg binary might be wrong&quot;)</span>
<span class="gi">+</span>
<span class="gi">+if IMAGEMAGICK_BINARY==&#39;auto-detect&#39;:</span>
<span class="w"> </span>    if os.name == &#39;nt&#39;:
<span class="w"> </span>        try:
<span class="gd">-            key = wr.OpenKey(wr.HKEY_LOCAL_MACHINE,</span>
<span class="gd">-                &#39;SOFTWARE\\ImageMagick\\Current&#39;)</span>
<span class="gd">-            IMAGEMAGICK_BINARY = wr.QueryValueEx(key, &#39;BinPath&#39;)[0</span>
<span class="gd">-                ] + &#39;\\convert.exe&#39;</span>
<span class="gi">+            key = wr.OpenKey(wr.HKEY_LOCAL_MACHINE, &#39;SOFTWARE\\ImageMagick\\Current&#39;)</span>
<span class="gi">+            IMAGEMAGICK_BINARY = wr.QueryValueEx(key, &#39;BinPath&#39;)[0] + r&quot;\convert.exe&quot;</span>
<span class="w"> </span>            key.Close()
<span class="w"> </span>        except:
<span class="w"> </span>            IMAGEMAGICK_BINARY = &#39;unset&#39;
<span class="gu">@@ -38,34 +64,55 @@ if IMAGEMAGICK_BINARY == &#39;auto-detect&#39;:</span>
<span class="w"> </span>        IMAGEMAGICK_BINARY = &#39;unset&#39;
<span class="w"> </span>else:
<span class="w"> </span>    if not os.path.exists(IMAGEMAGICK_BINARY):
<span class="gd">-        raise IOError(&#39;ImageMagick binary cannot be found at {}&#39;.format(</span>
<span class="gd">-            IMAGEMAGICK_BINARY))</span>
<span class="gi">+        raise IOError(</span>
<span class="gi">+            &quot;ImageMagick binary cannot be found at {}&quot;.format(</span>
<span class="gi">+                IMAGEMAGICK_BINARY</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>    if not os.path.isfile(IMAGEMAGICK_BINARY):
<span class="gd">-        raise IOError(&#39;ImageMagick binary found at {} is not a file&#39;.format</span>
<span class="gd">-            (IMAGEMAGICK_BINARY))</span>
<span class="gi">+        raise IOError(</span>
<span class="gi">+            &quot;ImageMagick binary found at {} is not a file&quot;.format(</span>
<span class="gi">+                IMAGEMAGICK_BINARY</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>    success, err = try_cmd([IMAGEMAGICK_BINARY])
<span class="w"> </span>    if not success:
<span class="gd">-        raise IOError(</span>
<span class="gd">-            &#39;%s - The path specified for the ImageMagick binary might be wrong: %s&#39;</span>
<span class="gd">-             % (err, IMAGEMAGICK_BINARY))</span>
<span class="gi">+        raise IOError(&quot;%s - The path specified for the ImageMagick binary might &quot;</span>
<span class="gi">+                      &quot;be wrong: %s&quot; % (err, IMAGEMAGICK_BINARY))</span>


<span class="w"> </span>def get_setting(varname):
<span class="w"> </span>    &quot;&quot;&quot; Returns the value of a configuration variable. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    gl = globals()</span>
<span class="gi">+    if varname not in gl.keys():</span>
<span class="gi">+        raise ValueError(&quot;Unknown setting %s&quot;%varname)</span>
<span class="gi">+    # Here, possibly add some code to raise exceptions if some</span>
<span class="gi">+    # parameter isn&#39;t set set properly, explaining on how to set it.</span>
<span class="gi">+    return gl[varname]</span>


<span class="w"> </span>def change_settings(new_settings=None, filename=None):
<span class="w"> </span>    &quot;&quot;&quot; Changes the value of configuration variables.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    new_settings = new_settings or {}</span>
<span class="gi">+    gl = globals()</span>
<span class="gi">+    if filename:</span>
<span class="gi">+        with open(filename) as in_file:</span>
<span class="gi">+            exec(in_file)</span>
<span class="gi">+        gl.update(locals())</span>
<span class="gi">+    gl.update(new_settings)</span>
<span class="gi">+    # Here you can add some code  to check that the new configuration</span>
<span class="gi">+    # values are valid.</span>


<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    if try_cmd([FFMPEG_BINARY])[0]:
<span class="gd">-        print(&#39;MoviePy : ffmpeg successfully found.&#39;)</span>
<span class="gi">+        print( &quot;MoviePy : ffmpeg successfully found.&quot; )</span>
<span class="w"> </span>    else:
<span class="gd">-        print(&quot;MoviePy : can&#39;t find or access ffmpeg.&quot;)</span>
<span class="gi">+        print( &quot;MoviePy : can&#39;t find or access ffmpeg.&quot; )</span>
<span class="gi">+</span>
<span class="w"> </span>    if try_cmd([IMAGEMAGICK_BINARY])[0]:
<span class="gd">-        print(&#39;MoviePy : ImageMagick successfully found.&#39;)</span>
<span class="gi">+        print( &quot;MoviePy : ImageMagick successfully found.&quot; )</span>
<span class="w"> </span>    else:
<span class="gd">-        print(&quot;MoviePy : can&#39;t find or access ImageMagick.&quot;)</span>
<span class="gi">+        print( &quot;MoviePy : can&#39;t find or access ImageMagick.&quot; )</span>
<span class="gh">diff --git a/moviepy/config_defaults.py b/moviepy/config_defaults.py</span>
<span class="gh">index 86fcdea..d88e1f7 100644</span>
<span class="gd">--- a/moviepy/config_defaults.py</span>
<span class="gi">+++ b/moviepy/config_defaults.py</span>
<span class="gu">@@ -18,7 +18,7 @@ Linux/Mac:</span>
<span class="w"> </span>   export FFMPEG_BINARY=path/to/ffmpeg

<span class="w"> </span>Windows:
<span class="gd">-   set FFMPEG_BINARY=path  ofmpeg</span>
<span class="gi">+   set FFMPEG_BINARY=path\to\ffmpeg</span>

<span class="w"> </span>Instructions
<span class="w"> </span>--------------
<span class="gu">@@ -34,7 +34,7 @@ FFMPEG_BINARY</span>
<span class="w"> </span>    enter it like that:

<span class="w"> </span>    FFMPEG_BINARY = r&quot;path/to/ffmpeg&quot; # on linux
<span class="gd">-    FFMPEG_BINARY = r&quot;path ofmpeg.exe&quot; # on windows</span>
<span class="gi">+    FFMPEG_BINARY = r&quot;path\to\ffmpeg.exe&quot; # on windows</span>

<span class="w"> </span>    Warning: the &#39;r&#39; before the path is important, especially on Windows.

<span class="gu">@@ -44,9 +44,11 @@ IMAGEMAGICK_BINARY</span>
<span class="w"> </span>    For Windows users, you must specify the path to the ImageMagick
<span class="w"> </span>    &#39;magick&#39; binary. For instance:

<span class="gd">-    IMAGEMAGICK_BINARY = r&quot;C:\\Program Files\\ImageMagick-6.8.8-Q16\\magick.exe&quot;</span>
<span class="gi">+    IMAGEMAGICK_BINARY = r&quot;C:\Program Files\ImageMagick-6.8.8-Q16\magick.exe&quot;</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="gi">+</span>
<span class="w"> </span>FFMPEG_BINARY = os.getenv(&#39;FFMPEG_BINARY&#39;, &#39;ffmpeg-imageio&#39;)
<span class="w"> </span>IMAGEMAGICK_BINARY = os.getenv(&#39;IMAGEMAGICK_BINARY&#39;, &#39;auto-detect&#39;)
<span class="gh">diff --git a/moviepy/decorators.py b/moviepy/decorators.py</span>
<span class="gh">index 8004202..277276c 100644</span>
<span class="gd">--- a/moviepy/decorators.py</span>
<span class="gi">+++ b/moviepy/decorators.py</span>
<span class="gu">@@ -1,40 +1,58 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>all decorators used in moviepy go there
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import decorator
<span class="gi">+</span>
<span class="w"> </span>from moviepy.tools import cvsecs


<span class="w"> </span>@decorator.decorator
<span class="w"> </span>def outplace(f, clip, *a, **k):
<span class="w"> </span>    &quot;&quot;&quot; Applies f(clip.copy(), *a, **k) and returns clip.copy()&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    newclip = clip.copy()</span>
<span class="gi">+    f(newclip, *a, **k)</span>
<span class="gi">+    return newclip</span>

<span class="w"> </span>@decorator.decorator
<span class="w"> </span>def convert_masks_to_RGB(f, clip, *a, **k):
<span class="w"> </span>    &quot;&quot;&quot; If the clip is a mask, convert it to RGB before running the function &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    if clip.ismask:</span>
<span class="gi">+        clip = clip.to_RGB()</span>
<span class="gi">+    return f(clip, *a, **k)</span>

<span class="w"> </span>@decorator.decorator
<span class="w"> </span>def apply_to_mask(f, clip, *a, **k):
<span class="w"> </span>    &quot;&quot;&quot; This decorator will apply the same function f to the mask of
<span class="w"> </span>        the clip created with f &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+        </span>
<span class="gi">+    newclip = f(clip, *a, **k)</span>
<span class="gi">+    if getattr(newclip, &#39;mask&#39;, None):</span>
<span class="gi">+        newclip.mask = f(newclip.mask, *a, **k)</span>
<span class="gi">+    return newclip</span>
<span class="gi">+</span>


<span class="w"> </span>@decorator.decorator
<span class="w"> </span>def apply_to_audio(f, clip, *a, **k):
<span class="w"> </span>    &quot;&quot;&quot; This decorator will apply the function f to the audio of
<span class="w"> </span>        the clip created with f &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+        </span>
<span class="gi">+    newclip = f(clip, *a, **k)</span>
<span class="gi">+    if getattr(newclip, &#39;audio&#39;, None):</span>
<span class="gi">+        newclip.audio = f(newclip.audio, *a, **k)</span>
<span class="gi">+    return newclip</span>


<span class="w"> </span>@decorator.decorator
<span class="w"> </span>def requires_duration(f, clip, *a, **k):
<span class="w"> </span>    &quot;&quot;&quot; Raise an error if the clip has no duration.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    if clip.duration is None:</span>
<span class="gi">+        raise ValueError(&quot;Attribute &#39;duration&#39; not set&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return f(clip, *a, **k)</span>
<span class="gi">+</span>


<span class="w"> </span>@decorator.decorator
<span class="gu">@@ -45,26 +63,73 @@ def audio_video_fx(f, clip, *a, **k):</span>
<span class="w"> </span>    can be also used on a video clip, at which case it returns a
<span class="w"> </span>    videoclip with unmodified video and modified audio.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def preprocess_args(fun, varnames):</span>
<span class="gi">+    </span>
<span class="gi">+    if hasattr(clip, &quot;audio&quot;):</span>
<span class="gi">+        newclip = clip.copy()</span>
<span class="gi">+        if clip.audio is not None:</span>
<span class="gi">+            newclip.audio =  f(clip.audio, *a, **k)</span>
<span class="gi">+        return newclip</span>
<span class="gi">+    else:</span>
<span class="gi">+        return f(clip, *a, **k)</span>
<span class="gi">+</span>
<span class="gi">+def preprocess_args(fun,varnames):</span>
<span class="w"> </span>    &quot;&quot;&quot; Applies fun to variables in varnames before launching the function &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    def wrapper(f, *a, **kw):</span>
<span class="gi">+        if hasattr(f, &quot;func_code&quot;):</span>
<span class="gi">+            func_code = f.func_code # Python 2</span>
<span class="gi">+        else:</span>
<span class="gi">+            func_code = f.__code__ # Python 3</span>
<span class="gi">+            </span>
<span class="gi">+        names = func_code.co_varnames</span>
<span class="gi">+        new_a = [fun(arg) if (name in varnames) else arg</span>
<span class="gi">+                 for (arg, name) in zip(a, names)]</span>
<span class="gi">+        new_kw = {k: fun(v) if k in varnames else v</span>
<span class="gi">+                 for (k,v) in kw.items()}</span>
<span class="gi">+        return f(*new_a, **new_kw)</span>
<span class="gi">+    return decorator.decorator(wrapper)</span>


<span class="w"> </span>def convert_to_seconds(varnames):
<span class="gd">-    &quot;&quot;&quot;Converts the specified variables to seconds&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;Converts the specified variables to seconds&quot;</span>
<span class="gi">+    return preprocess_args(cvsecs, varnames)</span>
<span class="gi">+</span>


<span class="w"> </span>@decorator.decorator
<span class="w"> </span>def add_mask_if_none(f, clip, *a, **k):
<span class="gd">-    &quot;&quot;&quot; Add a mask to the clip if there is none. &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot; Add a mask to the clip if there is none. &quot;&quot;&quot;        </span>
<span class="gi">+    if clip.mask is None:</span>
<span class="gi">+        clip = clip.add_mask()</span>
<span class="gi">+    return f(clip, *a, **k)</span>
<span class="gi">+</span>


<span class="w"> </span>@decorator.decorator
<span class="w"> </span>def use_clip_fps_by_default(f, clip, *a, **k):
<span class="w"> </span>    &quot;&quot;&quot; Will use clip.fps if no fps=... is provided in **k &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    def fun(fps):</span>
<span class="gi">+        if fps is not None:</span>
<span class="gi">+            return fps</span>
<span class="gi">+        elif getattr(clip, &#39;fps&#39;, None):</span>
<span class="gi">+            return clip.fps</span>
<span class="gi">+        raise AttributeError(&quot;No &#39;fps&#39; (frames per second) attribute specified&quot;</span>
<span class="gi">+                &quot; for function %s and the clip has no &#39;fps&#39; attribute. Either&quot;</span>
<span class="gi">+                &quot; provide e.g. fps=24 in the arguments of the function, or define&quot;</span>
<span class="gi">+                &quot; the clip&#39;s fps with `clip.fps=24`&quot; % f.__name__)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(f, &quot;func_code&quot;):</span>
<span class="gi">+        func_code = f.func_code # Python 2</span>
<span class="gi">+    else:</span>
<span class="gi">+        func_code = f.__code__ # Python 3</span>
<span class="gi">+        </span>
<span class="gi">+    names = func_code.co_varnames[1:]</span>
<span class="gi">+    </span>
<span class="gi">+    new_a = [fun(arg) if (name==&#39;fps&#39;) else arg</span>
<span class="gi">+             for (arg, name) in zip(a, names)]</span>
<span class="gi">+    new_kw = {k: fun(v) if k==&#39;fps&#39; else v</span>
<span class="gi">+             for (k,v) in k.items()}</span>
<span class="gi">+</span>
<span class="gi">+    return f(clip, *new_a, **new_kw)</span>
<span class="gh">diff --git a/moviepy/editor.py b/moviepy/editor.py</span>
<span class="gh">index 59873ec..c5dff72 100644</span>
<span class="gd">--- a/moviepy/editor.py</span>
<span class="gi">+++ b/moviepy/editor.py</span>
<span class="gu">@@ -13,61 +13,119 @@ we can write</span>
<span class="w"> </span>It also starts a PyGame session (if PyGame is installed) and enables
<span class="w"> </span>clip.preview().
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# Note that these imports could have been performed in the __init__.py</span>
<span class="gi">+# file, but this would make the loading of moviepy slower.</span>
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="gi">+# Downloads ffmpeg if it isn&#39;t already installed</span>
<span class="w"> </span>import imageio
<span class="gi">+# Checks to see if the user has set a place for their own version of ffmpeg</span>
<span class="gi">+</span>
<span class="w"> </span>if os.getenv(&#39;FFMPEG_BINARY&#39;) is None:
<span class="w"> </span>    if sys.version_info &lt; (3, 4):
<span class="gi">+        #uses an old version of imageio with ffmpeg.download.</span>
<span class="w"> </span>        imageio.plugins.ffmpeg.download()
<span class="gd">-os.environ[&#39;PYGAME_HIDE_SUPPORT_PROMPT&#39;] = &#39;1&#39;</span>
<span class="gi">+</span>
<span class="gi">+# Hide the welcome message from pygame: https://github.com/pygame/pygame/issues/542</span>
<span class="gi">+os.environ[&#39;PYGAME_HIDE_SUPPORT_PROMPT&#39;] = &quot;1&quot;</span>
<span class="gi">+</span>
<span class="gi">+# Clips</span>
<span class="w"> </span>from .video.io.VideoFileClip import VideoFileClip
<span class="w"> </span>from .video.io.ImageSequenceClip import ImageSequenceClip
<span class="w"> </span>from .video.io.downloader import download_webfile
<span class="w"> </span>from .video.VideoClip import VideoClip, ImageClip, ColorClip, TextClip
<span class="w"> </span>from .video.compositing.CompositeVideoClip import CompositeVideoClip, clips_array
<span class="gd">-from .video.compositing.concatenate import concatenate_videoclips, concatenate</span>
<span class="gi">+from .video.compositing.concatenate import concatenate_videoclips, concatenate # concatenate=deprecated</span>
<span class="gi">+</span>
<span class="w"> </span>from .audio.AudioClip import AudioClip, CompositeAudioClip, concatenate_audioclips
<span class="w"> </span>from .audio.io.AudioFileClip import AudioFileClip
<span class="gi">+</span>
<span class="gi">+# FX</span>
<span class="gi">+</span>
<span class="w"> </span>import moviepy.video.fx.all as vfx
<span class="w"> </span>import moviepy.audio.fx.all as afx
<span class="w"> </span>import moviepy.video.compositing.transitions as transfx
<span class="gi">+</span>
<span class="gi">+# Tools</span>
<span class="gi">+</span>
<span class="w"> </span>import moviepy.video.tools as videotools
<span class="w"> </span>import moviepy.video.io.ffmpeg_tools as ffmpeg_tools
<span class="w"> </span>from .video.io.html_tools import ipython_display
<span class="w"> </span>from .tools import cvsecs
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from .video.io.sliders import sliders
<span class="w"> </span>except ImportError:
<span class="w"> </span>    pass
<span class="gd">-for method in [&#39;afx.audio_fadein&#39;, &#39;afx.audio_fadeout&#39;,</span>
<span class="gd">-    &#39;afx.audio_normalize&#39;, &#39;afx.volumex&#39;, &#39;transfx.crossfadein&#39;,</span>
<span class="gd">-    &#39;transfx.crossfadeout&#39;, &#39;vfx.crop&#39;, &#39;vfx.fadein&#39;, &#39;vfx.fadeout&#39;,</span>
<span class="gd">-    &#39;vfx.invert_colors&#39;, &#39;vfx.loop&#39;, &#39;vfx.margin&#39;, &#39;vfx.mask_and&#39;,</span>
<span class="gd">-    &#39;vfx.mask_or&#39;, &#39;vfx.resize&#39;, &#39;vfx.rotate&#39;, &#39;vfx.speedx&#39;]:</span>
<span class="gd">-    exec(&#39;VideoClip.%s = %s&#39; % (method.split(&#39;.&#39;)[1], method))</span>
<span class="gd">-for method in [&#39;afx.audio_fadein&#39;, &#39;afx.audio_fadeout&#39;, &#39;afx.audio_loop&#39;,</span>
<span class="gd">-    &#39;afx.audio_normalize&#39;, &#39;afx.volumex&#39;]:</span>
<span class="gd">-    exec(&#39;AudioClip.%s = %s&#39; % (method.split(&#39;.&#39;)[1], method))</span>
<span class="gi">+</span>
<span class="gi">+# The next loop transforms many effects into VideoClip methods so that</span>
<span class="gi">+# they can be walled with myclip.resize(width=500) instead of </span>
<span class="gi">+# myclip.fx( vfx.resize, width= 500)</span>
<span class="gi">+for method in [</span>
<span class="gi">+          &quot;afx.audio_fadein&quot;,</span>
<span class="gi">+          &quot;afx.audio_fadeout&quot;,</span>
<span class="gi">+          &quot;afx.audio_normalize&quot;,</span>
<span class="gi">+          &quot;afx.volumex&quot;,</span>
<span class="gi">+          &quot;transfx.crossfadein&quot;,</span>
<span class="gi">+          &quot;transfx.crossfadeout&quot;,</span>
<span class="gi">+          &quot;vfx.crop&quot;,</span>
<span class="gi">+          &quot;vfx.fadein&quot;,</span>
<span class="gi">+          &quot;vfx.fadeout&quot;,</span>
<span class="gi">+          &quot;vfx.invert_colors&quot;,</span>
<span class="gi">+          &quot;vfx.loop&quot;,</span>
<span class="gi">+          &quot;vfx.margin&quot;,</span>
<span class="gi">+          &quot;vfx.mask_and&quot;,</span>
<span class="gi">+          &quot;vfx.mask_or&quot;,</span>
<span class="gi">+          &quot;vfx.resize&quot;,</span>
<span class="gi">+          &quot;vfx.rotate&quot;,</span>
<span class="gi">+          &quot;vfx.speedx&quot;</span>
<span class="gi">+          ]:</span>
<span class="gi">+</span>
<span class="gi">+    exec(&quot;VideoClip.%s = %s&quot; % (method.split(&#39;.&#39;)[1], method))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+for method in [&quot;afx.audio_fadein&quot;,</span>
<span class="gi">+               &quot;afx.audio_fadeout&quot;,</span>
<span class="gi">+               &quot;afx.audio_loop&quot;,</span>
<span class="gi">+               &quot;afx.audio_normalize&quot;,</span>
<span class="gi">+               &quot;afx.volumex&quot;</span>
<span class="gi">+              ]:</span>
<span class="gi">+              </span>
<span class="gi">+    exec(&quot;AudioClip.%s = %s&quot; % (method.split(&#39;.&#39;)[1], method))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# adds easy ipython integration</span>
<span class="w"> </span>VideoClip.ipython_display = ipython_display
<span class="w"> </span>AudioClip.ipython_display = ipython_display
<span class="gi">+#-----------------------------------------------------------------</span>
<span class="gi">+# Previews: try to import pygame, else make methods which raise</span>
<span class="gi">+# exceptions saying to install PyGame</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Add methods preview and show (only if pygame installed)</span>
<span class="w"> </span>try:
<span class="w"> </span>    from moviepy.video.io.preview import show, preview
<span class="w"> </span>except ImportError:
<span class="gd">-</span>
<span class="w"> </span>    def preview(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;NOT AVAILABLE : clip.preview requires Pygame installed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise ImportError(&quot;clip.preview requires Pygame installed&quot;)</span>

<span class="w"> </span>    def show(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;NOT AVAILABLE : clip.show requires Pygame installed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise ImportError(&quot;clip.show requires Pygame installed&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>VideoClip.preview = preview
<span class="w"> </span>VideoClip.show = show
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from moviepy.audio.io.preview import preview
<span class="w"> </span>except ImportError:
<span class="gd">-</span>
<span class="w"> </span>    def preview(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot; NOT AVAILABLE : clip.preview requires Pygame installed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise ImportError(&quot;clip.preview requires Pygame installed&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>AudioClip.preview = preview
<span class="gh">diff --git a/moviepy/tools.py b/moviepy/tools.py</span>
<span class="gh">index 51edf95..5357c3a 100644</span>
<span class="gd">--- a/moviepy/tools.py</span>
<span class="gi">+++ b/moviepy/tools.py</span>
<span class="gu">@@ -5,18 +5,27 @@ import os</span>
<span class="w"> </span>import subprocess as sp
<span class="w"> </span>import sys
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>import proglog
<span class="gi">+</span>
<span class="w"> </span>from .compat import DEVNULL


<span class="gi">+</span>
<span class="w"> </span>def sys_write_flush(s):
<span class="w"> </span>    &quot;&quot;&quot; Writes and flushes without delay a text in the console &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Reason for not using `print` is that in some consoles &quot;print&quot; </span>
<span class="gi">+    # commands get delayed, while stdout.flush are instantaneous, </span>
<span class="gi">+    # so this method is better at providing feedback.</span>
<span class="gi">+    # See https://github.com/Zulko/moviepy/pull/485</span>
<span class="gi">+    sys.stdout.write(s)</span>
<span class="gi">+    sys.stdout.flush()</span>


<span class="w"> </span>def verbose_print(verbose, s):
<span class="w"> </span>    &quot;&quot;&quot; Only prints s (with sys_write_flush) if verbose is True.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if verbose:</span>
<span class="gi">+        sys_write_flush(s)</span>


<span class="w"> </span>def subprocess_call(cmd, logger=&#39;bar&#39;, errorprint=True):
<span class="gu">@@ -24,13 +33,37 @@ def subprocess_call(cmd, logger=&#39;bar&#39;, errorprint=True):</span>

<span class="w"> </span>    Set logger to None or a custom Proglog logger to avoid printings.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+    logger(message=&#39;Moviepy - Running:\n&gt;&gt;&gt; &quot;+ &quot; &quot;.join(cmd)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    popen_params = {&quot;stdout&quot;: DEVNULL,</span>
<span class="gi">+                    &quot;stderr&quot;: sp.PIPE,</span>
<span class="gi">+                    &quot;stdin&quot;: DEVNULL}</span>
<span class="gi">+</span>
<span class="gi">+    if os.name == &quot;nt&quot;:</span>
<span class="gi">+        popen_params[&quot;creationflags&quot;] = 0x08000000</span>
<span class="gi">+</span>
<span class="gi">+    proc = sp.Popen(cmd, **popen_params)</span>

<span class="gi">+    out, err = proc.communicate() # proc.wait()</span>
<span class="gi">+    proc.stderr.close()</span>
<span class="gi">+</span>
<span class="gi">+    if proc.returncode:</span>
<span class="gi">+        if errorprint:</span>
<span class="gi">+            logger(message=&#39;Moviepy - Command returned an error&#39;)</span>
<span class="gi">+        raise IOError(err.decode(&#39;utf8&#39;))</span>
<span class="gi">+    else:</span>
<span class="gi">+        logger(message=&#39;Moviepy - Command successful&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    del proc</span>

<span class="w"> </span>def is_string(obj):
<span class="w"> </span>    &quot;&quot;&quot; Returns true if s is string or string-like object,
<span class="w"> </span>    compatible with Python 2 and Python 3.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return isinstance(obj, basestring)</span>
<span class="gi">+    except NameError:</span>
<span class="gi">+        return isinstance(obj, str)</span>


<span class="w"> </span>def cvsecs(time):
<span class="gu">@@ -56,7 +89,15 @@ def cvsecs(time):</span>
<span class="w"> </span>    &gt;&gt;&gt; cvsecs(&#39;33.5&#39;)      # only secs
<span class="w"> </span>    33.5
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    factors = (1, 60, 3600)</span>
<span class="gi">+    </span>
<span class="gi">+    if is_string(time):     </span>
<span class="gi">+        time = [float(f.replace(&#39;,&#39;, &#39;.&#39;)) for f in time.split(&#39;:&#39;)]</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(time, (tuple, list)):</span>
<span class="gi">+        return time</span>
<span class="gi">+</span>
<span class="gi">+    return sum(mult * part for mult, part in zip(factors, reversed(time)))</span>


<span class="w"> </span>def deprecated_version_of(f, oldname, newname=None):
<span class="gu">@@ -84,15 +125,53 @@ def deprecated_version_of(f, oldname, newname=None):</span>
<span class="w"> </span>    &gt;&gt;&gt;
<span class="w"> </span>    &gt;&gt;&gt; Clip.to_file = deprecated_version_of(Clip.write_file, &#39;to_file&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-extensions_dict = {&#39;mp4&#39;: {&#39;type&#39;: &#39;video&#39;, &#39;codec&#39;: [&#39;libx264&#39;, &#39;libmpeg4&#39;,</span>
<span class="gd">-    &#39;aac&#39;]}, &#39;ogv&#39;: {&#39;type&#39;: &#39;video&#39;, &#39;codec&#39;: [&#39;libtheora&#39;]}, &#39;webm&#39;: {</span>
<span class="gd">-    &#39;type&#39;: &#39;video&#39;, &#39;codec&#39;: [&#39;libvpx&#39;]}, &#39;avi&#39;: {&#39;type&#39;: &#39;video&#39;}, &#39;mov&#39;:</span>
<span class="gd">-    {&#39;type&#39;: &#39;video&#39;}, &#39;ogg&#39;: {&#39;type&#39;: &#39;audio&#39;, &#39;codec&#39;: [&#39;libvorbis&#39;]},</span>
<span class="gd">-    &#39;mp3&#39;: {&#39;type&#39;: &#39;audio&#39;, &#39;codec&#39;: [&#39;libmp3lame&#39;]}, &#39;wav&#39;: {&#39;type&#39;:</span>
<span class="gd">-    &#39;audio&#39;, &#39;codec&#39;: [&#39;pcm_s16le&#39;, &#39;pcm_s24le&#39;, &#39;pcm_s32le&#39;]}, &#39;m4a&#39;: {</span>
<span class="gd">-    &#39;type&#39;: &#39;audio&#39;, &#39;codec&#39;: [&#39;libfdk_aac&#39;]}}</span>
<span class="gd">-for ext in [&#39;jpg&#39;, &#39;jpeg&#39;, &#39;png&#39;, &#39;bmp&#39;, &#39;tiff&#39;]:</span>
<span class="gd">-    extensions_dict[ext] = {&#39;type&#39;: &#39;image&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    if newname is None: newname = f.__name__</span>
<span class="gi">+</span>
<span class="gi">+    warning= (&quot;The function ``%s`` is deprecated and is kept temporarily &quot;</span>
<span class="gi">+              &quot;for backwards compatibility.\nPlease use the new name, &quot;</span>
<span class="gi">+              &quot;``%s``, instead.&quot;)%(oldname, newname)</span>
<span class="gi">+</span>
<span class="gi">+    def fdepr(*a, **kw):</span>
<span class="gi">+        warnings.warn(&quot;MoviePy: &quot; + warning, PendingDeprecationWarning)</span>
<span class="gi">+        return f(*a, **kw)</span>
<span class="gi">+    fdepr.__doc__ = warning</span>
<span class="gi">+</span>
<span class="gi">+    return fdepr</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# non-exhaustive dictionnary to store default informations.</span>
<span class="gi">+# any addition is most welcome.</span>
<span class="gi">+# Note that &#39;gif&#39; is complicated to place. From a VideoFileClip point of view,</span>
<span class="gi">+# it is a video, but from a HTML5 point of view, it is an image.</span>
<span class="gi">+</span>
<span class="gi">+extensions_dict = { &quot;mp4&quot;:  {&#39;type&#39;:&#39;video&#39;, &#39;codec&#39;:[&#39;libx264&#39;,&#39;libmpeg4&#39;, &#39;aac&#39;]},</span>
<span class="gi">+                    &#39;ogv&#39;:  {&#39;type&#39;:&#39;video&#39;, &#39;codec&#39;:[&#39;libtheora&#39;]},</span>
<span class="gi">+                    &#39;webm&#39;: {&#39;type&#39;:&#39;video&#39;, &#39;codec&#39;:[&#39;libvpx&#39;]},</span>
<span class="gi">+                    &#39;avi&#39;:  {&#39;type&#39;:&#39;video&#39;},</span>
<span class="gi">+                    &#39;mov&#39;:  {&#39;type&#39;:&#39;video&#39;},</span>
<span class="gi">+</span>
<span class="gi">+                    &#39;ogg&#39;:  {&#39;type&#39;:&#39;audio&#39;, &#39;codec&#39;:[&#39;libvorbis&#39;]},</span>
<span class="gi">+                    &#39;mp3&#39;:  {&#39;type&#39;:&#39;audio&#39;, &#39;codec&#39;:[&#39;libmp3lame&#39;]},</span>
<span class="gi">+                    &#39;wav&#39;:  {&#39;type&#39;:&#39;audio&#39;, &#39;codec&#39;:[&#39;pcm_s16le&#39;, &#39;pcm_s24le&#39;, &#39;pcm_s32le&#39;]},</span>
<span class="gi">+                    &#39;m4a&#39;:  {&#39;type&#39;:&#39;audio&#39;, &#39;codec&#39;:[&#39;libfdk_aac&#39;]}</span>
<span class="gi">+                  }</span>
<span class="gi">+</span>
<span class="gi">+for ext in [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;tiff&quot;]:</span>
<span class="gi">+    extensions_dict[ext] = {&#39;type&#39;:&#39;image&#39;}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_extension(codec):</span>
<span class="gi">+    if codec in extensions_dict:</span>
<span class="gi">+        # codec is already the extension</span>
<span class="gi">+        return codec</span>
<span class="gi">+</span>
<span class="gi">+    for ext,infos in extensions_dict.items():</span>
<span class="gi">+        if codec in infos.get(&#39;codec&#39;, []):</span>
<span class="gi">+            return ext</span>
<span class="gi">+    raise ValueError(</span>
<span class="gi">+        &quot;The audio_codec you chose is unknown by MoviePy. &quot;</span>
<span class="gi">+        &quot;You should report this. In the meantime, you can &quot;</span>
<span class="gi">+        &quot;specify a temp_audiofile with the right extension &quot;</span>
<span class="gi">+        &quot;in write_videofile.&quot;</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/moviepy/utils.py b/moviepy/utils.py</span>
<span class="gh">index dfc7f21..705cb49 100644</span>
<span class="gd">--- a/moviepy/utils.py</span>
<span class="gi">+++ b/moviepy/utils.py</span>
<span class="gu">@@ -1,5 +1,20 @@</span>
<span class="w"> </span>from moviepy.audio.io.AudioFileClip import AudioFileClip
<span class="w"> </span>from moviepy.video.io.VideoFileClip import VideoFileClip
<span class="w"> </span>from moviepy.video.VideoClip import ImageClip
<span class="gd">-CLIP_TYPES = {&#39;audio&#39;: AudioFileClip, &#39;video&#39;: VideoFileClip, &#39;image&#39;:</span>
<span class="gd">-    ImageClip}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+CLIP_TYPES = {</span>
<span class="gi">+    &#39;audio&#39;: AudioFileClip,</span>
<span class="gi">+    &#39;video&#39;: VideoFileClip,</span>
<span class="gi">+    &#39;image&#39;: ImageClip,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+def close_all_clips(objects=&#39;globals&#39;, types=(&#39;audio&#39;, &#39;video&#39;, &#39;image&#39;)):</span>
<span class="gi">+    if objects == &#39;globals&#39;:</span>
<span class="gi">+        objects = globals()</span>
<span class="gi">+    if hasattr(objects, &#39;values&#39;):</span>
<span class="gi">+        objects = objects.values()</span>
<span class="gi">+    types_tuple = tuple(CLIP_TYPES[key] for key in types)</span>
<span class="gi">+    for obj in objects:</span>
<span class="gi">+        if isinstance(obj, types_tuple):</span>
<span class="gi">+            obj.close()</span>
<span class="gh">diff --git a/moviepy/version.py b/moviepy/version.py</span>
<span class="gh">index 3f6fab6..976498a 100644</span>
<span class="gd">--- a/moviepy/version.py</span>
<span class="gi">+++ b/moviepy/version.py</span>
<span class="gu">@@ -1 +1 @@</span>
<span class="gd">-__version__ = &#39;1.0.3&#39;</span>
<span class="gi">+__version__ = &quot;1.0.3&quot;</span>
<span class="gh">diff --git a/moviepy/video/VideoClip.py b/moviepy/video/VideoClip.py</span>
<span class="gh">index d855ddb..d19d253 100644</span>
<span class="gd">--- a/moviepy/video/VideoClip.py</span>
<span class="gi">+++ b/moviepy/video/VideoClip.py</span>
<span class="gu">@@ -8,16 +8,22 @@ import os</span>
<span class="w"> </span>import subprocess as sp
<span class="w"> </span>import tempfile
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import proglog
<span class="w"> </span>from imageio import imread, imsave
<span class="gi">+</span>
<span class="w"> </span>from ..Clip import Clip
<span class="w"> </span>from ..compat import DEVNULL, string_types
<span class="w"> </span>from ..config import get_setting
<span class="gd">-from ..decorators import add_mask_if_none, apply_to_mask, convert_masks_to_RGB, convert_to_seconds, outplace, requires_duration, use_clip_fps_by_default</span>
<span class="gd">-from ..tools import deprecated_version_of, extensions_dict, find_extension, is_string, subprocess_call</span>
<span class="gi">+from ..decorators import (add_mask_if_none, apply_to_mask,</span>
<span class="gi">+                          convert_masks_to_RGB, convert_to_seconds, outplace,</span>
<span class="gi">+                          requires_duration, use_clip_fps_by_default)</span>
<span class="gi">+from ..tools import (deprecated_version_of, extensions_dict, find_extension,</span>
<span class="gi">+                     is_string, subprocess_call)</span>
<span class="w"> </span>from .io.ffmpeg_writer import ffmpeg_write_video
<span class="gd">-from .io.gif_writers import write_gif, write_gif_with_image_io, write_gif_with_tempfiles</span>
<span class="gi">+from .io.gif_writers import (write_gif, write_gif_with_image_io,</span>
<span class="gi">+                             write_gif_with_tempfiles)</span>
<span class="w"> </span>from .tools.drawing import blit


<span class="gu">@@ -69,7 +75,7 @@ class VideoClip(Clip):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, make_frame=None, ismask=False, duration=None,
<span class="gd">-        has_constant_size=True):</span>
<span class="gi">+                 has_constant_size=True):</span>
<span class="w"> </span>        Clip.__init__(self)
<span class="w"> </span>        self.mask = None
<span class="w"> </span>        self.audio = None
<span class="gu">@@ -79,11 +85,26 @@ class VideoClip(Clip):</span>
<span class="w"> </span>            self.make_frame = make_frame
<span class="w"> </span>            self.size = self.get_frame(0).shape[:2][::-1]
<span class="w"> </span>        self.ismask = ismask
<span class="gd">-        self.has_constant_size = has_constant_size</span>
<span class="gi">+        self.has_constant_size=has_constant_size</span>
<span class="w"> </span>        if duration is not None:
<span class="w"> </span>            self.duration = duration
<span class="w"> </span>            self.end = duration

<span class="gi">+    @property</span>
<span class="gi">+    def w(self):</span>
<span class="gi">+        return self.size[0]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def h(self):</span>
<span class="gi">+        return self.size[1]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def aspect_ratio(self):</span>
<span class="gi">+        return self.w / float(self.h)</span>
<span class="gi">+</span>
<span class="gi">+    # ===============================================================</span>
<span class="gi">+    # EXPORT OPERATIONS</span>
<span class="gi">+</span>
<span class="w"> </span>    @convert_to_seconds([&#39;t&#39;])
<span class="w"> </span>    @convert_masks_to_RGB
<span class="w"> </span>    def save_frame(self, filename, t=0, withmask=True):
<span class="gu">@@ -97,17 +118,29 @@ class VideoClip(Clip):</span>
<span class="w"> </span>        the alpha layer of the picture (only works with PNGs).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        im = self.get_frame(t)</span>
<span class="gi">+        if withmask and self.mask is not None:</span>
<span class="gi">+            mask = 255 * self.mask.get_frame(t)</span>
<span class="gi">+            im = np.dstack([im, mask]).astype(&#39;uint8&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            im = im.astype(&quot;uint8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        imsave(filename, im)</span>

<span class="w"> </span>    @requires_duration
<span class="w"> </span>    @use_clip_fps_by_default
<span class="w"> </span>    @convert_masks_to_RGB
<span class="gd">-    def write_videofile(self, filename, fps=None, codec=None, bitrate=None,</span>
<span class="gd">-        audio=True, audio_fps=44100, preset=&#39;medium&#39;, audio_nbytes=4,</span>
<span class="gd">-        audio_codec=None, audio_bitrate=None, audio_bufsize=2000,</span>
<span class="gd">-        temp_audiofile=None, rewrite_audio=True, remove_temp=True,</span>
<span class="gd">-        write_logfile=False, verbose=True, threads=None, ffmpeg_params=None,</span>
<span class="gd">-        logger=&#39;bar&#39;):</span>
<span class="gi">+    def write_videofile(self, filename, fps=None, codec=None,</span>
<span class="gi">+                        bitrate=None, audio=True, audio_fps=44100,</span>
<span class="gi">+                        preset=&quot;medium&quot;,</span>
<span class="gi">+                        audio_nbytes=4, audio_codec=None,</span>
<span class="gi">+                        audio_bitrate=None, audio_bufsize=2000,</span>
<span class="gi">+                        temp_audiofile=None,</span>
<span class="gi">+                        rewrite_audio=True, remove_temp=True,</span>
<span class="gi">+                        write_logfile=False, verbose=True,</span>
<span class="gi">+                        threads=None, ffmpeg_params=None,</span>
<span class="gi">+                        logger=&#39;bar&#39;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Write the clip to a videofile.

<span class="w"> </span>        Parameters
<span class="gu">@@ -219,13 +252,70 @@ class VideoClip(Clip):</span>
<span class="w"> </span>        &gt;&gt;&gt; clip.close()

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        name, ext = os.path.splitext(os.path.basename(filename))</span>
<span class="gi">+        ext = ext[1:].lower()</span>
<span class="gi">+        logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+</span>
<span class="gi">+        if codec is None:</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                codec = extensions_dict[ext][&#39;codec&#39;][0]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                raise ValueError(&quot;MoviePy couldn&#39;t find the codec associated &quot;</span>
<span class="gi">+                                 &quot;with the filename. Provide the &#39;codec&#39; &quot;</span>
<span class="gi">+                                 &quot;parameter in write_videofile.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if audio_codec is None:</span>
<span class="gi">+            if ext in [&#39;ogv&#39;, &#39;webm&#39;]:</span>
<span class="gi">+                audio_codec = &#39;libvorbis&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                audio_codec = &#39;libmp3lame&#39;</span>
<span class="gi">+        elif audio_codec == &#39;raw16&#39;:</span>
<span class="gi">+            audio_codec = &#39;pcm_s16le&#39;</span>
<span class="gi">+        elif audio_codec == &#39;raw32&#39;:</span>
<span class="gi">+            audio_codec = &#39;pcm_s32le&#39;</span>
<span class="gi">+</span>
<span class="gi">+        audiofile = audio if is_string(audio) else None</span>
<span class="gi">+        make_audio = ((audiofile is None) and (audio == True) and</span>
<span class="gi">+                      (self.audio is not None))</span>
<span class="gi">+</span>
<span class="gi">+        if make_audio and temp_audiofile:</span>
<span class="gi">+            # The audio will be the clip&#39;s audio</span>
<span class="gi">+            audiofile = temp_audiofile</span>
<span class="gi">+        elif make_audio:</span>
<span class="gi">+            audio_ext = find_extension(audio_codec)</span>
<span class="gi">+            audiofile = (name + Clip._TEMP_FILES_PREFIX + &quot;wvf_snd.%s&quot; % audio_ext)</span>
<span class="gi">+</span>
<span class="gi">+        # enough cpu for multiprocessing ? USELESS RIGHT NOW, WILL COME AGAIN</span>
<span class="gi">+        # enough_cpu = (multiprocessing.cpu_count() &gt; 1)</span>
<span class="gi">+        logger(message=&quot;Moviepy - Building video %s.&quot; % filename)</span>
<span class="gi">+        if make_audio:</span>
<span class="gi">+            self.audio.write_audiofile(audiofile, audio_fps,</span>
<span class="gi">+                                       audio_nbytes, audio_bufsize,</span>
<span class="gi">+                                       audio_codec, bitrate=audio_bitrate,</span>
<span class="gi">+                                       write_logfile=write_logfile,</span>
<span class="gi">+                                       verbose=verbose,</span>
<span class="gi">+                                       logger=logger)</span>
<span class="gi">+</span>
<span class="gi">+        ffmpeg_write_video(self, filename, fps, codec,</span>
<span class="gi">+                           bitrate=bitrate,</span>
<span class="gi">+                           preset=preset,</span>
<span class="gi">+                           write_logfile=write_logfile,</span>
<span class="gi">+                           audiofile=audiofile,</span>
<span class="gi">+                           verbose=verbose, threads=threads,</span>
<span class="gi">+                           ffmpeg_params=ffmpeg_params,</span>
<span class="gi">+                           logger=logger)</span>
<span class="gi">+</span>
<span class="gi">+        if remove_temp and make_audio:</span>
<span class="gi">+            if os.path.exists(audiofile):</span>
<span class="gi">+                os.remove(audiofile)</span>
<span class="gi">+        logger(message=&quot;Moviepy - video ready %s&quot; % filename)</span>

<span class="w"> </span>    @requires_duration
<span class="w"> </span>    @use_clip_fps_by_default
<span class="w"> </span>    @convert_masks_to_RGB
<span class="w"> </span>    def write_images_sequence(self, nameformat, fps=None, verbose=True,
<span class="gd">-        withmask=True, logger=&#39;bar&#39;):</span>
<span class="gi">+                              withmask=True, logger=&#39;bar&#39;):</span>
<span class="w"> </span>        &quot;&quot;&quot; Writes the videoclip to a sequence of image files.

<span class="w"> </span>        Parameters
<span class="gu">@@ -265,13 +355,26 @@ class VideoClip(Clip):</span>
<span class="w"> </span>        ``ImageSequenceClip``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+        logger(message=&#39;Moviepy - Writing frames %s.&#39; % nameformat)</span>
<span class="gi">+</span>
<span class="gi">+        tt = np.arange(0, self.duration, 1.0 / fps)</span>
<span class="gi">+</span>
<span class="gi">+        filenames = []</span>
<span class="gi">+        for i, t in logger.iter_bar(t=list(enumerate(tt))):</span>
<span class="gi">+            name = nameformat % i</span>
<span class="gi">+            filenames.append(name)</span>
<span class="gi">+            self.save_frame(name, t, withmask=withmask)</span>
<span class="gi">+        logger(message=&#39;Moviepy - Done writing frames %s.&#39; % nameformat)</span>
<span class="gi">+</span>
<span class="gi">+        return filenames</span>

<span class="w"> </span>    @requires_duration
<span class="w"> </span>    @convert_masks_to_RGB
<span class="gd">-    def write_gif(self, filename, fps=None, program=&#39;imageio&#39;, opt=&#39;nq&#39;,</span>
<span class="gd">-        fuzz=1, verbose=True, loop=0, dispose=False, colors=None, tempfiles</span>
<span class="gd">-        =False, logger=&#39;bar&#39;):</span>
<span class="gi">+    def write_gif(self, filename, fps=None, program=&#39;imageio&#39;,</span>
<span class="gi">+                  opt=&#39;nq&#39;, fuzz=1, verbose=True,</span>
<span class="gi">+                  loop=0, dispose=False, colors=None, tempfiles=False,</span>
<span class="gi">+                  logger=&#39;bar&#39;):</span>
<span class="w"> </span>        &quot;&quot;&quot; Write the VideoClip to a GIF file.

<span class="w"> </span>        Converts a VideoClip into an animated GIF using ImageMagick
<span class="gu">@@ -322,7 +425,33 @@ class VideoClip(Clip):</span>
<span class="w"> </span>            &gt;&gt;&gt; myClip.speedx(0.5).to_gif(&#39;myClip.gif&#39;)

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # A little sketchy at the moment, maybe move all that in write_gif,</span>
<span class="gi">+        #  refactor a little... we will see.</span>
<span class="gi">+</span>
<span class="gi">+        if program == &#39;imageio&#39;:</span>
<span class="gi">+            write_gif_with_image_io(self, filename, fps=fps, opt=opt, loop=loop,</span>
<span class="gi">+                                    verbose=verbose, colors=colors,</span>
<span class="gi">+                                    logger=logger)</span>
<span class="gi">+        elif tempfiles:</span>
<span class="gi">+            # convert imageio opt variable to something that can be used with</span>
<span class="gi">+            # ImageMagick</span>
<span class="gi">+            opt = &#39;optimizeplus&#39; if opt == &#39;nq&#39; else &#39;OptimizeTransparency&#39;</span>
<span class="gi">+            write_gif_with_tempfiles(self, filename, fps=fps,</span>
<span class="gi">+                                     program=program, opt=opt, fuzz=fuzz,</span>
<span class="gi">+                                     verbose=verbose, loop=loop,</span>
<span class="gi">+                                     dispose=dispose, colors=colors,</span>
<span class="gi">+                                     logger=logger)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # convert imageio opt variable to something that can be used with</span>
<span class="gi">+            # ImageMagick</span>
<span class="gi">+            opt = &#39;optimizeplus&#39; if opt == &#39;nq&#39; else &#39;OptimizeTransparency&#39;</span>
<span class="gi">+            write_gif(self, filename, fps=fps, program=program,</span>
<span class="gi">+                      opt=opt, fuzz=fuzz, verbose=verbose, loop=loop,</span>
<span class="gi">+                      dispose=dispose, colors=colors,</span>
<span class="gi">+                      logger=logger)</span>
<span class="gi">+</span>
<span class="gi">+    # -----------------------------------------------------------------</span>
<span class="gi">+    # F I L T E R I N G</span>

<span class="w"> </span>    def subfx(self, fx, ta=0, tb=None, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Apply a transformation to a part of the clip.
<span class="gu">@@ -339,14 +468,46 @@ class VideoClip(Clip):</span>
<span class="w"> </span>        &gt;&gt;&gt; newclip = clip.subapply(lambda c:c.speedx(0.5) , 3,6)

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        left = self.subclip(0, ta) if ta else None</span>
<span class="gi">+        center = self.subclip(ta, tb).fx(fx, **kwargs)</span>
<span class="gi">+        right = self.subclip(t_start=tb) if tb else None</span>
<span class="gi">+</span>
<span class="gi">+        clips = [c for c in (left, center, right) if c]</span>
<span class="gi">+</span>
<span class="gi">+        # beurk, have to find other solution</span>
<span class="gi">+        from moviepy.video.compositing.concatenate import concatenate_videoclips</span>
<span class="gi">+</span>
<span class="gi">+        return concatenate_videoclips(clips).set_start(self.start)</span>
<span class="gi">+</span>
<span class="gi">+    # IMAGE FILTERS</span>

<span class="w"> </span>    def fl_image(self, image_func, apply_to=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Modifies the images of a clip by replacing the frame
<span class="w"> </span>        `get_frame(t)` by another frame,  `image_func(get_frame(t))`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        apply_to = apply_to or []</span>
<span class="gi">+        return self.fl(lambda gf, t: image_func(gf(t)), apply_to)</span>
<span class="gi">+</span>
<span class="gi">+    # --------------------------------------------------------------</span>
<span class="gi">+    # C O M P O S I T I N G</span>
<span class="gi">+</span>
<span class="gi">+    def fill_array(self, pre_array, shape=(0, 0)):</span>
<span class="gi">+        pre_shape = pre_array.shape</span>
<span class="gi">+        dx = shape[0] - pre_shape[0]</span>
<span class="gi">+        dy = shape[1] - pre_shape[1]</span>
<span class="gi">+        post_array = pre_array</span>
<span class="gi">+        if dx &lt; 0:</span>
<span class="gi">+            post_array = pre_array[:shape[0]]</span>
<span class="gi">+        elif dx &gt; 0:</span>
<span class="gi">+            x_1 = [[[1, 1, 1]] * pre_shape[1]] * dx</span>
<span class="gi">+            post_array = np.vstack((pre_array, x_1))</span>
<span class="gi">+        if dy &lt; 0:</span>
<span class="gi">+            post_array = post_array[:, :shape[1]]</span>
<span class="gi">+        elif dy &gt; 0:</span>
<span class="gi">+            x_1 = [[[1, 1, 1]] * dy] * post_array.shape[0]</span>
<span class="gi">+            post_array = np.hstack((post_array, x_1))</span>
<span class="gi">+        return post_array</span>

<span class="w"> </span>    def blit_on(self, picture, t):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -354,7 +515,53 @@ class VideoClip(Clip):</span>
<span class="w"> </span>        on the given `picture`, the position of the clip being given
<span class="w"> </span>        by the clip&#39;s ``pos`` attribute. Meant for compositing.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hf, wf = framesize = picture.shape[:2]</span>
<span class="gi">+</span>
<span class="gi">+        if self.ismask and picture.max():</span>
<span class="gi">+            return np.minimum(1, picture + self.blit_on(np.zeros(framesize), t))</span>
<span class="gi">+</span>
<span class="gi">+        ct = t - self.start  # clip time</span>
<span class="gi">+</span>
<span class="gi">+        # GET IMAGE AND MASK IF ANY</span>
<span class="gi">+</span>
<span class="gi">+        img = self.get_frame(ct)</span>
<span class="gi">+        mask = self.mask.get_frame(ct) if self.mask else None                </span>
<span class="gi">+        </span>
<span class="gi">+        if mask is not None and ((img.shape[0] != mask.shape[0]) or (img.shape[1] != mask.shape[1])):</span>
<span class="gi">+            img = self.fill_array(img, mask.shape)</span>
<span class="gi">+</span>
<span class="gi">+        hi, wi = img.shape[:2]</span>
<span class="gi">+</span>
<span class="gi">+        # SET POSITION</span>
<span class="gi">+        pos = self.pos(ct)</span>
<span class="gi">+</span>
<span class="gi">+        # preprocess short writings of the position</span>
<span class="gi">+        if isinstance(pos, str):</span>
<span class="gi">+            pos = {&#39;center&#39;: [&#39;center&#39;, &#39;center&#39;],</span>
<span class="gi">+                   &#39;left&#39;: [&#39;left&#39;, &#39;center&#39;],</span>
<span class="gi">+                   &#39;right&#39;: [&#39;right&#39;, &#39;center&#39;],</span>
<span class="gi">+                   &#39;top&#39;: [&#39;center&#39;, &#39;top&#39;],</span>
<span class="gi">+                   &#39;bottom&#39;: [&#39;center&#39;, &#39;bottom&#39;]}[pos]</span>
<span class="gi">+        else:</span>
<span class="gi">+            pos = list(pos)</span>
<span class="gi">+</span>
<span class="gi">+        # is the position relative (given in % of the clip&#39;s size) ?</span>
<span class="gi">+        if self.relative_pos:</span>
<span class="gi">+            for i, dim in enumerate([wf, hf]):</span>
<span class="gi">+                if not isinstance(pos[i], str):</span>
<span class="gi">+                    pos[i] = dim * pos[i]</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(pos[0], str):</span>
<span class="gi">+            D = {&#39;left&#39;: 0, &#39;center&#39;: (wf - wi) / 2, &#39;right&#39;: wf - wi}</span>
<span class="gi">+            pos[0] = D[pos[0]]</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(pos[1], str):</span>
<span class="gi">+            D = {&#39;top&#39;: 0, &#39;center&#39;: (hf - hi) / 2, &#39;bottom&#39;: hf - hi}</span>
<span class="gi">+            pos[1] = D[pos[1]]</span>
<span class="gi">+</span>
<span class="gi">+        pos = map(int, pos)</span>
<span class="gi">+</span>
<span class="gi">+        return blit(img, picture, pos, mask=mask, ismask=self.ismask)</span>

<span class="w"> </span>    def add_mask(self):
<span class="w"> </span>        &quot;&quot;&quot;Add a mask VideoClip to the VideoClip.
<span class="gu">@@ -366,9 +573,16 @@ class VideoClip(Clip):</span>
<span class="w"> </span>        Set ``constant_size`` to  `False` for clips with moving
<span class="w"> </span>        image size.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.has_constant_size:</span>
<span class="gi">+            mask = ColorClip(self.size, 1.0, ismask=True)</span>
<span class="gi">+            return self.set_mask(mask.set_duration(self.duration))</span>
<span class="gi">+        else:</span>
<span class="gi">+            make_frame = lambda t: np.ones(self.get_frame(t).shape[:2], dtype=float)</span>
<span class="gi">+            mask = VideoClip(ismask=True, make_frame=make_frame)</span>
<span class="gi">+            return self.set_mask(mask.set_duration(self.duration))</span>

<span class="gd">-    def on_color(self, size=None, color=(0, 0, 0), pos=None, col_opacity=None):</span>
<span class="gi">+    def on_color(self, size=None, color=(0, 0, 0), pos=None,</span>
<span class="gi">+                 col_opacity=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Place the clip on a colored background.

<span class="w"> </span>        Returns a clip made of the current clip overlaid on a color
<span class="gu">@@ -393,7 +607,31 @@ class VideoClip(Clip):</span>
<span class="w"> </span>          background.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .compositing.CompositeVideoClip import CompositeVideoClip</span>
<span class="gi">+</span>
<span class="gi">+        if size is None:</span>
<span class="gi">+            size = self.size</span>
<span class="gi">+        if pos is None:</span>
<span class="gi">+            pos = &#39;center&#39;</span>
<span class="gi">+        colorclip = ColorClip(size, color=color)</span>
<span class="gi">+</span>
<span class="gi">+        if col_opacity is not None:</span>
<span class="gi">+            colorclip = (ColorClip(size, color=color, duration=self.duration)</span>
<span class="gi">+                         .set_opacity(col_opacity))</span>
<span class="gi">+            result = CompositeVideoClip([colorclip, self.set_position(pos)])</span>
<span class="gi">+        else:</span>
<span class="gi">+            result = CompositeVideoClip([self.set_position(pos)],</span>
<span class="gi">+                                        size=size,</span>
<span class="gi">+                                        bg_color=color)</span>
<span class="gi">+</span>
<span class="gi">+        if (isinstance(self, ImageClip) and (not hasattr(pos, &quot;__call__&quot;))</span>
<span class="gi">+                and ((self.mask is None) or isinstance(self.mask, ImageClip))):</span>
<span class="gi">+            new_result = result.to_ImageClip()</span>
<span class="gi">+            if result.mask is not None:</span>
<span class="gi">+                new_result.mask = result.mask.to_ImageClip()</span>
<span class="gi">+            return new_result.set_duration(result.duration)</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    @outplace
<span class="w"> </span>    def set_make_frame(self, mf):
<span class="gu">@@ -402,7 +640,8 @@ class VideoClip(Clip):</span>
<span class="w"> </span>        Returns a copy of the VideoClip instance, with the make_frame
<span class="w"> </span>        attribute set to `mf`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.make_frame = mf</span>
<span class="gi">+        self.size = self.get_frame(0).shape[:2][::-1]</span>

<span class="w"> </span>    @outplace
<span class="w"> </span>    def set_audio(self, audioclip):
<span class="gu">@@ -411,7 +650,7 @@ class VideoClip(Clip):</span>
<span class="w"> </span>        Returns a copy of the VideoClip instance, with the `audio`
<span class="w"> </span>        attribute set to ``audio``, which must be an AudioClip instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.audio = audioclip</span>

<span class="w"> </span>    @outplace
<span class="w"> </span>    def set_mask(self, mask):
<span class="gu">@@ -419,7 +658,8 @@ class VideoClip(Clip):</span>

<span class="w"> </span>        Returns a copy of the VideoClip with the mask attribute set to
<span class="w"> </span>        ``mask``, which must be a greyscale (values in 0-1) VideoClip&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert mask is None or mask.ismask</span>
<span class="gi">+        self.mask = mask</span>

<span class="w"> </span>    @add_mask_if_none
<span class="w"> </span>    @outplace
<span class="gu">@@ -429,7 +669,7 @@ class VideoClip(Clip):</span>
<span class="w"> </span>        Returns a semi-transparent copy of the clip where the mask is
<span class="w"> </span>        multiplied by ``op`` (any float, normally between 0 and 1).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.mask = self.mask.fl_image(lambda pic: op * pic)</span>

<span class="w"> </span>    @apply_to_mask
<span class="w"> </span>    @outplace
<span class="gu">@@ -457,7 +697,14 @@ class VideoClip(Clip):</span>
<span class="w"> </span>        &gt;&gt;&gt; clip.set_position(lambda t: (&#39;center&#39;, 50+t) )

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.relative_pos = relative</span>
<span class="gi">+        if hasattr(pos, &#39;__call__&#39;):</span>
<span class="gi">+            self.pos = pos</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.pos = lambda t: pos</span>
<span class="gi">+</span>
<span class="gi">+    # --------------------------------------------------------------</span>
<span class="gi">+    # CONVERSIONS TO OTHER TYPES</span>

<span class="w"> </span>    @convert_to_seconds([&#39;t&#39;])
<span class="w"> </span>    def to_ImageClip(self, t=0, with_mask=True, duration=None):
<span class="gu">@@ -466,15 +713,34 @@ class VideoClip(Clip):</span>
<span class="w"> </span>        which can be expressed in seconds (15.35), in (min, sec),
<span class="w"> </span>        in (hour, min, sec), or as a string: &#39;01:03:05.35&#39;.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        newclip = ImageClip(self.get_frame(t), ismask=self.ismask,</span>
<span class="gi">+                            duration=duration)</span>
<span class="gi">+        if with_mask and self.mask is not None:</span>
<span class="gi">+            newclip.mask = self.mask.to_ImageClip(t)</span>
<span class="gi">+        return newclip</span>

<span class="w"> </span>    def to_mask(self, canal=0):
<span class="w"> </span>        &quot;&quot;&quot;Return a mask a video clip made from the clip.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ismask:</span>
<span class="gi">+            return self</span>
<span class="gi">+        else:</span>
<span class="gi">+            newclip = self.fl_image(lambda pic:</span>
<span class="gi">+                                    1.0 * pic[:, :, canal] / 255)</span>
<span class="gi">+            newclip.ismask = True</span>
<span class="gi">+            return newclip</span>

<span class="w"> </span>    def to_RGB(self):
<span class="w"> </span>        &quot;&quot;&quot;Return a non-mask video clip made from the mask video clip.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ismask:</span>
<span class="gi">+            f = lambda pic: np.dstack(3 * [255 * pic]).astype(&#39;uint8&#39;)</span>
<span class="gi">+            newclip = self.fl_image(f)</span>
<span class="gi">+            newclip.ismask = False</span>
<span class="gi">+            return newclip</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+    # ----------------------------------------------------------------</span>
<span class="gi">+    # Audio</span>

<span class="w"> </span>    @outplace
<span class="w"> </span>    def without_audio(self):
<span class="gu">@@ -483,7 +749,7 @@ class VideoClip(Clip):</span>
<span class="w"> </span>        Return a copy of the clip with audio set to None.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.audio = None</span>

<span class="w"> </span>    @outplace
<span class="w"> </span>    def afx(self, fun, *a, **k):
<span class="gu">@@ -492,7 +758,7 @@ class VideoClip(Clip):</span>
<span class="w"> </span>        Return a new clip whose audio has been transformed by ``fun``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.audio = self.audio.fx(fun, *a, **k)</span>


<span class="w"> </span>class DataVideoClip(VideoClip):
<span class="gu">@@ -516,13 +782,14 @@ class DataVideoClip(VideoClip):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, data, data_to_frame, fps, ismask=False,
<span class="gd">-        has_constant_size=True):</span>
<span class="gi">+                 has_constant_size=True):</span>
<span class="w"> </span>        self.data = data
<span class="w"> </span>        self.data_to_frame = data_to_frame
<span class="w"> </span>        self.fps = fps
<span class="gd">-        make_frame = lambda t: self.data_to_frame(self.data[int(self.fps * t)])</span>
<span class="gd">-        VideoClip.__init__(self, make_frame, ismask=ismask, duration=1.0 *</span>
<span class="gd">-            len(data) / fps, has_constant_size=has_constant_size)</span>
<span class="gi">+        make_frame = lambda t: self.data_to_frame(self.data[int(self.fps*t)])</span>
<span class="gi">+        VideoClip.__init__(self, make_frame, ismask=ismask,</span>
<span class="gi">+                           duration=1.0*len(data)/fps,</span>
<span class="gi">+                           has_constant_size=has_constant_size)</span>


<span class="w"> </span>class UpdatedVideoClip(VideoClip):
<span class="gu">@@ -565,8 +832,9 @@ class UpdatedVideoClip(VideoClip):</span>
<span class="w"> </span>            while self.world.clip_t &lt; t:
<span class="w"> </span>                world.update()
<span class="w"> </span>            return world.to_frame()
<span class="gd">-        VideoClip.__init__(self, make_frame=make_frame, ismask=ismask,</span>
<span class="gd">-            duration=duration)</span>
<span class="gi">+</span>
<span class="gi">+        VideoClip.__init__(self, make_frame=make_frame,</span>
<span class="gi">+                           ismask=ismask, duration=duration)</span>


<span class="w"> </span>&quot;&quot;&quot;---------------------------------------------------------------------
<span class="gu">@@ -613,23 +881,29 @@ class ImageClip(VideoClip):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, img, ismask=False, transparent=True, fromalpha=False,</span>
<span class="gd">-        duration=None):</span>
<span class="gi">+    def __init__(self, img, ismask=False, transparent=True,</span>
<span class="gi">+                 fromalpha=False, duration=None):</span>
<span class="w"> </span>        VideoClip.__init__(self, ismask=ismask, duration=duration)
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(img, string_types):
<span class="w"> </span>            img = imread(img)
<span class="gd">-        if len(img.shape) == 3:</span>
<span class="gi">+</span>
<span class="gi">+        if len(img.shape) == 3:  # img is (now) a RGB(a) numpy array</span>
<span class="gi">+</span>
<span class="w"> </span>            if img.shape[2] == 4:
<span class="w"> </span>                if fromalpha:
<span class="w"> </span>                    img = 1.0 * img[:, :, 3] / 255
<span class="w"> </span>                elif ismask:
<span class="w"> </span>                    img = 1.0 * img[:, :, 0] / 255
<span class="w"> </span>                elif transparent:
<span class="gd">-                    self.mask = ImageClip(1.0 * img[:, :, 3] / 255, ismask=True</span>
<span class="gd">-                        )</span>
<span class="gi">+                    self.mask = ImageClip(</span>
<span class="gi">+                        1.0 * img[:, :, 3] / 255, ismask=True)</span>
<span class="w"> </span>                    img = img[:, :, :3]
<span class="w"> </span>            elif ismask:
<span class="w"> </span>                img = 1.0 * img[:, :, 0] / 255
<span class="gi">+</span>
<span class="gi">+        # if the image was just a 2D mask, it should arrive here</span>
<span class="gi">+        # unchanged</span>
<span class="w"> </span>        self.make_frame = lambda t: img
<span class="w"> </span>        self.size = img.shape[:2][::-1]
<span class="w"> </span>        self.img = img
<span class="gu">@@ -640,7 +914,14 @@ class ImageClip(VideoClip):</span>
<span class="w"> </span>        Equivalent to VideoClip.fl . The result is no more an
<span class="w"> </span>        ImageClip, it has the class VideoClip (since it may be animated)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if apply_to is None:</span>
<span class="gi">+            apply_to = []</span>
<span class="gi">+        # When we use fl on an image clip it may become animated.</span>
<span class="gi">+        # Therefore the result is not an ImageClip, just a VideoClip.</span>
<span class="gi">+        newclip = VideoClip.fl(self, fl, apply_to=apply_to,</span>
<span class="gi">+                               keep_duration=keep_duration)</span>
<span class="gi">+        newclip.__class__ = VideoClip</span>
<span class="gi">+        return newclip</span>

<span class="w"> </span>    @outplace
<span class="w"> </span>    def fl_image(self, image_func, apply_to=None):
<span class="gu">@@ -650,10 +931,22 @@ class ImageClip(VideoClip):</span>
<span class="w"> </span>        tranformed clip is computed once and for all at the beginning,
<span class="w"> </span>        and not for each &#39;frame&#39;.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if apply_to is None:</span>
<span class="gi">+                apply_to = []</span>
<span class="gi">+        arr = image_func(self.get_frame(0))</span>
<span class="gi">+        self.size = arr.shape[:2][::-1]</span>
<span class="gi">+        self.make_frame = lambda t: arr</span>
<span class="gi">+        self.img = arr</span>
<span class="gi">+</span>
<span class="gi">+        for attr in apply_to:</span>
<span class="gi">+            a = getattr(self, attr, None)</span>
<span class="gi">+            if a is not None:</span>
<span class="gi">+                new_a = a.fl_image(image_func)</span>
<span class="gi">+                setattr(self, attr, new_a)</span>

<span class="w"> </span>    @outplace
<span class="gd">-    def fl_time(self, time_func, apply_to=None, keep_duration=False):</span>
<span class="gi">+    def fl_time(self, time_func, apply_to=None,</span>
<span class="gi">+                keep_duration=False):</span>
<span class="w"> </span>        &quot;&quot;&quot;Time-transformation filter.

<span class="w"> </span>        Applies a transformation to the clip&#39;s timeline
<span class="gu">@@ -662,15 +955,27 @@ class ImageClip(VideoClip):</span>
<span class="w"> </span>        This method does nothing for ImageClips (but it may affect their
<span class="w"> </span>        masks or their audios). The result is still an ImageClip.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-VideoClip.set_pos = deprecated_version_of(VideoClip.set_position, &#39;set_pos&#39;)</span>
<span class="gi">+        if apply_to is None:</span>
<span class="gi">+            apply_to = [&#39;mask&#39;, &#39;audio&#39;]</span>
<span class="gi">+        for attr in apply_to:</span>
<span class="gi">+            a = getattr(self, attr, None)</span>
<span class="gi">+            if a is not None:</span>
<span class="gi">+                new_a = a.fl_time(time_func)</span>
<span class="gi">+                setattr(self, attr, new_a)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ##</span>
<span class="gi">+#</span>
<span class="gi">+# The old functions to_videofile, to_gif, to_images sequences have been</span>
<span class="gi">+# replaced by the more explicite write_videofile, write_gif, etc.</span>
<span class="gi">+</span>
<span class="gi">+VideoClip.set_pos = deprecated_version_of(VideoClip.set_position,</span>
<span class="gi">+                                          &#39;set_pos&#39;)</span>
<span class="w"> </span>VideoClip.to_videofile = deprecated_version_of(VideoClip.write_videofile,
<span class="gd">-    &#39;to_videofile&#39;)</span>
<span class="gi">+                                               &#39;to_videofile&#39;)</span>
<span class="w"> </span>VideoClip.to_gif = deprecated_version_of(VideoClip.write_gif, &#39;to_gif&#39;)
<span class="gd">-VideoClip.to_images_sequence = deprecated_version_of(VideoClip.</span>
<span class="gd">-    write_images_sequence, &#39;to_images_sequence&#39;)</span>
<span class="gi">+VideoClip.to_images_sequence = deprecated_version_of(VideoClip.write_images_sequence,</span>
<span class="gi">+                                                     &#39;to_images_sequence&#39;)</span>


<span class="w"> </span>class ColorClip(ImageClip):
<span class="gu">@@ -694,22 +999,20 @@ class ColorClip(ImageClip):</span>
<span class="w"> </span>      Has been deprecated. Do not use.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, size, color=None, ismask=False, duration=None, col=None</span>
<span class="gd">-        ):</span>
<span class="gi">+    def __init__(self, size, color=None, ismask=False, duration=None, col=None):</span>
<span class="w"> </span>        if col is not None:
<span class="gd">-            warnings.warn(</span>
<span class="gd">-                &#39;The `ColorClip` parameter `col` has been deprecated. Please use `color` instead.&#39;</span>
<span class="gd">-                , DeprecationWarning)</span>
<span class="gi">+            warnings.warn(&quot;The `ColorClip` parameter `col` has been deprecated.&quot;</span>
<span class="gi">+                          &quot; Please use `color` instead.&quot;, DeprecationWarning)</span>
<span class="w"> </span>            if color is not None:
<span class="gd">-                warnings.warn(</span>
<span class="gd">-                    &#39;The arguments `color` and `col` have both been passed to `ColorClip` so `col` has been ignored.&#39;</span>
<span class="gd">-                    , UserWarning)</span>
<span class="gi">+                warnings.warn(&quot;The arguments `color` and `col` have both been &quot;</span>
<span class="gi">+                              &quot;passed to `ColorClip` so `col` has been ignored.&quot;,</span>
<span class="gi">+                              UserWarning)</span>
<span class="w"> </span>            else:
<span class="w"> </span>                color = col
<span class="w"> </span>        w, h = size
<span class="w"> </span>        shape = (h, w) if np.isscalar(color) else (h, w, len(color))
<span class="w"> </span>        ImageClip.__init__(self, np.tile(color, w * h).reshape(shape),
<span class="gd">-            ismask=ismask, duration=duration)</span>
<span class="gi">+                           ismask=ismask, duration=duration)</span>


<span class="w"> </span>class TextClip(ImageClip):
<span class="gu">@@ -777,63 +1080,76 @@ class TextClip(ImageClip):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, txt=None, filename=None, size=None, color=&#39;black&#39;,
<span class="gd">-        bg_color=&#39;transparent&#39;, fontsize=None, font=&#39;Courier&#39;, stroke_color</span>
<span class="gd">-        =None, stroke_width=1, method=&#39;label&#39;, kerning=None, align=&#39;center&#39;,</span>
<span class="gd">-        interline=None, tempfilename=None, temptxt=None, transparent=True,</span>
<span class="gd">-        remove_temp=True, print_cmd=False):</span>
<span class="gi">+                 bg_color=&#39;transparent&#39;, fontsize=None, font=&#39;Courier&#39;,</span>
<span class="gi">+                 stroke_color=None, stroke_width=1, method=&#39;label&#39;,</span>
<span class="gi">+                 kerning=None, align=&#39;center&#39;, interline=None,</span>
<span class="gi">+                 tempfilename=None, temptxt=None,</span>
<span class="gi">+                 transparent=True, remove_temp=True,</span>
<span class="gi">+                 print_cmd=False):</span>
<span class="gi">+</span>
<span class="w"> </span>        if txt is not None:
<span class="w"> </span>            if temptxt is None:
<span class="w"> </span>                temptxt_fd, temptxt = tempfile.mkstemp(suffix=&#39;.txt&#39;)
<span class="gd">-                try:</span>
<span class="gi">+                try:  # only in Python3 will this work</span>
<span class="w"> </span>                    os.write(temptxt_fd, bytes(txt, &#39;UTF8&#39;))
<span class="gd">-                except TypeError:</span>
<span class="gi">+                except TypeError:  # oops, fall back to Python2</span>
<span class="w"> </span>                    os.write(temptxt_fd, txt)
<span class="w"> </span>                os.close(temptxt_fd)
<span class="w"> </span>            txt = &#39;@&#39; + temptxt
<span class="w"> </span>        else:
<span class="gd">-            txt = &#39;@%&#39; + filename</span>
<span class="gi">+            # use a file instead of a text.</span>
<span class="gi">+            txt = &quot;@%&quot; + filename</span>
<span class="gi">+</span>
<span class="w"> </span>        if size is not None:
<span class="gd">-            size = &#39;&#39; if size[0] is None else str(size[0]), &#39;&#39; if size[1</span>
<span class="gd">-                ] is None else str(size[1])</span>
<span class="gd">-        cmd = [get_setting(&#39;IMAGEMAGICK_BINARY&#39;), &#39;-background&#39;, bg_color,</span>
<span class="gd">-            &#39;-fill&#39;, color, &#39;-font&#39;, font]</span>
<span class="gi">+            size = (&#39;&#39; if size[0] is None else str(size[0]),</span>
<span class="gi">+                    &#39;&#39; if size[1] is None else str(size[1]))</span>
<span class="gi">+</span>
<span class="gi">+        cmd = ([get_setting(&quot;IMAGEMAGICK_BINARY&quot;),</span>
<span class="gi">+               &quot;-background&quot;, bg_color,</span>
<span class="gi">+                &quot;-fill&quot;, color,</span>
<span class="gi">+                &quot;-font&quot;, font])</span>
<span class="gi">+</span>
<span class="w"> </span>        if fontsize is not None:
<span class="gd">-            cmd += [&#39;-pointsize&#39;, &#39;%d&#39; % fontsize]</span>
<span class="gi">+            cmd += [&quot;-pointsize&quot;, &quot;%d&quot; % fontsize]</span>
<span class="w"> </span>        if kerning is not None:
<span class="gd">-            cmd += [&#39;-kerning&#39;, &#39;%0.1f&#39; % kerning]</span>
<span class="gi">+            cmd += [&quot;-kerning&quot;, &quot;%0.1f&quot; % kerning]</span>
<span class="w"> </span>        if stroke_color is not None:
<span class="gd">-            cmd += [&#39;-stroke&#39;, stroke_color, &#39;-strokewidth&#39;, &#39;%.01f&#39; %</span>
<span class="gd">-                stroke_width]</span>
<span class="gi">+            cmd += [&quot;-stroke&quot;, stroke_color, &quot;-strokewidth&quot;,</span>
<span class="gi">+                    &quot;%.01f&quot; % stroke_width]</span>
<span class="w"> </span>        if size is not None:
<span class="gd">-            cmd += [&#39;-size&#39;, &#39;%sx%s&#39; % (size[0], size[1])]</span>
<span class="gi">+            cmd += [&quot;-size&quot;, &quot;%sx%s&quot; % (size[0], size[1])]</span>
<span class="w"> </span>        if align is not None:
<span class="gd">-            cmd += [&#39;-gravity&#39;, align]</span>
<span class="gi">+            cmd += [&quot;-gravity&quot;, align]</span>
<span class="w"> </span>        if interline is not None:
<span class="gd">-            cmd += [&#39;-interline-spacing&#39;, &#39;%d&#39; % interline]</span>
<span class="gi">+            cmd += [&quot;-interline-spacing&quot;, &quot;%d&quot; % interline]</span>
<span class="gi">+</span>
<span class="w"> </span>        if tempfilename is None:
<span class="w"> </span>            tempfile_fd, tempfilename = tempfile.mkstemp(suffix=&#39;.png&#39;)
<span class="w"> </span>            os.close(tempfile_fd)
<span class="gd">-        cmd += [&#39;%s:%s&#39; % (method, txt), &#39;-type&#39;, &#39;truecolormatte&#39;, </span>
<span class="gd">-            &#39;PNG32:%s&#39; % tempfilename]</span>
<span class="gi">+</span>
<span class="gi">+        cmd += [&quot;%s:%s&quot; % (method, txt),</span>
<span class="gi">+                &quot;-type&quot;, &quot;truecolormatte&quot;, &quot;PNG32:%s&quot; % tempfilename]</span>
<span class="gi">+</span>
<span class="w"> </span>        if print_cmd:
<span class="gd">-            print(&#39; &#39;.join(cmd))</span>
<span class="gi">+            print(&quot; &quot;.join(cmd))</span>
<span class="gi">+</span>
<span class="w"> </span>        try:
<span class="w"> </span>            subprocess_call(cmd, logger=None)
<span class="w"> </span>        except (IOError, OSError) as err:
<span class="gd">-            error = (</span>
<span class="gd">-                &quot;&quot;&quot;MoviePy Error: creation of %s failed because of the following error:</span>
<span class="gd">-</span>
<span class="gd">-%s.</span>
<span class="gd">-</span>
<span class="gd">-.&quot;&quot;&quot;</span>
<span class="gd">-                 % (filename, str(err)) +</span>
<span class="gd">-                &quot;This error can be due to the fact that ImageMagick is not installed on your computer, or (for Windows users) that you didn&#39;t specify the path to the ImageMagick binary in file conf.py, or that the path you specified is incorrect&quot;</span>
<span class="gd">-                )</span>
<span class="gi">+            error = (&quot;MoviePy Error: creation of %s failed because of the &quot;</span>
<span class="gi">+                     &quot;following error:\n\n%s.\n\n.&quot; % (filename, str(err))</span>
<span class="gi">+                     + (&quot;This error can be due to the fact that ImageMagick &quot;</span>
<span class="gi">+                        &quot;is not installed on your computer, or (for Windows &quot;</span>
<span class="gi">+                        &quot;users) that you didn&#39;t specify the path to the &quot;</span>
<span class="gi">+                        &quot;ImageMagick binary in file conf.py, or that the path &quot;</span>
<span class="gi">+                        &quot;you specified is incorrect&quot;))</span>
<span class="w"> </span>            raise IOError(error)
<span class="gi">+</span>
<span class="w"> </span>        ImageClip.__init__(self, tempfilename, transparent=transparent)
<span class="w"> </span>        self.txt = txt
<span class="w"> </span>        self.color = color
<span class="w"> </span>        self.stroke_color = stroke_color
<span class="gi">+</span>
<span class="w"> </span>        if remove_temp:
<span class="w"> </span>            if os.path.exists(tempfilename):
<span class="w"> </span>                os.remove(tempfilename)
<span class="gu">@@ -844,7 +1160,26 @@ class TextClip(ImageClip):</span>
<span class="w"> </span>    def list(arg):
<span class="w"> </span>        &quot;&quot;&quot;Returns the list of all valid entries for the argument of
<span class="w"> </span>        ``TextClip`` given (can be ``font``, ``color``, etc...) &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        popen_params = {&quot;stdout&quot;: sp.PIPE,</span>
<span class="gi">+                        &quot;stderr&quot;: DEVNULL,</span>
<span class="gi">+                        &quot;stdin&quot;: DEVNULL}</span>
<span class="gi">+</span>
<span class="gi">+        if os.name == &quot;nt&quot;:</span>
<span class="gi">+            popen_params[&quot;creationflags&quot;] = 0x08000000</span>
<span class="gi">+</span>
<span class="gi">+        process = sp.Popen([get_setting(&quot;IMAGEMAGICK_BINARY&quot;),</span>
<span class="gi">+                            &#39;-list&#39;, arg], **popen_params)</span>
<span class="gi">+        result = process.communicate()[0]</span>
<span class="gi">+        lines = result.splitlines()</span>
<span class="gi">+</span>
<span class="gi">+        if arg == &#39;font&#39;:</span>
<span class="gi">+            return [l.decode(&#39;UTF-8&#39;)[8:] for l in lines if l.startswith(b&quot;  Font:&quot;)]</span>
<span class="gi">+        elif arg == &#39;color&#39;:</span>
<span class="gi">+            return [l.split(b&quot; &quot;)[0] for l in lines[2:]]</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise Exception(&quot;Moviepy:Error! Argument must equal &quot;</span>
<span class="gi">+                            &quot;&#39;font&#39; or &#39;color&#39;&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def search(string, arg):
<span class="gu">@@ -855,4 +1190,6 @@ class TextClip(ImageClip):</span>
<span class="w"> </span>           &gt;&gt;&gt; print ( TextClip.search(&#39;Courier&#39;, &#39;font&#39;) )

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        string = string.lower()</span>
<span class="gi">+        names_list = TextClip.list(arg)</span>
<span class="gi">+        return [name for name in names_list if string in name.lower()]</span>
<span class="gh">diff --git a/moviepy/video/compositing/CompositeVideoClip.py b/moviepy/video/compositing/CompositeVideoClip.py</span>
<span class="gh">index fc3184d..080cd37 100644</span>
<span class="gd">--- a/moviepy/video/compositing/CompositeVideoClip.py</span>
<span class="gi">+++ b/moviepy/video/compositing/CompositeVideoClip.py</span>
<span class="gu">@@ -1,9 +1,12 @@</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>from moviepy.audio.AudioClip import CompositeAudioClip
<span class="w"> </span>from moviepy.video.VideoClip import ColorClip, VideoClip

<span class="gi">+#  CompositeVideoClip</span>

<span class="w"> </span>class CompositeVideoClip(VideoClip):
<span class="gi">+</span>
<span class="w"> </span>    &quot;&quot;&quot; 

<span class="w"> </span>    A VideoClip made of other videoclips displayed together. This is the
<span class="gu">@@ -43,22 +46,30 @@ class CompositeVideoClip(VideoClip):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, clips, size=None, bg_color=None, use_bgclip=False,
<span class="gd">-        ismask=False):</span>
<span class="gi">+                 ismask=False):</span>
<span class="gi">+</span>
<span class="w"> </span>        if size is None:
<span class="w"> </span>            size = clips[0].size
<span class="gd">-        if use_bgclip and clips[0].mask is None:</span>
<span class="gi">+</span>
<span class="gi">+        </span>
<span class="gi">+        if use_bgclip and (clips[0].mask is None):</span>
<span class="w"> </span>            transparent = False
<span class="w"> </span>        else:
<span class="gd">-            transparent = bg_color is None</span>
<span class="gi">+            transparent = (bg_color is None)</span>
<span class="gi">+        </span>
<span class="w"> </span>        if bg_color is None:
<span class="w"> </span>            bg_color = 0.0 if ismask else (0, 0, 0)
<span class="gi">+</span>
<span class="w"> </span>        fpss = [c.fps for c in clips if getattr(c, &#39;fps&#39;, None)]
<span class="w"> </span>        self.fps = max(fpss) if fpss else None
<span class="gi">+</span>
<span class="w"> </span>        VideoClip.__init__(self)
<span class="gi">+        </span>
<span class="w"> </span>        self.size = size
<span class="w"> </span>        self.ismask = ismask
<span class="w"> </span>        self.clips = clips
<span class="w"> </span>        self.bg_color = bg_color
<span class="gi">+</span>
<span class="w"> </span>        if use_bgclip:
<span class="w"> </span>            self.bg = clips[0]
<span class="w"> </span>            self.clips = clips[1:]
<span class="gu">@@ -67,37 +78,61 @@ class CompositeVideoClip(VideoClip):</span>
<span class="w"> </span>            self.clips = clips
<span class="w"> </span>            self.bg = ColorClip(size, color=self.bg_color)
<span class="w"> </span>            self.created_bg = True
<span class="gi">+</span>
<span class="gi">+        </span>
<span class="gi">+        # compute duration</span>
<span class="w"> </span>        ends = [c.end for c in self.clips]
<span class="w"> </span>        if None not in ends:
<span class="w"> </span>            duration = max(ends)
<span class="w"> </span>            self.duration = duration
<span class="w"> </span>            self.end = duration
<span class="gi">+</span>
<span class="gi">+        # compute audio</span>
<span class="w"> </span>        audioclips = [v.audio for v in self.clips if v.audio is not None]
<span class="w"> </span>        if audioclips:
<span class="w"> </span>            self.audio = CompositeAudioClip(audioclips)
<span class="gi">+</span>
<span class="gi">+        # compute mask if necessary</span>
<span class="w"> </span>        if transparent:
<span class="gd">-            maskclips = [(c.mask if c.mask is not None else c.add_mask().</span>
<span class="gd">-                mask).set_position(c.pos).set_end(c.end).set_start(c.start,</span>
<span class="gd">-                change_end=False) for c in self.clips]</span>
<span class="gd">-            self.mask = CompositeVideoClip(maskclips, self.size, ismask=</span>
<span class="gd">-                True, bg_color=0.0)</span>
<span class="gi">+            maskclips = [(c.mask if (c.mask is not None) else</span>
<span class="gi">+                          c.add_mask().mask).set_position(c.pos)</span>
<span class="gi">+                          .set_end(c.end).set_start(c.start, change_end=False)</span>
<span class="gi">+                          for c in self.clips]</span>
<span class="gi">+</span>
<span class="gi">+            self.mask = CompositeVideoClip(maskclips,self.size, ismask=True,</span>
<span class="gi">+                                               bg_color=0.0)</span>

<span class="w"> </span>        def make_frame(t):
<span class="w"> </span>            &quot;&quot;&quot; The clips playing at time `t` are blitted over one
<span class="w"> </span>                another. &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>            f = self.bg.get_frame(t)
<span class="w"> </span>            for c in self.playing_clips(t):
<span class="gd">-                f = c.blit_on(f, t)</span>
<span class="gi">+                    f = c.blit_on(f, t)</span>
<span class="w"> </span>            return f
<span class="gi">+</span>
<span class="w"> </span>        self.make_frame = make_frame

<span class="w"> </span>    def playing_clips(self, t=0):
<span class="w"> </span>        &quot;&quot;&quot; Returns a list of the clips in the composite clips that are
<span class="w"> </span>            actually playing at the given time `t`. &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [c for c in self.clips if c.is_playing(t)]</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        if self.created_bg and self.bg:</span>
<span class="gi">+            # Only close the background clip if it was locally created.</span>
<span class="gi">+            # Otherwise, it remains the job of whoever created it.</span>
<span class="gi">+            self.bg.close()</span>
<span class="gi">+            self.bg = None</span>
<span class="gi">+        if hasattr(self, &quot;audio&quot;) and self.audio:</span>
<span class="gi">+            self.audio.close()</span>
<span class="gi">+            self.audio = None</span>


<span class="gd">-def clips_array(array, rows_widths=None, cols_widths=None, bg_color=None):</span>
<span class="gi">+</span>
<span class="gi">+def clips_array(array, rows_widths=None, cols_widths=None,</span>
<span class="gi">+                bg_color = None):</span>
<span class="gi">+</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    rows_widths
<span class="gu">@@ -113,4 +148,29 @@ def clips_array(array, rows_widths=None, cols_widths=None, bg_color=None):</span>
<span class="w"> </span>       regions to be transparent (will be slower).

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    array = np.array(array)</span>
<span class="gi">+    sizes_array = np.array([[c.size for c in line] for line in array])</span>
<span class="gi">+    </span>
<span class="gi">+    # find row width and col_widths automatically if not provided</span>
<span class="gi">+    if rows_widths is None:</span>
<span class="gi">+        rows_widths = sizes_array[:,:,1].max(axis=1)</span>
<span class="gi">+    if cols_widths is None:</span>
<span class="gi">+        cols_widths = sizes_array[:,:,0].max(axis=0)</span>
<span class="gi">+    </span>
<span class="gi">+    xx = np.cumsum([0]+list(cols_widths)) </span>
<span class="gi">+    yy = np.cumsum([0]+list(rows_widths))</span>
<span class="gi">+    </span>
<span class="gi">+    for j, (x, cw) in enumerate(zip(xx[:-1], cols_widths)):</span>
<span class="gi">+        for i, (y, rw) in enumerate(zip(yy[:-1], rows_widths)):</span>
<span class="gi">+            clip = array[i, j]</span>
<span class="gi">+            w, h = clip.size</span>
<span class="gi">+            if (w &lt; cw) or (h &lt; rw):</span>
<span class="gi">+                clip = (CompositeVideoClip([clip.set_position(&#39;center&#39;)],</span>
<span class="gi">+                                          size = (cw,rw),</span>
<span class="gi">+                                          bg_color = bg_color).</span>
<span class="gi">+                                     set_duration(clip.duration))</span>
<span class="gi">+                </span>
<span class="gi">+            array[i, j] = clip.set_position((x, y))</span>
<span class="gi">+                 </span>
<span class="gi">+    return CompositeVideoClip(array.flatten(), size=(xx[-1], yy[-1]), bg_color=bg_color)</span>
<span class="gh">diff --git a/moviepy/video/compositing/concatenate.py b/moviepy/video/compositing/concatenate.py</span>
<span class="gh">index 288c1e6..5352608 100644</span>
<span class="gd">--- a/moviepy/video/compositing/concatenate.py</span>
<span class="gi">+++ b/moviepy/video/compositing/concatenate.py</span>
<span class="gu">@@ -1,17 +1,19 @@</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>from moviepy.audio.AudioClip import CompositeAudioClip
<span class="w"> </span>from moviepy.tools import deprecated_version_of
<span class="w"> </span>from moviepy.video.compositing.CompositeVideoClip import CompositeVideoClip
<span class="w"> </span>from moviepy.video.compositing.on_color import on_color
<span class="w"> </span>from moviepy.video.VideoClip import ColorClip, VideoClip
<span class="gd">-try:</span>
<span class="gd">-    reduce</span>
<span class="gd">-except NameError:</span>
<span class="gd">-    from functools import reduce</span>
<span class="gi">+</span>
<span class="gi">+try:               # Python 2</span>
<span class="gi">+   reduce</span>
<span class="gi">+except NameError:  # Python 3</span>
<span class="gi">+   from functools import reduce</span>


<span class="gd">-def concatenate_videoclips(clips, method=&#39;chain&#39;, transition=None, bg_color</span>
<span class="gd">-    =None, ismask=False, padding=0):</span>
<span class="gi">+def concatenate_videoclips(clips, method=&quot;chain&quot;, transition=None,</span>
<span class="gi">+                           bg_color=None, ismask=False, padding = 0):</span>
<span class="w"> </span>    &quot;&quot;&quot; Concatenates several video clips

<span class="w"> </span>    Returns a video clip made by clip by concatenating several video clips.
<span class="gu">@@ -60,8 +62,60 @@ def concatenate_videoclips(clips, method=&#39;chain&#39;, transition=None, bg_color</span>
<span class="w"> </span>      `compose`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if transition is not None:</span>
<span class="gi">+        l = [[v, transition] for v in clips[:-1]]</span>
<span class="gi">+        clips = reduce(lambda x, y: x + y, l) + [clips[-1]]</span>
<span class="gi">+        transition = None</span>
<span class="gi">+</span>
<span class="gi">+    tt = np.cumsum([0] + [c.duration for c in clips])</span>
<span class="gi">+</span>
<span class="gi">+    sizes = [v.size for v in clips]</span>
<span class="gi">+</span>
<span class="gi">+    w = max(r[0] for r in sizes)</span>
<span class="gi">+    h = max(r[1] for r in sizes)</span>
<span class="gi">+</span>
<span class="gi">+    tt = np.maximum(0, tt + padding * np.arange(len(tt)))</span>
<span class="gi">+</span>
<span class="gi">+    if method == &quot;chain&quot;:</span>
<span class="gi">+        def make_frame(t):</span>
<span class="gi">+            i = max([i for i, e in enumerate(tt) if e &lt;= t])</span>
<span class="gi">+            return clips[i].get_frame(t - tt[i])</span>
<span class="gi">+</span>
<span class="gi">+        def get_mask(c):</span>
<span class="gi">+            mask = c.mask or ColorClip([1, 1], color=1, ismask=True)</span>
<span class="gi">+            if mask.duration is None:</span>
<span class="gi">+               mask.duration = c.duration</span>
<span class="gi">+            return mask</span>
<span class="gi">+</span>
<span class="gi">+        result = VideoClip(ismask = ismask, make_frame = make_frame)</span>
<span class="gi">+        if any([c.mask is not None for c in clips]):</span>
<span class="gi">+            masks = [get_mask(c) for c in clips]</span>
<span class="gi">+            result.mask = concatenate_videoclips(masks, method=&quot;chain&quot;,</span>
<span class="gi">+                                                 ismask=True)</span>
<span class="gi">+            result.clips = clips</span>
<span class="gi">+    elif method == &quot;compose&quot;:</span>
<span class="gi">+        result = CompositeVideoClip( [c.set_start(t).set_position(&#39;center&#39;)</span>
<span class="gi">+                                for (c, t) in zip(clips, tt)],</span>
<span class="gi">+               size = (w, h), bg_color=bg_color, ismask=ismask)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise Exception(&quot;Moviepy Error: The &#39;method&#39; argument of &quot;</span>
<span class="gi">+                        &quot;concatenate_videoclips must be &#39;chain&#39; or &#39;compose&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    result.tt = tt</span>
<span class="gi">+</span>
<span class="gi">+    result.start_times = tt[:-1]</span>
<span class="gi">+    result.start, result.duration, result.end = 0, tt[-1] , tt[-1]</span>
<span class="gi">+</span>
<span class="gi">+    audio_t = [(c.audio, t) for c, t in zip(clips,tt) if c.audio is not None]</span>
<span class="gi">+    if audio_t:</span>
<span class="gi">+        result.audio = CompositeAudioClip([a.set_start(t)</span>
<span class="gi">+                                for a,t in audio_t])</span>
<span class="gi">+</span>
<span class="gi">+    fpss = [c.fps for c in clips if getattr(c, &#39;fps&#39;, None) is not None]</span>
<span class="gi">+    result.fps = max(fpss) if fpss else None</span>
<span class="gi">+    return result</span>


<span class="gd">-concatenate = deprecated_version_of(concatenate_videoclips, oldname=</span>
<span class="gd">-    &#39;concatenate&#39;)</span>
<span class="gi">+concatenate = deprecated_version_of(concatenate_videoclips,</span>
<span class="gi">+                                    oldname=&quot;concatenate&quot;)</span>
<span class="gh">diff --git a/moviepy/video/compositing/on_color.py b/moviepy/video/compositing/on_color.py</span>
<span class="gh">index 9f6c0bb..c5fcb14 100644</span>
<span class="gd">--- a/moviepy/video/compositing/on_color.py</span>
<span class="gi">+++ b/moviepy/video/compositing/on_color.py</span>
<span class="gu">@@ -14,4 +14,14 @@ def on_color(clip, size=None, color=(0, 0, 0), pos=None, col_opacity=None):</span>
<span class="w"> </span>    :param pos: the position of the clip in the final clip.
<span class="w"> </span>    :param col_opacity: should the added zones be transparent ?
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    if size is None:</span>
<span class="gi">+        size = clip.size</span>
<span class="gi">+    if pos is None:</span>
<span class="gi">+        pos = &#39;center&#39;</span>
<span class="gi">+    colorclip = ColorClip(size, color=color)</span>
<span class="gi">+    if col_opacity:</span>
<span class="gi">+        colorclip = colorclip.with_mask().set_opacity(col_opacity)</span>
<span class="gi">+</span>
<span class="gi">+    return CompositeVideoClip([colorclip, clip.set_position(pos)],</span>
<span class="gi">+                              transparent=(col_opacity is not None))</span>
<span class="gh">diff --git a/moviepy/video/compositing/positioning.py b/moviepy/video/compositing/positioning.py</span>
<span class="gh">index 633f1d8..910e48b 100644</span>
<span class="gd">--- a/moviepy/video/compositing/positioning.py</span>
<span class="gi">+++ b/moviepy/video/compositing/positioning.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>This module provides classes that make positioning easy
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# class ClipPosition:</span>
<span class="gh">diff --git a/moviepy/video/compositing/transitions.py b/moviepy/video/compositing/transitions.py</span>
<span class="gh">index 4a70b7f..db38151 100644</span>
<span class="gd">--- a/moviepy/video/compositing/transitions.py</span>
<span class="gi">+++ b/moviepy/video/compositing/transitions.py</span>
<span class="gu">@@ -3,9 +3,11 @@ Here is the current catalogue. These are meant</span>
<span class="w"> </span>to be used with clip.fx. There are available as transfx.crossfadein etc.
<span class="w"> </span>if you load them with ``from moviepy.editor import *``
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from moviepy.decorators import add_mask_if_none, requires_duration
<span class="w"> </span>from moviepy.video.fx.fadein import fadein
<span class="w"> </span>from moviepy.video.fx.fadeout import fadeout
<span class="gi">+</span>
<span class="w"> </span>from .CompositeVideoClip import CompositeVideoClip


<span class="gu">@@ -15,7 +17,10 @@ def crossfadein(clip, duration):</span>
<span class="w"> </span>    &quot;&quot;&quot; Makes the clip appear progressively, over ``duration`` seconds.
<span class="w"> </span>    Only works when the clip is included in a CompositeVideoClip.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    clip.mask.duration = clip.duration</span>
<span class="gi">+    newclip = clip.copy()</span>
<span class="gi">+    newclip.mask = clip.mask.fx(fadein, duration)</span>
<span class="gi">+    return newclip</span>


<span class="w"> </span>@requires_duration
<span class="gu">@@ -24,7 +29,10 @@ def crossfadeout(clip, duration):</span>
<span class="w"> </span>    &quot;&quot;&quot; Makes the clip disappear progressively, over ``duration`` seconds.
<span class="w"> </span>    Only works when the clip is included in a CompositeVideoClip.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    clip.mask.duration = clip.duration</span>
<span class="gi">+    newclip = clip.copy()</span>
<span class="gi">+    newclip.mask = clip.mask.fx(fadeout, duration)</span>
<span class="gi">+    return newclip</span>


<span class="w"> </span>def slide_in(clip, duration, side):
<span class="gu">@@ -57,7 +65,13 @@ def slide_in(clip, duration, side):</span>
<span class="w"> </span>    &gt;&gt;&gt; final_clip = concatenate( slided_clips, padding=-1)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w, h = clip.size</span>
<span class="gi">+    pos_dict = {&#39;left&#39;: lambda t: (min(0, w*(t/duration-1)), &#39;center&#39;),</span>
<span class="gi">+                &#39;right&#39;: lambda t: (max(0, w*(1-t/duration)), &#39;center&#39;),</span>
<span class="gi">+                &#39;top&#39;: lambda t: (&#39;center&#39;, min(0, h*(t/duration-1))),</span>
<span class="gi">+                &#39;bottom&#39;: lambda t: (&#39;center&#39;, max(0, h*(1-t/duration)))}</span>
<span class="gi">+</span>
<span class="gi">+    return clip.set_position(pos_dict[side])</span>


<span class="w"> </span>@requires_duration
<span class="gu">@@ -91,7 +105,15 @@ def slide_out(clip, duration, side):</span>
<span class="w"> </span>    &gt;&gt;&gt; final_clip = concatenate( slided_clips, padding=-1)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    w,h = clip.size</span>
<span class="gi">+    ts = clip.duration - duration # start time of the effect.</span>
<span class="gi">+    pos_dict = {&#39;left&#39; : lambda t: (min(0,w*(-(t-ts)/duration)),&#39;center&#39;),</span>
<span class="gi">+                &#39;right&#39; : lambda t: (max(0,w*((t-ts)/duration)),&#39;center&#39;),</span>
<span class="gi">+                &#39;top&#39; : lambda t: (&#39;center&#39;,min(0,h*(-(t-ts)/duration))),</span>
<span class="gi">+                &#39;bottom&#39;: lambda t: (&#39;center&#39;,max(0,h*((t-ts)/duration))) }</span>
<span class="gi">+</span>
<span class="gi">+    return clip.set_position(pos_dict[side])</span>


<span class="w"> </span>@requires_duration
<span class="gu">@@ -99,4 +121,6 @@ def make_loopable(clip, cross_duration):</span>
<span class="w"> </span>    &quot;&quot;&quot; Makes the clip fade in progressively at its own end, this way
<span class="w"> </span>    it can be looped indefinitely. ``cross`` is the duration in seconds
<span class="w"> </span>    of the fade-in.  &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    d = clip.duration</span>
<span class="gi">+    clip2 = clip.fx(crossfadein, cross_duration).set_start(d - cross_duration)</span>
<span class="gi">+    return CompositeVideoClip([clip, clip2]).subclip(cross_duration, d)</span>
<span class="gh">diff --git a/moviepy/video/fx/accel_decel.py b/moviepy/video/fx/accel_decel.py</span>
<span class="gh">index 2a5708a..6fbb4cc 100644</span>
<span class="gd">--- a/moviepy/video/fx/accel_decel.py</span>
<span class="gi">+++ b/moviepy/video/fx/accel_decel.py</span>
<span class="gu">@@ -9,7 +9,14 @@ def f_accel_decel(t, old_d, new_d, abruptness=1, soonness=1.0):</span>
<span class="w"> </span>      for positive abruptness, determines how soon the
<span class="w"> </span>      speedup occurs (0&lt;soonness &lt; inf)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    a = 1.0+abruptness</span>
<span class="gi">+    def _f(t):</span>
<span class="gi">+        f1 = lambda t: (0.5)**(1-a)*(t**a)</span>
<span class="gi">+        f2 = lambda t: (1-f1(1-t))</span>
<span class="gi">+        return (t&lt;.5)*f1(t) + (t&gt;=.5)*f2(t) </span>
<span class="gi">+    </span>
<span class="gi">+    return old_d*_f((t/new_d)**soonness)</span>


<span class="w"> </span>def accel_decel(clip, new_duration=None, abruptness=1.0, soonness=1.0):
<span class="gu">@@ -27,4 +34,11 @@ def accel_decel(clip, new_duration=None, abruptness=1.0, soonness=1.0):</span>
<span class="w"> </span>      for positive abruptness, determines how soon the
<span class="w"> </span>      speedup occurs (0&lt;soonness &lt; inf)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    if new_duration is None:</span>
<span class="gi">+        new_duration = clip.duration</span>
<span class="gi">+    </span>
<span class="gi">+    fl = lambda t : f_accel_decel(t, clip.duration, new_duration,</span>
<span class="gi">+                                   abruptness, soonness)</span>
<span class="gi">+</span>
<span class="gi">+    return clip.fl_time(fl).set_duration(new_duration)</span>
<span class="gh">diff --git a/moviepy/video/fx/blackwhite.py b/moviepy/video/fx/blackwhite.py</span>
<span class="gh">index 1e5c886..b6b95a8 100644</span>
<span class="gd">--- a/moviepy/video/fx/blackwhite.py</span>
<span class="gi">+++ b/moviepy/video/fx/blackwhite.py</span>
<span class="gu">@@ -1,10 +1,22 @@</span>
<span class="w"> </span>import numpy as np


<span class="gd">-def blackwhite(clip, RGB=None, preserve_luminosity=True):</span>
<span class="gi">+def blackwhite(clip, RGB = None, preserve_luminosity=True):</span>
<span class="w"> </span>    &quot;&quot;&quot; Desaturates the picture, makes it black and white.
<span class="w"> </span>    Parameter RGB allows to set weights for the different color
<span class="w"> </span>    channels.
<span class="w"> </span>    If RBG is &#39;CRT_phosphor&#39; a special set of values is used.
<span class="w"> </span>    preserve_luminosity maintains the sum of RGB to 1.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if RGB is None:</span>
<span class="gi">+        RGB = [1,1,1]</span>
<span class="gi">+</span>
<span class="gi">+    if RGB == &#39;CRT_phosphor&#39;:</span>
<span class="gi">+        RGB = [0.2125, 0.7154, 0.0721]</span>
<span class="gi">+</span>
<span class="gi">+    R,G,B = 1.0*np.array(RGB)/ (sum(RGB) if preserve_luminosity else 1)</span>
<span class="gi">+    </span>
<span class="gi">+    def fl(im):</span>
<span class="gi">+        im = (R*im[:,:,0] + G*im[:,:,1] + B*im[:,:,2])</span>
<span class="gi">+        return np.dstack(3*[im]).astype(&#39;uint8&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return clip.fl_image(fl)</span>
<span class="gh">diff --git a/moviepy/video/fx/blink.py b/moviepy/video/fx/blink.py</span>
<span class="gh">index dc6f2ce..c8a9624 100644</span>
<span class="gd">--- a/moviepy/video/fx/blink.py</span>
<span class="gi">+++ b/moviepy/video/fx/blink.py</span>
<span class="gu">@@ -7,4 +7,9 @@ def blink(clip, d_on, d_off):</span>
<span class="w"> </span>    seconds and disappear ``d_off`` seconds. Will only work in
<span class="w"> </span>    composite clips.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    newclip = copy.copy(clip)</span>
<span class="gi">+    if newclip.mask is None:</span>
<span class="gi">+        newclip = newclip.with_mask()</span>
<span class="gi">+    D = d_on + d_off</span>
<span class="gi">+    newclip.mask = newclip.mask.fl( lambda gf,t: gf(t)*((t % D) &lt; d_on))</span>
<span class="gi">+    return newclip</span>
<span class="gh">diff --git a/moviepy/video/fx/colorx.py b/moviepy/video/fx/colorx.py</span>
<span class="gh">index 31863f5..70f16d6 100644</span>
<span class="gd">--- a/moviepy/video/fx/colorx.py</span>
<span class="gi">+++ b/moviepy/video/fx/colorx.py</span>
<span class="gu">@@ -6,4 +6,5 @@ def colorx(clip, factor):</span>
<span class="w"> </span>        to decrease or increase the clip&#39;s brightness (is that the
<span class="w"> </span>        reight word ?)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return clip.fl_image( lambda pic: np.minimum(255,(factor*pic)).</span>
<span class="gi">+                                                        astype(&#39;uint8&#39;))</span>
<span class="gh">diff --git a/moviepy/video/fx/crop.py b/moviepy/video/fx/crop.py</span>
<span class="gh">index cb20ab6..8066418 100644</span>
<span class="gd">--- a/moviepy/video/fx/crop.py</span>
<span class="gi">+++ b/moviepy/video/fx/crop.py</span>
<span class="gu">@@ -1,5 +1,4 @@</span>
<span class="gd">-def crop(clip, x1=None, y1=None, x2=None, y2=None, width=None, height=None,</span>
<span class="gd">-    x_center=None, y_center=None):</span>
<span class="gi">+def crop(clip, x1=None, y1=None, x2=None, y2=None, width=None, height=None, x_center=None, y_center=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns a new clip in which just a rectangular subregion of the
<span class="w"> </span>    original clip is conserved. x1,y1 indicates the top left corner and
<span class="gu">@@ -29,4 +28,26 @@ def crop(clip, x1=None, y1=None, x2=None, y2=None, width=None, height=None,</span>
<span class="w"> </span>    &gt;&gt;&gt; crop(x_center=300, width=400, y1=100, y2=600)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if width and x1 is not None:</span>
<span class="gi">+        x2 = x1 + width</span>
<span class="gi">+    elif width and x2 is not None:</span>
<span class="gi">+        x1 = x2 - width</span>
<span class="gi">+</span>
<span class="gi">+    if height and y1 is not None:</span>
<span class="gi">+        y2 = y1 + height</span>
<span class="gi">+    elif height and y2 is not None:</span>
<span class="gi">+        y1 = y2 - height</span>
<span class="gi">+</span>
<span class="gi">+    if x_center:</span>
<span class="gi">+        x1, x2 = x_center - width / 2, x_center + width / 2</span>
<span class="gi">+</span>
<span class="gi">+    if y_center:</span>
<span class="gi">+        y1, y2 = y_center - height / 2, y_center + height / 2</span>
<span class="gi">+</span>
<span class="gi">+    x1 = x1 or 0</span>
<span class="gi">+    y1 = y1 or 0</span>
<span class="gi">+    x2 = x2 or clip.size[0]</span>
<span class="gi">+    y2 = y2 or clip.size[1]</span>
<span class="gi">+</span>
<span class="gi">+    return clip.fl_image(lambda pic: pic[int(y1) : int(y2), int(x1) : int(x2)], apply_to=[&quot;mask&quot;])</span>
<span class="gh">diff --git a/moviepy/video/fx/even_size.py b/moviepy/video/fx/even_size.py</span>
<span class="gh">index 3ca8ea7..c7290b8 100644</span>
<span class="gd">--- a/moviepy/video/fx/even_size.py</span>
<span class="gi">+++ b/moviepy/video/fx/even_size.py</span>
<span class="gu">@@ -6,4 +6,17 @@ def even_size(clip):</span>
<span class="w"> </span>    &quot;&quot;&quot; 
<span class="w"> </span>    Crops the clip to make dimensions even.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w, h = clip.size</span>
<span class="gi">+    w_even = w % 2 == 0</span>
<span class="gi">+    h_even = h % 2 == 0</span>
<span class="gi">+    if w_even and h_even:</span>
<span class="gi">+        return clip</span>
<span class="gi">+    </span>
<span class="gi">+    if not w_even and not h_even:</span>
<span class="gi">+        fl_image = lambda a : a[:-1,:-1,:]</span>
<span class="gi">+    elif w_even:</span>
<span class="gi">+        fl_image = lambda a : a[:,:-1,:]</span>
<span class="gi">+    else:</span>
<span class="gi">+        fl_image = lambda a : a[:-1,:,:]</span>
<span class="gi">+</span>
<span class="gi">+    return clip.fl_image(fl_image)</span>
<span class="gh">diff --git a/moviepy/video/fx/fadein.py b/moviepy/video/fx/fadein.py</span>
<span class="gh">index 3c91a46..c9fda92 100644</span>
<span class="gd">--- a/moviepy/video/fx/fadein.py</span>
<span class="gi">+++ b/moviepy/video/fx/fadein.py</span>
<span class="gu">@@ -9,4 +9,17 @@ def fadein(clip, duration, initial_color=None):</span>
<span class="w"> </span>    For cross-fading (progressive appearance or disappearance of a clip
<span class="w"> </span>    over another clip, see ``composition.crossfade``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if initial_color is None:</span>
<span class="gi">+        initial_color = 0 if clip.ismask else [0,0,0]</span>
<span class="gi">+    </span>
<span class="gi">+    initial_color = np.array(initial_color)</span>
<span class="gi">+    </span>
<span class="gi">+    def fl(gf, t):</span>
<span class="gi">+        if t&gt;=duration:</span>
<span class="gi">+            return gf(t)</span>
<span class="gi">+        else:</span>
<span class="gi">+            fading = (1.0*t/duration) </span>
<span class="gi">+            return fading*gf(t) + (1-fading)*initial_color</span>
<span class="gi">+</span>
<span class="gi">+    return clip.fl(fl)</span>
<span class="gh">diff --git a/moviepy/video/fx/fadeout.py b/moviepy/video/fx/fadeout.py</span>
<span class="gh">index 0475495..66c7230 100644</span>
<span class="gd">--- a/moviepy/video/fx/fadeout.py</span>
<span class="gi">+++ b/moviepy/video/fx/fadeout.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>from moviepy.decorators import requires_duration


<span class="gu">@@ -11,4 +12,17 @@ def fadeout(clip, duration, final_color=None):</span>
<span class="w"> </span>    For cross-fading (progressive appearance or disappearance of a clip
<span class="w"> </span>    over another clip, see ``composition.crossfade``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    if final_color is None:</span>
<span class="gi">+        final_color = 0 if clip.ismask else [0,0,0]</span>
<span class="gi">+    </span>
<span class="gi">+    final_color = np.array(final_color)</span>
<span class="gi">+</span>
<span class="gi">+    def fl(gf, t):</span>
<span class="gi">+        if (clip.duration-t)&gt;=duration:</span>
<span class="gi">+            return gf(t)</span>
<span class="gi">+        else:</span>
<span class="gi">+            fading = 1.0 * (clip.duration - t) / duration</span>
<span class="gi">+            return fading*gf(t) + (1-fading)*final_color</span>
<span class="gi">+</span>
<span class="gi">+    return clip.fl(fl)</span>
<span class="gh">diff --git a/moviepy/video/fx/freeze.py b/moviepy/video/fx/freeze.py</span>
<span class="gh">index cd36a63..ff4d4aa 100644</span>
<span class="gd">--- a/moviepy/video/fx/freeze.py</span>
<span class="gi">+++ b/moviepy/video/fx/freeze.py</span>
<span class="gu">@@ -4,8 +4,8 @@ from moviepy.video.VideoClip import ImageClip</span>


<span class="w"> </span>@requires_duration
<span class="gd">-def freeze(clip, t=0, freeze_duration=None, total_duration=None, padding_end=0</span>
<span class="gd">-    ):</span>
<span class="gi">+def freeze(clip, t=0, freeze_duration=None, total_duration=None,</span>
<span class="gi">+           padding_end=0):</span>
<span class="w"> </span>    &quot;&quot;&quot; Momentarily freeze the clip at time t.

<span class="w"> </span>    Set `t=&#39;end&#39;` to freeze the clip at the end (actually it will freeze on the
<span class="gu">@@ -15,4 +15,15 @@ def freeze(clip, t=0, freeze_duration=None, total_duration=None, padding_end=0</span>
<span class="w"> </span>    the clip and the freeze (i.e. the duration of the freeze is
<span class="w"> </span>    automatically calculated). One of them must be provided.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if t==&#39;end&#39;:</span>
<span class="gi">+        t = clip.duration - padding_end</span>
<span class="gi">+</span>
<span class="gi">+    if freeze_duration is None:</span>
<span class="gi">+        freeze_duration = total_duration - clip.duration</span>
<span class="gi">+</span>
<span class="gi">+    before = [clip.subclip(0,t)] if (t!=0) else []</span>
<span class="gi">+    freeze = [clip.to_ImageClip(t).set_duration(freeze_duration)]</span>
<span class="gi">+    after = [clip.subclip(t)] if (t !=clip.duration) else []</span>
<span class="gi">+    return concatenate_videoclips(before + freeze + after)</span>
<span class="gi">+  </span>
\ No newline at end of file
<span class="gh">diff --git a/moviepy/video/fx/freeze_region.py b/moviepy/video/fx/freeze_region.py</span>
<span class="gh">index f39e4d1..a8ec7cf 100644</span>
<span class="gd">--- a/moviepy/video/fx/freeze_region.py</span>
<span class="gi">+++ b/moviepy/video/fx/freeze_region.py</span>
<span class="gu">@@ -1,8 +1,10 @@</span>
<span class="w"> </span>from moviepy.decorators import apply_to_mask
<span class="w"> </span>from moviepy.video.compositing.CompositeVideoClip import CompositeVideoClip
<span class="gi">+</span>
<span class="w"> </span>from .crop import crop


<span class="gi">+#@apply_to_mask</span>
<span class="w"> </span>def freeze_region(clip, t=0, region=None, outside_region=None, mask=None):
<span class="w"> </span>    &quot;&quot;&quot; Freezes one region of the clip while the rest remains animated.

<span class="gu">@@ -29,4 +31,27 @@ def freeze_region(clip, t=0, region=None, outside_region=None, mask=None):</span>
<span class="w"> </span>      indicate the freezed region in the final picture.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    if region is not None:</span>
<span class="gi">+</span>
<span class="gi">+        x1, y1, x2, y2 = region</span>
<span class="gi">+        freeze = (clip.fx(crop, *region)</span>
<span class="gi">+                      .to_ImageClip(t=t)</span>
<span class="gi">+                      .set_duration(clip.duration)</span>
<span class="gi">+                      .set_position((x1,y1)))</span>
<span class="gi">+        return CompositeVideoClip([clip, freeze])</span>
<span class="gi">+    </span>
<span class="gi">+    elif outside_region is not None:</span>
<span class="gi">+        </span>
<span class="gi">+        x1, y1, x2, y2 = outside_region</span>
<span class="gi">+        animated_region = (clip.fx(crop, *outside_region)</span>
<span class="gi">+                               .set_position((x1,y1)))</span>
<span class="gi">+        freeze = (clip.to_ImageClip(t=t)</span>
<span class="gi">+                      .set_duration(clip.duration))</span>
<span class="gi">+        return CompositeVideoClip([freeze, animated_region])</span>
<span class="gi">+    </span>
<span class="gi">+    elif mask is not None:</span>
<span class="gi">+        freeze = (clip.to_ImageClip(t=t)</span>
<span class="gi">+                      .set_duration(clip.duration)</span>
<span class="gi">+                      .set_mask(mask))</span>
<span class="gi">+        return CompositeVideoClip([clip, freeze])</span>
<span class="gh">diff --git a/moviepy/video/fx/gamma_corr.py b/moviepy/video/fx/gamma_corr.py</span>
<span class="gh">index 7b3cfef..5668698 100644</span>
<span class="gd">--- a/moviepy/video/fx/gamma_corr.py</span>
<span class="gi">+++ b/moviepy/video/fx/gamma_corr.py</span>
<span class="gu">@@ -1,3 +1,8 @@</span>
<span class="gi">+</span>
<span class="w"> </span>def gamma_corr(clip, gamma):
<span class="w"> </span>    &quot;&quot;&quot; Gamma-correction of a video clip &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def fl(im):</span>
<span class="gi">+        corrected = (255*(1.0*im/255)**gamma)</span>
<span class="gi">+        return corrected.astype(&#39;uint8&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    return clip.fl_image(fl)</span>
<span class="gh">diff --git a/moviepy/video/fx/headblur.py b/moviepy/video/fx/headblur.py</span>
<span class="gh">index 98c97ec..2d46d5a 100644</span>
<span class="gd">--- a/moviepy/video/fx/headblur.py</span>
<span class="gi">+++ b/moviepy/video/fx/headblur.py</span>
<span class="gu">@@ -1,14 +1,17 @@</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="gi">+#------- CHECKING DEPENDENCIES ----------------------------------------- </span>
<span class="w"> </span>try:
<span class="w"> </span>    import cv2
<span class="w"> </span>    headblur_possible = True
<span class="w"> </span>    if cv2.__version__ &gt;= &#39;3.0.0&#39;:
<span class="gd">-        cv2.CV_AA = cv2.LINE_AA</span>
<span class="gi">+       cv2.CV_AA=cv2.LINE_AA</span>
<span class="w"> </span>except:
<span class="w"> </span>    headblur_possible = False
<span class="gi">+#-----------------------------------------------------------------------</span>


<span class="gd">-def headblur(clip, fx, fy, r_zone, r_blur=None):</span>
<span class="gi">+def headblur(clip,fx,fy,r_zone,r_blur=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns a filter that will blurr a moving part (a head ?) of
<span class="w"> </span>    the frames. The position of the blur at time t is
<span class="gu">@@ -18,9 +21,38 @@ def headblur(clip, fx, fy, r_zone, r_blur=None):</span>
<span class="w"> </span>    Automatically deals with the case where part of the image goes
<span class="w"> </span>    offscreen.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    if r_blur is None: r_blur = 2*r_zone/3</span>
<span class="gi">+    </span>
<span class="gi">+    def fl(gf,t):</span>
<span class="gi">+        </span>
<span class="gi">+        im = gf(t)</span>
<span class="gi">+        h,w,d = im.shape</span>
<span class="gi">+        x,y = int(fx(t)),int(fy(t))</span>
<span class="gi">+        x1,x2 = max(0,x-r_zone),min(x+r_zone,w)</span>
<span class="gi">+        y1,y2 = max(0,y-r_zone),min(y+r_zone,h)</span>
<span class="gi">+        region_size = y2-y1,x2-x1</span>
<span class="gi">+        </span>
<span class="gi">+        mask = np.zeros(region_size).astype(&#39;uint8&#39;)</span>
<span class="gi">+        cv2.circle(mask, (r_zone,r_zone), r_zone, 255, -1,</span>
<span class="gi">+                   lineType=cv2.CV_AA)</span>
<span class="gi">+                               </span>
<span class="gi">+        mask = np.dstack(3*[(1.0/255)*mask])</span>
<span class="gi">+        </span>
<span class="gi">+        orig = im[y1:y2, x1:x2]</span>
<span class="gi">+        blurred = cv2.blur(orig,(r_blur, r_blur))</span>
<span class="gi">+        im[y1:y2, x1:x2] = mask*blurred + (1-mask)*orig</span>
<span class="gi">+        return im</span>
<span class="gi">+    </span>
<span class="gi">+    return clip.fl(fl)</span>
<span class="gi">+</span>


<span class="gi">+#------- OVERWRITE IF REQUIREMENTS NOT MET -----------------------------</span>
<span class="w"> </span>if not headblur_possible:
<span class="w"> </span>    doc = headblur.__doc__
<span class="gi">+    def headblur(clip,fx,fy,r_zone,r_blur=None):</span>
<span class="gi">+        raise IOError(&quot;fx painting needs opencv&quot;)</span>
<span class="gi">+    </span>
<span class="w"> </span>    headblur.__doc__ = doc
<span class="gi">+#----------------------------------------------------------------------- </span>
<span class="gh">diff --git a/moviepy/video/fx/invert_colors.py b/moviepy/video/fx/invert_colors.py</span>
<span class="gh">index fc124ac..0fb948e 100644</span>
<span class="gd">--- a/moviepy/video/fx/invert_colors.py</span>
<span class="gi">+++ b/moviepy/video/fx/invert_colors.py</span>
<span class="gu">@@ -4,4 +4,5 @@ def invert_colors(clip):</span>
<span class="w"> </span>    The values of all pixels are replaced with (255-v) or (1-v) for masks 
<span class="w"> </span>    Black becomes white, green becomes purple, etc.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    maxi = (1.0 if clip.ismask else 255)</span>
<span class="gi">+    return clip.fl_image(lambda f : maxi - f)</span>
<span class="gh">diff --git a/moviepy/video/fx/loop.py b/moviepy/video/fx/loop.py</span>
<span class="gh">index e76eb1f..b0c04be 100644</span>
<span class="gd">--- a/moviepy/video/fx/loop.py</span>
<span class="gi">+++ b/moviepy/video/fx/loop.py</span>
<span class="gu">@@ -18,4 +18,9 @@ def loop(self, n=None, duration=None):</span>
<span class="w"> </span>    duration
<span class="w"> </span>      Total duration of the clip. Can be specified instead of n.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = self.fl_time(lambda t: t % self.duration)</span>
<span class="gi">+    if n:</span>
<span class="gi">+        duration = n*self.duration</span>
<span class="gi">+    if duration:</span>
<span class="gi">+        result = result.set_duration(duration)</span>
<span class="gi">+    return result</span>
<span class="gh">diff --git a/moviepy/video/fx/lum_contrast.py b/moviepy/video/fx/lum_contrast.py</span>
<span class="gh">index 9473d5a..a1ae55c 100644</span>
<span class="gd">--- a/moviepy/video/fx/lum_contrast.py</span>
<span class="gi">+++ b/moviepy/video/fx/lum_contrast.py</span>
<span class="gu">@@ -1,3 +1,11 @@</span>
<span class="gd">-def lum_contrast(clip, lum=0, contrast=0, contrast_thr=127):</span>
<span class="gi">+def lum_contrast(clip, lum = 0, contrast=0, contrast_thr=127):</span>
<span class="w"> </span>    &quot;&quot;&quot; luminosity-contrast correction of a clip &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    def fl_image(im):</span>
<span class="gi">+        im = 1.0*im # float conversion</span>
<span class="gi">+        corrected = im + lum + contrast*(im-float(contrast_thr))</span>
<span class="gi">+        corrected[corrected &lt; 0] = 0</span>
<span class="gi">+        corrected[corrected &gt; 255] = 255</span>
<span class="gi">+        return corrected.astype(&#39;uint8&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    return clip.fl_image(fl_image)</span>
<span class="gh">diff --git a/moviepy/video/fx/make_loopable.py b/moviepy/video/fx/make_loopable.py</span>
<span class="gh">index 269c25e..485887c 100644</span>
<span class="gd">--- a/moviepy/video/fx/make_loopable.py</span>
<span class="gi">+++ b/moviepy/video/fx/make_loopable.py</span>
<span class="gu">@@ -6,5 +6,9 @@ def make_loopable(clip, cross):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Makes the clip fade in progressively at its own end, this way
<span class="w"> </span>    it can be looped indefinitely. ``cross`` is the duration in seconds
<span class="gd">-    of the fade-in.  &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    of the fade-in.  &quot;&quot;&quot;  </span>
<span class="gi">+    d = clip.duration</span>
<span class="gi">+    clip2 = clip.fx(transfx.crossfadein, cross).\</span>
<span class="gi">+                 set_start(d - cross)</span>
<span class="gi">+    return CompositeVideoClip([ clip, clip2 ]).\</span>
<span class="gi">+                 subclip(cross,d)</span>
<span class="gh">diff --git a/moviepy/video/fx/margin.py b/moviepy/video/fx/margin.py</span>
<span class="gh">index 3b4e36b..20dd193 100644</span>
<span class="gd">--- a/moviepy/video/fx/margin.py</span>
<span class="gi">+++ b/moviepy/video/fx/margin.py</span>
<span class="gu">@@ -1,11 +1,12 @@</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>from moviepy.decorators import apply_to_mask
<span class="w"> </span>from moviepy.video.VideoClip import ImageClip


<span class="w"> </span>@apply_to_mask
<span class="gd">-def margin(clip, mar=None, left=0, right=0, top=0, bottom=0, color=(0, 0, 0</span>
<span class="gd">-    ), opacity=1.0):</span>
<span class="gi">+def margin(clip, mar=None, left=0, right=0, top=0,</span>
<span class="gi">+           bottom=0, color=(0, 0, 0), opacity = 1.0):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Draws an external margin all around the frame.

<span class="gu">@@ -21,4 +22,37 @@ def margin(clip, mar=None, left=0, right=0, top=0, bottom=0, color=(0, 0, 0</span>
<span class="w"> </span>        this value to 0 yields transparent margins.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if (opacity != 1.0) and (clip.mask is None) and not (clip.ismask):</span>
<span class="gi">+        clip = clip.add_mask()</span>
<span class="gi">+</span>
<span class="gi">+    if mar is not None:</span>
<span class="gi">+        left = right = top = bottom = mar</span>
<span class="gi">+    </span>
<span class="gi">+    def make_bg(w,h):</span>
<span class="gi">+        new_w, new_h = w + left + right, h + top + bottom</span>
<span class="gi">+        if clip.ismask:</span>
<span class="gi">+            shape = (new_h, new_w)</span>
<span class="gi">+            bg = ( np.tile(opacity, (new_h, new_w))</span>
<span class="gi">+                       .astype(float)</span>
<span class="gi">+                       .reshape(shape))</span>
<span class="gi">+        else:</span>
<span class="gi">+            shape = (new_h, new_w, 3)</span>
<span class="gi">+            bg = np.tile(color, (new_h, new_w)).reshape(shape)</span>
<span class="gi">+        return bg</span>
<span class="gi">+        </span>
<span class="gi">+    if isinstance(clip, ImageClip):</span>
<span class="gi">+        </span>
<span class="gi">+        im =  make_bg(clip.w,clip.h)</span>
<span class="gi">+        im[top:top + clip.h, left:left + clip.w] = clip.img</span>
<span class="gi">+        return clip.fl_image(lambda pic:im)</span>
<span class="gi">+        </span>
<span class="gi">+    else:</span>
<span class="gi">+        </span>
<span class="gi">+        def fl(gf, t):</span>
<span class="gi">+            pic = gf(t)</span>
<span class="gi">+            h,w = pic.shape[:2]</span>
<span class="gi">+            im = make_bg(w,h)</span>
<span class="gi">+            im[top:top + h, left:left + w] = pic</span>
<span class="gi">+            return im</span>
<span class="gi">+        return clip.fl(fl)</span>
<span class="gh">diff --git a/moviepy/video/fx/mask_and.py b/moviepy/video/fx/mask_and.py</span>
<span class="gh">index a42f22f..ccec602 100644</span>
<span class="gd">--- a/moviepy/video/fx/mask_and.py</span>
<span class="gi">+++ b/moviepy/video/fx/mask_and.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>from ..VideoClip import ImageClip


<span class="gu">@@ -7,4 +8,13 @@ def mask_and(clip, other_clip):</span>
<span class="w"> </span>        other_clip can be a mask clip or a picture (np.array).
<span class="w"> </span>        The result has the duration of &#39;clip&#39; (if it has any)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # To ensure that &#39;or&#39; of two ImageClips will be an ImageClip.</span>
<span class="gi">+    if isinstance(other_clip, ImageClip):</span>
<span class="gi">+       other_clip = other_clip.img</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(other_clip, np.ndarray):</span>
<span class="gi">+       return clip.fl_image(lambda f : np.minimum(f, other_clip))</span>
<span class="gi">+    else:</span>
<span class="gi">+       return clip.fl(lambda gf, t : np.minimum(gf(t),</span>
<span class="gi">+                                                other_clip.get_frame(t)))</span>
<span class="gh">diff --git a/moviepy/video/fx/mask_color.py b/moviepy/video/fx/mask_color.py</span>
<span class="gh">index 7a8a2e6..fba87dd 100644</span>
<span class="gd">--- a/moviepy/video/fx/mask_color.py</span>
<span class="gi">+++ b/moviepy/video/fx/mask_color.py</span>
<span class="gu">@@ -14,4 +14,21 @@ def mask_color(clip, color=None, thr=0, s=1):</span>
<span class="w"> </span>    which is 1 when d&gt;&gt;thr and 0 for d&lt;&lt;thr, the stiffness of the effect being
<span class="w"> </span>    parametrized by s
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if color is None:</span>
<span class="gi">+        color = [0,0,0]</span>
<span class="gi">+</span>
<span class="gi">+    color = np.array(color)</span>
<span class="gi">+</span>
<span class="gi">+    def hill(x):</span>
<span class="gi">+        if thr:</span>
<span class="gi">+            return x**s / (thr**s + x**s)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return 1.0 * (x != 0) </span>
<span class="gi">+    </span>
<span class="gi">+    def flim(im): </span>
<span class="gi">+        return hill(np.sqrt(((im-color)**2).sum(axis=2)))</span>
<span class="gi">+    </span>
<span class="gi">+    mask = clip.fl_image(flim)</span>
<span class="gi">+    mask.ismask= True</span>
<span class="gi">+    newclip = clip.set_mask(mask)</span>
<span class="gi">+    return newclip</span>
<span class="gh">diff --git a/moviepy/video/fx/mask_or.py b/moviepy/video/fx/mask_or.py</span>
<span class="gh">index 249ec6a..abe5e74 100644</span>
<span class="gd">--- a/moviepy/video/fx/mask_or.py</span>
<span class="gi">+++ b/moviepy/video/fx/mask_or.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>from ..VideoClip import ImageClip


<span class="gu">@@ -7,4 +8,13 @@ def mask_or(clip, other_clip):</span>
<span class="w"> </span>        other_clip can be a mask clip or a picture (np.array).
<span class="w"> </span>        The result has the duration of &#39;clip&#39; (if it has any)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # To ensure that &#39;or&#39; of two ImageClips will be an ImageClip.</span>
<span class="gi">+    if isinstance(other_clip, ImageClip):</span>
<span class="gi">+       other_clip = other_clip.img</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(other_clip, np.ndarray):</span>
<span class="gi">+       return clip.fl_image(lambda f : np.maximum(f, other_clip))</span>
<span class="gi">+    else:</span>
<span class="gi">+       return clip.fl(lambda gf, t : np.maximum(gf(t),</span>
<span class="gi">+                                                 other_clip.get_frame(t)))</span>
<span class="gh">diff --git a/moviepy/video/fx/mirror_x.py b/moviepy/video/fx/mirror_x.py</span>
<span class="gh">index 8577e02..3173dac 100644</span>
<span class="gd">--- a/moviepy/video/fx/mirror_x.py</span>
<span class="gi">+++ b/moviepy/video/fx/mirror_x.py</span>
<span class="gu">@@ -1,3 +1,4 @@</span>
<span class="gd">-def mirror_x(clip, apply_to=&#39;mask&#39;):</span>
<span class="gi">+</span>
<span class="gi">+def mirror_x(clip, apply_to= &quot;mask&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot; flips the clip horizontally (and its mask too, by default) &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return clip.fl_image(lambda f: f[:,::-1], apply_to = apply_to)</span>
<span class="gh">diff --git a/moviepy/video/fx/mirror_y.py b/moviepy/video/fx/mirror_y.py</span>
<span class="gh">index b61b15c..0a602e9 100644</span>
<span class="gd">--- a/moviepy/video/fx/mirror_y.py</span>
<span class="gi">+++ b/moviepy/video/fx/mirror_y.py</span>
<span class="gu">@@ -1,3 +1,3 @@</span>
<span class="gd">-def mirror_y(clip, apply_to=&#39;mask&#39;):</span>
<span class="gi">+def mirror_y(clip, apply_to= &quot;mask&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot; flips the clip vertically (and its mask too, by default) &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return clip.fl_image(lambda f : f[::-1], apply_to = apply_to)</span>
<span class="gh">diff --git a/moviepy/video/fx/painting.py b/moviepy/video/fx/painting.py</span>
<span class="gh">index 03236f0..b41bac3 100644</span>
<span class="gd">--- a/moviepy/video/fx/painting.py</span>
<span class="gi">+++ b/moviepy/video/fx/painting.py</span>
<span class="gu">@@ -1,3 +1,4 @@</span>
<span class="gi">+#------- CHECKING DEPENDENCIES ----------------------------------------- </span>
<span class="w"> </span>painting_possible = True
<span class="w"> </span>try:
<span class="w"> </span>    from skimage.filter import sobel
<span class="gu">@@ -6,24 +7,37 @@ except:</span>
<span class="w"> </span>        from scipy.ndimage.filters import sobel
<span class="w"> </span>    except:
<span class="w"> </span>        painting_possible = False
<span class="gd">-import numpy as np</span>
<span class="gi">+#-----------------------------------------------------------------------    </span>


<span class="gd">-def to_painting(image, saturation=1.4, black=0.006):</span>
<span class="gd">-    &quot;&quot;&quot; transforms any photo into some kind of painting &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+import numpy as np</span>


<span class="gd">-def painting(clip, saturation=1.4, black=0.006):</span>
<span class="gi">+def to_painting(image,saturation = 1.4,black = 0.006):</span>
<span class="gi">+    &quot;&quot;&quot; transforms any photo into some kind of painting &quot;&quot;&quot;</span>
<span class="gi">+    edges = sobel(image.mean(axis=2))</span>
<span class="gi">+    darkening =  black*(255*np.dstack(3*[edges]))</span>
<span class="gi">+    painting = saturation*image-darkening</span>
<span class="gi">+    return np.maximum(0,np.minimum(255,painting)).astype(&#39;uint8&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+def painting(clip, saturation = 1.4,black = 0.006):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Transforms any photo into some kind of painting. Saturation
<span class="w"> </span>    tells at which point the colors of the result should be
<span class="w"> </span>    flashy. ``black`` gives the anount of black lines wanted.
<span class="w"> </span>    Requires Scikit-image or Scipy installed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return clip.fl_image(lambda im : to_painting(im,saturation,black))</span>
<span class="gi">+        </span>
<span class="gi">+</span>

<span class="gi">+#------- OVERWRITE IF REQUIREMENTS NOT MET -----------------------------</span>

<span class="w"> </span>if not painting_possible:
<span class="w"> </span>    doc = painting.__doc__
<span class="gi">+    def painting(clip, newsize=None, height=None, width=None):</span>
<span class="gi">+        raise IOError(&quot;fx painting needs scikit-image or scipy&quot;)</span>
<span class="gi">+    </span>
<span class="w"> </span>    painting.__doc__ = doc
<span class="gi">+#----------------------------------------------------------------------- </span>
<span class="gh">diff --git a/moviepy/video/fx/resize.py b/moviepy/video/fx/resize.py</span>
<span class="gh">index 00274b3..8636e74 100644</span>
<span class="gd">--- a/moviepy/video/fx/resize.py</span>
<span class="gi">+++ b/moviepy/video/fx/resize.py</span>
<span class="gu">@@ -1,21 +1,60 @@</span>
<span class="w"> </span>resize_possible = True
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gi">+    # TRY USING OpenCV AS RESIZER</span>
<span class="gi">+    #raise ImportError #debugging</span>
<span class="w"> </span>    import cv2
<span class="w"> </span>    import numpy as np
<span class="gd">-    resizer.origin = &#39;cv2&#39;</span>
<span class="gi">+    def resizer (pic, newsize):</span>
<span class="gi">+        lx, ly = int(newsize[0]), int(newsize[1])</span>
<span class="gi">+        if lx &gt; pic.shape[1] or ly &gt; pic.shape[0]:</span>
<span class="gi">+            # For upsizing use linear for good quality &amp; decent speed</span>
<span class="gi">+            interpolation = cv2.INTER_LINEAR</span>
<span class="gi">+        else:</span>
<span class="gi">+            # For dowsizing use area to prevent aliasing</span>
<span class="gi">+            interpolation = cv2.INTER_AREA</span>
<span class="gi">+        return cv2.resize(+pic.astype(&#39;uint8&#39;), (lx, ly),</span>
<span class="gi">+                          interpolation=interpolation)</span>
<span class="gi">+</span>
<span class="gi">+    resizer.origin = &quot;cv2&quot;</span>
<span class="gi">+                </span>
<span class="w"> </span>except ImportError:
<span class="gi">+    </span>
<span class="gi">+    </span>
<span class="w"> </span>    try:
<span class="gi">+        # TRY USING PIL/PILLOW AS RESIZER</span>
<span class="w"> </span>        from PIL import Image
<span class="w"> </span>        import numpy as np
<span class="gd">-        resizer.origin = &#39;PIL&#39;</span>
<span class="gi">+        def resizer(pic, newsize):</span>
<span class="gi">+            newsize = list(map(int, newsize))[::-1]</span>
<span class="gi">+            shape = pic.shape</span>
<span class="gi">+            if len(shape)==3:</span>
<span class="gi">+                newshape = (newsize[0],newsize[1], shape[2] )</span>
<span class="gi">+            else:</span>
<span class="gi">+                newshape = (newsize[0],newsize[1])</span>
<span class="gi">+                </span>
<span class="gi">+            pilim = Image.fromarray(pic)</span>
<span class="gi">+            resized_pil = pilim.resize(newsize[::-1], Image.ANTIALIAS)</span>
<span class="gi">+            #arr = np.fromstring(resized_pil.tostring(), dtype=&#39;uint8&#39;)</span>
<span class="gi">+            #arr.reshape(newshape)</span>
<span class="gi">+            return np.array(resized_pil)</span>
<span class="gi">+            </span>
<span class="gi">+        resizer.origin = &quot;PIL&quot;</span>
<span class="gi">+            </span>
<span class="w"> </span>    except ImportError:
<span class="gi">+        # TRY USING SCIPY AS RESIZER</span>
<span class="w"> </span>        try:
<span class="w"> </span>            from scipy.misc import imresize
<span class="gd">-            resizer = lambda pic, newsize: imresize(pic, map(int, newsize[:</span>
<span class="gd">-                :-1]))</span>
<span class="gd">-            resizer.origin = &#39;Scipy&#39;</span>
<span class="gi">+            resizer = lambda pic, newsize : imresize(pic,</span>
<span class="gi">+                                            map(int, newsize[::-1]))</span>
<span class="gi">+            resizer.origin = &quot;Scipy&quot;</span>
<span class="gi">+                                               </span>
<span class="w"> </span>        except ImportError:
<span class="w"> </span>            resize_possible = False
<span class="gi">+            </span>
<span class="gi">+        </span>
<span class="gi">+        </span>
<span class="gi">+    </span>
<span class="w"> </span>from moviepy.decorators import apply_to_mask


<span class="gu">@@ -49,9 +88,78 @@ def resize(clip, newsize=None, height=None, width=None, apply_to_mask=True):</span>
<span class="w"> </span>    &gt;&gt;&gt; myClip.resize(lambda t : 1+0.02*t) # slow swelling of the clip

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    w, h = clip.size</span>
<span class="gi">+    </span>
<span class="gi">+    if newsize is not None:</span>
<span class="gi">+        </span>
<span class="gi">+        def trans_newsize(ns):</span>
<span class="gi">+            </span>
<span class="gi">+            if isinstance(ns, (int, float)):</span>
<span class="gi">+                return [ns * w, ns * h]</span>
<span class="gi">+            else:</span>
<span class="gi">+                return ns</span>
<span class="gi">+                </span>
<span class="gi">+        if hasattr(newsize, &quot;__call__&quot;):</span>
<span class="gi">+            </span>
<span class="gi">+            newsize2 = lambda t : trans_newsize(newsize(t))</span>
<span class="gi">+            </span>
<span class="gi">+            if clip.ismask:</span>
<span class="gi">+                </span>
<span class="gi">+                fun = lambda gf,t: (1.0*resizer((255 * gf(t)).astype(&#39;uint8&#39;),</span>
<span class="gi">+                                                 newsize2(t))/255)</span>
<span class="gi">+            else:</span>
<span class="gi">+                </span>
<span class="gi">+                fun = lambda gf,t: resizer(gf(t).astype(&#39;uint8&#39;),</span>
<span class="gi">+                                          newsize2(t))</span>
<span class="gi">+                </span>
<span class="gi">+            return clip.fl(fun, keep_duration=True,</span>
<span class="gi">+                           apply_to= ([&quot;mask&quot;] if apply_to_mask else []))</span>
<span class="gi">+            </span>
<span class="gi">+        else:</span>
<span class="gi">+            </span>
<span class="gi">+            newsize = trans_newsize(newsize)</span>
<span class="gi">+        </span>
<span class="gi">+</span>
<span class="gi">+    elif height is not None:</span>
<span class="gi">+        </span>
<span class="gi">+        if hasattr(height, &quot;__call__&quot;):</span>
<span class="gi">+            fun = lambda t : 1.0*int(height(t))/h</span>
<span class="gi">+            return resize(clip, fun)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            newsize = [w * height / h, height]</span>
<span class="gi">+        </span>
<span class="gi">+    elif width is not None:</span>
<span class="gi">+</span>
<span class="gi">+        if hasattr(width, &quot;__call__&quot;):</span>
<span class="gi">+            fun = lambda t : 1.0*width(t)/w</span>
<span class="gi">+            return resize(clip, fun)</span>
<span class="gi">+        </span>
<span class="gi">+        newsize = [width, h * width / w]</span>
<span class="gi">+        </span>
<span class="gi">+        </span>
<span class="gi">+    # From here, the resizing is constant (not a function of time), size=newsize</span>
<span class="gi">+</span>
<span class="gi">+    if clip.ismask:</span>
<span class="gi">+        fl = lambda pic: 1.0*resizer((255 * pic).astype(&#39;uint8&#39;), newsize)/255.0</span>
<span class="gi">+            </span>
<span class="gi">+    else:</span>
<span class="gi">+        fl = lambda pic: resizer(pic.astype(&#39;uint8&#39;), newsize)</span>
<span class="gi">+</span>
<span class="gi">+    newclip = clip.fl_image(fl)</span>
<span class="gi">+</span>
<span class="gi">+    if apply_to_mask and clip.mask is not None:</span>
<span class="gi">+        newclip.mask = resize(clip.mask, newsize, apply_to_mask=False)</span>
<span class="gi">+</span>
<span class="gi">+    return newclip</span>


<span class="w"> </span>if not resize_possible:
<span class="gi">+    </span>
<span class="w"> </span>    doc = resize.__doc__
<span class="gi">+    def resize(clip, newsize=None, height=None, width=None):</span>
<span class="gi">+        raise ImportError(&quot;fx resize needs OpenCV or Scipy or PIL&quot;)</span>
<span class="w"> </span>    resize.__doc__ = doc
<span class="gh">diff --git a/moviepy/video/fx/rotate.py b/moviepy/video/fx/rotate.py</span>
<span class="gh">index 973879e..da22268 100644</span>
<span class="gd">--- a/moviepy/video/fx/rotate.py</span>
<span class="gi">+++ b/moviepy/video/fx/rotate.py</span>
<span class="gu">@@ -1,13 +1,17 @@</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>from moviepy.decorators import apply_to_mask
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from PIL import Image
<span class="w"> </span>    PIL_FOUND = True
<span class="gi">+    def pil_rotater(pic, angle, resample, expand):</span>
<span class="gi">+        return np.array( Image.fromarray(pic).rotate(angle, expand=expand,</span>
<span class="gi">+                                                     resample=resample))</span>
<span class="w"> </span>except ImportError:
<span class="w"> </span>    PIL_FOUND = False

<span class="gd">-</span>
<span class="gd">-def rotate(clip, angle, unit=&#39;deg&#39;, resample=&#39;bicubic&#39;, expand=True):</span>
<span class="gi">+def rotate(clip, angle, unit=&#39;deg&#39;, resample=&quot;bicubic&quot;, expand=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Change unit to &#39;rad&#39; to define angles as radians.
<span class="w"> </span>    If the angle is not one of 90, 180, -90, -180 (degrees) there will be
<span class="gu">@@ -33,4 +37,37 @@ def rotate(clip, angle, unit=&#39;deg&#39;, resample=&#39;bicubic&#39;, expand=True):</span>
<span class="w"> </span>    expand
<span class="w"> </span>      Only applIf False, the clip will maintain the same True, the clip will be resized so that the whole
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    resample = {&quot;bilinear&quot;: Image.BILINEAR,</span>
<span class="gi">+                &quot;nearest&quot;: Image.NEAREST,</span>
<span class="gi">+                &quot;bicubic&quot;: Image.BICUBIC}[resample]</span>
<span class="gi">+</span>
<span class="gi">+    if not hasattr(angle, &#39;__call__&#39;):</span>
<span class="gi">+        # if angle is a constant, convert to a constant function</span>
<span class="gi">+        a = +angle</span>
<span class="gi">+        angle = lambda t: a</span>
<span class="gi">+</span>
<span class="gi">+    transpo = [1,0] if clip.ismask else [1,0,2]</span>
<span class="gi">+</span>
<span class="gi">+    def fl(gf, t):</span>
<span class="gi">+</span>
<span class="gi">+        a = angle(t)</span>
<span class="gi">+        im = gf(t)</span>
<span class="gi">+</span>
<span class="gi">+        if unit == &#39;rad&#39;:</span>
<span class="gi">+            a = 360.0*a/(2*np.pi)</span>
<span class="gi">+        </span>
<span class="gi">+        if (a==90) and expand:</span>
<span class="gi">+            return np.transpose(im, axes=transpo)[::-1]</span>
<span class="gi">+        elif (a==-90) and expand:</span>
<span class="gi">+            return np.transpose(im, axes=transpo)[:,::-1]</span>
<span class="gi">+        elif (a in [180, -180]) and expand:</span>
<span class="gi">+            return im[::-1,::-1]</span>
<span class="gi">+        elif not PIL_FOUND:</span>
<span class="gi">+            raise ValueError(&#39;Without &quot;Pillow&quot; installed, only angles 90, -90,&#39;</span>
<span class="gi">+                             &#39;180 are supported, please install &quot;Pillow&quot; with&#39;</span>
<span class="gi">+                             &quot;pip install pillow&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return pil_rotater(im, a, resample=resample, expand=expand)</span>
<span class="gi">+</span>
<span class="gi">+    return clip.fl(fl, apply_to=[&quot;mask&quot;])</span>
<span class="gh">diff --git a/moviepy/video/fx/scroll.py b/moviepy/video/fx/scroll.py</span>
<span class="gh">index 4a2c40a..34f4f40 100644</span>
<span class="gd">--- a/moviepy/video/fx/scroll.py</span>
<span class="gi">+++ b/moviepy/video/fx/scroll.py</span>
<span class="gu">@@ -1,5 +1,16 @@</span>
<span class="gd">-def scroll(clip, h=None, w=None, x_speed=0, y_speed=0, x_start=0, y_start=0,</span>
<span class="gd">-    apply_to=&#39;mask&#39;):</span>
<span class="gi">+def scroll(clip, h=None, w=None, x_speed=0, y_speed=0,</span>
<span class="gi">+           x_start=0, y_start=0, apply_to=&quot;mask&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot; Scrolls horizontally or vertically a clip, e.g. to make end
<span class="w"> </span>        credits &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if h is None: h = clip.h</span>
<span class="gi">+    if w is None: w = clip.w</span>
<span class="gi">+    </span>
<span class="gi">+    xmax = clip.w-w-1</span>
<span class="gi">+    ymax = clip.h-h-1</span>
<span class="gi">+</span>
<span class="gi">+    def f(gf,t):</span>
<span class="gi">+        x = int(max(0, min(xmax, x_start+ round(x_speed*t))))</span>
<span class="gi">+        y = int(max(0, min(ymax, y_start+ round(y_speed*t))))</span>
<span class="gi">+        return gf(t)[y:y+h, x:x+w]</span>
<span class="gi">+    </span>
<span class="gi">+    return clip.fl(f, apply_to = apply_to)</span>
<span class="gh">diff --git a/moviepy/video/fx/speedx.py b/moviepy/video/fx/speedx.py</span>
<span class="gh">index ee902f1..1c6b82c 100644</span>
<span class="gd">--- a/moviepy/video/fx/speedx.py</span>
<span class="gi">+++ b/moviepy/video/fx/speedx.py</span>
<span class="gu">@@ -1,7 +1,7 @@</span>
<span class="w"> </span>from moviepy.decorators import apply_to_audio, apply_to_mask


<span class="gd">-def speedx(clip, factor=None, final_duration=None):</span>
<span class="gi">+def speedx(clip, factor = None, final_duration=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns a clip playing the current clip but at a speed multiplied
<span class="w"> </span>    by ``factor``. Instead of factor one can indicate the desired
<span class="gu">@@ -9,4 +9,13 @@ def speedx(clip, factor=None, final_duration=None):</span>
<span class="w"> </span>    computed.
<span class="w"> </span>    The same effect is applied to the clip&#39;s audio and mask if any.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    if final_duration:</span>
<span class="gi">+        factor = 1.0* clip.duration / final_duration</span>
<span class="gi">+        </span>
<span class="gi">+    newclip = clip.fl_time(lambda t: factor * t, apply_to=[&#39;mask&#39;, &#39;audio&#39;])</span>
<span class="gi">+    </span>
<span class="gi">+    if clip.duration is not None:</span>
<span class="gi">+        newclip = newclip.set_duration(1.0 * clip.duration / factor)</span>
<span class="gi">+    </span>
<span class="gi">+    return newclip</span>
<span class="gh">diff --git a/moviepy/video/fx/supersample.py b/moviepy/video/fx/supersample.py</span>
<span class="gh">index e09615f..93b9d7a 100644</span>
<span class="gd">--- a/moviepy/video/fx/supersample.py</span>
<span class="gi">+++ b/moviepy/video/fx/supersample.py</span>
<span class="gu">@@ -4,4 +4,10 @@ import numpy as np</span>
<span class="w"> </span>def supersample(clip, d, nframes):
<span class="w"> </span>    &quot;&quot;&quot; Replaces each frame at time t by the mean of `nframes` equally spaced frames
<span class="w"> </span>    taken in the interval [t-d, t+d]. This results in motion blur.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    def fl(gf, t):</span>
<span class="gi">+        tt = np.linspace(t-d, t+d, nframes)</span>
<span class="gi">+        avg = np.mean(1.0*np.array([gf(t_) for t_ in tt], dtype=&#39;uint16&#39;), axis=0)</span>
<span class="gi">+        return avg.astype(&quot;uint8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return clip.fl(fl)</span>
<span class="gh">diff --git a/moviepy/video/fx/time_mirror.py b/moviepy/video/fx/time_mirror.py</span>
<span class="gh">index 92edbdb..1c044e3 100644</span>
<span class="gd">--- a/moviepy/video/fx/time_mirror.py</span>
<span class="gi">+++ b/moviepy/video/fx/time_mirror.py</span>
<span class="gu">@@ -10,4 +10,4 @@ def time_mirror(self):</span>
<span class="w"> </span>    The clip must have its ``duration`` attribute set.
<span class="w"> </span>    The same effect is applied to the clip&#39;s audio and mask if any.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return self.fl_time(lambda t: self.duration - t, keep_duration=True)</span>
<span class="gh">diff --git a/moviepy/video/fx/time_symmetrize.py b/moviepy/video/fx/time_symmetrize.py</span>
<span class="gh">index 7b9e089..de2f318 100644</span>
<span class="gd">--- a/moviepy/video/fx/time_symmetrize.py</span>
<span class="gi">+++ b/moviepy/video/fx/time_symmetrize.py</span>
<span class="gu">@@ -1,5 +1,6 @@</span>
<span class="w"> </span>from moviepy.decorators import apply_to_audio, apply_to_mask, requires_duration
<span class="w"> </span>from moviepy.video.compositing.concatenate import concatenate_videoclips
<span class="gi">+</span>
<span class="w"> </span>from .time_mirror import time_mirror


<span class="gu">@@ -13,4 +14,4 @@ def time_symmetrize(clip):</span>
<span class="w"> </span>    This effect is automatically applied to the clip&#39;s mask and audio
<span class="w"> </span>    if they exist.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return concatenate_videoclips([clip, clip.fx( time_mirror )])</span>
<span class="gh">diff --git a/moviepy/video/io/ImageSequenceClip.py b/moviepy/video/io/ImageSequenceClip.py</span>
<span class="gh">index de83c85..662138c 100644</span>
<span class="gd">--- a/moviepy/video/io/ImageSequenceClip.py</span>
<span class="gi">+++ b/moviepy/video/io/ImageSequenceClip.py</span>
<span class="gu">@@ -1,6 +1,8 @@</span>
<span class="w"> </span>import os
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>from imageio import imread
<span class="gi">+</span>
<span class="w"> </span>from ..VideoClip import VideoClip


<span class="gu">@@ -44,88 +46,119 @@ class ImageSequenceClip(VideoClip):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+</span>
<span class="w"> </span>    def __init__(self, sequence, fps=None, durations=None, with_mask=True,
<span class="gd">-        ismask=False, load_images=False):</span>
<span class="gd">-        if fps is None and durations is None:</span>
<span class="gi">+                 ismask=False, load_images=False):</span>
<span class="gi">+</span>
<span class="gi">+        # CODE WRITTEN AS IT CAME, MAY BE IMPROVED IN THE FUTURE</span>
<span class="gi">+</span>
<span class="gi">+        if (fps is None) and (durations is None):</span>
<span class="w"> </span>            raise ValueError(&quot;Please provide either &#39;fps&#39; or &#39;durations&#39;.&quot;)
<span class="w"> </span>        VideoClip.__init__(self, ismask=ismask)
<span class="gi">+</span>
<span class="gi">+        # Parse the data</span>
<span class="gi">+</span>
<span class="w"> </span>        fromfiles = True
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(sequence, list):
<span class="w"> </span>            if isinstance(sequence[0], str):
<span class="w"> </span>                if load_images:
<span class="w"> </span>                    sequence = [imread(f) for f in sequence]
<span class="w"> </span>                    fromfiles = False
<span class="w"> </span>                else:
<span class="gd">-                    fromfiles = True</span>
<span class="gi">+                    fromfiles= True</span>
<span class="w"> </span>            else:
<span class="gi">+                # sequence is already a list of numpy arrays</span>
<span class="w"> </span>                fromfiles = False
<span class="w"> </span>        else:
<span class="gi">+            # sequence is a folder name, make it a list of files:</span>
<span class="w"> </span>            fromfiles = True
<span class="gd">-            sequence = sorted([os.path.join(sequence, f) for f in os.</span>
<span class="gd">-                listdir(sequence)])</span>
<span class="gi">+            sequence = sorted([os.path.join(sequence, f)</span>
<span class="gi">+                        for f in os.listdir(sequence)])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+        #check that all the images are of the same size</span>
<span class="w"> </span>        if isinstance(sequence[0], str):
<span class="gd">-            size = imread(sequence[0]).shape</span>
<span class="gi">+           size = imread(sequence[0]).shape</span>
<span class="w"> </span>        else:
<span class="gd">-            size = sequence[0].shape</span>
<span class="gi">+           size = sequence[0].shape</span>
<span class="gi">+</span>
<span class="w"> </span>        for image in sequence:
<span class="gd">-            image1 = image</span>
<span class="gi">+            image1=image</span>
<span class="w"> </span>            if isinstance(image, str):
<span class="gd">-                image1 = imread(image)</span>
<span class="gi">+               image1=imread(image)</span>
<span class="w"> </span>            if size != image1.shape:
<span class="gd">-                raise Exception(</span>
<span class="gd">-                    &#39;Moviepy: ImageSequenceClip requires all images to be the same size&#39;</span>
<span class="gd">-                    )</span>
<span class="gi">+               raise Exception(&quot;Moviepy: ImageSequenceClip requires all images to be the same size&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>        self.fps = fps
<span class="w"> </span>        if fps is not None:
<span class="gd">-            durations = [(1.0 / fps) for image in sequence]</span>
<span class="gd">-            self.images_starts = [(1.0 * i / fps - np.finfo(np.float32).eps</span>
<span class="gd">-                ) for i in range(len(sequence))]</span>
<span class="gi">+            durations = [1.0/fps for image in sequence]</span>
<span class="gi">+            self.images_starts = [1.0*i/fps-np.finfo(np.float32).eps for i in range(len(sequence))]</span>
<span class="w"> </span>        else:
<span class="gd">-            self.images_starts = [0] + list(np.cumsum(durations))</span>
<span class="gi">+            self.images_starts = [0]+list(np.cumsum(durations))</span>
<span class="w"> </span>        self.durations = durations
<span class="w"> </span>        self.duration = sum(durations)
<span class="w"> </span>        self.end = self.duration
<span class="w"> </span>        self.sequence = sequence
<span class="gd">-</span>
<span class="gi">+        </span>
<span class="w"> </span>        def find_image_index(t):
<span class="gd">-            return max([i for i in range(len(self.sequence)) if self.</span>
<span class="gd">-                images_starts[i] &lt;= t])</span>
<span class="gi">+            return max([i for i in range(len(self.sequence))</span>
<span class="gi">+                              if self.images_starts[i]&lt;=t])</span>
<span class="gi">+</span>
<span class="w"> </span>        if fromfiles:
<span class="gi">+</span>
<span class="w"> </span>            self.lastindex = None
<span class="w"> </span>            self.lastimage = None

<span class="w"> </span>            def make_frame(t):
<span class="gi">+            </span>
<span class="w"> </span>                index = find_image_index(t)
<span class="gi">+</span>
<span class="w"> </span>                if index != self.lastindex:
<span class="gd">-                    self.lastimage = imread(self.sequence[index])[:, :, :3]</span>
<span class="gi">+                    self.lastimage = imread(self.sequence[index])[:,:,:3] </span>
<span class="w"> </span>                    self.lastindex = index
<span class="gi">+                </span>
<span class="w"> </span>                return self.lastimage
<span class="gd">-            if with_mask and imread(self.sequence[0]).shape[2] == 4:</span>
<span class="gi">+</span>
<span class="gi">+            if with_mask and (imread(self.sequence[0]).shape[2]==4):</span>
<span class="gi">+</span>
<span class="w"> </span>                self.mask = VideoClip(ismask=True)
<span class="w"> </span>                self.mask.lastindex = None
<span class="w"> </span>                self.mask.lastimage = None

<span class="w"> </span>                def mask_make_frame(t):
<span class="gi">+            </span>
<span class="w"> </span>                    index = find_image_index(t)
<span class="w"> </span>                    if index != self.mask.lastindex:
<span class="gd">-                        frame = imread(self.sequence[index])[:, :, 3]</span>
<span class="gd">-                        self.mask.lastimage = frame.astype(float) / 255</span>
<span class="gi">+                        frame = imread(self.sequence[index])[:,:,3]</span>
<span class="gi">+                        self.mask.lastimage = frame.astype(float)/255</span>
<span class="w"> </span>                        self.mask.lastindex = index
<span class="gi">+</span>
<span class="w"> </span>                    return self.mask.lastimage
<span class="gi">+</span>
<span class="w"> </span>                self.mask.make_frame = mask_make_frame
<span class="w"> </span>                self.mask.size = mask_make_frame(0).shape[:2][::-1]
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>        else:

<span class="w"> </span>            def make_frame(t):
<span class="gi">+            </span>
<span class="w"> </span>                index = find_image_index(t)
<span class="gd">-                return self.sequence[index][:, :, :3]</span>
<span class="gd">-            if with_mask and self.sequence[0].shape[2] == 4:</span>
<span class="gi">+                return self.sequence[index][:,:,:3]</span>
<span class="gi">+</span>
<span class="gi">+            if with_mask and (self.sequence[0].shape[2]==4):</span>
<span class="gi">+</span>
<span class="w"> </span>                self.mask = VideoClip(ismask=True)

<span class="w"> </span>                def mask_make_frame(t):
<span class="w"> </span>                    index = find_image_index(t)
<span class="gd">-                    return 1.0 * self.sequence[index][:, :, 3] / 255</span>
<span class="gi">+                    return 1.0*self.sequence[index][:,:,3]/255</span>
<span class="gi">+</span>
<span class="w"> </span>                self.mask.make_frame = mask_make_frame
<span class="w"> </span>                self.mask.size = mask_make_frame(0).shape[:2][::-1]
<span class="gi">+        </span>
<span class="gi">+            </span>
<span class="w"> </span>        self.make_frame = make_frame
<span class="w"> </span>        self.size = make_frame(0).shape[:2][::-1]
<span class="gh">diff --git a/moviepy/video/io/VideoFileClip.py b/moviepy/video/io/VideoFileClip.py</span>
<span class="gh">index 5bb4b1f..1d5c8b6 100644</span>
<span class="gd">--- a/moviepy/video/io/VideoFileClip.py</span>
<span class="gi">+++ b/moviepy/video/io/VideoFileClip.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>import os
<span class="gi">+</span>
<span class="w"> </span>from moviepy.audio.io.AudioFileClip import AudioFileClip
<span class="w"> </span>from moviepy.Clip import Clip
<span class="w"> </span>from moviepy.video.io.ffmpeg_reader import FFMPEG_VideoReader
<span class="gu">@@ -6,6 +7,7 @@ from moviepy.video.VideoClip import VideoClip</span>


<span class="w"> </span>class VideoFileClip(VideoClip):
<span class="gi">+</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    A video clip originating from a movie file. For instance: ::
<span class="gu">@@ -73,33 +75,60 @@ class VideoFileClip(VideoClip):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, filename, has_mask=False, audio=True,</span>
<span class="gd">-        audio_buffersize=200000, target_resolution=None, resize_algorithm=</span>
<span class="gd">-        &#39;bicubic&#39;, audio_fps=44100, audio_nbytes=2, verbose=False,</span>
<span class="gd">-        fps_source=&#39;tbr&#39;):</span>
<span class="gi">+    def __init__(self, filename, has_mask=False,</span>
<span class="gi">+                 audio=True, audio_buffersize=200000,</span>
<span class="gi">+                 target_resolution=None, resize_algorithm=&#39;bicubic&#39;,</span>
<span class="gi">+                 audio_fps=44100, audio_nbytes=2, verbose=False,</span>
<span class="gi">+                 fps_source=&#39;tbr&#39;):</span>
<span class="gi">+</span>
<span class="w"> </span>        VideoClip.__init__(self)
<span class="gd">-        pix_fmt = &#39;rgba&#39; if has_mask else &#39;rgb24&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # Make a reader</span>
<span class="gi">+        pix_fmt = &quot;rgba&quot; if has_mask else &quot;rgb24&quot;</span>
<span class="w"> </span>        self.reader = FFMPEG_VideoReader(filename, pix_fmt=pix_fmt,
<span class="gd">-            target_resolution=target_resolution, resize_algo=</span>
<span class="gd">-            resize_algorithm, fps_source=fps_source)</span>
<span class="gi">+                                         target_resolution=target_resolution,</span>
<span class="gi">+                                         resize_algo=resize_algorithm,</span>
<span class="gi">+                                         fps_source=fps_source)</span>
<span class="gi">+</span>
<span class="gi">+        # Make some of the reader&#39;s attributes accessible from the clip</span>
<span class="w"> </span>        self.duration = self.reader.duration
<span class="w"> </span>        self.end = self.reader.duration
<span class="gi">+</span>
<span class="w"> </span>        self.fps = self.reader.fps
<span class="w"> </span>        self.size = self.reader.size
<span class="w"> </span>        self.rotation = self.reader.rotation
<span class="gi">+</span>
<span class="w"> </span>        self.filename = self.reader.filename
<span class="gi">+</span>
<span class="w"> </span>        if has_mask:
<span class="gd">-            self.make_frame = lambda t: self.reader.get_frame(t)[:, :, :3]</span>
<span class="gd">-            mask_mf = lambda t: self.reader.get_frame(t)[:, :, 3] / 255.0</span>
<span class="gd">-            self.mask = VideoClip(ismask=True, make_frame=mask_mf</span>
<span class="gd">-                ).set_duration(self.duration)</span>
<span class="gi">+</span>
<span class="gi">+            self.make_frame = lambda t: self.reader.get_frame(t)[:,:,:3]</span>
<span class="gi">+            mask_mf = lambda t: self.reader.get_frame(t)[:,:,3]/255.0</span>
<span class="gi">+            self.mask = (VideoClip(ismask=True, make_frame=mask_mf)</span>
<span class="gi">+                         .set_duration(self.duration))</span>
<span class="w"> </span>            self.mask.fps = self.fps
<span class="gi">+</span>
<span class="w"> </span>        else:
<span class="gi">+</span>
<span class="w"> </span>            self.make_frame = lambda t: self.reader.get_frame(t)
<span class="gi">+</span>
<span class="gi">+        # Make a reader for the audio, if any.</span>
<span class="w"> </span>        if audio and self.reader.infos[&#39;audio_found&#39;]:
<span class="gd">-            self.audio = AudioFileClip(filename, buffersize=</span>
<span class="gd">-                audio_buffersize, fps=audio_fps, nbytes=audio_nbytes)</span>
<span class="gi">+</span>
<span class="gi">+            self.audio = AudioFileClip(filename,</span>
<span class="gi">+                                       buffersize=audio_buffersize,</span>
<span class="gi">+                                       fps=audio_fps,</span>
<span class="gi">+                                       nbytes=audio_nbytes)</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot; Close the internal reader. &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.reader:</span>
<span class="gi">+            self.reader.close()</span>
<span class="gi">+            self.reader = None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self.audio:</span>
<span class="gi">+                self.audio.close()</span>
<span class="gi">+                self.audio = None</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            pass</span>
<span class="gh">diff --git a/moviepy/video/io/bindings.py b/moviepy/video/io/bindings.py</span>
<span class="gh">index 21d54a8..4b206f7 100644</span>
<span class="gd">--- a/moviepy/video/io/bindings.py</span>
<span class="gi">+++ b/moviepy/video/io/bindings.py</span>
<span class="gu">@@ -2,15 +2,31 @@</span>
<span class="w"> </span>This module implements all the functions to communicate with other Python
<span class="w"> </span>modules (PIL, matplotlib, mayavi, etc.)
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import numpy as np


<span class="w"> </span>def PIL_to_npimage(im):
<span class="w"> </span>    &quot;&quot;&quot; Transforms a PIL/Pillow image into a numpy RGB(A) image.
<span class="w"> </span>        Actually all this do is returning numpy.array(im).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return np.array(im)</span>
<span class="gi">+    #w,h = im.size</span>
<span class="gi">+    #d = (4 if im.mode==&quot;RGBA&quot; else 3)</span>
<span class="gi">+    #return +np.frombuffer(im.tobytes(), dtype=&#39;uint8&#39;).reshape((h,w,d))</span>


<span class="w"> </span>def mplfig_to_npimage(fig):
<span class="w"> </span>    &quot;&quot;&quot; Converts a matplotlib figure to a RGB frame after updating the canvas&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    #  only the Agg backend now supports the tostring_rgb function</span>
<span class="gi">+    from matplotlib.backends.backend_agg import FigureCanvasAgg</span>
<span class="gi">+    canvas = FigureCanvasAgg(fig)</span>
<span class="gi">+    canvas.draw() # update/draw the elements</span>
<span class="gi">+</span>
<span class="gi">+    # get the width and the height to resize the matrix</span>
<span class="gi">+    l,b,w,h = canvas.figure.bbox.bounds</span>
<span class="gi">+    w, h = int(w), int(h)</span>
<span class="gi">+</span>
<span class="gi">+    #  exports the canvas to a string buffer and then to a numpy nd.array</span>
<span class="gi">+    buf = canvas.tostring_rgb()</span>
<span class="gi">+    image= np.frombuffer(buf, dtype=np.uint8)</span>
<span class="gi">+    return image.reshape(h,w,3)</span>
<span class="gh">diff --git a/moviepy/video/io/downloader.py b/moviepy/video/io/downloader.py</span>
<span class="gh">index 82a3b18..5b579de 100644</span>
<span class="gd">--- a/moviepy/video/io/downloader.py</span>
<span class="gi">+++ b/moviepy/video/io/downloader.py</span>
<span class="gu">@@ -1,8 +1,11 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Utilities to get a file from the internet
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="gi">+</span>
<span class="w"> </span>import requests
<span class="gi">+</span>
<span class="w"> </span>from moviepy.tools import subprocess_call


<span class="gu">@@ -12,4 +15,20 @@ def download_webfile(url, filename, overwrite=False):</span>
<span class="w"> </span>    using youtube-dl (install youtube-dl first !).
<span class="w"> </span>    If the filename already exists and overwrite=False, nothing will happen.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if os.path.exists(filename) and not overwrite:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;.&#39; in url:</span>
<span class="gi">+        r = requests.get(url, stream=True)</span>
<span class="gi">+        with open(filename, &#39;wb&#39;) as fd:</span>
<span class="gi">+            for chunk in r.iter_content(chunk_size=128):</span>
<span class="gi">+                fd.write(chunk)</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            subprocess_call([&#39;youtube-dl&#39;, url, &#39;-o&#39;, filename])</span>
<span class="gi">+        except OSError as e:</span>
<span class="gi">+            raise OSError(</span>
<span class="gi">+                e.message + &#39;\n A possible reason is that youtube-dl&#39;</span>
<span class="gi">+                &#39; is not installed on your computer. Install it with &#39;</span>
<span class="gi">+                &#39; &quot;pip install youtube_dl&quot;&#39;)</span>
<span class="gh">diff --git a/moviepy/video/io/ffmpeg_reader.py b/moviepy/video/io/ffmpeg_reader.py</span>
<span class="gh">index fd9fccf..7ef5b2d 100644</span>
<span class="gd">--- a/moviepy/video/io/ffmpeg_reader.py</span>
<span class="gi">+++ b/moviepy/video/io/ffmpeg_reader.py</span>
<span class="gu">@@ -2,64 +2,153 @@</span>
<span class="w"> </span>This module implements all the functions to read a video or a picture
<span class="w"> </span>using ffmpeg. It is quite ugly, as there are many pitfalls to avoid
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import division
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="w"> </span>import subprocess as sp
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>from moviepy.compat import DEVNULL, PY3
<span class="gd">-from moviepy.config import get_setting</span>
<span class="gi">+from moviepy.config import get_setting  # ffmpeg, ffmpeg.exe, etc...</span>
<span class="w"> </span>from moviepy.tools import cvsecs
<span class="gi">+</span>
<span class="w"> </span>logging.captureWarnings(True)


<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class FFMPEG_VideoReader:

<span class="gd">-    def __init__(self, filename, print_infos=False, bufsize=None, pix_fmt=</span>
<span class="gd">-        &#39;rgb24&#39;, check_duration=True, target_resolution=None, resize_algo=</span>
<span class="gd">-        &#39;bicubic&#39;, fps_source=&#39;tbr&#39;):</span>
<span class="gi">+    def __init__(self, filename, print_infos=False, bufsize = None,</span>
<span class="gi">+                 pix_fmt=&quot;rgb24&quot;, check_duration=True,</span>
<span class="gi">+                 target_resolution=None, resize_algo=&#39;bicubic&#39;,</span>
<span class="gi">+                 fps_source=&#39;tbr&#39;):</span>
<span class="gi">+</span>
<span class="w"> </span>        self.filename = filename
<span class="w"> </span>        self.proc = None
<span class="w"> </span>        infos = ffmpeg_parse_infos(filename, print_infos, check_duration,
<span class="gd">-            fps_source)</span>
<span class="gi">+                                   fps_source)</span>
<span class="w"> </span>        self.fps = infos[&#39;video_fps&#39;]
<span class="w"> </span>        self.size = infos[&#39;video_size&#39;]
<span class="w"> </span>        self.rotation = infos[&#39;video_rotation&#39;]
<span class="gi">+</span>
<span class="w"> </span>        if target_resolution:
<span class="gi">+            # revert the order, as ffmpeg used (width, height)</span>
<span class="w"> </span>            target_resolution = target_resolution[1], target_resolution[0]
<span class="gi">+</span>
<span class="w"> </span>            if None in target_resolution:
<span class="w"> </span>                ratio = 1
<span class="w"> </span>                for idx, target in enumerate(target_resolution):
<span class="w"> </span>                    if target:
<span class="w"> </span>                        ratio = target / self.size[idx]
<span class="gd">-                self.size = int(self.size[0] * ratio), int(self.size[1] * ratio</span>
<span class="gd">-                    )</span>
<span class="gi">+                self.size = (int(self.size[0] * ratio), int(self.size[1] * ratio))</span>
<span class="w"> </span>            else:
<span class="w"> </span>                self.size = target_resolution
<span class="w"> </span>        self.resize_algo = resize_algo
<span class="gi">+</span>
<span class="w"> </span>        self.duration = infos[&#39;video_duration&#39;]
<span class="w"> </span>        self.ffmpeg_duration = infos[&#39;duration&#39;]
<span class="w"> </span>        self.nframes = infos[&#39;video_nframes&#39;]
<span class="gi">+</span>
<span class="w"> </span>        self.infos = infos
<span class="gi">+</span>
<span class="w"> </span>        self.pix_fmt = pix_fmt
<span class="w"> </span>        self.depth = 4 if pix_fmt == &#39;rgba&#39; else 3
<span class="gi">+</span>
<span class="w"> </span>        if bufsize is None:
<span class="w"> </span>            w, h = self.size
<span class="w"> </span>            bufsize = self.depth * w * h + 100
<span class="gd">-        self.bufsize = bufsize</span>
<span class="gi">+</span>
<span class="gi">+        self.bufsize= bufsize</span>
<span class="w"> </span>        self.initialize()
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>        self.pos = 1
<span class="w"> </span>        self.lastread = self.read_frame()

<span class="gi">+</span>
<span class="w"> </span>    def initialize(self, starttime=0):
<span class="w"> </span>        &quot;&quot;&quot;Opens the file, creates the pipe. &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self.close() # if any</span>
<span class="gi">+</span>
<span class="gi">+        if starttime != 0 :</span>
<span class="gi">+            offset = min(1, starttime)</span>
<span class="gi">+            i_arg = [&#39;-ss&#39;, &quot;%.06f&quot; % (starttime - offset),</span>
<span class="gi">+                     &#39;-i&#39;, self.filename,</span>
<span class="gi">+                     &#39;-ss&#39;, &quot;%.06f&quot; % offset]</span>
<span class="gi">+        else:</span>
<span class="gi">+            i_arg = [ &#39;-i&#39;, self.filename]</span>
<span class="gi">+</span>
<span class="gi">+        cmd = ([get_setting(&quot;FFMPEG_BINARY&quot;)] + i_arg +</span>
<span class="gi">+               [&#39;-loglevel&#39;, &#39;error&#39;,</span>
<span class="gi">+                &#39;-f&#39;, &#39;image2pipe&#39;,</span>
<span class="gi">+                &#39;-vf&#39;, &#39;scale=%d:%d&#39; % tuple(self.size),</span>
<span class="gi">+                &#39;-sws_flags&#39;, self.resize_algo,</span>
<span class="gi">+                &quot;-pix_fmt&quot;, self.pix_fmt,</span>
<span class="gi">+                &#39;-vcodec&#39;, &#39;rawvideo&#39;, &#39;-&#39;])</span>
<span class="gi">+        popen_params = {&quot;bufsize&quot;: self.bufsize,</span>
<span class="gi">+                        &quot;stdout&quot;: sp.PIPE,</span>
<span class="gi">+                        &quot;stderr&quot;: sp.PIPE,</span>
<span class="gi">+                        &quot;stdin&quot;: DEVNULL}</span>
<span class="gi">+</span>
<span class="gi">+        if os.name == &quot;nt&quot;:</span>
<span class="gi">+            popen_params[&quot;creationflags&quot;] = 0x08000000</span>
<span class="gi">+</span>
<span class="gi">+        self.proc = sp.Popen(cmd, **popen_params)</span>
<span class="gi">+</span>

<span class="w"> </span>    def skip_frames(self, n=1):
<span class="w"> </span>        &quot;&quot;&quot;Reads and throws away n frames &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        w, h = self.size</span>
<span class="gi">+        for i in range(n):</span>
<span class="gi">+            self.proc.stdout.read(self.depth*w*h)</span>
<span class="gi">+            #self.proc.stdout.flush()</span>
<span class="gi">+        self.pos += n</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def read_frame(self):</span>
<span class="gi">+        w, h = self.size</span>
<span class="gi">+        nbytes= self.depth*w*h</span>
<span class="gi">+</span>
<span class="gi">+        s = self.proc.stdout.read(nbytes)</span>
<span class="gi">+        if len(s) != nbytes:</span>
<span class="gi">+</span>
<span class="gi">+            warnings.warn(&quot;Warning: in file %s, &quot;%(self.filename)+</span>
<span class="gi">+                   &quot;%d bytes wanted but %d bytes read,&quot;%(nbytes, len(s))+</span>
<span class="gi">+                   &quot;at frame %d/%d, at time %.02f/%.02f sec. &quot;%(</span>
<span class="gi">+                    self.pos,self.nframes,</span>
<span class="gi">+                    1.0*self.pos/self.fps,</span>
<span class="gi">+                    self.duration)+</span>
<span class="gi">+                   &quot;Using the last valid frame instead.&quot;,</span>
<span class="gi">+                   UserWarning)</span>
<span class="gi">+</span>
<span class="gi">+            if not hasattr(self, &#39;lastread&#39;):</span>
<span class="gi">+                raise IOError((&quot;MoviePy error: failed to read the first frame of &quot;</span>
<span class="gi">+                               &quot;video file %s. That might mean that the file is &quot;</span>
<span class="gi">+                               &quot;corrupted. That may also mean that you are using &quot;</span>
<span class="gi">+                               &quot;a deprecated version of FFMPEG. On Ubuntu/Debian &quot;</span>
<span class="gi">+                               &quot;for instance the version in the repos is deprecated. &quot;</span>
<span class="gi">+                               &quot;Please update to a recent version from the website.&quot;)%(</span>
<span class="gi">+                                self.filename))</span>
<span class="gi">+</span>
<span class="gi">+            result = self.lastread</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            if hasattr(np, &#39;frombuffer&#39;):</span>
<span class="gi">+                result = np.frombuffer(s, dtype=&#39;uint8&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                result = np.fromstring(s, dtype=&#39;uint8&#39;)</span>
<span class="gi">+            result.shape =(h, w, len(s)//(w*h)) # reshape((h, w, len(s)//(w*h)))</span>
<span class="gi">+            self.lastread = result</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def get_frame(self, t):
<span class="w"> </span>        &quot;&quot;&quot; Read a file video frame at time t.
<span class="gu">@@ -69,7 +158,42 @@ class FFMPEG_VideoReader:</span>
<span class="w"> </span>        This function tries to avoid fetching arbitrary frames
<span class="w"> </span>        whenever possible, by moving between adjacent frames.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # these definitely need to be rechecked sometime. Seems to work.</span>
<span class="gi">+</span>
<span class="gi">+        # I use that horrible &#39;+0.00001&#39; hack because sometimes due to numerical</span>
<span class="gi">+        # imprecisions a 3.0 can become a 2.99999999... which makes the int()</span>
<span class="gi">+        # go to the previous integer. This makes the fetching more robust in the</span>
<span class="gi">+        # case where you get the nth frame by writing get_frame(n/fps).</span>
<span class="gi">+</span>
<span class="gi">+        pos = int(self.fps*t + 0.00001)+1</span>
<span class="gi">+</span>
<span class="gi">+        # Initialize proc if it is not open</span>
<span class="gi">+        if not self.proc:</span>
<span class="gi">+            self.initialize(t)</span>
<span class="gi">+            self.pos = pos</span>
<span class="gi">+            self.lastread = self.read_frame()</span>
<span class="gi">+</span>
<span class="gi">+        if pos == self.pos:</span>
<span class="gi">+            return self.lastread</span>
<span class="gi">+        elif (pos &lt; self.pos) or (pos &gt; self.pos + 100):</span>
<span class="gi">+            self.initialize(t)</span>
<span class="gi">+            self.pos = pos</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.skip_frames(pos-self.pos-1)</span>
<span class="gi">+        result = self.read_frame()</span>
<span class="gi">+        self.pos = pos</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        if self.proc:</span>
<span class="gi">+            self.proc.terminate()</span>
<span class="gi">+            self.proc.stdout.close()</span>
<span class="gi">+            self.proc.stderr.close()</span>
<span class="gi">+            self.proc.wait()</span>
<span class="gi">+            self.proc = None</span>
<span class="gi">+        if hasattr(self, &#39;lastread&#39;):</span>
<span class="gi">+            del self.lastread</span>

<span class="w"> </span>    def __del__(self):
<span class="w"> </span>        self.close()
<span class="gu">@@ -95,11 +219,15 @@ def ffmpeg_read_image(filename, with_mask=True):</span>
<span class="w"> </span>      this layer as the mask of the returned ImageClip

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pix_fmt = &#39;rgba&#39; if with_mask else &quot;rgb24&quot; </span>
<span class="gi">+    reader = FFMPEG_VideoReader(filename, pix_fmt=pix_fmt, check_duration=False)</span>
<span class="gi">+    im = reader.lastread</span>
<span class="gi">+    del reader</span>
<span class="gi">+    return im</span>


<span class="w"> </span>def ffmpeg_parse_infos(filename, print_infos=False, check_duration=True,
<span class="gd">-    fps_source=&#39;tbr&#39;):</span>
<span class="gi">+                       fps_source=&#39;tbr&#39;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Get file infos using ffmpeg.

<span class="w"> </span>    Returns a dictionnary with the fields:
<span class="gu">@@ -110,4 +238,156 @@ def ffmpeg_parse_infos(filename, print_infos=False, check_duration=True,</span>
<span class="w"> </span>    fetching the uncomplete frames at the end, which raises an error.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    # open the file in a pipe, provoke an error, read output</span>
<span class="gi">+    is_GIF = filename.endswith(&#39;.gif&#39;)</span>
<span class="gi">+    cmd = [get_setting(&quot;FFMPEG_BINARY&quot;), &quot;-i&quot;, filename]</span>
<span class="gi">+    if is_GIF:</span>
<span class="gi">+        cmd += [&quot;-f&quot;, &quot;null&quot;, &quot;/dev/null&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    popen_params = {&quot;bufsize&quot;: 10**5,</span>
<span class="gi">+                    &quot;stdout&quot;: sp.PIPE,</span>
<span class="gi">+                    &quot;stderr&quot;: sp.PIPE,</span>
<span class="gi">+                    &quot;stdin&quot;: DEVNULL}</span>
<span class="gi">+</span>
<span class="gi">+    if os.name == &quot;nt&quot;:</span>
<span class="gi">+        popen_params[&quot;creationflags&quot;] = 0x08000000</span>
<span class="gi">+</span>
<span class="gi">+    proc = sp.Popen(cmd, **popen_params)</span>
<span class="gi">+    (output, error) = proc.communicate()</span>
<span class="gi">+    infos = error.decode(&#39;utf8&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    del proc</span>
<span class="gi">+</span>
<span class="gi">+    if print_infos:</span>
<span class="gi">+        # print the whole info text returned by FFMPEG</span>
<span class="gi">+        print(infos)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    lines = infos.splitlines()</span>
<span class="gi">+    if &quot;No such file or directory&quot; in lines[-1]:</span>
<span class="gi">+        raise IOError((&quot;MoviePy error: the file %s could not be found!\n&quot;</span>
<span class="gi">+                      &quot;Please check that you entered the correct &quot;</span>
<span class="gi">+                      &quot;path.&quot;)%filename)</span>
<span class="gi">+</span>
<span class="gi">+    result = dict()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    # get duration (in seconds)</span>
<span class="gi">+    result[&#39;duration&#39;] = None</span>
<span class="gi">+</span>
<span class="gi">+    if check_duration:</span>
<span class="gi">+        try:</span>
<span class="gi">+            keyword = (&#39;frame=&#39; if is_GIF else &#39;Duration: &#39;)</span>
<span class="gi">+            # for large GIFS the &quot;full&quot; duration is presented as the last element in the list.</span>
<span class="gi">+            index = -1 if is_GIF else 0</span>
<span class="gi">+            line = [l for l in lines if keyword in l][index]</span>
<span class="gi">+            match = re.findall(&quot;([0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9][0-9])&quot;, line)[0]</span>
<span class="gi">+            result[&#39;duration&#39;] = cvsecs(match)</span>
<span class="gi">+        except:</span>
<span class="gi">+            raise IOError((&quot;MoviePy error: failed to read the duration of file %s.\n&quot;</span>
<span class="gi">+                           &quot;Here are the file infos returned by ffmpeg:\n\n%s&quot;)%(</span>
<span class="gi">+                              filename, infos))</span>
<span class="gi">+</span>
<span class="gi">+    # get the output line that speaks about video</span>
<span class="gi">+    lines_video = [l for l in lines if &#39; Video: &#39; in l and re.search(&#39;\d+x\d+&#39;, l)]</span>
<span class="gi">+</span>
<span class="gi">+    result[&#39;video_found&#39;] = ( lines_video != [] )</span>
<span class="gi">+</span>
<span class="gi">+    if result[&#39;video_found&#39;]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            line = lines_video[0]</span>
<span class="gi">+</span>
<span class="gi">+            # get the size, of the form 460x320 (w x h)</span>
<span class="gi">+            match = re.search(&quot; [0-9]*x[0-9]*(,| )&quot;, line)</span>
<span class="gi">+            s = list(map(int, line[match.start():match.end()-1].split(&#39;x&#39;)))</span>
<span class="gi">+            result[&#39;video_size&#39;] = s</span>
<span class="gi">+        except:</span>
<span class="gi">+            raise IOError((&quot;MoviePy error: failed to read video dimensions in file %s.\n&quot;</span>
<span class="gi">+                           &quot;Here are the file infos returned by ffmpeg:\n\n%s&quot;)%(</span>
<span class="gi">+                              filename, infos))</span>
<span class="gi">+</span>
<span class="gi">+        # Get the frame rate. Sometimes it&#39;s &#39;tbr&#39;, sometimes &#39;fps&#39;, sometimes</span>
<span class="gi">+        # tbc, and sometimes tbc/2...</span>
<span class="gi">+        # Current policy: Trust tbr first, then fps unless fps_source is</span>
<span class="gi">+        # specified as &#39;fps&#39; in which case try fps then tbr</span>
<span class="gi">+</span>
<span class="gi">+        # If result is near from x*1000/1001 where x is 23,24,25,50,</span>
<span class="gi">+        # replace by x*1000/1001 (very common case for the fps).</span>
<span class="gi">+</span>
<span class="gi">+        def get_tbr():</span>
<span class="gi">+            match = re.search(&quot;( [0-9]*.| )[0-9]* tbr&quot;, line)</span>
<span class="gi">+</span>
<span class="gi">+            # Sometimes comes as e.g. 12k. We need to replace that with 12000.</span>
<span class="gi">+            s_tbr = line[match.start():match.end()].split(&#39; &#39;)[1]</span>
<span class="gi">+            if &quot;k&quot; in s_tbr:</span>
<span class="gi">+                tbr = float(s_tbr.replace(&quot;k&quot;, &quot;&quot;)) * 1000</span>
<span class="gi">+            else:</span>
<span class="gi">+                tbr = float(s_tbr)</span>
<span class="gi">+            return tbr</span>
<span class="gi">+</span>
<span class="gi">+        def get_fps():</span>
<span class="gi">+            match = re.search(&quot;( [0-9]*.| )[0-9]* fps&quot;, line)</span>
<span class="gi">+            fps = float(line[match.start():match.end()].split(&#39; &#39;)[1])</span>
<span class="gi">+            return fps</span>
<span class="gi">+</span>
<span class="gi">+        if fps_source == &#39;tbr&#39;:</span>
<span class="gi">+            try:</span>
<span class="gi">+                result[&#39;video_fps&#39;] = get_tbr()</span>
<span class="gi">+            except:</span>
<span class="gi">+                result[&#39;video_fps&#39;] = get_fps()</span>
<span class="gi">+</span>
<span class="gi">+        elif fps_source == &#39;fps&#39;:</span>
<span class="gi">+            try:</span>
<span class="gi">+                result[&#39;video_fps&#39;] = get_fps()</span>
<span class="gi">+            except:</span>
<span class="gi">+                result[&#39;video_fps&#39;] = get_tbr()</span>
<span class="gi">+</span>
<span class="gi">+        # It is known that a fps of 24 is often written as 24000/1001</span>
<span class="gi">+        # but then ffmpeg nicely rounds it to 23.98, which we hate.</span>
<span class="gi">+        coef = 1000.0/1001.0</span>
<span class="gi">+        fps = result[&#39;video_fps&#39;]</span>
<span class="gi">+        for x in [23,24,25,30,50]:</span>
<span class="gi">+            if (fps!=x) and abs(fps - x*coef) &lt; .01:</span>
<span class="gi">+                result[&#39;video_fps&#39;] = x*coef</span>
<span class="gi">+</span>
<span class="gi">+        if check_duration:</span>
<span class="gi">+            result[&#39;video_nframes&#39;] = int(result[&#39;duration&#39;]*result[&#39;video_fps&#39;])+1</span>
<span class="gi">+            result[&#39;video_duration&#39;] = result[&#39;duration&#39;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            result[&#39;video_nframes&#39;] = 1</span>
<span class="gi">+            result[&#39;video_duration&#39;] = None</span>
<span class="gi">+        # We could have also recomputed the duration from the number</span>
<span class="gi">+        # of frames, as follows:</span>
<span class="gi">+        # &gt;&gt;&gt; result[&#39;video_duration&#39;] = result[&#39;video_nframes&#39;] / result[&#39;video_fps&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        # get the video rotation info.</span>
<span class="gi">+        try:</span>
<span class="gi">+            rotation_lines = [l for l in lines if &#39;rotate          :&#39; in l and re.search(&#39;\d+$&#39;, l)]</span>
<span class="gi">+            if len(rotation_lines):</span>
<span class="gi">+                rotation_line = rotation_lines[0]</span>
<span class="gi">+                match = re.search(&#39;\d+$&#39;, rotation_line)</span>
<span class="gi">+                result[&#39;video_rotation&#39;] = int(rotation_line[match.start() : match.end()])</span>
<span class="gi">+            else:</span>
<span class="gi">+                result[&#39;video_rotation&#39;] = 0</span>
<span class="gi">+        except:</span>
<span class="gi">+            raise IOError((&quot;MoviePy error: failed to read video rotation in file %s.\n&quot;</span>
<span class="gi">+                           &quot;Here are the file infos returned by ffmpeg:\n\n%s&quot;)%(</span>
<span class="gi">+                              filename, infos))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    lines_audio = [l for l in lines if &#39; Audio: &#39; in l]</span>
<span class="gi">+</span>
<span class="gi">+    result[&#39;audio_found&#39;] = lines_audio != []</span>
<span class="gi">+</span>
<span class="gi">+    if result[&#39;audio_found&#39;]:</span>
<span class="gi">+        line = lines_audio[0]</span>
<span class="gi">+        try:</span>
<span class="gi">+            match = re.search(&quot; [0-9]* Hz&quot;, line)</span>
<span class="gi">+            hz_string = line[match.start()+1:match.end()-3]  # Removes the &#39;hz&#39; from the end</span>
<span class="gi">+            result[&#39;audio_fps&#39;] = int(hz_string)</span>
<span class="gi">+        except:</span>
<span class="gi">+            result[&#39;audio_fps&#39;] = &#39;unknown&#39;</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>
<span class="gh">diff --git a/moviepy/video/io/ffmpeg_tools.py b/moviepy/video/io/ffmpeg_tools.py</span>
<span class="gh">index cf73b19..ef66421 100644</span>
<span class="gd">--- a/moviepy/video/io/ffmpeg_tools.py</span>
<span class="gi">+++ b/moviepy/video/io/ffmpeg_tools.py</span>
<span class="gu">@@ -1,7 +1,9 @@</span>
<span class="w"> </span>&quot;&quot;&quot; Misc. bindings to ffmpeg and ImageMagick.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import subprocess as sp
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>from moviepy.config import get_setting
<span class="w"> </span>from moviepy.tools import subprocess_call

<span class="gu">@@ -11,28 +13,56 @@ def ffmpeg_movie_from_frames(filename, folder, fps, digits=6, bitrate=&#39;v&#39;):</span>
<span class="w"> </span>    Writes a movie out of the frames (picture files) in a folder.
<span class="w"> </span>    Almost deprecated.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    s = &quot;%&quot; + &quot;%02d&quot; % digits + &quot;d.png&quot;</span>
<span class="gi">+    cmd = [get_setting(&quot;FFMPEG_BINARY&quot;), &quot;-y&quot;, &quot;-f&quot;,&quot;image2&quot;,</span>
<span class="gi">+             &quot;-r&quot;, &quot;%d&quot;%fps,</span>
<span class="gi">+             &quot;-i&quot;, os.path.join(folder,folder) + &#39;/&#39; + s,</span>
<span class="gi">+             &quot;-b&quot;, &quot;%dk&quot;%bitrate,</span>
<span class="gi">+             &quot;-r&quot;, &quot;%d&quot;%fps,</span>
<span class="gi">+             filename]</span>
<span class="gi">+    </span>
<span class="gi">+    subprocess_call(cmd)</span>


<span class="w"> </span>def ffmpeg_extract_subclip(filename, t1, t2, targetname=None):
<span class="w"> </span>    &quot;&quot;&quot; Makes a new video file playing video file ``filename`` between
<span class="w"> </span>        the times ``t1`` and ``t2``. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    name, ext = os.path.splitext(filename)</span>
<span class="gi">+    if not targetname:</span>
<span class="gi">+        T1, T2 = [int(1000*t) for t in [t1, t2]]</span>
<span class="gi">+        targetname = &quot;%sSUB%d_%d.%s&quot; % (name, T1, T2, ext)</span>
<span class="gi">+    </span>
<span class="gi">+    cmd = [get_setting(&quot;FFMPEG_BINARY&quot;),&quot;-y&quot;,</span>
<span class="gi">+           &quot;-ss&quot;, &quot;%0.2f&quot;%t1,</span>
<span class="gi">+           &quot;-i&quot;, filename,</span>
<span class="gi">+           &quot;-t&quot;, &quot;%0.2f&quot;%(t2-t1),</span>
<span class="gi">+           &quot;-map&quot;, &quot;0&quot;, &quot;-vcodec&quot;, &quot;copy&quot;, &quot;-acodec&quot;, &quot;copy&quot;, targetname]</span>
<span class="gi">+    </span>
<span class="gi">+    subprocess_call(cmd)</span>


<span class="gd">-def ffmpeg_merge_video_audio(video, audio, output, vcodec=&#39;copy&#39;, acodec=</span>
<span class="gd">-    &#39;copy&#39;, ffmpeg_output=False, logger=&#39;bar&#39;):</span>
<span class="gi">+def ffmpeg_merge_video_audio(video,audio,output, vcodec=&#39;copy&#39;,</span>
<span class="gi">+                             acodec=&#39;copy&#39;, ffmpeg_output=False,</span>
<span class="gi">+                             logger = &#39;bar&#39;):</span>
<span class="w"> </span>    &quot;&quot;&quot; merges video file ``video`` and audio file ``audio`` into one
<span class="w"> </span>        movie file ``output``. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cmd = [get_setting(&quot;FFMPEG_BINARY&quot;), &quot;-y&quot;, &quot;-i&quot;, audio,&quot;-i&quot;, video,</span>
<span class="gi">+             &quot;-vcodec&quot;, vcodec, &quot;-acodec&quot;, acodec, output]</span>
<span class="gi">+             </span>
<span class="gi">+    subprocess_call(cmd, logger = logger)</span>
<span class="gi">+    </span>

<span class="gd">-</span>
<span class="gd">-def ffmpeg_extract_audio(inputfile, output, bitrate=3000, fps=44100):</span>
<span class="gi">+def ffmpeg_extract_audio(inputfile,output,bitrate=3000,fps=44100):</span>
<span class="w"> </span>    &quot;&quot;&quot; extract the sound from a video file and save it in ``output`` &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    cmd = [get_setting(&quot;FFMPEG_BINARY&quot;), &quot;-y&quot;, &quot;-i&quot;, inputfile, &quot;-ab&quot;, &quot;%dk&quot;%bitrate,</span>
<span class="gi">+         &quot;-ar&quot;, &quot;%d&quot;%fps, output]</span>
<span class="gi">+    subprocess_call(cmd)</span>
<span class="gi">+    </span>

<span class="gd">-def ffmpeg_resize(video, output, size):</span>
<span class="gi">+def ffmpeg_resize(video,output,size):</span>
<span class="w"> </span>    &quot;&quot;&quot; resizes ``video`` to new size ``size`` and write the result
<span class="w"> </span>        in file ``output``. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cmd= [get_setting(&quot;FFMPEG_BINARY&quot;), &quot;-i&quot;, video, &quot;-vf&quot;, &quot;scale=%d:%d&quot;%(size[0], size[1]),</span>
<span class="gi">+             output]</span>
<span class="gi">+             </span>
<span class="gi">+    subprocess_call(cmd)</span>
<span class="gh">diff --git a/moviepy/video/io/ffmpeg_writer.py b/moviepy/video/io/ffmpeg_writer.py</span>
<span class="gh">index 5d6bb8b..7fdd1dd 100644</span>
<span class="gd">--- a/moviepy/video/io/ffmpeg_writer.py</span>
<span class="gi">+++ b/moviepy/video/io/ffmpeg_writer.py</span>
<span class="gu">@@ -2,10 +2,13 @@</span>
<span class="w"> </span>On the long term this will implement several methods to make videos
<span class="w"> </span>out of VideoClips
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import subprocess as sp
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>from proglog import proglog
<span class="gi">+</span>
<span class="w"> </span>from moviepy.compat import DEVNULL, PY3
<span class="w"> </span>from moviepy.config import get_setting

<span class="gu">@@ -62,39 +65,130 @@ class FFMPEG_VideoWriter:</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, filename, size, fps, codec=&#39;libx264&#39;, audiofile=None,</span>
<span class="gd">-        preset=&#39;medium&#39;, bitrate=None, withmask=False, logfile=None,</span>
<span class="gd">-        threads=None, ffmpeg_params=None):</span>
<span class="gi">+    def __init__(self, filename, size, fps, codec=&quot;libx264&quot;, audiofile=None,</span>
<span class="gi">+                 preset=&quot;medium&quot;, bitrate=None, withmask=False,</span>
<span class="gi">+                 logfile=None, threads=None, ffmpeg_params=None):</span>
<span class="gi">+</span>
<span class="w"> </span>        if logfile is None:
<span class="w"> </span>            logfile = sp.PIPE
<span class="gi">+</span>
<span class="w"> </span>        self.filename = filename
<span class="w"> </span>        self.codec = codec
<span class="gd">-        self.ext = self.filename.split(&#39;.&#39;)[-1]</span>
<span class="gd">-        cmd = [get_setting(&#39;FFMPEG_BINARY&#39;), &#39;-y&#39;, &#39;-loglevel&#39;, &#39;error&#39; if </span>
<span class="gd">-            logfile == sp.PIPE else &#39;info&#39;, &#39;-f&#39;, &#39;rawvideo&#39;, &#39;-vcodec&#39;,</span>
<span class="gd">-            &#39;rawvideo&#39;, &#39;-s&#39;, &#39;%dx%d&#39; % (size[0], size[1]), &#39;-pix_fmt&#39;, </span>
<span class="gd">-            &#39;rgba&#39; if withmask else &#39;rgb24&#39;, &#39;-r&#39;, &#39;%.02f&#39; % fps, &#39;-an&#39;,</span>
<span class="gd">-            &#39;-i&#39;, &#39;-&#39;]</span>
<span class="gi">+        self.ext = self.filename.split(&quot;.&quot;)[-1]</span>
<span class="gi">+</span>
<span class="gi">+        # order is important</span>
<span class="gi">+        cmd = [</span>
<span class="gi">+            get_setting(&quot;FFMPEG_BINARY&quot;),</span>
<span class="gi">+            &#39;-y&#39;,</span>
<span class="gi">+            &#39;-loglevel&#39;, &#39;error&#39; if logfile == sp.PIPE else &#39;info&#39;,</span>
<span class="gi">+            &#39;-f&#39;, &#39;rawvideo&#39;,</span>
<span class="gi">+            &#39;-vcodec&#39;, &#39;rawvideo&#39;,</span>
<span class="gi">+            &#39;-s&#39;, &#39;%dx%d&#39; % (size[0], size[1]),</span>
<span class="gi">+            &#39;-pix_fmt&#39;, &#39;rgba&#39; if withmask else &#39;rgb24&#39;,</span>
<span class="gi">+            &#39;-r&#39;, &#39;%.02f&#39; % fps,</span>
<span class="gi">+            &#39;-an&#39;, &#39;-i&#39;, &#39;-&#39;</span>
<span class="gi">+        ]</span>
<span class="w"> </span>        if audiofile is not None:
<span class="gd">-            cmd.extend([&#39;-i&#39;, audiofile, &#39;-acodec&#39;, &#39;copy&#39;])</span>
<span class="gd">-        cmd.extend([&#39;-vcodec&#39;, codec, &#39;-preset&#39;, preset])</span>
<span class="gi">+            cmd.extend([</span>
<span class="gi">+                &#39;-i&#39;, audiofile,</span>
<span class="gi">+                &#39;-acodec&#39;, &#39;copy&#39;</span>
<span class="gi">+            ])</span>
<span class="gi">+        cmd.extend([</span>
<span class="gi">+            &#39;-vcodec&#39;, codec,</span>
<span class="gi">+            &#39;-preset&#39;, preset,</span>
<span class="gi">+        ])</span>
<span class="w"> </span>        if ffmpeg_params is not None:
<span class="w"> </span>            cmd.extend(ffmpeg_params)
<span class="w"> </span>        if bitrate is not None:
<span class="gd">-            cmd.extend([&#39;-b&#39;, bitrate])</span>
<span class="gi">+            cmd.extend([</span>
<span class="gi">+                &#39;-b&#39;, bitrate</span>
<span class="gi">+            ])</span>
<span class="gi">+</span>
<span class="w"> </span>        if threads is not None:
<span class="gd">-            cmd.extend([&#39;-threads&#39;, str(threads)])</span>
<span class="gd">-        if codec == &#39;libx264&#39; and size[0] % 2 == 0 and size[1] % 2 == 0:</span>
<span class="gd">-            cmd.extend([&#39;-pix_fmt&#39;, &#39;yuv420p&#39;])</span>
<span class="gd">-        cmd.extend([filename])</span>
<span class="gd">-        popen_params = {&#39;stdout&#39;: DEVNULL, &#39;stderr&#39;: logfile, &#39;stdin&#39;: sp.PIPE}</span>
<span class="gd">-        if os.name == &#39;nt&#39;:</span>
<span class="gd">-            popen_params[&#39;creationflags&#39;] = 134217728</span>
<span class="gi">+            cmd.extend([&quot;-threads&quot;, str(threads)])</span>
<span class="gi">+</span>
<span class="gi">+        if ((codec == &#39;libx264&#39;) and</span>
<span class="gi">+                (size[0] % 2 == 0) and</span>
<span class="gi">+                (size[1] % 2 == 0)):</span>
<span class="gi">+            cmd.extend([</span>
<span class="gi">+                &#39;-pix_fmt&#39;, &#39;yuv420p&#39;</span>
<span class="gi">+            ])</span>
<span class="gi">+        cmd.extend([</span>
<span class="gi">+            filename</span>
<span class="gi">+        ])</span>
<span class="gi">+</span>
<span class="gi">+        popen_params = {&quot;stdout&quot;: DEVNULL,</span>
<span class="gi">+                        &quot;stderr&quot;: logfile,</span>
<span class="gi">+                        &quot;stdin&quot;: sp.PIPE}</span>
<span class="gi">+</span>
<span class="gi">+        # This was added so that no extra unwanted window opens on windows</span>
<span class="gi">+        # when the child process is created</span>
<span class="gi">+        if os.name == &quot;nt&quot;:</span>
<span class="gi">+            popen_params[&quot;creationflags&quot;] = 0x08000000  # CREATE_NO_WINDOW</span>
<span class="gi">+</span>
<span class="w"> </span>        self.proc = sp.Popen(cmd, **popen_params)

<span class="gi">+</span>
<span class="w"> </span>    def write_frame(self, img_array):
<span class="w"> </span>        &quot;&quot;&quot; Writes one frame in the file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            if PY3:</span>
<span class="gi">+               self.proc.stdin.write(img_array.tobytes())</span>
<span class="gi">+            else:</span>
<span class="gi">+               self.proc.stdin.write(img_array.tostring())</span>
<span class="gi">+        except IOError as err:</span>
<span class="gi">+            _, ffmpeg_error = self.proc.communicate()</span>
<span class="gi">+            error = (str(err) + (&quot;\n\nMoviePy error: FFMPEG encountered &quot;</span>
<span class="gi">+                                 &quot;the following error while writing file %s:&quot;</span>
<span class="gi">+                                 &quot;\n\n %s&quot; % (self.filename, str(ffmpeg_error))))</span>
<span class="gi">+</span>
<span class="gi">+            if b&quot;Unknown encoder&quot; in ffmpeg_error:</span>
<span class="gi">+</span>
<span class="gi">+                error = error+(&quot;\n\nThe video export &quot;</span>
<span class="gi">+                  &quot;failed because FFMPEG didn&#39;t find the specified &quot;</span>
<span class="gi">+                  &quot;codec for video encoding (%s). Please install &quot;</span>
<span class="gi">+                  &quot;this codec or change the codec when calling &quot;</span>
<span class="gi">+                  &quot;write_videofile. For instance:\n&quot;</span>
<span class="gi">+                  &quot;  &gt;&gt;&gt; clip.write_videofile(&#39;myvid.webm&#39;, codec=&#39;libvpx&#39;)&quot;)%(self.codec)</span>
<span class="gi">+</span>
<span class="gi">+            elif b&quot;incorrect codec parameters ?&quot; in ffmpeg_error:</span>
<span class="gi">+</span>
<span class="gi">+                 error = error+(&quot;\n\nThe video export &quot;</span>
<span class="gi">+                  &quot;failed, possibly because the codec specified for &quot;</span>
<span class="gi">+                  &quot;the video (%s) is not compatible with the given &quot;</span>
<span class="gi">+                  &quot;extension (%s). Please specify a valid &#39;codec&#39; &quot;</span>
<span class="gi">+                  &quot;argument in write_videofile. This would be &#39;libx264&#39; &quot;</span>
<span class="gi">+                  &quot;or &#39;mpeg4&#39; for mp4, &#39;libtheora&#39; for ogv, &#39;libvpx for webm. &quot;</span>
<span class="gi">+                  &quot;Another possible reason is that the audio codec was not &quot;</span>
<span class="gi">+                  &quot;compatible with the video codec. For instance the video &quot;</span>
<span class="gi">+                  &quot;extensions &#39;ogv&#39; and &#39;webm&#39; only allow &#39;libvorbis&#39; (default) as a&quot;</span>
<span class="gi">+                  &quot;video codec.&quot;</span>
<span class="gi">+                  )%(self.codec, self.ext)</span>
<span class="gi">+</span>
<span class="gi">+            elif  b&quot;encoder setup failed&quot; in ffmpeg_error:</span>
<span class="gi">+</span>
<span class="gi">+                error = error+(&quot;\n\nThe video export &quot;</span>
<span class="gi">+                  &quot;failed, possibly because the bitrate you specified &quot;</span>
<span class="gi">+                  &quot;was too high or too low for the video codec.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            elif b&quot;Invalid encoder type&quot; in ffmpeg_error:</span>
<span class="gi">+</span>
<span class="gi">+                error = error + (&quot;\n\nThe video export failed because the codec &quot;</span>
<span class="gi">+                  &quot;or file extension you provided is not a video&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+            raise IOError(error)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        if self.proc:</span>
<span class="gi">+            self.proc.stdin.close()</span>
<span class="gi">+            if self.proc.stderr is not None:</span>
<span class="gi">+                self.proc.stderr.close()</span>
<span class="gi">+            self.proc.wait()</span>
<span class="gi">+</span>
<span class="gi">+        self.proc = None</span>
<span class="gi">+</span>
<span class="gi">+    # Support the Context Manager protocol, to ensure that resources are cleaned up.</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self
<span class="gu">@@ -102,17 +196,74 @@ class FFMPEG_VideoWriter:</span>
<span class="w"> </span>    def __exit__(self, exc_type, exc_value, traceback):
<span class="w"> </span>        self.close()

<span class="gd">-</span>
<span class="gd">-def ffmpeg_write_video(clip, filename, fps, codec=&#39;libx264&#39;, bitrate=None,</span>
<span class="gd">-    preset=&#39;medium&#39;, withmask=False, write_logfile=False, audiofile=None,</span>
<span class="gd">-    verbose=True, threads=None, ffmpeg_params=None, logger=&#39;bar&#39;):</span>
<span class="gi">+def ffmpeg_write_video(clip, filename, fps, codec=&quot;libx264&quot;, bitrate=None,</span>
<span class="gi">+                       preset=&quot;medium&quot;, withmask=False, write_logfile=False,</span>
<span class="gi">+                       audiofile=None, verbose=True, threads=None, ffmpeg_params=None,</span>
<span class="gi">+                       logger=&#39;bar&#39;):</span>
<span class="w"> </span>    &quot;&quot;&quot; Write the clip to a videofile. See VideoClip.write_videofile for details
<span class="w"> </span>    on the parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+</span>
<span class="gi">+    if write_logfile:</span>
<span class="gi">+        logfile = open(filename + &quot;.log&quot;, &#39;w+&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        logfile = None</span>
<span class="gi">+    logger(message=&#39;Moviepy - Writing video %s\n&#39; % filename)</span>
<span class="gi">+    with FFMPEG_VideoWriter(filename, clip.size, fps, codec = codec,</span>
<span class="gi">+                                preset=preset, bitrate=bitrate, logfile=logfile,</span>
<span class="gi">+                                audiofile=audiofile, threads=threads,</span>
<span class="gi">+                                ffmpeg_params=ffmpeg_params) as writer:</span>
<span class="gi">+</span>
<span class="gi">+        nframes = int(clip.duration*fps)</span>
<span class="gi">+</span>
<span class="gi">+        for t,frame in clip.iter_frames(logger=logger, with_times=True,</span>
<span class="gi">+                                        fps=fps, dtype=&quot;uint8&quot;):</span>
<span class="gi">+            if withmask:</span>
<span class="gi">+                mask = (255*clip.mask.get_frame(t))</span>
<span class="gi">+                if mask.dtype != &quot;uint8&quot;:</span>
<span class="gi">+                    mask = mask.astype(&quot;uint8&quot;)</span>
<span class="gi">+                frame = np.dstack([frame,mask])</span>
<span class="gi">+</span>
<span class="gi">+            writer.write_frame(frame)</span>
<span class="gi">+</span>
<span class="gi">+    if write_logfile:</span>
<span class="gi">+        logfile.close()</span>
<span class="gi">+    logger(message=&#39;Moviepy - Done !&#39;)</span>


<span class="w"> </span>def ffmpeg_write_image(filename, image, logfile=False):
<span class="w"> </span>    &quot;&quot;&quot; Writes an image (HxWx3 or HxWx4 numpy array) to a file, using
<span class="w"> </span>        ffmpeg. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if image.dtype != &#39;uint8&#39;:</span>
<span class="gi">+          image = image.astype(&quot;uint8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    cmd = [ get_setting(&quot;FFMPEG_BINARY&quot;), &#39;-y&#39;,</span>
<span class="gi">+           &#39;-s&#39;, &quot;%dx%d&quot;%(image.shape[:2][::-1]),</span>
<span class="gi">+           &quot;-f&quot;, &#39;rawvideo&#39;,</span>
<span class="gi">+           &#39;-pix_fmt&#39;, &quot;rgba&quot; if (image.shape[2] == 4) else &quot;rgb24&quot;,</span>
<span class="gi">+           &#39;-i&#39;,&#39;-&#39;, filename]</span>
<span class="gi">+</span>
<span class="gi">+    if logfile:</span>
<span class="gi">+        log_file = open(filename + &quot;.log&quot;, &#39;w+&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        log_file = sp.PIPE</span>
<span class="gi">+</span>
<span class="gi">+    popen_params = {&quot;stdout&quot;: DEVNULL,</span>
<span class="gi">+                    &quot;stderr&quot;: log_file,</span>
<span class="gi">+                    &quot;stdin&quot;: sp.PIPE}</span>
<span class="gi">+</span>
<span class="gi">+    if os.name == &quot;nt&quot;:</span>
<span class="gi">+        popen_params[&quot;creationflags&quot;] = 0x08000000</span>
<span class="gi">+</span>
<span class="gi">+    proc = sp.Popen(cmd, **popen_params)</span>
<span class="gi">+    out, err = proc.communicate(image.tostring())</span>
<span class="gi">+</span>
<span class="gi">+    if proc.returncode:</span>
<span class="gi">+        err = &quot;\n&quot;.join([&quot;[MoviePy] Running : %s\n&quot; % cmd,</span>
<span class="gi">+                         &quot;WARNING: this command returned an error:&quot;,</span>
<span class="gi">+                         err.decode(&#39;utf8&#39;)])</span>
<span class="gi">+        raise IOError(err)</span>
<span class="gi">+</span>
<span class="gi">+    del proc</span>
<span class="gh">diff --git a/moviepy/video/io/gif_writers.py b/moviepy/video/io/gif_writers.py</span>
<span class="gh">index 5b4de02..b17d0e6 100644</span>
<span class="gd">--- a/moviepy/video/io/gif_writers.py</span>
<span class="gi">+++ b/moviepy/video/io/gif_writers.py</span>
<span class="gu">@@ -1,11 +1,14 @@</span>
<span class="w"> </span>import os
<span class="w"> </span>import subprocess as sp
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import proglog
<span class="gi">+</span>
<span class="w"> </span>from moviepy.compat import DEVNULL
<span class="w"> </span>from moviepy.config import get_setting
<span class="w"> </span>from moviepy.decorators import requires_duration, use_clip_fps_by_default
<span class="w"> </span>from moviepy.tools import subprocess_call
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import imageio
<span class="w"> </span>    IMAGEIO_FOUND = True
<span class="gu">@@ -15,9 +18,9 @@ except ImportError:</span>

<span class="w"> </span>@requires_duration
<span class="w"> </span>@use_clip_fps_by_default
<span class="gd">-def write_gif_with_tempfiles(clip, filename, fps=None, program=</span>
<span class="gd">-    &#39;ImageMagick&#39;, opt=&#39;OptimizeTransparency&#39;, fuzz=1, verbose=True, loop=0,</span>
<span class="gd">-    dispose=True, colors=None, logger=&#39;bar&#39;):</span>
<span class="gi">+def write_gif_with_tempfiles(clip, filename, fps=None, program= &#39;ImageMagick&#39;,</span>
<span class="gi">+       opt=&quot;OptimizeTransparency&quot;, fuzz=1, verbose=True,</span>
<span class="gi">+       loop=0, dispose=True, colors=None, logger=&#39;bar&#39;):</span>
<span class="w"> </span>    &quot;&quot;&quot; Write the VideoClip to a GIF file.


<span class="gu">@@ -27,14 +30,72 @@ def write_gif_with_tempfiles(clip, filename, fps=None, program=</span>
<span class="w"> </span>    them in the RAM. Useful on computers with little RAM.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+    fileName, ext = os.path.splitext(filename)</span>
<span class="gi">+    tt = np.arange(0,clip.duration, 1.0/fps)</span>
<span class="gi">+</span>
<span class="gi">+    tempfiles = []</span>
<span class="gi">+    </span>
<span class="gi">+    logger(message=&#39;MoviePy - Building file %s\n&#39; % filename)</span>
<span class="gi">+    logger(message=&#39;MoviePy - - Generating GIF frames&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    </span>
<span class="gi">+    for i, t in logger.iter_bar(t=list(enumerate(tt))):</span>
<span class="gi">+</span>
<span class="gi">+        name = &quot;%s_GIFTEMP%04d.png&quot;%(fileName, i+1)</span>
<span class="gi">+        tempfiles.append(name)</span>
<span class="gi">+        clip.save_frame(name, t, withmask=True)</span>
<span class="gi">+</span>
<span class="gi">+    delay = int(100.0/fps)</span>
<span class="gi">+</span>
<span class="gi">+    if program == &quot;ImageMagick&quot;:</span>
<span class="gi">+        logger(message=&#39;MoviePy - - Optimizing GIF with ImageMagick...&#39;)</span>
<span class="gi">+        cmd = [get_setting(&quot;IMAGEMAGICK_BINARY&quot;),</span>
<span class="gi">+              &#39;-delay&#39; , &#39;%d&#39;%delay,</span>
<span class="gi">+              &quot;-dispose&quot; ,&quot;%d&quot;%(2 if dispose else 1),</span>
<span class="gi">+              &quot;-loop&quot; , &quot;%d&quot;%loop,</span>
<span class="gi">+              &quot;%s_GIFTEMP*.png&quot;%fileName,</span>
<span class="gi">+              &quot;-coalesce&quot;,</span>
<span class="gi">+              &quot;-fuzz&quot;, &quot;%02d&quot;%fuzz + &quot;%&quot;,</span>
<span class="gi">+              &quot;-layers&quot;, &quot;%s&quot;%opt,</span>
<span class="gi">+              ]+([&quot;-colors&quot;, &quot;%d&quot;%colors] if colors is not None else [])+[</span>
<span class="gi">+              filename]</span>
<span class="gi">+</span>
<span class="gi">+    elif program == &quot;ffmpeg&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        cmd = [get_setting(&quot;FFMPEG_BINARY&quot;), &#39;-y&#39;,</span>
<span class="gi">+               &#39;-f&#39;, &#39;image2&#39;, &#39;-r&#39;,str(fps),</span>
<span class="gi">+               &#39;-i&#39;, fileName+&#39;_GIFTEMP%04d.png&#39;,</span>
<span class="gi">+               &#39;-r&#39;,str(fps),</span>
<span class="gi">+               filename]</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        subprocess_call(cmd, logger=logger)</span>
<span class="gi">+        logger(message=&#39;MoviePy - GIF ready: %s.&#39; % filename)</span>
<span class="gi">+</span>
<span class="gi">+    except (IOError,OSError) as err:</span>
<span class="gi">+</span>
<span class="gi">+        error = (&quot;MoviePy Error: creation of %s failed because &quot;</span>
<span class="gi">+          &quot;of the following error:\n\n%s.\n\n.&quot;%(filename, str(err)))</span>
<span class="gi">+</span>
<span class="gi">+        if program == &quot;ImageMagick&quot;:</span>
<span class="gi">+            error = error + (&quot;This error can be due to the fact that &quot;</span>
<span class="gi">+                &quot;ImageMagick is not installed on your computer, or &quot;</span>
<span class="gi">+                &quot;(for Windows users) that you didn&#39;t specify the &quot;</span>
<span class="gi">+                &quot;path to the ImageMagick binary in file config_defaults.py.&quot; )</span>
<span class="gi">+</span>
<span class="gi">+        raise IOError(error)</span>
<span class="gi">+</span>
<span class="gi">+    for f in tempfiles:</span>
<span class="gi">+        os.remove(f)</span>
<span class="gi">+</span>


<span class="w"> </span>@requires_duration
<span class="w"> </span>@use_clip_fps_by_default
<span class="gd">-def write_gif(clip, filename, fps=None, program=&#39;ImageMagick&#39;, opt=</span>
<span class="gd">-    &#39;OptimizeTransparency&#39;, fuzz=1, verbose=True, withmask=True, loop=0,</span>
<span class="gd">-    dispose=True, colors=None, logger=&#39;bar&#39;):</span>
<span class="gi">+def write_gif(clip, filename, fps=None, program= &#39;ImageMagick&#39;,</span>
<span class="gi">+           opt=&quot;OptimizeTransparency&quot;, fuzz=1, verbose=True, withmask=True,</span>
<span class="gi">+           loop=0, dispose=True, colors=None, logger=&#39;bar&#39;):</span>
<span class="w"> </span>    &quot;&quot;&quot; Write the VideoClip to a GIF file, without temporary files.

<span class="w"> </span>    Converts a VideoClip into an animated GIF using ImageMagick
<span class="gu">@@ -77,11 +138,117 @@ def write_gif(clip, filename, fps=None, program=&#39;ImageMagick&#39;, opt=</span>
<span class="w"> </span>        &gt;&gt;&gt; myClip.speedx(0.5).write_gif(&#39;myClip.gif&#39;)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    #</span>
<span class="gi">+    # We use processes chained with pipes.</span>
<span class="gi">+    #</span>
<span class="gi">+    # if program == &#39;ffmpeg&#39;</span>
<span class="gi">+    # frames --ffmpeg--&gt; gif</span>
<span class="gi">+    #</span>
<span class="gi">+    # if program == &#39;ImageMagick&#39; and optimize == (None, False)</span>
<span class="gi">+    # frames --ffmpeg--&gt; bmp frames --ImageMagick--&gt; gif</span>
<span class="gi">+    #</span>
<span class="gi">+    #</span>
<span class="gi">+    # if program == &#39;ImageMagick&#39; and optimize != (None, False)</span>
<span class="gi">+    # frames -ffmpeg-&gt; bmp frames -ImagMag-&gt; gif -ImagMag-&gt; better gif</span>
<span class="gi">+    #</span>
<span class="gi">+</span>
<span class="gi">+    delay= 100.0/fps</span>
<span class="gi">+    logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+    if clip.mask is None:</span>
<span class="gi">+        withmask = False</span>
<span class="gi">+</span>
<span class="gi">+    cmd1 = [get_setting(&quot;FFMPEG_BINARY&quot;), &#39;-y&#39;, &#39;-loglevel&#39;, &#39;error&#39;,</span>
<span class="gi">+            &#39;-f&#39;, &#39;rawvideo&#39;,</span>
<span class="gi">+            &#39;-vcodec&#39;,&#39;rawvideo&#39;, &#39;-r&#39;, &quot;%.02f&quot;%fps,</span>
<span class="gi">+            &#39;-s&#39;, &quot;%dx%d&quot;%(clip.w, clip.h),</span>
<span class="gi">+            &#39;-pix_fmt&#39;, (&#39;rgba&#39; if withmask else &#39;rgb24&#39;),</span>
<span class="gi">+            &#39;-i&#39;, &#39;-&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    popen_params = {&quot;stdout&quot;: DEVNULL,</span>
<span class="gi">+                    &quot;stderr&quot;: DEVNULL,</span>
<span class="gi">+                    &quot;stdin&quot;: DEVNULL}</span>
<span class="gi">+</span>
<span class="gi">+    if os.name == &quot;nt&quot;:</span>
<span class="gi">+        popen_params[&quot;creationflags&quot;] = 0x08000000</span>
<span class="gi">+</span>
<span class="gi">+    if program == &quot;ffmpeg&quot;:</span>
<span class="gi">+        popen_params[&quot;stdin&quot;] = sp.PIPE</span>
<span class="gi">+        popen_params[&quot;stdout&quot;] = DEVNULL</span>
<span class="gi">+</span>
<span class="gi">+        proc1 = sp.Popen(cmd1+[ &#39;-pix_fmt&#39;, (&#39;rgba&#39; if withmask else &#39;rgb24&#39;),</span>
<span class="gi">+                                &#39;-r&#39;, &quot;%.02f&quot;%fps, filename], **popen_params)</span>
<span class="gi">+    else:</span>

<span class="gd">-def write_gif_with_image_io(clip, filename, fps=None, opt=0, loop=0, colors</span>
<span class="gd">-    =None, verbose=True, logger=&#39;bar&#39;):</span>
<span class="gi">+        popen_params[&quot;stdin&quot;] = sp.PIPE</span>
<span class="gi">+        popen_params[&quot;stdout&quot;] = sp.PIPE</span>
<span class="gi">+</span>
<span class="gi">+        proc1 = sp.Popen(cmd1+ [&#39;-f&#39;, &#39;image2pipe&#39;, &#39;-vcodec&#39;, &#39;bmp&#39;, &#39;-&#39;],</span>
<span class="gi">+                         **popen_params)</span>
<span class="gi">+</span>
<span class="gi">+    if program == &#39;ImageMagick&#39;:</span>
<span class="gi">+</span>
<span class="gi">+        cmd2 = [get_setting(&quot;IMAGEMAGICK_BINARY&quot;), &#39;-delay&#39;, &quot;%.02f&quot;%(delay),</span>
<span class="gi">+                &quot;-dispose&quot; ,&quot;%d&quot;%(2 if dispose else 1),</span>
<span class="gi">+                &#39;-loop&#39;, &#39;%d&#39;%loop, &#39;-&#39;, &#39;-coalesce&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        if (opt in [False, None]):</span>
<span class="gi">+            popen_params[&quot;stdin&quot;] = proc1.stdout</span>
<span class="gi">+            popen_params[&quot;stdout&quot;] = DEVNULL</span>
<span class="gi">+            proc2 = sp.Popen(cmd2+[filename], **popen_params)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            popen_params[&quot;stdin&quot;] = proc1.stdout</span>
<span class="gi">+            popen_params[&quot;stdout&quot;] = sp.PIPE</span>
<span class="gi">+            proc2 = sp.Popen(cmd2+[&#39;gif:-&#39;], **popen_params)</span>
<span class="gi">+</span>
<span class="gi">+        if opt:</span>
<span class="gi">+</span>
<span class="gi">+            cmd3 = [get_setting(&quot;IMAGEMAGICK_BINARY&quot;), &#39;-&#39;,</span>
<span class="gi">+                    &#39;-fuzz&#39;, &#39;%d&#39;%fuzz+&#39;%&#39;, &#39;-layers&#39;, opt</span>
<span class="gi">+                   ]+([&quot;-colors&quot;, &quot;%d&quot;%colors] if colors is not None else [])+[</span>
<span class="gi">+                   filename]</span>
<span class="gi">+</span>
<span class="gi">+            popen_params[&quot;stdin&quot;] = proc2.stdout</span>
<span class="gi">+            popen_params[&quot;stdout&quot;] = DEVNULL</span>
<span class="gi">+            proc3 = sp.Popen(cmd3, **popen_params)</span>
<span class="gi">+</span>
<span class="gi">+    # We send all the frames to the first process</span>
<span class="gi">+    logger(message=&#39;MoviePy - Building file  %s&#39; % filename)</span>
<span class="gi">+    logger(message=&#39;MoviePy - - Generating GIF frames.&#39;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        for t,frame in clip.iter_frames(fps=fps, logger=logger,</span>
<span class="gi">+                                        with_times=True,  dtype=&quot;uint8&quot;):</span>
<span class="gi">+            if withmask:</span>
<span class="gi">+                mask = 255 * clip.mask.get_frame(t)</span>
<span class="gi">+                frame = np.dstack([frame, mask]).astype(&#39;uint8&#39;)</span>
<span class="gi">+            proc1.stdin.write(frame.tostring())</span>
<span class="gi">+</span>
<span class="gi">+    except IOError as err:</span>
<span class="gi">+</span>
<span class="gi">+        error = (&quot;[MoviePy] Error: creation of %s failed because &quot;</span>
<span class="gi">+          &quot;of the following error:\n\n%s.\n\n.&quot;%(filename, str(err)))</span>
<span class="gi">+</span>
<span class="gi">+        if program == &quot;ImageMagick&quot;:</span>
<span class="gi">+            error = error + (&quot;This can be due to the fact that &quot;</span>
<span class="gi">+                &quot;ImageMagick is not installed on your computer, or &quot;</span>
<span class="gi">+                &quot;(for Windows users) that you didn&#39;t specify the &quot;</span>
<span class="gi">+                &quot;path to the ImageMagick binary in file config_defaults.py.&quot; )</span>
<span class="gi">+</span>
<span class="gi">+        raise IOError(error)</span>
<span class="gi">+    if program == &#39;ImageMagick&#39;:</span>
<span class="gi">+        logger(message=&#39;MoviePy - - Optimizing GIF with ImageMagick.&#39;)</span>
<span class="gi">+    proc1.stdin.close()</span>
<span class="gi">+    proc1.wait()</span>
<span class="gi">+    if program == &#39;ImageMagick&#39;:</span>
<span class="gi">+        proc2.wait()</span>
<span class="gi">+        if opt:</span>
<span class="gi">+            proc3.wait()</span>
<span class="gi">+    logger(message=&#39;MoviePy - - File ready: %s.&#39; % filename)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def write_gif_with_image_io(clip, filename, fps=None, opt=0, loop=0,</span>
<span class="gi">+                            colors=None, verbose=True, logger=&#39;bar&#39;):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Writes the gif with the Python library ImageIO (calls FreeImage).

<span class="gu">@@ -90,4 +257,29 @@ def write_gif_with_image_io(clip, filename, fps=None, opt=0, loop=0, colors</span>
<span class="w"> </span>    opt

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if colors is None:</span>
<span class="gi">+        colors = 256</span>
<span class="gi">+    logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+</span>
<span class="gi">+    if not IMAGEIO_FOUND:</span>
<span class="gi">+        raise ImportError(&quot;Writing a gif with imageio requires ImageIO installed,&quot;</span>
<span class="gi">+                         &quot; with e.g. &#39;pip install imageio&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if fps is None:</span>
<span class="gi">+        fps = clip.fps</span>
<span class="gi">+</span>
<span class="gi">+    quantizer = 0 if opt != 0 else &#39;nq&#39;</span>
<span class="gi">+</span>
<span class="gi">+    writer = imageio.save(</span>
<span class="gi">+        filename,</span>
<span class="gi">+        duration=1.0/fps,</span>
<span class="gi">+        quantizer=quantizer,</span>
<span class="gi">+        palettesize=colors,</span>
<span class="gi">+        loop=loop</span>
<span class="gi">+        )</span>
<span class="gi">+    logger(message=&#39;MoviePy - Building file %s with imageio.&#39; % filename)</span>
<span class="gi">+</span>
<span class="gi">+    for frame in clip.iter_frames(fps=fps, logger=logger, dtype=&#39;uint8&#39;):</span>
<span class="gi">+</span>
<span class="gi">+        writer.append_data(frame)</span>
<span class="gh">diff --git a/moviepy/video/io/html_tools.py b/moviepy/video/io/html_tools.py</span>
<span class="gh">index d4ecc6b..f24af51 100644</span>
<span class="gd">--- a/moviepy/video/io/html_tools.py</span>
<span class="gi">+++ b/moviepy/video/io/html_tools.py</span>
<span class="gu">@@ -2,34 +2,46 @@</span>
<span class="w"> </span>This module implements ipython_display
<span class="w"> </span>A function to embed images/videos/audio in the IPython Notebook
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# Notes:</span>
<span class="gi">+# All media are physically embedded in the IPython Notebook</span>
<span class="gi">+# (instead of simple links to the original files)</span>
<span class="gi">+# That is because most browsers use a cache system and they won&#39;t</span>
<span class="gi">+# properly refresh the media when the original files are changed.</span>
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from base64 import b64encode
<span class="gi">+</span>
<span class="w"> </span>from moviepy.audio.AudioClip import AudioClip
<span class="w"> </span>from moviepy.tools import extensions_dict
<span class="gi">+</span>
<span class="w"> </span>from ..VideoClip import ImageClip, VideoClip
<span class="w"> </span>from .ffmpeg_reader import ffmpeg_parse_infos
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from IPython.display import HTML
<span class="w"> </span>    ipython_available = True
<span class="gd">-</span>
<span class="gd">-</span>
<span class="w"> </span>    class HTML2(HTML):
<span class="gd">-</span>
<span class="w"> </span>        def __add__(self, other):
<span class="gd">-            return HTML2(self.data + other.data)</span>
<span class="gi">+            return HTML2(self.data+other.data)</span>
<span class="gi">+</span>
<span class="w"> </span>except ImportError:
<span class="w"> </span>    ipython_available = False
<span class="gd">-sorry = &quot;Sorry, seems like your browser doesn&#39;t support HTML5 audio/video&quot;</span>
<span class="gd">-templates = {&#39;audio&#39;: </span>
<span class="gd">-    &quot;&lt;audio controls&gt;&lt;source %(options)s  src=&#39;data:audio/%(ext)s;base64,%(data)s&#39;&gt;&quot;</span>
<span class="gd">-     + sorry + &#39;&lt;/audio&gt;&#39;, &#39;image&#39;:</span>
<span class="gd">-    &quot;&lt;img %(options)s src=&#39;data:image/%(ext)s;base64,%(data)s&#39;&gt;&quot;, &#39;video&#39;: </span>
<span class="gd">-    &quot;&lt;video %(options)ssrc=&#39;data:video/%(ext)s;base64,%(data)s&#39; controls&gt;&quot; +</span>
<span class="gd">-    sorry + &#39;&lt;/video&gt;&#39;}</span>


<span class="gd">-def html_embed(clip, filetype=None, maxduration=60, rd_kwargs=None, center=</span>
<span class="gd">-    True, **html_kwargs):</span>
<span class="gi">+sorry = &quot;Sorry, seems like your browser doesn&#39;t support HTML5 audio/video&quot;</span>
<span class="gi">+templates = {&quot;audio&quot;:(&quot;&lt;audio controls&gt;&quot;</span>
<span class="gi">+                         &quot;&lt;source %(options)s  src=&#39;data:audio/%(ext)s;base64,%(data)s&#39;&gt;&quot;</span>
<span class="gi">+                     +sorry+&quot;&lt;/audio&gt;&quot;),</span>
<span class="gi">+             &quot;image&quot;:&quot;&lt;img %(options)s &quot;</span>
<span class="gi">+                     &quot;src=&#39;data:image/%(ext)s;base64,%(data)s&#39;&gt;&quot;,</span>
<span class="gi">+             &quot;video&quot;:(&quot;&lt;video %(options)s&quot;</span>
<span class="gi">+                       &quot;src=&#39;data:video/%(ext)s;base64,%(data)s&#39; controls&gt;&quot;</span>
<span class="gi">+                       +sorry+&quot;&lt;/video&gt;&quot;)}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def html_embed(clip, filetype=None, maxduration=60, rd_kwargs=None,</span>
<span class="gi">+               center=True, **html_kwargs):</span>
<span class="w"> </span>    &quot;&quot;&quot; Returns HTML5 code embedding the clip

<span class="w"> </span>    clip
<span class="gu">@@ -67,12 +79,85 @@ def html_embed(clip, filetype=None, maxduration=60, rd_kwargs=None, center=</span>
<span class="w"> </span>    &gt;&gt;&gt; clip.save_frame(&quot;first_frame.jpeg&quot;)
<span class="w"> </span>    &gt;&gt;&gt; mpy.ipython_display(&quot;first_frame.jpeg&quot;)

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;  </span>
<span class="gi">+    </span>
<span class="gi">+    if rd_kwargs is None:</span>
<span class="gi">+        rd_kwargs = {}</span>
<span class="gi">+</span>
<span class="gi">+    if &quot;Clip&quot; in str(clip.__class__):</span>
<span class="gi">+        TEMP_PREFIX = &quot;__temp__&quot;</span>
<span class="gi">+        if isinstance(clip,ImageClip):</span>
<span class="gi">+            filename = TEMP_PREFIX+&quot;.png&quot;</span>
<span class="gi">+            kwargs = {&#39;filename&#39;:filename, &#39;withmask&#39;:True}</span>
<span class="gi">+            kwargs.update(rd_kwargs)</span>
<span class="gi">+            clip.save_frame(**kwargs)</span>
<span class="gi">+        elif isinstance(clip,VideoClip):</span>
<span class="gi">+            filename = TEMP_PREFIX+&quot;.mp4&quot;</span>
<span class="gi">+            kwargs = {&#39;filename&#39;:filename, &#39;verbose&#39;:False, &#39;preset&#39;:&#39;ultrafast&#39;}</span>
<span class="gi">+            kwargs.update(rd_kwargs)</span>
<span class="gi">+            clip.write_videofile(**kwargs)</span>
<span class="gi">+        elif isinstance(clip,AudioClip):</span>
<span class="gi">+            filename = TEMP_PREFIX+&quot;.mp3&quot;</span>
<span class="gi">+            kwargs = {&#39;filename&#39;: filename, &#39;verbose&#39;:False}</span>
<span class="gi">+            kwargs.update(rd_kwargs)</span>
<span class="gi">+            clip.write_audiofile(**kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+          raise ValueError(&quot;Unknown class for the clip. Cannot embed and preview.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return html_embed(filename, maxduration=maxduration, rd_kwargs=rd_kwargs,</span>
<span class="gi">+                           center=center, **html_kwargs)</span>
<span class="gi">+    </span>
<span class="gi">+    filename = clip</span>
<span class="gi">+    options = &quot; &quot;.join([&quot;%s=&#39;%s&#39;&quot;%(str(k), str(v)) for k,v in html_kwargs.items()])</span>
<span class="gi">+    name, ext = os.path.splitext(filename)</span>
<span class="gi">+    ext = ext[1:]</span>
<span class="gi">+</span>
<span class="gi">+    if filetype is None:</span>
<span class="gi">+        ext = filename.split(&#39;.&#39;)[-1].lower()</span>
<span class="gi">+        if ext == &quot;gif&quot;:</span>
<span class="gi">+            filetype = &#39;image&#39;</span>
<span class="gi">+        elif ext in extensions_dict:</span>
<span class="gi">+            filetype = extensions_dict[ext][&#39;type&#39;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;No file type is known for the provided file. Please provide &quot;</span>
<span class="gi">+                             &quot;argument `filetype` (one of &#39;image&#39;, &#39;video&#39;, &#39;sound&#39;) to the &quot;</span>
<span class="gi">+                             &quot;ipython display function.&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    </span>
<span class="gi">+    if filetype== &#39;video&#39;:</span>
<span class="gi">+        # The next lines set the HTML5-cvompatible extension and check that the</span>
<span class="gi">+        # extension is HTML5-valid</span>
<span class="gi">+        exts_htmltype = {&#39;mp4&#39;: &#39;mp4&#39;, &#39;webm&#39;:&#39;webm&#39;, &#39;ogv&#39;:&#39;ogg&#39;}</span>
<span class="gi">+        allowed_exts = &quot; &quot;.join(exts_htmltype.keys()) </span>
<span class="gi">+        try:</span>
<span class="gi">+            ext = exts_htmltype[ext]</span>
<span class="gi">+        except:</span>
<span class="gi">+            raise ValueError(&quot;This video extension cannot be displayed in the &quot;</span>
<span class="gi">+                   &quot;IPython Notebook. Allowed extensions: &quot;+allowed_exts)</span>
<span class="gi">+    </span>
<span class="gi">+    if filetype in [&#39;audio&#39;, &#39;video&#39;]:</span>
<span class="gi">+</span>
<span class="gi">+        duration = ffmpeg_parse_infos(filename)[&#39;duration&#39;]</span>
<span class="gi">+        if duration &gt; maxduration:</span>
<span class="gi">+            raise ValueError(&quot;The duration of video %s (%.1f) exceeds the &#39;maxduration&#39; &quot;%(filename, duration)+</span>
<span class="gi">+                             &quot;attribute. You can increase &#39;maxduration&#39;, by passing &#39;maxduration&#39; parameter&quot;</span>
<span class="gi">+                             &quot;to ipython_display function.&quot;</span>
<span class="gi">+                             &quot;But note that embedding large videos may take all the memory away !&quot;)</span>
<span class="gi">+            </span>
<span class="gi">+    with open(filename, &quot;rb&quot;) as f:</span>
<span class="gi">+        data= b64encode(f.read()).decode(&quot;utf-8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    template = templates[filetype]</span>
<span class="gi">+</span>
<span class="gi">+    result = template%{&#39;data&#39;:data, &#39;options&#39;:options, &#39;ext&#39;:ext}</span>
<span class="gi">+    if center:</span>
<span class="gi">+        result = r&quot;&lt;div align=middle&gt;%s&lt;/div&gt;&quot;%result</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def ipython_display(clip, filetype=None, maxduration=60, t=None, fps=None,
<span class="gd">-    rd_kwargs=None, center=True, **html_kwargs):</span>
<span class="gi">+                    rd_kwargs=None, center=True, **html_kwargs):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    clip
<span class="w"> </span>      Either the name of a file, or a clip to preview. The clip will
<span class="gu">@@ -119,4 +204,18 @@ def ipython_display(clip, filetype=None, maxduration=60, t=None, fps=None,</span>
<span class="w"> </span>    &gt;&gt;&gt; clip.save_frame(&quot;first_frame.jpeg&quot;)
<span class="w"> </span>    &gt;&gt;&gt; mpy.ipython_display(&quot;first_frame.jpeg&quot;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+        </span>
<span class="gi">+    if not ipython_available:</span>
<span class="gi">+        raise ImportError(&quot;Only works inside an IPython Notebook&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if rd_kwargs is None:</span>
<span class="gi">+        rd_kwargs = {}</span>
<span class="gi">+        </span>
<span class="gi">+    if fps is not None:</span>
<span class="gi">+        rd_kwargs[&#39;fps&#39;] = fps</span>
<span class="gi">+</span>
<span class="gi">+    if t is not None:</span>
<span class="gi">+        clip = clip.to_ImageClip(t)</span>
<span class="gi">+</span>
<span class="gi">+    return HTML2(html_embed(clip, filetype=filetype, maxduration=maxduration,</span>
<span class="gi">+                center=center, rd_kwargs=rd_kwargs, **html_kwargs))</span>
<span class="gh">diff --git a/moviepy/video/io/preview.py b/moviepy/video/io/preview.py</span>
<span class="gh">index 0cb06a5..fbab22d 100644</span>
<span class="gd">--- a/moviepy/video/io/preview.py</span>
<span class="gi">+++ b/moviepy/video/io/preview.py</span>
<span class="gu">@@ -1,16 +1,23 @@</span>
<span class="w"> </span>import threading
<span class="w"> </span>import time
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>import pygame as pg
<span class="w"> </span>from moviepy.decorators import convert_masks_to_RGB, requires_duration
<span class="w"> </span>from moviepy.tools import cvsecs
<span class="gi">+</span>
<span class="w"> </span>pg.init()
<span class="w"> </span>pg.display.set_caption(&#39;MoviePy&#39;)


<span class="w"> </span>def imdisplay(imarray, screen=None):
<span class="w"> </span>    &quot;&quot;&quot;Splashes the given image array on the given pygame screen &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    a = pg.surfarray.make_surface(imarray.swapaxes(0, 1))</span>
<span class="gi">+    if screen is None:</span>
<span class="gi">+        screen = pg.display.set_mode(imarray.shape[:2][::-1])</span>
<span class="gi">+    screen.blit(a, (0, 0))</span>
<span class="gi">+    pg.display.flip()</span>


<span class="w"> </span>@convert_masks_to_RGB
<span class="gu">@@ -29,13 +36,37 @@ def show(clip, t=0, with_mask=True, interactive=False):</span>
<span class="w"> </span>      without the mask.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(t, tuple):</span>
<span class="gi">+        t = cvsecs(*t)</span>
<span class="gi">+</span>
<span class="gi">+    if with_mask and (clip.mask is not None):</span>
<span class="gi">+        import moviepy.video.compositing.CompositeVideoClip as cvc</span>
<span class="gi">+        clip = cvc.CompositeVideoClip([clip.set_position((0, 0))])</span>
<span class="gi">+    img = clip.get_frame(t)</span>
<span class="gi">+    imdisplay(img)</span>
<span class="gi">+</span>
<span class="gi">+    if interactive:</span>
<span class="gi">+        result = []</span>
<span class="gi">+        while True:</span>
<span class="gi">+            for event in pg.event.get():</span>
<span class="gi">+                if event.type == pg.KEYDOWN:</span>
<span class="gi">+                    if event.key == pg.K_ESCAPE:</span>
<span class="gi">+                        print(&quot;Keyboard interrupt&quot;)</span>
<span class="gi">+                        return result</span>
<span class="gi">+                elif event.type == pg.MOUSEBUTTONDOWN:</span>
<span class="gi">+                    x, y = pg.mouse.get_pos()</span>
<span class="gi">+                    rgb = img[y, x]</span>
<span class="gi">+                    result.append({&#39;position&#39;: (x, y), &#39;color&#39;: rgb})</span>
<span class="gi">+                    print(&quot;position, color : &quot;, &quot;%s, %s&quot; %</span>
<span class="gi">+                          (str((x, y)), str(rgb)))</span>
<span class="gi">+            time.sleep(.03)</span>


<span class="w"> </span>@requires_duration
<span class="w"> </span>@convert_masks_to_RGB
<span class="gd">-def preview(clip, fps=15, audio=True, audio_fps=22050, audio_buffersize=</span>
<span class="gd">-    3000, audio_nbytes=2, fullscreen=False):</span>
<span class="gi">+def preview(clip, fps=15, audio=True, audio_fps=22050, audio_buffersize=3000,</span>
<span class="gi">+            audio_nbytes=2, fullscreen=False):</span>
<span class="w"> </span>    &quot;&quot;&quot; 
<span class="w"> </span>    Displays the clip in a window, at the given frames per second
<span class="w"> </span>    (of movie) rate. It will avoid that the clip be played faster
<span class="gu">@@ -60,4 +91,61 @@ def preview(clip, fps=15, audio=True, audio_fps=22050, audio_buffersize=</span>
<span class="w"> </span>      ``True`` if you want the preview to be displayed fullscreen.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if fullscreen:</span>
<span class="gi">+        flags = pg.FULLSCREEN</span>
<span class="gi">+    else:</span>
<span class="gi">+        flags = 0</span>
<span class="gi">+    </span>
<span class="gi">+    # compute and splash the first image</span>
<span class="gi">+    screen = pg.display.set_mode(clip.size, flags)</span>
<span class="gi">+    </span>
<span class="gi">+    audio = audio and (clip.audio is not None)</span>
<span class="gi">+    </span>
<span class="gi">+    if audio:</span>
<span class="gi">+        # the sound will be played in parrallel. We are not</span>
<span class="gi">+        # parralellizing it on different CPUs because it seems that</span>
<span class="gi">+        # pygame and openCV already use several cpus it seems.</span>
<span class="gi">+        </span>
<span class="gi">+        # two synchro-flags to tell whether audio and video are ready</span>
<span class="gi">+        videoFlag = threading.Event()</span>
<span class="gi">+        audioFlag = threading.Event()</span>
<span class="gi">+        # launch the thread</span>
<span class="gi">+        audiothread = threading.Thread(target=clip.audio.preview,</span>
<span class="gi">+                                       args=(audio_fps,</span>
<span class="gi">+                                             audio_buffersize,</span>
<span class="gi">+                                             audio_nbytes,</span>
<span class="gi">+                                             audioFlag, videoFlag))</span>
<span class="gi">+        audiothread.start()</span>
<span class="gi">+    </span>
<span class="gi">+    img = clip.get_frame(0)</span>
<span class="gi">+    imdisplay(img, screen)</span>
<span class="gi">+    if audio:  # synchronize with audio</span>
<span class="gi">+        videoFlag.set()  # say to the audio: video is ready</span>
<span class="gi">+        audioFlag.wait()  # wait for the audio to be ready</span>
<span class="gi">+    </span>
<span class="gi">+    result = []</span>
<span class="gi">+    </span>
<span class="gi">+    t0 = time.time()</span>
<span class="gi">+    for t in np.arange(1.0 / fps, clip.duration-.001, 1.0 / fps):</span>
<span class="gi">+        </span>
<span class="gi">+        img = clip.get_frame(t)</span>
<span class="gi">+        </span>
<span class="gi">+        for event in pg.event.get():</span>
<span class="gi">+            if event.type == pg.QUIT or \</span>
<span class="gi">+                    (event.type == pg.KEYDOWN and event.key == pg.K_ESCAPE):</span>
<span class="gi">+                if audio:</span>
<span class="gi">+                    videoFlag.clear()</span>
<span class="gi">+                print(&quot;Interrupt&quot;)</span>
<span class="gi">+                return result</span>
<span class="gi">+                    </span>
<span class="gi">+            elif event.type == pg.MOUSEBUTTONDOWN:</span>
<span class="gi">+                x, y = pg.mouse.get_pos()</span>
<span class="gi">+                rgb = img[y, x]</span>
<span class="gi">+                result.append({&#39;time&#39;: t, &#39;position&#39;: (x, y),</span>
<span class="gi">+                               &#39;color&#39;: rgb})</span>
<span class="gi">+                print(&quot;time, position, color : &quot;, &quot;%.03f, %s, %s&quot; %</span>
<span class="gi">+                      (t, str((x, y)), str(rgb)))</span>
<span class="gi">+                    </span>
<span class="gi">+        t1 = time.time()</span>
<span class="gi">+        time.sleep(max(0, t - (t1-t0)))</span>
<span class="gi">+        imdisplay(img, screen)</span>
<span class="gh">diff --git a/moviepy/video/io/sliders.py b/moviepy/video/io/sliders.py</span>
<span class="gh">index ac234a1..f94eae0 100644</span>
<span class="gd">--- a/moviepy/video/io/sliders.py</span>
<span class="gi">+++ b/moviepy/video/io/sliders.py</span>
<span class="gu">@@ -2,7 +2,7 @@ import matplotlib.pyplot as plt</span>
<span class="w"> </span>from matplotlib.widgets import Button, Slider


<span class="gd">-def sliders(f, sliders_properties, wait_for_validation=False):</span>
<span class="gi">+def sliders(f, sliders_properties, wait_for_validation = False):</span>
<span class="w"> </span>    &quot;&quot;&quot; A light GUI to manually explore and tune the outputs of 
<span class="w"> </span>        a function.
<span class="w"> </span>        slider_properties is a list of dicts (arguments for Slider )
<span class="gu">@@ -15,4 +15,60 @@ def sliders(f, sliders_properties, wait_for_validation=False):</span>
<span class="w"> </span>                  { &#39;label&#39; :  &#39;depth&#39;,  &#39;valmin&#39;: 1 , &#39;valmax&#39;: 5 } ]
<span class="w"> </span>        inputExplorer(volume,intervals)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+        </span>
<span class="gi">+    nVars = len(sliders_properties)</span>
<span class="gi">+    slider_width = 1.0/nVars</span>
<span class="gi">+    </span>
<span class="gi">+    # CREATE THE CANVAS</span>
<span class="gi">+    </span>
<span class="gi">+    figure,ax = plt.subplots(1)</span>
<span class="gi">+    figure.canvas.set_window_title( &quot;Inputs for &#39;%s&#39;&quot;%(f.func_name) )</span>
<span class="gi">+    </span>
<span class="gi">+    # choose an appropriate height</span>
<span class="gi">+    </span>
<span class="gi">+    width,height = figure.get_size_inches()</span>
<span class="gi">+    height = min(0.5*nVars,8)</span>
<span class="gi">+    figure.set_size_inches(width,height,forward = True)</span>
<span class="gi">+    </span>
<span class="gi">+    </span>
<span class="gi">+    # hide the axis</span>
<span class="gi">+    ax.set_frame_on(False)</span>
<span class="gi">+    ax.get_xaxis().set_visible(False)</span>
<span class="gi">+    ax.get_yaxis().set_visible(False)</span>
<span class="gi">+    </span>
<span class="gi">+</span>
<span class="gi">+    # CREATE THE SLIDERS</span>
<span class="gi">+    </span>
<span class="gi">+    sliders = []</span>
<span class="gi">+    </span>
<span class="gi">+    for i, properties in enumerate(sliders_properties):    </span>
<span class="gi">+        ax = plt.axes([0.1 , 0.95-0.9*(i+1)*slider_width,</span>
<span class="gi">+                       0.8 , 0.8* slider_width])</span>
<span class="gi">+        if not isinstance(properties,dict):</span>
<span class="gi">+            properties =dict(zip([&#39;label&#39;,&#39;valmin&#39;, &#39;valmax&#39;, &#39;valinit&#39;],</span>
<span class="gi">+                             properties))</span>
<span class="gi">+        sliders.append( Slider(ax=ax, **properties) )</span>
<span class="gi">+    </span>
<span class="gi">+    </span>
<span class="gi">+    # CREATE THE CALLBACK FUNCTIONS</span>
<span class="gi">+    </span>
<span class="gi">+    def on_changed(event) :     </span>
<span class="gi">+        res = f(*(s.val for s in sliders))</span>
<span class="gi">+        if res is not None:</span>
<span class="gi">+            print( res )</span>
<span class="gi">+    </span>
<span class="gi">+    def on_key_press(event):</span>
<span class="gi">+        if event.key is &#39;enter&#39;:</span>
<span class="gi">+            on_changed(event)   </span>
<span class="gi">+    </span>
<span class="gi">+    figure.canvas.mpl_connect(&#39;key_press_event&#39;, on_key_press)</span>
<span class="gi">+    </span>
<span class="gi">+    # AUTOMATIC UPDATE ?</span>
<span class="gi">+    </span>
<span class="gi">+    if not wait_for_validation:</span>
<span class="gi">+        for s in sliders :</span>
<span class="gi">+            s.on_changed(on_changed)</span>
<span class="gi">+    </span>
<span class="gi">+    </span>
<span class="gi">+    # DISPLAY THE SLIDERS</span>
<span class="gi">+    plt.show()</span>
<span class="gh">diff --git a/moviepy/video/tools/credits.py b/moviepy/video/tools/credits.py</span>
<span class="gh">index ee5dfb2..a5adfbb 100644</span>
<span class="gd">--- a/moviepy/video/tools/credits.py</span>
<span class="gi">+++ b/moviepy/video/tools/credits.py</span>
<span class="gu">@@ -3,13 +3,14 @@ This module contains different functions to make end and opening</span>
<span class="w"> </span>credits, even though it is difficult to fill everyone needs in this
<span class="w"> </span>matter.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from moviepy.video.compositing.CompositeVideoClip import CompositeVideoClip
<span class="w"> </span>from moviepy.video.fx.resize import resize
<span class="w"> </span>from moviepy.video.VideoClip import ImageClip, TextClip


<span class="gd">-def credits1(creditfile, width, stretch=30, color=&#39;white&#39;, stroke_color=</span>
<span class="gd">-    &#39;black&#39;, stroke_width=2, font=&#39;Impact-Normal&#39;, fontsize=60, gap=0):</span>
<span class="gi">+def credits1(creditfile, width, stretch=30, color=&#39;white&#39;, stroke_color=&#39;black&#39;,</span>
<span class="gi">+             stroke_width=2, font=&#39;Impact-Normal&#39;, fontsize=60, gap=0):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    Parameters
<span class="gu">@@ -70,4 +71,48 @@ def credits1(creditfile, width, stretch=30, color=&#39;white&#39;, stroke_color=</span>
<span class="w"> </span>                Music Supervisor    JEAN DIDIER

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # PARSE THE TXT FILE</span>
<span class="gi">+    texts = []</span>
<span class="gi">+    oneline = True</span>
<span class="gi">+    </span>
<span class="gi">+    with open(creditfile) as f:</span>
<span class="gi">+        for l in f:</span>
<span class="gi">+            if l.startswith((&#39;\n&#39;, &#39;#&#39;)):</span>
<span class="gi">+                # exclude blank lines or comments</span>
<span class="gi">+                continue</span>
<span class="gi">+            elif l.startswith(&#39;.blank&#39;):</span>
<span class="gi">+                # ..blank n  </span>
<span class="gi">+                for i in range(int(l.split(&#39; &#39;)[1])):</span>
<span class="gi">+                    texts.append([&#39;\n&#39;, &#39;\n&#39;])</span>
<span class="gi">+            elif l.startswith(&#39;..&#39;):</span>
<span class="gi">+                texts.append([l[2:], &#39;&#39;])</span>
<span class="gi">+                oneline = True</span>
<span class="gi">+            elif oneline:</span>
<span class="gi">+                texts.append([&#39;&#39;, l])</span>
<span class="gi">+                oneline = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                texts.append([&#39;\n&#39;, l])</span>
<span class="gi">+       </span>
<span class="gi">+    left, right = (&quot;&quot;.join(l) for l in zip(*texts))</span>
<span class="gi">+    </span>
<span class="gi">+    # MAKE TWO COLUMNS FOR THE CREDITS    </span>
<span class="gi">+    left, right = [TextClip(txt, color=color, stroke_color=stroke_color,</span>
<span class="gi">+                            stroke_width=stroke_width, font=font,</span>
<span class="gi">+                            fontsize=fontsize, align=al)</span>
<span class="gi">+                   for txt, al in [(left, &#39;East&#39;), (right, &#39;West&#39;)]]</span>
<span class="gi">+</span>
<span class="gi">+    cc = CompositeVideoClip([left, right.set_position((left.w + gap, 0))],</span>
<span class="gi">+                            size=(left.w + right.w + gap, right.h),</span>
<span class="gi">+                            bg_color=None)</span>
<span class="gi">+    </span>
<span class="gi">+    # SCALE TO THE REQUIRED SIZE</span>
<span class="gi">+    </span>
<span class="gi">+    scaled = resize(cc, width=width)</span>
<span class="gi">+    </span>
<span class="gi">+    # TRANSFORM THE WHOLE CREDIT CLIP INTO AN ImageCLip</span>
<span class="gi">+    </span>
<span class="gi">+    imclip = ImageClip(scaled.get_frame(0))</span>
<span class="gi">+    amask = ImageClip(scaled.mask.get_frame(0), ismask=True)</span>
<span class="gi">+    </span>
<span class="gi">+    return imclip.set_mask(amask)</span>
<span class="gh">diff --git a/moviepy/video/tools/cuts.py b/moviepy/video/tools/cuts.py</span>
<span class="gh">index 9587e45..de75f78 100644</span>
<span class="gd">--- a/moviepy/video/tools/cuts.py</span>
<span class="gi">+++ b/moviepy/video/tools/cuts.py</span>
<span class="gu">@@ -1,14 +1,22 @@</span>
<span class="w"> </span>&quot;&quot;&quot; This module contains everything that can help automatize
<span class="w"> </span>the cuts in MoviePy &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from collections import defaultdict
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>from moviepy.decorators import use_clip_fps_by_default


<span class="w"> </span>@use_clip_fps_by_default
<span class="gd">-def find_video_period(clip, fps=None, tmin=0.3):</span>
<span class="gi">+def find_video_period(clip,fps=None,tmin=.3):</span>
<span class="w"> </span>    &quot;&quot;&quot; Finds the period of a video based on frames correlation &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    frame = lambda t: clip.get_frame(t).flatten()</span>
<span class="gi">+    tt = np.arange(tmin, clip.duration, 1.0/ fps)[1:]</span>
<span class="gi">+    ref = frame(0)</span>
<span class="gi">+    corrs = [ np.corrcoef(ref, frame(t))[0,1] for t in tt]</span>
<span class="gi">+    return tt[np.argmax(corrs)]</span>


<span class="w"> </span>class FramesMatch:
<span class="gu">@@ -36,15 +44,16 @@ class FramesMatch:</span>
<span class="w"> </span>        self.t2 = t2
<span class="w"> </span>        self.d_min = d_min
<span class="w"> </span>        self.d_max = d_max
<span class="gd">-        self.time_span = t2 - t1</span>
<span class="gi">+        self.time_span = t2-t1</span>

<span class="w"> </span>    def __str__(self):
<span class="gd">-        return &#39;(%.04f, %.04f, %.04f, %.04f)&#39; % (self.t1, self.t2, self.</span>
<span class="gd">-            d_min, self.d_max)</span>
<span class="gi">+</span>
<span class="gi">+        return &#39;(%.04f, %.04f, %.04f, %.04f)&#39;%(</span>
<span class="gi">+                self.t1, self.t2, self.d_min, self.d_max)</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;(%.04f, %.04f, %.04f, %.04f)&#39; % (self.t1, self.t2, self.</span>
<span class="gd">-            d_min, self.d_max)</span>
<span class="gi">+        return &#39;(%.04f, %.04f, %.04f, %.04f)&#39;%(</span>
<span class="gi">+                self.t1, self.t2, self.d_min, self.d_max)</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        return iter((self.t1, self.t2, self.d_min, self.d_max))
<span class="gu">@@ -53,8 +62,14 @@ class FramesMatch:</span>
<span class="w"> </span>class FramesMatches(list):

<span class="w"> </span>    def __init__(self, lst):
<span class="gi">+</span>
<span class="w"> </span>        list.__init__(self, sorted(lst, key=lambda e: e.d_max))

<span class="gi">+    def best(self, n=1, percent=None):</span>
<span class="gi">+        if percent is not None:</span>
<span class="gi">+            n = len(self)*percent/100</span>
<span class="gi">+        return self[0] if n==1 else FramesMatches(self[:n])</span>
<span class="gi">+    </span>
<span class="w"> </span>    def filter(self, cond):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns a FramesMatches object obtained by filtering out the FramesMatch
<span class="gu">@@ -66,15 +81,23 @@ class FramesMatches(list):</span>
<span class="w"> </span>        &gt;&gt;&gt; # Only keep the matches corresponding to (&gt; 1 second) sequences.
<span class="w"> </span>        &gt;&gt;&gt; new_matches = matches.filter( lambda match: match.time_span &gt; 1)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return FramesMatches(filter(cond, self))</span>
<span class="gi">+</span>
<span class="gi">+    def save(self, filename):</span>
<span class="gi">+        np.savetxt(filename, np.array([np.array(list(e)) for e in self]),</span>
<span class="gi">+                   fmt=&#39;%.03f&#39;, delimiter=&#39;\t&#39;)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def load(filename):
<span class="w"> </span>        &quot;&quot;&quot; Loads a FramesMatches object from a file.
<span class="w"> </span>        &gt;&gt;&gt; matching_frames = FramesMatches.load(&quot;somefile&quot;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        arr = np.loadtxt(filename)</span>
<span class="gi">+        mfs = [FramesMatch(*e) for e in arr]</span>
<span class="gi">+        return FramesMatches(mfs)</span>

<span class="gi">+        </span>
<span class="gi">+    </span>
<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def from_clip(clip, dist_thr, max_d, fps=None):
<span class="w"> </span>        &quot;&quot;&quot; Finds all the frames tht look alike in a clip, for instance to make a
<span class="gu">@@ -113,11 +136,71 @@ class FramesMatches(list):</span>
<span class="w"> </span>        fps
<span class="w"> </span>          Frames per second (default will be clip.fps)

<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot; </span>
<span class="gi">+        </span>
<span class="gi">+        N_pixels = clip.w * clip.h * 3</span>
<span class="gi">+        dot_product = lambda F1, F2: (F1*F2).sum()/N_pixels</span>
<span class="gi">+        F = {} # will store the frames and their mutual distances</span>
<span class="gi">+        </span>
<span class="gi">+        def distance(t1, t2):</span>
<span class="gi">+            uv = dot_product(F[t1][&#39;frame&#39;], F[t2][&#39;frame&#39;])</span>
<span class="gi">+            u, v = F[t1][&#39;|F|sq&#39;], F[t2][&#39;|F|sq&#39;]</span>
<span class="gi">+            return np.sqrt(u+v - 2*uv)</span>
<span class="gi">+        </span>
<span class="gi">+        matching_frames = [] # the final result.</span>
<span class="gi">+        </span>
<span class="gi">+        for (t,frame) in clip.iter_frames(with_times=True, logger=&#39;bar&#39;):</span>
<span class="gi">+            </span>
<span class="gi">+            flat_frame = 1.0*frame.flatten()</span>
<span class="gi">+            F_norm_sq = dot_product(flat_frame, flat_frame)</span>
<span class="gi">+            F_norm = np.sqrt(F_norm_sq)</span>
<span class="gi">+            </span>
<span class="gi">+            for t2 in list(F.keys()):</span>
<span class="gi">+                # forget old frames, add &#39;t&#39; to the others frames</span>
<span class="gi">+                # check for early rejections based on differing norms</span>
<span class="gi">+                if (t-t2) &gt; max_d:</span>
<span class="gi">+                    F.pop(t2)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    F[t2][t] = {&#39;min&#39;:abs(F[t2][&#39;|F|&#39;] - F_norm),</span>
<span class="gi">+                                &#39;max&#39;:F[t2][&#39;|F|&#39;] + F_norm}</span>
<span class="gi">+                    F[t2][t][&#39;rejected&#39;]= (F[t2][t][&#39;min&#39;] &gt; dist_thr)</span>
<span class="gi">+            </span>
<span class="gi">+            t_F = sorted(F.keys())</span>
<span class="gi">+            </span>
<span class="gi">+            F[t] = {&#39;frame&#39;: flat_frame, &#39;|F|sq&#39;: F_norm_sq, &#39;|F|&#39;: F_norm}</span>
<span class="gi">+                    </span>
<span class="gi">+            for i,t2 in enumerate(t_F):</span>
<span class="gi">+                # Compare F(t) to all the previous frames</span>
<span class="gi">+                </span>
<span class="gi">+                if F[t2][t][&#39;rejected&#39;]:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                </span>
<span class="gi">+                dist = distance(t, t2)</span>
<span class="gi">+                F[t2][t][&#39;min&#39;] = F[t2][t][&#39;max&#39;] = dist</span>
<span class="gi">+                F[t2][t][&#39;rejected&#39;]  = (dist &gt;= dist_thr)</span>
<span class="gi">+                </span>
<span class="gi">+                for t3 in t_F[i+1:]:</span>
<span class="gi">+                    # For all the next times t3, use d(F(t), F(t2)) to</span>
<span class="gi">+                    # update the bounds on d(F(t), F(t3)). See if you can</span>
<span class="gi">+                    # conclude on wether F(t) and F(t3) match.</span>
<span class="gi">+                    t3t, t2t3 = F[t3][t], F[t2][t3]</span>
<span class="gi">+                    t3t[&#39;max&#39;] = min(t3t[&#39;max&#39;], dist+ t2t3[&#39;max&#39;])</span>
<span class="gi">+                    t3t[&#39;min&#39;] = max(t3t[&#39;min&#39;], dist - t2t3[&#39;max&#39;],</span>
<span class="gi">+                                     t2t3[&#39;min&#39;] - dist)</span>
<span class="gi">+                                          </span>
<span class="gi">+                    if t3t[&#39;min&#39;] &gt; dist_thr:</span>
<span class="gi">+                        t3t[&#39;rejected&#39;] = True</span>
<span class="gi">+        </span>
<span class="gi">+            # Store all the good matches (t2,t)</span>
<span class="gi">+            matching_frames += [(t1, t, F[t1][t][&#39;min&#39;], F[t1][t][&#39;max&#39;]) for t1 in F</span>
<span class="gi">+                                if (t1!=t) and not F[t1][t][&#39;rejected&#39;]]</span>
<span class="gi">+                       </span>
<span class="gi">+        return FramesMatches([FramesMatch(*e) for e in matching_frames])</span>
<span class="gi">+</span>
<span class="gi">+</span>

<span class="w"> </span>    def select_scenes(self, match_thr, min_time_span, nomatch_thr=None,
<span class="gd">-        time_distance=0):</span>
<span class="gi">+                      time_distance=0):</span>
<span class="w"> </span>        &quot;&quot;&quot;

<span class="w"> </span>        match_thr
<span class="gu">@@ -131,12 +214,62 @@ class FramesMatches(list):</span>
<span class="w"> </span>          If None, then it is chosen equal to match_thr

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if nomatch_thr is None:</span>
<span class="gi">+            nomatch_thr = match_thr</span>
<span class="gi">+</span>
<span class="gi">+        dict_starts = defaultdict(lambda : [])</span>
<span class="gi">+        for (start, end, d_min, d_max) in self:</span>
<span class="gi">+            dict_starts[start].append([end, d_min, d_max])</span>
<span class="gi">+</span>
<span class="gi">+        starts_ends = sorted(dict_starts.items(), key = lambda k: k[0])</span>
<span class="gi">+        </span>
<span class="gi">+        result = []</span>
<span class="gi">+        min_start= 0</span>
<span class="gi">+        for start, ends_distances in starts_ends:</span>
<span class="gi">+</span>
<span class="gi">+            if start &lt; min_start:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            ends = [end for (end, d_min, d_max) in ends_distances]</span>
<span class="gi">+            great_matches = [(end,d_min, d_max)</span>
<span class="gi">+                             for (end,d_min, d_max) in ends_distances</span>
<span class="gi">+                             if d_max&lt;match_thr]</span>
<span class="gi">+            </span>
<span class="gi">+            great_long_matches = [(end,d_min, d_max)</span>
<span class="gi">+                                  for (end,d_min, d_max) in great_matches</span>
<span class="gi">+                                  if (end-start)&gt;min_time_span]</span>
<span class="gi">+            </span>
<span class="gi">+            </span>
<span class="gi">+            if not great_long_matches:</span>
<span class="gi">+                continue # No GIF can be made starting at this time</span>
<span class="gi">+            </span>
<span class="gi">+            poor_matches = {end for (end,d_min, d_max) in ends_distances if d_min &gt; nomatch_thr}</span>
<span class="gi">+            short_matches = {end for end in ends if (end-start) &lt;= 0.6}</span>
<span class="gi">+            </span>
<span class="gi">+            if not poor_matches.intersection(short_matches):</span>
<span class="gi">+                continue</span>
<span class="gi">+    </span>
<span class="gi">+            end = max(end for (end, d_min, d_max) in great_long_matches)</span>
<span class="gi">+            end, d_min, d_max = next(e for e in great_long_matches if e[0]==end)</span>
<span class="gi">+            </span>
<span class="gi">+            result.append(FramesMatch(start, end, d_min, d_max))</span>
<span class="gi">+            min_start = start + time_distance</span>
<span class="gi">+</span>
<span class="gi">+        return FramesMatches(result)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def write_gifs(self, clip, gif_dir):</span>
<span class="gi">+        for (start, end, _, _) in self: </span>
<span class="gi">+            name = &quot;%s/%08d_%08d.gif&quot; % (gif_dir, 100*start, 100*end)</span>
<span class="gi">+            clip.subclip(start, end).write_gif(name, verbose=False)</span>
<span class="gi">+</span>
<span class="gi">+</span>


<span class="w"> </span>@use_clip_fps_by_default
<span class="gd">-def detect_scenes(clip=None, luminosities=None, thr=10, logger=&#39;bar&#39;, fps=None</span>
<span class="gd">-    ):</span>
<span class="gi">+def detect_scenes(clip=None, luminosities=None, thr=10,</span>
<span class="gi">+                  logger=&#39;bar&#39;, fps=None):</span>
<span class="w"> </span>    &quot;&quot;&quot; Detects scenes of a clip based on luminosity changes.

<span class="w"> </span>    Note that for large clip this may take some time
<span class="gu">@@ -176,5 +309,20 @@ def detect_scenes(clip=None, luminosities=None, thr=10, logger=&#39;bar&#39;, fps=None</span>
<span class="w"> </span>      fps attribute.


<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;       </span>
<span class="gi">+    if luminosities is None:</span>
<span class="gi">+        luminosities = [f.sum() for f in clip.iter_frames(</span>
<span class="gi">+                             fps=fps, dtype=&#39;uint32&#39;, logger=logger)]</span>
<span class="gi">+    </span>
<span class="gi">+    luminosities = np.array(luminosities, dtype=float)</span>
<span class="gi">+    if clip is not None:</span>
<span class="gi">+        end = clip.duration</span>
<span class="gi">+    else:</span>
<span class="gi">+        end = len(luminosities)*(1.0/fps) </span>
<span class="gi">+    lum_diffs = abs(np.diff(luminosities))</span>
<span class="gi">+    avg = lum_diffs.mean()</span>
<span class="gi">+    luminosity_jumps = 1+np.array(np.nonzero(lum_diffs&gt; thr*avg))[0]</span>
<span class="gi">+    tt = [0]+list((1.0/fps) *luminosity_jumps) + [end]</span>
<span class="gi">+    #print tt</span>
<span class="gi">+    cuts = [(t1,t2) for t1,t2 in zip(tt,tt[1:])]</span>
<span class="gi">+    return cuts, luminosities</span>
<span class="gh">diff --git a/moviepy/video/tools/drawing.py b/moviepy/video/tools/drawing.py</span>
<span class="gh">index 262e880..fdc3705 100644</span>
<span class="gd">--- a/moviepy/video/tools/drawing.py</span>
<span class="gi">+++ b/moviepy/video/tools/drawing.py</span>
<span class="gu">@@ -2,6 +2,7 @@</span>
<span class="w"> </span>This module deals with making images (np arrays). It provides drawing
<span class="w"> </span>methods that are difficult to do with the existing Python libraries.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import numpy as np


<span class="gu">@@ -12,11 +13,45 @@ def blit(im1, im2, pos=None, mask=None, ismask=False):</span>
<span class="w"> </span>    ``mask`` if provided. If ``im1`` and ``im2`` are mask pictures
<span class="w"> </span>    (2D float arrays) then ``ismask`` must be ``True``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if pos is None:</span>
<span class="gi">+        pos = [0, 0]</span>
<span class="gi">+</span>
<span class="gi">+    # xp1,yp1,xp2,yp2 = blit area on im2</span>
<span class="gi">+    # x1,y1,x2,y2 = area of im1 to blit on im2</span>
<span class="gi">+    xp, yp = pos</span>
<span class="gi">+    x1 = max(0, -xp)</span>
<span class="gi">+    y1 = max(0, -yp)</span>
<span class="gi">+    h1, w1 = im1.shape[:2]</span>
<span class="gi">+    h2, w2 = im2.shape[:2]</span>
<span class="gi">+    xp2 = min(w2, xp + w1)</span>
<span class="gi">+    yp2 = min(h2, yp + h1)</span>
<span class="gi">+    x2 = min(w1, w2 - xp)</span>
<span class="gi">+    y2 = min(h1, h2 - yp)</span>
<span class="gi">+    xp1 = max(0, xp)</span>
<span class="gi">+    yp1 = max(0, yp)</span>
<span class="gi">+</span>
<span class="gi">+    if (xp1 &gt;= xp2) or (yp1 &gt;= yp2):</span>
<span class="gi">+        return im2</span>
<span class="gi">+</span>
<span class="gi">+    blitted = im1[y1:y2, x1:x2]</span>
<span class="gi">+</span>
<span class="gi">+    new_im2 = +im2</span>
<span class="gi">+</span>
<span class="gi">+    if mask is None:</span>
<span class="gi">+        new_im2[yp1:yp2, xp1:xp2] = blitted</span>
<span class="gi">+    else:</span>
<span class="gi">+        mask = mask[y1:y2, x1:x2]</span>
<span class="gi">+        if len(im1.shape) == 3:</span>
<span class="gi">+            mask = np.dstack(3 * [mask])</span>
<span class="gi">+        blit_region = new_im2[yp1:yp2, xp1:xp2]</span>
<span class="gi">+        new_im2[yp1:yp2, xp1:xp2] = (1.0 * mask * blitted + (1.0 - mask) * blit_region)</span>
<span class="gi">+    </span>
<span class="gi">+    return new_im2.astype(&#39;uint8&#39;) if (not ismask) else new_im2</span>


<span class="gd">-def color_gradient(size, p1, p2=None, vector=None, r=None, col1=0, col2=1.0,</span>
<span class="gd">-    shape=&#39;linear&#39;, offset=0):</span>
<span class="gi">+</span>
<span class="gi">+def color_gradient(size,p1,p2=None,vector=None, r=None, col1=0,col2=1.0,</span>
<span class="gi">+                   shape=&#39;linear&#39;, offset = 0):</span>
<span class="w"> </span>    &quot;&quot;&quot;Draw a linear, bilinear, or radial gradient.

<span class="w"> </span>    The result is a picture of size ``size``, whose color varies
<span class="gu">@@ -79,11 +114,70 @@ def color_gradient(size, p1, p2=None, vector=None, r=None, col1=0, col2=1.0,</span>
<span class="w"> </span>    &gt;&gt;&gt; grad = color_gradient(blabla).astype(&#39;uint8&#39;)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    # np-arrayize and change x,y coordinates to y,x</span>
<span class="gi">+    w,h = size</span>
<span class="gi">+    </span>
<span class="gi">+    col1 = np.array(col1).astype(float) </span>
<span class="gi">+    col2 = np.array(col2).astype(float) </span>
<span class="gi">+    </span>
<span class="gi">+    if shape == &#39;bilinear&#39;:</span>
<span class="gi">+        if vector is None:</span>
<span class="gi">+            vector = np.array(p2) - np.array(p1)</span>
<span class="gi">+        </span>
<span class="gi">+        m1, m2 = [ color_gradient(size, p1, vector=v, col1 = 1.0, col2 = 0,</span>
<span class="gi">+                                 shape = &#39;linear&#39;, offset= offset)</span>
<span class="gi">+                            for v in [vector,-vector]]</span>
<span class="gi">+                            </span>
<span class="gi">+        arr = np.maximum(m1, m2)</span>
<span class="gi">+        if col1.size &gt; 1:</span>
<span class="gi">+            arr = np.dstack(3*[arr])</span>
<span class="gi">+        return arr*col1 + (1-arr)*col2</span>
<span class="gi">+        </span>
<span class="gi">+    </span>
<span class="gi">+    p1 = np.array(p1[::-1]).astype(float)</span>
<span class="gi">+    </span>
<span class="gi">+    if vector is None and p2:</span>
<span class="gi">+        p2 = np.array(p2[::-1])</span>
<span class="gi">+        vector = p2-p1</span>
<span class="gi">+    else:</span>
<span class="gi">+        vector = np.array(vector[::-1])</span>
<span class="gi">+        p2 = p1 + vector</span>
<span class="gi">+    </span>
<span class="gi">+    if vector:    </span>
<span class="gi">+        norm = np.linalg.norm(vector)</span>
<span class="gi">+    </span>
<span class="gi">+    M = np.dstack(np.meshgrid(range(w),range(h))[::-1]).astype(float)</span>
<span class="gi">+    </span>
<span class="gi">+    if shape == &#39;linear&#39;:</span>
<span class="gi">+        </span>
<span class="gi">+        n_vec = vector/norm**2 # norm 1/norm(vector)</span>
<span class="gi">+        </span>
<span class="gi">+        p1 = p1 + offset*vector</span>
<span class="gi">+        arr = (M- p1).dot(n_vec)/(1-offset)</span>
<span class="gi">+        arr = np.minimum(1,np.maximum(0,arr))</span>
<span class="gi">+        if col1.size &gt; 1:</span>
<span class="gi">+            arr = np.dstack(3*[arr])</span>
<span class="gi">+        return arr*col1 + (1-arr)*col2</span>
<span class="gi">+    </span>
<span class="gi">+    elif shape == &#39;radial&#39;:</span>
<span class="gi">+        if r is None:</span>
<span class="gi">+           r = norm</span>

<span class="gi">+        if r == 0:</span>
<span class="gi">+            arr = np.ones((h,w))</span>
<span class="gi">+        else:</span>
<span class="gi">+            arr = (np.sqrt(((M - p1) ** 2).sum(axis=2))) - offset * r</span>
<span class="gi">+            arr = arr / ((1-offset)*r)</span>
<span class="gi">+            arr = np.minimum(1.0, np.maximum(0, arr))</span>
<span class="gi">+                </span>
<span class="gi">+        if col1.size &gt; 1:</span>
<span class="gi">+            arr = np.dstack(3*[arr])</span>
<span class="gi">+        return (1-arr)*col1 + arr*col2</span>
<span class="gi">+                </span>

<span class="gd">-def color_split(size, x=None, y=None, p1=None, p2=None, vector=None, col1=0,</span>
<span class="gd">-    col2=1.0, grad_width=0):</span>
<span class="gi">+def color_split(size,x=None,y=None,p1=None,p2=None,vector=None,</span>
<span class="gi">+                             col1=0,col2=1.0, grad_width=0):</span>
<span class="w"> </span>    &quot;&quot;&quot;Make an image splitted in 2 colored regions.

<span class="w"> </span>    Returns an array of size ``size`` divided in two regions called 1 and
<span class="gu">@@ -129,9 +223,39 @@ def color_split(size, x=None, y=None, p1=None, p2=None, vector=None, col1=0,</span>
<span class="w"> </span>    &gt;&gt;&gt; color_split(size, p1=[20,50], p2=[25,70] col1=0, col2=1)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    </span>
<span class="gi">+    if grad_width or ( (x is None) and (y is None)):</span>
<span class="gi">+        if p2 is not None:</span>
<span class="gi">+            vector = (np.array(p2) - np.array(p1))</span>
<span class="gi">+        elif x is not None:</span>
<span class="gi">+            vector = np.array([0,-1.0])</span>
<span class="gi">+            p1 = np.array([x, 0])</span>
<span class="gi">+        elif y is not None:</span>
<span class="gi">+            vector = np.array([1.0, 0.0])</span>
<span class="gi">+            p1 = np.array([0,y])</span>

<span class="gi">+        x,y = vector</span>
<span class="gi">+        vector = np.array([y,-x]).astype(&#39;float&#39;)</span>
<span class="gi">+        norm = np.linalg.norm(vector)</span>
<span class="gi">+        vector = max(0.1, grad_width) * vector / norm</span>
<span class="gi">+        return color_gradient(size,p1,vector=vector,</span>
<span class="gi">+                              col1 = col1, col2 = col2, shape=&#39;linear&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        w, h = size</span>
<span class="gi">+        shape = (h, w) if np.isscalar(col1) else (h, w, len(col1))</span>
<span class="gi">+        arr = np.zeros(shape)</span>
<span class="gi">+        if x:</span>
<span class="gi">+            arr[:,:x] = col1</span>
<span class="gi">+            arr[:,x:] = col2</span>
<span class="gi">+        elif y:</span>
<span class="gi">+            arr[:y] = col1</span>
<span class="gi">+            arr[y:] = col2</span>
<span class="gi">+        return arr</span>
<span class="gi">+     </span>
<span class="gi">+    # if we are here, it means we didn&#39;t exit with a proper &#39;return&#39;</span>
<span class="gi">+    print( &quot;Arguments in color_split not understood !&quot; )</span>
<span class="gi">+    raise</span>
<span class="gi">+        </span>
<span class="w"> </span>def circle(screensize, center, radius, col1=1.0, col2=0, blur=1):
<span class="w"> </span>    &quot;&quot;&quot; Draw an image with a circle.

<span class="gu">@@ -140,4 +264,6 @@ def circle(screensize, center, radius, col1=1.0, col2=0, blur=1):</span>
<span class="w"> </span>    with a radius ``radius`` but slightly blurred on the border by ``blur``
<span class="w"> </span>    pixels
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    offset = 1.0*(radius-blur)/radius if radius else 0              </span>
<span class="gi">+    return color_gradient(screensize,p1=center,r=radius, col1=col1,</span>
<span class="gi">+                          col2=col2, shape=&#39;radial&#39;, offset=offset)</span>
<span class="gh">diff --git a/moviepy/video/tools/interpolators.py b/moviepy/video/tools/interpolators.py</span>
<span class="gh">index e2d435d..9d1f495 100644</span>
<span class="gd">--- a/moviepy/video/tools/interpolators.py</span>
<span class="gi">+++ b/moviepy/video/tools/interpolators.py</span>
<span class="gu">@@ -2,17 +2,20 @@</span>
<span class="w"> </span>Classes for easy interpolation of trajectories and Curves.
<span class="w"> </span>Requires Scipy installed.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import numpy as np


<span class="w"> </span>class Interpolator:
<span class="w"> </span>    &quot;&quot;&quot; Poorman&#39;s linear interpolator, doesn&#39;t require Scipy. &quot;&quot;&quot;
<span class="gi">+    </span>
<span class="gi">+    def __init__(self, tt=None, ss=None, ttss = None, left=None, right=None):</span>

<span class="gd">-    def __init__(self, tt=None, ss=None, ttss=None, left=None, right=None):</span>
<span class="w"> </span>        if ttss is not None:
<span class="w"> </span>            tt, ss = zip(*ttss)
<span class="gd">-        self.tt = 1.0 * np.array(tt)</span>
<span class="gd">-        self.ss = 1.0 * np.array(ss)</span>
<span class="gi">+        </span>
<span class="gi">+        self.tt = 1.0*np.array(tt)</span>
<span class="gi">+        self.ss = 1.0*np.array(ss)</span>
<span class="w"> </span>        self.left = left
<span class="w"> </span>        self.right = right
<span class="w"> </span>        self.tmin, self.tmax = min(tt), max(tt)
<span class="gu">@@ -20,14 +23,51 @@ class Interpolator:</span>
<span class="w"> </span>    def __call__(self, t):
<span class="w"> </span>        return np.interp(t, self.tt, self.ss, self.left, self.right)

<span class="gd">-</span>
<span class="w"> </span>class Trajectory:

<span class="w"> </span>    def __init__(self, tt, xx, yy):
<span class="gd">-        self.tt = 1.0 * np.array(tt)</span>
<span class="gi">+</span>
<span class="gi">+        self.tt = 1.0*np.array(tt)</span>
<span class="w"> </span>        self.xx = np.array(xx)
<span class="w"> </span>        self.yy = np.array(yy)
<span class="w"> </span>        self.update_interpolators()

<span class="w"> </span>    def __call__(self, t):
<span class="w"> </span>        return np.array([self.xi(t), self.yi(t)])
<span class="gi">+</span>
<span class="gi">+    def addx(self, x):</span>
<span class="gi">+        return Trajectory(self.tt, self.xx+x, self.yy)</span>
<span class="gi">+</span>
<span class="gi">+    def addy(self, y):</span>
<span class="gi">+        return Trajectory(self.tt, self.xx, self.yy+y)</span>
<span class="gi">+</span>
<span class="gi">+    def update_interpolators(self):</span>
<span class="gi">+        self.xi =  Interpolator(self.tt, self.xx)</span>
<span class="gi">+        self.yi =  Interpolator(self.tt, self.yy)</span>
<span class="gi">+    </span>
<span class="gi">+    def txy(self, tms=False):</span>
<span class="gi">+        return zip((1000 if tms else 1)*self.tt, self.xx, self.yy)</span>
<span class="gi">+</span>
<span class="gi">+    def to_file(self, filename):</span>
<span class="gi">+        np.savetxt(filename, np.array(self.txy(tms=True)),</span>
<span class="gi">+                   fmt=&quot;%d&quot;, delimiter=&#39;\t&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def from_file(filename):</span>
<span class="gi">+        arr = np.loadtxt(filename, delimiter=&#39;\t&#39;)</span>
<span class="gi">+        tt, xx, yy = arr.T</span>
<span class="gi">+        return Trajectory(1.0*tt/1000, xx, yy)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def save_list(trajs, filename):</span>
<span class="gi">+        N = len(trajs)</span>
<span class="gi">+        arr = np.hstack([np.array(list(t.txy(tms=True))) for t in trajs])</span>
<span class="gi">+        np.savetxt( filename, arr, fmt=&quot;%d&quot;, delimiter=&#39;\t&#39;,</span>
<span class="gi">+                    header = &quot;\t&quot;.join(N*[&#39;t(ms)&#39;, &#39;x&#39;, &#39;y&#39;]))</span>
<span class="gi">+    </span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def load_list(filename):</span>
<span class="gi">+        arr = np.loadtxt(filename, delimiter=&#39;\t&#39;).T</span>
<span class="gi">+        Nlines = arr.shape[0]</span>
<span class="gi">+        return [Trajectory(tt=1.0*a[0]/1000, xx=a[1], yy=a[2])</span>
<span class="gi">+                for a in np.split(arr, Nlines/3)]</span>
<span class="gh">diff --git a/moviepy/video/tools/segmenting.py b/moviepy/video/tools/segmenting.py</span>
<span class="gh">index 39b1c9e..1e6c06b 100644</span>
<span class="gd">--- a/moviepy/video/tools/segmenting.py</span>
<span class="gi">+++ b/moviepy/video/tools/segmenting.py</span>
<span class="gu">@@ -1,9 +1,10 @@</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>import scipy.ndimage as ndi
<span class="w"> </span>from moviepy.video.VideoClip import ImageClip


<span class="gd">-def findObjects(clip, rem_thr=500, preview=False):</span>
<span class="gi">+def findObjects(clip,rem_thr=500, preview=False):</span>
<span class="w"> </span>    &quot;&quot;&quot; 
<span class="w"> </span>    Returns a list of ImageClips representing each a separate object on
<span class="w"> </span>    the screen.
<span class="gu">@@ -12,4 +13,47 @@ def findObjects(clip, rem_thr=500, preview=False):</span>
<span class="w"> </span>         considered false positives and will be removed

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    image = clip.get_frame(0)</span>
<span class="gi">+    if not clip.mask:</span>
<span class="gi">+        clip = clip.add_mask()</span>
<span class="gi">+        </span>
<span class="gi">+    mask = clip.mask.get_frame(0)</span>
<span class="gi">+    labelled, num_features = ndi.measurements.label(image[:,:,0])</span>
<span class="gi">+    </span>
<span class="gi">+    #find the objects</span>
<span class="gi">+    slices = []</span>
<span class="gi">+    for e in ndi.find_objects(labelled):</span>
<span class="gi">+        if mask[e[0],e[1]].mean() &lt;= 0.2:</span>
<span class="gi">+            # remove letter holes (in o,e,a, etc.)</span>
<span class="gi">+            continue</span>
<span class="gi">+        if image[e[0],e[1]].size &lt;= rem_thr:</span>
<span class="gi">+            # remove very small slices</span>
<span class="gi">+            continue</span>
<span class="gi">+        slices.append(e)</span>
<span class="gi">+    islices = sorted(enumerate(slices), key = lambda s : s[1][1].start)</span>
<span class="gi">+    </span>
<span class="gi">+    letters = []</span>
<span class="gi">+    for i,(ind,(sy,sx)) in enumerate(islices):</span>
<span class="gi">+        &quot;&quot;&quot; crop each letter separately &quot;&quot;&quot;</span>
<span class="gi">+        sy = slice(sy.start-1,sy.stop+1)</span>
<span class="gi">+        sx = slice(sx.start-1,sx.stop+1)</span>
<span class="gi">+        letter = image[sy,sx]</span>
<span class="gi">+        labletter = labelled[sy,sx]</span>
<span class="gi">+        maskletter = (labletter==(ind+1))*mask[sy,sx]</span>
<span class="gi">+        letter = ImageClip(image[sy,sx])</span>
<span class="gi">+        letter.mask = ImageClip( maskletter,ismask=True)</span>
<span class="gi">+        letter.screenpos = np.array((sx.start,sy.start))</span>
<span class="gi">+        letters.append(letter)</span>
<span class="gi">+    </span>
<span class="gi">+    if preview:</span>
<span class="gi">+        import matplotlib.pyplot as plt</span>
<span class="gi">+        print( &quot;found %d objects&quot;%(num_features) )</span>
<span class="gi">+        fig,ax = plt.subplots(2)</span>
<span class="gi">+        ax[0].axis(&#39;off&#39;)</span>
<span class="gi">+        ax[0].imshow(labelled)</span>
<span class="gi">+        ax[1].imshow([range(num_features)],interpolation=&#39;nearest&#39;)</span>
<span class="gi">+        ax[1].set_yticks([])</span>
<span class="gi">+        plt.show()</span>
<span class="gi">+    </span>
<span class="gi">+    return letters</span>
<span class="gh">diff --git a/moviepy/video/tools/subtitles.py b/moviepy/video/tools/subtitles.py</span>
<span class="gh">index b191e4d..34a8615 100644</span>
<span class="gd">--- a/moviepy/video/tools/subtitles.py</span>
<span class="gi">+++ b/moviepy/video/tools/subtitles.py</span>
<span class="gu">@@ -1,6 +1,9 @@</span>
<span class="w"> </span>&quot;&quot;&quot; Experimental module for subtitles support. &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>from moviepy.tools import cvsecs
<span class="w"> </span>from moviepy.video.VideoClip import TextClip, VideoClip

<span class="gu">@@ -32,70 +35,108 @@ class SubtitlesClip(VideoClip):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, subtitles, make_textclip=None):
<span class="gi">+        </span>
<span class="w"> </span>        VideoClip.__init__(self, has_constant_size=False)
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(subtitles, str):
<span class="w"> </span>            subtitles = file_to_subtitles(subtitles)
<span class="gi">+</span>
<span class="gi">+        #subtitles = [(map(cvsecs, tt),txt) for tt, txt in subtitles]</span>
<span class="w"> </span>        self.subtitles = subtitles
<span class="w"> </span>        self.textclips = dict()
<span class="gi">+</span>
<span class="w"> </span>        if make_textclip is None:
<span class="w"> </span>            make_textclip = lambda txt: TextClip(txt, font=&#39;Georgia-Bold&#39;,
<span class="gd">-                fontsize=24, color=&#39;white&#39;, stroke_color=&#39;black&#39;,</span>
<span class="gd">-                stroke_width=0.5)</span>
<span class="gd">-        self.make_textclip = make_textclip</span>
<span class="gd">-        self.start = 0</span>
<span class="gd">-        self.duration = max([tb for (ta, tb), txt in self.subtitles])</span>
<span class="gd">-        self.end = self.duration</span>
<span class="gi">+                                        fontsize=24, color=&#39;white&#39;,</span>
<span class="gi">+                                        stroke_color=&#39;black&#39;, stroke_width=0.5)</span>

<span class="gi">+        self.make_textclip = make_textclip</span>
<span class="gi">+        self.start=0</span>
<span class="gi">+        self.duration = max([tb for ((ta,tb), txt) in self.subtitles])</span>
<span class="gi">+        self.end=self.duration</span>
<span class="gi">+        </span>
<span class="w"> </span>        def add_textclip_if_none(t):
<span class="w"> </span>            &quot;&quot;&quot; Will generate a textclip if it hasn&#39;t been generated asked
<span class="w"> </span>            to generate it yet. If there is no subtitle to show at t, return
<span class="w"> </span>            false. &quot;&quot;&quot;
<span class="gd">-            sub = [((ta, tb), txt) for (ta, tb), txt in self.textclips.keys</span>
<span class="gd">-                () if ta &lt;= t &lt; tb]</span>
<span class="gi">+            sub =[((ta,tb),txt) for ((ta,tb),txt) in self.textclips.keys()</span>
<span class="gi">+                   if (ta&lt;=t&lt;tb)]</span>
<span class="w"> </span>            if not sub:
<span class="gd">-                sub = [((ta, tb), txt) for (ta, tb), txt in self.subtitles if</span>
<span class="gd">-                    ta &lt;= t &lt; tb]</span>
<span class="gi">+                sub = [((ta,tb),txt) for ((ta,tb),txt) in self.subtitles if</span>
<span class="gi">+                       (ta&lt;=t&lt;tb)]</span>
<span class="w"> </span>                if not sub:
<span class="w"> </span>                    return False
<span class="w"> </span>            sub = sub[0]
<span class="w"> </span>            if sub not in self.textclips.keys():
<span class="w"> </span>                self.textclips[sub] = self.make_textclip(sub[1])
<span class="gi">+</span>
<span class="w"> </span>            return sub

<span class="w"> </span>        def make_frame(t):
<span class="w"> </span>            sub = add_textclip_if_none(t)
<span class="gd">-            return self.textclips[sub].get_frame(t) if sub else np.array([[</span>
<span class="gd">-                [0, 0, 0]]])</span>
<span class="gi">+            return (self.textclips[sub].get_frame(t) if sub</span>
<span class="gi">+                    else np.array([[[0,0,0]]]))</span>

<span class="w"> </span>        def make_mask_frame(t):
<span class="w"> </span>            sub = add_textclip_if_none(t)
<span class="gd">-            return self.textclips[sub].mask.get_frame(t) if sub else np.array([</span>
<span class="gd">-                [0]])</span>
<span class="gi">+            return (self.textclips[sub].mask.get_frame(t) if sub</span>
<span class="gi">+                    else np.array([[0]]))</span>
<span class="gi">+        </span>
<span class="w"> </span>        self.make_frame = make_frame
<span class="w"> </span>        hasmask = bool(self.make_textclip(&#39;T&#39;).mask)
<span class="gd">-        self.mask = VideoClip(make_mask_frame, ismask=True</span>
<span class="gd">-            ) if hasmask else None</span>
<span class="gi">+        self.mask = VideoClip(make_mask_frame, ismask=True) if hasmask else None</span>

<span class="gd">-    def in_subclip(self, t_start=None, t_end=None):</span>
<span class="gi">+    def in_subclip(self, t_start= None, t_end= None):</span>
<span class="w"> </span>        &quot;&quot;&quot; Returns a sequence of [(t1,t2), txt] covering all the given subclip
<span class="w"> </span>        from t_start to t_end. The first and last times will be cropped so as
<span class="w"> </span>        to be exactly t_start and t_end if possible. &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def is_in_subclip(t1,t2):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return (t_start&lt;=t1&lt;t_end) or (t_start&lt; t2 &lt;=t_end)</span>
<span class="gi">+            except:</span>
<span class="gi">+                return False</span>
<span class="gi">+        def try_cropping(t1,t2):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return (max(t1, t_start), min(t2, t_end))</span>
<span class="gi">+            except:</span>
<span class="gi">+                return (t1, t2)</span>
<span class="gi">+        return [(try_cropping(t1,t2), txt) for ((t1,t2), txt) in self.subtitles</span>
<span class="gi">+                                               if is_in_subclip(t1,t2)]</span>
<span class="gi">+    </span>
<span class="gi">+</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        return iter(self.subtitles)
<span class="gi">+    </span>
<span class="gi">+</span>

<span class="w"> </span>    def __getitem__(self, k):
<span class="w"> </span>        return self.subtitles[k]

<span class="gi">+    </span>
<span class="gi">+</span>
<span class="w"> </span>    def __str__(self):

<span class="w"> </span>        def to_srt(sub_element):
<span class="w"> </span>            (ta, tb), txt = sub_element
<span class="w"> </span>            fta = cvsecs(ta)
<span class="w"> </span>            ftb = cvsecs(tb)
<span class="gd">-            return &#39;%s - %s\n%s&#39; % (fta, ftb, txt)</span>
<span class="gd">-        return &#39;\n\n&#39;.join(to_srt(s) for s in self.subtitles)</span>
<span class="gi">+            return &quot;%s - %s\n%s&quot;%(fta, ftb, txt)</span>
<span class="gi">+        </span>
<span class="gi">+        return &quot;\n\n&quot;.join(to_srt(s) for s in self.subtitles)</span>
<span class="gi">+    </span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def match_expr(self, expr):</span>
<span class="gi">+</span>
<span class="gi">+        return SubtitlesClip([e for e in self.subtitles</span>
<span class="gi">+                              if re.findall(expr, e[1]) != []])</span>
<span class="gi">+    </span>
<span class="gi">+</span>
<span class="gi">+    def write_srt(self, filename):</span>
<span class="gi">+        with open(filename, &#39;w+&#39;) as f:</span>
<span class="gi">+            f.write(str(self))</span>


<span class="w"> </span>def file_to_subtitles(filename):
<span class="gu">@@ -106,4 +147,17 @@ def file_to_subtitles(filename):</span>

<span class="w"> </span>    Only works for &#39;.srt&#39; format for the moment.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    times_texts = []</span>
<span class="gi">+    current_times = None</span>
<span class="gi">+    current_text = &quot;&quot;</span>
<span class="gi">+    with open(filename,&#39;r&#39;) as f:</span>
<span class="gi">+        for line in f:</span>
<span class="gi">+            times = re.findall(&quot;([0-9]*:[0-9]*:[0-9]*,[0-9]*)&quot;, line)</span>
<span class="gi">+            if times:</span>
<span class="gi">+                current_times = [cvsecs(t) for t in times]</span>
<span class="gi">+            elif line.strip() == &#39;&#39;:</span>
<span class="gi">+                times_texts.append((current_times, current_text.strip(&#39;\n&#39;)))</span>
<span class="gi">+                current_times, current_text = None, &quot;&quot;</span>
<span class="gi">+            elif current_times:</span>
<span class="gi">+                current_text += line</span>
<span class="gi">+    return times_texts</span>
<span class="gh">diff --git a/moviepy/video/tools/tracking.py b/moviepy/video/tools/tracking.py</span>
<span class="gh">index f52522c..fd5247f 100644</span>
<span class="gd">--- a/moviepy/video/tools/tracking.py</span>
<span class="gi">+++ b/moviepy/video/tools/tracking.py</span>
<span class="gu">@@ -7,21 +7,31 @@ time t is out of the time bounds of the tracking time interval</span>
<span class="w"> </span>fx and fy return the position of the object at the start or at the end
<span class="w"> </span>of the tracking time interval).
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="gi">+</span>
<span class="w"> </span>from moviepy.decorators import convert_to_seconds, use_clip_fps_by_default
<span class="gi">+</span>
<span class="w"> </span>from ..io.preview import imdisplay
<span class="w"> </span>from .interpolators import Trajectory
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import cv2
<span class="w"> </span>    autotracking_possible = True
<span class="w"> </span>except:
<span class="gi">+    # Note: this will be later fixed with scipy/skimage replacements</span>
<span class="gi">+    # but for the moment OpenCV is mandatory, so...</span>
<span class="w"> </span>    autotracking_possible = False


<span class="gd">-@convert_to_seconds([&#39;t1&#39;, &#39;t2&#39;])</span>
<span class="gi">+# WE START WITH A TOOL FUNCTION</span>
<span class="gi">+</span>
<span class="gi">+# MANUAL TRACKING</span>
<span class="gi">+</span>
<span class="gi">+@convert_to_seconds([&quot;t1&quot;,&quot;t2&quot;])</span>
<span class="w"> </span>@use_clip_fps_by_default
<span class="gd">-def manual_tracking(clip, t1=None, t2=None, fps=None, nobjects=1, savefile=None</span>
<span class="gd">-    ):</span>
<span class="gi">+def manual_tracking(clip, t1=None, t2=None, fps=None, nobjects = 1,</span>
<span class="gi">+                    savefile = None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Allows manual tracking of an object(s) in the video clip between
<span class="w"> </span>    times `t1` and `t2`. This displays the clip frame by frame
<span class="gu">@@ -66,17 +76,81 @@ def manual_tracking(clip, t1=None, t2=None, fps=None, nobjects=1, savefile=None</span>
<span class="w"> </span>    &gt;&gt;&gt; traj, =  Trajectory.load_list(&#39;track.txt&#39;)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    import pygame as pg</span>
<span class="gi">+</span>
<span class="gi">+    screen = pg.display.set_mode(clip.size)</span>
<span class="gi">+    step = 1.0 / fps</span>
<span class="gi">+    if (t1 is None) and (t2 is None):</span>
<span class="gi">+        t1,t2 = 0, clip.duration</span>
<span class="gi">+    elif (t2 is None):</span>
<span class="gi">+        t2 = t1 + step / 2</span>
<span class="gi">+    t = t1</span>
<span class="gi">+    txy_list = []</span>
<span class="gi">+    </span>
<span class="gi">+    def gatherClicks(t):</span>
<span class="gi">+        </span>
<span class="gi">+        imdisplay(clip.get_frame(t), screen)</span>
<span class="gi">+        objects_to_click = nobjects</span>
<span class="gi">+        clicks = []</span>
<span class="gi">+        while objects_to_click:</span>
<span class="gi">+</span>
<span class="gi">+            for event in pg.event.get():</span>
<span class="gi">+</span>
<span class="gi">+                if event.type == pg.KEYDOWN:</span>
<span class="gi">+                    if (event.key == pg.K_BACKSLASH):</span>
<span class="gi">+                        return &quot;return&quot;</span>
<span class="gi">+                    elif (event.key == pg.K_ESCAPE):</span>
<span class="gi">+                        raise KeyboardInterrupt()</span>
<span class="gi">+                        </span>
<span class="gi">+</span>
<span class="gi">+                elif event.type == pg.MOUSEBUTTONDOWN:</span>
<span class="gi">+                    x, y = pg.mouse.get_pos()</span>
<span class="gi">+                    clicks.append((x, y))</span>
<span class="gi">+                    objects_to_click -= 1</span>
<span class="gi">+                    </span>
<span class="gi">+        return clicks</span>
<span class="gi">+        </span>
<span class="gi">+    while t &lt; t2:</span>
<span class="gi">+        </span>
<span class="gi">+        clicks  =gatherClicks(t)</span>
<span class="gi">+        if clicks == &#39;return&#39;:</span>
<span class="gi">+            txy_list.pop()</span>
<span class="gi">+            t -= step</span>
<span class="gi">+        else:</span>
<span class="gi">+            txy_list.append((t,clicks))</span>
<span class="gi">+            t += step</span>

<span class="gi">+    tt, xylist = zip(*txy_list) </span>
<span class="gi">+    result = []</span>
<span class="gi">+    for i in range(nobjects):</span>
<span class="gi">+        xys = [e[i] for e in xylist]</span>
<span class="gi">+        xx, yy = zip(*xys)</span>
<span class="gi">+        result.append(Trajectory(tt, xx, yy))</span>
<span class="gi">+    </span>
<span class="gi">+    if savefile is not None:</span>
<span class="gi">+        Trajectory.save_list(result, savefile)</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# AUTOMATED TRACKING OF A PATTERN</span>

<span class="gd">-def findAround(pic, pat, xy=None, r=None):</span>
<span class="gi">+def findAround(pic,pat,xy=None,r=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    find image pattern ``pat`` in ``pic[x +/- r, y +/- r]``.
<span class="w"> </span>    if xy is none, consider the whole picture.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    </span>
<span class="gi">+    if xy and r:</span>
<span class="gi">+        h,w = pat.shape[:2]</span>
<span class="gi">+        x,y = xy</span>
<span class="gi">+        pic = pic[y-r : y+h+r , x-r : x+w+r]</span>
<span class="gi">+        </span>
<span class="gi">+    matches = cv2.matchTemplate(pat,pic,cv2.TM_CCOEFF_NORMED)</span>
<span class="gi">+    yf,xf = np.unravel_index(matches.argmax(),matches.shape)</span>
<span class="gi">+    return (x-r+xf,y-r+yf) if (xy and r) else (xf,yf)</span>
<span class="gi">+        </span>
<span class="gi">+        </span>
<span class="w"> </span>def autoTrack(clip, pattern, tt=None, fps=None, radius=20, xy0=None):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Tracks a given pattern (small image array) in a video clip.
<span class="gu">@@ -90,4 +164,23 @@ def autoTrack(clip, pattern, tt=None, fps=None, radius=20, xy0=None):</span>
<span class="w"> </span>    to -1 the pattern will be searched in the whole screen at each frame).
<span class="w"> </span>    You can also provide the original position of the pattern with xy0.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if not autotracking_possible:</span>
<span class="gi">+        raise IOError(&quot;Sorry, autotrack requires OpenCV for the moment. &quot;</span>
<span class="gi">+                      &quot;Install OpenCV (aka cv2) to use it.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    if not xy0:</span>
<span class="gi">+        xy0 = findAround(clip.get_frame(tt[0]),pattern)</span>
<span class="gi">+    </span>
<span class="gi">+    if tt is None:</span>
<span class="gi">+        tt = np.arange(0, clip.duration, 1.0/fps)</span>
<span class="gi">+        </span>
<span class="gi">+    xys = [xy0]</span>
<span class="gi">+    for t in tt[1:]:</span>
<span class="gi">+        xys.append( findAround(clip.get_frame(t),pattern,</span>
<span class="gi">+                               xy=xys[-1],r=radius))</span>
<span class="gi">+    </span>
<span class="gi">+    xx,yy = zip(*xys)</span>
<span class="gi">+</span>
<span class="gi">+    return Trajectory(tt, xx, yy)</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>