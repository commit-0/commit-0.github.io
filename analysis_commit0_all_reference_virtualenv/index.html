
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference virtualenv - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-virtualenv" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference virtualenv
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_cshpytest_cshno_prompt" class="md-nav__link">
    <span class="md-ellipsis">
      test_csh.py::test_csh[no_prompt]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_nushellpytest_nushellno_prompt" class="md-nav__link">
    <span class="md-ellipsis">
      test_nushell.py::test_nushell[no_prompt]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fishpytest_fishno_prompt" class="md-nav__link">
    <span class="md-ellipsis">
      test_fish.py::test_fish[no_prompt]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_python_activatorpytest_pythonno_prompt" class="md-nav__link">
    <span class="md-ellipsis">
      test_python_activator.py::test_python[no_prompt]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_bashpytest_bashno_prompt-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_bash.py::test_bash[no_prompt-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_bashpytest_bashno_prompt-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_bash.py::test_bash[no_prompt-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_cshpytest_cshwith_prompt" class="md-nav__link">
    <span class="md-ellipsis">
      test_csh.py::test_csh[with_prompt]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_nushellpytest_nushellwith_prompt" class="md-nav__link">
    <span class="md-ellipsis">
      test_nushell.py::test_nushell[with_prompt]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fishpytest_fishwith_prompt" class="md-nav__link">
    <span class="md-ellipsis">
      test_fish.py::test_fish[with_prompt]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_python_activatorpytest_pythonwith_prompt" class="md-nav__link">
    <span class="md-ellipsis">
      test_python_activator.py::test_python[with_prompt]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_bashpytest_bashwith_prompt-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_bash.py::test_bash[with_prompt-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_bashpytest_bashwith_prompt-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_bash.py::test_bash[with_prompt-False]
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-virtualenv"><strong>Reference (Gold)</strong>: virtualenv</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">296</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">24</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">12</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">332</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">332</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_cshpytest_cshno_prompt">test_csh.py::test_csh[no_prompt]</h3>
<details><summary> <pre>test_csh.py::test_csh[no_prompt]</pre></summary><pre>
activation_tester_class = <class 'conftest.ActivationTester'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064db8b370>

    def test_csh(activation_tester_class, activation_tester):
        class Csh(activation_tester_class):
            def __init__(self, session) -> None:
                super().__init__(CShellActivator, session, "csh", "activate.csh", "csh")

            def print_prompt(self):
                # Original csh doesn't print the last newline,
                # breaking the test; hence the trailing echo.
                return "echo 'source \"$VIRTUAL_ENV/bin/activate.csh\"; echo $prompt' | csh -i ; echo"

>       activation_tester(Csh)

Csh        = <class 'test_csh.test_csh.<locals>.Csh'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064db8b370>
activation_tester_class = <class 'conftest.ActivationTester'>

/testbed/tests/unit/activation/test_csh.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/unit/activation/conftest.py:253: in _tester
    return tester(monkeypatch, tmp_path)
        activation_python = <virtualenv.run.session.Session object at 0x7f064f52fe80>
        is_inside_ci = False
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f52d7b0>
        tester     = Csh(
version='# exit\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tester_class = <class 'test_csh.test_csh.<locals>.Csh'>
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_csh_no_prompt_0')
        version    = '# exit\n'
/testbed/tests/unit/activation/conftest.py:89: in __call__
    self.assert_output(out, raw, tmp_path)
        _          = None
        activate_script = PosixPath('/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/activate.csh')
        env        = {'BLIS_NUM_THREADS': '1', 'CFLAGS': '-g0', 'HOME': '/root', 'LC_CTYPE': 'C.UTF-8', ...}
        invoke     = ['csh', '/tmp/pytest-of-root/pytest-0/test_csh_no_prompt_0/script.csh']
        line       = b'rehash'
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f52d7b0>
        out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
        process    = <Popen: returncode: 0 args: ['csh', '/tmp/pytest-of-root/pytest-0/test_csh_n...>
        raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/pyth...s shell.\n# (e-$ èрт🚒♞中片-j) #\n(e-$ èрт🚒♞中片-j) # exit\nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
        raw_       = b'/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ \xc3\xa8\xd1\x80\...x9a\x92\xe2\x99\x9e\xe4\xb8\xad\xe7\x89\x87-j) # exit\nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
        script_content = b'# This file must be used with "source bin/activate.csh" *from csh*.\n# You cannot run it directly.\n# Created by Dav...ompt:q"\n        endif\n    endif\nendif\n\nunset env_name\nunset do_prompt\n\nalias pydoc python -m pydoc\n\nrehash\n'
        self       = Csh(
version='# exit\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        test_script = PosixPath('/tmp/pytest-of-root/pytest-0/test_csh_no_prompt_0/script.csh')
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_csh_no_prompt_0')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Csh(
version='# exit\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
out = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/pyth...s shell.\n# (e-$ èрт🚒♞中片-j) #\n(e-$ èрт🚒♞中片-j) # exit\nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_csh_no_prompt_0')

    def assert_output(self, out, raw, tmp_path):
        # pre-activation
        assert out[0], raw
        assert out[1] == "None", raw
>       assert out[2] == "None", raw
E       AssertionError: /testbed/.venv/bin/python3
E         None
E         testbed
E         /tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3
E         /tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j
E         e-$ èрт🚒♞中片-j
E         Warning: no access to tty (Bad file descriptor).
E         Thus no job control in this shell.
E         # (e-$ èрт🚒♞中片-j) #
E         (e-$ èрт🚒♞中片-j) # exit
E         wrote pydoc_test.html
E         /testbed/.venv/bin/python3
E         None
E         None
E         
E       assert 'testbed' == 'None'
E         
E         - None
E         + testbed

out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/pyth...s shell.\n# (e-$ èрт🚒♞中片-j) #\n(e-$ èрт🚒♞中片-j) # exit\nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
self       = Csh(
version='# exit\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_csh_no_prompt_0')

/testbed/tests/unit/activation/conftest.py:137: AssertionError
</pre>
</details>
<h3 id="test_nushellpytest_nushellno_prompt">test_nushell.py::test_nushell[no_prompt]</h3>
<details><summary> <pre>test_nushell.py::test_nushell[no_prompt]</pre></summary><pre>
activation_tester_class = <class 'conftest.ActivationTester'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064db8be20>

    def test_nushell(activation_tester_class, activation_tester):
        class Nushell(activation_tester_class):
            def __init__(self, session) -> None:
                cmd = which("nu")
                if cmd is None and IS_WIN:
                    cmd = "c:\\program files\\nu\\bin\\nu.exe"

                super().__init__(NushellActivator, session, cmd, "activate.nu", "nu")

                self.activate_cmd = "overlay use"
                self.unix_line_ending = not IS_WIN

            def print_prompt(self):
                return r"print $env.VIRTUAL_PREFIX"

            def activate_call(self, script):
                # Commands are called without quotes in Nushell
                cmd = self.activate_cmd
                scr = self.quote(str(script))
                return f"{cmd} {scr}".strip()

>       activation_tester(Nushell)

Nushell    = <class 'test_nushell.test_nushell.<locals>.Nushell'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064db8be20>
activation_tester_class = <class 'conftest.ActivationTester'>

/testbed/tests/unit/activation/test_nushell.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/unit/activation/conftest.py:253: in _tester
    return tester(monkeypatch, tmp_path)
        activation_python = <virtualenv.run.session.Session object at 0x7f064f52fe80>
        is_inside_ci = False
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f4e1840>
        tester     = Nushell(
version='0.98.0\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tester_class = <class 'test_nushell.test_nushell.<locals>.Nushell'>
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_nushell_no_prompt_0')
        version    = '0.98.0\n'
/testbed/tests/unit/activation/conftest.py:89: in __call__
    self.assert_output(out, raw, tmp_path)
        _          = None
        activate_script = PosixPath('/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/activate.nu')
        env        = {'BLIS_NUM_THREADS': '1', 'CFLAGS': '-g0', 'HOME': '/root', 'LC_CTYPE': 'C.UTF-8', ...}
        invoke     = ['/root/.cargo/bin/nu', '/tmp/pytest-of-root/pytest-0/test_nushell_no_prompt_0/script.nu']
        line       = b'export alias deactivate = overlay hide activate'
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f4e1840>
        out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
        process    = <Popen: returncode: 0 args: ['/root/.cargo/bin/nu', '/tmp/pytest-of-root/pyt...>
        raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/pyth...nv0/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\ntestbed\n'
        raw_       = b'/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ \xc3\xa8\xd1\x80\...9f\x9a\x92\xe2\x99\x9e\xe4\xb8\xad\xe7\x89\x87-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\ntestbed\n'
        script_content = b'# virtualenv activation module\n# Activate with `overlay use activate.nu`\n# Deactivate with `deactivate`, as usual\...v\n    load-env $new_env\n}\n\nexport alias pydoc = python -m pydoc\nexport alias deactivate = overlay hide activate\n'
        self       = Nushell(
version='0.98.0\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        test_script = PosixPath('/tmp/pytest-of-root/pytest-0/test_nushell_no_prompt_0/script.nu')
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_nushell_no_prompt_0')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Nushell(
version='0.98.0\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
out = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/pyth...nv0/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\ntestbed\n'
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_nushell_no_prompt_0')

    def assert_output(self, out, raw, tmp_path):
        # pre-activation
        assert out[0], raw
        assert out[1] == "None", raw
>       assert out[2] == "None", raw
E       AssertionError: /testbed/.venv/bin/python3
E         None
E         testbed
E         /tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3
E         /tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j
E         e-$ èрт🚒♞中片-j
E         (e-$ èрт🚒♞中片-j) 
E         wrote pydoc_test.html
E         /testbed/.venv/bin/python3
E         None
E         testbed
E         
E       assert 'testbed' == 'None'
E         
E         - None
E         + testbed

out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/pyth...nv0/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\ntestbed\n'
self       = Nushell(
version='0.98.0\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_nushell_no_prompt_0')

/testbed/tests/unit/activation/conftest.py:137: AssertionError
</pre>
</details>
<h3 id="test_fishpytest_fishno_prompt">test_fish.py::test_fish[no_prompt]</h3>
<details><summary> <pre>test_fish.py::test_fish[no_prompt]</pre></summary><pre>
activation_tester_class = <class 'conftest.ActivationTester'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064db89870>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f768880>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_fish_no_prompt_0')

    @pytest.mark.skipif(IS_WIN, reason="we have not setup fish in CI yet")
    def test_fish(activation_tester_class, activation_tester, monkeypatch, tmp_path):
        monkeypatch.setenv("HOME", str(tmp_path))
        fish_conf_dir = tmp_path / ".config" / "fish"
        fish_conf_dir.mkdir(parents=True)
        (fish_conf_dir / "config.fish").write_text("", encoding="utf-8")

        class Fish(activation_tester_class):
            def __init__(self, session) -> None:
                super().__init__(FishActivator, session, "fish", "activate.fish", "fish")

            def print_prompt(self):
                return "fish_prompt"

>       activation_tester(Fish)

Fish       = <class 'test_fish.test_fish.<locals>.Fish'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064db89870>
activation_tester_class = <class 'conftest.ActivationTester'>
fish_conf_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_fish_no_prompt_0/.config/fish')
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f768880>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_fish_no_prompt_0')

/testbed/tests/unit/activation/test_fish.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/unit/activation/conftest.py:253: in _tester
    return tester(monkeypatch, tmp_path)
        activation_python = <virtualenv.run.session.Session object at 0x7f064f52fe80>
        is_inside_ci = False
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f768880>
        tester     = Fish(
version='fish, version 3.3.1\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tester_class = <class 'test_fish.test_fish.<locals>.Fish'>
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_fish_no_prompt_0')
        version    = 'fish, version 3.3.1\n'
/testbed/tests/unit/activation/conftest.py:89: in __call__
    self.assert_output(out, raw, tmp_path)
        _          = None
        activate_script = PosixPath('/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/activate.fish')
        env        = {'BLIS_NUM_THREADS': '1', 'CFLAGS': '-g0', 'HOME': '/tmp/pytest-of-root/pytest-0/test_fish_no_prompt_0', 'LC_CTYPE': 'C.UTF-8', ...}
        invoke     = ['fish', '/tmp/pytest-of-root/pytest-0/test_fish_no_prompt_0/script.fish']
        line       = b'end'
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f768880>
        out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
        process    = <Popen: returncode: 0 args: ['fish', '/tmp/pytest-of-root/pytest-0/test_fish...>
        raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/pyth...B\x1b[m@modal\x1b(B\x1b[m ~\x1b(B\x1b[m\x1b(B\x1b[m# \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
        raw_       = b'/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ \xc3\xa8\xd1\x80\...B\x1b[m@modal\x1b(B\x1b[m ~\x1b(B\x1b[m\x1b(B\x1b[m# \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
        script_content = b'# This file must be used using `source bin/activate.fish` *within a running fish ( http://fishshell.com ) session*.\...oin -- \\n $prompt # handle multi-line prompts\n    end\n\n    set -gx _OLD_FISH_PROMPT_OVERRIDE "$VIRTUAL_ENV"\nend\n'
        self       = Fish(
version='fish, version 3.3.1\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        test_script = PosixPath('/tmp/pytest-of-root/pytest-0/test_fish_no_prompt_0/script.fish')
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_fish_no_prompt_0')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Fish(
version='fish, version 3.3.1\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
out = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/pyth...B\x1b[m@modal\x1b(B\x1b[m ~\x1b(B\x1b[m\x1b(B\x1b[m# \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_fish_no_prompt_0')

    def assert_output(self, out, raw, tmp_path):
        # pre-activation
        assert out[0], raw
        assert out[1] == "None", raw
>       assert out[2] == "None", raw
E       AssertionError: /testbed/.venv/bin/python3
E         None
E         testbed
E         /tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3
E         /tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j
E         e-$ èрт🚒♞中片-j
E         (e-$ èрт🚒♞中片-j) root(B[m@modal(B[m ~(B[m(B[m# 
E         wrote pydoc_test.html
E         /testbed/.venv/bin/python3
E         None
E         None
E         
E       assert 'testbed' == 'None'
E         
E         - None
E         + testbed

out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/pyth...B\x1b[m@modal\x1b(B\x1b[m ~\x1b(B\x1b[m\x1b(B\x1b[m# \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
self       = Fish(
version='fish, version 3.3.1\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_fish_no_prompt_0')

/testbed/tests/unit/activation/conftest.py:137: AssertionError
</pre>
</details>
<h3 id="test_python_activatorpytest_pythonno_prompt">test_python_activator.py::test_python[no_prompt]</h3>
<details><summary> <pre>test_python_activator.py::test_python[no_prompt]</pre></summary><pre>
raise_on_non_source_class = <class 'conftest.RaiseOnNonSourceCall'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dbf8a60>

    def test_python(raise_on_non_source_class, activation_tester):
        class Python(raise_on_non_source_class):
            def __init__(self, session) -> None:
                super().__init__(
                    PythonActivator,
                    session,
                    sys.executable,
                    activate_script="activate_this.py",
                    extension="py",
                    non_source_fail_message="You must use import runpy; runpy.run_path(this_file)",
                )
                self.unix_line_ending = not IS_WIN

            def env(self, tmp_path):
                env = os.environ.copy()
                env["PYTHONIOENCODING"] = "utf-8"
                for key in ("VIRTUAL_ENV", "PYTHONPATH"):
                    env.pop(str(key), None)
                env["PATH"] = os.pathsep.join([str(tmp_path), str(tmp_path / "other")])
                return env

            @staticmethod
            def _get_test_lines(activate_script):
                raw = f"""
                import os
                import sys
                import platform
                import runpy

                def print_r(value):
                    print(repr(value))

                print_r(os.environ.get("VIRTUAL_ENV"))
                print_r(os.environ.get("VIRTUAL_ENV_PROMPT"))
                print_r(os.environ.get("PATH").split(os.pathsep))
                print_r(sys.path)

                file_at = {str(activate_script)!r}
                # CPython 2 requires non-ascii path open to be unicode
                runpy.run_path(file_at)
                print_r(os.environ.get("VIRTUAL_ENV"))
                print_r(os.environ.get("VIRTUAL_ENV_PROMPT"))
                print_r(os.environ.get("PATH").split(os.pathsep))
                print_r(sys.path)

                import pydoc_test
                print_r(pydoc_test.__file__)
                """
                return dedent(raw).splitlines()

            def assert_output(self, out, raw, tmp_path):  # noqa: ARG002
                out = [literal_eval(i) for i in out]
                assert out[0] is None  # start with VIRTUAL_ENV None
                assert out[1] is None  # likewise for VIRTUAL_ENV_PROMPT

                prev_path = out[2]
                prev_sys_path = out[3]
                assert out[4] == str(self._creator.dest)  # VIRTUAL_ENV now points to the virtual env folder

                assert out[5] == str(self._creator.env_name)  # VIRTUAL_ENV_PROMPT now has the env name

                new_path = out[6]  # PATH now starts with bin path of current
                assert ([str(self._creator.bin_dir), *prev_path]) == new_path

                # sys path contains the site package at its start
                new_sys_path = out[7]

                new_lib_paths = {str(i) for i in self._creator.libs}
                assert prev_sys_path == new_sys_path[len(new_lib_paths) :]
                assert new_lib_paths == set(new_sys_path[: len(new_lib_paths)])

                # manage to import from activate site package
                dest = self.norm_path(self._creator.purelib / "pydoc_test.py")
                found = self.norm_path(out[8])
                assert found.startswith(dest)

            def non_source_activate(self, activate_script):
                act = str(activate_script)
                return [*self._invoke_script, "-c", f"exec(open({act!r}).read())"]

>       activation_tester(Python)

Python     = <class 'test_python_activator.test_python.<locals>.Python'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dbf8a60>
raise_on_non_source_class = <class 'conftest.RaiseOnNonSourceCall'>

/testbed/tests/unit/activation/test_python_activator.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/unit/activation/conftest.py:253: in _tester
    return tester(monkeypatch, tmp_path)
        activation_python = <virtualenv.run.session.Session object at 0x7f064f52fe80>
        is_inside_ci = False
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f4e1270>
        tester     = Python(
version='Python 3.10.12\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tester_class = <class 'test_python_activator.test_python.<locals>.Python'>
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_python_no_prompt_0')
        version    = 'Python 3.10.12\n'
/testbed/tests/unit/activation/conftest.py:209: in __call__
    env, activate_script = super().__call__(monkeypatch, tmp_path)
        __class__  = <class 'conftest.RaiseOnNonSourceCall'>
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f4e1270>
        self       = Python(
version='Python 3.10.12\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_python_no_prompt_0')
/testbed/tests/unit/activation/conftest.py:89: in __call__
    self.assert_output(out, raw, tmp_path)
        _          = None
        activate_script = PosixPath('/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/activate_this.py')
        env        = {'BLIS_NUM_THREADS': '1', 'CFLAGS': '-g0', 'HOME': '/root', 'LC_CTYPE': 'C.UTF-8', ...}
        invoke     = ['/testbed/.venv/bin/python3', '/tmp/pytest-of-root/pytest-0/test_python_no_prompt_0/script.py']
        line       = b'sys.prefix = base'
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f4e1270>
        out        = ['None', "'testbed'", "['/tmp/pytest-of-root/pytest-0/test_python_no_prompt_0', '/tmp/pytest-of-root/pytest-0/test_pyt...ages', '/testbed/src']", "'/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j'", "'e-$ èрт🚒♞中片-j'", ...]
        process    = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', '/tmp/pytest-of-r...>
        raw        = "None\n'testbed'\n['/tmp/pytest-of-root/pytest-0/test_python_no_prompt_0', '/tmp/pytest-of-root/pytest-0/test_python_n...rc']\n'/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/lib/python3.10/site-packages/pydoc_test.py'\n"
        raw_       = b"None\n'testbed'\n['/tmp/pytest-of-root/pytest-0/test_python_no_prompt_0', '/tmp/pytest-of-root/pytest-0/test_python_...a8\xd1\x80\xd1\x82\xf0\x9f\x9a\x92\xe2\x99\x9e\xe4\xb8\xad\xe7\x89\x87-j/lib/python3.10/site-packages/pydoc_test.py'\n"
        script_content = b'"""\nActivate virtualenv for current interpreter:\n\nimport runpy\nrunpy.run_path(this_file)\n\nThis can be used whe...)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\n\nsys.real_prefix = sys.prefix\nsys.prefix = base\n'
        self       = Python(
version='Python 3.10.12\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        test_script = PosixPath('/tmp/pytest-of-root/pytest-0/test_python_no_prompt_0/script.py')
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_python_no_prompt_0')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Python(
version='Python 3.10.12\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
out = [None, 'testbed', ['/tmp/pytest-of-root/pytest-0/test_python_no_prompt_0', '/tmp/pytest-of-root/pytest-0/test_python_n...-packages', '/testbed/src'], '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw = "None\n'testbed'\n['/tmp/pytest-of-root/pytest-0/test_python_no_prompt_0', '/tmp/pytest-of-root/pytest-0/test_python_n...rc']\n'/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/lib/python3.10/site-packages/pydoc_test.py'\n"
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_python_no_prompt_0')

    def assert_output(self, out, raw, tmp_path):  # noqa: ARG002
        out = [literal_eval(i) for i in out]
        assert out[0] is None  # start with VIRTUAL_ENV None
>       assert out[1] is None  # likewise for VIRTUAL_ENV_PROMPT
E       AssertionError: assert 'testbed' is None

out        = [None, 'testbed', ['/tmp/pytest-of-root/pytest-0/test_python_no_prompt_0', '/tmp/pytest-of-root/pytest-0/test_python_n...-packages', '/testbed/src'], '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw        = "None\n'testbed'\n['/tmp/pytest-of-root/pytest-0/test_python_no_prompt_0', '/tmp/pytest-of-root/pytest-0/test_python_n...rc']\n'/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/lib/python3.10/site-packages/pydoc_test.py'\n"
self       = Python(
version='Python 3.10.12\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_python_no_prompt_0')

/testbed/tests/unit/activation/test_python_activator.py:65: AssertionError
</pre>
</details>
<h3 id="test_bashpytest_bashno_prompt-false">test_bash.py::test_bash[no_prompt-False]</h3>
<details><summary> <pre>test_bash.py::test_bash[no_prompt-False]</pre></summary><pre>
raise_on_non_source_class = <class 'conftest.RaiseOnNonSourceCall'>
hashing_enabled = False
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dbf8700>

    @pytest.mark.skipif(IS_WIN, reason="Github Actions ships with WSL bash")
    @pytest.mark.parametrize("hashing_enabled", [True, False])
    def test_bash(raise_on_non_source_class, hashing_enabled, activation_tester):
        class Bash(raise_on_non_source_class):
            def __init__(self, session) -> None:
                super().__init__(
                    BashActivator,
                    session,
                    "bash",
                    "activate",
                    "sh",
                    "You must source this script: $ source ",
                )
                self.deactivate += " || exit 1"
                self._invoke_script.append("-h" if hashing_enabled else "+h")

            def activate_call(self, script):
                return super().activate_call(script) + " || exit 1"

            def print_prompt(self):
                return self.print_os_env_var("PS1")

>       activation_tester(Bash)

Bash       = <class 'test_bash.test_bash.<locals>.Bash'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dbf8700>
hashing_enabled = False
raise_on_non_source_class = <class 'conftest.RaiseOnNonSourceCall'>

/testbed/tests/unit/activation/test_bash.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/unit/activation/conftest.py:253: in _tester
    return tester(monkeypatch, tmp_path)
        activation_python = <virtualenv.run.session.Session object at 0x7f064f52fe80>
        is_inside_ci = False
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f768e20>
        tester     = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tester_class = <class 'test_bash.test_bash.<locals>.Bash'>
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_no_prompt_False_0')
        version    = 'GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation, Inc.\nLicense...is free software; you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n'
/testbed/tests/unit/activation/conftest.py:209: in __call__
    env, activate_script = super().__call__(monkeypatch, tmp_path)
        __class__  = <class 'conftest.RaiseOnNonSourceCall'>
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f768e20>
        self       = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_no_prompt_False_0')
/testbed/tests/unit/activation/conftest.py:89: in __call__
    self.assert_output(out, raw, tmp_path)
        _          = None
        activate_script = PosixPath('/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/activate')
        env        = {'BLIS_NUM_THREADS': '1', 'CFLAGS': '-g0', 'HOME': '/root', 'LC_CTYPE': 'C.UTF-8', ...}
        invoke     = ['bash', '+h', '/tmp/pytest-of-root/pytest-0/test_bash_no_prompt_False_0/script.sh']
        line       = b'hash -r 2>/dev/null || true'
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f768e20>
        out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
        process    = <Popen: returncode: 0 args: ['bash', '+h', '/tmp/pytest-of-root/pytest-0/tes...>
        raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/pyth...r-env0/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
        raw_       = b'/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ \xc3\xa8\xd1\x80\...0\x9f\x9a\x92\xe2\x99\x9e\xe4\xb8\xad\xe7\x89\x87-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
        script_content = b'# This file must be used with "source bin/activate" *from bash*\n# you cannot run it directly\n\n\nif [ "${BASH_SOUR...nds. Without forgetting past commands the $PATH changes\n# we made may not be respected\nhash -r 2>/dev/null || true\n'
        self       = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        test_script = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_no_prompt_False_0/script.sh')
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_no_prompt_False_0')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
out = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/pyth...r-env0/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_no_prompt_False_0')

    def assert_output(self, out, raw, tmp_path):
        # pre-activation
        assert out[0], raw
        assert out[1] == "None", raw
>       assert out[2] == "None", raw
E       AssertionError: /testbed/.venv/bin/python3
E         None
E         testbed
E         /tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3
E         /tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j
E         e-$ èрт🚒♞中片-j
E         (e-$ èрт🚒♞中片-j) 
E         wrote pydoc_test.html
E         /testbed/.venv/bin/python3
E         None
E         None
E         
E       assert 'testbed' == 'None'
E         
E         - None
E         + testbed

out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/pyth...r-env0/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
self       = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_no_prompt_False_0')

/testbed/tests/unit/activation/conftest.py:137: AssertionError
</pre>
</details>
<h3 id="test_bashpytest_bashno_prompt-true">test_bash.py::test_bash[no_prompt-True]</h3>
<details><summary> <pre>test_bash.py::test_bash[no_prompt-True]</pre></summary><pre>
raise_on_non_source_class = <class 'conftest.RaiseOnNonSourceCall'>
hashing_enabled = True
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dbf9990>

    @pytest.mark.skipif(IS_WIN, reason="Github Actions ships with WSL bash")
    @pytest.mark.parametrize("hashing_enabled", [True, False])
    def test_bash(raise_on_non_source_class, hashing_enabled, activation_tester):
        class Bash(raise_on_non_source_class):
            def __init__(self, session) -> None:
                super().__init__(
                    BashActivator,
                    session,
                    "bash",
                    "activate",
                    "sh",
                    "You must source this script: $ source ",
                )
                self.deactivate += " || exit 1"
                self._invoke_script.append("-h" if hashing_enabled else "+h")

            def activate_call(self, script):
                return super().activate_call(script) + " || exit 1"

            def print_prompt(self):
                return self.print_os_env_var("PS1")

>       activation_tester(Bash)

Bash       = <class 'test_bash.test_bash.<locals>.Bash'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dbf9990>
hashing_enabled = True
raise_on_non_source_class = <class 'conftest.RaiseOnNonSourceCall'>

/testbed/tests/unit/activation/test_bash.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/unit/activation/conftest.py:253: in _tester
    return tester(monkeypatch, tmp_path)
        activation_python = <virtualenv.run.session.Session object at 0x7f064f52fe80>
        is_inside_ci = False
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f73efe0>
        tester     = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tester_class = <class 'test_bash.test_bash.<locals>.Bash'>
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_no_prompt_True_0')
        version    = 'GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation, Inc.\nLicense...is free software; you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n'
/testbed/tests/unit/activation/conftest.py:209: in __call__
    env, activate_script = super().__call__(monkeypatch, tmp_path)
        __class__  = <class 'conftest.RaiseOnNonSourceCall'>
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f73efe0>
        self       = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_no_prompt_True_0')
/testbed/tests/unit/activation/conftest.py:89: in __call__
    self.assert_output(out, raw, tmp_path)
        _          = None
        activate_script = PosixPath('/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/activate')
        env        = {'BLIS_NUM_THREADS': '1', 'CFLAGS': '-g0', 'HOME': '/root', 'LC_CTYPE': 'C.UTF-8', ...}
        invoke     = ['bash', '-h', '/tmp/pytest-of-root/pytest-0/test_bash_no_prompt_True_0/script.sh']
        line       = b'hash -r 2>/dev/null || true'
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f73efe0>
        out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
        process    = <Popen: returncode: 0 args: ['bash', '-h', '/tmp/pytest-of-root/pytest-0/tes...>
        raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/pyth...r-env0/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
        raw_       = b'/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ \xc3\xa8\xd1\x80\...0\x9f\x9a\x92\xe2\x99\x9e\xe4\xb8\xad\xe7\x89\x87-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
        script_content = b'# This file must be used with "source bin/activate" *from bash*\n# you cannot run it directly\n\n\nif [ "${BASH_SOUR...nds. Without forgetting past commands the $PATH changes\n# we made may not be respected\nhash -r 2>/dev/null || true\n'
        self       = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        test_script = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_no_prompt_True_0/script.sh')
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_no_prompt_True_0')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
out = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/pyth...r-env0/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_no_prompt_True_0')

    def assert_output(self, out, raw, tmp_path):
        # pre-activation
        assert out[0], raw
        assert out[1] == "None", raw
>       assert out[2] == "None", raw
E       AssertionError: /testbed/.venv/bin/python3
E         None
E         testbed
E         /tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3
E         /tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j
E         e-$ èрт🚒♞中片-j
E         (e-$ èрт🚒♞中片-j) 
E         wrote pydoc_test.html
E         /testbed/.venv/bin/python3
E         None
E         None
E         
E       assert 'testbed' == 'None'
E         
E         - None
E         + testbed

out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env0/e-$ èрт🚒♞中片-j/bin/pyth...r-env0/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
self       = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_no_prompt_True_0')

/testbed/tests/unit/activation/conftest.py:137: AssertionError
</pre>
</details>
<h3 id="test_cshpytest_cshwith_prompt">test_csh.py::test_csh[with_prompt]</h3>
<details><summary> <pre>test_csh.py::test_csh[with_prompt]</pre></summary><pre>
activation_tester_class = <class 'conftest.ActivationTester'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dbfa950>

    def test_csh(activation_tester_class, activation_tester):
        class Csh(activation_tester_class):
            def __init__(self, session) -> None:
                super().__init__(CShellActivator, session, "csh", "activate.csh", "csh")

            def print_prompt(self):
                # Original csh doesn't print the last newline,
                # breaking the test; hence the trailing echo.
                return "echo 'source \"$VIRTUAL_ENV/bin/activate.csh\"; echo $prompt' | csh -i ; echo"

>       activation_tester(Csh)

Csh        = <class 'test_csh.test_csh.<locals>.Csh'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dbfa950>
activation_tester_class = <class 'conftest.ActivationTester'>

/testbed/tests/unit/activation/test_csh.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/unit/activation/conftest.py:253: in _tester
    return tester(monkeypatch, tmp_path)
        activation_python = <virtualenv.run.session.Session object at 0x7f064f5b4190>
        is_inside_ci = False
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f5b7a60>
        tester     = Csh(
version='# exit\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tester_class = <class 'test_csh.test_csh.<locals>.Csh'>
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_csh_with_prompt_0')
        version    = '# exit\n'
/testbed/tests/unit/activation/conftest.py:89: in __call__
    self.assert_output(out, raw, tmp_path)
        _          = None
        activate_script = PosixPath('/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/activate.csh')
        env        = {'BLIS_NUM_THREADS': '1', 'CFLAGS': '-g0', 'HOME': '/root', 'LC_CTYPE': 'C.UTF-8', ...}
        invoke     = ['csh', '/tmp/pytest-of-root/pytest-0/test_csh_with_prompt_0/script.csh']
        line       = b'rehash'
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f5b7a60>
        out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
        process    = <Popen: returncode: 0 args: ['csh', '/tmp/pytest-of-root/pytest-0/test_csh_w...>
        raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/pyth...s shell.\n# (e-$ èрт🚒♞中片-j) #\n(e-$ èрт🚒♞中片-j) # exit\nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
        raw_       = b'/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ \xc3\xa8\xd1\x80\...x9a\x92\xe2\x99\x9e\xe4\xb8\xad\xe7\x89\x87-j) # exit\nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
        script_content = b'# This file must be used with "source bin/activate.csh" *from csh*.\n# You cannot run it directly.\n# Created by Dav...ompt:q"\n        endif\n    endif\nendif\n\nunset env_name\nunset do_prompt\n\nalias pydoc python -m pydoc\n\nrehash\n'
        self       = Csh(
version='# exit\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        test_script = PosixPath('/tmp/pytest-of-root/pytest-0/test_csh_with_prompt_0/script.csh')
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_csh_with_prompt_0')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Csh(
version='# exit\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
out = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/pyth...s shell.\n# (e-$ èрт🚒♞中片-j) #\n(e-$ èрт🚒♞中片-j) # exit\nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_csh_with_prompt_0')

    def assert_output(self, out, raw, tmp_path):
        # pre-activation
        assert out[0], raw
        assert out[1] == "None", raw
>       assert out[2] == "None", raw
E       AssertionError: /testbed/.venv/bin/python3
E         None
E         testbed
E         /tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3
E         /tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j
E         e-$ èрт🚒♞中片-j
E         Warning: no access to tty (Bad file descriptor).
E         Thus no job control in this shell.
E         # (e-$ èрт🚒♞中片-j) #
E         (e-$ èрт🚒♞中片-j) # exit
E         wrote pydoc_test.html
E         /testbed/.venv/bin/python3
E         None
E         None
E         
E       assert 'testbed' == 'None'
E         
E         - None
E         + testbed

out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/pyth...s shell.\n# (e-$ èрт🚒♞中片-j) #\n(e-$ èрт🚒♞中片-j) # exit\nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
self       = Csh(
version='# exit\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_csh_with_prompt_0')

/testbed/tests/unit/activation/conftest.py:137: AssertionError
</pre>
</details>
<h3 id="test_nushellpytest_nushellwith_prompt">test_nushell.py::test_nushell[with_prompt]</h3>
<details><summary> <pre>test_nushell.py::test_nushell[with_prompt]</pre></summary><pre>
activation_tester_class = <class 'conftest.ActivationTester'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dbfb0a0>

    def test_nushell(activation_tester_class, activation_tester):
        class Nushell(activation_tester_class):
            def __init__(self, session) -> None:
                cmd = which("nu")
                if cmd is None and IS_WIN:
                    cmd = "c:\\program files\\nu\\bin\\nu.exe"

                super().__init__(NushellActivator, session, cmd, "activate.nu", "nu")

                self.activate_cmd = "overlay use"
                self.unix_line_ending = not IS_WIN

            def print_prompt(self):
                return r"print $env.VIRTUAL_PREFIX"

            def activate_call(self, script):
                # Commands are called without quotes in Nushell
                cmd = self.activate_cmd
                scr = self.quote(str(script))
                return f"{cmd} {scr}".strip()

>       activation_tester(Nushell)

Nushell    = <class 'test_nushell.test_nushell.<locals>.Nushell'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dbfb0a0>
activation_tester_class = <class 'conftest.ActivationTester'>

/testbed/tests/unit/activation/test_nushell.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/unit/activation/conftest.py:253: in _tester
    return tester(monkeypatch, tmp_path)
        activation_python = <virtualenv.run.session.Session object at 0x7f064f5b4190>
        is_inside_ci = False
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f5b5120>
        tester     = Nushell(
version='0.98.0\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tester_class = <class 'test_nushell.test_nushell.<locals>.Nushell'>
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_nushell_with_prompt_0')
        version    = '0.98.0\n'
/testbed/tests/unit/activation/conftest.py:89: in __call__
    self.assert_output(out, raw, tmp_path)
        _          = None
        activate_script = PosixPath('/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/activate.nu')
        env        = {'BLIS_NUM_THREADS': '1', 'CFLAGS': '-g0', 'HOME': '/root', 'LC_CTYPE': 'C.UTF-8', ...}
        invoke     = ['/root/.cargo/bin/nu', '/tmp/pytest-of-root/pytest-0/test_nushell_with_prompt_0/script.nu']
        line       = b'export alias deactivate = overlay hide activate'
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f5b5120>
        out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
        process    = <Popen: returncode: 0 args: ['/root/.cargo/bin/nu', '/tmp/pytest-of-root/pyt...>
        raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/pyth...nv1/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\ntestbed\n'
        raw_       = b'/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ \xc3\xa8\xd1\x80\...9f\x9a\x92\xe2\x99\x9e\xe4\xb8\xad\xe7\x89\x87-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\ntestbed\n'
        script_content = b'# virtualenv activation module\n# Activate with `overlay use activate.nu`\n# Deactivate with `deactivate`, as usual\...v\n    load-env $new_env\n}\n\nexport alias pydoc = python -m pydoc\nexport alias deactivate = overlay hide activate\n'
        self       = Nushell(
version='0.98.0\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        test_script = PosixPath('/tmp/pytest-of-root/pytest-0/test_nushell_with_prompt_0/script.nu')
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_nushell_with_prompt_0')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Nushell(
version='0.98.0\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
out = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/pyth...nv1/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\ntestbed\n'
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_nushell_with_prompt_0')

    def assert_output(self, out, raw, tmp_path):
        # pre-activation
        assert out[0], raw
        assert out[1] == "None", raw
>       assert out[2] == "None", raw
E       AssertionError: /testbed/.venv/bin/python3
E         None
E         testbed
E         /tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3
E         /tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j
E         e-$ èрт🚒♞中片-j
E         (e-$ èрт🚒♞中片-j) 
E         wrote pydoc_test.html
E         /testbed/.venv/bin/python3
E         None
E         testbed
E         
E       assert 'testbed' == 'None'
E         
E         - None
E         + testbed

out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/pyth...nv1/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\ntestbed\n'
self       = Nushell(
version='0.98.0\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_nushell_with_prompt_0')

/testbed/tests/unit/activation/conftest.py:137: AssertionError
</pre>
</details>
<h3 id="test_fishpytest_fishwith_prompt">test_fish.py::test_fish[with_prompt]</h3>
<details><summary> <pre>test_fish.py::test_fish[with_prompt]</pre></summary><pre>
activation_tester_class = <class 'conftest.ActivationTester'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dbfb250>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f4e0a60>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_fish_with_prompt_0')

    @pytest.mark.skipif(IS_WIN, reason="we have not setup fish in CI yet")
    def test_fish(activation_tester_class, activation_tester, monkeypatch, tmp_path):
        monkeypatch.setenv("HOME", str(tmp_path))
        fish_conf_dir = tmp_path / ".config" / "fish"
        fish_conf_dir.mkdir(parents=True)
        (fish_conf_dir / "config.fish").write_text("", encoding="utf-8")

        class Fish(activation_tester_class):
            def __init__(self, session) -> None:
                super().__init__(FishActivator, session, "fish", "activate.fish", "fish")

            def print_prompt(self):
                return "fish_prompt"

>       activation_tester(Fish)

Fish       = <class 'test_fish.test_fish.<locals>.Fish'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dbfb250>
activation_tester_class = <class 'conftest.ActivationTester'>
fish_conf_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_fish_with_prompt_0/.config/fish')
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f4e0a60>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_fish_with_prompt_0')

/testbed/tests/unit/activation/test_fish.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/unit/activation/conftest.py:253: in _tester
    return tester(monkeypatch, tmp_path)
        activation_python = <virtualenv.run.session.Session object at 0x7f064f5b4190>
        is_inside_ci = False
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f4e0a60>
        tester     = Fish(
version='fish, version 3.3.1\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tester_class = <class 'test_fish.test_fish.<locals>.Fish'>
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_fish_with_prompt_0')
        version    = 'fish, version 3.3.1\n'
/testbed/tests/unit/activation/conftest.py:89: in __call__
    self.assert_output(out, raw, tmp_path)
        _          = None
        activate_script = PosixPath('/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/activate.fish')
        env        = {'BLIS_NUM_THREADS': '1', 'CFLAGS': '-g0', 'HOME': '/tmp/pytest-of-root/pytest-0/test_fish_with_prompt_0', 'LC_CTYPE': 'C.UTF-8', ...}
        invoke     = ['fish', '/tmp/pytest-of-root/pytest-0/test_fish_with_prompt_0/script.fish']
        line       = b'end'
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f4e0a60>
        out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
        process    = <Popen: returncode: 0 args: ['fish', '/tmp/pytest-of-root/pytest-0/test_fish...>
        raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/pyth...B\x1b[m@modal\x1b(B\x1b[m ~\x1b(B\x1b[m\x1b(B\x1b[m# \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
        raw_       = b'/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ \xc3\xa8\xd1\x80\...B\x1b[m@modal\x1b(B\x1b[m ~\x1b(B\x1b[m\x1b(B\x1b[m# \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
        script_content = b'# This file must be used using `source bin/activate.fish` *within a running fish ( http://fishshell.com ) session*.\...oin -- \\n $prompt # handle multi-line prompts\n    end\n\n    set -gx _OLD_FISH_PROMPT_OVERRIDE "$VIRTUAL_ENV"\nend\n'
        self       = Fish(
version='fish, version 3.3.1\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        test_script = PosixPath('/tmp/pytest-of-root/pytest-0/test_fish_with_prompt_0/script.fish')
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_fish_with_prompt_0')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Fish(
version='fish, version 3.3.1\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
out = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/pyth...B\x1b[m@modal\x1b(B\x1b[m ~\x1b(B\x1b[m\x1b(B\x1b[m# \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_fish_with_prompt_0')

    def assert_output(self, out, raw, tmp_path):
        # pre-activation
        assert out[0], raw
        assert out[1] == "None", raw
>       assert out[2] == "None", raw
E       AssertionError: /testbed/.venv/bin/python3
E         None
E         testbed
E         /tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3
E         /tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j
E         e-$ èрт🚒♞中片-j
E         (e-$ èрт🚒♞中片-j) root(B[m@modal(B[m ~(B[m(B[m# 
E         wrote pydoc_test.html
E         /testbed/.venv/bin/python3
E         None
E         None
E         
E       assert 'testbed' == 'None'
E         
E         - None
E         + testbed

out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/pyth...B\x1b[m@modal\x1b(B\x1b[m ~\x1b(B\x1b[m\x1b(B\x1b[m# \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
self       = Fish(
version='fish, version 3.3.1\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_fish_with_prompt_0')

/testbed/tests/unit/activation/conftest.py:137: AssertionError
</pre>
</details>
<h3 id="test_python_activatorpytest_pythonwith_prompt">test_python_activator.py::test_python[with_prompt]</h3>
<details><summary> <pre>test_python_activator.py::test_python[with_prompt]</pre></summary><pre>
raise_on_non_source_class = <class 'conftest.RaiseOnNonSourceCall'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dc38040>

    def test_python(raise_on_non_source_class, activation_tester):
        class Python(raise_on_non_source_class):
            def __init__(self, session) -> None:
                super().__init__(
                    PythonActivator,
                    session,
                    sys.executable,
                    activate_script="activate_this.py",
                    extension="py",
                    non_source_fail_message="You must use import runpy; runpy.run_path(this_file)",
                )
                self.unix_line_ending = not IS_WIN

            def env(self, tmp_path):
                env = os.environ.copy()
                env["PYTHONIOENCODING"] = "utf-8"
                for key in ("VIRTUAL_ENV", "PYTHONPATH"):
                    env.pop(str(key), None)
                env["PATH"] = os.pathsep.join([str(tmp_path), str(tmp_path / "other")])
                return env

            @staticmethod
            def _get_test_lines(activate_script):
                raw = f"""
                import os
                import sys
                import platform
                import runpy

                def print_r(value):
                    print(repr(value))

                print_r(os.environ.get("VIRTUAL_ENV"))
                print_r(os.environ.get("VIRTUAL_ENV_PROMPT"))
                print_r(os.environ.get("PATH").split(os.pathsep))
                print_r(sys.path)

                file_at = {str(activate_script)!r}
                # CPython 2 requires non-ascii path open to be unicode
                runpy.run_path(file_at)
                print_r(os.environ.get("VIRTUAL_ENV"))
                print_r(os.environ.get("VIRTUAL_ENV_PROMPT"))
                print_r(os.environ.get("PATH").split(os.pathsep))
                print_r(sys.path)

                import pydoc_test
                print_r(pydoc_test.__file__)
                """
                return dedent(raw).splitlines()

            def assert_output(self, out, raw, tmp_path):  # noqa: ARG002
                out = [literal_eval(i) for i in out]
                assert out[0] is None  # start with VIRTUAL_ENV None
                assert out[1] is None  # likewise for VIRTUAL_ENV_PROMPT

                prev_path = out[2]
                prev_sys_path = out[3]
                assert out[4] == str(self._creator.dest)  # VIRTUAL_ENV now points to the virtual env folder

                assert out[5] == str(self._creator.env_name)  # VIRTUAL_ENV_PROMPT now has the env name

                new_path = out[6]  # PATH now starts with bin path of current
                assert ([str(self._creator.bin_dir), *prev_path]) == new_path

                # sys path contains the site package at its start
                new_sys_path = out[7]

                new_lib_paths = {str(i) for i in self._creator.libs}
                assert prev_sys_path == new_sys_path[len(new_lib_paths) :]
                assert new_lib_paths == set(new_sys_path[: len(new_lib_paths)])

                # manage to import from activate site package
                dest = self.norm_path(self._creator.purelib / "pydoc_test.py")
                found = self.norm_path(out[8])
                assert found.startswith(dest)

            def non_source_activate(self, activate_script):
                act = str(activate_script)
                return [*self._invoke_script, "-c", f"exec(open({act!r}).read())"]

>       activation_tester(Python)

Python     = <class 'test_python_activator.test_python.<locals>.Python'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dc38040>
raise_on_non_source_class = <class 'conftest.RaiseOnNonSourceCall'>

/testbed/tests/unit/activation/test_python_activator.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/unit/activation/conftest.py:253: in _tester
    return tester(monkeypatch, tmp_path)
        activation_python = <virtualenv.run.session.Session object at 0x7f064f5b4190>
        is_inside_ci = False
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f5b4340>
        tester     = Python(
version='Python 3.10.12\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tester_class = <class 'test_python_activator.test_python.<locals>.Python'>
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_python_with_prompt_0')
        version    = 'Python 3.10.12\n'
/testbed/tests/unit/activation/conftest.py:209: in __call__
    env, activate_script = super().__call__(monkeypatch, tmp_path)
        __class__  = <class 'conftest.RaiseOnNonSourceCall'>
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f5b4340>
        self       = Python(
version='Python 3.10.12\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_python_with_prompt_0')
/testbed/tests/unit/activation/conftest.py:89: in __call__
    self.assert_output(out, raw, tmp_path)
        _          = None
        activate_script = PosixPath('/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/activate_this.py')
        env        = {'BLIS_NUM_THREADS': '1', 'CFLAGS': '-g0', 'HOME': '/root', 'LC_CTYPE': 'C.UTF-8', ...}
        invoke     = ['/testbed/.venv/bin/python3', '/tmp/pytest-of-root/pytest-0/test_python_with_prompt_0/script.py']
        line       = b'sys.prefix = base'
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f5b4340>
        out        = ['None', "'testbed'", "['/tmp/pytest-of-root/pytest-0/test_python_with_prompt_0', '/tmp/pytest-of-root/pytest-0/test_p...ages', '/testbed/src']", "'/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j'", "'e-$ èрт🚒♞中片-j'", ...]
        process    = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', '/tmp/pytest-of-r...>
        raw        = "None\n'testbed'\n['/tmp/pytest-of-root/pytest-0/test_python_with_prompt_0', '/tmp/pytest-of-root/pytest-0/test_python...rc']\n'/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/lib/python3.10/site-packages/pydoc_test.py'\n"
        raw_       = b"None\n'testbed'\n['/tmp/pytest-of-root/pytest-0/test_python_with_prompt_0', '/tmp/pytest-of-root/pytest-0/test_pytho...a8\xd1\x80\xd1\x82\xf0\x9f\x9a\x92\xe2\x99\x9e\xe4\xb8\xad\xe7\x89\x87-j/lib/python3.10/site-packages/pydoc_test.py'\n"
        script_content = b'"""\nActivate virtualenv for current interpreter:\n\nimport runpy\nrunpy.run_path(this_file)\n\nThis can be used whe...)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\n\nsys.real_prefix = sys.prefix\nsys.prefix = base\n'
        self       = Python(
version='Python 3.10.12\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        test_script = PosixPath('/tmp/pytest-of-root/pytest-0/test_python_with_prompt_0/script.py')
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_python_with_prompt_0')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Python(
version='Python 3.10.12\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
out = [None, 'testbed', ['/tmp/pytest-of-root/pytest-0/test_python_with_prompt_0', '/tmp/pytest-of-root/pytest-0/test_python...-packages', '/testbed/src'], '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw = "None\n'testbed'\n['/tmp/pytest-of-root/pytest-0/test_python_with_prompt_0', '/tmp/pytest-of-root/pytest-0/test_python...rc']\n'/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/lib/python3.10/site-packages/pydoc_test.py'\n"
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_python_with_prompt_0')

    def assert_output(self, out, raw, tmp_path):  # noqa: ARG002
        out = [literal_eval(i) for i in out]
        assert out[0] is None  # start with VIRTUAL_ENV None
>       assert out[1] is None  # likewise for VIRTUAL_ENV_PROMPT
E       AssertionError: assert 'testbed' is None

out        = [None, 'testbed', ['/tmp/pytest-of-root/pytest-0/test_python_with_prompt_0', '/tmp/pytest-of-root/pytest-0/test_python...-packages', '/testbed/src'], '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw        = "None\n'testbed'\n['/tmp/pytest-of-root/pytest-0/test_python_with_prompt_0', '/tmp/pytest-of-root/pytest-0/test_python...rc']\n'/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/lib/python3.10/site-packages/pydoc_test.py'\n"
self       = Python(
version='Python 3.10.12\n',
creator=CPython3Posix(dest=/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_python_with_prompt_0')

/testbed/tests/unit/activation/test_python_activator.py:65: AssertionError
</pre>
</details>
<h3 id="test_bashpytest_bashwith_prompt-true">test_bash.py::test_bash[with_prompt-True]</h3>
<details><summary> <pre>test_bash.py::test_bash[with_prompt-True]</pre></summary><pre>
raise_on_non_source_class = <class 'conftest.RaiseOnNonSourceCall'>
hashing_enabled = True
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dc395a0>

    @pytest.mark.skipif(IS_WIN, reason="Github Actions ships with WSL bash")
    @pytest.mark.parametrize("hashing_enabled", [True, False])
    def test_bash(raise_on_non_source_class, hashing_enabled, activation_tester):
        class Bash(raise_on_non_source_class):
            def __init__(self, session) -> None:
                super().__init__(
                    BashActivator,
                    session,
                    "bash",
                    "activate",
                    "sh",
                    "You must source this script: $ source ",
                )
                self.deactivate += " || exit 1"
                self._invoke_script.append("-h" if hashing_enabled else "+h")

            def activate_call(self, script):
                return super().activate_call(script) + " || exit 1"

            def print_prompt(self):
                return self.print_os_env_var("PS1")

>       activation_tester(Bash)

Bash       = <class 'test_bash.test_bash.<locals>.Bash'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dc395a0>
hashing_enabled = True
raise_on_non_source_class = <class 'conftest.RaiseOnNonSourceCall'>

/testbed/tests/unit/activation/test_bash.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/unit/activation/conftest.py:253: in _tester
    return tester(monkeypatch, tmp_path)
        activation_python = <virtualenv.run.session.Session object at 0x7f064f5b4190>
        is_inside_ci = False
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064da7fac0>
        tester     = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tester_class = <class 'test_bash.test_bash.<locals>.Bash'>
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_with_prompt_True_0')
        version    = 'GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation, Inc.\nLicense...is free software; you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n'
/testbed/tests/unit/activation/conftest.py:209: in __call__
    env, activate_script = super().__call__(monkeypatch, tmp_path)
        __class__  = <class 'conftest.RaiseOnNonSourceCall'>
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064da7fac0>
        self       = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_with_prompt_True_0')
/testbed/tests/unit/activation/conftest.py:89: in __call__
    self.assert_output(out, raw, tmp_path)
        _          = None
        activate_script = PosixPath('/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/activate')
        env        = {'BLIS_NUM_THREADS': '1', 'CFLAGS': '-g0', 'HOME': '/root', 'LC_CTYPE': 'C.UTF-8', ...}
        invoke     = ['bash', '-h', '/tmp/pytest-of-root/pytest-0/test_bash_with_prompt_True_0/script.sh']
        line       = b'hash -r 2>/dev/null || true'
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064da7fac0>
        out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
        process    = <Popen: returncode: 0 args: ['bash', '-h', '/tmp/pytest-of-root/pytest-0/tes...>
        raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/pyth...r-env1/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
        raw_       = b'/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ \xc3\xa8\xd1\x80\...0\x9f\x9a\x92\xe2\x99\x9e\xe4\xb8\xad\xe7\x89\x87-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
        script_content = b'# This file must be used with "source bin/activate" *from bash*\n# you cannot run it directly\n\n\nif [ "${BASH_SOUR...nds. Without forgetting past commands the $PATH changes\n# we made may not be respected\nhash -r 2>/dev/null || true\n'
        self       = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        test_script = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_with_prompt_True_0/script.sh')
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_with_prompt_True_0')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
out = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/pyth...r-env1/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_with_prompt_True_0')

    def assert_output(self, out, raw, tmp_path):
        # pre-activation
        assert out[0], raw
        assert out[1] == "None", raw
>       assert out[2] == "None", raw
E       AssertionError: /testbed/.venv/bin/python3
E         None
E         testbed
E         /tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3
E         /tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j
E         e-$ èрт🚒♞中片-j
E         (e-$ èрт🚒♞中片-j) 
E         wrote pydoc_test.html
E         /testbed/.venv/bin/python3
E         None
E         None
E         
E       assert 'testbed' == 'None'
E         
E         - None
E         + testbed

out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/pyth...r-env1/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
self       = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_with_prompt_True_0')

/testbed/tests/unit/activation/conftest.py:137: AssertionError
</pre>
</details>
<h3 id="test_bashpytest_bashwith_prompt-false">test_bash.py::test_bash[with_prompt-False]</h3>
<details><summary> <pre>test_bash.py::test_bash[with_prompt-False]</pre></summary><pre>
raise_on_non_source_class = <class 'conftest.RaiseOnNonSourceCall'>
hashing_enabled = False
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dc38af0>

    @pytest.mark.skipif(IS_WIN, reason="Github Actions ships with WSL bash")
    @pytest.mark.parametrize("hashing_enabled", [True, False])
    def test_bash(raise_on_non_source_class, hashing_enabled, activation_tester):
        class Bash(raise_on_non_source_class):
            def __init__(self, session) -> None:
                super().__init__(
                    BashActivator,
                    session,
                    "bash",
                    "activate",
                    "sh",
                    "You must source this script: $ source ",
                )
                self.deactivate += " || exit 1"
                self._invoke_script.append("-h" if hashing_enabled else "+h")

            def activate_call(self, script):
                return super().activate_call(script) + " || exit 1"

            def print_prompt(self):
                return self.print_os_env_var("PS1")

>       activation_tester(Bash)

Bash       = <class 'test_bash.test_bash.<locals>.Bash'>
activation_tester = <function activation_tester.<locals>._tester at 0x7f064dc38af0>
hashing_enabled = False
raise_on_non_source_class = <class 'conftest.RaiseOnNonSourceCall'>

/testbed/tests/unit/activation/test_bash.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/unit/activation/conftest.py:253: in _tester
    return tester(monkeypatch, tmp_path)
        activation_python = <virtualenv.run.session.Session object at 0x7f064f5b4190>
        is_inside_ci = False
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f851090>
        tester     = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tester_class = <class 'test_bash.test_bash.<locals>.Bash'>
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_with_prompt_False_0')
        version    = 'GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation, Inc.\nLicense...is free software; you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n'
/testbed/tests/unit/activation/conftest.py:209: in __call__
    env, activate_script = super().__call__(monkeypatch, tmp_path)
        __class__  = <class 'conftest.RaiseOnNonSourceCall'>
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f851090>
        self       = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_with_prompt_False_0')
/testbed/tests/unit/activation/conftest.py:89: in __call__
    self.assert_output(out, raw, tmp_path)
        _          = None
        activate_script = PosixPath('/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/activate')
        env        = {'BLIS_NUM_THREADS': '1', 'CFLAGS': '-g0', 'HOME': '/root', 'LC_CTYPE': 'C.UTF-8', ...}
        invoke     = ['bash', '+h', '/tmp/pytest-of-root/pytest-0/test_bash_with_prompt_False_0/script.sh']
        line       = b'hash -r 2>/dev/null || true'
        monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f064f851090>
        out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
        process    = <Popen: returncode: 0 args: ['bash', '+h', '/tmp/pytest-of-root/pytest-0/tes...>
        raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/pyth...r-env1/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
        raw_       = b'/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ \xc3\xa8\xd1\x80\...0\x9f\x9a\x92\xe2\x99\x9e\xe4\xb8\xad\xe7\x89\x87-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
        script_content = b'# This file must be used with "source bin/activate" *from bash*\n# you cannot run it directly\n\n\nif [ "${BASH_SOUR...nds. Without forgetting past commands the $PATH changes\n# we made may not be respected\nhash -r 2>/dev/null || true\n'
        self       = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
        test_script = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_with_prompt_False_0/script.sh')
        tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_with_prompt_False_0')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
out = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/pyth...r-env1/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_with_prompt_False_0')

    def assert_output(self, out, raw, tmp_path):
        # pre-activation
        assert out[0], raw
        assert out[1] == "None", raw
>       assert out[2] == "None", raw
E       AssertionError: /testbed/.venv/bin/python3
E         None
E         testbed
E         /tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3
E         /tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j
E         e-$ èрт🚒♞中片-j
E         (e-$ èрт🚒♞中片-j) 
E         wrote pydoc_test.html
E         /testbed/.venv/bin/python3
E         None
E         None
E         
E       assert 'testbed' == 'None'
E         
E         - None
E         + testbed

out        = ['/testbed/.venv/bin/python3', 'None', 'testbed', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/python3', '/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j', 'e-$ èрт🚒♞中片-j', ...]
raw        = '/testbed/.venv/bin/python3\nNone\ntestbed\n/tmp/pytest-of-root/pytest-0/activation-tester-env1/e-$ èрт🚒♞中片-j/bin/pyth...r-env1/e-$ èрт🚒♞中片-j\ne-$ èрт🚒♞中片-j\n(e-$ èрт🚒♞中片-j) \nwrote pydoc_test.html\n/testbed/.venv/bin/python3\nNone\nNone\n'
self       = Bash(
version='GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2020 Free Software Foundation,...bin/python3, platform=linux, version='3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0]', encoding_fs_io=utf-8-utf-8))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_bash_with_prompt_False_0')

/testbed/tests/unit/activation/conftest.py:137: AssertionError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/virtualenv/activation/activator.py b/src/virtualenv/activation/activator.py</span>
<span class="gh">index 328589c..dd404b4 100644</span>
<span class="gd">--- a/src/virtualenv/activation/activator.py</span>
<span class="gi">+++ b/src/virtualenv/activation/activator.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from abc import ABC, abstractmethod

<span class="gu">@@ -6,26 +7,25 @@ from abc import ABC, abstractmethod</span>
<span class="w"> </span>class Activator(ABC):
<span class="w"> </span>    &quot;&quot;&quot;Generates activate script for the virtual environment.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, options) -&gt;None:</span>
<span class="gi">+    def __init__(self, options) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a new activator generator.

<span class="w"> </span>        :param options: the parsed options as defined within :meth:`add_parser_arguments`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        self.flag_prompt = os.path.basename(os.getcwd()</span>
<span class="gd">-            ) if options.prompt == &#39;.&#39; else options.prompt</span>
<span class="gi">+        self.flag_prompt = os.path.basename(os.getcwd()) if options.prompt == &quot;.&quot; else options.prompt</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def supports(cls, interpreter):</span>
<span class="gi">+    def supports(cls, interpreter):  # noqa: ARG003</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Check if the activation script is supported in the given interpreter.

<span class="w"> </span>        :param interpreter: the interpreter we need to support
<span class="w"> </span>        :return: ``True`` if supported, ``False`` otherwise
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return True</span>

<span class="gd">-    @classmethod</span>
<span class="gi">+    @classmethod  # noqa: B027</span>
<span class="w"> </span>    def add_parser_arguments(cls, parser, interpreter):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Add CLI arguments for this activation script.
<span class="gu">@@ -33,16 +33,18 @@ class Activator(ABC):</span>
<span class="w"> </span>        :param parser: the CLI parser
<span class="w"> </span>        :param interpreter: the interpreter this virtual environment is based of
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def generate(self, creator):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Generate activate script for the given creator.

<span class="gd">-        :param creator: the creator (based of :class:`virtualenv.create.creator.Creator`) we used to create this         virtual environment</span>
<span class="gi">+        :param creator: the creator (based of :class:`virtualenv.create.creator.Creator`) we used to create this \</span>
<span class="gi">+        virtual environment</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="gd">-__all__ = [&#39;Activator&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Activator&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/activation/python/activate_this.py b/src/virtualenv/activation/python/activate_this.py</span>
<span class="gh">index cde4ce6..388e001 100644</span>
<span class="gd">--- a/src/virtualenv/activation/python/activate_this.py</span>
<span class="gi">+++ b/src/virtualenv/activation/python/activate_this.py</span>
<span class="gu">@@ -5,27 +5,34 @@ import runpy</span>
<span class="w"> </span>runpy.run_path(this_file)

<span class="w"> </span>This can be used when you must use an existing Python interpreter, not the virtualenv bin/python.
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+&quot;&quot;&quot;  # noqa: D415</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import site
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    abs_file = os.path.abspath(__file__)
<span class="w"> </span>except NameError as exc:
<span class="gd">-    msg = &#39;You must use import runpy; runpy.run_path(this_file)&#39;</span>
<span class="gi">+    msg = &quot;You must use import runpy; runpy.run_path(this_file)&quot;</span>
<span class="w"> </span>    raise AssertionError(msg) from exc
<span class="gi">+</span>
<span class="w"> </span>bin_dir = os.path.dirname(abs_file)
<span class="gd">-base = bin_dir[:-len(&#39;__BIN_NAME__&#39;) - 1]</span>
<span class="gd">-os.environ[&#39;PATH&#39;] = os.pathsep.join([bin_dir, *os.environ.get(&#39;PATH&#39;, &#39;&#39;).</span>
<span class="gd">-    split(os.pathsep)])</span>
<span class="gd">-os.environ[&#39;VIRTUAL_ENV&#39;] = base</span>
<span class="gd">-os.environ[&#39;VIRTUAL_ENV_PROMPT&#39;] = &#39;__VIRTUAL_PROMPT__&#39; or os.path.basename(</span>
<span class="gd">-    base)</span>
<span class="gi">+base = bin_dir[: -len(&quot;__BIN_NAME__&quot;) - 1]  # strip away the bin part from the __file__, plus the path separator</span>
<span class="gi">+</span>
<span class="gi">+# prepend bin to PATH (this file is inside the bin directory)</span>
<span class="gi">+os.environ[&quot;PATH&quot;] = os.pathsep.join([bin_dir, *os.environ.get(&quot;PATH&quot;, &quot;&quot;).split(os.pathsep)])</span>
<span class="gi">+os.environ[&quot;VIRTUAL_ENV&quot;] = base  # virtual env is right above bin directory</span>
<span class="gi">+os.environ[&quot;VIRTUAL_ENV_PROMPT&quot;] = &quot;__VIRTUAL_PROMPT__&quot; or os.path.basename(base)  # noqa: SIM222</span>
<span class="gi">+</span>
<span class="gi">+# add the virtual environments libraries to the host python import mechanism</span>
<span class="w"> </span>prev_length = len(sys.path)
<span class="gd">-for lib in &#39;__LIB_FOLDERS__&#39;.split(os.pathsep):</span>
<span class="gi">+for lib in &quot;__LIB_FOLDERS__&quot;.split(os.pathsep):</span>
<span class="w"> </span>    path = os.path.realpath(os.path.join(bin_dir, lib))
<span class="gd">-    site.addsitedir(path.decode(&#39;utf-8&#39;) if &#39;__DECODE_PATH__&#39; else path)</span>
<span class="gi">+    site.addsitedir(path.decode(&quot;utf-8&quot;) if &quot;__DECODE_PATH__&quot; else path)</span>
<span class="w"> </span>sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]
<span class="gi">+</span>
<span class="w"> </span>sys.real_prefix = sys.prefix
<span class="w"> </span>sys.prefix = base
<span class="gh">diff --git a/src/virtualenv/activation/via_template.py b/src/virtualenv/activation/via_template.py</span>
<span class="gh">index 6b70a4d..ab9b901 100644</span>
<span class="gd">--- a/src/virtualenv/activation/via_template.py</span>
<span class="gi">+++ b/src/virtualenv/activation/via_template.py</span>
<span class="gu">@@ -1,16 +1,76 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>from abc import ABC, abstractmethod
<span class="gi">+</span>
<span class="w"> </span>from .activator import Activator
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 10):
<span class="w"> </span>    from importlib.resources import files
<span class="gi">+</span>
<span class="gi">+    def read_binary(module_name: str, filename: str) -&gt; bytes:</span>
<span class="gi">+        return (files(module_name) / filename).read_bytes()</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="w"> </span>    from importlib.resources import read_binary


<span class="w"> </span>class ViaTemplateActivator(Activator, ABC):
<span class="gd">-    pass</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def templates(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def generate(self, creator):</span>
<span class="gi">+        dest_folder = creator.bin_dir</span>
<span class="gi">+        replacements = self.replacements(creator, dest_folder)</span>
<span class="gi">+        generated = self._generate(replacements, self.templates(), dest_folder, creator)</span>
<span class="gi">+        if self.flag_prompt is not None:</span>
<span class="gi">+            creator.pyenv_cfg[&quot;prompt&quot;] = self.flag_prompt</span>
<span class="gi">+        return generated</span>
<span class="gi">+</span>
<span class="gi">+    def replacements(self, creator, dest_folder):  # noqa: ARG002</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;__VIRTUAL_PROMPT__&quot;: &quot;&quot; if self.flag_prompt is None else self.flag_prompt,</span>
<span class="gi">+            &quot;__VIRTUAL_ENV__&quot;: str(creator.dest),</span>
<span class="gi">+            &quot;__VIRTUAL_NAME__&quot;: creator.env_name,</span>
<span class="gi">+            &quot;__BIN_NAME__&quot;: str(creator.bin_dir.relative_to(creator.dest)),</span>
<span class="gi">+            &quot;__PATH_SEP__&quot;: os.pathsep,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def _generate(self, replacements, templates, to_folder, creator):</span>
<span class="gi">+        generated = []</span>
<span class="gi">+        for template in templates:</span>
<span class="gi">+            text = self.instantiate_template(replacements, template, creator)</span>
<span class="gi">+            dest = to_folder / self.as_name(template)</span>
<span class="gi">+            # remove the file if it already exists - this prevents permission</span>
<span class="gi">+            # errors when the dest is not writable</span>
<span class="gi">+            if dest.exists():</span>
<span class="gi">+                dest.unlink()</span>
<span class="gi">+            # Powershell assumes Windows 1252 encoding when reading files without BOM</span>
<span class="gi">+            encoding = &quot;utf-8-sig&quot; if str(template).endswith(&quot;.ps1&quot;) else &quot;utf-8&quot;</span>
<span class="gi">+            # use write_bytes to avoid platform specific line normalization (\n -&gt; \r\n)</span>
<span class="gi">+            dest.write_bytes(text.encode(encoding))</span>
<span class="gi">+            generated.append(dest)</span>
<span class="gi">+        return generated</span>
<span class="gi">+</span>
<span class="gi">+    def as_name(self, template):</span>
<span class="gi">+        return template</span>
<span class="gi">+</span>
<span class="gi">+    def instantiate_template(self, replacements, template, creator):</span>
<span class="gi">+        # read content as binary to avoid platform specific line normalization (\n -&gt; \r\n)</span>
<span class="gi">+        binary = read_binary(self.__module__, template)</span>
<span class="gi">+        text = binary.decode(&quot;utf-8&quot;, errors=&quot;strict&quot;)</span>
<span class="gi">+        for key, value in replacements.items():</span>
<span class="gi">+            value_uni = self._repr_unicode(creator, value)</span>
<span class="gi">+            text = text.replace(key, value_uni)</span>
<span class="gi">+        return text</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _repr_unicode(creator, value):  # noqa: ARG004</span>
<span class="gi">+        return value  # by default, we just let it be unicode</span>


<span class="gd">-__all__ = [&#39;ViaTemplateActivator&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;ViaTemplateActivator&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/app_data/base.py b/src/virtualenv/app_data/base.py</span>
<span class="gh">index c8e5b7b..2077dee 100644</span>
<span class="gd">--- a/src/virtualenv/app_data/base.py</span>
<span class="gi">+++ b/src/virtualenv/app_data/base.py</span>
<span class="gu">@@ -1,7 +1,10 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Application data stored by virtualenv.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABC, abstractmethod
<span class="w"> </span>from contextlib import contextmanager
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.info import IS_ZIPAPP


<span class="gu">@@ -11,21 +14,83 @@ class AppData(ABC):</span>
<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;Called before virtualenv exits.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def reset(self):
<span class="w"> </span>        &quot;&quot;&quot;Called when the user passes in the reset app data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def py_info(self, path):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def py_info_clear(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def can_update(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def embed_update_log(self, distribution, for_py_version):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def house(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def transient(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def wheel_image(self, for_py_version, name):</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @contextmanager
<span class="w"> </span>    def ensure_extracted(self, path, to_folder=None):
<span class="w"> </span>        &quot;&quot;&quot;Some paths might be within the zipapp, unzip these to a path on the disk.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if IS_ZIPAPP:</span>
<span class="gi">+            with self.extract(path, to_folder) as result:</span>
<span class="gi">+                yield result</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield path</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def extract(self, path, to_folder):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def locked(self, path):</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>class ContentStore(ABC):
<span class="gd">-    pass</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def exists(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def read(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def write(self, content):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def remove(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def locked(self):</span>
<span class="gi">+        pass</span>


<span class="gd">-__all__ = [&#39;AppData&#39;, &#39;ContentStore&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;AppData&quot;,</span>
<span class="gi">+    &quot;ContentStore&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/app_data/na.py b/src/virtualenv/app_data/na.py</span>
<span class="gh">index 76639f8..921e83a 100644</span>
<span class="gd">--- a/src/virtualenv/app_data/na.py</span>
<span class="gi">+++ b/src/virtualenv/app_data/na.py</span>
<span class="gu">@@ -1,49 +1,72 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from contextlib import contextmanager
<span class="gi">+</span>
<span class="w"> </span>from .base import AppData, ContentStore


<span class="w"> </span>class AppDataDisabled(AppData):
<span class="w"> </span>    &quot;&quot;&quot;No application cache available (most likely as we don&#39;t have write permissions).&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    transient = True
<span class="w"> </span>    can_update = False

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        pass
<span class="gd">-    error = RuntimeError(</span>
<span class="gd">-        &#39;no app data folder available, probably no write access to the folder&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    error = RuntimeError(&quot;no app data folder available, probably no write access to the folder&quot;)</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;Do nothing.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    def reset(self):
<span class="w"> </span>        &quot;&quot;&quot;Do nothing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+    def py_info(self, path):  # noqa: ARG002</span>
<span class="gi">+        return ContentStoreNA()</span>
<span class="gi">+</span>
<span class="gi">+    def embed_update_log(self, distribution, for_py_version):  # noqa: ARG002</span>
<span class="gi">+        return ContentStoreNA()</span>
<span class="gi">+</span>
<span class="gi">+    def extract(self, path, to_folder):  # noqa: ARG002</span>
<span class="gi">+        raise self.error</span>

<span class="w"> </span>    @contextmanager
<span class="gd">-    def locked(self, path):</span>
<span class="gi">+    def locked(self, path):  # noqa: ARG002</span>
<span class="w"> </span>        &quot;&quot;&quot;Do nothing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        yield</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def house(self):</span>
<span class="gi">+        raise self.error</span>
<span class="gi">+</span>
<span class="gi">+    def wheel_image(self, for_py_version, name):  # noqa: ARG002</span>
<span class="gi">+        raise self.error</span>

<span class="w"> </span>    def py_info_clear(self):
<span class="w"> </span>        &quot;&quot;&quot;Nothing to clear.&quot;&quot;&quot;
<span class="gd">-        pass</span>


<span class="w"> </span>class ContentStoreNA(ContentStore):
<span class="gi">+    def exists(self):</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def read(self):
<span class="w"> </span>        &quot;&quot;&quot;Nothing to read.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return</span>

<span class="w"> </span>    def write(self, content):
<span class="w"> </span>        &quot;&quot;&quot;Nothing to write.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    def remove(self):
<span class="w"> </span>        &quot;&quot;&quot;Nothing to remove.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def locked(self):</span>
<span class="gi">+        yield</span>


<span class="gd">-__all__ = [&#39;AppDataDisabled&#39;, &#39;ContentStoreNA&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;AppDataDisabled&quot;,</span>
<span class="gi">+    &quot;ContentStoreNA&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/app_data/read_only.py b/src/virtualenv/app_data/read_only.py</span>
<span class="gh">index a2e161c..952dbad 100644</span>
<span class="gd">--- a/src/virtualenv/app_data/read_only.py</span>
<span class="gi">+++ b/src/virtualenv/app_data/read_only.py</span>
<span class="gu">@@ -1,22 +1,42 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os.path
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.util.lock import NoOpFileLock
<span class="gi">+</span>
<span class="w"> </span>from .via_disk_folder import AppDataDiskFolder, PyInfoStoreDisk


<span class="w"> </span>class ReadOnlyAppData(AppDataDiskFolder):
<span class="w"> </span>    can_update = False

<span class="gd">-    def __init__(self, folder: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, folder: str) -&gt; None:</span>
<span class="w"> </span>        if not os.path.isdir(folder):
<span class="gd">-            msg = f&#39;read-only app data directory {folder} does not exist&#39;</span>
<span class="gi">+            msg = f&quot;read-only app data directory {folder} does not exist&quot;</span>
<span class="w"> </span>            raise RuntimeError(msg)
<span class="w"> </span>        super().__init__(folder)
<span class="w"> </span>        self.lock = NoOpFileLock(folder)

<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        msg = &quot;read-only app data does not support reset&quot;</span>
<span class="gi">+        raise RuntimeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    def py_info_clear(self) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def py_info(self, path):</span>
<span class="gi">+        return _PyInfoStoreDiskReadOnly(self.py_info_at, path)</span>
<span class="gi">+</span>
<span class="gi">+    def embed_update_log(self, distribution, for_py_version):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>

<span class="w"> </span>class _PyInfoStoreDiskReadOnly(PyInfoStoreDisk):
<span class="gd">-    pass</span>
<span class="gi">+    def write(self, content):  # noqa: ARG002</span>
<span class="gi">+        msg = &quot;read-only app data python info cannot be updated&quot;</span>
<span class="gi">+        raise RuntimeError(msg)</span>


<span class="gd">-__all__ = [&#39;ReadOnlyAppData&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;ReadOnlyAppData&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/app_data/via_disk_folder.py b/src/virtualenv/app_data/via_disk_folder.py</span>
<span class="gh">index fe0a164..5228e49 100644</span>
<span class="gd">--- a/src/virtualenv/app_data/via_disk_folder.py</span>
<span class="gi">+++ b/src/virtualenv/app_data/via_disk_folder.py</span>
<span class="gu">@@ -20,64 +20,155 @@ virtualenv-app-data</span>
<span class="w"> </span>         ├── py_info.py
<span class="w"> </span>         ├── debug.py
<span class="w"> </span>         └── _virtualenv.py
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+&quot;&quot;&quot;  # noqa: D415</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import json
<span class="w"> </span>import logging
<span class="w"> </span>from abc import ABC
<span class="w"> </span>from contextlib import contextmanager, suppress
<span class="w"> </span>from hashlib import sha256
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.util.lock import ReentrantFileLock
<span class="w"> </span>from virtualenv.util.path import safe_delete
<span class="w"> </span>from virtualenv.util.zipapp import extract
<span class="w"> </span>from virtualenv.version import __version__
<span class="gi">+</span>
<span class="w"> </span>from .base import AppData, ContentStore


<span class="w"> </span>class AppDataDiskFolder(AppData):
<span class="w"> </span>    &quot;&quot;&quot;Store the application data on the disk within a folder layout.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    transient = False
<span class="w"> </span>    can_update = True

<span class="gd">-    def __init__(self, folder) -&gt;None:</span>
<span class="gi">+    def __init__(self, folder) -&gt; None:</span>
<span class="w"> </span>        self.lock = ReentrantFileLock(folder)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{type(self).__name__}({self.lock.path})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{type(self).__name__}({self.lock.path})&quot;</span>

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return str(self.lock.path)

<span class="gi">+    def reset(self):</span>
<span class="gi">+        logging.debug(&quot;reset app data folder %s&quot;, self.lock.path)</span>
<span class="gi">+        safe_delete(self.lock.path)</span>
<span class="gi">+</span>
<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;Do nothing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def locked(self, path):</span>
<span class="gi">+        path_lock = self.lock / path</span>
<span class="gi">+        with path_lock:</span>
<span class="gi">+            yield path_lock.path</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def extract(self, path, to_folder):</span>
<span class="gi">+        root = ReentrantFileLock(to_folder()) if to_folder is not None else self.lock / &quot;unzip&quot; / __version__</span>
<span class="gi">+        with root.lock_for_key(path.name):</span>
<span class="gi">+            dest = root.path / path.name</span>
<span class="gi">+            if not dest.exists():</span>
<span class="gi">+                extract(path, dest)</span>
<span class="gi">+            yield dest</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def py_info_at(self):</span>
<span class="gi">+        return self.lock / &quot;py_info&quot; / &quot;1&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def py_info(self, path):</span>
<span class="gi">+        return PyInfoStoreDisk(self.py_info_at, path)</span>

<span class="w"> </span>    def py_info_clear(self):
<span class="w"> </span>        &quot;&quot;&quot;clear py info.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        py_info_folder = self.py_info_at</span>
<span class="gi">+        with py_info_folder:</span>
<span class="gi">+            for filename in py_info_folder.path.iterdir():</span>
<span class="gi">+                if filename.suffix == &quot;.json&quot;:</span>
<span class="gi">+                    with py_info_folder.lock_for_key(filename.stem):</span>
<span class="gi">+                        if filename.exists():</span>
<span class="gi">+                            filename.unlink()</span>

<span class="gi">+    def embed_update_log(self, distribution, for_py_version):</span>
<span class="gi">+        return EmbedDistributionUpdateStoreDisk(self.lock / &quot;wheel&quot; / for_py_version / &quot;embed&quot; / &quot;3&quot;, distribution)</span>

<span class="gd">-class JSONStoreDisk(ContentStore, ABC):</span>
<span class="gi">+    @property</span>
<span class="gi">+    def house(self):</span>
<span class="gi">+        path = self.lock.path / &quot;wheel&quot; / &quot;house&quot;</span>
<span class="gi">+        path.mkdir(parents=True, exist_ok=True)</span>
<span class="gi">+        return path</span>
<span class="gi">+</span>
<span class="gi">+    def wheel_image(self, for_py_version, name):</span>
<span class="gi">+        return self.lock.path / &quot;wheel&quot; / for_py_version / &quot;image&quot; / &quot;1&quot; / name</span>

<span class="gd">-    def __init__(self, in_folder, key, msg, msg_args) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class JSONStoreDisk(ContentStore, ABC):</span>
<span class="gi">+    def __init__(self, in_folder, key, msg, msg_args) -&gt; None:</span>
<span class="w"> </span>        self.in_folder = in_folder
<span class="w"> </span>        self.key = key
<span class="w"> </span>        self.msg = msg
<span class="gd">-        self.msg_args = *msg_args, self.file</span>
<span class="gi">+        self.msg_args = (*msg_args, self.file)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def file(self):</span>
<span class="gi">+        return self.in_folder.path / f&quot;{self.key}.json&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def exists(self):</span>
<span class="gi">+        return self.file.exists()</span>
<span class="gi">+</span>
<span class="gi">+    def read(self):</span>
<span class="gi">+        data, bad_format = None, False</span>
<span class="gi">+        try:</span>
<span class="gi">+            data = json.loads(self.file.read_text(encoding=&quot;utf-8&quot;))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            bad_format = True</span>
<span class="gi">+        except Exception:  # noqa: BLE001, S110</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            logging.debug(&quot;got %s from %s&quot;, self.msg, self.msg_args)</span>
<span class="gi">+            return data</span>
<span class="gi">+        if bad_format:</span>
<span class="gi">+            with suppress(OSError):  # reading and writing on the same file may cause race on multiple processes</span>
<span class="gi">+                self.remove()</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def remove(self):</span>
<span class="gi">+        self.file.unlink()</span>
<span class="gi">+        logging.debug(&quot;removed %s at %s&quot;, self.msg, self.msg_args)</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def locked(self):</span>
<span class="gi">+        with self.in_folder.lock_for_key(self.key):</span>
<span class="gi">+            yield</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, content):</span>
<span class="gi">+        folder = self.file.parent</span>
<span class="gi">+        folder.mkdir(parents=True, exist_ok=True)</span>
<span class="gi">+        self.file.write_text(json.dumps(content, sort_keys=True, indent=2), encoding=&quot;utf-8&quot;)</span>
<span class="gi">+        logging.debug(&quot;wrote %s at %s&quot;, self.msg, self.msg_args)</span>


<span class="w"> </span>class PyInfoStoreDisk(JSONStoreDisk):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, in_folder, path) -&gt;None:</span>
<span class="gd">-        key = sha256(str(path).encode(&#39;utf-8&#39;)).hexdigest()</span>
<span class="gd">-        super().__init__(in_folder, key, &#39;python info of %s&#39;, (path,))</span>
<span class="gi">+    def __init__(self, in_folder, path) -&gt; None:</span>
<span class="gi">+        key = sha256(str(path).encode(&quot;utf-8&quot;)).hexdigest()</span>
<span class="gi">+        super().__init__(in_folder, key, &quot;python info of %s&quot;, (path,))</span>


<span class="w"> </span>class EmbedDistributionUpdateStoreDisk(JSONStoreDisk):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, in_folder, distribution) -&gt;None:</span>
<span class="gd">-        super().__init__(in_folder, distribution,</span>
<span class="gd">-            &#39;embed update of distribution %s&#39;, (distribution,))</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-__all__ = [&#39;AppDataDiskFolder&#39;, &#39;JSONStoreDisk&#39;, &#39;PyInfoStoreDisk&#39;]</span>
<span class="gi">+    def __init__(self, in_folder, distribution) -&gt; None:</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            in_folder,</span>
<span class="gi">+            distribution,</span>
<span class="gi">+            &quot;embed update of distribution %s&quot;,</span>
<span class="gi">+            (distribution,),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;AppDataDiskFolder&quot;,</span>
<span class="gi">+    &quot;JSONStoreDisk&quot;,</span>
<span class="gi">+    &quot;PyInfoStoreDisk&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/app_data/via_tempdir.py b/src/virtualenv/app_data/via_tempdir.py</span>
<span class="gh">index c3cae69..0a30dfe 100644</span>
<span class="gd">--- a/src/virtualenv/app_data/via_tempdir.py</span>
<span class="gi">+++ b/src/virtualenv/app_data/via_tempdir.py</span>
<span class="gu">@@ -1,7 +1,10 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>from tempfile import mkdtemp
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.util.path import safe_delete
<span class="gi">+</span>
<span class="w"> </span>from .via_disk_folder import AppDataDiskFolder


<span class="gu">@@ -9,13 +12,21 @@ class TempAppData(AppDataDiskFolder):</span>
<span class="w"> </span>    transient = True
<span class="w"> </span>    can_update = False

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__(folder=mkdtemp())
<span class="gd">-        logging.debug(&#39;created temporary app data folder %s&#39;, self.lock.path)</span>
<span class="gi">+        logging.debug(&quot;created temporary app data folder %s&quot;, self.lock.path)</span>

<span class="w"> </span>    def reset(self):
<span class="w"> </span>        &quot;&quot;&quot;This is a temporary folder, is already empty to start with.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        logging.debug(&quot;remove temporary app data folder %s&quot;, self.lock.path)</span>
<span class="gi">+        safe_delete(self.lock.path)</span>
<span class="gi">+</span>
<span class="gi">+    def embed_update_log(self, distribution, for_py_version):</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="gd">-__all__ = [&#39;TempAppData&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;TempAppData&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/config/cli/parser.py b/src/virtualenv/config/cli/parser.py</span>
<span class="gh">index 6deeebf..9323d4e 100644</span>
<span class="gd">--- a/src/virtualenv/config/cli/parser.py</span>
<span class="gi">+++ b/src/virtualenv/config/cli/parser.py</span>
<span class="gu">@@ -1,56 +1,126 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from argparse import SUPPRESS, ArgumentDefaultsHelpFormatter, ArgumentParser, Namespace
<span class="w"> </span>from collections import OrderedDict
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.config.convert import get_type
<span class="w"> </span>from virtualenv.config.env_var import get_env_var
<span class="w"> </span>from virtualenv.config.ini import IniConfig


<span class="w"> </span>class VirtualEnvOptions(Namespace):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, **kwargs) -&gt;None:</span>
<span class="gi">+    def __init__(self, **kwargs) -&gt; None:</span>
<span class="w"> </span>        super().__init__(**kwargs)
<span class="w"> </span>        self._src = None
<span class="w"> </span>        self._sources = {}

<span class="gd">-    def __setattr__(self, key, value) -&gt;None:</span>
<span class="gd">-        if getattr(self, &#39;_src&#39;, None) is not None:</span>
<span class="gi">+    def set_src(self, key, value, src):</span>
<span class="gi">+        setattr(self, key, value)</span>
<span class="gi">+        if src.startswith(&quot;env var&quot;):</span>
<span class="gi">+            src = &quot;env var&quot;</span>
<span class="gi">+        self._sources[key] = src</span>
<span class="gi">+</span>
<span class="gi">+    def __setattr__(self, key, value) -&gt; None:</span>
<span class="gi">+        if getattr(self, &quot;_src&quot;, None) is not None:</span>
<span class="w"> </span>            self._sources[key] = self._src
<span class="w"> </span>        super().__setattr__(key, value)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&quot;{type(self).__name__}({&#39;, &#39;.join(f&#39;{k}={v}&#39; for k, v in vars(self).items() if not k.startswith(&#39;_&#39;))})&quot;</span>
<span class="gd">-            )</span>
<span class="gi">+    def get_source(self, key):</span>
<span class="gi">+        return self._sources.get(key)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def verbosity(self):</span>
<span class="gi">+        if not hasattr(self, &quot;verbose&quot;) and not hasattr(self, &quot;quiet&quot;):</span>
<span class="gi">+            return None</span>
<span class="gi">+        return max(self.verbose - self.quiet, 0)</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{type(self).__name__}({&#39;, &#39;.join(f&#39;{k}={v}&#39; for k, v in vars(self).items() if not k.startswith(&#39;_&#39;))})&quot;</span>


<span class="w"> </span>class VirtualEnvConfigParser(ArgumentParser):
<span class="w"> </span>    &quot;&quot;&quot;Custom option parser which updates its defaults by checking the configuration files and environmental vars.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, options=None, env=None, *args, **kwargs) -&gt;None:</span>
<span class="gi">+    def __init__(self, options=None, env=None, *args, **kwargs) -&gt; None:</span>
<span class="w"> </span>        env = os.environ if env is None else env
<span class="w"> </span>        self.file_config = IniConfig(env)
<span class="w"> </span>        self.epilog_list = []
<span class="w"> </span>        self.env = env
<span class="gd">-        kwargs[&#39;epilog&#39;] = self.file_config.epilog</span>
<span class="gd">-        kwargs[&#39;add_help&#39;] = False</span>
<span class="gd">-        kwargs[&#39;formatter_class&#39;] = HelpFormatter</span>
<span class="gd">-        kwargs[&#39;prog&#39;] = &#39;virtualenv&#39;</span>
<span class="gi">+        kwargs[&quot;epilog&quot;] = self.file_config.epilog</span>
<span class="gi">+        kwargs[&quot;add_help&quot;] = False</span>
<span class="gi">+        kwargs[&quot;formatter_class&quot;] = HelpFormatter</span>
<span class="gi">+        kwargs[&quot;prog&quot;] = &quot;virtualenv&quot;</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        self._fixed = set()
<span class="w"> </span>        if options is not None and not isinstance(options, VirtualEnvOptions):
<span class="gd">-            msg = &#39;options must be of type VirtualEnvOptions&#39;</span>
<span class="gi">+            msg = &quot;options must be of type VirtualEnvOptions&quot;</span>
<span class="w"> </span>            raise TypeError(msg)
<span class="w"> </span>        self.options = VirtualEnvOptions() if options is None else options
<span class="w"> </span>        self._interpreter = None
<span class="w"> </span>        self._app_data = None

<span class="gi">+    def _fix_defaults(self):</span>
<span class="gi">+        for action in self._actions:</span>
<span class="gi">+            action_id = id(action)</span>
<span class="gi">+            if action_id not in self._fixed:</span>
<span class="gi">+                self._fix_default(action)</span>
<span class="gi">+                self._fixed.add(action_id)</span>

<span class="gd">-class HelpFormatter(ArgumentDefaultsHelpFormatter):</span>
<span class="gi">+    def _fix_default(self, action):</span>
<span class="gi">+        if hasattr(action, &quot;default&quot;) and hasattr(action, &quot;dest&quot;) and action.default != SUPPRESS:</span>
<span class="gi">+            as_type = get_type(action)</span>
<span class="gi">+            names = OrderedDict((i.lstrip(&quot;-&quot;).replace(&quot;-&quot;, &quot;_&quot;), None) for i in action.option_strings)</span>
<span class="gi">+            outcome = None</span>
<span class="gi">+            for name in names:</span>
<span class="gi">+                outcome = get_env_var(name, as_type, self.env)</span>
<span class="gi">+                if outcome is not None:</span>
<span class="gi">+                    break</span>
<span class="gi">+            if outcome is None and self.file_config:</span>
<span class="gi">+                for name in names:</span>
<span class="gi">+                    outcome = self.file_config.get(name, as_type)</span>
<span class="gi">+                    if outcome is not None:</span>
<span class="gi">+                        break</span>
<span class="gi">+            if outcome is not None:</span>
<span class="gi">+                action.default, action.default_source = outcome</span>
<span class="gi">+            else:</span>
<span class="gi">+                outcome = action.default, &quot;default&quot;</span>
<span class="gi">+            self.options.set_src(action.dest, *outcome)</span>
<span class="gi">+</span>
<span class="gi">+    def enable_help(self):</span>
<span class="gi">+        self._fix_defaults()</span>
<span class="gi">+        self.add_argument(&quot;-h&quot;, &quot;--help&quot;, action=&quot;help&quot;, default=SUPPRESS, help=&quot;show this help message and exit&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_known_args(self, args=None, namespace=None):</span>
<span class="gi">+        if namespace is None:</span>
<span class="gi">+            namespace = self.options</span>
<span class="gi">+        elif namespace is not self.options:</span>
<span class="gi">+            msg = &quot;can only pass in parser.options&quot;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+        self._fix_defaults()</span>
<span class="gi">+        self.options._src = &quot;cli&quot;  # noqa: SLF001</span>
<span class="gi">+        try:</span>
<span class="gi">+            namespace.env = self.env</span>
<span class="gi">+            return super().parse_known_args(args, namespace=namespace)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.options._src = None  # noqa: SLF001</span>

<span class="gd">-    def __init__(self, prog) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class HelpFormatter(ArgumentDefaultsHelpFormatter):</span>
<span class="gi">+    def __init__(self, prog) -&gt; None:</span>
<span class="w"> </span>        super().__init__(prog, max_help_position=32, width=240)

<span class="gi">+    def _get_help_string(self, action):</span>
<span class="gi">+        text = super()._get_help_string(action)</span>
<span class="gi">+        if hasattr(action, &quot;default_source&quot;):</span>
<span class="gi">+            default = &quot; (default: %(default)s)&quot;</span>
<span class="gi">+            if text.endswith(default):</span>
<span class="gi">+                text = f&quot;{text[: -len(default)]} (default: %(default)s -&gt; from %(default_source)s)&quot;</span>
<span class="gi">+        return text</span>
<span class="gi">+</span>

<span class="gd">-__all__ = [&#39;HelpFormatter&#39;, &#39;VirtualEnvConfigParser&#39;, &#39;VirtualEnvOptions&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;HelpFormatter&quot;,</span>
<span class="gi">+    &quot;VirtualEnvConfigParser&quot;,</span>
<span class="gi">+    &quot;VirtualEnvOptions&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/config/convert.py b/src/virtualenv/config/convert.py</span>
<span class="gh">index d0fdefb..ecd9d2b 100644</span>
<span class="gd">--- a/src/virtualenv/config/convert.py</span>
<span class="gi">+++ b/src/virtualenv/config/convert.py</span>
<span class="gu">@@ -1,36 +1,59 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="w"> </span>from typing import ClassVar


<span class="w"> </span>class TypeData:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, default_type, as_type) -&gt;None:</span>
<span class="gi">+    def __init__(self, default_type, as_type) -&gt; None:</span>
<span class="w"> </span>        self.default_type = default_type
<span class="w"> </span>        self.as_type = as_type

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;{self.__class__.__name__}(base={self.default_type}, as={self.as_type})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}(base={self.default_type}, as={self.as_type})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def convert(self, value):</span>
<span class="gi">+        return self.default_type(value)</span>


<span class="w"> </span>class BoolType(TypeData):
<span class="gd">-    BOOLEAN_STATES: ClassVar[dict[str, bool]] = {&#39;1&#39;: True, &#39;yes&#39;: True,</span>
<span class="gd">-        &#39;true&#39;: True, &#39;on&#39;: True, &#39;0&#39;: False, &#39;no&#39;: False, &#39;false&#39;: False,</span>
<span class="gd">-        &#39;off&#39;: False}</span>
<span class="gi">+    BOOLEAN_STATES: ClassVar[dict[str, bool]] = {</span>
<span class="gi">+        &quot;1&quot;: True,</span>
<span class="gi">+        &quot;yes&quot;: True,</span>
<span class="gi">+        &quot;true&quot;: True,</span>
<span class="gi">+        &quot;on&quot;: True,</span>
<span class="gi">+        &quot;0&quot;: False,</span>
<span class="gi">+        &quot;no&quot;: False,</span>
<span class="gi">+        &quot;false&quot;: False,</span>
<span class="gi">+        &quot;off&quot;: False,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def convert(self, value):</span>
<span class="gi">+        if value.lower() not in self.BOOLEAN_STATES:</span>
<span class="gi">+            msg = f&quot;Not a boolean: {value}&quot;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+        return self.BOOLEAN_STATES[value.lower()]</span>


<span class="w"> </span>class NoneType(TypeData):
<span class="gd">-    pass</span>
<span class="gi">+    def convert(self, value):</span>
<span class="gi">+        if not value:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return str(value)</span>


<span class="w"> </span>class ListType(TypeData):
<span class="gd">-</span>
<span class="w"> </span>    def _validate(self):
<span class="w"> </span>        &quot;&quot;&quot;no op.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+    def convert(self, value, flatten=True):  # noqa: ARG002, FBT002</span>
<span class="gi">+        values = self.split_values(value)</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for a_value in values:</span>
<span class="gi">+            sub_values = a_value.split(os.pathsep)</span>
<span class="gi">+            result.extend(sub_values)</span>
<span class="gi">+        return [self.as_type(i) for i in result]</span>

<span class="w"> </span>    def split_values(self, value):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -39,13 +62,39 @@ class ListType(TypeData):</span>
<span class="w"> </span>        First this is done by newlines. If there were no newlines in the text,
<span class="w"> </span>        then we next try to split by comma.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(value, (str, bytes)):</span>
<span class="gi">+            # Use `splitlines` rather than a custom check for whether there is</span>
<span class="gi">+            # more than one line. This ensures that the full `splitlines()`</span>
<span class="gi">+            # logic is supported here.</span>
<span class="gi">+            values = value.splitlines()</span>
<span class="gi">+            if len(values) &lt;= 1:</span>
<span class="gi">+                values = value.split(&quot;,&quot;)</span>
<span class="gi">+            values = filter(None, [x.strip() for x in values])</span>
<span class="gi">+        else:</span>
<span class="gi">+            values = list(value)</span>
<span class="gi">+</span>
<span class="gi">+        return values</span>


<span class="w"> </span>def convert(value, as_type, source):
<span class="w"> </span>    &quot;&quot;&quot;Convert the value as a given type where the value comes from the given source.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return as_type.convert(value)</span>
<span class="gi">+    except Exception as exception:</span>
<span class="gi">+        logging.warning(&quot;%s failed to convert %r as %r because %r&quot;, source, value, as_type, exception)</span>
<span class="gi">+        raise</span>


<span class="w"> </span>_CONVERT = {bool: BoolType, type(None): NoneType, list: ListType}
<span class="gd">-__all__ = [&#39;convert&#39;, &#39;get_type&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_type(action):</span>
<span class="gi">+    default_type = type(action.default)</span>
<span class="gi">+    as_type = default_type if action.type is None else action.type</span>
<span class="gi">+    return _CONVERT.get(default_type, TypeData)(default_type, as_type)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;convert&quot;,</span>
<span class="gi">+    &quot;get_type&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/config/env_var.py b/src/virtualenv/config/env_var.py</span>
<span class="gh">index 1c12a68..e127234 100644</span>
<span class="gd">--- a/src/virtualenv/config/env_var.py</span>
<span class="gi">+++ b/src/virtualenv/config/env_var.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from contextlib import suppress
<span class="gi">+</span>
<span class="w"> </span>from .convert import convert


<span class="gu">@@ -12,7 +14,17 @@ def get_env_var(key, as_type, env):</span>
<span class="w"> </span>    :param env: environment variables to use
<span class="w"> </span>    :return:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    environ_key = f&quot;VIRTUALENV_{key.upper()}&quot;</span>
<span class="gi">+    if env.get(environ_key):</span>
<span class="gi">+        value = env[environ_key]</span>
<span class="gi">+</span>
<span class="gi">+        with suppress(Exception):  # note the converter already logs a warning when failures happen</span>
<span class="gi">+            source = f&quot;env var {environ_key}&quot;</span>
<span class="gi">+            as_type = convert(value, as_type, source)</span>
<span class="gi">+            return as_type, source</span>
<span class="gi">+    return None</span>


<span class="gd">-__all__ = [&#39;get_env_var&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;get_env_var&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/config/ini.py b/src/virtualenv/config/ini.py</span>
<span class="gh">index 572f07e..cd6ecf5 100644</span>
<span class="gd">--- a/src/virtualenv/config/ini.py</span>
<span class="gi">+++ b/src/virtualenv/config/ini.py</span>
<span class="gu">@@ -1,30 +1,33 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="w"> </span>from configparser import ConfigParser
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import ClassVar
<span class="gi">+</span>
<span class="w"> </span>from platformdirs import user_config_dir
<span class="gi">+</span>
<span class="w"> </span>from .convert import convert


<span class="w"> </span>class IniConfig:
<span class="gd">-    VIRTUALENV_CONFIG_FILE_ENV_VAR: ClassVar[str] = &#39;VIRTUALENV_CONFIG_FILE&#39;</span>
<span class="gd">-    STATE: ClassVar[dict[bool | None, str]] = {None: &#39;failed to parse&#39;, (</span>
<span class="gd">-        True): &#39;active&#39;, (False): &#39;missing&#39;}</span>
<span class="gd">-    section = &#39;virtualenv&#39;</span>
<span class="gi">+    VIRTUALENV_CONFIG_FILE_ENV_VAR: ClassVar[str] = &quot;VIRTUALENV_CONFIG_FILE&quot;</span>
<span class="gi">+    STATE: ClassVar[dict[bool | None, str]] = {None: &quot;failed to parse&quot;, True: &quot;active&quot;, False: &quot;missing&quot;}</span>

<span class="gd">-    def __init__(self, env=None) -&gt;None:</span>
<span class="gi">+    section = &quot;virtualenv&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, env=None) -&gt; None:</span>
<span class="w"> </span>        env = os.environ if env is None else env
<span class="w"> </span>        config_file = env.get(self.VIRTUALENV_CONFIG_FILE_ENV_VAR, None)
<span class="w"> </span>        self.is_env_var = config_file is not None
<span class="w"> </span>        if config_file is None:
<span class="gd">-            config_file = Path(user_config_dir(appname=&#39;virtualenv&#39;,</span>
<span class="gd">-                appauthor=&#39;pypa&#39;)) / &#39;virtualenv.ini&#39;</span>
<span class="gi">+            config_file = Path(user_config_dir(appname=&quot;virtualenv&quot;, appauthor=&quot;pypa&quot;)) / &quot;virtualenv.ini&quot;</span>
<span class="w"> </span>        else:
<span class="w"> </span>            config_file = Path(config_file)
<span class="w"> </span>        self.config_file = config_file
<span class="w"> </span>        self._cache = {}
<span class="gi">+</span>
<span class="w"> </span>        exception = None
<span class="w"> </span>        self.has_config_file = None
<span class="w"> </span>        try:
<span class="gu">@@ -37,13 +40,36 @@ class IniConfig:</span>
<span class="w"> </span>                self.config_parser = ConfigParser()
<span class="w"> </span>                try:
<span class="w"> </span>                    self._load()
<span class="gd">-                    self.has_virtualenv_section = (self.config_parser.</span>
<span class="gd">-                        has_section(self.section))</span>
<span class="gd">-                except Exception as exc:</span>
<span class="gi">+                    self.has_virtualenv_section = self.config_parser.has_section(self.section)</span>
<span class="gi">+                except Exception as exc:  # noqa: BLE001</span>
<span class="w"> </span>                    exception = exc
<span class="w"> </span>        if exception is not None:
<span class="gd">-            logging.error(&#39;failed to read config file %s because %r&#39;,</span>
<span class="gd">-                config_file, exception)</span>
<span class="gi">+            logging.error(&quot;failed to read config file %s because %r&quot;, config_file, exception)</span>

<span class="gd">-    def __bool__(self) -&gt;bool:</span>
<span class="gi">+    def _load(self):</span>
<span class="gi">+        with self.config_file.open(&quot;rt&quot;, encoding=&quot;utf-8&quot;) as file_handler:</span>
<span class="gi">+            return self.config_parser.read_file(file_handler)</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, key, as_type):</span>
<span class="gi">+        cache_key = key, as_type</span>
<span class="gi">+        if cache_key in self._cache:</span>
<span class="gi">+            return self._cache[cache_key]</span>
<span class="gi">+        try:</span>
<span class="gi">+            source = &quot;file&quot;</span>
<span class="gi">+            raw_value = self.config_parser.get(self.section, key.lower())</span>
<span class="gi">+            value = convert(raw_value, as_type, source)</span>
<span class="gi">+            result = value, source</span>
<span class="gi">+        except Exception:  # noqa: BLE001</span>
<span class="gi">+            result = None</span>
<span class="gi">+        self._cache[cache_key] = result</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def __bool__(self) -&gt; bool:</span>
<span class="w"> </span>        return bool(self.has_config_file) and bool(self.has_virtualenv_section)
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def epilog(self):</span>
<span class="gi">+        return (</span>
<span class="gi">+            f&quot;\nconfig file {self.config_file} {self.STATE[self.has_config_file]} &quot;</span>
<span class="gi">+            f&quot;(change{&#39;d&#39; if self.is_env_var else &#39;&#39;} via env var {self.VIRTUALENV_CONFIG_FILE_ENV_VAR})&quot;</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/src/virtualenv/create/creator.py b/src/virtualenv/create/creator.py</span>
<span class="gh">index 96df65b..7a98a51 100644</span>
<span class="gd">--- a/src/virtualenv/create/creator.py</span>
<span class="gi">+++ b/src/virtualenv/create/creator.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import json
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="gu">@@ -8,25 +9,27 @@ from argparse import ArgumentTypeError</span>
<span class="w"> </span>from ast import literal_eval
<span class="w"> </span>from collections import OrderedDict
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.discovery.cached_py_info import LogCmd
<span class="w"> </span>from virtualenv.util.path import safe_delete
<span class="w"> </span>from virtualenv.util.subprocess import run_cmd
<span class="w"> </span>from virtualenv.version import __version__
<span class="gi">+</span>
<span class="w"> </span>from .pyenv_cfg import PyEnvCfg
<span class="gi">+</span>
<span class="w"> </span>HERE = Path(os.path.abspath(__file__)).parent
<span class="gd">-DEBUG_SCRIPT = HERE / &#39;debug.py&#39;</span>
<span class="gi">+DEBUG_SCRIPT = HERE / &quot;debug.py&quot;</span>


<span class="w"> </span>class CreatorMeta:
<span class="gd">-</span>
<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self.error = None


<span class="w"> </span>class Creator(ABC):
<span class="w"> </span>    &quot;&quot;&quot;A class that given a python Interpreter creates a virtual environment.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, options, interpreter) -&gt;None:</span>
<span class="gi">+    def __init__(self, options, interpreter) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Construct a new virtual environment creator.

<span class="gu">@@ -42,23 +45,29 @@ class Creator(ABC):</span>
<span class="w"> </span>        self.app_data = options.app_data
<span class="w"> </span>        self.env = options.env

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&quot;{self.__class__.__name__}({&#39;, &#39;.join(f&#39;{k}={v}&#39; for k, v in self._args())})&quot;</span>
<span class="gd">-            )</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({&#39;, &#39;.join(f&#39;{k}={v}&#39; for k, v in self._args())})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _args(self):</span>
<span class="gi">+        return [</span>
<span class="gi">+            (&quot;dest&quot;, str(self.dest)),</span>
<span class="gi">+            (&quot;clear&quot;, self.clear),</span>
<span class="gi">+            (&quot;no_vcs_ignore&quot;, self.no_vcs_ignore),</span>
<span class="gi">+        ]</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def can_create(cls, interpreter):</span>
<span class="gi">+    def can_create(cls, interpreter):  # noqa: ARG003</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Determine if we can create a virtual environment.

<span class="w"> </span>        :param interpreter: the interpreter in question
<span class="gd">-        :return: ``None`` if we can&#39;t create, any other object otherwise that will be forwarded to                   :meth:`add_parser_arguments`</span>
<span class="gi">+        :return: ``None`` if we can&#39;t create, any other object otherwise that will be forwarded to \</span>
<span class="gi">+                  :meth:`add_parser_arguments`</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def add_parser_arguments(cls, parser, interpreter, meta, app_data):</span>
<span class="gi">+    def add_parser_arguments(cls, parser, interpreter, meta, app_data):  # noqa: ARG003</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Add CLI arguments for the creator.

<span class="gu">@@ -67,26 +76,151 @@ class Creator(ABC):</span>
<span class="w"> </span>        :param interpreter: the interpreter we&#39;re asked to create virtual environment for
<span class="w"> </span>        :param meta: value as returned by :meth:`can_create`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parser.add_argument(</span>
<span class="gi">+            &quot;dest&quot;,</span>
<span class="gi">+            help=&quot;directory to create virtualenv at&quot;,</span>
<span class="gi">+            type=cls.validate_dest,</span>
<span class="gi">+        )</span>
<span class="gi">+        parser.add_argument(</span>
<span class="gi">+            &quot;--clear&quot;,</span>
<span class="gi">+            dest=&quot;clear&quot;,</span>
<span class="gi">+            action=&quot;store_true&quot;,</span>
<span class="gi">+            help=&quot;remove the destination directory if exist before starting (will overwrite files otherwise)&quot;,</span>
<span class="gi">+            default=False,</span>
<span class="gi">+        )</span>
<span class="gi">+        parser.add_argument(</span>
<span class="gi">+            &quot;--no-vcs-ignore&quot;,</span>
<span class="gi">+            dest=&quot;no_vcs_ignore&quot;,</span>
<span class="gi">+            action=&quot;store_true&quot;,</span>
<span class="gi">+            help=&quot;don&#39;t create VCS ignore directive in the destination directory&quot;,</span>
<span class="gi">+            default=False,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def create(self):
<span class="w"> </span>        &quot;&quot;&quot;Perform the virtual environment creation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def validate_dest(cls, raw_value):</span>
<span class="gi">+    def validate_dest(cls, raw_value):  # noqa: C901</span>
<span class="w"> </span>        &quot;&quot;&quot;No path separator in the path, valid chars and must be write-able.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def non_write_able(dest, value):</span>
<span class="gi">+            common = Path(*os.path.commonprefix([value.parts, dest.parts]))</span>
<span class="gi">+            msg = f&quot;the destination {dest.relative_to(common)} is not write-able at {common}&quot;</span>
<span class="gi">+            raise ArgumentTypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        # the file system must be able to encode</span>
<span class="gi">+        # note in newer CPython this is always utf-8 https://www.python.org/dev/peps/pep-0529/</span>
<span class="gi">+        encoding = sys.getfilesystemencoding()</span>
<span class="gi">+        refused = OrderedDict()</span>
<span class="gi">+        kwargs = {&quot;errors&quot;: &quot;ignore&quot;} if encoding != &quot;mbcs&quot; else {}</span>
<span class="gi">+        for char in str(raw_value):</span>
<span class="gi">+            try:</span>
<span class="gi">+                trip = char.encode(encoding, **kwargs).decode(encoding)</span>
<span class="gi">+                if trip == char:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                raise ValueError(trip)  # noqa: TRY301</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                refused[char] = None</span>
<span class="gi">+        if refused:</span>
<span class="gi">+            bad = &quot;&quot;.join(refused.keys())</span>
<span class="gi">+            msg = f&quot;the file system codec ({encoding}) cannot handle characters {bad!r} within {raw_value!r}&quot;</span>
<span class="gi">+            raise ArgumentTypeError(msg)</span>
<span class="gi">+        if os.pathsep in raw_value:</span>
<span class="gi">+            msg = (</span>
<span class="gi">+                f&quot;destination {raw_value!r} must not contain the path separator ({os.pathsep})&quot;</span>
<span class="gi">+                f&quot; as this would break the activation scripts&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            raise ArgumentTypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        value = Path(raw_value)</span>
<span class="gi">+        if value.exists() and value.is_file():</span>
<span class="gi">+            msg = f&quot;the destination {value} already exists and is a file&quot;</span>
<span class="gi">+            raise ArgumentTypeError(msg)</span>
<span class="gi">+        dest = Path(os.path.abspath(str(value))).resolve()  # on Windows absolute does not imply resolve so use both</span>
<span class="gi">+        value = dest</span>
<span class="gi">+        while dest:</span>
<span class="gi">+            if dest.exists():</span>
<span class="gi">+                if os.access(str(dest), os.W_OK):</span>
<span class="gi">+                    break</span>
<span class="gi">+                non_write_able(dest, value)</span>
<span class="gi">+            base, _ = dest.parent, dest.name</span>
<span class="gi">+            if base == dest:</span>
<span class="gi">+                non_write_able(dest, value)  # pragma: no cover</span>
<span class="gi">+            dest = base</span>
<span class="gi">+        return str(value)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self):</span>
<span class="gi">+        if self.dest.exists() and self.clear:</span>
<span class="gi">+            logging.debug(&quot;delete %s&quot;, self.dest)</span>
<span class="gi">+            safe_delete(self.dest)</span>
<span class="gi">+        self.create()</span>
<span class="gi">+        self.set_pyenv_cfg()</span>
<span class="gi">+        if not self.no_vcs_ignore:</span>
<span class="gi">+            self.setup_ignore_vcs()</span>
<span class="gi">+</span>
<span class="gi">+    def set_pyenv_cfg(self):</span>
<span class="gi">+        self.pyenv_cfg.content = OrderedDict()</span>
<span class="gi">+        self.pyenv_cfg[&quot;home&quot;] = os.path.dirname(os.path.abspath(self.interpreter.system_executable))</span>
<span class="gi">+        self.pyenv_cfg[&quot;implementation&quot;] = self.interpreter.implementation</span>
<span class="gi">+        self.pyenv_cfg[&quot;version_info&quot;] = &quot;.&quot;.join(str(i) for i in self.interpreter.version_info)</span>
<span class="gi">+        self.pyenv_cfg[&quot;virtualenv&quot;] = __version__</span>

<span class="w"> </span>    def setup_ignore_vcs(self):
<span class="w"> </span>        &quot;&quot;&quot;Generate ignore instructions for version control systems.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # mark this folder to be ignored by VCS, handle https://www.python.org/dev/peps/pep-0610/#registered-vcs</span>
<span class="gi">+        git_ignore = self.dest / &quot;.gitignore&quot;</span>
<span class="gi">+        if not git_ignore.exists():</span>
<span class="gi">+            git_ignore.write_text(&quot;# created by virtualenv automatically\n*\n&quot;, encoding=&quot;utf-8&quot;)</span>
<span class="gi">+        # Mercurial - does not support the .hgignore file inside a subdirectory directly, but only if included via the</span>
<span class="gi">+        # subinclude directive from root, at which point on might as well ignore the directory itself, see</span>
<span class="gi">+        # https://www.selenic.com/mercurial/hgignore.5.html for more details</span>
<span class="gi">+        # Bazaar - does not support ignore files in sub-directories, only at root level via .bzrignore</span>
<span class="gi">+        # Subversion - does not support ignore files, requires direct manipulation with the svn tool</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def debug(self):
<span class="w"> </span>        &quot;&quot;&quot;:return: debug information about the virtual environment (only valid after :meth:`create` has run)&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-__all__ = [&#39;Creator&#39;, &#39;CreatorMeta&#39;]</span>
<span class="gi">+        if self._debug is None and self.exe is not None:</span>
<span class="gi">+            self._debug = get_env_debug_info(self.exe, self.debug_script(), self.app_data, self.env)</span>
<span class="gi">+        return self._debug</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def debug_script():</span>
<span class="gi">+        return DEBUG_SCRIPT</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_env_debug_info(env_exe, debug_script, app_data, env):</span>
<span class="gi">+    env = env.copy()</span>
<span class="gi">+    env.pop(&quot;PYTHONPATH&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+    with app_data.ensure_extracted(debug_script) as debug_script_extracted:</span>
<span class="gi">+        cmd = [str(env_exe), str(debug_script_extracted)]</span>
<span class="gi">+        logging.debug(&quot;debug via %r&quot;, LogCmd(cmd))</span>
<span class="gi">+        code, out, err = run_cmd(cmd)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        if code != 0:</span>
<span class="gi">+            if out:</span>
<span class="gi">+                result = literal_eval(out)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if code == 2 and &quot;file&quot; in err:  # noqa: PLR2004</span>
<span class="gi">+                    # Re-raise FileNotFoundError from `run_cmd()`</span>
<span class="gi">+                    raise OSError(err)  # noqa: TRY301</span>
<span class="gi">+                raise Exception(err)  # noqa: TRY002, TRY301</span>
<span class="gi">+        else:</span>
<span class="gi">+            result = json.loads(out)</span>
<span class="gi">+        if err:</span>
<span class="gi">+            result[&quot;err&quot;] = err</span>
<span class="gi">+    except Exception as exception:  # noqa: BLE001</span>
<span class="gi">+        return {&quot;out&quot;: out, &quot;err&quot;: err, &quot;returncode&quot;: code, &quot;exception&quot;: repr(exception)}</span>
<span class="gi">+    if &quot;sys&quot; in result and &quot;path&quot; in result[&quot;sys&quot;]:</span>
<span class="gi">+        del result[&quot;sys&quot;][&quot;path&quot;][0]</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Creator&quot;,</span>
<span class="gi">+    &quot;CreatorMeta&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/create/debug.py b/src/virtualenv/create/debug.py</span>
<span class="gh">index e728f1f..8a4845e 100644</span>
<span class="gd">--- a/src/virtualenv/create/debug.py</span>
<span class="gi">+++ b/src/virtualenv/create/debug.py</span>
<span class="gu">@@ -1,12 +1,102 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Inspect a target Python interpreter virtual environment wise.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gd">-import sys</span>
<span class="gi">+</span>
<span class="gi">+import sys  # built-in</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def encode_path(value):</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    if not isinstance(value, (str, bytes)):</span>
<span class="gi">+        value = repr(value) if isinstance(value, type) else repr(type(value))</span>
<span class="gi">+    if isinstance(value, bytes):</span>
<span class="gi">+        value = value.decode(sys.getfilesystemencoding())</span>
<span class="gi">+    return value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def encode_list_path(value):</span>
<span class="gi">+    return [encode_path(i) for i in value]</span>


<span class="w"> </span>def run():
<span class="w"> </span>    &quot;&quot;&quot;Print debug data about the virtual environment.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        from collections import OrderedDict  # noqa: PLC0415</span>
<span class="gi">+    except ImportError:  # pragma: no cover</span>
<span class="gi">+        # this is possible if the standard library cannot be accessed</span>
<span class="gi">+</span>
<span class="gi">+        OrderedDict = dict  # pragma: no cover  # noqa: N806</span>
<span class="gi">+    result = OrderedDict([(&quot;sys&quot;, OrderedDict())])</span>
<span class="gi">+    path_keys = (</span>
<span class="gi">+        &quot;executable&quot;,</span>
<span class="gi">+        &quot;_base_executable&quot;,</span>
<span class="gi">+        &quot;prefix&quot;,</span>
<span class="gi">+        &quot;base_prefix&quot;,</span>
<span class="gi">+        &quot;real_prefix&quot;,</span>
<span class="gi">+        &quot;exec_prefix&quot;,</span>
<span class="gi">+        &quot;base_exec_prefix&quot;,</span>
<span class="gi">+        &quot;path&quot;,</span>
<span class="gi">+        &quot;meta_path&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    for key in path_keys:</span>
<span class="gi">+        value = getattr(sys, key, None)</span>
<span class="gi">+        value = encode_list_path(value) if isinstance(value, list) else encode_path(value)</span>
<span class="gi">+        result[&quot;sys&quot;][key] = value</span>
<span class="gi">+    result[&quot;sys&quot;][&quot;fs_encoding&quot;] = sys.getfilesystemencoding()</span>
<span class="gi">+    result[&quot;sys&quot;][&quot;io_encoding&quot;] = getattr(sys.stdout, &quot;encoding&quot;, None)</span>
<span class="gi">+    result[&quot;version&quot;] = sys.version</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        import sysconfig  # noqa: PLC0415</span>
<span class="gi">+</span>
<span class="gi">+        # https://bugs.python.org/issue22199</span>
<span class="gi">+        makefile = getattr(sysconfig, &quot;get_makefile_filename&quot;, getattr(sysconfig, &quot;_get_makefile_filename&quot;, None))</span>
<span class="gi">+        result[&quot;makefile_filename&quot;] = encode_path(makefile())</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    import os  # landmark  # noqa: PLC0415</span>
<span class="gi">+</span>
<span class="gi">+    result[&quot;os&quot;] = repr(os)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        import site  # site  # noqa: PLC0415</span>
<span class="gi">+</span>
<span class="gi">+        result[&quot;site&quot;] = repr(site)</span>
<span class="gi">+    except ImportError as exception:  # pragma: no cover</span>
<span class="gi">+        result[&quot;site&quot;] = repr(exception)  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        import datetime  # site  # noqa: PLC0415</span>
<span class="gi">+</span>
<span class="gi">+        result[&quot;datetime&quot;] = repr(datetime)</span>
<span class="gi">+    except ImportError as exception:  # pragma: no cover</span>
<span class="gi">+        result[&quot;datetime&quot;] = repr(exception)  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        import math  # site  # noqa: PLC0415</span>
<span class="gi">+</span>
<span class="gi">+        result[&quot;math&quot;] = repr(math)</span>
<span class="gi">+    except ImportError as exception:  # pragma: no cover</span>
<span class="gi">+        result[&quot;math&quot;] = repr(exception)  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    # try to print out, this will validate if other core modules are available (json in this case)</span>
<span class="gi">+    try:</span>
<span class="gi">+        import json  # noqa: PLC0415</span>
<span class="gi">+</span>
<span class="gi">+        result[&quot;json&quot;] = repr(json)</span>
<span class="gi">+    except ImportError as exception:</span>
<span class="gi">+        result[&quot;json&quot;] = repr(exception)</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            content = json.dumps(result, indent=2)</span>
<span class="gi">+            sys.stdout.write(content)</span>
<span class="gi">+        except (ValueError, TypeError) as exception:  # pragma: no cover</span>
<span class="gi">+            sys.stderr.write(repr(exception))</span>
<span class="gi">+            sys.stdout.write(repr(result))  # pragma: no cover</span>
<span class="gi">+            raise SystemExit(1)  # noqa: B904  # pragma: no cover</span>


<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    run()
<span class="gh">diff --git a/src/virtualenv/create/describe.py b/src/virtualenv/create/describe.py</span>
<span class="gh">index 5d7690c..1ee250c 100644</span>
<span class="gd">--- a/src/virtualenv/create/describe.py</span>
<span class="gi">+++ b/src/virtualenv/create/describe.py</span>
<span class="gu">@@ -1,15 +1,18 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABC
<span class="w"> </span>from collections import OrderedDict
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.info import IS_WIN


<span class="w"> </span>class Describe:
<span class="w"> </span>    &quot;&quot;&quot;Given a host interpreter tell us information about what the created interpreter might look like.&quot;&quot;&quot;
<span class="gd">-    suffix = &#39;.exe&#39; if IS_WIN else &#39;&#39;</span>

<span class="gd">-    def __init__(self, dest, interpreter) -&gt;None:</span>
<span class="gi">+    suffix = &quot;.exe&quot; if IS_WIN else &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, dest, interpreter) -&gt; None:</span>
<span class="w"> </span>        self.interpreter = interpreter
<span class="w"> </span>        self.dest = dest
<span class="w"> </span>        self._stdlib = None
<span class="gu">@@ -17,27 +20,91 @@ class Describe:</span>
<span class="w"> </span>        self._system_stdlib = None
<span class="w"> </span>        self._conf_vars = None

<span class="gi">+    @property</span>
<span class="gi">+    def bin_dir(self):</span>
<span class="gi">+        return self.script_dir</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def script_dir(self):</span>
<span class="gi">+        return self.dest / self.interpreter.install_path(&quot;scripts&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def purelib(self):</span>
<span class="gi">+        return self.dest / self.interpreter.install_path(&quot;purelib&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def platlib(self):</span>
<span class="gi">+        return self.dest / self.interpreter.install_path(&quot;platlib&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def libs(self):</span>
<span class="gi">+        return list(OrderedDict(((self.platlib, None), (self.purelib, None))).keys())</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def stdlib(self):</span>
<span class="gi">+        if self._stdlib is None:</span>
<span class="gi">+            self._stdlib = Path(self.interpreter.sysconfig_path(&quot;stdlib&quot;, config_var=self._config_vars))</span>
<span class="gi">+        return self._stdlib</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def stdlib_platform(self):</span>
<span class="gi">+        if self._stdlib_platform is None:</span>
<span class="gi">+            self._stdlib_platform = Path(self.interpreter.sysconfig_path(&quot;platstdlib&quot;, config_var=self._config_vars))</span>
<span class="gi">+        return self._stdlib_platform</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _config_vars(self):</span>
<span class="gi">+        if self._conf_vars is None:</span>
<span class="gi">+            self._conf_vars = self._calc_config_vars(self.dest)</span>
<span class="gi">+        return self._conf_vars</span>
<span class="gi">+</span>
<span class="gi">+    def _calc_config_vars(self, to):</span>
<span class="gi">+        sys_vars = self.interpreter.sysconfig_vars</span>
<span class="gi">+        return {k: (to if v is not None and v.startswith(self.interpreter.prefix) else v) for k, v in sys_vars.items()}</span>
<span class="gi">+</span>
<span class="w"> </span>    @classmethod
<span class="gd">-    def can_describe(cls, interpreter):</span>
<span class="gi">+    def can_describe(cls, interpreter):  # noqa: ARG003</span>
<span class="w"> </span>        &quot;&quot;&quot;Knows means it knows how the output will look.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def env_name(self):</span>
<span class="gi">+        return self.dest.parts[-1]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def exe(self):</span>
<span class="gi">+        return self.bin_dir / f&quot;{self.exe_stem()}{self.suffix}&quot;</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def exe_stem(cls):
<span class="w"> </span>        &quot;&quot;&quot;Executable name without suffix - there seems to be no standard way to get this without creating it.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def script(self, name):</span>
<span class="gi">+        return self.script_dir / f&quot;{name}{self.suffix}&quot;</span>


<span class="w"> </span>class Python3Supports(Describe, ABC):
<span class="gd">-    pass</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def can_describe(cls, interpreter):</span>
<span class="gi">+        return interpreter.version_info.major == 3 and super().can_describe(interpreter)  # noqa: PLR2004</span>


<span class="w"> </span>class PosixSupports(Describe, ABC):
<span class="gd">-    pass</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def can_describe(cls, interpreter):</span>
<span class="gi">+        return interpreter.os == &quot;posix&quot; and super().can_describe(interpreter)</span>


<span class="w"> </span>class WindowsSupports(Describe, ABC):
<span class="gd">-    pass</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def can_describe(cls, interpreter):</span>
<span class="gi">+        return interpreter.os == &quot;nt&quot; and super().can_describe(interpreter)</span>


<span class="gd">-__all__ = [&#39;Describe&#39;, &#39;PosixSupports&#39;, &#39;Python3Supports&#39;, &#39;WindowsSupports&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Describe&quot;,</span>
<span class="gi">+    &quot;PosixSupports&quot;,</span>
<span class="gi">+    &quot;Python3Supports&quot;,</span>
<span class="gi">+    &quot;WindowsSupports&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/create/pyenv_cfg.py b/src/virtualenv/create/pyenv_cfg.py</span>
<span class="gh">index a47c2ac..04883de 100644</span>
<span class="gd">--- a/src/virtualenv/create/pyenv_cfg.py</span>
<span class="gi">+++ b/src/virtualenv/create/pyenv_cfg.py</span>
<span class="gu">@@ -1,26 +1,66 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="w"> </span>from collections import OrderedDict


<span class="w"> </span>class PyEnvCfg:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, content, path) -&gt;None:</span>
<span class="gi">+    def __init__(self, content, path) -&gt; None:</span>
<span class="w"> </span>        self.content = content
<span class="w"> </span>        self.path = path

<span class="gd">-    def __setitem__(self, key, value) -&gt;None:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_folder(cls, folder):</span>
<span class="gi">+        return cls.from_file(folder / &quot;pyvenv.cfg&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_file(cls, path):</span>
<span class="gi">+        content = cls._read_values(path) if path.exists() else OrderedDict()</span>
<span class="gi">+        return PyEnvCfg(content, path)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _read_values(path):</span>
<span class="gi">+        content = OrderedDict()</span>
<span class="gi">+        for line in path.read_text(encoding=&quot;utf-8&quot;).splitlines():</span>
<span class="gi">+            equals_at = line.index(&quot;=&quot;)</span>
<span class="gi">+            key = line[:equals_at].strip()</span>
<span class="gi">+            value = line[equals_at + 1 :].strip()</span>
<span class="gi">+            content[key] = value</span>
<span class="gi">+        return content</span>
<span class="gi">+</span>
<span class="gi">+    def write(self):</span>
<span class="gi">+        logging.debug(&quot;write %s&quot;, self.path)</span>
<span class="gi">+        text = &quot;&quot;</span>
<span class="gi">+        for key, value in self.content.items():</span>
<span class="gi">+            normalized_value = os.path.realpath(value) if value and os.path.exists(value) else value</span>
<span class="gi">+            line = f&quot;{key} = {normalized_value}&quot;</span>
<span class="gi">+            logging.debug(&quot;\t%s&quot;, line)</span>
<span class="gi">+            text += line</span>
<span class="gi">+            text += &quot;\n&quot;</span>
<span class="gi">+        self.path.write_text(text, encoding=&quot;utf-8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def refresh(self):</span>
<span class="gi">+        self.content = self._read_values(self.path)</span>
<span class="gi">+        return self.content</span>
<span class="gi">+</span>
<span class="gi">+    def __setitem__(self, key, value) -&gt; None:</span>
<span class="w"> </span>        self.content[key] = value

<span class="w"> </span>    def __getitem__(self, key):
<span class="w"> </span>        return self.content[key]

<span class="gd">-    def __contains__(self, item) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, item) -&gt; bool:</span>
<span class="w"> </span>        return item in self.content

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}(path={self.path})&#39;</span>
<span class="gi">+    def update(self, other):</span>
<span class="gi">+        self.content.update(other)</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}(path={self.path})&quot;</span>


<span class="gd">-__all__ = [&#39;PyEnvCfg&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;PyEnvCfg&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/create/via_global_ref/_virtualenv.py b/src/virtualenv/create/via_global_ref/_virtualenv.py</span>
<span class="gh">index e27c1e4..b61db30 100644</span>
<span class="gd">--- a/src/virtualenv/create/via_global_ref/_virtualenv.py</span>
<span class="gi">+++ b/src/virtualenv/create/via_global_ref/_virtualenv.py</span>
<span class="gu">@@ -1,7 +1,10 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Patches that are applied at runtime to the virtual environment.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>VIRTUALENV_PATCH_FILE = os.path.join(__file__)


<span class="gu">@@ -11,17 +14,90 @@ def patch_dist(dist):</span>
<span class="w"> </span>    https://docs.python.org/3/install/index.html#distutils-configuration-files.

<span class="w"> </span>    Some of this arguments though don&#39;t make sense in context of the virtual environment files, let&#39;s fix them up.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;  # noqa: D205</span>
<span class="gi">+    # we cannot allow some install config as that would get packages installed outside of the virtual environment</span>
<span class="gi">+    old_parse_config_files = dist.Distribution.parse_config_files</span>

<span class="gi">+    def parse_config_files(self, *args, **kwargs):</span>
<span class="gi">+        result = old_parse_config_files(self, *args, **kwargs)</span>
<span class="gi">+        install = self.get_option_dict(&quot;install&quot;)</span>

<span class="gd">-_DISTUTILS_PATCH = &#39;distutils.dist&#39;, &#39;setuptools.dist&#39;</span>
<span class="gi">+        if &quot;prefix&quot; in install:  # the prefix governs where to install the libraries</span>
<span class="gi">+            install[&quot;prefix&quot;] = VIRTUALENV_PATCH_FILE, os.path.abspath(sys.prefix)</span>
<span class="gi">+        for base in (&quot;purelib&quot;, &quot;platlib&quot;, &quot;headers&quot;, &quot;scripts&quot;, &quot;data&quot;):</span>
<span class="gi">+            key = f&quot;install_{base}&quot;</span>
<span class="gi">+            if key in install:  # do not allow global configs to hijack venv paths</span>
<span class="gi">+                install.pop(key, None)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    dist.Distribution.parse_config_files = parse_config_files</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Import hook that patches some modules to ignore configuration values that break package installation in case</span>
<span class="gi">+# of virtual environments.</span>
<span class="gi">+_DISTUTILS_PATCH = &quot;distutils.dist&quot;, &quot;setuptools.dist&quot;</span>
<span class="gi">+# https://docs.python.org/3/library/importlib.html#setting-up-an-importer</span>


<span class="w"> </span>class _Finder:
<span class="w"> </span>    &quot;&quot;&quot;A meta path finder that allows patching the imported distutils modules.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    fullname = None
<span class="gd">-    lock = []</span>
<span class="gi">+</span>
<span class="gi">+    # lock[0] is threading.Lock(), but initialized lazily to avoid importing threading very early at startup,</span>
<span class="gi">+    # because there are gevent-based applications that need to be first to import threading by themselves.</span>
<span class="gi">+    # See https://github.com/pypa/virtualenv/issues/1895 for details.</span>
<span class="gi">+    lock = []  # noqa: RUF012</span>
<span class="gi">+</span>
<span class="gi">+    def find_spec(self, fullname, path, target=None):  # noqa: ARG002</span>
<span class="gi">+        if fullname in _DISTUTILS_PATCH and self.fullname is None:  # noqa: PLR1702</span>
<span class="gi">+            # initialize lock[0] lazily</span>
<span class="gi">+            if len(self.lock) == 0:</span>
<span class="gi">+                import threading  # noqa: PLC0415</span>
<span class="gi">+</span>
<span class="gi">+                lock = threading.Lock()</span>
<span class="gi">+                # there is possibility that two threads T1 and T2 are simultaneously running into find_spec,</span>
<span class="gi">+                # observing .lock as empty, and further going into hereby initialization. However due to the GIL,</span>
<span class="gi">+                # list.append() operation is atomic and this way only one of the threads will &quot;win&quot; to put the lock</span>
<span class="gi">+                # - that every thread will use - into .lock[0].</span>
<span class="gi">+                # https://docs.python.org/3/faq/library.html#what-kinds-of-global-value-mutation-are-thread-safe</span>
<span class="gi">+                self.lock.append(lock)</span>
<span class="gi">+</span>
<span class="gi">+            from functools import partial  # noqa: PLC0415</span>
<span class="gi">+            from importlib.util import find_spec  # noqa: PLC0415</span>
<span class="gi">+</span>
<span class="gi">+            with self.lock[0]:</span>
<span class="gi">+                self.fullname = fullname</span>
<span class="gi">+                try:</span>
<span class="gi">+                    spec = find_spec(fullname, path)</span>
<span class="gi">+                    if spec is not None:</span>
<span class="gi">+                        # https://www.python.org/dev/peps/pep-0451/#how-loading-will-work</span>
<span class="gi">+                        is_new_api = hasattr(spec.loader, &quot;exec_module&quot;)</span>
<span class="gi">+                        func_name = &quot;exec_module&quot; if is_new_api else &quot;load_module&quot;</span>
<span class="gi">+                        old = getattr(spec.loader, func_name)</span>
<span class="gi">+                        func = self.exec_module if is_new_api else self.load_module</span>
<span class="gi">+                        if old is not func:</span>
<span class="gi">+                            try:  # noqa: SIM105</span>
<span class="gi">+                                setattr(spec.loader, func_name, partial(func, old))</span>
<span class="gi">+                            except AttributeError:</span>
<span class="gi">+                                pass  # C-Extension loaders are r/o such as zipimporter with &lt;3.7</span>
<span class="gi">+                        return spec</span>
<span class="gi">+                finally:</span>
<span class="gi">+                    self.fullname = None</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def exec_module(old, module):</span>
<span class="gi">+        old(module)</span>
<span class="gi">+        if module.__name__ in _DISTUTILS_PATCH:</span>
<span class="gi">+            patch_dist(module)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def load_module(old, name):</span>
<span class="gi">+        module = old(name)</span>
<span class="gi">+        if module.__name__ in _DISTUTILS_PATCH:</span>
<span class="gi">+            patch_dist(module)</span>
<span class="gi">+        return module</span>


<span class="w"> </span>sys.meta_path.insert(0, _Finder())
<span class="gh">diff --git a/src/virtualenv/create/via_global_ref/api.py b/src/virtualenv/create/via_global_ref/api.py</span>
<span class="gh">index 942e93c..d29067c 100644</span>
<span class="gd">--- a/src/virtualenv/create/via_global_ref/api.py</span>
<span class="gi">+++ b/src/virtualenv/create/via_global_ref/api.py</span>
<span class="gu">@@ -1,32 +1,114 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="w"> </span>from abc import ABC
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.create.creator import Creator, CreatorMeta
<span class="w"> </span>from virtualenv.info import fs_supports_symlink


<span class="w"> </span>class ViaGlobalRefMeta(CreatorMeta):
<span class="gd">-</span>
<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.copy_error = None
<span class="w"> </span>        self.symlink_error = None
<span class="w"> </span>        if not fs_supports_symlink():
<span class="gd">-            self.symlink_error = &#39;the filesystem does not supports symlink&#39;</span>
<span class="gi">+            self.symlink_error = &quot;the filesystem does not supports symlink&quot;</span>

<span class="gi">+    @property</span>
<span class="gi">+    def can_copy(self):</span>
<span class="gi">+        return not self.copy_error</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def can_symlink(self):</span>
<span class="gi">+        return not self.symlink_error</span>

<span class="gd">-class ViaGlobalRefApi(Creator, ABC):</span>

<span class="gd">-    def __init__(self, options, interpreter) -&gt;None:</span>
<span class="gi">+class ViaGlobalRefApi(Creator, ABC):</span>
<span class="gi">+    def __init__(self, options, interpreter) -&gt; None:</span>
<span class="w"> </span>        super().__init__(options, interpreter)
<span class="w"> </span>        self.symlinks = self._should_symlink(options)
<span class="w"> </span>        self.enable_system_site_package = options.system_site

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _should_symlink(options):</span>
<span class="gi">+        # Priority of where the option is set to follow the order: CLI, env var, file, hardcoded.</span>
<span class="gi">+        # If both set at same level prefers copy over symlink.</span>
<span class="gi">+        copies, symlinks = getattr(options, &quot;copies&quot;, False), getattr(options, &quot;symlinks&quot;, False)</span>
<span class="gi">+        copy_src, sym_src = options.get_source(&quot;copies&quot;), options.get_source(&quot;symlinks&quot;)</span>
<span class="gi">+        for level in [&quot;cli&quot;, &quot;env var&quot;, &quot;file&quot;, &quot;default&quot;]:</span>
<span class="gi">+            s_opt = symlinks if sym_src == level else None</span>
<span class="gi">+            c_opt = copies if copy_src == level else None</span>
<span class="gi">+            if s_opt is True and c_opt is True:</span>
<span class="gi">+                return False</span>
<span class="gi">+            if s_opt is True:</span>
<span class="gi">+                return True</span>
<span class="gi">+            if c_opt is True:</span>
<span class="gi">+                return False</span>
<span class="gi">+        return False  # fallback to copy</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def add_parser_arguments(cls, parser, interpreter, meta, app_data):</span>
<span class="gi">+        super().add_parser_arguments(parser, interpreter, meta, app_data)</span>
<span class="gi">+        parser.add_argument(</span>
<span class="gi">+            &quot;--system-site-packages&quot;,</span>
<span class="gi">+            default=False,</span>
<span class="gi">+            action=&quot;store_true&quot;,</span>
<span class="gi">+            dest=&quot;system_site&quot;,</span>
<span class="gi">+            help=&quot;give the virtual environment access to the system site-packages dir&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        if not meta.can_symlink and not meta.can_copy:</span>
<span class="gi">+            msg = &quot;neither symlink or copy method supported&quot;</span>
<span class="gi">+            raise RuntimeError(msg)</span>
<span class="gi">+        group = parser.add_mutually_exclusive_group()</span>
<span class="gi">+        if meta.can_symlink:</span>
<span class="gi">+            group.add_argument(</span>
<span class="gi">+                &quot;--symlinks&quot;,</span>
<span class="gi">+                default=True,</span>
<span class="gi">+                action=&quot;store_true&quot;,</span>
<span class="gi">+                dest=&quot;symlinks&quot;,</span>
<span class="gi">+                help=&quot;try to use symlinks rather than copies, when symlinks are not the default for the platform&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+        if meta.can_copy:</span>
<span class="gi">+            group.add_argument(</span>
<span class="gi">+                &quot;--copies&quot;,</span>
<span class="gi">+                &quot;--always-copy&quot;,</span>
<span class="gi">+                default=not meta.can_symlink,</span>
<span class="gi">+                action=&quot;store_true&quot;,</span>
<span class="gi">+                dest=&quot;copies&quot;,</span>
<span class="gi">+                help=&quot;try to use copies rather than symlinks, even when symlinks are the default for the platform&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def create(self):</span>
<span class="gi">+        self.install_patch()</span>
<span class="gi">+</span>
<span class="gi">+    def install_patch(self):</span>
<span class="gi">+        text = self.env_patch_text()</span>
<span class="gi">+        if text:</span>
<span class="gi">+            pth = self.purelib / &quot;_virtualenv.pth&quot;</span>
<span class="gi">+            logging.debug(&quot;create virtualenv import hook file %s&quot;, pth)</span>
<span class="gi">+            pth.write_text(&quot;import _virtualenv&quot;, encoding=&quot;utf-8&quot;)</span>
<span class="gi">+            dest_path = self.purelib / &quot;_virtualenv.py&quot;</span>
<span class="gi">+            logging.debug(&quot;create %s&quot;, dest_path)</span>
<span class="gi">+            dest_path.write_text(text, encoding=&quot;utf-8&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>    def env_patch_text(self):
<span class="w"> </span>        &quot;&quot;&quot;Patch the distutils package to not be derailed by its configuration files.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.app_data.ensure_extracted(Path(__file__).parent / &quot;_virtualenv.py&quot;) as resolved_path:</span>
<span class="gi">+            text = resolved_path.read_text(encoding=&quot;utf-8&quot;)</span>
<span class="gi">+            return text.replace(&#39;&quot;__SCRIPT_DIR__&quot;&#39;, repr(os.path.relpath(str(self.script_dir), str(self.purelib))))</span>
<span class="gi">+</span>
<span class="gi">+    def _args(self):</span>
<span class="gi">+        return [*super()._args(), (&quot;global&quot;, self.enable_system_site_package)]</span>
<span class="gi">+</span>
<span class="gi">+    def set_pyenv_cfg(self):</span>
<span class="gi">+        super().set_pyenv_cfg()</span>
<span class="gi">+        self.pyenv_cfg[&quot;include-system-site-packages&quot;] = &quot;true&quot; if self.enable_system_site_package else &quot;false&quot;</span>


<span class="gd">-__all__ = [&#39;ViaGlobalRefApi&#39;, &#39;ViaGlobalRefMeta&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;ViaGlobalRefApi&quot;,</span>
<span class="gi">+    &quot;ViaGlobalRefMeta&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/create/via_global_ref/builtin/builtin_way.py b/src/virtualenv/create/via_global_ref/builtin/builtin_way.py</span>
<span class="gh">index 69e3068..791b1d9 100644</span>
<span class="gd">--- a/src/virtualenv/create/via_global_ref/builtin/builtin_way.py</span>
<span class="gi">+++ b/src/virtualenv/create/via_global_ref/builtin/builtin_way.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABC
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.create.creator import Creator
<span class="w"> </span>from virtualenv.create.describe import Describe

<span class="gu">@@ -7,9 +9,11 @@ from virtualenv.create.describe import Describe</span>
<span class="w"> </span>class VirtualenvBuiltin(Creator, Describe, ABC):
<span class="w"> </span>    &quot;&quot;&quot;A creator that does operations itself without delegation, if we can create it we can also describe it.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, options, interpreter) -&gt;None:</span>
<span class="gi">+    def __init__(self, options, interpreter) -&gt; None:</span>
<span class="w"> </span>        Creator.__init__(self, options, interpreter)
<span class="w"> </span>        Describe.__init__(self, self.dest, interpreter)


<span class="gd">-__all__ = [&#39;VirtualenvBuiltin&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;VirtualenvBuiltin&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/create/via_global_ref/builtin/cpython/common.py b/src/virtualenv/create/via_global_ref/builtin/cpython/common.py</span>
<span class="gh">index 4560e8d..2c28f37 100644</span>
<span class="gd">--- a/src/virtualenv/create/via_global_ref/builtin/cpython/common.py</span>
<span class="gi">+++ b/src/virtualenv/create/via_global_ref/builtin/cpython/common.py</span>
<span class="gu">@@ -1,27 +1,73 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from abc import ABC
<span class="w"> </span>from collections import OrderedDict
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.create.describe import PosixSupports, WindowsSupports
<span class="w"> </span>from virtualenv.create.via_global_ref.builtin.ref import RefMust, RefWhen
<span class="w"> </span>from virtualenv.create.via_global_ref.builtin.via_global_self_do import ViaGlobalRefVirtualenvBuiltin


<span class="w"> </span>class CPython(ViaGlobalRefVirtualenvBuiltin, ABC):
<span class="gd">-    pass</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def can_describe(cls, interpreter):</span>
<span class="gi">+        return interpreter.implementation == &quot;CPython&quot; and super().can_describe(interpreter)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def exe_stem(cls):</span>
<span class="gi">+        return &quot;python&quot;</span>


<span class="w"> </span>class CPythonPosix(CPython, PosixSupports, ABC):
<span class="w"> </span>    &quot;&quot;&quot;Create a CPython virtual environment on POSIX platforms.&quot;&quot;&quot;

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _executables(cls, interpreter):</span>
<span class="gi">+        host_exe = Path(interpreter.system_executable)</span>
<span class="gi">+        major, minor = interpreter.version_info.major, interpreter.version_info.minor</span>
<span class="gi">+        targets = OrderedDict((i, None) for i in [&quot;python&quot;, f&quot;python{major}&quot;, f&quot;python{major}.{minor}&quot;, host_exe.name])</span>
<span class="gi">+        yield host_exe, list(targets.keys()), RefMust.NA, RefWhen.ANY</span>
<span class="gi">+</span>

<span class="w"> </span>class CPythonWindows(CPython, WindowsSupports, ABC):
<span class="gd">-    pass</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _executables(cls, interpreter):</span>
<span class="gi">+        # symlink of the python executables does not work reliably, copy always instead</span>
<span class="gi">+        # - https://bugs.python.org/issue42013</span>
<span class="gi">+        # - venv</span>
<span class="gi">+        host = cls.host_python(interpreter)</span>
<span class="gi">+        for path in (host.parent / n for n in {&quot;python.exe&quot;, host.name}):  # noqa: PLC0208</span>
<span class="gi">+            yield host, [path.name], RefMust.COPY, RefWhen.ANY</span>
<span class="gi">+        # for more info on pythonw.exe see https://stackoverflow.com/a/30313091</span>
<span class="gi">+        python_w = host.parent / &quot;pythonw.exe&quot;</span>
<span class="gi">+        yield python_w, [python_w.name], RefMust.COPY, RefWhen.ANY</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def host_python(cls, interpreter):</span>
<span class="gi">+        return Path(interpreter.system_executable)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_mac_os_framework(interpreter):</span>
<span class="gi">+    if interpreter.platform == &quot;darwin&quot;:</span>
<span class="gi">+        return interpreter.sysconfig_vars.get(&quot;PYTHONFRAMEWORK&quot;) == &quot;Python3&quot;</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_macos_brew(interpreter):</span>
<span class="gi">+    return interpreter.platform == &quot;darwin&quot; and _BREW.fullmatch(interpreter.system_prefix) is not None</span>


<span class="w"> </span>_BREW = re.compile(
<span class="gd">-    &#39;/(usr/local|opt/homebrew)/(opt/python@3\\.\\d{1,2}|Cellar/python@3\\.\\d{1,2}/3\\.\\d{1,2}\\.\\d{1,2})/Frameworks/Python\\.framework/Versions/3\\.\\d{1,2}&#39;</span>
<span class="gd">-    )</span>
<span class="gd">-__all__ = [&#39;CPython&#39;, &#39;CPythonPosix&#39;, &#39;CPythonWindows&#39;,</span>
<span class="gd">-    &#39;is_mac_os_framework&#39;, &#39;is_macos_brew&#39;]</span>
<span class="gi">+    r&quot;/(usr/local|opt/homebrew)/(opt/python@3\.\d{1,2}|Cellar/python@3\.\d{1,2}/3\.\d{1,2}\.\d{1,2})/Frameworks/&quot;</span>
<span class="gi">+    r&quot;Python\.framework/Versions/3\.\d{1,2}&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;CPython&quot;,</span>
<span class="gi">+    &quot;CPythonPosix&quot;,</span>
<span class="gi">+    &quot;CPythonWindows&quot;,</span>
<span class="gi">+    &quot;is_mac_os_framework&quot;,</span>
<span class="gi">+    &quot;is_macos_brew&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/create/via_global_ref/builtin/cpython/cpython3.py b/src/virtualenv/create/via_global_ref/builtin/cpython/cpython3.py</span>
<span class="gh">index fd977a0..daa4741 100644</span>
<span class="gd">--- a/src/virtualenv/create/via_global_ref/builtin/cpython/cpython3.py</span>
<span class="gi">+++ b/src/virtualenv/create/via_global_ref/builtin/cpython/cpython3.py</span>
<span class="gu">@@ -1,13 +1,16 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import abc
<span class="w"> </span>import fnmatch
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from operator import methodcaller as method
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from textwrap import dedent
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.create.describe import Python3Supports
<span class="w"> </span>from virtualenv.create.via_global_ref.builtin.ref import PathRefToDest
<span class="w"> </span>from virtualenv.create.via_global_ref.store import is_store_python
<span class="gi">+</span>
<span class="w"> </span>from .common import CPython, CPythonPosix, CPythonWindows, is_mac_os_framework, is_macos_brew


<span class="gu">@@ -16,12 +19,92 @@ class CPython3(CPython, Python3Supports, abc.ABC):</span>


<span class="w"> </span>class CPython3Posix(CPythonPosix, CPython3):
<span class="gd">-    pass</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def can_describe(cls, interpreter):</span>
<span class="gi">+        return (</span>
<span class="gi">+            is_mac_os_framework(interpreter) is False</span>
<span class="gi">+            and is_macos_brew(interpreter) is False</span>
<span class="gi">+            and super().can_describe(interpreter)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def env_patch_text(self):</span>
<span class="gi">+        text = super().env_patch_text()</span>
<span class="gi">+        if self.pyvenv_launch_patch_active(self.interpreter):</span>
<span class="gi">+            text += dedent(</span>
<span class="gi">+                &quot;&quot;&quot;</span>
<span class="gi">+                # for https://github.com/python/cpython/pull/9516, see https://github.com/pypa/virtualenv/issues/1704</span>
<span class="gi">+                import os</span>
<span class="gi">+                if &quot;__PYVENV_LAUNCHER__&quot; in os.environ:</span>
<span class="gi">+                    del os.environ[&quot;__PYVENV_LAUNCHER__&quot;]</span>
<span class="gi">+                &quot;&quot;&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+        return text</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def pyvenv_launch_patch_active(cls, interpreter):</span>
<span class="gi">+        ver = interpreter.version_info</span>
<span class="gi">+        return interpreter.platform == &quot;darwin&quot; and ((3, 7, 8) &gt; ver &gt;= (3, 7) or (3, 8, 3) &gt; ver &gt;= (3, 8))</span>


<span class="w"> </span>class CPython3Windows(CPythonWindows, CPython3):
<span class="w"> </span>    &quot;&quot;&quot;CPython 3 on Windows.&quot;&quot;&quot;

<span class="gi">+    @classmethod</span>
<span class="gi">+    def setup_meta(cls, interpreter):</span>
<span class="gi">+        if is_store_python(interpreter):  # store python is not supported here</span>
<span class="gi">+            return None</span>
<span class="gi">+        return super().setup_meta(interpreter)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def sources(cls, interpreter):</span>
<span class="gi">+        if cls.has_shim(interpreter):</span>
<span class="gi">+            refs = cls.executables(interpreter)</span>
<span class="gi">+        else:</span>
<span class="gi">+            refs = chain(</span>
<span class="gi">+                cls.executables(interpreter),</span>
<span class="gi">+                cls.dll_and_pyd(interpreter),</span>
<span class="gi">+                cls.python_zip(interpreter),</span>
<span class="gi">+            )</span>
<span class="gi">+        yield from refs</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def executables(cls, interpreter):</span>
<span class="gi">+        return super().sources(interpreter)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def has_shim(cls, interpreter):</span>
<span class="gi">+        return interpreter.version_info.minor &gt;= 7 and cls.shim(interpreter) is not None  # noqa: PLR2004</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def shim(cls, interpreter):</span>
<span class="gi">+        shim = Path(interpreter.system_stdlib) / &quot;venv&quot; / &quot;scripts&quot; / &quot;nt&quot; / &quot;python.exe&quot;</span>
<span class="gi">+        if shim.exists():</span>
<span class="gi">+            return shim</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def host_python(cls, interpreter):</span>
<span class="gi">+        if cls.has_shim(interpreter):</span>
<span class="gi">+            # starting with CPython 3.7 Windows ships with a venvlauncher.exe that avoids the need for dll/pyd copies</span>
<span class="gi">+            # it also means the wrapper must be copied to avoid bugs such as https://bugs.python.org/issue42013</span>
<span class="gi">+            return cls.shim(interpreter)</span>
<span class="gi">+        return super().host_python(interpreter)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def dll_and_pyd(cls, interpreter):</span>
<span class="gi">+        folders = [Path(interpreter.system_executable).parent]</span>
<span class="gi">+</span>
<span class="gi">+        # May be missing on some Python hosts.</span>
<span class="gi">+        # See https://github.com/pypa/virtualenv/issues/2368</span>
<span class="gi">+        dll_folder = Path(interpreter.system_prefix) / &quot;DLLs&quot;</span>
<span class="gi">+        if dll_folder.is_dir():</span>
<span class="gi">+            folders.append(dll_folder)</span>
<span class="gi">+</span>
<span class="gi">+        for folder in folders:</span>
<span class="gi">+            for file in folder.iterdir():</span>
<span class="gi">+                if file.suffix in {&quot;.pyd&quot;, &quot;.dll&quot;}:</span>
<span class="gi">+                    yield PathRefToDest(file, cls.to_bin)</span>
<span class="gi">+</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def python_zip(cls, interpreter):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -35,8 +118,18 @@ class CPython3Windows(CPythonWindows, CPython3):</span>
<span class="w"> </span>        &quot;python{VERSION}.zip&quot; and &quot;python{VERSION}._pth&quot; files. User can
<span class="w"> </span>        move/rename *zip* file and edit `sys.path` by editing *_pth* file.
<span class="w"> </span>        Here the `pattern` is used only for the default *zip* file name!
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;  # noqa: D205</span>
<span class="gi">+        pattern = f&quot;*python{interpreter.version_nodot}.zip&quot;</span>
<span class="gi">+        matches = fnmatch.filter(interpreter.path, pattern)</span>
<span class="gi">+        matched_paths = map(Path, matches)</span>
<span class="gi">+        existing_paths = filter(method(&quot;exists&quot;), matched_paths)</span>
<span class="gi">+        path = next(existing_paths, None)</span>
<span class="gi">+        if path is not None:</span>
<span class="gi">+            yield PathRefToDest(path, cls.to_bin)</span>


<span class="gd">-__all__ = [&#39;CPython3&#39;, &#39;CPython3Posix&#39;, &#39;CPython3Windows&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;CPython3&quot;,</span>
<span class="gi">+    &quot;CPython3Posix&quot;,</span>
<span class="gi">+    &quot;CPython3Windows&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/create/via_global_ref/builtin/cpython/mac_os.py b/src/virtualenv/create/via_global_ref/builtin/cpython/mac_os.py</span>
<span class="gh">index ed427f7..b5e9313 100644</span>
<span class="gd">--- a/src/virtualenv/create/via_global_ref/builtin/cpython/mac_os.py</span>
<span class="gi">+++ b/src/virtualenv/create/via_global_ref/builtin/cpython/mac_os.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The Apple Framework builds require their own customization.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="w"> </span>import struct
<span class="gu">@@ -7,18 +9,85 @@ import subprocess</span>
<span class="w"> </span>from abc import ABC, abstractmethod
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from textwrap import dedent
<span class="gd">-from virtualenv.create.via_global_ref.builtin.ref import ExePathRefToDest, PathRefToDest, RefMust</span>
<span class="gi">+</span>
<span class="gi">+from virtualenv.create.via_global_ref.builtin.ref import (</span>
<span class="gi">+    ExePathRefToDest,</span>
<span class="gi">+    PathRefToDest,</span>
<span class="gi">+    RefMust,</span>
<span class="gi">+)</span>
<span class="w"> </span>from virtualenv.create.via_global_ref.builtin.via_global_self_do import BuiltinViaGlobalRefMeta
<span class="gi">+</span>
<span class="w"> </span>from .common import CPython, CPythonPosix, is_mac_os_framework, is_macos_brew
<span class="w"> </span>from .cpython3 import CPython3


<span class="w"> </span>class CPythonmacOsFramework(CPython, ABC):
<span class="gd">-    pass</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def can_describe(cls, interpreter):</span>
<span class="gi">+        return is_mac_os_framework(interpreter) and super().can_describe(interpreter)</span>
<span class="gi">+</span>
<span class="gi">+    def create(self):</span>
<span class="gi">+        super().create()</span>
<span class="gi">+</span>
<span class="gi">+        # change the install_name of the copied python executables</span>
<span class="gi">+        target = self.desired_mach_o_image_path()</span>
<span class="gi">+        current = self.current_mach_o_image_path()</span>
<span class="gi">+        for src in self._sources:</span>
<span class="gi">+            if isinstance(src, ExePathRefToDest) and (src.must == RefMust.COPY or not self.symlinks):</span>
<span class="gi">+                exes = [self.bin_dir / src.base]</span>
<span class="gi">+                if not self.symlinks:</span>
<span class="gi">+                    exes.extend(self.bin_dir / a for a in src.aliases)</span>
<span class="gi">+                for exe in exes:</span>
<span class="gi">+                    fix_mach_o(str(exe), current, target, self.interpreter.max_size)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _executables(cls, interpreter):</span>
<span class="gi">+        for _, targets, must, when in super()._executables(interpreter):</span>
<span class="gi">+            # Make sure we use the embedded interpreter inside the framework, even if sys.executable points to the</span>
<span class="gi">+            # stub executable in ${sys.prefix}/bin.</span>
<span class="gi">+            # See http://groups.google.com/group/python-virtualenv/browse_thread/thread/17cab2f85da75951</span>
<span class="gi">+            fixed_host_exe = Path(interpreter.prefix) / &quot;Resources&quot; / &quot;Python.app&quot; / &quot;Contents&quot; / &quot;MacOS&quot; / &quot;Python&quot;</span>
<span class="gi">+            yield fixed_host_exe, targets, must, when</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def current_mach_o_image_path(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def desired_mach_o_image_path(self):</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>class CPython3macOsFramework(CPythonmacOsFramework, CPython3, CPythonPosix):
<span class="gd">-    pass</span>
<span class="gi">+    def current_mach_o_image_path(self):</span>
<span class="gi">+        return &quot;@executable_path/../../../../Python3&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def desired_mach_o_image_path(self):</span>
<span class="gi">+        return &quot;@executable_path/../.Python&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def sources(cls, interpreter):</span>
<span class="gi">+        yield from super().sources(interpreter)</span>
<span class="gi">+</span>
<span class="gi">+        # add a symlink to the host python image</span>
<span class="gi">+        exe = Path(interpreter.prefix) / &quot;Python3&quot;</span>
<span class="gi">+        yield PathRefToDest(exe, dest=lambda self, _: self.dest / &quot;.Python&quot;, must=RefMust.SYMLINK)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def reload_code(self):</span>
<span class="gi">+        result = super().reload_code</span>
<span class="gi">+        return dedent(</span>
<span class="gi">+            f&quot;&quot;&quot;</span>
<span class="gi">+        # the bundled site.py always adds the global site package if we&#39;re on python framework build, escape this</span>
<span class="gi">+        import sys</span>
<span class="gi">+        before = sys._framework</span>
<span class="gi">+        try:</span>
<span class="gi">+            sys._framework = None</span>
<span class="gi">+            {result}</span>
<span class="gi">+        finally:</span>
<span class="gi">+            sys._framework = before</span>
<span class="gi">+        &quot;&quot;&quot;,</span>
<span class="gi">+        )</span>


<span class="w"> </span>def fix_mach_o(exe, current, new, max_size):
<span class="gu">@@ -45,12 +114,166 @@ def fix_mach_o(exe, current, new, max_size):</span>
<span class="w"> </span>    (found in the __LINKEDIT section) function. In 10.6 these new Link Edit tables are compressed by removing unused and
<span class="w"> </span>    unneeded bits of information, however Mac OS X 10.5 and earlier cannot read this new Link Edit table format.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        logging.debug(&quot;change Mach-O for %s from %s to %s&quot;, exe, current, new)</span>
<span class="gi">+        _builtin_change_mach_o(max_size)(exe, current, new)</span>
<span class="gi">+    except Exception as e:  # noqa: BLE001</span>
<span class="gi">+        logging.warning(&quot;Could not call _builtin_change_mac_o: %s. Trying to call install_name_tool instead.&quot;, e)</span>
<span class="gi">+        try:</span>
<span class="gi">+            cmd = [&quot;install_name_tool&quot;, &quot;-change&quot;, current, new, exe]</span>
<span class="gi">+            subprocess.check_call(cmd)  # noqa: S603</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            logging.fatal(&quot;Could not call install_name_tool -- you must have Apple&#39;s development tools installed&quot;)</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _builtin_change_mach_o(maxint):  # noqa: C901</span>
<span class="gi">+    MH_MAGIC = 0xFEEDFACE  # noqa: N806</span>
<span class="gi">+    MH_CIGAM = 0xCEFAEDFE  # noqa: N806</span>
<span class="gi">+    MH_MAGIC_64 = 0xFEEDFACF  # noqa: N806</span>
<span class="gi">+    MH_CIGAM_64 = 0xCFFAEDFE  # noqa: N806</span>
<span class="gi">+    FAT_MAGIC = 0xCAFEBABE  # noqa: N806</span>
<span class="gi">+    BIG_ENDIAN = &quot;&gt;&quot;  # noqa: N806</span>
<span class="gi">+    LITTLE_ENDIAN = &quot;&lt;&quot;  # noqa: N806</span>
<span class="gi">+    LC_LOAD_DYLIB = 0xC  # noqa: N806</span>
<span class="gi">+</span>
<span class="gi">+    class FileView:</span>
<span class="gi">+        &quot;&quot;&quot;A proxy for file-like objects that exposes a given view of a file. Modified from macholib.&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        def __init__(self, file_obj, start=0, size=maxint) -&gt; None:</span>
<span class="gi">+            if isinstance(file_obj, FileView):</span>
<span class="gi">+                self._file_obj = file_obj._file_obj  # noqa: SLF001</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._file_obj = file_obj</span>
<span class="gi">+            self._start = start</span>
<span class="gi">+            self._end = start + size</span>
<span class="gi">+            self._pos = 0</span>
<span class="gi">+</span>
<span class="gi">+        def __repr__(self) -&gt; str:</span>
<span class="gi">+            return f&quot;&lt;fileview [{self._start:d}, {self._end:d}] {self._file_obj!r}&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        def tell(self):</span>
<span class="gi">+            return self._pos</span>
<span class="gi">+</span>
<span class="gi">+        def _checkwindow(self, seek_to, op):</span>
<span class="gi">+            if not (self._start &lt;= seek_to &lt;= self._end):</span>
<span class="gi">+                msg = f&quot;{op} to offset {seek_to:d} is outside window [{self._start:d}, {self._end:d}]&quot;</span>
<span class="gi">+                raise OSError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        def seek(self, offset, whence=0):</span>
<span class="gi">+            seek_to = offset</span>
<span class="gi">+            if whence == os.SEEK_SET:</span>
<span class="gi">+                seek_to += self._start</span>
<span class="gi">+            elif whence == os.SEEK_CUR:</span>
<span class="gi">+                seek_to += self._start + self._pos</span>
<span class="gi">+            elif whence == os.SEEK_END:</span>
<span class="gi">+                seek_to += self._end</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg = f&quot;Invalid whence argument to seek: {whence!r}&quot;</span>
<span class="gi">+                raise OSError(msg)</span>
<span class="gi">+            self._checkwindow(seek_to, &quot;seek&quot;)</span>
<span class="gi">+            self._file_obj.seek(seek_to)</span>
<span class="gi">+            self._pos = seek_to - self._start</span>
<span class="gi">+</span>
<span class="gi">+        def write(self, content):</span>
<span class="gi">+            here = self._start + self._pos</span>
<span class="gi">+            self._checkwindow(here, &quot;write&quot;)</span>
<span class="gi">+            self._checkwindow(here + len(content), &quot;write&quot;)</span>
<span class="gi">+            self._file_obj.seek(here, os.SEEK_SET)</span>
<span class="gi">+            self._file_obj.write(content)</span>
<span class="gi">+            self._pos += len(content)</span>
<span class="gi">+</span>
<span class="gi">+        def read(self, size=maxint):</span>
<span class="gi">+            assert size &gt;= 0  # noqa: S101</span>
<span class="gi">+            here = self._start + self._pos</span>
<span class="gi">+            self._checkwindow(here, &quot;read&quot;)</span>
<span class="gi">+            size = min(size, self._end - here)</span>
<span class="gi">+            self._file_obj.seek(here, os.SEEK_SET)</span>
<span class="gi">+            read_bytes = self._file_obj.read(size)</span>
<span class="gi">+            self._pos += len(read_bytes)</span>
<span class="gi">+            return read_bytes</span>
<span class="gi">+</span>
<span class="gi">+    def read_data(file, endian, num=1):</span>
<span class="gi">+        &quot;&quot;&quot;Read a given number of 32-bits unsigned integers from the given file with the given endianness.&quot;&quot;&quot;</span>
<span class="gi">+        res = struct.unpack(endian + &quot;L&quot; * num, file.read(num * 4))</span>
<span class="gi">+        if len(res) == 1:</span>
<span class="gi">+            return res[0]</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+    def mach_o_change(at_path, what, value):  # noqa: C901</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Replace a given name (what) in any LC_LOAD_DYLIB command found in the given binary with a new name (value),</span>
<span class="gi">+        provided it&#39;s shorter.</span>
<span class="gi">+        &quot;&quot;&quot;  # noqa: D205</span>
<span class="gi">+</span>
<span class="gi">+        def do_macho(file, bits, endian):</span>
<span class="gi">+            # Read Mach-O header (the magic number is assumed read by the caller)</span>
<span class="gi">+            _cpu_type, _cpu_sub_type, _file_type, n_commands, _size_of_commands, _flags = read_data(file, endian, 6)</span>
<span class="gi">+            # 64-bits header has one more field.</span>
<span class="gi">+            if bits == 64:  # noqa: PLR2004</span>
<span class="gi">+                read_data(file, endian)</span>
<span class="gi">+            # The header is followed by n commands</span>
<span class="gi">+            for _ in range(n_commands):</span>
<span class="gi">+                where = file.tell()</span>
<span class="gi">+                # Read command header</span>
<span class="gi">+                cmd, cmd_size = read_data(file, endian, 2)</span>
<span class="gi">+                if cmd == LC_LOAD_DYLIB:</span>
<span class="gi">+                    # The first data field in LC_LOAD_DYLIB commands is the offset of the name, starting from the</span>
<span class="gi">+                    # beginning of the  command.</span>
<span class="gi">+                    name_offset = read_data(file, endian)</span>
<span class="gi">+                    file.seek(where + name_offset, os.SEEK_SET)</span>
<span class="gi">+                    # Read the NUL terminated string</span>
<span class="gi">+                    load = file.read(cmd_size - name_offset).decode()</span>
<span class="gi">+                    load = load[: load.index(&quot;\0&quot;)]</span>
<span class="gi">+                    # If the string is what is being replaced, overwrite it.</span>
<span class="gi">+                    if load == what:</span>
<span class="gi">+                        file.seek(where + name_offset, os.SEEK_SET)</span>
<span class="gi">+                        file.write(value.encode() + b&quot;\0&quot;)</span>
<span class="gi">+                # Seek to the next command</span>
<span class="gi">+                file.seek(where + cmd_size, os.SEEK_SET)</span>
<span class="gi">+</span>
<span class="gi">+        def do_file(file, offset=0, size=maxint):</span>
<span class="gi">+            file = FileView(file, offset, size)</span>
<span class="gi">+            # Read magic number</span>
<span class="gi">+            magic = read_data(file, BIG_ENDIAN)</span>
<span class="gi">+            if magic == FAT_MAGIC:</span>
<span class="gi">+                # Fat binaries contain nfat_arch Mach-O binaries</span>
<span class="gi">+                n_fat_arch = read_data(file, BIG_ENDIAN)</span>
<span class="gi">+                for _ in range(n_fat_arch):</span>
<span class="gi">+                    # Read arch header</span>
<span class="gi">+                    _cpu_type, _cpu_sub_type, offset, size, _align = read_data(file, BIG_ENDIAN, 5)</span>
<span class="gi">+                    do_file(file, offset, size)</span>
<span class="gi">+            elif magic == MH_MAGIC:</span>
<span class="gi">+                do_macho(file, 32, BIG_ENDIAN)</span>
<span class="gi">+            elif magic == MH_CIGAM:</span>
<span class="gi">+                do_macho(file, 32, LITTLE_ENDIAN)</span>
<span class="gi">+            elif magic == MH_MAGIC_64:</span>
<span class="gi">+                do_macho(file, 64, BIG_ENDIAN)</span>
<span class="gi">+            elif magic == MH_CIGAM_64:</span>
<span class="gi">+                do_macho(file, 64, LITTLE_ENDIAN)</span>
<span class="gi">+</span>
<span class="gi">+        assert len(what) &gt;= len(value)  # noqa: S101</span>
<span class="gi">+</span>
<span class="gi">+        with open(at_path, &quot;r+b&quot;) as f:</span>
<span class="gi">+            do_file(f)</span>
<span class="gi">+</span>
<span class="gi">+    return mach_o_change</span>


<span class="w"> </span>class CPython3macOsBrew(CPython3, CPythonPosix):
<span class="gd">-    pass</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def can_describe(cls, interpreter):</span>
<span class="gi">+        return is_macos_brew(interpreter) and super().can_describe(interpreter)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def setup_meta(cls, interpreter):  # noqa: ARG003</span>
<span class="gi">+        meta = BuiltinViaGlobalRefMeta()</span>
<span class="gi">+        meta.copy_error = &quot;Brew disables copy creation: https://github.com/Homebrew/homebrew-core/issues/138159&quot;</span>
<span class="gi">+        return meta</span>


<span class="gd">-__all__ = [&#39;CPython3macOsBrew&#39;, &#39;CPython3macOsFramework&#39;,</span>
<span class="gd">-    &#39;CPythonmacOsFramework&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;CPython3macOsBrew&quot;,</span>
<span class="gi">+    &quot;CPython3macOsFramework&quot;,</span>
<span class="gi">+    &quot;CPythonmacOsFramework&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/create/via_global_ref/builtin/pypy/common.py b/src/virtualenv/create/via_global_ref/builtin/pypy/common.py</span>
<span class="gh">index 1056bf3..ca4b45f 100644</span>
<span class="gd">--- a/src/virtualenv/create/via_global_ref/builtin/pypy/common.py</span>
<span class="gi">+++ b/src/virtualenv/create/via_global_ref/builtin/pypy/common.py</span>
<span class="gu">@@ -1,12 +1,53 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import abc
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.create.via_global_ref.builtin.ref import PathRefToDest, RefMust, RefWhen
<span class="w"> </span>from virtualenv.create.via_global_ref.builtin.via_global_self_do import ViaGlobalRefVirtualenvBuiltin


<span class="w"> </span>class PyPy(ViaGlobalRefVirtualenvBuiltin, abc.ABC):
<span class="gd">-    pass</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def can_describe(cls, interpreter):</span>
<span class="gi">+        return interpreter.implementation == &quot;PyPy&quot; and super().can_describe(interpreter)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _executables(cls, interpreter):</span>
<span class="gi">+        host = Path(interpreter.system_executable)</span>
<span class="gi">+        targets = sorted(f&quot;{name}{PyPy.suffix}&quot; for name in cls.exe_names(interpreter))</span>
<span class="gi">+        yield host, targets, RefMust.NA, RefWhen.ANY</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def executables(cls, interpreter):</span>
<span class="gi">+        yield from super().sources(interpreter)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def exe_names(cls, interpreter):</span>
<span class="gi">+        return {</span>
<span class="gi">+            cls.exe_stem(),</span>
<span class="gi">+            &quot;python&quot;,</span>
<span class="gi">+            f&quot;python{interpreter.version_info.major}&quot;,</span>
<span class="gi">+            f&quot;python{interpreter.version_info.major}.{interpreter.version_info.minor}&quot;,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def sources(cls, interpreter):</span>
<span class="gi">+        yield from cls.executables(interpreter)</span>
<span class="gi">+        for host in cls._add_shared_libs(interpreter):</span>
<span class="gi">+            yield PathRefToDest(host, dest=lambda self, s: self.bin_dir / s.name)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _add_shared_libs(cls, interpreter):</span>
<span class="gi">+        # https://bitbucket.org/pypy/pypy/issue/1922/future-proofing-virtualenv</span>
<span class="gi">+        python_dir = Path(interpreter.system_executable).resolve().parent</span>
<span class="gi">+        yield from cls._shared_libs(python_dir)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _shared_libs(cls, python_dir):</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="gd">-__all__ = [&#39;PyPy&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;PyPy&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/create/via_global_ref/builtin/pypy/pypy3.py b/src/virtualenv/create/via_global_ref/builtin/pypy/pypy3.py</span>
<span class="gh">index 023840f..fa61ebc 100644</span>
<span class="gd">--- a/src/virtualenv/create/via_global_ref/builtin/pypy/pypy3.py</span>
<span class="gi">+++ b/src/virtualenv/create/via_global_ref/builtin/pypy/pypy3.py</span>
<span class="gu">@@ -1,21 +1,76 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import abc
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.create.describe import PosixSupports, Python3Supports, WindowsSupports
<span class="w"> </span>from virtualenv.create.via_global_ref.builtin.ref import PathRefToDest
<span class="gi">+</span>
<span class="w"> </span>from .common import PyPy


<span class="w"> </span>class PyPy3(PyPy, Python3Supports, abc.ABC):
<span class="gd">-    pass</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def exe_stem(cls):</span>
<span class="gi">+        return &quot;pypy3&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def exe_names(cls, interpreter):</span>
<span class="gi">+        return super().exe_names(interpreter) | {&quot;pypy&quot;}</span>


<span class="w"> </span>class PyPy3Posix(PyPy3, PosixSupports):
<span class="w"> </span>    &quot;&quot;&quot;PyPy 3 on POSIX.&quot;&quot;&quot;

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _shared_libs(cls, python_dir):</span>
<span class="gi">+        # glob for libpypy3-c.so, libpypy3-c.dylib, libpypy3.9-c.so ...</span>
<span class="gi">+        return python_dir.glob(&quot;libpypy3*.*&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def to_lib(self, src):</span>
<span class="gi">+        return self.dest / &quot;lib&quot; / src.name</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def sources(cls, interpreter):</span>
<span class="gi">+        yield from super().sources(interpreter)</span>
<span class="gi">+        # PyPy &gt;= 3.8 supports a standard prefix installation, where older</span>
<span class="gi">+        # versions always used a portable/development style installation.</span>
<span class="gi">+        # If this is a standard prefix installation, skip the below:</span>
<span class="gi">+        if interpreter.system_prefix == &quot;/usr&quot;:</span>
<span class="gi">+            return</span>
<span class="gi">+        # Also copy/symlink anything under prefix/lib, which, for &quot;portable&quot;</span>
<span class="gi">+        # PyPy builds, includes the tk,tcl runtime and a number of shared</span>
<span class="gi">+        # objects. In distro-specific builds or on conda this should be empty</span>
<span class="gi">+        # (on PyPy3.8+ it will, like on CPython, hold the stdlib).</span>
<span class="gi">+        host_lib = Path(interpreter.system_prefix) / &quot;lib&quot;</span>
<span class="gi">+        stdlib = Path(interpreter.system_stdlib)</span>
<span class="gi">+        if host_lib.exists() and host_lib.is_dir():</span>
<span class="gi">+            for path in host_lib.iterdir():</span>
<span class="gi">+                if stdlib == path:</span>
<span class="gi">+                    # For PyPy3.8+ the stdlib lives in lib/pypy3.8</span>
<span class="gi">+                    # We need to avoid creating a symlink to it since that</span>
<span class="gi">+                    # will defeat the purpose of a virtualenv</span>
<span class="gi">+                    continue</span>
<span class="gi">+                yield PathRefToDest(path, dest=cls.to_lib)</span>
<span class="gi">+</span>

<span class="w"> </span>class Pypy3Windows(PyPy3, WindowsSupports):
<span class="w"> </span>    &quot;&quot;&quot;PyPy 3 on Windows.&quot;&quot;&quot;

<span class="gi">+    @property</span>
<span class="gi">+    def less_v37(self):</span>
<span class="gi">+        return self.interpreter.version_info.minor &lt; 7  # noqa: PLR2004</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _shared_libs(cls, python_dir):</span>
<span class="gi">+        # glob for libpypy*.dll and libffi*.dll</span>
<span class="gi">+        for pattern in [&quot;libpypy*.dll&quot;, &quot;libffi*.dll&quot;]:</span>
<span class="gi">+            srcs = python_dir.glob(pattern)</span>
<span class="gi">+            yield from srcs</span>
<span class="gi">+</span>

<span class="gd">-__all__ = [&#39;PyPy3&#39;, &#39;PyPy3Posix&#39;, &#39;Pypy3Windows&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;PyPy3&quot;,</span>
<span class="gi">+    &quot;PyPy3Posix&quot;,</span>
<span class="gi">+    &quot;Pypy3Windows&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/create/via_global_ref/builtin/ref.py b/src/virtualenv/create/via_global_ref/builtin/ref.py</span>
<span class="gh">index 0892a96..2598c67 100644</span>
<span class="gd">--- a/src/virtualenv/create/via_global_ref/builtin/ref.py</span>
<span class="gi">+++ b/src/virtualenv/create/via_global_ref/builtin/ref.py</span>
<span class="gu">@@ -2,34 +2,38 @@</span>
<span class="w"> </span>Virtual environments in the traditional sense are built as reference to the host python. This file allows declarative
<span class="w"> </span>references to elements on the file system, allowing our system to automatically detect what modes it can support given
<span class="w"> </span>the constraints: e.g. can the file system symlink, can the files be read, executed, etc.
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+&quot;&quot;&quot;  # noqa: D205</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from abc import ABC, abstractmethod
<span class="w"> </span>from collections import OrderedDict
<span class="w"> </span>from stat import S_IXGRP, S_IXOTH, S_IXUSR
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.info import fs_is_case_sensitive, fs_supports_symlink
<span class="w"> </span>from virtualenv.util.path import copy, make_exe, symlink


<span class="w"> </span>class RefMust:
<span class="gd">-    NA = &#39;NA&#39;</span>
<span class="gd">-    COPY = &#39;copy&#39;</span>
<span class="gd">-    SYMLINK = &#39;symlink&#39;</span>
<span class="gi">+    NA = &quot;NA&quot;</span>
<span class="gi">+    COPY = &quot;copy&quot;</span>
<span class="gi">+    SYMLINK = &quot;symlink&quot;</span>


<span class="w"> </span>class RefWhen:
<span class="gd">-    ANY = &#39;ANY&#39;</span>
<span class="gd">-    COPY = &#39;copy&#39;</span>
<span class="gd">-    SYMLINK = &#39;symlink&#39;</span>
<span class="gi">+    ANY = &quot;ANY&quot;</span>
<span class="gi">+    COPY = &quot;copy&quot;</span>
<span class="gi">+    SYMLINK = &quot;symlink&quot;</span>


<span class="w"> </span>class PathRef(ABC):
<span class="w"> </span>    &quot;&quot;&quot;Base class that checks if a file reference can be symlink/copied.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    FS_SUPPORTS_SYMLINK = fs_supports_symlink()
<span class="w"> </span>    FS_CASE_SENSITIVE = fs_is_case_sensitive()

<span class="gd">-    def __init__(self, src, must=RefMust.NA, when=RefWhen.ANY) -&gt;None:</span>
<span class="gi">+    def __init__(self, src, must=RefMust.NA, when=RefWhen.ANY) -&gt; None:</span>
<span class="w"> </span>        self.must = must
<span class="w"> </span>        self.when = when
<span class="w"> </span>        self.src = src
<span class="gu">@@ -41,44 +45,134 @@ class PathRef(ABC):</span>
<span class="w"> </span>        self._can_copy = None if self.exists else False
<span class="w"> </span>        self._can_symlink = None if self.exists else False

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}(src={self.src})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}(src={self.src})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def can_read(self):</span>
<span class="gi">+        if self._can_read is None:</span>
<span class="gi">+            if self.src.is_file():</span>
<span class="gi">+                try:</span>
<span class="gi">+                    with self.src.open(&quot;rb&quot;):</span>
<span class="gi">+                        self._can_read = True</span>
<span class="gi">+                except OSError:</span>
<span class="gi">+                    self._can_read = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._can_read = os.access(str(self.src), os.R_OK)</span>
<span class="gi">+        return self._can_read</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def can_copy(self):</span>
<span class="gi">+        if self._can_copy is None:</span>
<span class="gi">+            if self.must == RefMust.SYMLINK:</span>
<span class="gi">+                self._can_copy = self.can_symlink</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._can_copy = self.can_read</span>
<span class="gi">+        return self._can_copy</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def can_symlink(self):</span>
<span class="gi">+        if self._can_symlink is None:</span>
<span class="gi">+            if self.must == RefMust.COPY:</span>
<span class="gi">+                self._can_symlink = self.can_copy</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._can_symlink = self.FS_SUPPORTS_SYMLINK and self.can_read</span>
<span class="gi">+        return self._can_symlink</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def run(self, creator, symlinks):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def method(self, symlinks):</span>
<span class="gi">+        if self.must == RefMust.SYMLINK:</span>
<span class="gi">+            return symlink</span>
<span class="gi">+        if self.must == RefMust.COPY:</span>
<span class="gi">+            return copy</span>
<span class="gi">+        return symlink if symlinks else copy</span>


<span class="w"> </span>class ExePathRef(PathRef, ABC):
<span class="w"> </span>    &quot;&quot;&quot;Base class that checks if a executable can be references via symlink/copy.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, src, must=RefMust.NA, when=RefWhen.ANY) -&gt;None:</span>
<span class="gi">+    def __init__(self, src, must=RefMust.NA, when=RefWhen.ANY) -&gt; None:</span>
<span class="w"> </span>        super().__init__(src, must, when)
<span class="w"> </span>        self._can_run = None

<span class="gi">+    @property</span>
<span class="gi">+    def can_symlink(self):</span>
<span class="gi">+        if self.FS_SUPPORTS_SYMLINK:</span>
<span class="gi">+            return self.can_run</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def can_run(self):</span>
<span class="gi">+        if self._can_run is None:</span>
<span class="gi">+            mode = self.src.stat().st_mode</span>
<span class="gi">+            for key in [S_IXUSR, S_IXGRP, S_IXOTH]:</span>
<span class="gi">+                if mode &amp; key:</span>
<span class="gi">+                    self._can_run = True</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._can_run = False</span>
<span class="gi">+        return self._can_run</span>
<span class="gi">+</span>

<span class="w"> </span>class PathRefToDest(PathRef):
<span class="w"> </span>    &quot;&quot;&quot;Link a path on the file system.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, src, dest, must=RefMust.NA, when=RefWhen.ANY) -&gt;None:</span>
<span class="gi">+    def __init__(self, src, dest, must=RefMust.NA, when=RefWhen.ANY) -&gt; None:</span>
<span class="w"> </span>        super().__init__(src, must, when)
<span class="w"> </span>        self.dest = dest

<span class="gi">+    def run(self, creator, symlinks):</span>
<span class="gi">+        dest = self.dest(creator, self.src)</span>
<span class="gi">+        method = self.method(symlinks)</span>
<span class="gi">+        dest_iterable = dest if isinstance(dest, list) else (dest,)</span>
<span class="gi">+        if not dest.parent.exists():</span>
<span class="gi">+            dest.parent.mkdir(parents=True, exist_ok=True)</span>
<span class="gi">+        for dst in dest_iterable:</span>
<span class="gi">+            method(self.src, dst)</span>
<span class="gi">+</span>

<span class="w"> </span>class ExePathRefToDest(PathRefToDest, ExePathRef):
<span class="w"> </span>    &quot;&quot;&quot;Link a exe path on the file system.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, src, targets, dest, must=RefMust.NA, when=RefWhen.ANY</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, src, targets, dest, must=RefMust.NA, when=RefWhen.ANY) -&gt; None:  # noqa: PLR0913</span>
<span class="w"> </span>        ExePathRef.__init__(self, src, must, when)
<span class="w"> </span>        PathRefToDest.__init__(self, src, dest, must, when)
<span class="w"> </span>        if not self.FS_CASE_SENSITIVE:
<span class="gd">-            targets = list(OrderedDict((i.lower(), None) for i in targets).</span>
<span class="gd">-                keys())</span>
<span class="gi">+            targets = list(OrderedDict((i.lower(), None) for i in targets).keys())</span>
<span class="w"> </span>        self.base = targets[0]
<span class="w"> </span>        self.aliases = targets[1:]
<span class="w"> </span>        self.dest = dest

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;{self.__class__.__name__}(src={self.src}, alias={self.aliases})&#39;)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-__all__ = [&#39;ExePathRef&#39;, &#39;ExePathRefToDest&#39;, &#39;PathRef&#39;, &#39;PathRefToDest&#39;,</span>
<span class="gd">-    &#39;RefMust&#39;, &#39;RefWhen&#39;]</span>
<span class="gi">+    def run(self, creator, symlinks):</span>
<span class="gi">+        bin_dir = self.dest(creator, self.src).parent</span>
<span class="gi">+        dest = bin_dir / self.base</span>
<span class="gi">+        method = self.method(symlinks)</span>
<span class="gi">+        method(self.src, dest)</span>
<span class="gi">+        if not symlinks:</span>
<span class="gi">+            make_exe(dest)</span>
<span class="gi">+        for extra in self.aliases:</span>
<span class="gi">+            link_file = bin_dir / extra</span>
<span class="gi">+            if link_file.exists():</span>
<span class="gi">+                link_file.unlink()</span>
<span class="gi">+            if symlinks:</span>
<span class="gi">+                link_file.symlink_to(self.base)</span>
<span class="gi">+            else:</span>
<span class="gi">+                copy(self.src, link_file)</span>
<span class="gi">+            if not symlinks:</span>
<span class="gi">+                make_exe(link_file)</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}(src={self.src}, alias={self.aliases})&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;ExePathRef&quot;,</span>
<span class="gi">+    &quot;ExePathRefToDest&quot;,</span>
<span class="gi">+    &quot;PathRef&quot;,</span>
<span class="gi">+    &quot;PathRefToDest&quot;,</span>
<span class="gi">+    &quot;RefMust&quot;,</span>
<span class="gi">+    &quot;RefWhen&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/create/via_global_ref/builtin/via_global_self_do.py b/src/virtualenv/create/via_global_ref/builtin/via_global_self_do.py</span>
<span class="gh">index 5be5210..2f7f2f1 100644</span>
<span class="gd">--- a/src/virtualenv/create/via_global_ref/builtin/via_global_self_do.py</span>
<span class="gi">+++ b/src/virtualenv/create/via_global_ref/builtin/via_global_self_do.py</span>
<span class="gu">@@ -1,35 +1,118 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABC
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.create.via_global_ref.api import ViaGlobalRefApi, ViaGlobalRefMeta
<span class="gd">-from virtualenv.create.via_global_ref.builtin.ref import ExePathRefToDest, RefMust, RefWhen</span>
<span class="gi">+from virtualenv.create.via_global_ref.builtin.ref import (</span>
<span class="gi">+    ExePathRefToDest,</span>
<span class="gi">+    RefMust,</span>
<span class="gi">+    RefWhen,</span>
<span class="gi">+)</span>
<span class="w"> </span>from virtualenv.util.path import ensure_dir
<span class="gi">+</span>
<span class="w"> </span>from .builtin_way import VirtualenvBuiltin


<span class="w"> </span>class BuiltinViaGlobalRefMeta(ViaGlobalRefMeta):
<span class="gd">-</span>
<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.sources = []


<span class="w"> </span>class ViaGlobalRefVirtualenvBuiltin(ViaGlobalRefApi, VirtualenvBuiltin, ABC):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, options, interpreter) -&gt;None:</span>
<span class="gi">+    def __init__(self, options, interpreter) -&gt; None:</span>
<span class="w"> </span>        super().__init__(options, interpreter)
<span class="gd">-        self._sources = getattr(options.meta, &#39;sources&#39;, None)</span>
<span class="gi">+        self._sources = getattr(options.meta, &quot;sources&quot;, None)  # if we&#39;re created as a describer this might be missing</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def can_create(cls, interpreter):
<span class="w"> </span>        &quot;&quot;&quot;By default, all built-in methods assume that if we can describe it we can create it.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # first we must be able to describe it</span>
<span class="gi">+        if not cls.can_describe(interpreter):</span>
<span class="gi">+            return None</span>
<span class="gi">+        meta = cls.setup_meta(interpreter)</span>
<span class="gi">+        if meta is not None and meta:</span>
<span class="gi">+            cls._sources_can_be_applied(interpreter, meta)</span>
<span class="gi">+        return meta</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _sources_can_be_applied(cls, interpreter, meta):</span>
<span class="gi">+        for src in cls.sources(interpreter):</span>
<span class="gi">+            if src.exists:</span>
<span class="gi">+                if meta.can_copy and not src.can_copy:</span>
<span class="gi">+                    meta.copy_error = f&quot;cannot copy {src}&quot;</span>
<span class="gi">+                if meta.can_symlink and not src.can_symlink:</span>
<span class="gi">+                    meta.symlink_error = f&quot;cannot symlink {src}&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg = f&quot;missing required file {src}&quot;</span>
<span class="gi">+                if src.when == RefMust.NA:</span>
<span class="gi">+                    meta.error = msg</span>
<span class="gi">+                elif src.when == RefMust.COPY:</span>
<span class="gi">+                    meta.copy_error = msg</span>
<span class="gi">+                elif src.when == RefMust.SYMLINK:</span>
<span class="gi">+                    meta.symlink_error = msg</span>
<span class="gi">+            if not meta.can_copy and not meta.can_symlink:</span>
<span class="gi">+                meta.error = f&quot;neither copy or symlink supported, copy: {meta.copy_error} symlink: {meta.symlink_error}&quot;</span>
<span class="gi">+            if meta.error:</span>
<span class="gi">+                break</span>
<span class="gi">+            meta.sources.append(src)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def setup_meta(cls, interpreter):  # noqa: ARG003</span>
<span class="gi">+        return BuiltinViaGlobalRefMeta()</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def sources(cls, interpreter):</span>
<span class="gi">+        for host_exe, targets, must, when in cls._executables(interpreter):</span>
<span class="gi">+            yield ExePathRefToDest(host_exe, dest=cls.to_bin, targets=targets, must=must, when=when)</span>
<span class="gi">+</span>
<span class="gi">+    def to_bin(self, src):</span>
<span class="gi">+        return self.bin_dir / src.name</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _executables(cls, interpreter):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def create(self):</span>
<span class="gi">+        dirs = self.ensure_directories()</span>
<span class="gi">+        for directory in list(dirs):</span>
<span class="gi">+            if any(i for i in dirs if i is not directory and directory.parts == i.parts[: len(directory.parts)]):</span>
<span class="gi">+                dirs.remove(directory)</span>
<span class="gi">+        for directory in sorted(dirs):</span>
<span class="gi">+            ensure_dir(directory)</span>
<span class="gi">+</span>
<span class="gi">+        self.set_pyenv_cfg()</span>
<span class="gi">+        self.pyenv_cfg.write()</span>
<span class="gi">+        true_system_site = self.enable_system_site_package</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.enable_system_site_package = False</span>
<span class="gi">+            for src in self._sources:</span>
<span class="gi">+                if (</span>
<span class="gi">+                    src.when == RefWhen.ANY</span>
<span class="gi">+                    or (src.when == RefWhen.SYMLINK and self.symlinks is True)</span>
<span class="gi">+                    or (src.when == RefWhen.COPY and self.symlinks is False)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    src.run(self, self.symlinks)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            if true_system_site != self.enable_system_site_package:</span>
<span class="gi">+                self.enable_system_site_package = true_system_site</span>
<span class="gi">+        super().create()</span>
<span class="gi">+</span>
<span class="gi">+    def ensure_directories(self):</span>
<span class="gi">+        return {self.dest, self.bin_dir, self.script_dir, self.stdlib} | set(self.libs)</span>

<span class="w"> </span>    def set_pyenv_cfg(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        We directly inject the base prefix and base exec prefix to avoid site.py needing to discover these
<span class="w"> </span>        from home (which usually is done within the interpreter itself).
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;  # noqa: D205</span>
<span class="gi">+        super().set_pyenv_cfg()</span>
<span class="gi">+        self.pyenv_cfg[&quot;base-prefix&quot;] = self.interpreter.system_prefix</span>
<span class="gi">+        self.pyenv_cfg[&quot;base-exec-prefix&quot;] = self.interpreter.system_exec_prefix</span>
<span class="gi">+        self.pyenv_cfg[&quot;base-executable&quot;] = self.interpreter.system_executable</span>


<span class="gd">-__all__ = [&#39;BuiltinViaGlobalRefMeta&#39;, &#39;ViaGlobalRefVirtualenvBuiltin&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;BuiltinViaGlobalRefMeta&quot;,</span>
<span class="gi">+    &quot;ViaGlobalRefVirtualenvBuiltin&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/create/via_global_ref/store.py b/src/virtualenv/create/via_global_ref/store.py</span>
<span class="gh">index 9bcde55..4be6689 100644</span>
<span class="gd">--- a/src/virtualenv/create/via_global_ref/store.py</span>
<span class="gi">+++ b/src/virtualenv/create/via_global_ref/store.py</span>
<span class="gu">@@ -1,3 +1,26 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from pathlib import Path
<span class="gd">-__all__ = [&#39;handle_store_python&#39;, &#39;is_store_python&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def handle_store_python(meta, interpreter):</span>
<span class="gi">+    if is_store_python(interpreter):</span>
<span class="gi">+        meta.symlink_error = &quot;Windows Store Python does not support virtual environments via symlink&quot;</span>
<span class="gi">+    return meta</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_store_python(interpreter):</span>
<span class="gi">+    parts = Path(interpreter.system_executable).parts</span>
<span class="gi">+    return (</span>
<span class="gi">+        len(parts) &gt; 4  # noqa: PLR2004</span>
<span class="gi">+        and parts[-4] == &quot;Microsoft&quot;</span>
<span class="gi">+        and parts[-3] == &quot;WindowsApps&quot;</span>
<span class="gi">+        and parts[-2].startswith(&quot;PythonSoftwareFoundation.Python.3.&quot;)</span>
<span class="gi">+        and parts[-1].startswith(&quot;python&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;handle_store_python&quot;,</span>
<span class="gi">+    &quot;is_store_python&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/create/via_global_ref/venv.py b/src/virtualenv/create/via_global_ref/venv.py</span>
<span class="gh">index dab115b..7220af1 100644</span>
<span class="gd">--- a/src/virtualenv/create/via_global_ref/venv.py</span>
<span class="gi">+++ b/src/virtualenv/create/via_global_ref/venv.py</span>
<span class="gu">@@ -1,41 +1,102 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>from copy import copy
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.create.via_global_ref.store import handle_store_python
<span class="w"> </span>from virtualenv.discovery.py_info import PythonInfo
<span class="w"> </span>from virtualenv.util.error import ProcessCallFailedError
<span class="w"> </span>from virtualenv.util.path import ensure_dir
<span class="w"> </span>from virtualenv.util.subprocess import run_cmd
<span class="gi">+</span>
<span class="w"> </span>from .api import ViaGlobalRefApi, ViaGlobalRefMeta
<span class="w"> </span>from .builtin.cpython.mac_os import CPython3macOsBrew
<span class="w"> </span>from .builtin.pypy.pypy3 import Pypy3Windows


<span class="w"> </span>class Venv(ViaGlobalRefApi):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, options, interpreter) -&gt;None:</span>
<span class="gi">+    def __init__(self, options, interpreter) -&gt; None:</span>
<span class="w"> </span>        self.describe = options.describe
<span class="w"> </span>        super().__init__(options, interpreter)
<span class="w"> </span>        current = PythonInfo.current()
<span class="gd">-        self.can_be_inline = (interpreter is current and interpreter.</span>
<span class="gd">-            executable == interpreter.system_executable)</span>
<span class="gi">+        self.can_be_inline = interpreter is current and interpreter.executable == interpreter.system_executable</span>
<span class="w"> </span>        self._context = None

<span class="gi">+    def _args(self):</span>
<span class="gi">+        return super()._args() + ([(&quot;describe&quot;, self.describe.__class__.__name__)] if self.describe else [])</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def can_create(cls, interpreter):</span>
<span class="gi">+        if interpreter.has_venv:</span>
<span class="gi">+            if CPython3macOsBrew.can_describe(interpreter):</span>
<span class="gi">+                return CPython3macOsBrew.setup_meta(interpreter)</span>
<span class="gi">+            meta = ViaGlobalRefMeta()</span>
<span class="gi">+            if interpreter.platform == &quot;win32&quot;:</span>
<span class="gi">+                meta = handle_store_python(meta, interpreter)</span>
<span class="gi">+            return meta</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def create(self):</span>
<span class="gi">+        if self.can_be_inline:</span>
<span class="gi">+            self.create_inline()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.create_via_sub_process()</span>
<span class="gi">+        for lib in self.libs:</span>
<span class="gi">+            ensure_dir(lib)</span>
<span class="gi">+        super().create()</span>
<span class="gi">+        self.executables_for_win_pypy_less_v37()</span>
<span class="gi">+</span>
<span class="w"> </span>    def executables_for_win_pypy_less_v37(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        PyPy &lt;= 3.6 (v7.3.3) for Windows contains only pypy3.exe and pypy3w.exe
<span class="w"> </span>        Venv does not handle non-existing exe sources, e.g. python.exe, so this
<span class="w"> </span>        patch does it.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;  # noqa: D205</span>
<span class="gi">+        creator = self.describe</span>
<span class="gi">+        if isinstance(creator, Pypy3Windows) and creator.less_v37:</span>
<span class="gi">+            for exe in creator.executables(self.interpreter):</span>
<span class="gi">+                exe.run(creator, self.symlinks)</span>
<span class="gi">+</span>
<span class="gi">+    def create_inline(self):</span>
<span class="gi">+        from venv import EnvBuilder  # noqa: PLC0415</span>
<span class="gi">+</span>
<span class="gi">+        builder = EnvBuilder(</span>
<span class="gi">+            system_site_packages=self.enable_system_site_package,</span>
<span class="gi">+            clear=False,</span>
<span class="gi">+            symlinks=self.symlinks,</span>
<span class="gi">+            with_pip=False,</span>
<span class="gi">+        )</span>
<span class="gi">+        builder.create(str(self.dest))</span>
<span class="gi">+</span>
<span class="gi">+    def create_via_sub_process(self):</span>
<span class="gi">+        cmd = self.get_host_create_cmd()</span>
<span class="gi">+        logging.info(&quot;using host built-in venv to create via %s&quot;, &quot; &quot;.join(cmd))</span>
<span class="gi">+        code, out, err = run_cmd(cmd)</span>
<span class="gi">+        if code != 0:</span>
<span class="gi">+            raise ProcessCallFailedError(code, out, err, cmd)</span>
<span class="gi">+</span>
<span class="gi">+    def get_host_create_cmd(self):</span>
<span class="gi">+        cmd = [self.interpreter.system_executable, &quot;-m&quot;, &quot;venv&quot;, &quot;--without-pip&quot;]</span>
<span class="gi">+        if self.enable_system_site_package:</span>
<span class="gi">+            cmd.append(&quot;--system-site-packages&quot;)</span>
<span class="gi">+        cmd.extend((&quot;--symlinks&quot; if self.symlinks else &quot;--copies&quot;, str(self.dest)))</span>
<span class="gi">+        return cmd</span>
<span class="gi">+</span>
<span class="gi">+    def set_pyenv_cfg(self):</span>
<span class="gi">+        # prefer venv options over ours, but keep our extra</span>
<span class="gi">+        venv_content = copy(self.pyenv_cfg.refresh())</span>
<span class="gi">+        super().set_pyenv_cfg()</span>
<span class="gi">+        self.pyenv_cfg.update(venv_content)</span>

<span class="w"> </span>    def __getattribute__(self, item):
<span class="gd">-        describe = object.__getattribute__(self, &#39;describe&#39;)</span>
<span class="gi">+        describe = object.__getattribute__(self, &quot;describe&quot;)</span>
<span class="w"> </span>        if describe is not None and hasattr(describe, item):
<span class="w"> </span>            element = getattr(describe, item)
<span class="gd">-            if not callable(element) or item == &#39;script&#39;:</span>
<span class="gi">+            if not callable(element) or item == &quot;script&quot;:</span>
<span class="w"> </span>                return element
<span class="w"> </span>        return object.__getattribute__(self, item)


<span class="gd">-__all__ = [&#39;Venv&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Venv&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/discovery/builtin.py b/src/virtualenv/discovery/builtin.py</span>
<span class="gh">index c685c6c..ae0612b 100644</span>
<span class="gd">--- a/src/virtualenv/discovery/builtin.py</span>
<span class="gi">+++ b/src/virtualenv/discovery/builtin.py</span>
<span class="gu">@@ -1,16 +1,21 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import TYPE_CHECKING, Callable
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.info import IS_WIN, fs_path_id
<span class="gi">+</span>
<span class="w"> </span>from .discover import Discover
<span class="w"> </span>from .py_info import PythonInfo
<span class="w"> </span>from .py_spec import PythonSpec
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from argparse import ArgumentParser
<span class="w"> </span>    from collections.abc import Generator, Iterable, Mapping, Sequence
<span class="gi">+</span>
<span class="w"> </span>    from virtualenv.app_data.base import AppData


<span class="gu">@@ -19,49 +24,202 @@ class Builtin(Discover):</span>
<span class="w"> </span>    app_data: AppData
<span class="w"> </span>    try_first_with: Sequence[str]

<span class="gd">-    def __init__(self, options) -&gt;None:</span>
<span class="gi">+    def __init__(self, options) -&gt; None:</span>
<span class="w"> </span>        super().__init__(options)
<span class="w"> </span>        self.python_spec = options.python or [sys.executable]
<span class="w"> </span>        self.app_data = options.app_data
<span class="w"> </span>        self.try_first_with = options.try_first_with

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        spec = self.python_spec[0] if len(self.python_spec</span>
<span class="gd">-            ) == 1 else self.python_spec</span>
<span class="gd">-        return f&#39;{self.__class__.__name__} discover of python_spec={spec!r}&#39;</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def add_parser_arguments(cls, parser: ArgumentParser) -&gt; None:</span>
<span class="gi">+        parser.add_argument(</span>
<span class="gi">+            &quot;-p&quot;,</span>
<span class="gi">+            &quot;--python&quot;,</span>
<span class="gi">+            dest=&quot;python&quot;,</span>
<span class="gi">+            metavar=&quot;py&quot;,</span>
<span class="gi">+            type=str,</span>
<span class="gi">+            action=&quot;append&quot;,</span>
<span class="gi">+            default=[],</span>
<span class="gi">+            help=&quot;interpreter based on what to create environment (path/identifier) &quot;</span>
<span class="gi">+            &quot;- by default use the interpreter where the tool is installed - first found wins&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        parser.add_argument(</span>
<span class="gi">+            &quot;--try-first-with&quot;,</span>
<span class="gi">+            dest=&quot;try_first_with&quot;,</span>
<span class="gi">+            metavar=&quot;py_exe&quot;,</span>
<span class="gi">+            type=str,</span>
<span class="gi">+            action=&quot;append&quot;,</span>
<span class="gi">+            default=[],</span>
<span class="gi">+            help=&quot;try first these interpreters before starting the discovery&quot;,</span>
<span class="gi">+        )</span>

<span class="gi">+    def run(self) -&gt; PythonInfo | None:</span>
<span class="gi">+        for python_spec in self.python_spec:</span>
<span class="gi">+            result = get_interpreter(python_spec, self.try_first_with, self.app_data, self._env)</span>
<span class="gi">+            if result is not None:</span>
<span class="gi">+                return result</span>
<span class="gi">+        return None</span>

<span class="gd">-class LazyPathDump:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        spec = self.python_spec[0] if len(self.python_spec) == 1 else self.python_spec</span>
<span class="gi">+        return f&quot;{self.__class__.__name__} discover of python_spec={spec!r}&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_interpreter(</span>
<span class="gi">+    key, try_first_with: Iterable[str], app_data: AppData | None = None, env: Mapping[str, str] | None = None</span>
<span class="gi">+) -&gt; PythonInfo | None:</span>
<span class="gi">+    spec = PythonSpec.from_string_spec(key)</span>
<span class="gi">+    logging.info(&quot;find interpreter for spec %r&quot;, spec)</span>
<span class="gi">+    proposed_paths = set()</span>
<span class="gi">+    env = os.environ if env is None else env</span>
<span class="gi">+    for interpreter, impl_must_match in propose_interpreters(spec, try_first_with, app_data, env):</span>
<span class="gi">+        key = interpreter.system_executable, impl_must_match</span>
<span class="gi">+        if key in proposed_paths:</span>
<span class="gi">+            continue</span>
<span class="gi">+        logging.info(&quot;proposed %s&quot;, interpreter)</span>
<span class="gi">+        if interpreter.satisfies(spec, impl_must_match):</span>
<span class="gi">+            logging.debug(&quot;accepted %s&quot;, interpreter)</span>
<span class="gi">+            return interpreter</span>
<span class="gi">+        proposed_paths.add(key)</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def propose_interpreters(  # noqa: C901, PLR0912, PLR0915</span>
<span class="gi">+    spec: PythonSpec,</span>
<span class="gi">+    try_first_with: Iterable[str],</span>
<span class="gi">+    app_data: AppData | None = None,</span>
<span class="gi">+    env: Mapping[str, str] | None = None,</span>
<span class="gi">+) -&gt; Generator[tuple[PythonInfo, bool], None, None]:</span>
<span class="gi">+    # 0. try with first</span>
<span class="gi">+    env = os.environ if env is None else env</span>
<span class="gi">+    tested_exes: set[str] = set()</span>
<span class="gi">+    for py_exe in try_first_with:</span>
<span class="gi">+        path = os.path.abspath(py_exe)</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.lstat(path)  # Windows Store Python does not work with os.path.exists, but does for os.lstat</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            exe_raw = os.path.abspath(path)</span>
<span class="gi">+            exe_id = fs_path_id(exe_raw)</span>
<span class="gi">+            if exe_id in tested_exes:</span>
<span class="gi">+                continue</span>
<span class="gi">+            tested_exes.add(exe_id)</span>
<span class="gi">+            yield PythonInfo.from_exe(exe_raw, app_data, env=env), True</span>

<span class="gd">-    def __init__(self, pos: int, path: Path, env: Mapping[str, str]) -&gt;None:</span>
<span class="gi">+    # 1. if it&#39;s a path and exists</span>
<span class="gi">+    if spec.path is not None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.lstat(spec.path)  # Windows Store Python does not work with os.path.exists, but does for os.lstat</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            if spec.is_abs:</span>
<span class="gi">+                raise</span>
<span class="gi">+        else:</span>
<span class="gi">+            exe_raw = os.path.abspath(spec.path)</span>
<span class="gi">+            exe_id = fs_path_id(exe_raw)</span>
<span class="gi">+            if exe_id not in tested_exes:</span>
<span class="gi">+                tested_exes.add(exe_id)</span>
<span class="gi">+                yield PythonInfo.from_exe(exe_raw, app_data, env=env), True</span>
<span class="gi">+        if spec.is_abs:</span>
<span class="gi">+            return</span>
<span class="gi">+    else:</span>
<span class="gi">+        # 2. otherwise try with the current</span>
<span class="gi">+        current_python = PythonInfo.current_system(app_data)</span>
<span class="gi">+        exe_raw = str(current_python.executable)</span>
<span class="gi">+        exe_id = fs_path_id(exe_raw)</span>
<span class="gi">+        if exe_id not in tested_exes:</span>
<span class="gi">+            tested_exes.add(exe_id)</span>
<span class="gi">+            yield current_python, True</span>
<span class="gi">+</span>
<span class="gi">+        # 3. otherwise fallback to platform default logic</span>
<span class="gi">+        if IS_WIN:</span>
<span class="gi">+            from .windows import propose_interpreters  # noqa: PLC0415</span>
<span class="gi">+</span>
<span class="gi">+            for interpreter in propose_interpreters(spec, app_data, env):</span>
<span class="gi">+                exe_raw = str(interpreter.executable)</span>
<span class="gi">+                exe_id = fs_path_id(exe_raw)</span>
<span class="gi">+                if exe_id in tested_exes:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                tested_exes.add(exe_id)</span>
<span class="gi">+                yield interpreter, True</span>
<span class="gi">+    # finally just find on path, the path order matters (as the candidates are less easy to control by end user)</span>
<span class="gi">+    find_candidates = path_exe_finder(spec)</span>
<span class="gi">+    for pos, path in enumerate(get_paths(env)):</span>
<span class="gi">+        logging.debug(LazyPathDump(pos, path, env))</span>
<span class="gi">+        for exe, impl_must_match in find_candidates(path):</span>
<span class="gi">+            exe_raw = str(exe)</span>
<span class="gi">+            exe_id = fs_path_id(exe_raw)</span>
<span class="gi">+            if exe_id in tested_exes:</span>
<span class="gi">+                continue</span>
<span class="gi">+            tested_exes.add(exe_id)</span>
<span class="gi">+            interpreter = PathPythonInfo.from_exe(exe_raw, app_data, raise_on_error=False, env=env)</span>
<span class="gi">+            if interpreter is not None:</span>
<span class="gi">+                yield interpreter, impl_must_match</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_paths(env: Mapping[str, str]) -&gt; Generator[Path, None, None]:</span>
<span class="gi">+    path = env.get(&quot;PATH&quot;, None)</span>
<span class="gi">+    if path is None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            path = os.confstr(&quot;CS_PATH&quot;)</span>
<span class="gi">+        except (AttributeError, ValueError):</span>
<span class="gi">+            path = os.defpath</span>
<span class="gi">+    if path:</span>
<span class="gi">+        for p in map(Path, path.split(os.pathsep)):</span>
<span class="gi">+            if p.exists():</span>
<span class="gi">+                yield p</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class LazyPathDump:</span>
<span class="gi">+    def __init__(self, pos: int, path: Path, env: Mapping[str, str]) -&gt; None:</span>
<span class="w"> </span>        self.pos = pos
<span class="w"> </span>        self.path = path
<span class="w"> </span>        self.env = env

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        content = f&#39;discover PATH[{self.pos}]={self.path}&#39;</span>
<span class="gd">-        if self.env.get(&#39;_VIRTUALENV_DEBUG&#39;):</span>
<span class="gd">-            content += &#39; with =&gt;&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        content = f&quot;discover PATH[{self.pos}]={self.path}&quot;</span>
<span class="gi">+        if self.env.get(&quot;_VIRTUALENV_DEBUG&quot;):  # this is the over the board debug</span>
<span class="gi">+            content += &quot; with =&gt;&quot;</span>
<span class="w"> </span>            for file_path in self.path.iterdir():
<span class="w"> </span>                try:
<span class="gd">-                    if file_path.is_dir() or not file_path.stat(</span>
<span class="gd">-                        ).st_mode &amp; os.X_OK:</span>
<span class="gi">+                    if file_path.is_dir() or not (file_path.stat().st_mode &amp; os.X_OK):</span>
<span class="w"> </span>                        continue
<span class="w"> </span>                except OSError:
<span class="w"> </span>                    pass
<span class="gd">-                content += &#39; &#39;</span>
<span class="gi">+                content += &quot; &quot;</span>
<span class="w"> </span>                content += file_path.name
<span class="w"> </span>        return content


<span class="gd">-def path_exe_finder(spec: PythonSpec) -&gt;Callable[[Path], Generator[tuple[</span>
<span class="gd">-    Path, bool], None, None]]:</span>
<span class="gi">+def path_exe_finder(spec: PythonSpec) -&gt; Callable[[Path], Generator[tuple[Path, bool], None, None]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Given a spec, return a function that can be called on a path to find all matching files in it.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pat = spec.generate_re(windows=sys.platform == &quot;win32&quot;)</span>
<span class="gi">+    direct = spec.str_spec</span>
<span class="gi">+    if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+        direct = f&quot;{direct}.exe&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def path_exes(path: Path) -&gt; Generator[tuple[Path, bool], None, None]:</span>
<span class="gi">+        # 4. then maybe it&#39;s something exact on PATH - if it was direct lookup implementation no longer counts</span>
<span class="gi">+        direct_path = path / direct</span>
<span class="gi">+        if direct_path.exists():</span>
<span class="gi">+            yield direct_path, False</span>
<span class="gi">+</span>
<span class="gi">+        # 5. or from the spec we can deduce if a name on path matches</span>
<span class="gi">+        for exe in path.iterdir():</span>
<span class="gi">+            match = pat.fullmatch(exe.name)</span>
<span class="gi">+            if match:</span>
<span class="gi">+                # the implementation must match when we find “python[ver]”</span>
<span class="gi">+                yield exe.absolute(), match[&quot;impl&quot;] == &quot;python&quot;</span>
<span class="gi">+</span>
<span class="gi">+    return path_exes</span>


<span class="w"> </span>class PathPythonInfo(PythonInfo):
<span class="w"> </span>    &quot;&quot;&quot;python info from path.&quot;&quot;&quot;


<span class="gd">-__all__ = [&#39;Builtin&#39;, &#39;PathPythonInfo&#39;, &#39;get_interpreter&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Builtin&quot;,</span>
<span class="gi">+    &quot;PathPythonInfo&quot;,</span>
<span class="gi">+    &quot;get_interpreter&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/discovery/cached_py_info.py b/src/virtualenv/discovery/cached_py_info.py</span>
<span class="gh">index ba59bf6..d2cf607 100644</span>
<span class="gd">--- a/src/virtualenv/discovery/cached_py_info.py</span>
<span class="gi">+++ b/src/virtualenv/discovery/cached_py_info.py</span>
<span class="gu">@@ -3,8 +3,10 @@</span>
<span class="w"> </span>We acquire the python information by running an interrogation script via subprocess trigger. This operation is not
<span class="w"> </span>cheap, especially not on Windows. To not have to pay this hefty cost every time we apply multiple levels of
<span class="w"> </span>caching.
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+&quot;&quot;&quot;  # noqa: D205</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="w"> </span>import random
<span class="gu">@@ -14,25 +16,163 @@ from pathlib import Path</span>
<span class="w"> </span>from shlex import quote
<span class="w"> </span>from string import ascii_lowercase, ascii_uppercase, digits
<span class="w"> </span>from subprocess import Popen
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.app_data import AppDataDisabled
<span class="w"> </span>from virtualenv.discovery.py_info import PythonInfo
<span class="w"> </span>from virtualenv.util.subprocess import subprocess
<span class="gi">+</span>
<span class="w"> </span>_CACHE = OrderedDict()
<span class="w"> </span>_CACHE[Path(sys.executable)] = PythonInfo()
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_exe(cls, app_data, exe, env=None, raise_on_error=True, ignore_cache=False):  # noqa: FBT002, PLR0913</span>
<span class="gi">+    env = os.environ if env is None else env</span>
<span class="gi">+    result = _get_from_cache(cls, app_data, exe, env, ignore_cache=ignore_cache)</span>
<span class="gi">+    if isinstance(result, Exception):</span>
<span class="gi">+        if raise_on_error:</span>
<span class="gi">+            raise result</span>
<span class="gi">+        logging.info(&quot;%s&quot;, result)</span>
<span class="gi">+        result = None</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_from_cache(cls, app_data, exe, env, ignore_cache=True):  # noqa: FBT002</span>
<span class="gi">+    # note here we cannot resolve symlinks, as the symlink may trigger different prefix information if there&#39;s a</span>
<span class="gi">+    # pyenv.cfg somewhere alongside on python3.5+</span>
<span class="gi">+    exe_path = Path(exe)</span>
<span class="gi">+    if not ignore_cache and exe_path in _CACHE:  # check in the in-memory cache</span>
<span class="gi">+        result = _CACHE[exe_path]</span>
<span class="gi">+    else:  # otherwise go through the app data cache</span>
<span class="gi">+        py_info = _get_via_file_cache(cls, app_data, exe_path, exe, env)</span>
<span class="gi">+        result = _CACHE[exe_path] = py_info</span>
<span class="gi">+    # independent if it was from the file or in-memory cache fix the original executable location</span>
<span class="gi">+    if isinstance(result, PythonInfo):</span>
<span class="gi">+        result.executable = exe</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_via_file_cache(cls, app_data, path, exe, env):</span>
<span class="gi">+    path_text = str(path)</span>
<span class="gi">+    try:</span>
<span class="gi">+        path_modified = path.stat().st_mtime</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        path_modified = -1</span>
<span class="gi">+    if app_data is None:</span>
<span class="gi">+        app_data = AppDataDisabled()</span>
<span class="gi">+    py_info, py_info_store = None, app_data.py_info(path)</span>
<span class="gi">+    with py_info_store.locked():</span>
<span class="gi">+        if py_info_store.exists():  # if exists and matches load</span>
<span class="gi">+            data = py_info_store.read()</span>
<span class="gi">+            of_path, of_st_mtime, of_content = data[&quot;path&quot;], data[&quot;st_mtime&quot;], data[&quot;content&quot;]</span>
<span class="gi">+            if of_path == path_text and of_st_mtime == path_modified:</span>
<span class="gi">+                py_info = cls._from_dict(of_content.copy())</span>
<span class="gi">+                sys_exe = py_info.system_executable</span>
<span class="gi">+                if sys_exe is not None and not os.path.exists(sys_exe):</span>
<span class="gi">+                    py_info_store.remove()</span>
<span class="gi">+                    py_info = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                py_info_store.remove()</span>
<span class="gi">+        if py_info is None:  # if not loaded run and save</span>
<span class="gi">+            failure, py_info = _run_subprocess(cls, exe, app_data, env)</span>
<span class="gi">+            if failure is None:</span>
<span class="gi">+                data = {&quot;st_mtime&quot;: path_modified, &quot;path&quot;: path_text, &quot;content&quot;: py_info._to_dict()}  # noqa: SLF001</span>
<span class="gi">+                py_info_store.write(data)</span>
<span class="gi">+            else:</span>
<span class="gi">+                py_info = failure</span>
<span class="gi">+    return py_info</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>COOKIE_LENGTH: int = 32


<span class="gd">-class LogCmd:</span>
<span class="gi">+def gen_cookie():</span>
<span class="gi">+    return &quot;&quot;.join(</span>
<span class="gi">+        random.choice(f&quot;{ascii_lowercase}{ascii_uppercase}{digits}&quot;)  # noqa: S311</span>
<span class="gi">+        for _ in range(COOKIE_LENGTH)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>

<span class="gd">-    def __init__(self, cmd, env=None) -&gt;None:</span>
<span class="gi">+def _run_subprocess(cls, exe, app_data, env):</span>
<span class="gi">+    py_info_script = Path(os.path.abspath(__file__)).parent / &quot;py_info.py&quot;</span>
<span class="gi">+    # Cookies allow to split the serialized stdout output generated by the script collecting the info from the output</span>
<span class="gi">+    # generated by something else. The right way to deal with it is to create an anonymous pipe and pass its descriptor</span>
<span class="gi">+    # to the child and output to it. But AFAIK all of them are either not cross-platform or too big to implement and are</span>
<span class="gi">+    # not in the stdlib. So the easiest and the shortest way I could mind is just using the cookies.</span>
<span class="gi">+    # We generate pseudorandom cookies because it easy to implement and avoids breakage from outputting modules source</span>
<span class="gi">+    # code, i.e. by debug output libraries. We reverse the cookies to avoid breakages resulting from variable values</span>
<span class="gi">+    # appearing in debug output.</span>
<span class="gi">+</span>
<span class="gi">+    start_cookie = gen_cookie()</span>
<span class="gi">+    end_cookie = gen_cookie()</span>
<span class="gi">+    with app_data.ensure_extracted(py_info_script) as py_info_script:</span>
<span class="gi">+        cmd = [exe, str(py_info_script), start_cookie, end_cookie]</span>
<span class="gi">+        # prevent sys.prefix from leaking into the child process - see https://bugs.python.org/issue22490</span>
<span class="gi">+        env = env.copy()</span>
<span class="gi">+        env.pop(&quot;__PYVENV_LAUNCHER__&quot;, None)</span>
<span class="gi">+        logging.debug(&quot;get interpreter info via cmd: %s&quot;, LogCmd(cmd))</span>
<span class="gi">+        try:</span>
<span class="gi">+            process = Popen(</span>
<span class="gi">+                cmd,  # noqa: S603</span>
<span class="gi">+                universal_newlines=True,</span>
<span class="gi">+                stdin=subprocess.PIPE,</span>
<span class="gi">+                stderr=subprocess.PIPE,</span>
<span class="gi">+                stdout=subprocess.PIPE,</span>
<span class="gi">+                env=env,</span>
<span class="gi">+                encoding=&quot;utf-8&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+            out, err = process.communicate()</span>
<span class="gi">+            code = process.returncode</span>
<span class="gi">+        except OSError as os_error:</span>
<span class="gi">+            out, err, code = &quot;&quot;, os_error.strerror, os_error.errno</span>
<span class="gi">+    result, failure = None, None</span>
<span class="gi">+    if code == 0:</span>
<span class="gi">+        out_starts = out.find(start_cookie[::-1])</span>
<span class="gi">+</span>
<span class="gi">+        if out_starts &gt; -1:</span>
<span class="gi">+            pre_cookie = out[:out_starts]</span>
<span class="gi">+</span>
<span class="gi">+            if pre_cookie:</span>
<span class="gi">+                sys.stdout.write(pre_cookie)</span>
<span class="gi">+</span>
<span class="gi">+            out = out[out_starts + COOKIE_LENGTH :]</span>
<span class="gi">+</span>
<span class="gi">+        out_ends = out.find(end_cookie[::-1])</span>
<span class="gi">+</span>
<span class="gi">+        if out_ends &gt; -1:</span>
<span class="gi">+            post_cookie = out[out_ends + COOKIE_LENGTH :]</span>
<span class="gi">+</span>
<span class="gi">+            if post_cookie:</span>
<span class="gi">+                sys.stdout.write(post_cookie)</span>
<span class="gi">+</span>
<span class="gi">+            out = out[:out_ends]</span>
<span class="gi">+</span>
<span class="gi">+        result = cls._from_json(out)</span>
<span class="gi">+        result.executable = exe  # keep original executable as this may contain initialization code</span>
<span class="gi">+    else:</span>
<span class="gi">+        msg = f&quot;{exe} with code {code}{f&#39; out: {out!r}&#39; if out else &#39;&#39;}{f&#39; err: {err!r}&#39; if err else &#39;&#39;}&quot;</span>
<span class="gi">+        failure = RuntimeError(f&quot;failed to query {msg}&quot;)</span>
<span class="gi">+    return failure, result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class LogCmd:</span>
<span class="gi">+    def __init__(self, cmd, env=None) -&gt; None:</span>
<span class="w"> </span>        self.cmd = cmd
<span class="w"> </span>        self.env = env

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        cmd_repr = &#39; &#39;.join(quote(str(c)) for c in self.cmd)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        cmd_repr = &quot; &quot;.join(quote(str(c)) for c in self.cmd)</span>
<span class="w"> </span>        if self.env is not None:
<span class="gd">-            cmd_repr = f&#39;{cmd_repr} env of {self.env!r}&#39;</span>
<span class="gi">+            cmd_repr = f&quot;{cmd_repr} env of {self.env!r}&quot;</span>
<span class="w"> </span>        return cmd_repr


<span class="gd">-___all___ = [&#39;from_exe&#39;, &#39;clear&#39;, &#39;LogCmd&#39;]</span>
<span class="gi">+def clear(app_data):</span>
<span class="gi">+    app_data.py_info_clear()</span>
<span class="gi">+    _CACHE.clear()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+___all___ = [</span>
<span class="gi">+    &quot;from_exe&quot;,</span>
<span class="gi">+    &quot;clear&quot;,</span>
<span class="gi">+    &quot;LogCmd&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/discovery/discover.py b/src/virtualenv/discovery/discover.py</span>
<span class="gh">index c6a9976..0aaa17c 100644</span>
<span class="gd">--- a/src/virtualenv/discovery/discover.py</span>
<span class="gi">+++ b/src/virtualenv/discovery/discover.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABC, abstractmethod


<span class="gu">@@ -12,9 +13,9 @@ class Discover(ABC):</span>

<span class="w"> </span>        :param parser: the CLI parser
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def __init__(self, options) -&gt;None:</span>
<span class="gi">+    def __init__(self, options) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a new discovery mechanism.

<span class="gu">@@ -31,12 +32,17 @@ class Discover(ABC):</span>

<span class="w"> </span>        :return: the interpreter ready to use for virtual environment creation
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def interpreter(self):
<span class="w"> </span>        &quot;&quot;&quot;:return: the interpreter as returned by :meth:`run`, cached&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._has_run is False:</span>
<span class="gi">+            self._interpreter = self.run()</span>
<span class="gi">+            self._has_run = True</span>
<span class="gi">+        return self._interpreter</span>


<span class="gd">-__all__ = [&#39;Discover&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Discover&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/discovery/py_info.py b/src/virtualenv/discovery/py_info.py</span>
<span class="gh">index 423ca50..882daa3 100644</span>
<span class="gd">--- a/src/virtualenv/discovery/py_info.py</span>
<span class="gi">+++ b/src/virtualenv/discovery/py_info.py</span>
<span class="gu">@@ -3,7 +3,9 @@ The PythonInfo contains information about a concrete instance of a Python interp</span>

<span class="w"> </span>Note: this file is also used to query target interpreters, so can only use standard library methods
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import json
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="gu">@@ -14,105 +16,320 @@ import sysconfig</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from collections import OrderedDict, namedtuple
<span class="w"> </span>from string import digits
<span class="gd">-VersionInfo = namedtuple(&#39;VersionInfo&#39;, [&#39;major&#39;, &#39;minor&#39;, &#39;micro&#39;,</span>
<span class="gd">-    &#39;releaselevel&#39;, &#39;serial&#39;])</span>
<span class="gi">+</span>
<span class="gi">+VersionInfo = namedtuple(&quot;VersionInfo&quot;, [&quot;major&quot;, &quot;minor&quot;, &quot;micro&quot;, &quot;releaselevel&quot;, &quot;serial&quot;])  # noqa: PYI024</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_path_extensions():</span>
<span class="gi">+    return list(OrderedDict.fromkeys([&quot;&quot;, *os.environ.get(&quot;PATHEXT&quot;, &quot;&quot;).lower().split(os.pathsep)]))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>EXTENSIONS = _get_path_extensions()
<span class="gd">-_CONF_VAR_RE = re.compile(&#39;\\{\\w+\\}&#39;)</span>
<span class="gi">+_CONF_VAR_RE = re.compile(r&quot;\{\w+\}&quot;)</span>


<span class="gd">-class PythonInfo:</span>
<span class="gi">+class PythonInfo:  # noqa: PLR0904</span>
<span class="w"> </span>    &quot;&quot;&quot;Contains information for a Python interpreter.&quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-</span>
<span class="gi">+    def __init__(self) -&gt; None:  # noqa: PLR0915</span>
<span class="w"> </span>        def abs_path(v):
<span class="gd">-            return None if v is None else os.path.abspath(v)</span>
<span class="gi">+            return None if v is None else os.path.abspath(v)  # unroll relative elements from path (e.g. ..)</span>
<span class="gi">+</span>
<span class="gi">+        # qualifies the python</span>
<span class="w"> </span>        self.platform = sys.platform
<span class="w"> </span>        self.implementation = platform.python_implementation()
<span class="gd">-        if self.implementation == &#39;PyPy&#39;:</span>
<span class="gi">+        if self.implementation == &quot;PyPy&quot;:</span>
<span class="w"> </span>            self.pypy_version_info = tuple(sys.pypy_version_info)
<span class="gi">+</span>
<span class="gi">+        # this is a tuple in earlier, struct later, unify to our own named tuple</span>
<span class="w"> </span>        self.version_info = VersionInfo(*sys.version_info)
<span class="gd">-        self.architecture = 64 if sys.maxsize &gt; 2 ** 32 else 32</span>
<span class="gd">-        self.version_nodot = sysconfig.get_config_var(&#39;py_version_nodot&#39;)</span>
<span class="gi">+        self.architecture = 64 if sys.maxsize &gt; 2**32 else 32</span>
<span class="gi">+</span>
<span class="gi">+        # Used to determine some file names.</span>
<span class="gi">+        # See `CPython3Windows.python_zip()`.</span>
<span class="gi">+        self.version_nodot = sysconfig.get_config_var(&quot;py_version_nodot&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.version = sys.version
<span class="w"> </span>        self.os = os.name
<span class="gd">-        self.prefix = abs_path(getattr(sys, &#39;prefix&#39;, None))</span>
<span class="gd">-        self.base_prefix = abs_path(getattr(sys, &#39;base_prefix&#39;, None))</span>
<span class="gd">-        self.real_prefix = abs_path(getattr(sys, &#39;real_prefix&#39;, None))</span>
<span class="gd">-        self.base_exec_prefix = abs_path(getattr(sys, &#39;base_exec_prefix&#39;, None)</span>
<span class="gd">-            )</span>
<span class="gd">-        self.exec_prefix = abs_path(getattr(sys, &#39;exec_prefix&#39;, None))</span>
<span class="gd">-        self.executable = abs_path(sys.executable)</span>
<span class="gd">-        self.original_executable = abs_path(self.executable)</span>
<span class="gd">-        self.system_executable = self._fast_get_system_executable()</span>
<span class="gi">+</span>
<span class="gi">+        # information about the prefix - determines python home</span>
<span class="gi">+        self.prefix = abs_path(getattr(sys, &quot;prefix&quot;, None))  # prefix we think</span>
<span class="gi">+        self.base_prefix = abs_path(getattr(sys, &quot;base_prefix&quot;, None))  # venv</span>
<span class="gi">+        self.real_prefix = abs_path(getattr(sys, &quot;real_prefix&quot;, None))  # old virtualenv</span>
<span class="gi">+</span>
<span class="gi">+        # information about the exec prefix - dynamic stdlib modules</span>
<span class="gi">+        self.base_exec_prefix = abs_path(getattr(sys, &quot;base_exec_prefix&quot;, None))</span>
<span class="gi">+        self.exec_prefix = abs_path(getattr(sys, &quot;exec_prefix&quot;, None))</span>
<span class="gi">+</span>
<span class="gi">+        self.executable = abs_path(sys.executable)  # the executable we were invoked via</span>
<span class="gi">+        self.original_executable = abs_path(self.executable)  # the executable as known by the interpreter</span>
<span class="gi">+        self.system_executable = self._fast_get_system_executable()  # the executable we are based of (if available)</span>
<span class="gi">+</span>
<span class="w"> </span>        try:
<span class="gd">-            __import__(&#39;venv&#39;)</span>
<span class="gi">+            __import__(&quot;venv&quot;)</span>
<span class="w"> </span>            has = True
<span class="w"> </span>        except ImportError:
<span class="w"> </span>            has = False
<span class="w"> </span>        self.has_venv = has
<span class="w"> </span>        self.path = sys.path
<span class="w"> </span>        self.file_system_encoding = sys.getfilesystemencoding()
<span class="gd">-        self.stdout_encoding = getattr(sys.stdout, &#39;encoding&#39;, None)</span>
<span class="gi">+        self.stdout_encoding = getattr(sys.stdout, &quot;encoding&quot;, None)</span>
<span class="gi">+</span>
<span class="w"> </span>        scheme_names = sysconfig.get_scheme_names()
<span class="gd">-        if &#39;venv&#39; in scheme_names:</span>
<span class="gd">-            self.sysconfig_scheme = &#39;venv&#39;</span>
<span class="gd">-            self.sysconfig_paths = {i: sysconfig.get_path(i, expand=False,</span>
<span class="gd">-                scheme=self.sysconfig_scheme) for i in sysconfig.</span>
<span class="gd">-                get_path_names()}</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;venv&quot; in scheme_names:</span>
<span class="gi">+            self.sysconfig_scheme = &quot;venv&quot;</span>
<span class="gi">+            self.sysconfig_paths = {</span>
<span class="gi">+                i: sysconfig.get_path(i, expand=False, scheme=self.sysconfig_scheme) for i in sysconfig.get_path_names()</span>
<span class="gi">+            }</span>
<span class="gi">+            # we cannot use distutils at all if &quot;venv&quot; exists, distutils don&#39;t know it</span>
<span class="w"> </span>            self.distutils_install = {}
<span class="gd">-        elif sys.version_info[:2] == (3, 10) and &#39;deb_system&#39; in scheme_names:</span>
<span class="gd">-            self.sysconfig_scheme = &#39;posix_prefix&#39;</span>
<span class="gd">-            self.sysconfig_paths = {i: sysconfig.get_path(i, expand=False,</span>
<span class="gd">-                scheme=self.sysconfig_scheme) for i in sysconfig.</span>
<span class="gd">-                get_path_names()}</span>
<span class="gi">+        # debian / ubuntu python 3.10 without `python3-distutils` will report</span>
<span class="gi">+        # mangled `local/bin` / etc. names for the default prefix</span>
<span class="gi">+        # intentionally select `posix_prefix` which is the unaltered posix-like paths</span>
<span class="gi">+        elif sys.version_info[:2] == (3, 10) and &quot;deb_system&quot; in scheme_names:</span>
<span class="gi">+            self.sysconfig_scheme = &quot;posix_prefix&quot;</span>
<span class="gi">+            self.sysconfig_paths = {</span>
<span class="gi">+                i: sysconfig.get_path(i, expand=False, scheme=self.sysconfig_scheme) for i in sysconfig.get_path_names()</span>
<span class="gi">+            }</span>
<span class="gi">+            # we cannot use distutils at all if &quot;venv&quot; exists, distutils don&#39;t know it</span>
<span class="w"> </span>            self.distutils_install = {}
<span class="w"> </span>        else:
<span class="w"> </span>            self.sysconfig_scheme = None
<span class="gd">-            self.sysconfig_paths = {i: sysconfig.get_path(i, expand=False) for</span>
<span class="gd">-                i in sysconfig.get_path_names()}</span>
<span class="gi">+            self.sysconfig_paths = {i: sysconfig.get_path(i, expand=False) for i in sysconfig.get_path_names()}</span>
<span class="w"> </span>            self.distutils_install = self._distutils_install().copy()
<span class="gd">-        makefile = getattr(sysconfig, &#39;get_makefile_filename&#39;, getattr(</span>
<span class="gd">-            sysconfig, &#39;_get_makefile_filename&#39;, None))</span>
<span class="gd">-        self.sysconfig = {k: v for k, v in [(&#39;makefile_filename&#39;, makefile(</span>
<span class="gd">-            ))] if k is not None}</span>
<span class="gi">+</span>
<span class="gi">+        # https://bugs.python.org/issue22199</span>
<span class="gi">+        makefile = getattr(sysconfig, &quot;get_makefile_filename&quot;, getattr(sysconfig, &quot;_get_makefile_filename&quot;, None))</span>
<span class="gi">+        self.sysconfig = {</span>
<span class="gi">+            k: v</span>
<span class="gi">+            for k, v in [</span>
<span class="gi">+                # a list of content to store from sysconfig</span>
<span class="gi">+                (&quot;makefile_filename&quot;, makefile()),</span>
<span class="gi">+            ]</span>
<span class="gi">+            if k is not None</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="w"> </span>        config_var_keys = set()
<span class="w"> </span>        for element in self.sysconfig_paths.values():
<span class="gd">-            config_var_keys.update(k[1:-1] for k in _CONF_VAR_RE.findall(</span>
<span class="gd">-                element))</span>
<span class="gd">-        config_var_keys.add(&#39;PYTHONFRAMEWORK&#39;)</span>
<span class="gd">-        self.sysconfig_vars = {i: sysconfig.get_config_var(i or &#39;&#39;) for i in</span>
<span class="gd">-            config_var_keys}</span>
<span class="gd">-        confs = {k: (self.system_prefix if v is not None and v.startswith(</span>
<span class="gd">-            self.prefix) else v) for k, v in self.sysconfig_vars.items()}</span>
<span class="gd">-        self.system_stdlib = self.sysconfig_path(&#39;stdlib&#39;, confs)</span>
<span class="gd">-        self.system_stdlib_platform = self.sysconfig_path(&#39;platstdlib&#39;, confs)</span>
<span class="gd">-        self.max_size = getattr(sys, &#39;maxsize&#39;, getattr(sys, &#39;maxint&#39;, None))</span>
<span class="gi">+            config_var_keys.update(k[1:-1] for k in _CONF_VAR_RE.findall(element))</span>
<span class="gi">+        config_var_keys.add(&quot;PYTHONFRAMEWORK&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.sysconfig_vars = {i: sysconfig.get_config_var(i or &quot;&quot;) for i in config_var_keys}</span>
<span class="gi">+</span>
<span class="gi">+        confs = {</span>
<span class="gi">+            k: (self.system_prefix if v is not None and v.startswith(self.prefix) else v)</span>
<span class="gi">+            for k, v in self.sysconfig_vars.items()</span>
<span class="gi">+        }</span>
<span class="gi">+        self.system_stdlib = self.sysconfig_path(&quot;stdlib&quot;, confs)</span>
<span class="gi">+        self.system_stdlib_platform = self.sysconfig_path(&quot;platstdlib&quot;, confs)</span>
<span class="gi">+        self.max_size = getattr(sys, &quot;maxsize&quot;, getattr(sys, &quot;maxint&quot;, None))</span>
<span class="w"> </span>        self._creators = None

<span class="w"> </span>    def _fast_get_system_executable(self):
<span class="w"> </span>        &quot;&quot;&quot;Try to get the system executable by just looking at properties.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;{}({!r})&#39;.format(self.__class__.__name__, {k: v for k, v in</span>
<span class="gd">-            self.__dict__.items() if not k.startswith(&#39;_&#39;)})</span>
<span class="gd">-</span>
<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return &#39;{}({})&#39;.format(self.__class__.__name__, &#39;, &#39;.join(</span>
<span class="gd">-            f&#39;{k}={v}&#39; for k, v in ((&#39;spec&#39;, self.spec), (&#39;system&#39; if self.</span>
<span class="gd">-            system_executable is not None and self.system_executable !=</span>
<span class="gd">-            self.executable else None, self.system_executable), (&#39;original&#39; if</span>
<span class="gd">-            self.original_executable not in {self.system_executable, self.</span>
<span class="gd">-            executable} else None, self.original_executable), (&#39;exe&#39;, self.</span>
<span class="gd">-            executable), (&#39;platform&#39;, self.platform), (&#39;version&#39;, repr(self</span>
<span class="gd">-            .version)), (&#39;encoding_fs_io&#39;,</span>
<span class="gd">-            f&#39;{self.file_system_encoding}-{self.stdout_encoding}&#39;)) if k is not</span>
<span class="gd">-            None))</span>
<span class="gd">-</span>
<span class="gd">-    def satisfies(self, spec, impl_must_match):</span>
<span class="gi">+        if self.real_prefix or (  # noqa: PLR1702</span>
<span class="gi">+            self.base_prefix is not None and self.base_prefix != self.prefix</span>
<span class="gi">+        ):  # if this is a virtual environment</span>
<span class="gi">+            if self.real_prefix is None:</span>
<span class="gi">+                base_executable = getattr(sys, &quot;_base_executable&quot;, None)  # some platforms may set this to help us</span>
<span class="gi">+                if base_executable is not None:  # noqa: SIM102 # use the saved system executable if present</span>
<span class="gi">+                    if sys.executable != base_executable:  # we know we&#39;re in a virtual environment, cannot be us</span>
<span class="gi">+                        if os.path.exists(base_executable):</span>
<span class="gi">+                            return base_executable</span>
<span class="gi">+                        # Python may return &quot;python&quot; because it was invoked from the POSIX virtual environment</span>
<span class="gi">+                        # however some installs/distributions do not provide a version-less &quot;python&quot; binary in</span>
<span class="gi">+                        # the system install location (see PEP 394) so try to fallback to a versioned binary.</span>
<span class="gi">+                        #</span>
<span class="gi">+                        # Gate this to Python 3.11 as `sys._base_executable` path resolution is now relative to</span>
<span class="gi">+                        # the &#39;home&#39; key from pyvenv.cfg which often points to the system install location.</span>
<span class="gi">+                        major, minor = self.version_info.major, self.version_info.minor</span>
<span class="gi">+                        if self.os == &quot;posix&quot; and (major, minor) &gt;= (3, 11):</span>
<span class="gi">+                            # search relative to the directory of sys._base_executable</span>
<span class="gi">+                            base_dir = os.path.dirname(base_executable)</span>
<span class="gi">+                            for base_executable in [</span>
<span class="gi">+                                os.path.join(base_dir, exe) for exe in (f&quot;python{major}&quot;, f&quot;python{major}.{minor}&quot;)</span>
<span class="gi">+                            ]:</span>
<span class="gi">+                                if os.path.exists(base_executable):</span>
<span class="gi">+                                    return base_executable</span>
<span class="gi">+            return None  # in this case we just can&#39;t tell easily without poking around FS and calling them, bail</span>
<span class="gi">+        # if we&#39;re not in a virtual environment, this is already a system python, so return the original executable</span>
<span class="gi">+        # note we must choose the original and not the pure executable as shim scripts might throw us off</span>
<span class="gi">+        return self.original_executable</span>
<span class="gi">+</span>
<span class="gi">+    def install_path(self, key):</span>
<span class="gi">+        result = self.distutils_install.get(key)</span>
<span class="gi">+        if result is None:  # use sysconfig if sysconfig_scheme is set or distutils is unavailable</span>
<span class="gi">+            # set prefixes to empty =&gt; result is relative from cwd</span>
<span class="gi">+            prefixes = self.prefix, self.exec_prefix, self.base_prefix, self.base_exec_prefix</span>
<span class="gi">+            config_var = {k: &quot;&quot; if v in prefixes else v for k, v in self.sysconfig_vars.items()}</span>
<span class="gi">+            result = self.sysconfig_path(key, config_var=config_var).lstrip(os.sep)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _distutils_install():</span>
<span class="gi">+        # use distutils primarily because that&#39;s what pip does</span>
<span class="gi">+        # https://github.com/pypa/pip/blob/main/src/pip/_internal/locations.py#L95</span>
<span class="gi">+        # note here we don&#39;t import Distribution directly to allow setuptools to patch it</span>
<span class="gi">+        with warnings.catch_warnings():  # disable warning for PEP-632</span>
<span class="gi">+            warnings.simplefilter(&quot;ignore&quot;)</span>
<span class="gi">+            try:</span>
<span class="gi">+                from distutils import dist  # noqa: PLC0415</span>
<span class="gi">+                from distutils.command.install import SCHEME_KEYS  # noqa: PLC0415</span>
<span class="gi">+            except ImportError:  # if removed or not installed ignore</span>
<span class="gi">+                return {}</span>
<span class="gi">+</span>
<span class="gi">+        d = dist.Distribution({&quot;script_args&quot;: &quot;--no-user-cfg&quot;})  # conf files not parsed so they do not hijack paths</span>
<span class="gi">+        if hasattr(sys, &quot;_framework&quot;):</span>
<span class="gi">+            sys._framework = None  # disable macOS static paths for framework  # noqa: SLF001</span>
<span class="gi">+</span>
<span class="gi">+        with warnings.catch_warnings():  # disable warning for PEP-632</span>
<span class="gi">+            warnings.simplefilter(&quot;ignore&quot;)</span>
<span class="gi">+            i = d.get_command_obj(&quot;install&quot;, create=True)</span>
<span class="gi">+</span>
<span class="gi">+        i.prefix = os.sep  # paths generated are relative to prefix that contains the path sep, this makes it relative</span>
<span class="gi">+        i.finalize_options()</span>
<span class="gi">+        return {key: (getattr(i, f&quot;install_{key}&quot;)[1:]).lstrip(os.sep) for key in SCHEME_KEYS}</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def version_str(self):</span>
<span class="gi">+        return &quot;.&quot;.join(str(i) for i in self.version_info[0:3])</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def version_release_str(self):</span>
<span class="gi">+        return &quot;.&quot;.join(str(i) for i in self.version_info[0:2])</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def python_name(self):</span>
<span class="gi">+        version_info = self.version_info</span>
<span class="gi">+        return f&quot;python{version_info.major}.{version_info.minor}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def is_old_virtualenv(self):</span>
<span class="gi">+        return self.real_prefix is not None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def is_venv(self):</span>
<span class="gi">+        return self.base_prefix is not None</span>
<span class="gi">+</span>
<span class="gi">+    def sysconfig_path(self, key, config_var=None, sep=os.sep):</span>
<span class="gi">+        pattern = self.sysconfig_paths[key]</span>
<span class="gi">+        if config_var is None:</span>
<span class="gi">+            config_var = self.sysconfig_vars</span>
<span class="gi">+        else:</span>
<span class="gi">+            base = self.sysconfig_vars.copy()</span>
<span class="gi">+            base.update(config_var)</span>
<span class="gi">+            config_var = base</span>
<span class="gi">+        return pattern.format(**config_var).replace(&quot;/&quot;, sep)</span>
<span class="gi">+</span>
<span class="gi">+    def creators(self, refresh=False):  # noqa: FBT002</span>
<span class="gi">+        if self._creators is None or refresh is True:</span>
<span class="gi">+            from virtualenv.run.plugin.creators import CreatorSelector  # noqa: PLC0415</span>
<span class="gi">+</span>
<span class="gi">+            self._creators = CreatorSelector.for_interpreter(self)</span>
<span class="gi">+        return self._creators</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def system_include(self):</span>
<span class="gi">+        path = self.sysconfig_path(</span>
<span class="gi">+            &quot;include&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                k: (self.system_prefix if v is not None and v.startswith(self.prefix) else v)</span>
<span class="gi">+                for k, v in self.sysconfig_vars.items()</span>
<span class="gi">+            },</span>
<span class="gi">+        )</span>
<span class="gi">+        if not os.path.exists(path):  # some broken packaging don&#39;t respect the sysconfig, fallback to distutils path</span>
<span class="gi">+            # the pattern include the distribution name too at the end, remove that via the parent call</span>
<span class="gi">+            fallback = os.path.join(self.prefix, os.path.dirname(self.install_path(&quot;headers&quot;)))</span>
<span class="gi">+            if os.path.exists(fallback):</span>
<span class="gi">+                path = fallback</span>
<span class="gi">+        return path</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def system_prefix(self):</span>
<span class="gi">+        return self.real_prefix or self.base_prefix or self.prefix</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def system_exec_prefix(self):</span>
<span class="gi">+        return self.real_prefix or self.base_exec_prefix or self.exec_prefix</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;{}({!r})&quot;.format(</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            {k: v for k, v in self.__dict__.items() if not k.startswith(&quot;_&quot;)},</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return &quot;{}({})&quot;.format(</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            &quot;, &quot;.join(</span>
<span class="gi">+                f&quot;{k}={v}&quot;</span>
<span class="gi">+                for k, v in (</span>
<span class="gi">+                    (&quot;spec&quot;, self.spec),</span>
<span class="gi">+                    (</span>
<span class="gi">+                        &quot;system&quot;</span>
<span class="gi">+                        if self.system_executable is not None and self.system_executable != self.executable</span>
<span class="gi">+                        else None,</span>
<span class="gi">+                        self.system_executable,</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    (</span>
<span class="gi">+                        &quot;original&quot;</span>
<span class="gi">+                        if self.original_executable not in {self.system_executable, self.executable}</span>
<span class="gi">+                        else None,</span>
<span class="gi">+                        self.original_executable,</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    (&quot;exe&quot;, self.executable),</span>
<span class="gi">+                    (&quot;platform&quot;, self.platform),</span>
<span class="gi">+                    (&quot;version&quot;, repr(self.version)),</span>
<span class="gi">+                    (&quot;encoding_fs_io&quot;, f&quot;{self.file_system_encoding}-{self.stdout_encoding}&quot;),</span>
<span class="gi">+                )</span>
<span class="gi">+                if k is not None</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def spec(self):</span>
<span class="gi">+        return &quot;{}{}-{}&quot;.format(self.implementation, &quot;.&quot;.join(str(i) for i in self.version_info), self.architecture)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def clear_cache(cls, app_data):</span>
<span class="gi">+        # this method is not used by itself, so here and called functions can import stuff locally</span>
<span class="gi">+        from virtualenv.discovery.cached_py_info import clear  # noqa: PLC0415</span>
<span class="gi">+</span>
<span class="gi">+        clear(app_data)</span>
<span class="gi">+        cls._cache_exe_discovery.clear()</span>
<span class="gi">+</span>
<span class="gi">+    def satisfies(self, spec, impl_must_match):  # noqa: C901</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if a given specification can be satisfied by the this python interpreter instance.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if spec.path:</span>
<span class="gi">+            if self.executable == os.path.abspath(spec.path):</span>
<span class="gi">+                return True  # if the path is a our own executable path we&#39;re done</span>
<span class="gi">+            if not spec.is_abs:</span>
<span class="gi">+                # if path set, and is not our original executable name, this does not match</span>
<span class="gi">+                basename = os.path.basename(self.original_executable)</span>
<span class="gi">+                spec_path = spec.path</span>
<span class="gi">+                if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+                    basename, suffix = os.path.splitext(basename)</span>
<span class="gi">+                    if spec_path.endswith(suffix):</span>
<span class="gi">+                        spec_path = spec_path[: -len(suffix)]</span>
<span class="gi">+                if basename != spec_path:</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            impl_must_match</span>
<span class="gi">+            and spec.implementation is not None</span>
<span class="gi">+            and spec.implementation.lower() != self.implementation.lower()</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if spec.architecture is not None and spec.architecture != self.architecture:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        for our, req in zip(self.version_info[0:3], (spec.major, spec.minor, spec.micro)):</span>
<span class="gi">+            if req is not None and our is not None and our != req:</span>
<span class="gi">+                return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="w"> </span>    _current_system = None
<span class="w"> </span>    _current = None

<span class="gu">@@ -121,37 +338,235 @@ class PythonInfo:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        This locates the current host interpreter information. This might be different than what we run into in case
<span class="w"> </span>        the host python has been upgraded from underneath us.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;  # noqa: D205</span>
<span class="gi">+        if cls._current is None:</span>
<span class="gi">+            cls._current = cls.from_exe(sys.executable, app_data, raise_on_error=True, resolve_to_host=False)</span>
<span class="gi">+        return cls._current</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def current_system(cls, app_data=None) -&gt;PythonInfo:</span>
<span class="gi">+    def current_system(cls, app_data=None) -&gt; PythonInfo:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        This locates the current host interpreter information. This might be different than what we run into in case
<span class="w"> </span>        the host python has been upgraded from underneath us.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;  # noqa: D205</span>
<span class="gi">+        if cls._current_system is None:</span>
<span class="gi">+            cls._current_system = cls.from_exe(sys.executable, app_data, raise_on_error=True, resolve_to_host=True)</span>
<span class="gi">+        return cls._current_system</span>
<span class="gi">+</span>
<span class="gi">+    def _to_json(self):</span>
<span class="gi">+        # don&#39;t save calculated paths, as these are non primitive types</span>
<span class="gi">+        return json.dumps(self._to_dict(), indent=2)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_dict(self):</span>
<span class="gi">+        data = {var: (getattr(self, var) if var != &quot;_creators&quot; else None) for var in vars(self)}</span>
<span class="gi">+</span>
<span class="gi">+        data[&quot;version_info&quot;] = data[&quot;version_info&quot;]._asdict()  # namedtuple to dictionary</span>
<span class="gi">+        return data</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_exe(cls, exe, app_data=None, raise_on_error=True, ignore_cache</span>
<span class="gd">-        =False, resolve_to_host=True, env=None):</span>
<span class="gi">+    def from_exe(  # noqa: PLR0913</span>
<span class="gi">+        cls,</span>
<span class="gi">+        exe,</span>
<span class="gi">+        app_data=None,</span>
<span class="gi">+        raise_on_error=True,  # noqa: FBT002</span>
<span class="gi">+        ignore_cache=False,  # noqa: FBT002</span>
<span class="gi">+        resolve_to_host=True,  # noqa: FBT002</span>
<span class="gi">+        env=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Given a path to an executable get the python information.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    _cache_exe_discovery = {}</span>
<span class="gi">+        # this method is not used by itself, so here and called functions can import stuff locally</span>
<span class="gi">+        from virtualenv.discovery.cached_py_info import from_exe  # noqa: PLC0415</span>

<span class="gi">+        env = os.environ if env is None else env</span>
<span class="gi">+        proposed = from_exe(cls, app_data, exe, env=env, raise_on_error=raise_on_error, ignore_cache=ignore_cache)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(proposed, PythonInfo) and resolve_to_host:</span>
<span class="gi">+            try:</span>
<span class="gi">+                proposed = proposed._resolve_to_system(app_data, proposed)  # noqa: SLF001</span>
<span class="gi">+            except Exception as exception:</span>
<span class="gi">+                if raise_on_error:</span>
<span class="gi">+                    raise</span>
<span class="gi">+                logging.info(&quot;ignore %s due cannot resolve system due to %r&quot;, proposed.original_executable, exception)</span>
<span class="gi">+                proposed = None</span>
<span class="gi">+        return proposed</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _from_json(cls, payload):</span>
<span class="gi">+        # the dictionary unroll here is to protect against pypy bug of interpreter crashing</span>
<span class="gi">+        raw = json.loads(payload)</span>
<span class="gi">+        return cls._from_dict(raw.copy())</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _from_dict(cls, data):</span>
<span class="gi">+        data[&quot;version_info&quot;] = VersionInfo(**data[&quot;version_info&quot;])  # restore this to a named tuple structure</span>
<span class="gi">+        result = cls()</span>
<span class="gi">+        result.__dict__ = data.copy()</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _resolve_to_system(cls, app_data, target):</span>
<span class="gi">+        start_executable = target.executable</span>
<span class="gi">+        prefixes = OrderedDict()</span>
<span class="gi">+        while target.system_executable is None:</span>
<span class="gi">+            prefix = target.real_prefix or target.base_prefix or target.prefix</span>
<span class="gi">+            if prefix in prefixes:</span>
<span class="gi">+                if len(prefixes) == 1:</span>
<span class="gi">+                    # if we&#39;re linking back to ourselves accept ourselves with a WARNING</span>
<span class="gi">+                    logging.info(&quot;%r links back to itself via prefixes&quot;, target)</span>
<span class="gi">+                    target.system_executable = target.executable</span>
<span class="gi">+                    break</span>
<span class="gi">+                for at, (p, t) in enumerate(prefixes.items(), start=1):</span>
<span class="gi">+                    logging.error(&quot;%d: prefix=%s, info=%r&quot;, at, p, t)</span>
<span class="gi">+                logging.error(&quot;%d: prefix=%s, info=%r&quot;, len(prefixes) + 1, prefix, target)</span>
<span class="gi">+                msg = &quot;prefixes are causing a circle {}&quot;.format(&quot;|&quot;.join(prefixes.keys()))</span>
<span class="gi">+                raise RuntimeError(msg)</span>
<span class="gi">+            prefixes[prefix] = target</span>
<span class="gi">+            target = target.discover_exe(app_data, prefix=prefix, exact=False)</span>
<span class="gi">+        if target.executable != target.system_executable:</span>
<span class="gi">+            target = cls.from_exe(target.system_executable, app_data)</span>
<span class="gi">+        target.executable = start_executable</span>
<span class="gi">+        return target</span>
<span class="gi">+</span>
<span class="gi">+    _cache_exe_discovery = {}  # noqa: RUF012</span>
<span class="gi">+</span>
<span class="gi">+    def discover_exe(self, app_data, prefix, exact=True, env=None):  # noqa: FBT002</span>
<span class="gi">+        key = prefix, exact</span>
<span class="gi">+        if key in self._cache_exe_discovery and prefix:</span>
<span class="gi">+            logging.debug(&quot;discover exe from cache %s - exact %s: %r&quot;, prefix, exact, self._cache_exe_discovery[key])</span>
<span class="gi">+            return self._cache_exe_discovery[key]</span>
<span class="gi">+        logging.debug(&quot;discover exe for %s in %s&quot;, self, prefix)</span>
<span class="gi">+        # we don&#39;t know explicitly here, do some guess work - our executable name should tell</span>
<span class="gi">+        possible_names = self._find_possible_exe_names()</span>
<span class="gi">+        possible_folders = self._find_possible_folders(prefix)</span>
<span class="gi">+        discovered = []</span>
<span class="gi">+        env = os.environ if env is None else env</span>
<span class="gi">+        for folder in possible_folders:</span>
<span class="gi">+            for name in possible_names:</span>
<span class="gi">+                info = self._check_exe(app_data, folder, name, exact, discovered, env)</span>
<span class="gi">+                if info is not None:</span>
<span class="gi">+                    self._cache_exe_discovery[key] = info</span>
<span class="gi">+                    return info</span>
<span class="gi">+        if exact is False and discovered:</span>
<span class="gi">+            info = self._select_most_likely(discovered, self)</span>
<span class="gi">+            folders = os.pathsep.join(possible_folders)</span>
<span class="gi">+            self._cache_exe_discovery[key] = info</span>
<span class="gi">+            logging.debug(&quot;no exact match found, chosen most similar of %s within base folders %s&quot;, info, folders)</span>
<span class="gi">+            return info</span>
<span class="gi">+        msg = &quot;failed to detect {} in {}&quot;.format(&quot;|&quot;.join(possible_names), os.pathsep.join(possible_folders))</span>
<span class="gi">+        raise RuntimeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_exe(self, app_data, folder, name, exact, discovered, env):  # noqa: PLR0913</span>
<span class="gi">+        exe_path = os.path.join(folder, name)</span>
<span class="gi">+        if not os.path.exists(exe_path):</span>
<span class="gi">+            return None</span>
<span class="gi">+        info = self.from_exe(exe_path, app_data, resolve_to_host=False, raise_on_error=False, env=env)</span>
<span class="gi">+        if info is None:  # ignore if for some reason we can&#39;t query</span>
<span class="gi">+            return None</span>
<span class="gi">+        for item in [&quot;implementation&quot;, &quot;architecture&quot;, &quot;version_info&quot;]:</span>
<span class="gi">+            found = getattr(info, item)</span>
<span class="gi">+            searched = getattr(self, item)</span>
<span class="gi">+            if found != searched:</span>
<span class="gi">+                if item == &quot;version_info&quot;:</span>
<span class="gi">+                    found, searched = &quot;.&quot;.join(str(i) for i in found), &quot;.&quot;.join(str(i) for i in searched)</span>
<span class="gi">+                executable = info.executable</span>
<span class="gi">+                logging.debug(&quot;refused interpreter %s because %s differs %s != %s&quot;, executable, item, found, searched)</span>
<span class="gi">+                if exact is False:</span>
<span class="gi">+                    discovered.append(info)</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            return info</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _select_most_likely(discovered, target):</span>
<span class="gi">+        # no exact match found, start relaxing our requirements then to facilitate system package upgrades that</span>
<span class="gi">+        # could cause this (when using copy strategy of the host python)</span>
<span class="gi">+        def sort_by(info):</span>
<span class="gi">+            # we need to setup some priority of traits, this is as follows:</span>
<span class="gi">+            # implementation, major, minor, micro, architecture, tag, serial</span>
<span class="gi">+            matches = [</span>
<span class="gi">+                info.implementation == target.implementation,</span>
<span class="gi">+                info.version_info.major == target.version_info.major,</span>
<span class="gi">+                info.version_info.minor == target.version_info.minor,</span>
<span class="gi">+                info.architecture == target.architecture,</span>
<span class="gi">+                info.version_info.micro == target.version_info.micro,</span>
<span class="gi">+                info.version_info.releaselevel == target.version_info.releaselevel,</span>
<span class="gi">+                info.version_info.serial == target.version_info.serial,</span>
<span class="gi">+            ]</span>
<span class="gi">+            return sum((1 &lt;&lt; pos if match else 0) for pos, match in enumerate(reversed(matches)))</span>
<span class="gi">+</span>
<span class="gi">+        sorted_discovered = sorted(discovered, key=sort_by, reverse=True)  # sort by priority in decreasing order</span>
<span class="gi">+        return sorted_discovered[0]</span>
<span class="gi">+</span>
<span class="gi">+    def _find_possible_folders(self, inside_folder):</span>
<span class="gi">+        candidate_folder = OrderedDict()</span>
<span class="gi">+        executables = OrderedDict()</span>
<span class="gi">+        executables[os.path.realpath(self.executable)] = None</span>
<span class="gi">+        executables[self.executable] = None</span>
<span class="gi">+        executables[os.path.realpath(self.original_executable)] = None</span>
<span class="gi">+        executables[self.original_executable] = None</span>
<span class="gi">+        for exe in executables:</span>
<span class="gi">+            base = os.path.dirname(exe)</span>
<span class="gi">+            # following path pattern of the current</span>
<span class="gi">+            if base.startswith(self.prefix):</span>
<span class="gi">+                relative = base[len(self.prefix) :]</span>
<span class="gi">+                candidate_folder[f&quot;{inside_folder}{relative}&quot;] = None</span>
<span class="gi">+</span>
<span class="gi">+        # or at root level</span>
<span class="gi">+        candidate_folder[inside_folder] = None</span>
<span class="gi">+        return [i for i in candidate_folder if os.path.exists(i)]</span>
<span class="gi">+</span>
<span class="gi">+    def _find_possible_exe_names(self):</span>
<span class="gi">+        name_candidate = OrderedDict()</span>
<span class="gi">+        for name in self._possible_base():</span>
<span class="gi">+            for at in (3, 2, 1, 0):</span>
<span class="gi">+                version = &quot;.&quot;.join(str(i) for i in self.version_info[:at])</span>
<span class="gi">+                for arch in [f&quot;-{self.architecture}&quot;, &quot;&quot;]:</span>
<span class="gi">+                    for ext in EXTENSIONS:</span>
<span class="gi">+                        candidate = f&quot;{name}{version}{arch}{ext}&quot;</span>
<span class="gi">+                        name_candidate[candidate] = None</span>
<span class="gi">+        return list(name_candidate.keys())</span>
<span class="gi">+</span>
<span class="gi">+    def _possible_base(self):</span>
<span class="gi">+        possible_base = OrderedDict()</span>
<span class="gi">+        basename = os.path.splitext(os.path.basename(self.executable))[0].rstrip(digits)</span>
<span class="gi">+        possible_base[basename] = None</span>
<span class="gi">+        possible_base[self.implementation] = None</span>
<span class="gi">+        # python is always the final option as in practice is used by multiple implementation as exe name</span>
<span class="gi">+        if &quot;python&quot; in possible_base:</span>
<span class="gi">+            del possible_base[&quot;python&quot;]</span>
<span class="gi">+        possible_base[&quot;python&quot;] = None</span>
<span class="gi">+        for base in possible_base:</span>
<span class="gi">+            lower = base.lower()</span>
<span class="gi">+            yield lower</span>
<span class="gi">+            from virtualenv.info import fs_is_case_sensitive  # noqa: PLC0415</span>
<span class="gi">+</span>
<span class="gi">+            if fs_is_case_sensitive():</span>
<span class="gi">+                if base != lower:</span>
<span class="gi">+                    yield base</span>
<span class="gi">+                upper = base.upper()</span>
<span class="gi">+                if upper != base:</span>
<span class="gi">+                    yield upper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="gi">+    # dump a JSON representation of the current python</span>

<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="w"> </span>    argv = sys.argv[1:]
<span class="gi">+</span>
<span class="w"> </span>    if len(argv) &gt;= 1:
<span class="w"> </span>        start_cookie = argv[0]
<span class="w"> </span>        argv = argv[1:]
<span class="w"> </span>    else:
<span class="gd">-        start_cookie = &#39;&#39;</span>
<span class="gi">+        start_cookie = &quot;&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>    if len(argv) &gt;= 1:
<span class="w"> </span>        end_cookie = argv[0]
<span class="w"> </span>        argv = argv[1:]
<span class="w"> </span>    else:
<span class="gd">-        end_cookie = &#39;&#39;</span>
<span class="gi">+        end_cookie = &quot;&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>    sys.argv = sys.argv[:1] + argv
<span class="gd">-    info = PythonInfo()._to_json()</span>
<span class="gd">-    sys.stdout.write(&#39;&#39;.join((start_cookie[::-1], info, end_cookie[::-1])))</span>
<span class="gi">+</span>
<span class="gi">+    info = PythonInfo()._to_json()  # noqa: SLF001</span>
<span class="gi">+    sys.stdout.write(&quot;&quot;.join((start_cookie[::-1], info, end_cookie[::-1])))</span>
<span class="gh">diff --git a/src/virtualenv/discovery/py_spec.py b/src/virtualenv/discovery/py_spec.py</span>
<span class="gh">index fda6851..dcd84f4 100644</span>
<span class="gd">--- a/src/virtualenv/discovery/py_spec.py</span>
<span class="gi">+++ b/src/virtualenv/discovery/py_spec.py</span>
<span class="gu">@@ -1,17 +1,26 @@</span>
<span class="w"> </span>&quot;&quot;&quot;A Python specification is an abstract requirement definition of an interpreter.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="gd">-PATTERN = re.compile(</span>
<span class="gd">-    &#39;^(?P&lt;impl&gt;[a-zA-Z]+)?(?P&lt;version&gt;[0-9.]+)?(?:-(?P&lt;arch&gt;32|64))?$&#39;)</span>
<span class="gi">+</span>
<span class="gi">+PATTERN = re.compile(r&quot;^(?P&lt;impl&gt;[a-zA-Z]+)?(?P&lt;version&gt;[0-9.]+)?(?:-(?P&lt;arch&gt;32|64))?$&quot;)</span>


<span class="w"> </span>class PythonSpec:
<span class="w"> </span>    &quot;&quot;&quot;Contains specification about a Python Interpreter.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, str_spec: str, implementation: (str | None), major:</span>
<span class="gd">-        (int | None), minor: (int | None), micro: (int | None),</span>
<span class="gd">-        architecture: (int | None), path: (str | None)) -&gt;None:</span>
<span class="gi">+    def __init__(  # noqa: PLR0913</span>
<span class="gi">+        self,</span>
<span class="gi">+        str_spec: str,</span>
<span class="gi">+        implementation: str | None,</span>
<span class="gi">+        major: int | None,</span>
<span class="gi">+        minor: int | None,</span>
<span class="gi">+        micro: int | None,</span>
<span class="gi">+        architecture: int | None,</span>
<span class="gi">+        path: str | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.str_spec = str_spec
<span class="w"> </span>        self.implementation = implementation
<span class="w"> </span>        self.major = major
<span class="gu">@@ -20,21 +29,94 @@ class PythonSpec:</span>
<span class="w"> </span>        self.architecture = architecture
<span class="w"> </span>        self.path = path

<span class="gd">-    def generate_re(self, *, windows: bool) -&gt;re.Pattern:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_string_spec(cls, string_spec: str):  # noqa: C901, PLR0912</span>
<span class="gi">+        impl, major, minor, micro, arch, path = None, None, None, None, None, None</span>
<span class="gi">+        if os.path.isabs(string_spec):  # noqa: PLR1702</span>
<span class="gi">+            path = string_spec</span>
<span class="gi">+        else:</span>
<span class="gi">+            ok = False</span>
<span class="gi">+            match = re.match(PATTERN, string_spec)</span>
<span class="gi">+            if match:</span>
<span class="gi">+</span>
<span class="gi">+                def _int_or_none(val):</span>
<span class="gi">+                    return None if val is None else int(val)</span>
<span class="gi">+</span>
<span class="gi">+                try:</span>
<span class="gi">+                    groups = match.groupdict()</span>
<span class="gi">+                    version = groups[&quot;version&quot;]</span>
<span class="gi">+                    if version is not None:</span>
<span class="gi">+                        versions = tuple(int(i) for i in version.split(&quot;.&quot;) if i)</span>
<span class="gi">+                        if len(versions) &gt; 3:  # noqa: PLR2004</span>
<span class="gi">+                            raise ValueError  # noqa: TRY301</span>
<span class="gi">+                        if len(versions) == 3:  # noqa: PLR2004</span>
<span class="gi">+                            major, minor, micro = versions</span>
<span class="gi">+                        elif len(versions) == 2:  # noqa: PLR2004</span>
<span class="gi">+                            major, minor = versions</span>
<span class="gi">+                        elif len(versions) == 1:</span>
<span class="gi">+                            version_data = versions[0]</span>
<span class="gi">+                            major = int(str(version_data)[0])  # first digit major</span>
<span class="gi">+                            if version_data &gt; 9:  # noqa: PLR2004</span>
<span class="gi">+                                minor = int(str(version_data)[1:])</span>
<span class="gi">+                    ok = True</span>
<span class="gi">+                except ValueError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    impl = groups[&quot;impl&quot;]</span>
<span class="gi">+                    if impl in {&quot;py&quot;, &quot;python&quot;}:</span>
<span class="gi">+                        impl = None</span>
<span class="gi">+                    arch = _int_or_none(groups[&quot;arch&quot;])</span>
<span class="gi">+</span>
<span class="gi">+            if not ok:</span>
<span class="gi">+                path = string_spec</span>
<span class="gi">+</span>
<span class="gi">+        return cls(string_spec, impl, major, minor, micro, arch, path)</span>
<span class="gi">+</span>
<span class="gi">+    def generate_re(self, *, windows: bool) -&gt; re.Pattern:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate a regular expression for matching against a filename.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        version = r&quot;{}(\.{}(\.{})?)?&quot;.format(</span>
<span class="gi">+            *(r&quot;\d+&quot; if v is None else v for v in (self.major, self.minor, self.micro))</span>
<span class="gi">+        )</span>
<span class="gi">+        impl = &quot;python&quot; if self.implementation is None else f&quot;python|{re.escape(self.implementation)}&quot;</span>
<span class="gi">+        suffix = r&quot;\.exe&quot; if windows else &quot;&quot;</span>
<span class="gi">+        version_conditional = (</span>
<span class="gi">+            &quot;?&quot;</span>
<span class="gi">+            # Windows Python executables are almost always unversioned</span>
<span class="gi">+            if windows</span>
<span class="gi">+            # Spec is an empty string</span>
<span class="gi">+            or self.major is None</span>
<span class="gi">+            else &quot;&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        # Try matching `direct` first, so the `direct` group is filled when possible.</span>
<span class="gi">+        return re.compile(</span>
<span class="gi">+            rf&quot;(?P&lt;impl&gt;{impl})(?P&lt;v&gt;{version}){version_conditional}{suffix}$&quot;,</span>
<span class="gi">+            flags=re.IGNORECASE,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def is_abs(self):</span>
<span class="gi">+        return self.path is not None and os.path.isabs(self.path)</span>

<span class="w"> </span>    def satisfies(self, spec):
<span class="w"> </span>        &quot;&quot;&quot;Called when there&#39;s a candidate metadata spec to see if compatible - e.g. PEP-514 on Windows.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if spec.is_abs and self.is_abs and self.path != spec.path:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if spec.implementation is not None and spec.implementation.lower() != self.implementation.lower():</span>
<span class="gi">+            return False</span>
<span class="gi">+        if spec.architecture is not None and spec.architecture != self.architecture:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        for our, req in zip((self.major, self.minor, self.micro), (spec.major, spec.minor, spec.micro)):</span>
<span class="gi">+            if req is not None and our is not None and our != req:</span>
<span class="gi">+                return False</span>
<span class="gi">+        return True</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        name = type(self).__name__
<span class="gd">-        params = (&#39;implementation&#39;, &#39;major&#39;, &#39;minor&#39;, &#39;micro&#39;,</span>
<span class="gd">-            &#39;architecture&#39;, &#39;path&#39;)</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&quot;{name}({&#39;, &#39;.join(f&#39;{k}={getattr(self, k)}&#39; for k in params if getattr(self, k) is not None)})&quot;</span>
<span class="gd">-            )</span>
<span class="gi">+        params = &quot;implementation&quot;, &quot;major&quot;, &quot;minor&quot;, &quot;micro&quot;, &quot;architecture&quot;, &quot;path&quot;</span>
<span class="gi">+        return f&quot;{name}({&#39;, &#39;.join(f&#39;{k}={getattr(self, k)}&#39; for k in params if getattr(self, k) is not None)})&quot;</span>


<span class="gd">-__all__ = [&#39;PythonSpec&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;PythonSpec&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/discovery/windows/pep514.py b/src/virtualenv/discovery/windows/pep514.py</span>
<span class="gh">index 3635215..8bc9e30 100644</span>
<span class="gd">--- a/src/virtualenv/discovery/windows/pep514.py</span>
<span class="gi">+++ b/src/virtualenv/discovery/windows/pep514.py</span>
<span class="gu">@@ -1,9 +1,152 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Implement https://www.python.org/dev/peps/pep-0514/ to discover interpreters - Windows only.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="w"> </span>import winreg
<span class="w"> </span>from logging import basicConfig, getLogger
<span class="gi">+</span>
<span class="w"> </span>LOGGER = getLogger(__name__)
<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def enum_keys(key):</span>
<span class="gi">+    at = 0</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield winreg.EnumKey(key, at)</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            break</span>
<span class="gi">+        at += 1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_value(key, value_name):</span>
<span class="gi">+    try:</span>
<span class="gi">+        return winreg.QueryValueEx(key, value_name)[0]</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def discover_pythons():</span>
<span class="gi">+    for hive, hive_name, key, flags, default_arch in [</span>
<span class="gi">+        (winreg.HKEY_CURRENT_USER, &quot;HKEY_CURRENT_USER&quot;, r&quot;Software\Python&quot;, 0, 64),</span>
<span class="gi">+        (winreg.HKEY_LOCAL_MACHINE, &quot;HKEY_LOCAL_MACHINE&quot;, r&quot;Software\Python&quot;, winreg.KEY_WOW64_64KEY, 64),</span>
<span class="gi">+        (winreg.HKEY_LOCAL_MACHINE, &quot;HKEY_LOCAL_MACHINE&quot;, r&quot;Software\Python&quot;, winreg.KEY_WOW64_32KEY, 32),</span>
<span class="gi">+    ]:</span>
<span class="gi">+        yield from process_set(hive, hive_name, key, flags, default_arch)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def process_set(hive, hive_name, key, flags, default_arch):</span>
<span class="gi">+    try:</span>
<span class="gi">+        with winreg.OpenKeyEx(hive, key, 0, winreg.KEY_READ | flags) as root_key:</span>
<span class="gi">+            for company in enum_keys(root_key):</span>
<span class="gi">+                if company == &quot;PyLauncher&quot;:  # reserved</span>
<span class="gi">+                    continue</span>
<span class="gi">+                yield from process_company(hive_name, company, root_key, default_arch)</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def process_company(hive_name, company, root_key, default_arch):</span>
<span class="gi">+    with winreg.OpenKeyEx(root_key, company) as company_key:</span>
<span class="gi">+        for tag in enum_keys(company_key):</span>
<span class="gi">+            spec = process_tag(hive_name, company, company_key, tag, default_arch)</span>
<span class="gi">+            if spec is not None:</span>
<span class="gi">+                yield spec</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def process_tag(hive_name, company, company_key, tag, default_arch):</span>
<span class="gi">+    with winreg.OpenKeyEx(company_key, tag) as tag_key:</span>
<span class="gi">+        version = load_version_data(hive_name, company, tag, tag_key)</span>
<span class="gi">+        if version is not None:  # if failed to get version bail</span>
<span class="gi">+            major, minor, _ = version</span>
<span class="gi">+            arch = load_arch_data(hive_name, company, tag, tag_key, default_arch)</span>
<span class="gi">+            if arch is not None:</span>
<span class="gi">+                exe_data = load_exe(hive_name, company, company_key, tag)</span>
<span class="gi">+                if exe_data is not None:</span>
<span class="gi">+                    exe, args = exe_data</span>
<span class="gi">+                    return company, major, minor, arch, exe, args</span>
<span class="gi">+                return None</span>
<span class="gi">+            return None</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_exe(hive_name, company, company_key, tag):</span>
<span class="gi">+    key_path = f&quot;{hive_name}/{company}/{tag}&quot;</span>
<span class="gi">+    try:</span>
<span class="gi">+        with winreg.OpenKeyEx(company_key, rf&quot;{tag}\InstallPath&quot;) as ip_key, ip_key:</span>
<span class="gi">+            exe = get_value(ip_key, &quot;ExecutablePath&quot;)</span>
<span class="gi">+            if exe is None:</span>
<span class="gi">+                ip = get_value(ip_key, None)</span>
<span class="gi">+                if ip is None:</span>
<span class="gi">+                    msg(key_path, &quot;no ExecutablePath or default for it&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                else:</span>
<span class="gi">+                    exe = os.path.join(ip, &quot;python.exe&quot;)</span>
<span class="gi">+            if exe is not None and os.path.exists(exe):</span>
<span class="gi">+                args = get_value(ip_key, &quot;ExecutableArguments&quot;)</span>
<span class="gi">+                return exe, args</span>
<span class="gi">+            msg(key_path, f&quot;could not load exe with value {exe}&quot;)</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        msg(f&quot;{key_path}/InstallPath&quot;, &quot;missing&quot;)</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_arch_data(hive_name, company, tag, tag_key, default_arch):</span>
<span class="gi">+    arch_str = get_value(tag_key, &quot;SysArchitecture&quot;)</span>
<span class="gi">+    if arch_str is not None:</span>
<span class="gi">+        key_path = f&quot;{hive_name}/{company}/{tag}/SysArchitecture&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            return parse_arch(arch_str)</span>
<span class="gi">+        except ValueError as sys_arch:</span>
<span class="gi">+            msg(key_path, sys_arch)</span>
<span class="gi">+    return default_arch</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_arch(arch_str):</span>
<span class="gi">+    if isinstance(arch_str, str):</span>
<span class="gi">+        match = re.match(r&quot;^(\d+)bit$&quot;, arch_str)</span>
<span class="gi">+        if match:</span>
<span class="gi">+            return int(next(iter(match.groups())))</span>
<span class="gi">+        error = f&quot;invalid format {arch_str}&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        error = f&quot;arch is not string: {arch_str!r}&quot;</span>
<span class="gi">+    raise ValueError(error)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_version_data(hive_name, company, tag, tag_key):</span>
<span class="gi">+    for candidate, key_path in [</span>
<span class="gi">+        (get_value(tag_key, &quot;SysVersion&quot;), f&quot;{hive_name}/{company}/{tag}/SysVersion&quot;),</span>
<span class="gi">+        (tag, f&quot;{hive_name}/{company}/{tag}&quot;),</span>
<span class="gi">+    ]:</span>
<span class="gi">+        if candidate is not None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return parse_version(candidate)</span>
<span class="gi">+            except ValueError as sys_version:</span>
<span class="gi">+                msg(key_path, sys_version)</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_version(version_str):</span>
<span class="gi">+    if isinstance(version_str, str):</span>
<span class="gi">+        match = re.match(r&quot;^(\d+)(?:\.(\d+))?(?:\.(\d+))?$&quot;, version_str)</span>
<span class="gi">+        if match:</span>
<span class="gi">+            return tuple(int(i) if i is not None else None for i in match.groups())</span>
<span class="gi">+        error = f&quot;invalid format {version_str}&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        error = f&quot;version is not string: {version_str!r}&quot;</span>
<span class="gi">+    raise ValueError(error)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def msg(path, what):</span>
<span class="gi">+    LOGGER.warning(&quot;PEP-514 violation in Windows Registry at %s error: %s&quot;, path, what)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _run():</span>
<span class="gi">+    basicConfig()</span>
<span class="gi">+    interpreters = [repr(spec) for spec in discover_pythons()]</span>
<span class="gi">+    print(&quot;\n&quot;.join(sorted(interpreters)))  # noqa: T201</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    _run()
<span class="gh">diff --git a/src/virtualenv/info.py b/src/virtualenv/info.py</span>
<span class="gh">index 974fc0b..8b217d0 100644</span>
<span class="gd">--- a/src/virtualenv/info.py</span>
<span class="gi">+++ b/src/virtualenv/info.py</span>
<span class="gu">@@ -1,17 +1,65 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="w"> </span>import platform
<span class="w"> </span>import sys
<span class="w"> </span>import tempfile
<span class="gi">+</span>
<span class="w"> </span>IMPLEMENTATION = platform.python_implementation()
<span class="gd">-IS_PYPY = IMPLEMENTATION == &#39;PyPy&#39;</span>
<span class="gd">-IS_CPYTHON = IMPLEMENTATION == &#39;CPython&#39;</span>
<span class="gd">-IS_WIN = sys.platform == &#39;win32&#39;</span>
<span class="gd">-IS_MAC_ARM64 = sys.platform == &#39;darwin&#39; and platform.machine() == &#39;arm64&#39;</span>
<span class="gd">-ROOT = os.path.realpath(os.path.join(os.path.abspath(__file__), os.path.</span>
<span class="gd">-    pardir, os.path.pardir))</span>
<span class="gi">+IS_PYPY = IMPLEMENTATION == &quot;PyPy&quot;</span>
<span class="gi">+IS_CPYTHON = IMPLEMENTATION == &quot;CPython&quot;</span>
<span class="gi">+IS_WIN = sys.platform == &quot;win32&quot;</span>
<span class="gi">+IS_MAC_ARM64 = sys.platform == &quot;darwin&quot; and platform.machine() == &quot;arm64&quot;</span>
<span class="gi">+ROOT = os.path.realpath(os.path.join(os.path.abspath(__file__), os.path.pardir, os.path.pardir))</span>
<span class="w"> </span>IS_ZIPAPP = os.path.isfile(ROOT)
<span class="w"> </span>_CAN_SYMLINK = _FS_CASE_SENSITIVE = _CFG_DIR = _DATA_DIR = None
<span class="gd">-__all__ = (&#39;IS_CPYTHON&#39;, &#39;IS_MAC_ARM64&#39;, &#39;IS_PYPY&#39;, &#39;IS_WIN&#39;, &#39;IS_ZIPAPP&#39;,</span>
<span class="gd">-    &#39;ROOT&#39;, &#39;fs_is_case_sensitive&#39;, &#39;fs_path_id&#39;, &#39;fs_supports_symlink&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def fs_is_case_sensitive():</span>
<span class="gi">+    global _FS_CASE_SENSITIVE  # noqa: PLW0603</span>
<span class="gi">+</span>
<span class="gi">+    if _FS_CASE_SENSITIVE is None:</span>
<span class="gi">+        with tempfile.NamedTemporaryFile(prefix=&quot;TmP&quot;) as tmp_file:</span>
<span class="gi">+            _FS_CASE_SENSITIVE = not os.path.exists(tmp_file.name.lower())</span>
<span class="gi">+            logging.debug(&quot;filesystem is %scase-sensitive&quot;, &quot;&quot; if _FS_CASE_SENSITIVE else &quot;not &quot;)</span>
<span class="gi">+    return _FS_CASE_SENSITIVE</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def fs_supports_symlink():</span>
<span class="gi">+    global _CAN_SYMLINK  # noqa: PLW0603</span>
<span class="gi">+</span>
<span class="gi">+    if _CAN_SYMLINK is None:</span>
<span class="gi">+        can = False</span>
<span class="gi">+        if hasattr(os, &quot;symlink&quot;):</span>
<span class="gi">+            if IS_WIN:</span>
<span class="gi">+                with tempfile.NamedTemporaryFile(prefix=&quot;TmP&quot;) as tmp_file:</span>
<span class="gi">+                    temp_dir = os.path.dirname(tmp_file.name)</span>
<span class="gi">+                    dest = os.path.join(temp_dir, f&quot;{tmp_file.name}-{&#39;b&#39;}&quot;)</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        os.symlink(tmp_file.name, dest)</span>
<span class="gi">+                        can = True</span>
<span class="gi">+                    except (OSError, NotImplementedError):</span>
<span class="gi">+                        pass</span>
<span class="gi">+                logging.debug(&quot;symlink on filesystem does%s work&quot;, &quot;&quot; if can else &quot; not&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                can = True</span>
<span class="gi">+        _CAN_SYMLINK = can</span>
<span class="gi">+    return _CAN_SYMLINK</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def fs_path_id(path: str) -&gt; str:</span>
<span class="gi">+    return path.casefold() if fs_is_case_sensitive() else path</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (</span>
<span class="gi">+    &quot;IS_CPYTHON&quot;,</span>
<span class="gi">+    &quot;IS_MAC_ARM64&quot;,</span>
<span class="gi">+    &quot;IS_PYPY&quot;,</span>
<span class="gi">+    &quot;IS_WIN&quot;,</span>
<span class="gi">+    &quot;IS_ZIPAPP&quot;,</span>
<span class="gi">+    &quot;ROOT&quot;,</span>
<span class="gi">+    &quot;fs_is_case_sensitive&quot;,</span>
<span class="gi">+    &quot;fs_path_id&quot;,</span>
<span class="gi">+    &quot;fs_supports_symlink&quot;,</span>
<span class="gi">+)</span>
<span class="gh">diff --git a/src/virtualenv/report.py b/src/virtualenv/report.py</span>
<span class="gh">index 572a341..9ad52a1 100644</span>
<span class="gd">--- a/src/virtualenv/report.py</span>
<span class="gi">+++ b/src/virtualenv/report.py</span>
<span class="gu">@@ -1,8 +1,50 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import sys
<span class="gd">-LEVELS = {(0): logging.CRITICAL, (1): logging.ERROR, (2): logging.WARNING,</span>
<span class="gd">-    (3): logging.INFO, (4): logging.DEBUG, (5): logging.NOTSET}</span>
<span class="gi">+</span>
<span class="gi">+LEVELS = {</span>
<span class="gi">+    0: logging.CRITICAL,</span>
<span class="gi">+    1: logging.ERROR,</span>
<span class="gi">+    2: logging.WARNING,</span>
<span class="gi">+    3: logging.INFO,</span>
<span class="gi">+    4: logging.DEBUG,</span>
<span class="gi">+    5: logging.NOTSET,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="w"> </span>MAX_LEVEL = max(LEVELS.keys())
<span class="w"> </span>LOGGER = logging.getLogger()
<span class="gd">-__all__ = [&#39;LEVELS&#39;, &#39;MAX_LEVEL&#39;, &#39;setup_report&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup_report(verbosity, show_pid=False):  # noqa: FBT002</span>
<span class="gi">+    _clean_handlers(LOGGER)</span>
<span class="gi">+    verbosity = min(verbosity, MAX_LEVEL)  # pragma: no cover</span>
<span class="gi">+    level = LEVELS[verbosity]</span>
<span class="gi">+    msg_format = &quot;%(message)s&quot;</span>
<span class="gi">+    if level &lt;= logging.DEBUG:</span>
<span class="gi">+        locate = &quot;module&quot;</span>
<span class="gi">+        msg_format = f&quot;%(relativeCreated)d {msg_format} [%(levelname)s %({locate})s:%(lineno)d]&quot;</span>
<span class="gi">+    if show_pid:</span>
<span class="gi">+        msg_format = f&quot;[%(process)d] {msg_format}&quot;</span>
<span class="gi">+    formatter = logging.Formatter(msg_format)</span>
<span class="gi">+    stream_handler = logging.StreamHandler(stream=sys.stdout)</span>
<span class="gi">+    stream_handler.setLevel(level)</span>
<span class="gi">+    LOGGER.setLevel(logging.NOTSET)</span>
<span class="gi">+    stream_handler.setFormatter(formatter)</span>
<span class="gi">+    LOGGER.addHandler(stream_handler)</span>
<span class="gi">+    level_name = logging.getLevelName(level)</span>
<span class="gi">+    logging.debug(&quot;setup logging to %s&quot;, level_name)</span>
<span class="gi">+    logging.getLogger(&quot;distlib&quot;).setLevel(logging.ERROR)</span>
<span class="gi">+    return verbosity</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _clean_handlers(log):</span>
<span class="gi">+    for log_handler in list(log.handlers):  # remove handlers of libraries</span>
<span class="gi">+        log.removeHandler(log_handler)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;LEVELS&quot;,</span>
<span class="gi">+    &quot;MAX_LEVEL&quot;,</span>
<span class="gi">+    &quot;setup_report&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/run/plugin/activators.py b/src/virtualenv/run/plugin/activators.py</span>
<span class="gh">index 3a63907..a0e8669 100644</span>
<span class="gd">--- a/src/virtualenv/run/plugin/activators.py</span>
<span class="gi">+++ b/src/virtualenv/run/plugin/activators.py</span>
<span class="gu">@@ -1,18 +1,62 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from argparse import ArgumentTypeError
<span class="w"> </span>from collections import OrderedDict
<span class="gi">+</span>
<span class="w"> </span>from .base import ComponentBuilder


<span class="w"> </span>class ActivationSelector(ComponentBuilder):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, interpreter, parser) -&gt;None:</span>
<span class="gi">+    def __init__(self, interpreter, parser) -&gt; None:</span>
<span class="w"> </span>        self.default = None
<span class="gd">-        possible = OrderedDict((k, v) for k, v in self.options(</span>
<span class="gd">-            &#39;virtualenv.activate&#39;).items() if v.supports(interpreter))</span>
<span class="gd">-        super().__init__(interpreter, parser, &#39;activators&#39;, possible)</span>
<span class="gd">-        self.parser.description = &#39;options for activation scripts&#39;</span>
<span class="gi">+        possible = OrderedDict(</span>
<span class="gi">+            (k, v) for k, v in self.options(&quot;virtualenv.activate&quot;).items() if v.supports(interpreter)</span>
<span class="gi">+        )</span>
<span class="gi">+        super().__init__(interpreter, parser, &quot;activators&quot;, possible)</span>
<span class="gi">+        self.parser.description = &quot;options for activation scripts&quot;</span>
<span class="w"> </span>        self.active = None

<span class="gi">+    def add_selector_arg_parse(self, name, choices):</span>
<span class="gi">+        self.default = &quot;,&quot;.join(choices)</span>
<span class="gi">+        self.parser.add_argument(</span>
<span class="gi">+            f&quot;--{name}&quot;,</span>
<span class="gi">+            default=self.default,</span>
<span class="gi">+            metavar=&quot;comma_sep_list&quot;,</span>
<span class="gi">+            required=False,</span>
<span class="gi">+            help=&quot;activators to generate - default is all supported&quot;,</span>
<span class="gi">+            type=self._extract_activators,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _extract_activators(self, entered_str):</span>
<span class="gi">+        elements = [e.strip() for e in entered_str.split(&quot;,&quot;) if e.strip()]</span>
<span class="gi">+        missing = [e for e in elements if e not in self.possible]</span>
<span class="gi">+        if missing:</span>
<span class="gi">+            msg = f&quot;the following activators are not available {&#39;,&#39;.join(missing)}&quot;</span>
<span class="gi">+            raise ArgumentTypeError(msg)</span>
<span class="gi">+        return elements</span>
<span class="gi">+</span>
<span class="gi">+    def handle_selected_arg_parse(self, options):</span>
<span class="gi">+        selected_activators = (</span>
<span class="gi">+            self._extract_activators(self.default) if options.activators is self.default else options.activators</span>
<span class="gi">+        )</span>
<span class="gi">+        self.active = {k: v for k, v in self.possible.items() if k in selected_activators}</span>
<span class="gi">+        self.parser.add_argument(</span>
<span class="gi">+            &quot;--prompt&quot;,</span>
<span class="gi">+            dest=&quot;prompt&quot;,</span>
<span class="gi">+            metavar=&quot;prompt&quot;,</span>
<span class="gi">+            help=(</span>
<span class="gi">+                &quot;provides an alternative prompt prefix for this environment &quot;</span>
<span class="gi">+                &quot;(value of . means name of the current working directory)&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+            default=None,</span>
<span class="gi">+        )</span>
<span class="gi">+        for activator in self.active.values():</span>
<span class="gi">+            activator.add_parser_arguments(self.parser, self.interpreter)</span>
<span class="gi">+</span>
<span class="gi">+    def create(self, options):</span>
<span class="gi">+        return [activator_class(options) for activator_class in self.active.values()]</span>
<span class="gi">+</span>

<span class="gd">-__all__ = [&#39;ActivationSelector&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;ActivationSelector&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/run/plugin/base.py b/src/virtualenv/run/plugin/base.py</span>
<span class="gh">index c9eda3d..f0682dd 100644</span>
<span class="gd">--- a/src/virtualenv/run/plugin/base.py</span>
<span class="gi">+++ b/src/virtualenv/run/plugin/base.py</span>
<span class="gu">@@ -1,23 +1,37 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>from collections import OrderedDict
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 8):
<span class="w"> </span>    from importlib.metadata import entry_points
<span class="gi">+</span>
<span class="w"> </span>    importlib_metadata_version = ()
<span class="w"> </span>else:
<span class="w"> </span>    from importlib_metadata import entry_points, version
<span class="gd">-    importlib_metadata_version = tuple(int(i) for i in version(</span>
<span class="gd">-        &#39;importlib_metadata&#39;).split(&#39;.&#39;)[:2])</span>
<span class="gi">+</span>
<span class="gi">+    importlib_metadata_version = tuple(int(i) for i in version(&quot;importlib_metadata&quot;).split(&quot;.&quot;)[:2])</span>


<span class="w"> </span>class PluginLoader:
<span class="w"> </span>    _OPTIONS = None
<span class="w"> </span>    _ENTRY_POINTS = None

<span class="gi">+    @classmethod</span>
<span class="gi">+    def entry_points_for(cls, key):</span>
<span class="gi">+        if sys.version_info &gt;= (3, 10) or importlib_metadata_version &gt;= (3, 6):</span>
<span class="gi">+            return OrderedDict((e.name, e.load()) for e in cls.entry_points().select(group=key))</span>
<span class="gi">+        return OrderedDict((e.name, e.load()) for e in cls.entry_points().get(key, {}))</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def entry_points():</span>
<span class="gi">+        if PluginLoader._ENTRY_POINTS is None:</span>
<span class="gi">+            PluginLoader._ENTRY_POINTS = entry_points()</span>
<span class="gi">+        return PluginLoader._ENTRY_POINTS</span>

<span class="gd">-class ComponentBuilder(PluginLoader):</span>

<span class="gd">-    def __init__(self, interpreter, parser, name, possible) -&gt;None:</span>
<span class="gi">+class ComponentBuilder(PluginLoader):</span>
<span class="gi">+    def __init__(self, interpreter, parser, name, possible) -&gt; None:</span>
<span class="w"> </span>        self.interpreter = interpreter
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self._impl_class = None
<span class="gu">@@ -25,5 +39,33 @@ class ComponentBuilder(PluginLoader):</span>
<span class="w"> </span>        self.parser = parser.add_argument_group(title=name)
<span class="w"> </span>        self.add_selector_arg_parse(name, list(self.possible))

<span class="gi">+    @classmethod</span>
<span class="gi">+    def options(cls, key):</span>
<span class="gi">+        if cls._OPTIONS is None:</span>
<span class="gi">+            cls._OPTIONS = cls.entry_points_for(key)</span>
<span class="gi">+        return cls._OPTIONS</span>
<span class="gi">+</span>
<span class="gi">+    def add_selector_arg_parse(self, name, choices):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def handle_selected_arg_parse(self, options):</span>
<span class="gi">+        selected = getattr(options, self.name)</span>
<span class="gi">+        if selected not in self.possible:</span>
<span class="gi">+            msg = f&quot;No implementation for {self.interpreter}&quot;</span>
<span class="gi">+            raise RuntimeError(msg)</span>
<span class="gi">+        self._impl_class = self.possible[selected]</span>
<span class="gi">+        self.populate_selected_argparse(selected, options.app_data)</span>
<span class="gi">+        return selected</span>
<span class="gi">+</span>
<span class="gi">+    def populate_selected_argparse(self, selected, app_data):</span>
<span class="gi">+        self.parser.description = f&quot;options for {self.name} {selected}&quot;</span>
<span class="gi">+        self._impl_class.add_parser_arguments(self.parser, self.interpreter, app_data)</span>
<span class="gi">+</span>
<span class="gi">+    def create(self, options):</span>
<span class="gi">+        return self._impl_class(options, self.interpreter)</span>
<span class="gi">+</span>

<span class="gd">-__all__ = [&#39;ComponentBuilder&#39;, &#39;PluginLoader&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;ComponentBuilder&quot;,</span>
<span class="gi">+    &quot;PluginLoader&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/run/plugin/creators.py b/src/virtualenv/run/plugin/creators.py</span>
<span class="gh">index 662d6db..6bb1184 100644</span>
<span class="gd">--- a/src/virtualenv/run/plugin/creators.py</span>
<span class="gi">+++ b/src/virtualenv/run/plugin/creators.py</span>
<span class="gu">@@ -1,9 +1,13 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections import OrderedDict, defaultdict
<span class="w"> </span>from typing import TYPE_CHECKING, NamedTuple
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.create.describe import Describe
<span class="w"> </span>from virtualenv.create.via_global_ref.builtin.builtin_way import VirtualenvBuiltin
<span class="gi">+</span>
<span class="w"> </span>from .base import ComponentBuilder
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from virtualenv.create.creator import Creator, CreatorMeta

<span class="gu">@@ -16,11 +20,72 @@ class CreatorInfo(NamedTuple):</span>


<span class="w"> </span>class CreatorSelector(ComponentBuilder):
<span class="gi">+    def __init__(self, interpreter, parser) -&gt; None:</span>
<span class="gi">+        creators, self.key_to_meta, self.describe, self.builtin_key = self.for_interpreter(interpreter)</span>
<span class="gi">+        super().__init__(interpreter, parser, &quot;creator&quot;, creators)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def for_interpreter(cls, interpreter):</span>
<span class="gi">+        key_to_class, key_to_meta, builtin_key, describe = OrderedDict(), {}, None, None</span>
<span class="gi">+        errors = defaultdict(list)</span>
<span class="gi">+        for key, creator_class in cls.options(&quot;virtualenv.create&quot;).items():</span>
<span class="gi">+            if key == &quot;builtin&quot;:</span>
<span class="gi">+                msg = &quot;builtin creator is a reserved name&quot;</span>
<span class="gi">+                raise RuntimeError(msg)</span>
<span class="gi">+            meta = creator_class.can_create(interpreter)</span>
<span class="gi">+            if meta:</span>
<span class="gi">+                if meta.error:</span>
<span class="gi">+                    errors[meta.error].append(creator_class)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if &quot;builtin&quot; not in key_to_class and issubclass(creator_class, VirtualenvBuiltin):</span>
<span class="gi">+                        builtin_key = key</span>
<span class="gi">+                        key_to_class[&quot;builtin&quot;] = creator_class</span>
<span class="gi">+                        key_to_meta[&quot;builtin&quot;] = meta</span>
<span class="gi">+                    key_to_class[key] = creator_class</span>
<span class="gi">+                    key_to_meta[key] = meta</span>
<span class="gi">+            if describe is None and issubclass(creator_class, Describe) and creator_class.can_describe(interpreter):</span>
<span class="gi">+                describe = creator_class</span>
<span class="gi">+        if not key_to_meta:</span>
<span class="gi">+            if errors:</span>
<span class="gi">+                rows = [f&quot;{k} for creators {&#39;, &#39;.join(i.__name__ for i in v)}&quot; for k, v in errors.items()]</span>
<span class="gi">+                raise RuntimeError(&quot;\n&quot;.join(rows))</span>
<span class="gi">+            msg = f&quot;No virtualenv implementation for {interpreter}&quot;</span>
<span class="gi">+            raise RuntimeError(msg)</span>
<span class="gi">+        return CreatorInfo(</span>
<span class="gi">+            key_to_class=key_to_class,</span>
<span class="gi">+            key_to_meta=key_to_meta,</span>
<span class="gi">+            describe=describe,</span>
<span class="gi">+            builtin_key=builtin_key,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def add_selector_arg_parse(self, name, choices):</span>
<span class="gi">+        # prefer the built-in venv if present, otherwise fallback to first defined type</span>
<span class="gi">+        choices = sorted(choices, key=lambda a: 0 if a == &quot;builtin&quot; else 1)</span>
<span class="gi">+        default_value = self._get_default(choices)</span>
<span class="gi">+        self.parser.add_argument(</span>
<span class="gi">+            f&quot;--{name}&quot;,</span>
<span class="gi">+            choices=choices,</span>
<span class="gi">+            default=default_value,</span>
<span class="gi">+            required=False,</span>
<span class="gi">+            help=f&quot;create environment via{&#39;&#39; if self.builtin_key is None else f&#39; (builtin = {self.builtin_key})&#39;}&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _get_default(choices):</span>
<span class="gi">+        return next(iter(choices))</span>
<span class="gi">+</span>
<span class="gi">+    def populate_selected_argparse(self, selected, app_data):</span>
<span class="gi">+        self.parser.description = f&quot;options for {self.name} {selected}&quot;</span>
<span class="gi">+        self._impl_class.add_parser_arguments(self.parser, self.interpreter, self.key_to_meta[selected], app_data)</span>

<span class="gd">-    def __init__(self, interpreter, parser) -&gt;None:</span>
<span class="gd">-        creators, self.key_to_meta, self.describe, self.builtin_key = (self</span>
<span class="gd">-            .for_interpreter(interpreter))</span>
<span class="gd">-        super().__init__(interpreter, parser, &#39;creator&#39;, creators)</span>
<span class="gi">+    def create(self, options):</span>
<span class="gi">+        options.meta = self.key_to_meta[getattr(options, self.name)]</span>
<span class="gi">+        if not issubclass(self._impl_class, Describe):</span>
<span class="gi">+            options.describe = self.describe(options, self.interpreter)</span>
<span class="gi">+        return super().create(options)</span>


<span class="gd">-__all__ = [&#39;CreatorInfo&#39;, &#39;CreatorSelector&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;CreatorInfo&quot;,</span>
<span class="gi">+    &quot;CreatorSelector&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/run/plugin/discovery.py b/src/virtualenv/run/plugin/discovery.py</span>
<span class="gh">index dbdba67..a963042 100644</span>
<span class="gd">--- a/src/virtualenv/run/plugin/discovery.py</span>
<span class="gi">+++ b/src/virtualenv/run/plugin/discovery.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from .base import PluginLoader


<span class="gu">@@ -6,4 +7,34 @@ class Discovery(PluginLoader):</span>
<span class="w"> </span>    &quot;&quot;&quot;Discovery plugins.&quot;&quot;&quot;


<span class="gd">-__all__ = [&#39;Discovery&#39;, &#39;get_discover&#39;]</span>
<span class="gi">+def get_discover(parser, args):</span>
<span class="gi">+    discover_types = Discovery.entry_points_for(&quot;virtualenv.discovery&quot;)</span>
<span class="gi">+    discovery_parser = parser.add_argument_group(</span>
<span class="gi">+        title=&quot;discovery&quot;,</span>
<span class="gi">+        description=&quot;discover and provide a target interpreter&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    choices = _get_default_discovery(discover_types)</span>
<span class="gi">+    # prefer the builtin if present, otherwise fallback to first defined type</span>
<span class="gi">+    choices = sorted(choices, key=lambda a: 0 if a == &quot;builtin&quot; else 1)</span>
<span class="gi">+    discovery_parser.add_argument(</span>
<span class="gi">+        &quot;--discovery&quot;,</span>
<span class="gi">+        choices=choices,</span>
<span class="gi">+        default=next(iter(choices)),</span>
<span class="gi">+        required=False,</span>
<span class="gi">+        help=&quot;interpreter discovery method&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    options, _ = parser.parse_known_args(args)</span>
<span class="gi">+    discover_class = discover_types[options.discovery]</span>
<span class="gi">+    discover_class.add_parser_arguments(discovery_parser)</span>
<span class="gi">+    options, _ = parser.parse_known_args(args, namespace=options)</span>
<span class="gi">+    return discover_class(options)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_default_discovery(discover_types):</span>
<span class="gi">+    return list(discover_types.keys())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Discovery&quot;,</span>
<span class="gi">+    &quot;get_discover&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/run/plugin/seeders.py b/src/virtualenv/run/plugin/seeders.py</span>
<span class="gh">index 6ef8879..b1da34c 100644</span>
<span class="gd">--- a/src/virtualenv/run/plugin/seeders.py</span>
<span class="gi">+++ b/src/virtualenv/run/plugin/seeders.py</span>
<span class="gu">@@ -1,12 +1,40 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from .base import ComponentBuilder


<span class="w"> </span>class SeederSelector(ComponentBuilder):
<span class="gi">+    def __init__(self, interpreter, parser) -&gt; None:</span>
<span class="gi">+        possible = self.options(&quot;virtualenv.seed&quot;)</span>
<span class="gi">+        super().__init__(interpreter, parser, &quot;seeder&quot;, possible)</span>
<span class="gi">+</span>
<span class="gi">+    def add_selector_arg_parse(self, name, choices):</span>
<span class="gi">+        self.parser.add_argument(</span>
<span class="gi">+            f&quot;--{name}&quot;,</span>
<span class="gi">+            choices=choices,</span>
<span class="gi">+            default=self._get_default(),</span>
<span class="gi">+            required=False,</span>
<span class="gi">+            help=&quot;seed packages install method&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        self.parser.add_argument(</span>
<span class="gi">+            &quot;--no-seed&quot;,</span>
<span class="gi">+            &quot;--without-pip&quot;,</span>
<span class="gi">+            help=&quot;do not install seed packages&quot;,</span>
<span class="gi">+            action=&quot;store_true&quot;,</span>
<span class="gi">+            dest=&quot;no_seed&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _get_default():</span>
<span class="gi">+        return &quot;app-data&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def handle_selected_arg_parse(self, options):</span>
<span class="gi">+        return super().handle_selected_arg_parse(options)</span>

<span class="gd">-    def __init__(self, interpreter, parser) -&gt;None:</span>
<span class="gd">-        possible = self.options(&#39;virtualenv.seed&#39;)</span>
<span class="gd">-        super().__init__(interpreter, parser, &#39;seeder&#39;, possible)</span>
<span class="gi">+    def create(self, options):</span>
<span class="gi">+        return self._impl_class(options)</span>


<span class="gd">-__all__ = [&#39;SeederSelector&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;SeederSelector&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/run/session.py b/src/virtualenv/run/session.py</span>
<span class="gh">index 33a12c6..9ffd890 100644</span>
<span class="gd">--- a/src/virtualenv/run/session.py</span>
<span class="gi">+++ b/src/virtualenv/run/session.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import json
<span class="w"> </span>import logging

<span class="gu">@@ -6,8 +7,7 @@ import logging</span>
<span class="w"> </span>class Session:
<span class="w"> </span>    &quot;&quot;&quot;Represents a virtual environment creation session.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, verbosity, app_data, interpreter, creator, seeder,</span>
<span class="gd">-        activators) -&gt;None:</span>
<span class="gi">+    def __init__(self, verbosity, app_data, interpreter, creator, seeder, activators) -&gt; None:  # noqa: PLR0913</span>
<span class="w"> </span>        self._verbosity = verbosity
<span class="w"> </span>        self._app_data = app_data
<span class="w"> </span>        self._interpreter = interpreter
<span class="gu">@@ -18,27 +18,51 @@ class Session:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def verbosity(self):
<span class="w"> </span>        &quot;&quot;&quot;The verbosity of the run.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._verbosity</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def interpreter(self):
<span class="w"> </span>        &quot;&quot;&quot;Create a virtual environment based on this reference interpreter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._interpreter</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def creator(self):
<span class="w"> </span>        &quot;&quot;&quot;The creator used to build the virtual environment (must be compatible with the interpreter).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._creator</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def seeder(self):
<span class="w"> </span>        &quot;&quot;&quot;The mechanism used to provide the seed packages (pip, setuptools, wheel).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._seeder</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def activators(self):
<span class="w"> </span>        &quot;&quot;&quot;Activators used to generate activations scripts.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._activators</span>
<span class="gi">+</span>
<span class="gi">+    def run(self):</span>
<span class="gi">+        self._create()</span>
<span class="gi">+        self._seed()</span>
<span class="gi">+        self._activate()</span>
<span class="gi">+        self.creator.pyenv_cfg.write()</span>
<span class="gi">+</span>
<span class="gi">+    def _create(self):</span>
<span class="gi">+        logging.info(&quot;create virtual environment via %s&quot;, self.creator)</span>
<span class="gi">+        self.creator.run()</span>
<span class="gi">+        logging.debug(_DEBUG_MARKER)</span>
<span class="gi">+        logging.debug(&quot;%s&quot;, _Debug(self.creator))</span>
<span class="gi">+</span>
<span class="gi">+    def _seed(self):</span>
<span class="gi">+        if self.seeder is not None and self.seeder.enabled:</span>
<span class="gi">+            logging.info(&quot;add seed packages via %s&quot;, self.seeder)</span>
<span class="gi">+            self.seeder.run(self.creator)</span>
<span class="gi">+</span>
<span class="gi">+    def _activate(self):</span>
<span class="gi">+        if self.activators:</span>
<span class="gi">+            active = &quot;, &quot;.join(type(i).__name__.replace(&quot;Activator&quot;, &quot;&quot;) for i in self.activators)</span>
<span class="gi">+            logging.info(&quot;add activators for %s&quot;, active)</span>
<span class="gi">+            for activator in self.activators:</span>
<span class="gi">+                activator.generate(self.creator)</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self
<span class="gu">@@ -47,17 +71,19 @@ class Session:</span>
<span class="w"> </span>        self._app_data.close()


<span class="gd">-_DEBUG_MARKER = &#39;=&#39; * 30 + &#39; target debug &#39; + &#39;=&#39; * 30</span>
<span class="gi">+_DEBUG_MARKER = &quot;=&quot; * 30 + &quot; target debug &quot; + &quot;=&quot; * 30</span>


<span class="w"> </span>class _Debug:
<span class="w"> </span>    &quot;&quot;&quot;lazily populate debug.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, creator) -&gt;None:</span>
<span class="gi">+    def __init__(self, creator) -&gt; None:</span>
<span class="w"> </span>        self.creator = creator

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return json.dumps(self.creator.debug, indent=2)


<span class="gd">-__all__ = [&#39;Session&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Session&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/seed/embed/base_embed.py b/src/virtualenv/seed/embed/base_embed.py</span>
<span class="gh">index 4f02960..864cc49 100644</span>
<span class="gd">--- a/src/virtualenv/seed/embed/base_embed.py</span>
<span class="gi">+++ b/src/virtualenv/seed/embed/base_embed.py</span>
<span class="gu">@@ -1,46 +1,118 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABC
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.seed.seeder import Seeder
<span class="w"> </span>from virtualenv.seed.wheels import Version
<span class="gi">+</span>
<span class="w"> </span>PERIODIC_UPDATE_ON_BY_DEFAULT = True


<span class="w"> </span>class BaseEmbed(Seeder, ABC):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, options) -&gt;None:</span>
<span class="gi">+    def __init__(self, options) -&gt; None:</span>
<span class="w"> </span>        super().__init__(options, enabled=options.no_seed is False)
<span class="gi">+</span>
<span class="w"> </span>        self.download = options.download
<span class="gd">-        self.extra_search_dir = [i.resolve() for i in options.</span>
<span class="gd">-            extra_search_dir if i.exists()]</span>
<span class="gi">+        self.extra_search_dir = [i.resolve() for i in options.extra_search_dir if i.exists()]</span>
<span class="gi">+</span>
<span class="w"> </span>        self.pip_version = options.pip
<span class="w"> </span>        self.setuptools_version = options.setuptools
<span class="w"> </span>        self.wheel_version = options.wheel
<span class="gi">+</span>
<span class="w"> </span>        self.no_pip = options.no_pip
<span class="w"> </span>        self.no_setuptools = options.no_setuptools
<span class="w"> </span>        self.no_wheel = options.no_wheel
<span class="w"> </span>        self.app_data = options.app_data
<span class="w"> </span>        self.periodic_update = not options.no_periodic_update
<span class="gi">+</span>
<span class="w"> </span>        if not self.distribution_to_versions():
<span class="w"> </span>            self.enabled = False

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def distributions(cls) -&gt; dict[str, Version]:</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;pip&quot;: Version.bundle,</span>
<span class="gi">+            &quot;setuptools&quot;: Version.bundle,</span>
<span class="gi">+            &quot;wheel&quot;: Version.bundle,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def distribution_to_versions(self) -&gt; dict[str, str]:</span>
<span class="gi">+        return {</span>
<span class="gi">+            distribution: getattr(self, f&quot;{distribution}_version&quot;)</span>
<span class="gi">+            for distribution in self.distributions()</span>
<span class="gi">+            if getattr(self, f&quot;no_{distribution}&quot;) is False and getattr(self, f&quot;{distribution}_version&quot;) != &quot;none&quot;</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def add_parser_arguments(cls, parser, interpreter, app_data):  # noqa: ARG003</span>
<span class="gi">+        group = parser.add_mutually_exclusive_group()</span>
<span class="gi">+        group.add_argument(</span>
<span class="gi">+            &quot;--no-download&quot;,</span>
<span class="gi">+            &quot;--never-download&quot;,</span>
<span class="gi">+            dest=&quot;download&quot;,</span>
<span class="gi">+            action=&quot;store_false&quot;,</span>
<span class="gi">+            help=f&quot;pass to disable download of the latest {&#39;/&#39;.join(cls.distributions())} from PyPI&quot;,</span>
<span class="gi">+            default=True,</span>
<span class="gi">+        )</span>
<span class="gi">+        group.add_argument(</span>
<span class="gi">+            &quot;--download&quot;,</span>
<span class="gi">+            dest=&quot;download&quot;,</span>
<span class="gi">+            action=&quot;store_true&quot;,</span>
<span class="gi">+            help=f&quot;pass to enable download of the latest {&#39;/&#39;.join(cls.distributions())} from PyPI&quot;,</span>
<span class="gi">+            default=False,</span>
<span class="gi">+        )</span>
<span class="gi">+        parser.add_argument(</span>
<span class="gi">+            &quot;--extra-search-dir&quot;,</span>
<span class="gi">+            metavar=&quot;d&quot;,</span>
<span class="gi">+            type=Path,</span>
<span class="gi">+            nargs=&quot;+&quot;,</span>
<span class="gi">+            help=&quot;a path containing wheels to extend the internal wheel list (can be set 1+ times)&quot;,</span>
<span class="gi">+            default=[],</span>
<span class="gi">+        )</span>
<span class="gi">+        for distribution, default in cls.distributions().items():</span>
<span class="gi">+            if interpreter.version_info[:2] &gt;= (3, 12) and distribution in {&quot;wheel&quot;, &quot;setuptools&quot;}:</span>
<span class="gi">+                default = &quot;none&quot;  # noqa: PLW2901</span>
<span class="gi">+            parser.add_argument(</span>
<span class="gi">+                f&quot;--{distribution}&quot;,</span>
<span class="gi">+                dest=distribution,</span>
<span class="gi">+                metavar=&quot;version&quot;,</span>
<span class="gi">+                help=f&quot;version of {distribution} to install as seed: embed, bundle, none or exact version&quot;,</span>
<span class="gi">+                default=default,</span>
<span class="gi">+            )</span>
<span class="gi">+        for distribution in cls.distributions():</span>
<span class="gi">+            parser.add_argument(</span>
<span class="gi">+                f&quot;--no-{distribution}&quot;,</span>
<span class="gi">+                dest=f&quot;no_{distribution}&quot;,</span>
<span class="gi">+                action=&quot;store_true&quot;,</span>
<span class="gi">+                help=f&quot;do not install {distribution}&quot;,</span>
<span class="gi">+                default=False,</span>
<span class="gi">+            )</span>
<span class="gi">+        parser.add_argument(</span>
<span class="gi">+            &quot;--no-periodic-update&quot;,</span>
<span class="gi">+            dest=&quot;no_periodic_update&quot;,</span>
<span class="gi">+            action=&quot;store_true&quot;,</span>
<span class="gi">+            help=&quot;disable the periodic (once every 14 days) update of the embedded wheels&quot;,</span>
<span class="gi">+            default=not PERIODIC_UPDATE_ON_BY_DEFAULT,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        result = self.__class__.__name__
<span class="gd">-        result += &#39;(&#39;</span>
<span class="gi">+        result += &quot;(&quot;</span>
<span class="w"> </span>        if self.extra_search_dir:
<span class="gd">-            result += (</span>
<span class="gd">-                f&quot;extra_search_dir={&#39;, &#39;.join(str(i) for i in self.extra_search_dir)},&quot;</span>
<span class="gd">-                )</span>
<span class="gd">-        result += f&#39;download={self.download},&#39;</span>
<span class="gi">+            result += f&quot;extra_search_dir={&#39;, &#39;.join(str(i) for i in self.extra_search_dir)},&quot;</span>
<span class="gi">+        result += f&quot;download={self.download},&quot;</span>
<span class="w"> </span>        for distribution in self.distributions():
<span class="gd">-            if getattr(self, f&#39;no_{distribution}&#39;):</span>
<span class="gi">+            if getattr(self, f&quot;no_{distribution}&quot;):</span>
<span class="w"> </span>                continue
<span class="gd">-            version = getattr(self, f&#39;{distribution}_version&#39;, None)</span>
<span class="gd">-            if version == &#39;none&#39;:</span>
<span class="gi">+            version = getattr(self, f&quot;{distribution}_version&quot;, None)</span>
<span class="gi">+            if version == &quot;none&quot;:</span>
<span class="w"> </span>                continue
<span class="w"> </span>            ver = f&quot;={version or &#39;latest&#39;}&quot;
<span class="gd">-            result += f&#39; {distribution}{ver},&#39;</span>
<span class="gd">-        return result[:-1] + &#39;)&#39;</span>
<span class="gi">+            result += f&quot; {distribution}{ver},&quot;</span>
<span class="gi">+        return result[:-1] + &quot;)&quot;</span>


<span class="gd">-__all__ = [&#39;BaseEmbed&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;BaseEmbed&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/seed/embed/pip_invoke.py b/src/virtualenv/seed/embed/pip_invoke.py</span>
<span class="gh">index 33b0e2a..2625a01 100644</span>
<span class="gd">--- a/src/virtualenv/seed/embed/pip_invoke.py</span>
<span class="gi">+++ b/src/virtualenv/seed/embed/pip_invoke.py</span>
<span class="gu">@@ -1,16 +1,63 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from subprocess import Popen
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.discovery.cached_py_info import LogCmd
<span class="w"> </span>from virtualenv.seed.embed.base_embed import BaseEmbed
<span class="w"> </span>from virtualenv.seed.wheels import Version, get_wheel, pip_wheel_env_run


<span class="w"> </span>class PipInvoke(BaseEmbed):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, options) -&gt;None:</span>
<span class="gi">+    def __init__(self, options) -&gt; None:</span>
<span class="w"> </span>        super().__init__(options)

<span class="gi">+    def run(self, creator):</span>
<span class="gi">+        if not self.enabled:</span>
<span class="gi">+            return</span>
<span class="gi">+        for_py_version = creator.interpreter.version_release_str</span>
<span class="gi">+        with self.get_pip_install_cmd(creator.exe, for_py_version) as cmd:</span>
<span class="gi">+            env = pip_wheel_env_run(self.extra_search_dir, self.app_data, self.env)</span>
<span class="gi">+            self._execute(cmd, env)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _execute(cmd, env):</span>
<span class="gi">+        logging.debug(&quot;pip seed by running: %s&quot;, LogCmd(cmd, env))</span>
<span class="gi">+        process = Popen(cmd, env=env)  # noqa: S603</span>
<span class="gi">+        process.communicate()</span>
<span class="gi">+        if process.returncode != 0:</span>
<span class="gi">+            msg = f&quot;failed seed with code {process.returncode}&quot;</span>
<span class="gi">+            raise RuntimeError(msg)</span>
<span class="gi">+        return process</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def get_pip_install_cmd(self, exe, for_py_version):</span>
<span class="gi">+        cmd = [str(exe), &quot;-m&quot;, &quot;pip&quot;, &quot;-q&quot;, &quot;install&quot;, &quot;--only-binary&quot;, &quot;:all:&quot;, &quot;--disable-pip-version-check&quot;]</span>
<span class="gi">+        if not self.download:</span>
<span class="gi">+            cmd.append(&quot;--no-index&quot;)</span>
<span class="gi">+        folders = set()</span>
<span class="gi">+        for dist, version in self.distribution_to_versions().items():</span>
<span class="gi">+            wheel = get_wheel(</span>
<span class="gi">+                distribution=dist,</span>
<span class="gi">+                version=version,</span>
<span class="gi">+                for_py_version=for_py_version,</span>
<span class="gi">+                search_dirs=self.extra_search_dir,</span>
<span class="gi">+                download=False,</span>
<span class="gi">+                app_data=self.app_data,</span>
<span class="gi">+                do_periodic_update=self.periodic_update,</span>
<span class="gi">+                env=self.env,</span>
<span class="gi">+            )</span>
<span class="gi">+            if wheel is None:</span>
<span class="gi">+                msg = f&quot;could not get wheel for distribution {dist}&quot;</span>
<span class="gi">+                raise RuntimeError(msg)</span>
<span class="gi">+            folders.add(str(wheel.path.parent))</span>
<span class="gi">+            cmd.append(Version.as_pip_req(dist, wheel.version))</span>
<span class="gi">+        for folder in sorted(folders):</span>
<span class="gi">+            cmd.extend([&quot;--find-links&quot;, str(folder)])</span>
<span class="gi">+        yield cmd</span>
<span class="gi">+</span>

<span class="gd">-__all__ = [&#39;PipInvoke&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;PipInvoke&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/seed/embed/via_app_data/pip_install/base.py b/src/virtualenv/seed/embed/via_app_data/pip_install/base.py</span>
<span class="gh">index 68cd39d..961cd42 100644</span>
<span class="gd">--- a/src/virtualenv/seed/embed/via_app_data/pip_install/base.py</span>
<span class="gi">+++ b/src/virtualenv/seed/embed/via_app_data/pip_install/base.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="gu">@@ -8,13 +9,14 @@ from configparser import ConfigParser</span>
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from tempfile import mkdtemp
<span class="gi">+</span>
<span class="w"> </span>from distlib.scripts import ScriptMaker, enquote_executable
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.util.path import safe_delete


<span class="w"> </span>class PipInstall(ABC):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, wheel, creator, image_folder) -&gt;None:</span>
<span class="gi">+    def __init__(self, wheel, creator, image_folder) -&gt; None:</span>
<span class="w"> </span>        self._wheel = wheel
<span class="w"> </span>        self._creator = creator
<span class="w"> </span>        self._image_dir = image_folder
<span class="gu">@@ -22,17 +24,181 @@ class PipInstall(ABC):</span>
<span class="w"> </span>        self.__dist_info = None
<span class="w"> </span>        self._console_entry_points = None

<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def _sync(self, src, dst):</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-class ScriptMakerCustom(ScriptMaker):</span>
<span class="gi">+    def install(self, version_info):</span>
<span class="gi">+        self._extracted = True</span>
<span class="gi">+        self._uninstall_previous_version()</span>
<span class="gi">+        # sync image</span>
<span class="gi">+        for filename in self._image_dir.iterdir():</span>
<span class="gi">+            into = self._creator.purelib / filename.name</span>
<span class="gi">+            self._sync(filename, into)</span>
<span class="gi">+        # generate console executables</span>
<span class="gi">+        consoles = set()</span>
<span class="gi">+        script_dir = self._creator.script_dir</span>
<span class="gi">+        for name, module in self._console_scripts.items():</span>
<span class="gi">+            consoles.update(self._create_console_entry_point(name, module, script_dir, version_info))</span>
<span class="gi">+        logging.debug(&quot;generated console scripts %s&quot;, &quot; &quot;.join(i.name for i in consoles))</span>
<span class="gi">+</span>
<span class="gi">+    def build_image(self):</span>
<span class="gi">+        # 1. first extract the wheel</span>
<span class="gi">+        logging.debug(&quot;build install image for %s to %s&quot;, self._wheel.name, self._image_dir)</span>
<span class="gi">+        with zipfile.ZipFile(str(self._wheel)) as zip_ref:</span>
<span class="gi">+            self._shorten_path_if_needed(zip_ref)</span>
<span class="gi">+            zip_ref.extractall(str(self._image_dir))</span>
<span class="gi">+            self._extracted = True</span>
<span class="gi">+        # 2. now add additional files not present in the distribution</span>
<span class="gi">+        new_files = self._generate_new_files()</span>
<span class="gi">+        # 3. finally fix the records file</span>
<span class="gi">+        self._fix_records(new_files)</span>
<span class="gi">+</span>
<span class="gi">+    def _shorten_path_if_needed(self, zip_ref):</span>
<span class="gi">+        if os.name == &quot;nt&quot;:</span>
<span class="gi">+            to_folder = str(self._image_dir)</span>
<span class="gi">+            # https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation</span>
<span class="gi">+            zip_max_len = max(len(i) for i in zip_ref.namelist())</span>
<span class="gi">+            path_len = zip_max_len + len(to_folder)</span>
<span class="gi">+            if path_len &gt; 260:  # noqa: PLR2004</span>
<span class="gi">+                self._image_dir.mkdir(exist_ok=True)  # to get a short path must exist</span>
<span class="gi">+</span>
<span class="gi">+                from virtualenv.util.path import get_short_path_name  # noqa: PLC0415</span>
<span class="gi">+</span>
<span class="gi">+                to_folder = get_short_path_name(to_folder)</span>
<span class="gi">+                self._image_dir = Path(to_folder)</span>
<span class="gi">+</span>
<span class="gi">+    def _records_text(self, files):</span>
<span class="gi">+        return &quot;\n&quot;.join(f&quot;{os.path.relpath(str(rec), str(self._image_dir))},,&quot; for rec in files)</span>
<span class="gi">+</span>
<span class="gi">+    def _generate_new_files(self):</span>
<span class="gi">+        new_files = set()</span>
<span class="gi">+        installer = self._dist_info / &quot;INSTALLER&quot;</span>
<span class="gi">+        installer.write_text(&quot;pip\n&quot;, encoding=&quot;utf-8&quot;)</span>
<span class="gi">+        new_files.add(installer)</span>
<span class="gi">+        # inject a no-op root element, as workaround for bug in https://github.com/pypa/pip/issues/7226</span>
<span class="gi">+        marker = self._image_dir / f&quot;{self._dist_info.stem}.virtualenv&quot;</span>
<span class="gi">+        marker.write_text(&quot;&quot;, encoding=&quot;utf-8&quot;)</span>
<span class="gi">+        new_files.add(marker)</span>
<span class="gi">+        folder = mkdtemp()</span>
<span class="gi">+        try:</span>
<span class="gi">+            to_folder = Path(folder)</span>
<span class="gi">+            rel = os.path.relpath(str(self._creator.script_dir), str(self._creator.purelib))</span>
<span class="gi">+            version_info = self._creator.interpreter.version_info</span>
<span class="gi">+            for name, module in self._console_scripts.items():</span>
<span class="gi">+                new_files.update(</span>
<span class="gi">+                    Path(os.path.normpath(str(self._image_dir / rel / i.name)))</span>
<span class="gi">+                    for i in self._create_console_entry_point(name, module, to_folder, version_info)</span>
<span class="gi">+                )</span>
<span class="gi">+        finally:</span>
<span class="gi">+            safe_delete(folder)</span>
<span class="gi">+        return new_files</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _dist_info(self):</span>
<span class="gi">+        if self._extracted is False:</span>
<span class="gi">+            return None  # pragma: no cover</span>
<span class="gi">+        if self.__dist_info is None:</span>
<span class="gi">+            files = []</span>
<span class="gi">+            for filename in self._image_dir.iterdir():</span>
<span class="gi">+                files.append(filename.name)</span>
<span class="gi">+                if filename.suffix == &quot;.dist-info&quot;:</span>
<span class="gi">+                    self.__dist_info = filename</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg = f&quot;no .dist-info at {self._image_dir}, has {&#39;, &#39;.join(files)}&quot;</span>
<span class="gi">+                raise RuntimeError(msg)  # pragma: no cover</span>
<span class="gi">+        return self.__dist_info</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def _fix_records(self, extra_record_data):</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def __init__(self, target_dir, version_info, executable, name) -&gt;None:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _console_scripts(self):</span>
<span class="gi">+        if self._extracted is False:</span>
<span class="gi">+            return None  # pragma: no cover</span>
<span class="gi">+        if self._console_entry_points is None:</span>
<span class="gi">+            self._console_entry_points = {}</span>
<span class="gi">+            entry_points = self._dist_info / &quot;entry_points.txt&quot;</span>
<span class="gi">+            if entry_points.exists():</span>
<span class="gi">+                parser = ConfigParser()</span>
<span class="gi">+                with entry_points.open(encoding=&quot;utf-8&quot;) as file_handler:</span>
<span class="gi">+                    parser.read_file(file_handler)</span>
<span class="gi">+                if &quot;console_scripts&quot; in parser.sections():</span>
<span class="gi">+                    for name, value in parser.items(&quot;console_scripts&quot;):</span>
<span class="gi">+                        match = re.match(r&quot;(.*?)-?\d\.?\d*&quot;, name)</span>
<span class="gi">+                        our_name = match.groups(1)[0] if match else name</span>
<span class="gi">+                        self._console_entry_points[our_name] = value</span>
<span class="gi">+        return self._console_entry_points</span>
<span class="gi">+</span>
<span class="gi">+    def _create_console_entry_point(self, name, value, to_folder, version_info):</span>
<span class="gi">+        result = []</span>
<span class="gi">+        maker = ScriptMakerCustom(to_folder, version_info, self._creator.exe, name)</span>
<span class="gi">+        specification = f&quot;{name} = {value}&quot;</span>
<span class="gi">+        new_files = maker.make(specification)</span>
<span class="gi">+        result.extend(Path(i) for i in new_files)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def _uninstall_previous_version(self):</span>
<span class="gi">+        dist_name = self._dist_info.stem.split(&quot;-&quot;)[0]</span>
<span class="gi">+        in_folders = chain.from_iterable([i.iterdir() for i in (self._creator.purelib, self._creator.platlib)])</span>
<span class="gi">+        paths = (p for p in in_folders if p.stem.split(&quot;-&quot;)[0] == dist_name and p.suffix == &quot;.dist-info&quot; and p.is_dir())</span>
<span class="gi">+        existing_dist = next(paths, None)</span>
<span class="gi">+        if existing_dist is not None:</span>
<span class="gi">+            self._uninstall_dist(existing_dist)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _uninstall_dist(dist):</span>
<span class="gi">+        dist_base = dist.parent</span>
<span class="gi">+        logging.debug(&quot;uninstall existing distribution %s from %s&quot;, dist.stem, dist_base)</span>
<span class="gi">+</span>
<span class="gi">+        top_txt = dist / &quot;top_level.txt&quot;  # add top level packages at folder level</span>
<span class="gi">+        paths = (</span>
<span class="gi">+            {dist.parent / i.strip() for i in top_txt.read_text(encoding=&quot;utf-8&quot;).splitlines()}</span>
<span class="gi">+            if top_txt.exists()</span>
<span class="gi">+            else set()</span>
<span class="gi">+        )</span>
<span class="gi">+        paths.add(dist)  # add the dist-info folder itself</span>
<span class="gi">+</span>
<span class="gi">+        base_dirs, record = paths.copy(), dist / &quot;RECORD&quot;  # collect entries in record that we did not register yet</span>
<span class="gi">+        for name in (</span>
<span class="gi">+            (i.split(&quot;,&quot;)[0] for i in record.read_text(encoding=&quot;utf-8&quot;).splitlines()) if record.exists() else ()</span>
<span class="gi">+        ):</span>
<span class="gi">+            path = dist_base / name</span>
<span class="gi">+            if not any(p in base_dirs for p in path.parents):  # only add if not already added as a base dir</span>
<span class="gi">+                paths.add(path)</span>
<span class="gi">+</span>
<span class="gi">+        for path in sorted(paths):  # actually remove stuff in a stable order</span>
<span class="gi">+            if path.exists():</span>
<span class="gi">+                if path.is_dir() and not path.is_symlink():</span>
<span class="gi">+                    safe_delete(path)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    path.unlink()</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self):</span>
<span class="gi">+        if self._image_dir.exists():</span>
<span class="gi">+            safe_delete(self._image_dir)</span>
<span class="gi">+</span>
<span class="gi">+    def has_image(self):</span>
<span class="gi">+        return self._image_dir.exists() and next(self._image_dir.iterdir()) is not None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ScriptMakerCustom(ScriptMaker):</span>
<span class="gi">+    def __init__(self, target_dir, version_info, executable, name) -&gt; None:</span>
<span class="w"> </span>        super().__init__(None, str(target_dir))
<span class="gd">-        self.clobber = True</span>
<span class="gd">-        self.set_mode = True</span>
<span class="gi">+        self.clobber = True  # overwrite</span>
<span class="gi">+        self.set_mode = True  # ensure they are executable</span>
<span class="w"> </span>        self.executable = enquote_executable(str(executable))
<span class="w"> </span>        self.version_info = version_info.major, version_info.minor
<span class="gd">-        self.variants = {&#39;&#39;, &#39;X&#39;, &#39;X.Y&#39;}</span>
<span class="gi">+        self.variants = {&quot;&quot;, &quot;X&quot;, &quot;X.Y&quot;}</span>
<span class="w"> </span>        self._name = name

<span class="gi">+    def _write_script(self, names, shebang, script_bytes, filenames, ext):  # noqa: PLR0913</span>
<span class="gi">+        names.add(f&quot;{self._name}{self.version_info[0]}.{self.version_info[1]}&quot;)</span>
<span class="gi">+        super()._write_script(names, shebang, script_bytes, filenames, ext)</span>
<span class="gi">+</span>

<span class="gd">-__all__ = [&#39;PipInstall&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;PipInstall&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/seed/embed/via_app_data/pip_install/copy.py b/src/virtualenv/seed/embed/via_app_data/pip_install/copy.py</span>
<span class="gh">index c1e008c..b5f01aa 100644</span>
<span class="gd">--- a/src/virtualenv/seed/embed/via_app_data/pip_install/copy.py</span>
<span class="gi">+++ b/src/virtualenv/seed/embed/via_app_data/pip_install/copy.py</span>
<span class="gu">@@ -1,12 +1,40 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.util.path import copy
<span class="gi">+</span>
<span class="w"> </span>from .base import PipInstall


<span class="w"> </span>class CopyPipInstall(PipInstall):
<span class="gd">-    pass</span>
<span class="gi">+    def _sync(self, src, dst):</span>
<span class="gi">+        copy(src, dst)</span>
<span class="gi">+</span>
<span class="gi">+    def _generate_new_files(self):</span>
<span class="gi">+        # create the pyc files</span>
<span class="gi">+        new_files = super()._generate_new_files()</span>
<span class="gi">+        new_files.update(self._cache_files())</span>
<span class="gi">+        return new_files</span>
<span class="gi">+</span>
<span class="gi">+    def _cache_files(self):</span>
<span class="gi">+        version = self._creator.interpreter.version_info</span>
<span class="gi">+        py_c_ext = f&quot;.{self._creator.interpreter.implementation.lower()}-{version.major}{version.minor}.pyc&quot;</span>
<span class="gi">+        for root, dirs, files in os.walk(str(self._image_dir), topdown=True):</span>
<span class="gi">+            root_path = Path(root)</span>
<span class="gi">+            for name in files:</span>
<span class="gi">+                if name.endswith(&quot;.py&quot;):</span>
<span class="gi">+                    yield root_path / f&quot;{name[:-3]}{py_c_ext}&quot;</span>
<span class="gi">+            for name in dirs:</span>
<span class="gi">+                yield root_path / name / &quot;__pycache__&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _fix_records(self, new_files):</span>
<span class="gi">+        extra_record_data_str = self._records_text(new_files)</span>
<span class="gi">+        with (self._dist_info / &quot;RECORD&quot;).open(&quot;ab&quot;) as file_handler:</span>
<span class="gi">+            file_handler.write(extra_record_data_str.encode(&quot;utf-8&quot;))</span>


<span class="gd">-__all__ = [&#39;CopyPipInstall&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;CopyPipInstall&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/seed/embed/via_app_data/pip_install/symlink.py b/src/virtualenv/seed/embed/via_app_data/pip_install/symlink.py</span>
<span class="gh">index 4d91177..1ffefc6 100644</span>
<span class="gd">--- a/src/virtualenv/seed/embed/via_app_data/pip_install/symlink.py</span>
<span class="gi">+++ b/src/virtualenv/seed/embed/via_app_data/pip_install/symlink.py</span>
<span class="gu">@@ -1,13 +1,58 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from stat import S_IREAD, S_IRGRP, S_IROTH
<span class="w"> </span>from subprocess import PIPE, Popen
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.util.path import safe_delete, set_tree
<span class="gi">+</span>
<span class="w"> </span>from .base import PipInstall


<span class="w"> </span>class SymlinkPipInstall(PipInstall):
<span class="gd">-    pass</span>
<span class="gi">+    def _sync(self, src, dst):</span>
<span class="gi">+        os.symlink(str(src), str(dst))</span>
<span class="gi">+</span>
<span class="gi">+    def _generate_new_files(self):</span>
<span class="gi">+        # create the pyc files, as the build image will be R/O</span>
<span class="gi">+        cmd = [str(self._creator.exe), &quot;-m&quot;, &quot;compileall&quot;, str(self._image_dir)]</span>
<span class="gi">+        process = Popen(cmd, stdout=PIPE, stderr=PIPE)  # noqa: S603</span>
<span class="gi">+        process.communicate()</span>
<span class="gi">+        # the root pyc is shared, so we&#39;ll not symlink that - but still add the pyc files to the RECORD for close</span>
<span class="gi">+        root_py_cache = self._image_dir / &quot;__pycache__&quot;</span>
<span class="gi">+        new_files = set()</span>
<span class="gi">+        if root_py_cache.exists():</span>
<span class="gi">+            new_files.update(root_py_cache.iterdir())</span>
<span class="gi">+            new_files.add(root_py_cache)</span>
<span class="gi">+            safe_delete(root_py_cache)</span>
<span class="gi">+        core_new_files = super()._generate_new_files()</span>
<span class="gi">+        # remove files that are within the image folder deeper than one level (as these will be not linked directly)</span>
<span class="gi">+        for file in core_new_files:</span>
<span class="gi">+            try:</span>
<span class="gi">+                rel = file.relative_to(self._image_dir)</span>
<span class="gi">+                if len(rel.parts) &gt; 1:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            new_files.add(file)</span>
<span class="gi">+        return new_files</span>
<span class="gi">+</span>
<span class="gi">+    def _fix_records(self, new_files):</span>
<span class="gi">+        new_files.update(i for i in self._image_dir.iterdir())</span>
<span class="gi">+        extra_record_data_str = self._records_text(sorted(new_files, key=str))</span>
<span class="gi">+        (self._dist_info / &quot;RECORD&quot;).write_text(extra_record_data_str, encoding=&quot;utf-8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def build_image(self):</span>
<span class="gi">+        super().build_image()</span>
<span class="gi">+        # protect the image by making it read only</span>
<span class="gi">+        set_tree(self._image_dir, S_IREAD | S_IRGRP | S_IROTH)</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self):</span>
<span class="gi">+        if self._image_dir.exists():</span>
<span class="gi">+            safe_delete(self._image_dir)</span>
<span class="gi">+        super().clear()</span>


<span class="gd">-__all__ = [&#39;SymlinkPipInstall&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;SymlinkPipInstall&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/seed/embed/via_app_data/via_app_data.py b/src/virtualenv/seed/embed/via_app_data/via_app_data.py</span>
<span class="gh">index af51fec..7e58bfc 100644</span>
<span class="gd">--- a/src/virtualenv/seed/embed/via_app_data/via_app_data.py</span>
<span class="gi">+++ b/src/virtualenv/seed/embed/via_app_data/via_app_data.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Bootstrap.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import sys
<span class="w"> </span>import traceback
<span class="gu">@@ -7,25 +9,136 @@ from contextlib import contextmanager</span>
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from subprocess import CalledProcessError
<span class="w"> </span>from threading import Lock, Thread
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.info import fs_supports_symlink
<span class="w"> </span>from virtualenv.seed.embed.base_embed import BaseEmbed
<span class="w"> </span>from virtualenv.seed.wheels import get_wheel
<span class="gi">+</span>
<span class="w"> </span>from .pip_install.copy import CopyPipInstall
<span class="w"> </span>from .pip_install.symlink import SymlinkPipInstall


<span class="w"> </span>class FromAppData(BaseEmbed):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, options) -&gt;None:</span>
<span class="gi">+    def __init__(self, options) -&gt; None:</span>
<span class="w"> </span>        super().__init__(options)
<span class="w"> </span>        self.symlinks = options.symlink_app_data

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        msg = (</span>
<span class="gd">-            f&quot;, via={&#39;symlink&#39; if self.symlinks else &#39;copy&#39;}, app_data_dir={self.app_data}&quot;</span>
<span class="gd">-            )</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def add_parser_arguments(cls, parser, interpreter, app_data):</span>
<span class="gi">+        super().add_parser_arguments(parser, interpreter, app_data)</span>
<span class="gi">+        can_symlink = app_data.transient is False and fs_supports_symlink()</span>
<span class="gi">+        sym = &quot;&quot; if can_symlink else &quot;not supported - &quot;</span>
<span class="gi">+        parser.add_argument(</span>
<span class="gi">+            &quot;--symlink-app-data&quot;,</span>
<span class="gi">+            dest=&quot;symlink_app_data&quot;,</span>
<span class="gi">+            action=&quot;store_true&quot; if can_symlink else &quot;store_false&quot;,</span>
<span class="gi">+            help=f&quot;{sym} symlink the python packages from the app-data folder (requires seed pip&gt;=19.3)&quot;,</span>
<span class="gi">+            default=False,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def run(self, creator):</span>
<span class="gi">+        if not self.enabled:</span>
<span class="gi">+            return</span>
<span class="gi">+        with self._get_seed_wheels(creator) as name_to_whl:</span>
<span class="gi">+            pip_version = name_to_whl[&quot;pip&quot;].version_tuple if &quot;pip&quot; in name_to_whl else None</span>
<span class="gi">+            installer_class = self.installer_class(pip_version)</span>
<span class="gi">+            exceptions = {}</span>
<span class="gi">+</span>
<span class="gi">+            def _install(name, wheel):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    logging.debug(&quot;install %s from wheel %s via %s&quot;, name, wheel, installer_class.__name__)</span>
<span class="gi">+                    key = Path(installer_class.__name__) / wheel.path.stem</span>
<span class="gi">+                    wheel_img = self.app_data.wheel_image(creator.interpreter.version_release_str, key)</span>
<span class="gi">+                    installer = installer_class(wheel.path, creator, wheel_img)</span>
<span class="gi">+                    parent = self.app_data.lock / wheel_img.parent</span>
<span class="gi">+                    with parent.non_reentrant_lock_for_key(wheel_img.name):</span>
<span class="gi">+                        if not installer.has_image():</span>
<span class="gi">+                            installer.build_image()</span>
<span class="gi">+                    installer.install(creator.interpreter.version_info)</span>
<span class="gi">+                except Exception:  # noqa: BLE001</span>
<span class="gi">+                    exceptions[name] = sys.exc_info()</span>
<span class="gi">+</span>
<span class="gi">+            threads = [Thread(target=_install, args=(n, w)) for n, w in name_to_whl.items()]</span>
<span class="gi">+            for thread in threads:</span>
<span class="gi">+                thread.start()</span>
<span class="gi">+            for thread in threads:</span>
<span class="gi">+                thread.join()</span>
<span class="gi">+            if exceptions:</span>
<span class="gi">+                messages = [f&quot;failed to build image {&#39;, &#39;.join(exceptions.keys())} because:&quot;]</span>
<span class="gi">+                for value in exceptions.values():</span>
<span class="gi">+                    exc_type, exc_value, exc_traceback = value</span>
<span class="gi">+                    messages.append(&quot;&quot;.join(traceback.format_exception(exc_type, exc_value, exc_traceback)))</span>
<span class="gi">+                raise RuntimeError(&quot;\n&quot;.join(messages))</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def _get_seed_wheels(self, creator):  # noqa: C901</span>
<span class="gi">+        name_to_whl, lock, fail = {}, Lock(), {}</span>
<span class="gi">+</span>
<span class="gi">+        def _get(distribution, version):</span>
<span class="gi">+            for_py_version = creator.interpreter.version_release_str</span>
<span class="gi">+            failure, result = None, None</span>
<span class="gi">+            # fallback to download in case the exact version is not available</span>
<span class="gi">+            for download in [True] if self.download else [False, True]:</span>
<span class="gi">+                failure = None</span>
<span class="gi">+                try:</span>
<span class="gi">+                    result = get_wheel(</span>
<span class="gi">+                        distribution=distribution,</span>
<span class="gi">+                        version=version,</span>
<span class="gi">+                        for_py_version=for_py_version,</span>
<span class="gi">+                        search_dirs=self.extra_search_dir,</span>
<span class="gi">+                        download=download,</span>
<span class="gi">+                        app_data=self.app_data,</span>
<span class="gi">+                        do_periodic_update=self.periodic_update,</span>
<span class="gi">+                        env=self.env,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    if result is not None:</span>
<span class="gi">+                        break</span>
<span class="gi">+                except Exception as exception:</span>
<span class="gi">+                    logging.exception(&quot;fail&quot;)</span>
<span class="gi">+                    failure = exception</span>
<span class="gi">+            if failure:</span>
<span class="gi">+                if isinstance(failure, CalledProcessError):</span>
<span class="gi">+                    msg = f&quot;failed to download {distribution}&quot;</span>
<span class="gi">+                    if version is not None:</span>
<span class="gi">+                        msg += f&quot; version {version}&quot;</span>
<span class="gi">+                    msg += f&quot;, pip download exit code {failure.returncode}&quot;</span>
<span class="gi">+                    output = failure.output + failure.stderr</span>
<span class="gi">+                    if output:</span>
<span class="gi">+                        msg += &quot;\n&quot;</span>
<span class="gi">+                        msg += output</span>
<span class="gi">+                else:</span>
<span class="gi">+                    msg = repr(failure)</span>
<span class="gi">+                logging.error(msg)</span>
<span class="gi">+                with lock:</span>
<span class="gi">+                    fail[distribution] = version</span>
<span class="gi">+            else:</span>
<span class="gi">+                with lock:</span>
<span class="gi">+                    name_to_whl[distribution] = result</span>
<span class="gi">+</span>
<span class="gi">+        threads = [</span>
<span class="gi">+            Thread(target=_get, args=(distribution, version))</span>
<span class="gi">+            for distribution, version in self.distribution_to_versions().items()</span>
<span class="gi">+        ]</span>
<span class="gi">+        for thread in threads:</span>
<span class="gi">+            thread.start()</span>
<span class="gi">+        for thread in threads:</span>
<span class="gi">+            thread.join()</span>
<span class="gi">+        if fail:</span>
<span class="gi">+            msg = f&quot;seed failed due to failing to download wheels {&#39;, &#39;.join(fail.keys())}&quot;</span>
<span class="gi">+            raise RuntimeError(msg)</span>
<span class="gi">+        yield name_to_whl</span>
<span class="gi">+</span>
<span class="gi">+    def installer_class(self, pip_version_tuple):</span>
<span class="gi">+        if self.symlinks and pip_version_tuple and pip_version_tuple &gt;= (19, 3):  # symlink support requires pip 19.3+</span>
<span class="gi">+            return SymlinkPipInstall</span>
<span class="gi">+        return CopyPipInstall</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        msg = f&quot;, via={&#39;symlink&#39; if self.symlinks else &#39;copy&#39;}, app_data_dir={self.app_data}&quot;</span>
<span class="w"> </span>        base = super().__repr__()
<span class="gd">-        return f&#39;{base[:-1]}{msg}{base[-1]}&#39;</span>
<span class="gi">+        return f&quot;{base[:-1]}{msg}{base[-1]}&quot;</span>


<span class="gd">-__all__ = [&#39;FromAppData&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;FromAppData&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/seed/seeder.py b/src/virtualenv/seed/seeder.py</span>
<span class="gh">index 744b173..58fd8f4 100644</span>
<span class="gd">--- a/src/virtualenv/seed/seeder.py</span>
<span class="gi">+++ b/src/virtualenv/seed/seeder.py</span>
<span class="gu">@@ -1,11 +1,12 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABC, abstractmethod


<span class="w"> </span>class Seeder(ABC):
<span class="w"> </span>    &quot;&quot;&quot;A seeder will install some seed packages into a virtual environment.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, options, enabled) -&gt;None:</span>
<span class="gi">+    def __init__(self, options, enabled) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create.

<span class="gu">@@ -24,16 +25,19 @@ class Seeder(ABC):</span>
<span class="w"> </span>        :param app_data: the CLI parser
<span class="w"> </span>        :param interpreter: the interpreter this virtual environment is based of
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def run(self, creator):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Perform the seed operation.

<span class="gd">-        :param creator: the creator (based of :class:`virtualenv.create.creator.Creator`) we used to create this         virtual environment</span>
<span class="gi">+        :param creator: the creator (based of :class:`virtualenv.create.creator.Creator`) we used to create this \</span>
<span class="gi">+        virtual environment</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="gd">-__all__ = [&#39;Seeder&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Seeder&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/seed/wheels/acquire.py b/src/virtualenv/seed/wheels/acquire.py</span>
<span class="gh">index a3225d0..48fd46a 100644</span>
<span class="gd">--- a/src/virtualenv/seed/wheels/acquire.py</span>
<span class="gi">+++ b/src/virtualenv/seed/wheels/acquire.py</span>
<span class="gu">@@ -1,19 +1,132 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Bootstrap.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import sys
<span class="w"> </span>from operator import eq, lt
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from subprocess import PIPE, CalledProcessError, Popen
<span class="gi">+</span>
<span class="w"> </span>from .bundle import from_bundle
<span class="w"> </span>from .periodic_update import add_wheel_to_update_log
<span class="w"> </span>from .util import Version, Wheel, discover_wheels


<span class="gd">-def get_wheel(distribution, version, for_py_version, search_dirs, download,</span>
<span class="gd">-    app_data, do_periodic_update, env):</span>
<span class="gi">+def get_wheel(  # noqa: PLR0913</span>
<span class="gi">+    distribution,</span>
<span class="gi">+    version,</span>
<span class="gi">+    for_py_version,</span>
<span class="gi">+    search_dirs,</span>
<span class="gi">+    download,</span>
<span class="gi">+    app_data,</span>
<span class="gi">+    do_periodic_update,</span>
<span class="gi">+    env,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Get a wheel with the given distribution-version-for_py_version trio, by using the extra search dir + download.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # not all wheels are compatible with all python versions, so we need to py version qualify it</span>
<span class="gi">+    wheel = None</span>
<span class="gi">+</span>
<span class="gi">+    if not download or version != Version.bundle:</span>
<span class="gi">+        # 1. acquire from bundle</span>
<span class="gi">+        wheel = from_bundle(distribution, version, for_py_version, search_dirs, app_data, do_periodic_update, env)</span>
<span class="gi">+</span>
<span class="gi">+    if download and wheel is None and version != Version.embed:</span>
<span class="gi">+        # 2. download from the internet</span>
<span class="gi">+        wheel = download_wheel(</span>
<span class="gi">+            distribution=distribution,</span>
<span class="gi">+            version_spec=Version.as_version_spec(version),</span>
<span class="gi">+            for_py_version=for_py_version,</span>
<span class="gi">+            search_dirs=search_dirs,</span>
<span class="gi">+            app_data=app_data,</span>
<span class="gi">+            to_folder=app_data.house,</span>
<span class="gi">+            env=env,</span>
<span class="gi">+        )</span>
<span class="gi">+        if wheel is not None and app_data.can_update:</span>
<span class="gi">+            add_wheel_to_update_log(wheel, for_py_version, app_data)</span>
<span class="gi">+</span>
<span class="gi">+    return wheel</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def download_wheel(distribution, version_spec, for_py_version, search_dirs, app_data, to_folder, env):  # noqa: PLR0913</span>
<span class="gi">+    to_download = f&quot;{distribution}{version_spec or &#39;&#39;}&quot;</span>
<span class="gi">+    logging.debug(&quot;download wheel %s %s to %s&quot;, to_download, for_py_version, to_folder)</span>
<span class="gi">+    cmd = [</span>
<span class="gi">+        sys.executable,</span>
<span class="gi">+        &quot;-m&quot;,</span>
<span class="gi">+        &quot;pip&quot;,</span>
<span class="gi">+        &quot;download&quot;,</span>
<span class="gi">+        &quot;--progress-bar&quot;,</span>
<span class="gi">+        &quot;off&quot;,</span>
<span class="gi">+        &quot;--disable-pip-version-check&quot;,</span>
<span class="gi">+        &quot;--only-binary=:all:&quot;,</span>
<span class="gi">+        &quot;--no-deps&quot;,</span>
<span class="gi">+        &quot;--python-version&quot;,</span>
<span class="gi">+        for_py_version,</span>
<span class="gi">+        &quot;-d&quot;,</span>
<span class="gi">+        str(to_folder),</span>
<span class="gi">+        to_download,</span>
<span class="gi">+    ]</span>
<span class="gi">+    # pip has no interface in python - must be a new sub-process</span>
<span class="gi">+    env = pip_wheel_env_run(search_dirs, app_data, env)</span>
<span class="gi">+    process = Popen(cmd, env=env, stdout=PIPE, stderr=PIPE, universal_newlines=True, encoding=&quot;utf-8&quot;)  # noqa: S603</span>
<span class="gi">+    out, err = process.communicate()</span>
<span class="gi">+    if process.returncode != 0:</span>
<span class="gi">+        kwargs = {&quot;output&quot;: out, &quot;stderr&quot;: err}</span>
<span class="gi">+        raise CalledProcessError(process.returncode, cmd, **kwargs)</span>
<span class="gi">+    result = _find_downloaded_wheel(distribution, version_spec, for_py_version, to_folder, out)</span>
<span class="gi">+    logging.debug(&quot;downloaded wheel %s&quot;, result.name)</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_downloaded_wheel(distribution, version_spec, for_py_version, to_folder, out):</span>
<span class="gi">+    for line in out.splitlines():</span>
<span class="gi">+        stripped_line = line.lstrip()</span>
<span class="gi">+        for marker in (&quot;Saved &quot;, &quot;File was already downloaded &quot;):</span>
<span class="gi">+            if stripped_line.startswith(marker):</span>
<span class="gi">+                return Wheel(Path(stripped_line[len(marker) :]).absolute())</span>
<span class="gi">+    # if for some reason the output does not match fallback to the latest version with that spec</span>
<span class="gi">+    return find_compatible_in_house(distribution, version_spec, for_py_version, to_folder)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_compatible_in_house(distribution, version_spec, for_py_version, in_folder):</span>
<span class="gi">+    wheels = discover_wheels(in_folder, distribution, None, for_py_version)</span>
<span class="gi">+    start, end = 0, len(wheels)</span>
<span class="gi">+    if version_spec is not None and version_spec:</span>
<span class="gi">+        if version_spec.startswith(&quot;&lt;&quot;):</span>
<span class="gi">+            from_pos, op = 1, lt</span>
<span class="gi">+        elif version_spec.startswith(&quot;==&quot;):</span>
<span class="gi">+            from_pos, op = 2, eq</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(version_spec)</span>
<span class="gi">+        version = Wheel.as_version_tuple(version_spec[from_pos:])</span>
<span class="gi">+        start = next((at for at, w in enumerate(wheels) if op(w.version_tuple, version)), len(wheels))</span>
<span class="gi">+</span>
<span class="gi">+    return None if start == end else wheels[start]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pip_wheel_env_run(search_dirs, app_data, env):</span>
<span class="gi">+    env = env.copy()</span>
<span class="gi">+    env.update({&quot;PIP_USE_WHEEL&quot;: &quot;1&quot;, &quot;PIP_USER&quot;: &quot;0&quot;, &quot;PIP_NO_INPUT&quot;: &quot;1&quot;})</span>
<span class="gi">+    wheel = get_wheel(</span>
<span class="gi">+        distribution=&quot;pip&quot;,</span>
<span class="gi">+        version=None,</span>
<span class="gi">+        for_py_version=f&quot;{sys.version_info.major}.{sys.version_info.minor}&quot;,</span>
<span class="gi">+        search_dirs=search_dirs,</span>
<span class="gi">+        download=False,</span>
<span class="gi">+        app_data=app_data,</span>
<span class="gi">+        do_periodic_update=False,</span>
<span class="gi">+        env=env,</span>
<span class="gi">+    )</span>
<span class="gi">+    if wheel is None:</span>
<span class="gi">+        msg = &quot;could not find the embedded pip&quot;</span>
<span class="gi">+        raise RuntimeError(msg)</span>
<span class="gi">+    env[&quot;PYTHONPATH&quot;] = str(wheel.path)</span>
<span class="gi">+    return env</span>


<span class="gd">-__all__ = [&#39;download_wheel&#39;, &#39;get_wheel&#39;, &#39;pip_wheel_env_run&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;download_wheel&quot;,</span>
<span class="gi">+    &quot;get_wheel&quot;,</span>
<span class="gi">+    &quot;pip_wheel_env_run&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/seed/wheels/bundle.py b/src/virtualenv/seed/wheels/bundle.py</span>
<span class="gh">index dacec6a..523e45c 100644</span>
<span class="gd">--- a/src/virtualenv/seed/wheels/bundle.py</span>
<span class="gi">+++ b/src/virtualenv/seed/wheels/bundle.py</span>
<span class="gu">@@ -1,18 +1,50 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.seed.wheels.embed import get_embed_wheel
<span class="gi">+</span>
<span class="w"> </span>from .periodic_update import periodic_update
<span class="w"> </span>from .util import Version, Wheel, discover_wheels


<span class="gd">-def from_bundle(distribution, version, for_py_version, search_dirs,</span>
<span class="gd">-    app_data, do_periodic_update, env):</span>
<span class="gi">+def from_bundle(distribution, version, for_py_version, search_dirs, app_data, do_periodic_update, env):  # noqa: PLR0913</span>
<span class="w"> </span>    &quot;&quot;&quot;Load the bundled wheel to a cache directory.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    of_version = Version.of_version(version)</span>
<span class="gi">+    wheel = load_embed_wheel(app_data, distribution, for_py_version, of_version)</span>
<span class="gi">+</span>
<span class="gi">+    if version != Version.embed:</span>
<span class="gi">+        # 2. check if we have upgraded embed</span>
<span class="gi">+        if app_data.can_update:</span>
<span class="gi">+            per = do_periodic_update</span>
<span class="gi">+            wheel = periodic_update(distribution, of_version, for_py_version, wheel, search_dirs, app_data, per, env)</span>
<span class="gi">+</span>
<span class="gi">+        # 3. acquire from extra search dir</span>
<span class="gi">+        found_wheel = from_dir(distribution, of_version, for_py_version, search_dirs)</span>
<span class="gi">+        if found_wheel is not None and (wheel is None or found_wheel.version_tuple &gt; wheel.version_tuple):</span>
<span class="gi">+            wheel = found_wheel</span>
<span class="gi">+    return wheel</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_embed_wheel(app_data, distribution, for_py_version, version):</span>
<span class="gi">+    wheel = get_embed_wheel(distribution, for_py_version)</span>
<span class="gi">+    if wheel is not None:</span>
<span class="gi">+        version_match = version == wheel.version</span>
<span class="gi">+        if version is None or version_match:</span>
<span class="gi">+            with app_data.ensure_extracted(wheel.path, lambda: app_data.house) as wheel_path:</span>
<span class="gi">+                wheel = Wheel(wheel_path)</span>
<span class="gi">+        else:  # if version does not match ignore</span>
<span class="gi">+            wheel = None</span>
<span class="gi">+    return wheel</span>


<span class="w"> </span>def from_dir(distribution, version, for_py_version, directories):
<span class="w"> </span>    &quot;&quot;&quot;Load a compatible wheel from a given folder.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for folder in directories:</span>
<span class="gi">+        for wheel in discover_wheels(folder, distribution, version, for_py_version):</span>
<span class="gi">+            return wheel</span>
<span class="gi">+    return None</span>


<span class="gd">-__all__ = [&#39;from_bundle&#39;, &#39;load_embed_wheel&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;from_bundle&quot;,</span>
<span class="gi">+    &quot;load_embed_wheel&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/seed/wheels/periodic_update.py b/src/virtualenv/seed/wheels/periodic_update.py</span>
<span class="gh">index 8d77ff3..a421079 100644</span>
<span class="gd">--- a/src/virtualenv/seed/wheels/periodic_update.py</span>
<span class="gi">+++ b/src/virtualenv/seed/wheels/periodic_update.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Periodically update bundled versions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import json
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="gu">@@ -14,49 +16,412 @@ from textwrap import dedent</span>
<span class="w"> </span>from threading import Thread
<span class="w"> </span>from urllib.error import URLError
<span class="w"> </span>from urllib.request import urlopen
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.app_data import AppDataDiskFolder
<span class="w"> </span>from virtualenv.seed.wheels.embed import BUNDLE_SUPPORT
<span class="w"> </span>from virtualenv.seed.wheels.util import Wheel
<span class="w"> </span>from virtualenv.util.subprocess import CREATE_NO_WINDOW
<span class="gd">-GRACE_PERIOD_CI = timedelta(hours=1)</span>
<span class="gi">+</span>
<span class="gi">+GRACE_PERIOD_CI = timedelta(hours=1)  # prevent version switch in the middle of a CI run</span>
<span class="w"> </span>GRACE_PERIOD_MINOR = timedelta(days=28)
<span class="w"> </span>UPDATE_PERIOD = timedelta(days=14)
<span class="w"> </span>UPDATE_ABORTED_DELAY = timedelta(hours=1)
<span class="gd">-DATETIME_FMT = &#39;%Y-%m-%dT%H:%M:%S.%fZ&#39;</span>


<span class="gd">-class NewVersion:</span>
<span class="gi">+def periodic_update(  # noqa: PLR0913</span>
<span class="gi">+    distribution,</span>
<span class="gi">+    of_version,</span>
<span class="gi">+    for_py_version,</span>
<span class="gi">+    wheel,</span>
<span class="gi">+    search_dirs,</span>
<span class="gi">+    app_data,</span>
<span class="gi">+    do_periodic_update,</span>
<span class="gi">+    env,</span>
<span class="gi">+):</span>
<span class="gi">+    if do_periodic_update:</span>
<span class="gi">+        handle_auto_update(distribution, for_py_version, wheel, search_dirs, app_data, env)</span>
<span class="gi">+</span>
<span class="gi">+    now = datetime.now(tz=timezone.utc)</span>
<span class="gi">+</span>
<span class="gi">+    def _update_wheel(ver):</span>
<span class="gi">+        updated_wheel = Wheel(app_data.house / ver.filename)</span>
<span class="gi">+        logging.debug(&quot;using %supdated wheel %s&quot;, &quot;periodically &quot; if updated_wheel else &quot;&quot;, updated_wheel)</span>
<span class="gi">+        return updated_wheel</span>
<span class="gi">+</span>
<span class="gi">+    u_log = UpdateLog.from_app_data(app_data, distribution, for_py_version)</span>
<span class="gi">+    if of_version is None:</span>
<span class="gi">+        for _, group in groupby(u_log.versions, key=lambda v: v.wheel.version_tuple[0:2]):</span>
<span class="gi">+            # use only latest patch version per minor, earlier assumed to be buggy</span>
<span class="gi">+            all_patches = list(group)</span>
<span class="gi">+            ignore_grace_period_minor = any(version for version in all_patches if version.use(now))</span>
<span class="gi">+            for version in all_patches:</span>
<span class="gi">+                if wheel is not None and Path(version.filename).name == wheel.name:</span>
<span class="gi">+                    return wheel</span>
<span class="gi">+                if version.use(now, ignore_grace_period_minor):</span>
<span class="gi">+                    return _update_wheel(version)</span>
<span class="gi">+    else:</span>
<span class="gi">+        for version in u_log.versions:</span>
<span class="gi">+            if version.wheel.version == of_version:</span>
<span class="gi">+                return _update_wheel(version)</span>
<span class="gi">+</span>
<span class="gi">+    return wheel</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def handle_auto_update(distribution, for_py_version, wheel, search_dirs, app_data, env):  # noqa: PLR0913</span>
<span class="gi">+    embed_update_log = app_data.embed_update_log(distribution, for_py_version)</span>
<span class="gi">+    u_log = UpdateLog.from_dict(embed_update_log.read())</span>
<span class="gi">+    if u_log.needs_update:</span>
<span class="gi">+        u_log.periodic = True</span>
<span class="gi">+        u_log.started = datetime.now(tz=timezone.utc)</span>
<span class="gi">+        embed_update_log.write(u_log.to_dict())</span>
<span class="gi">+        trigger_update(distribution, for_py_version, wheel, search_dirs, app_data, periodic=True, env=env)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def add_wheel_to_update_log(wheel, for_py_version, app_data):</span>
<span class="gi">+    embed_update_log = app_data.embed_update_log(wheel.distribution, for_py_version)</span>
<span class="gi">+    logging.debug(&quot;adding %s information to %s&quot;, wheel.name, embed_update_log.file)</span>
<span class="gi">+    u_log = UpdateLog.from_dict(embed_update_log.read())</span>
<span class="gi">+    if any(version.filename == wheel.name for version in u_log.versions):</span>
<span class="gi">+        logging.warning(&quot;%s already present in %s&quot;, wheel.name, embed_update_log.file)</span>
<span class="gi">+        return</span>
<span class="gi">+    # we don&#39;t need a release date for sources other than &quot;periodic&quot;</span>
<span class="gi">+    version = NewVersion(wheel.name, datetime.now(tz=timezone.utc), None, &quot;download&quot;)</span>
<span class="gi">+    u_log.versions.append(version)  # always write at the end for proper updates</span>
<span class="gi">+    embed_update_log.write(u_log.to_dict())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+DATETIME_FMT = &quot;%Y-%m-%dT%H:%M:%S.%fZ&quot;</span>
<span class="gi">+</span>

<span class="gd">-    def __init__(self, filename, found_date, release_date, source) -&gt;None:</span>
<span class="gi">+def dump_datetime(value):</span>
<span class="gi">+    return None if value is None else value.strftime(DATETIME_FMT)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_datetime(value):</span>
<span class="gi">+    return None if value is None else datetime.strptime(value, DATETIME_FMT).replace(tzinfo=timezone.utc)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class NewVersion:  # noqa: PLW1641</span>
<span class="gi">+    def __init__(self, filename, found_date, release_date, source) -&gt; None:</span>
<span class="w"> </span>        self.filename = filename
<span class="w"> </span>        self.found_date = found_date
<span class="w"> </span>        self.release_date = release_date
<span class="w"> </span>        self.source = source

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_dict(cls, dictionary):</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            filename=dictionary[&quot;filename&quot;],</span>
<span class="gi">+            found_date=load_datetime(dictionary[&quot;found_date&quot;]),</span>
<span class="gi">+            release_date=load_datetime(dictionary[&quot;release_date&quot;]),</span>
<span class="gi">+            source=dictionary[&quot;source&quot;],</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def to_dict(self):</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;filename&quot;: self.filename,</span>
<span class="gi">+            &quot;release_date&quot;: dump_datetime(self.release_date),</span>
<span class="gi">+            &quot;found_date&quot;: dump_datetime(self.found_date),</span>
<span class="gi">+            &quot;source&quot;: self.source,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def use(self, now, ignore_grace_period_minor=False, ignore_grace_period_ci=False):  # noqa: FBT002</span>
<span class="gi">+        if self.source == &quot;manual&quot;:</span>
<span class="gi">+            return True</span>
<span class="gi">+        if self.source == &quot;periodic&quot; and (self.found_date &lt; now - GRACE_PERIOD_CI or ignore_grace_period_ci):</span>
<span class="gi">+            if not ignore_grace_period_minor:</span>
<span class="gi">+                compare_from = self.release_date or self.found_date</span>
<span class="gi">+                return now - compare_from &gt;= GRACE_PERIOD_MINOR</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return (
<span class="gd">-            f&#39;{self.__class__.__name__}(filename={self.filename}), found_date={self.found_date}, release_date={self.release_date}, source={self.source})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+            f&quot;{self.__class__.__name__}(filename={self.filename}), found_date={self.found_date}, &quot;</span>
<span class="gi">+            f&quot;release_date={self.release_date}, source={self.source})&quot;</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="gd">-        return type(self) == type(other) and all(getattr(self, k) ==</span>
<span class="gd">-            getattr(other, k) for k in [&#39;filename&#39;, &#39;release_date&#39;,</span>
<span class="gd">-            &#39;found_date&#39;, &#39;source&#39;])</span>
<span class="gi">+        return type(self) == type(other) and all(</span>
<span class="gi">+            getattr(self, k) == getattr(other, k) for k in [&quot;filename&quot;, &quot;release_date&quot;, &quot;found_date&quot;, &quot;source&quot;]</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __ne__(self, other):
<span class="gd">-        return not self == other</span>
<span class="gi">+        return not (self == other)</span>

<span class="gi">+    @property</span>
<span class="gi">+    def wheel(self):</span>
<span class="gi">+        return Wheel(Path(self.filename))</span>

<span class="gd">-class UpdateLog:</span>

<span class="gd">-    def __init__(self, started, completed, versions, periodic) -&gt;None:</span>
<span class="gi">+class UpdateLog:</span>
<span class="gi">+    def __init__(self, started, completed, versions, periodic) -&gt; None:</span>
<span class="w"> </span>        self.started = started
<span class="w"> </span>        self.completed = completed
<span class="w"> </span>        self.versions = versions
<span class="w"> </span>        self.periodic = periodic

<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_dict(cls, dictionary):</span>
<span class="gi">+        if dictionary is None:</span>
<span class="gi">+            dictionary = {}</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            load_datetime(dictionary.get(&quot;started&quot;)),</span>
<span class="gi">+            load_datetime(dictionary.get(&quot;completed&quot;)),</span>
<span class="gi">+            [NewVersion.from_dict(v) for v in dictionary.get(&quot;versions&quot;, [])],</span>
<span class="gi">+            dictionary.get(&quot;periodic&quot;),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_app_data(cls, app_data, distribution, for_py_version):</span>
<span class="gi">+        raw_json = app_data.embed_update_log(distribution, for_py_version).read()</span>
<span class="gi">+        return cls.from_dict(raw_json)</span>
<span class="gi">+</span>
<span class="gi">+    def to_dict(self):</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;started&quot;: dump_datetime(self.started),</span>
<span class="gi">+            &quot;completed&quot;: dump_datetime(self.completed),</span>
<span class="gi">+            &quot;periodic&quot;: self.periodic,</span>
<span class="gi">+            &quot;versions&quot;: [r.to_dict() for r in self.versions],</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def needs_update(self):</span>
<span class="gi">+        now = datetime.now(tz=timezone.utc)</span>
<span class="gi">+        if self.completed is None:  # never completed</span>
<span class="gi">+            return self._check_start(now)</span>
<span class="gi">+        if now - self.completed &lt;= UPDATE_PERIOD:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return self._check_start(now)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_start(self, now):</span>
<span class="gi">+        return self.started is None or now - self.started &gt; UPDATE_ABORTED_DELAY</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def trigger_update(distribution, for_py_version, wheel, search_dirs, app_data, env, periodic):  # noqa: PLR0913</span>
<span class="gi">+    wheel_path = None if wheel is None else str(wheel.path)</span>
<span class="gi">+    cmd = [</span>
<span class="gi">+        sys.executable,</span>
<span class="gi">+        &quot;-c&quot;,</span>
<span class="gi">+        dedent(</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+        from virtualenv.report import setup_report, MAX_LEVEL</span>
<span class="gi">+        from virtualenv.seed.wheels.periodic_update import do_update</span>
<span class="gi">+        setup_report(MAX_LEVEL, show_pid=True)</span>
<span class="gi">+        do_update({!r}, {!r}, {!r}, {!r}, {!r}, {!r})</span>
<span class="gi">+        &quot;&quot;&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        .strip()</span>
<span class="gi">+        .format(distribution, for_py_version, wheel_path, str(app_data), [str(p) for p in search_dirs], periodic),</span>
<span class="gi">+    ]</span>
<span class="gi">+    debug = env.get(&quot;_VIRTUALENV_PERIODIC_UPDATE_INLINE&quot;) == &quot;1&quot;</span>
<span class="gi">+    pipe = None if debug else DEVNULL</span>
<span class="gi">+    kwargs = {&quot;stdout&quot;: pipe, &quot;stderr&quot;: pipe}</span>
<span class="gi">+    if not debug and sys.platform == &quot;win32&quot;:</span>
<span class="gi">+        kwargs[&quot;creationflags&quot;] = CREATE_NO_WINDOW</span>
<span class="gi">+    process = Popen(cmd, **kwargs)  # noqa: S603</span>
<span class="gi">+    logging.info(</span>
<span class="gi">+        &quot;triggered periodic upgrade of %s%s (for python %s) via background process having PID %d&quot;,</span>
<span class="gi">+        distribution,</span>
<span class="gi">+        &quot;&quot; if wheel is None else f&quot;=={wheel.version}&quot;,</span>
<span class="gi">+        for_py_version,</span>
<span class="gi">+        process.pid,</span>
<span class="gi">+    )</span>
<span class="gi">+    if debug:</span>
<span class="gi">+        process.communicate()  # on purpose not called to make it a background process</span>
<span class="gi">+    else:</span>
<span class="gi">+        # set the returncode here -&gt; no ResourceWarning on main process exit if the subprocess still runs</span>
<span class="gi">+        process.returncode = 0</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def do_update(distribution, for_py_version, embed_filename, app_data, search_dirs, periodic):  # noqa: PLR0913</span>
<span class="gi">+    versions = None</span>
<span class="gi">+    try:</span>
<span class="gi">+        versions = _run_do_update(app_data, distribution, embed_filename, for_py_version, periodic, search_dirs)</span>
<span class="gi">+    finally:</span>
<span class="gi">+        logging.debug(&quot;done %s %s with %s&quot;, distribution, for_py_version, versions)</span>
<span class="gi">+    return versions</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _run_do_update(  # noqa: C901, PLR0913</span>
<span class="gi">+    app_data,</span>
<span class="gi">+    distribution,</span>
<span class="gi">+    embed_filename,</span>
<span class="gi">+    for_py_version,</span>
<span class="gi">+    periodic,</span>
<span class="gi">+    search_dirs,</span>
<span class="gi">+):</span>
<span class="gi">+    from virtualenv.seed.wheels import acquire  # noqa: PLC0415</span>
<span class="gi">+</span>
<span class="gi">+    wheel_filename = None if embed_filename is None else Path(embed_filename)</span>
<span class="gi">+    embed_version = None if wheel_filename is None else Wheel(wheel_filename).version_tuple</span>
<span class="gi">+    app_data = AppDataDiskFolder(app_data) if isinstance(app_data, str) else app_data</span>
<span class="gi">+    search_dirs = [Path(p) if isinstance(p, str) else p for p in search_dirs]</span>
<span class="gi">+    wheelhouse = app_data.house</span>
<span class="gi">+    embed_update_log = app_data.embed_update_log(distribution, for_py_version)</span>
<span class="gi">+    u_log = UpdateLog.from_dict(embed_update_log.read())</span>
<span class="gi">+    now = datetime.now(tz=timezone.utc)</span>
<span class="gi">+</span>
<span class="gi">+    update_versions, other_versions = [], []</span>
<span class="gi">+    for version in u_log.versions:</span>
<span class="gi">+        if version.source in {&quot;periodic&quot;, &quot;manual&quot;}:</span>
<span class="gi">+            update_versions.append(version)</span>
<span class="gi">+        else:</span>
<span class="gi">+            other_versions.append(version)</span>
<span class="gi">+</span>
<span class="gi">+    if periodic:</span>
<span class="gi">+        source = &quot;periodic&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        source = &quot;manual&quot;</span>
<span class="gi">+        # mark the most recent one as source &quot;manual&quot;</span>
<span class="gi">+        if update_versions:</span>
<span class="gi">+            update_versions[0].source = source</span>
<span class="gi">+</span>
<span class="gi">+    if wheel_filename is not None:</span>
<span class="gi">+        dest = wheelhouse / wheel_filename.name</span>
<span class="gi">+        if not dest.exists():</span>
<span class="gi">+            copy2(str(wheel_filename), str(wheelhouse))</span>
<span class="gi">+    last, last_version, versions, filenames = None, None, [], set()</span>
<span class="gi">+    while last is None or not last.use(now, ignore_grace_period_ci=True):</span>
<span class="gi">+        download_time = datetime.now(tz=timezone.utc)</span>
<span class="gi">+        dest = acquire.download_wheel(</span>
<span class="gi">+            distribution=distribution,</span>
<span class="gi">+            version_spec=None if last_version is None else f&quot;&lt;{last_version}&quot;,</span>
<span class="gi">+            for_py_version=for_py_version,</span>
<span class="gi">+            search_dirs=search_dirs,</span>
<span class="gi">+            app_data=app_data,</span>
<span class="gi">+            to_folder=wheelhouse,</span>
<span class="gi">+            env=os.environ,</span>
<span class="gi">+        )</span>
<span class="gi">+        if dest is None or (update_versions and update_versions[0].filename == dest.name):</span>
<span class="gi">+            break</span>
<span class="gi">+        release_date = release_date_for_wheel_path(dest.path)</span>
<span class="gi">+        last = NewVersion(filename=dest.path.name, release_date=release_date, found_date=download_time, source=source)</span>
<span class="gi">+        logging.info(&quot;detected %s in %s&quot;, last, datetime.now(tz=timezone.utc) - download_time)</span>
<span class="gi">+        versions.append(last)</span>
<span class="gi">+        filenames.add(last.filename)</span>
<span class="gi">+        last_wheel = last.wheel</span>
<span class="gi">+        last_version = last_wheel.version</span>
<span class="gi">+        if embed_version is not None and embed_version &gt;= last_wheel.version_tuple:</span>
<span class="gi">+            break  # stop download if we reach the embed version</span>
<span class="gi">+    u_log.periodic = periodic</span>
<span class="gi">+    if not u_log.periodic:</span>
<span class="gi">+        u_log.started = now</span>
<span class="gi">+    # update other_versions by removing version we just found</span>
<span class="gi">+    other_versions = [version for version in other_versions if version.filename not in filenames]</span>
<span class="gi">+    u_log.versions = versions + update_versions + other_versions</span>
<span class="gi">+    u_log.completed = datetime.now(tz=timezone.utc)</span>
<span class="gi">+    embed_update_log.write(u_log.to_dict())</span>
<span class="gi">+    return versions</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def release_date_for_wheel_path(dest):</span>
<span class="gi">+    wheel = Wheel(dest)</span>
<span class="gi">+    # the most accurate is to ask PyPi - e.g. https://pypi.org/pypi/pip/json,</span>
<span class="gi">+    # see https://warehouse.pypa.io/api-reference/json/ for more details</span>
<span class="gi">+    content = _pypi_get_distribution_info_cached(wheel.distribution)</span>
<span class="gi">+    if content is not None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            upload_time = content[&quot;releases&quot;][wheel.version][0][&quot;upload_time&quot;]</span>
<span class="gi">+            return datetime.strptime(upload_time, &quot;%Y-%m-%dT%H:%M:%S&quot;).replace(tzinfo=timezone.utc)</span>
<span class="gi">+        except Exception as exception:  # noqa: BLE001</span>
<span class="gi">+            logging.error(&quot;could not load release date %s because %r&quot;, content, exception)  # noqa: TRY400</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _request_context():</span>
<span class="gi">+    yield None</span>
<span class="gi">+    # fallback to non verified HTTPS (the information we request is not sensitive, so fallback)</span>
<span class="gi">+    yield ssl._create_unverified_context()  # noqa: S323, SLF001</span>
<span class="gi">+</span>

<span class="w"> </span>_PYPI_CACHE = {}
<span class="gd">-__all__ = [&#39;NewVersion&#39;, &#39;UpdateLog&#39;, &#39;add_wheel_to_update_log&#39;,</span>
<span class="gd">-    &#39;do_update&#39;, &#39;dump_datetime&#39;, &#39;load_datetime&#39;, &#39;manual_upgrade&#39;,</span>
<span class="gd">-    &#39;periodic_update&#39;, &#39;release_date_for_wheel_path&#39;, &#39;trigger_update&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _pypi_get_distribution_info_cached(distribution):</span>
<span class="gi">+    if distribution not in _PYPI_CACHE:</span>
<span class="gi">+        _PYPI_CACHE[distribution] = _pypi_get_distribution_info(distribution)</span>
<span class="gi">+    return _PYPI_CACHE[distribution]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _pypi_get_distribution_info(distribution):</span>
<span class="gi">+    content, url = None, f&quot;https://pypi.org/pypi/{distribution}/json&quot;</span>
<span class="gi">+    try:</span>
<span class="gi">+        for context in _request_context():</span>
<span class="gi">+            try:</span>
<span class="gi">+                with urlopen(url, context=context) as file_handler:  # noqa: S310</span>
<span class="gi">+                    content = json.load(file_handler)</span>
<span class="gi">+                break</span>
<span class="gi">+            except URLError as exception:</span>
<span class="gi">+                logging.error(&quot;failed to access %s because %r&quot;, url, exception)  # noqa: TRY400</span>
<span class="gi">+    except Exception as exception:  # noqa: BLE001</span>
<span class="gi">+        logging.error(&quot;failed to access %s because %r&quot;, url, exception)  # noqa: TRY400</span>
<span class="gi">+    return content</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def manual_upgrade(app_data, env):</span>
<span class="gi">+    threads = []</span>
<span class="gi">+</span>
<span class="gi">+    for for_py_version, distribution_to_package in BUNDLE_SUPPORT.items():</span>
<span class="gi">+        # load extra search dir for the given for_py</span>
<span class="gi">+        for distribution in distribution_to_package:</span>
<span class="gi">+            thread = Thread(target=_run_manual_upgrade, args=(app_data, distribution, for_py_version, env))</span>
<span class="gi">+            thread.start()</span>
<span class="gi">+            threads.append(thread)</span>
<span class="gi">+</span>
<span class="gi">+    for thread in threads:</span>
<span class="gi">+        thread.join()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _run_manual_upgrade(app_data, distribution, for_py_version, env):</span>
<span class="gi">+    start = datetime.now(tz=timezone.utc)</span>
<span class="gi">+    from .bundle import from_bundle  # noqa: PLC0415</span>
<span class="gi">+</span>
<span class="gi">+    current = from_bundle(</span>
<span class="gi">+        distribution=distribution,</span>
<span class="gi">+        version=None,</span>
<span class="gi">+        for_py_version=for_py_version,</span>
<span class="gi">+        search_dirs=[],</span>
<span class="gi">+        app_data=app_data,</span>
<span class="gi">+        do_periodic_update=False,</span>
<span class="gi">+        env=env,</span>
<span class="gi">+    )</span>
<span class="gi">+    logging.warning(</span>
<span class="gi">+        &quot;upgrade %s for python %s with current %s&quot;,</span>
<span class="gi">+        distribution,</span>
<span class="gi">+        for_py_version,</span>
<span class="gi">+        &quot;&quot; if current is None else current.name,</span>
<span class="gi">+    )</span>
<span class="gi">+    versions = do_update(</span>
<span class="gi">+        distribution=distribution,</span>
<span class="gi">+        for_py_version=for_py_version,</span>
<span class="gi">+        embed_filename=current.path,</span>
<span class="gi">+        app_data=app_data,</span>
<span class="gi">+        search_dirs=[],</span>
<span class="gi">+        periodic=False,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    args = [</span>
<span class="gi">+        distribution,</span>
<span class="gi">+        for_py_version,</span>
<span class="gi">+        datetime.now(tz=timezone.utc) - start,</span>
<span class="gi">+    ]</span>
<span class="gi">+    if versions:</span>
<span class="gi">+        args.append(&quot;\n&quot;.join(f&quot;\t{v}&quot; for v in versions))</span>
<span class="gi">+    ver_update = &quot;new entries found:\n%s&quot; if versions else &quot;no new versions found&quot;</span>
<span class="gi">+    msg = f&quot;upgraded %s for python %s in %s {ver_update}&quot;</span>
<span class="gi">+    logging.warning(msg, *args)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;NewVersion&quot;,</span>
<span class="gi">+    &quot;UpdateLog&quot;,</span>
<span class="gi">+    &quot;add_wheel_to_update_log&quot;,</span>
<span class="gi">+    &quot;do_update&quot;,</span>
<span class="gi">+    &quot;dump_datetime&quot;,</span>
<span class="gi">+    &quot;load_datetime&quot;,</span>
<span class="gi">+    &quot;manual_upgrade&quot;,</span>
<span class="gi">+    &quot;periodic_update&quot;,</span>
<span class="gi">+    &quot;release_date_for_wheel_path&quot;,</span>
<span class="gi">+    &quot;trigger_update&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/seed/wheels/util.py b/src/virtualenv/seed/wheels/util.py</span>
<span class="gh">index aced3f7..2bc01ae 100644</span>
<span class="gd">--- a/src/virtualenv/seed/wheels/util.py</span>
<span class="gi">+++ b/src/virtualenv/seed/wheels/util.py</span>
<span class="gu">@@ -1,25 +1,121 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from operator import attrgetter
<span class="w"> </span>from zipfile import ZipFile


<span class="w"> </span>class Wheel:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, path) -&gt;None:</span>
<span class="gi">+    def __init__(self, path) -&gt; None:</span>
<span class="gi">+        # https://www.python.org/dev/peps/pep-0427/#file-name-convention</span>
<span class="gi">+        # The wheel filename is {distribution}-{version}(-{build tag})?-{python tag}-{abi tag}-{platform tag}.whl</span>
<span class="w"> </span>        self.path = path
<span class="gd">-        self._parts = path.stem.split(&#39;-&#39;)</span>
<span class="gi">+        self._parts = path.stem.split(&quot;-&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_path(cls, path):</span>
<span class="gi">+        if path is not None and path.suffix == &quot;.whl&quot; and len(path.stem.split(&quot;-&quot;)) &gt;= 5:  # noqa: PLR2004</span>
<span class="gi">+            return cls(path)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def distribution(self):</span>
<span class="gi">+        return self._parts[0]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def version(self):</span>
<span class="gi">+        return self._parts[1]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def version_tuple(self):</span>
<span class="gi">+        return self.as_version_tuple(self.version)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def as_version_tuple(version):</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for part in version.split(&quot;.&quot;)[0:3]:</span>
<span class="gi">+            try:</span>
<span class="gi">+                result.append(int(part))</span>
<span class="gi">+            except ValueError:  # noqa: PERF203</span>
<span class="gi">+                break</span>
<span class="gi">+        if not result:</span>
<span class="gi">+            raise ValueError(version)</span>
<span class="gi">+        return tuple(result)</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}({self.path})&#39;</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return self.path.name</span>

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def support_py(self, py_version):</span>
<span class="gi">+        name = f&quot;{&#39;-&#39;.join(self.path.stem.split(&#39;-&#39;)[0:2])}.dist-info/METADATA&quot;</span>
<span class="gi">+        with ZipFile(str(self.path), &quot;r&quot;) as zip_file:</span>
<span class="gi">+            metadata = zip_file.read(name).decode(&quot;utf-8&quot;)</span>
<span class="gi">+        marker = &quot;Requires-Python:&quot;</span>
<span class="gi">+        requires = next((i[len(marker) :] for i in metadata.splitlines() if i.startswith(marker)), None)</span>
<span class="gi">+        if requires is None:  # if it does not specify a python requires the assumption is compatible</span>
<span class="gi">+            return True</span>
<span class="gi">+        py_version_int = tuple(int(i) for i in py_version.split(&quot;.&quot;))</span>
<span class="gi">+        for require in (i.strip() for i in requires.split(&quot;,&quot;)):</span>
<span class="gi">+            # https://www.python.org/dev/peps/pep-0345/#version-specifiers</span>
<span class="gi">+            for operator, check in [</span>
<span class="gi">+                (&quot;!=&quot;, lambda v: py_version_int != v),</span>
<span class="gi">+                (&quot;==&quot;, lambda v: py_version_int == v),</span>
<span class="gi">+                (&quot;&lt;=&quot;, lambda v: py_version_int &lt;= v),</span>
<span class="gi">+                (&quot;&gt;=&quot;, lambda v: py_version_int &gt;= v),</span>
<span class="gi">+                (&quot;&lt;&quot;, lambda v: py_version_int &lt; v),</span>
<span class="gi">+                (&quot;&gt;&quot;, lambda v: py_version_int &gt; v),</span>
<span class="gi">+            ]:</span>
<span class="gi">+                if require.startswith(operator):</span>
<span class="gi">+                    ver_str = require[len(operator) :].strip()</span>
<span class="gi">+                    version = tuple((int(i) if i != &quot;*&quot; else None) for i in ver_str.split(&quot;.&quot;))[0:2]</span>
<span class="gi">+                    if not check(version):</span>
<span class="gi">+                        return False</span>
<span class="gi">+                    break</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self.path})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return str(self.path)


<span class="gi">+def discover_wheels(from_folder, distribution, version, for_py_version):</span>
<span class="gi">+    wheels = []</span>
<span class="gi">+    for filename in from_folder.iterdir():</span>
<span class="gi">+        wheel = Wheel.from_path(filename)</span>
<span class="gi">+        if (</span>
<span class="gi">+            wheel</span>
<span class="gi">+            and wheel.distribution == distribution</span>
<span class="gi">+            and (version is None or wheel.version == version)</span>
<span class="gi">+            and wheel.support_py(for_py_version)</span>
<span class="gi">+        ):</span>
<span class="gi">+            wheels.append(wheel)</span>
<span class="gi">+    return sorted(wheels, key=attrgetter(&quot;version_tuple&quot;, &quot;distribution&quot;), reverse=True)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Version:
<span class="gd">-    bundle = &#39;bundle&#39;</span>
<span class="gd">-    embed = &#39;embed&#39;</span>
<span class="gd">-    non_version = bundle, embed</span>
<span class="gi">+    #: the version bundled with virtualenv</span>
<span class="gi">+    bundle = &quot;bundle&quot;</span>
<span class="gi">+    embed = &quot;embed&quot;</span>
<span class="gi">+    #: custom version handlers</span>
<span class="gi">+    non_version = (bundle, embed)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def of_version(value):</span>
<span class="gi">+        return None if value in Version.non_version else value</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def as_pip_req(distribution, version):</span>
<span class="gi">+        return f&quot;{distribution}{Version.as_version_spec(version)}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def as_version_spec(version):</span>
<span class="gi">+        of_version = Version.of_version(version)</span>
<span class="gi">+        return &quot;&quot; if of_version is None else f&quot;=={of_version}&quot;</span>


<span class="gd">-__all__ = [&#39;Version&#39;, &#39;Wheel&#39;, &#39;discover_wheels&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Version&quot;,</span>
<span class="gi">+    &quot;Wheel&quot;,</span>
<span class="gi">+    &quot;discover_wheels&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/util/error.py b/src/virtualenv/util/error.py</span>
<span class="gh">index 1978e83..a317ddc 100644</span>
<span class="gd">--- a/src/virtualenv/util/error.py</span>
<span class="gi">+++ b/src/virtualenv/util/error.py</span>
<span class="gu">@@ -1,11 +1,12 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Errors.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations


<span class="w"> </span>class ProcessCallFailedError(RuntimeError):
<span class="w"> </span>    &quot;&quot;&quot;Failed a process call.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, code, out, err, cmd) -&gt;None:</span>
<span class="gi">+    def __init__(self, code, out, err, cmd) -&gt; None:</span>
<span class="w"> </span>        super().__init__(code, out, err, cmd)
<span class="w"> </span>        self.code = code
<span class="w"> </span>        self.out = out
<span class="gh">diff --git a/src/virtualenv/util/lock.py b/src/virtualenv/util/lock.py</span>
<span class="gh">index 03295d2..b4dc66a 100644</span>
<span class="gd">--- a/src/virtualenv/util/lock.py</span>
<span class="gi">+++ b/src/virtualenv/util/lock.py</span>
<span class="gu">@@ -1,38 +1,55 @@</span>
<span class="w"> </span>&quot;&quot;&quot;holds locking functionality that works across processes.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="w"> </span>from abc import ABC, abstractmethod
<span class="w"> </span>from contextlib import contextmanager, suppress
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from threading import Lock, RLock
<span class="gi">+</span>
<span class="w"> </span>from filelock import FileLock, Timeout


<span class="w"> </span>class _CountedFileLock(FileLock):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, lock_file) -&gt;None:</span>
<span class="gi">+    def __init__(self, lock_file) -&gt; None:</span>
<span class="w"> </span>        parent = os.path.dirname(lock_file)
<span class="w"> </span>        if not os.path.isdir(parent):
<span class="w"> </span>            with suppress(OSError):
<span class="w"> </span>                os.makedirs(parent)
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(lock_file)
<span class="w"> </span>        self.count = 0
<span class="w"> </span>        self.thread_safe = RLock()

<span class="gi">+    def acquire(self, timeout=None, poll_interval=0.05):</span>
<span class="gi">+        if not self.thread_safe.acquire(timeout=-1 if timeout is None else timeout):</span>
<span class="gi">+            raise Timeout(self.lock_file)</span>
<span class="gi">+        if self.count == 0:</span>
<span class="gi">+            super().acquire(timeout, poll_interval)</span>
<span class="gi">+        self.count += 1</span>
<span class="gi">+</span>
<span class="gi">+    def release(self, force=False):  # noqa: FBT002</span>
<span class="gi">+        with self.thread_safe:</span>
<span class="gi">+            if self.count &gt; 0:</span>
<span class="gi">+                self.thread_safe.release()</span>
<span class="gi">+            if self.count == 1:</span>
<span class="gi">+                super().release(force=force)</span>
<span class="gi">+            self.count = max(self.count - 1, 0)</span>
<span class="gi">+</span>

<span class="w"> </span>_lock_store = {}
<span class="w"> </span>_store_lock = Lock()


<span class="w"> </span>class PathLockBase(ABC):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, folder) -&gt;None:</span>
<span class="gi">+    def __init__(self, folder) -&gt; None:</span>
<span class="w"> </span>        path = Path(folder)
<span class="w"> </span>        self.path = path.resolve() if path.exists() else path

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}({self.path})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self.path})&quot;</span>

<span class="w"> </span>    def __truediv__(self, other):
<span class="w"> </span>        return type(self)(self.path / other)
<span class="gu">@@ -45,14 +62,37 @@ class PathLockBase(ABC):</span>
<span class="w"> </span>    def __exit__(self, exc_type, exc_val, exc_tb):
<span class="w"> </span>        raise NotImplementedError

<span class="gi">+    @abstractmethod</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def lock_for_key(self, name, no_block=False):  # noqa: FBT002</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-class ReentrantFileLock(PathLockBase):</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def non_reentrant_lock_for_key(self, name):</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def __init__(self, folder) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ReentrantFileLock(PathLockBase):</span>
<span class="gi">+    def __init__(self, folder) -&gt; None:</span>
<span class="w"> </span>        super().__init__(folder)
<span class="w"> </span>        self._lock = None

<span class="gd">-    def __del__(self) -&gt;None:</span>
<span class="gi">+    def _create_lock(self, name=&quot;&quot;):</span>
<span class="gi">+        lock_file = str(self.path / f&quot;{name}.lock&quot;)</span>
<span class="gi">+        with _store_lock:</span>
<span class="gi">+            if lock_file not in _lock_store:</span>
<span class="gi">+                _lock_store[lock_file] = _CountedFileLock(lock_file)</span>
<span class="gi">+            return _lock_store[lock_file]</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _del_lock(lock):</span>
<span class="gi">+        if lock is not None:</span>
<span class="gi">+            with _store_lock, lock.thread_safe:</span>
<span class="gi">+                if lock.count == 0:</span>
<span class="gi">+                    _lock_store.pop(lock.lock_file, None)</span>
<span class="gi">+</span>
<span class="gi">+    def __del__(self) -&gt; None:</span>
<span class="w"> </span>        self._del_lock(self._lock)

<span class="w"> </span>    def __enter__(self):
<span class="gu">@@ -64,14 +104,63 @@ class ReentrantFileLock(PathLockBase):</span>
<span class="w"> </span>        self._del_lock(self._lock)
<span class="w"> </span>        self._lock = None

<span class="gi">+    def _lock_file(self, lock, no_block=False):  # noqa: FBT002</span>
<span class="gi">+        # multiple processes might be trying to get a first lock... so we cannot check if this directory exist without</span>
<span class="gi">+        # a lock, but that lock might then become expensive, and it&#39;s not clear where that lock should live.</span>
<span class="gi">+        # Instead here we just ignore if we fail to create the directory.</span>
<span class="gi">+        with suppress(OSError):</span>
<span class="gi">+            os.makedirs(str(self.path))</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            lock.acquire(0.0001)</span>
<span class="gi">+        except Timeout:</span>
<span class="gi">+            if no_block:</span>
<span class="gi">+                raise</span>
<span class="gi">+            logging.debug(&quot;lock file %s present, will block until released&quot;, lock.lock_file)</span>
<span class="gi">+            lock.release()  # release the acquire try from above</span>
<span class="gi">+            lock.acquire()</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _release(lock):</span>
<span class="gi">+        lock.release()</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def lock_for_key(self, name, no_block=False):  # noqa: FBT002</span>
<span class="gi">+        lock = self._create_lock(name)</span>
<span class="gi">+        try:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._lock_file(lock, no_block)</span>
<span class="gi">+                yield</span>
<span class="gi">+            finally:</span>
<span class="gi">+                self._release(lock)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._del_lock(lock)</span>
<span class="gi">+            lock = None</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def non_reentrant_lock_for_key(self, name):</span>
<span class="gi">+        with _CountedFileLock(str(self.path / f&quot;{name}.lock&quot;)):</span>
<span class="gi">+            yield</span>

<span class="gd">-class NoOpFileLock(PathLockBase):</span>

<span class="gi">+class NoOpFileLock(PathLockBase):</span>
<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        raise NotImplementedError

<span class="w"> </span>    def __exit__(self, exc_type, exc_val, exc_tb):
<span class="w"> </span>        raise NotImplementedError

<span class="gi">+    @contextmanager</span>
<span class="gi">+    def lock_for_key(self, name, no_block=False):  # noqa: ARG002, FBT002</span>
<span class="gi">+        yield</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def non_reentrant_lock_for_key(self, name):  # noqa: ARG002</span>
<span class="gi">+        yield</span>
<span class="gi">+</span>

<span class="gd">-__all__ = [&#39;NoOpFileLock&#39;, &#39;ReentrantFileLock&#39;, &#39;Timeout&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;NoOpFileLock&quot;,</span>
<span class="gi">+    &quot;ReentrantFileLock&quot;,</span>
<span class="gi">+    &quot;Timeout&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/util/path/_permission.py b/src/virtualenv/util/path/_permission.py</span>
<span class="gh">index 880f7f2..8dcad0c 100644</span>
<span class="gd">--- a/src/virtualenv/util/path/_permission.py</span>
<span class="gi">+++ b/src/virtualenv/util/path/_permission.py</span>
<span class="gu">@@ -1,4 +1,30 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from stat import S_IXGRP, S_IXOTH, S_IXUSR
<span class="gd">-__all__ = &#39;make_exe&#39;, &#39;set_tree&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_exe(filename):</span>
<span class="gi">+    original_mode = filename.stat().st_mode</span>
<span class="gi">+    levels = [S_IXUSR, S_IXGRP, S_IXOTH]</span>
<span class="gi">+    for at in range(len(levels), 0, -1):</span>
<span class="gi">+        try:</span>
<span class="gi">+            mode = original_mode</span>
<span class="gi">+            for level in levels[:at]:</span>
<span class="gi">+                mode |= level</span>
<span class="gi">+            filename.chmod(mode)</span>
<span class="gi">+            break</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def set_tree(folder, stat):</span>
<span class="gi">+    for root, _, files in os.walk(str(folder)):</span>
<span class="gi">+        for filename in files:</span>
<span class="gi">+            os.chmod(os.path.join(root, filename), stat)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (</span>
<span class="gi">+    &quot;make_exe&quot;,</span>
<span class="gi">+    &quot;set_tree&quot;,</span>
<span class="gi">+)</span>
<span class="gh">diff --git a/src/virtualenv/util/path/_sync.py b/src/virtualenv/util/path/_sync.py</span>
<span class="gh">index 8daa74c..78684f0 100644</span>
<span class="gd">--- a/src/virtualenv/util/path/_sync.py</span>
<span class="gi">+++ b/src/virtualenv/util/path/_sync.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="w"> </span>import shutil
<span class="gu">@@ -6,17 +7,77 @@ import sys</span>
<span class="w"> </span>from stat import S_IWUSR


<span class="gd">-class _Debug:</span>
<span class="gi">+def ensure_dir(path):</span>
<span class="gi">+    if not path.exists():</span>
<span class="gi">+        logging.debug(&quot;create folder %s&quot;, str(path))</span>
<span class="gi">+        os.makedirs(str(path))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ensure_safe_to_do(src, dest):</span>
<span class="gi">+    if src == dest:</span>
<span class="gi">+        msg = f&quot;source and destination is the same {src}&quot;</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+    if not dest.exists():</span>
<span class="gi">+        return</span>
<span class="gi">+    if dest.is_dir() and not dest.is_symlink():</span>
<span class="gi">+        logging.debug(&quot;remove directory %s&quot;, dest)</span>
<span class="gi">+        safe_delete(dest)</span>
<span class="gi">+    else:</span>
<span class="gi">+        logging.debug(&quot;remove file %s&quot;, dest)</span>
<span class="gi">+        dest.unlink()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def symlink(src, dest):</span>
<span class="gi">+    ensure_safe_to_do(src, dest)</span>
<span class="gi">+    logging.debug(&quot;symlink %s&quot;, _Debug(src, dest))</span>
<span class="gi">+    dest.symlink_to(src, target_is_directory=src.is_dir())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def copy(src, dest):</span>
<span class="gi">+    ensure_safe_to_do(src, dest)</span>
<span class="gi">+    is_dir = src.is_dir()</span>
<span class="gi">+    method = copytree if is_dir else shutil.copy</span>
<span class="gi">+    logging.debug(&quot;copy %s&quot;, _Debug(src, dest))</span>
<span class="gi">+    method(str(src), str(dest))</span>

<span class="gd">-    def __init__(self, src, dest) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def copytree(src, dest):</span>
<span class="gi">+    for root, _, files in os.walk(src):</span>
<span class="gi">+        dest_dir = os.path.join(dest, os.path.relpath(root, src))</span>
<span class="gi">+        if not os.path.isdir(dest_dir):</span>
<span class="gi">+            os.makedirs(dest_dir)</span>
<span class="gi">+        for name in files:</span>
<span class="gi">+            src_f = os.path.join(root, name)</span>
<span class="gi">+            dest_f = os.path.join(dest_dir, name)</span>
<span class="gi">+            shutil.copy(src_f, dest_f)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def safe_delete(dest):</span>
<span class="gi">+    def onerror(func, path, exc_info):  # noqa: ARG001</span>
<span class="gi">+        if not os.access(path, os.W_OK):</span>
<span class="gi">+            os.chmod(path, S_IWUSR)</span>
<span class="gi">+            func(path)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise  # noqa: PLE0704</span>
<span class="gi">+</span>
<span class="gi">+    kwargs = {&quot;onexc&quot; if sys.version_info &gt;= (3, 12) else &quot;onerror&quot;: onerror}</span>
<span class="gi">+    shutil.rmtree(str(dest), ignore_errors=True, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class _Debug:</span>
<span class="gi">+    def __init__(self, src, dest) -&gt; None:</span>
<span class="w"> </span>        self.src = src
<span class="w"> </span>        self.dest = dest

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&quot;{&#39;directory &#39; if self.src.is_dir() else &#39;&#39;}{self.src!s} to {self.dest!s}&quot;</span>
<span class="gd">-            )</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{&#39;directory &#39; if self.src.is_dir() else &#39;&#39;}{self.src!s} to {self.dest!s}&quot;</span>


<span class="gd">-__all__ = [&#39;copy&#39;, &#39;copytree&#39;, &#39;ensure_dir&#39;, &#39;safe_delete&#39;, &#39;symlink&#39;,</span>
<span class="gd">-    &#39;symlink&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;copy&quot;,</span>
<span class="gi">+    &quot;copytree&quot;,</span>
<span class="gi">+    &quot;ensure_dir&quot;,</span>
<span class="gi">+    &quot;safe_delete&quot;,</span>
<span class="gi">+    &quot;symlink&quot;,</span>
<span class="gi">+    &quot;symlink&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/util/path/_win.py b/src/virtualenv/util/path/_win.py</span>
<span class="gh">index e274b39..aa67ca7 100644</span>
<span class="gd">--- a/src/virtualenv/util/path/_win.py</span>
<span class="gi">+++ b/src/virtualenv/util/path/_win.py</span>
<span class="gu">@@ -3,7 +3,21 @@ from __future__ import annotations</span>

<span class="w"> </span>def get_short_path_name(long_name):
<span class="w"> </span>    &quot;&quot;&quot;Gets the short path name of a given long path - http://stackoverflow.com/a/23598461/200291.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import ctypes  # noqa: PLC0415</span>
<span class="gi">+    from ctypes import wintypes  # noqa: PLC0415</span>

<span class="gi">+    _GetShortPathNameW = ctypes.windll.kernel32.GetShortPathNameW  # noqa: N806</span>
<span class="gi">+    _GetShortPathNameW.argtypes = [wintypes.LPCWSTR, wintypes.LPWSTR, wintypes.DWORD]</span>
<span class="gi">+    _GetShortPathNameW.restype = wintypes.DWORD</span>
<span class="gi">+    output_buf_size = 0</span>
<span class="gi">+    while True:</span>
<span class="gi">+        output_buf = ctypes.create_unicode_buffer(output_buf_size)</span>
<span class="gi">+        needed = _GetShortPathNameW(long_name, output_buf, output_buf_size)</span>
<span class="gi">+        if output_buf_size &gt;= needed:</span>
<span class="gi">+            return output_buf.value</span>
<span class="gi">+        output_buf_size = needed</span>

<span class="gd">-__all__ = [&#39;get_short_path_name&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;get_short_path_name&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/virtualenv/util/zipapp.py b/src/virtualenv/util/zipapp.py</span>
<span class="gh">index a51e799..958db15 100644</span>
<span class="gd">--- a/src/virtualenv/util/zipapp.py</span>
<span class="gi">+++ b/src/virtualenv/util/zipapp.py</span>
<span class="gu">@@ -1,6 +1,41 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="w"> </span>import zipfile
<span class="gi">+</span>
<span class="w"> </span>from virtualenv.info import IS_WIN, ROOT
<span class="gd">-__all__ = [&#39;extract&#39;, &#39;read&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def read(full_path):</span>
<span class="gi">+    sub_file = _get_path_within_zip(full_path)</span>
<span class="gi">+    with zipfile.ZipFile(ROOT, &quot;r&quot;) as zip_file, zip_file.open(sub_file) as file_handler:</span>
<span class="gi">+        return file_handler.read().decode(&quot;utf-8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def extract(full_path, dest):</span>
<span class="gi">+    logging.debug(&quot;extract %s to %s&quot;, full_path, dest)</span>
<span class="gi">+    sub_file = _get_path_within_zip(full_path)</span>
<span class="gi">+    with zipfile.ZipFile(ROOT, &quot;r&quot;) as zip_file:</span>
<span class="gi">+        info = zip_file.getinfo(sub_file)</span>
<span class="gi">+        info.filename = dest.name</span>
<span class="gi">+        zip_file.extract(info, str(dest.parent))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_path_within_zip(full_path):</span>
<span class="gi">+    full_path = os.path.realpath(os.path.abspath(str(full_path)))</span>
<span class="gi">+    prefix = f&quot;{ROOT}{os.sep}&quot;</span>
<span class="gi">+    if not full_path.startswith(prefix):</span>
<span class="gi">+        msg = f&quot;full_path={full_path} should start with prefix={prefix}.&quot;</span>
<span class="gi">+        raise RuntimeError(msg)</span>
<span class="gi">+    sub_file = full_path[len(prefix) :]</span>
<span class="gi">+    if IS_WIN:</span>
<span class="gi">+        # paths are always UNIX separators, even on Windows, though __file__ still follows platform default</span>
<span class="gi">+        sub_file = sub_file.replace(os.sep, &quot;/&quot;)</span>
<span class="gi">+    return sub_file</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;extract&quot;,</span>
<span class="gi">+    &quot;read&quot;,</span>
<span class="gi">+]</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>