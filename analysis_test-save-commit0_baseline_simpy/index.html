
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis test save commit0 baseline simpy - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-base-baseline" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis test save commit0 baseline simpy
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_and" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_and
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_and_blocked" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_and_blocked
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_or" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_or
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_nested_and" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_nested_and
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_nested_or" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_nested_or
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_nested_cond_with_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_nested_cond_with_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_cond_with_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_cond_with_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_cond_with_nested_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_cond_with_nested_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_cond_with_uncaught_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_cond_with_uncaught_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_iand_with_and_cond" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_iand_with_and_cond
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_iand_with_or_cond" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_iand_with_or_cond
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_ior_with_or_cond" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_ior_with_or_cond
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_ior_with_and_cond" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_ior_with_and_cond
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_immutable_results" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_immutable_results
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_shared_and_condition" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_shared_and_condition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_shared_or_condition" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_shared_or_condition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_condition_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_condition_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_result_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_result_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_nested_result_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_nested_result_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_event_queue_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_event_queue_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_negative_until" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_negative_until
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_resume" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_resume
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_until_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_until_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_with_processed_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_with_processed_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_with_untriggered_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_with_untriggered_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_succeed" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_succeed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_fail" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_fail
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_unavailable_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_unavailable_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_triggered" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_triggered
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_condition_callback_removal" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_condition_callback_removal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_condition_nested_callback_removal" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_condition_nested_callback_removal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_error_forwarding" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_error_forwarding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_no_parent_process" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_no_parent_process
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_crashing_child_traceback" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_crashing_child_traceback
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_exception_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_exception_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_invalid_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_invalid_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_exception_handling" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_exception_handling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_callback_exception_handling" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_callback_exception_handling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_process_exception_handling" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_process_exception_handling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_process_exception_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_process_exception_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_sys_excepthook" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_sys_excepthook
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interruption" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interruption
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_concurrent_interrupts" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_concurrent_interrupts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_concurrent_interrupts_and_events" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_concurrent_interrupts_and_events
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_init_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_init_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interrupt_terminated_process" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interrupt_terminated_process
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_multiple_interrupts" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_multiple_interrupts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interrupt_self" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interrupt_self
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_immediate_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_immediate_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interrupt_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interrupt_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_concurrent_behaviour" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_concurrent_behaviour
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_get_state" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_get_state
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_target" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_target
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_wait_for_proc" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_wait_for_proc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_return_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_return_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_child_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_child_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_interrupted_join" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_interrupted_join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_interrupted_join_and_rejoin" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_interrupted_join_and_rejoin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_context_manager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_slots" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_slots
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_continue_after_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_continue_after_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_release_after_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_release_after_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_immediate_requests" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_immediate_requests
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_cm_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_cm_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_with_condition" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_with_condition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_with_priority_queue" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_with_priority_queue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_sorted_queue_maxlen" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_sorted_queue_maxlen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_get_users" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_get_users
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_preemptive_resource" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_preemptive_resource
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_preemptive_resource_timeout_0" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_preemptive_resource_timeout_0
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_mixed_preemption" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_mixed_preemption
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_nested_preemption" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_nested_preemption
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_container" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_container
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_container_get_queued" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_container_get_queued
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_store" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_store
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_store_capacity" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_store_capacity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_store_cancel" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_store_cancel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_priority_store_item_priority" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_priority_store_item_priority
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_priority_store_stable_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_priority_store_stable_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_store" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_store
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_store_get_after_mismatch" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_store_get_after_mismatch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_calls_best_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_calls_best_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_calls_worst_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_calls_worst_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_immediate_put_request" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_immediate_put_request
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_immediate_get_request" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_immediate_get_request
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt01" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt[0.1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt005" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt[0.05]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt015" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt[0.15]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_multiple_call" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_multiple_call
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_slow_sim_default_behavior" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_slow_sim_default_behavior
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_slow_sim_no_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_slow_sim_no_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_illegal_until" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_illegal_until
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_sync" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_sync
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_run_with_untriggered_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_run_with_untriggered_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_discrete_time_steps" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_discrete_time_steps
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_negative_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_negative_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_timeout_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_timeout_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_shared_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_shared_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_triggered_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_triggered_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_start_delayed" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_start_delayed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_terminated_proc" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_terminated_proc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_with_join" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_with_join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_at_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_at_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_at_timeout_with_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_at_timeout_with_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_generator" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_generator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_wait_for_all_with_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_wait_for_all_with_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_chaining_intermediate_results" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_chaining_intermediate_results
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_with_triggered_events" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_with_triggered_events
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of_with_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of_with_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of_with_triggered_events" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of_with_triggered_events
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_empty_any_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_empty_any_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_empty_all_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_empty_all_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_expansion" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_expansion
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_test-save-commit0_baseline">back to Claude Sonnet 3.5 - Base summary</a></p>
<h1 id="claude-sonnet-35-base-baseline"><strong>Claude Sonnet 3.5 - Base</strong>: baseline</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">120</td>
</tr>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">20</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">140</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">150</td>
</tr>
<tr>
<td style="text-align: left;">deselected</td>
<td style="text-align: center;">10</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_conditionpytest_operator_and">test_condition.py::test_operator_and</h3>
<details><summary> <pre>test_condition.py::test_operator_and</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0762ec0d0>

    def test_operator_and(env):
        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            results = yield timeout[0] & timeout[1] & timeout[2]

            assert results == {
                timeout[0]: 0,
                timeout[1]: 1,
                timeout[2]: 2,
            }

        env.process(process(env))
>       env.run()

tests/test_condition.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0762ec0d0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_operator_and_blocked">test_condition.py::test_operator_and_blocked</h3>
<details><summary> <pre>test_condition.py::test_operator_and_blocked</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0765a8e80>

    def test_operator_and_blocked(env):
        def process(env):
            timeout = env.timeout(1)
            event = env.event()
            yield env.timeout(1)

            condition = timeout & event
            assert not condition.triggered

        env.process(process(env))
>       env.run()

tests/test_condition.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0765a8e80>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_operator_or">test_condition.py::test_operator_or</h3>
<details><summary> <pre>test_condition.py::test_operator_or</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0775299f0>

    def test_operator_or(env):
        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            results = yield timeout[0] | timeout[1] | timeout[2]

            assert results == {
                timeout[0]: 0,
            }

        env.process(process(env))
>       env.run()

tests/test_condition.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0775299f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_operator_nested_and">test_condition.py::test_operator_nested_and</h3>
<details><summary> <pre>test_condition.py::test_operator_nested_and</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0772ae740>

    def test_operator_nested_and(env):
        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            results = yield (timeout[0] & timeout[2]) | timeout[1]

            assert results == {
                timeout[0]: 0,
                timeout[1]: 1,
            }
            assert env.now == 1

        env.process(process(env))
>       env.run()

tests/test_condition.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0772ae740>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_operator_nested_or">test_condition.py::test_operator_nested_or</h3>
<details><summary> <pre>test_condition.py::test_operator_nested_or</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0775f2f80>

    def test_operator_nested_or(env):
        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            results = yield (timeout[0] | timeout[1]) & timeout[2]

            assert results == {
                timeout[0]: 0,
                timeout[1]: 1,
                timeout[2]: 2,
            }
            assert env.now == 2

        env.process(process(env))
>       env.run()

tests/test_condition.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0775f2f80>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_nested_cond_with_error">test_condition.py::test_nested_cond_with_error</h3>
<details><summary> <pre>test_condition.py::test_nested_cond_with_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07702eef0>

    def test_nested_cond_with_error(env):
        def explode(env):
            yield env.timeout(1)
            raise ValueError('Onoes!')

        def process(env):
            with pytest.raises(ValueError, match='Onoes!'):
                yield env.process(explode(env)) & env.timeout(1)

        env.process(process(env))
>       env.run()

tests/test_condition.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07702eef0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_cond_with_error">test_condition.py::test_cond_with_error</h3>
<details><summary> <pre>test_condition.py::test_cond_with_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07760a350>

    def test_cond_with_error(env):
        def explode(env, delay):
            yield env.timeout(delay)
            raise ValueError(f'Onoes, failed after {delay}!')

        def process(env):
            with pytest.raises(ValueError, match='Onoes, failed after 0!'):
                yield env.process(explode(env, 0)) | env.timeout(1)

        env.process(process(env))
>       env.run()

tests/test_condition.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07760a350>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_cond_with_nested_error">test_condition.py::test_cond_with_nested_error</h3>
<details><summary> <pre>test_condition.py::test_cond_with_nested_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076f01690>

    def test_cond_with_nested_error(env):
        def explode(env, delay):
            yield env.timeout(delay)
            raise ValueError(f'Onoes, failed after {delay}!')

        def process(env):
            with pytest.raises(ValueError, match='Onoes, failed after 0!'):
                yield env.process(explode(env, 0)) & env.timeout(1) | env.timeout(1)

        env.process(process(env))
>       env.run()

tests/test_condition.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076f01690>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_cond_with_uncaught_error">test_condition.py::test_cond_with_uncaught_error</h3>
<details><summary> <pre>test_condition.py::test_cond_with_uncaught_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe077862260>

    def test_cond_with_uncaught_error(env):
        """Errors that happen after the condition has been triggered will not be
        handled by the condition and cause the simulation to crash."""

        def explode(env, delay):
            yield env.timeout(delay)
            raise ValueError(f'Onoes, failed after {delay}!')

        def process(env):
            yield env.timeout(1) | env.process(explode(env, 2))

        env.process(process(env))
        with pytest.raises(ValueError, match='Onoes, failed after'):
>           env.run()

tests/test_condition.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe077862260>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_iand_with_and_cond">test_condition.py::test_iand_with_and_cond</h3>
<details><summary> <pre>test_condition.py::test_iand_with_and_cond</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0772ac3a0>

    def test_iand_with_and_cond(env):
        def process(env):
            cond = env.timeout(1, value=1) & env.timeout(2, value=2)
            orig = cond

            cond &= env.timeout(0, value=0)
            assert cond is not orig

            results = yield cond
            assert list(results.values()) == [1, 2, 0]

        env.process(process(env))
>       env.run()

tests/test_condition.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0772ac3a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_iand_with_or_cond">test_condition.py::test_iand_with_or_cond</h3>
<details><summary> <pre>test_condition.py::test_iand_with_or_cond</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07647a920>

    def test_iand_with_or_cond(env):
        def process(env):
            cond = env.timeout(1, value=1) | env.timeout(2, value=2)
            orig = cond

            cond &= env.timeout(0, value=0)
            assert cond is not orig

            results = yield cond
            assert list(results.values()) == [1, 0]

        env.process(process(env))
>       env.run()

tests/test_condition.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07647a920>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_ior_with_or_cond">test_condition.py::test_ior_with_or_cond</h3>
<details><summary> <pre>test_condition.py::test_ior_with_or_cond</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076e85ab0>

    def test_ior_with_or_cond(env):
        def process(env):
            cond = env.timeout(1, value=1) | env.timeout(2, value=2)
            orig = cond

            cond |= env.timeout(0, value=0)
            assert cond is not orig

            results = yield cond
            assert list(results.values()) == [0]

        env.process(process(env))
>       env.run()

tests/test_condition.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076e85ab0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_ior_with_and_cond">test_condition.py::test_ior_with_and_cond</h3>
<details><summary> <pre>test_condition.py::test_ior_with_and_cond</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0772f1990>

    def test_ior_with_and_cond(env):
        def process(env):
            cond = env.timeout(1, value=1) & env.timeout(2, value=2)
            orig = cond

            cond |= env.timeout(0, value=0)
            assert cond is not orig

            results = yield cond
            assert list(results.values()) == [0]

        env.process(process(env))
>       env.run()

tests/test_condition.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0772f1990>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_immutable_results">test_condition.py::test_immutable_results</h3>
<details><summary> <pre>test_condition.py::test_immutable_results</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0776bac80>

    def test_immutable_results(env):
        """Results of conditions should not change after they have been
        triggered."""

        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            # The or condition in this expression will trigger immediately. The and
            # condition will trigger later on.
            condition = timeout[0] | (timeout[1] & timeout[2])

            results = yield condition
            assert results == {timeout[0]: 0}

            # Make sure that the results of condition were frozen. The results of
            # the nested and condition do not become visible afterwards.
            yield env.timeout(2)
            assert results == {timeout[0]: 0}

        env.process(process(env))
>       env.run()

tests/test_condition.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0776bac80>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_shared_and_condition">test_condition.py::test_shared_and_condition</h3>
<details><summary> <pre>test_condition.py::test_shared_and_condition</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076e68f70>

    def test_shared_and_condition(env):
        timeout = [env.timeout(delay, value=delay) for delay in range(3)]
        c1 = timeout[0] & timeout[1]
        c2 = c1 & timeout[2]

        def p1(_, condition):
            results = yield condition
            assert results == {timeout[0]: 0, timeout[1]: 1}

        def p2(_, condition):
            results = yield condition
            assert results == {timeout[0]: 0, timeout[1]: 1, timeout[2]: 2}

        env.process(p1(env, c1))
        env.process(p2(env, c2))
>       env.run()

tests/test_condition.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076e68f70>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_shared_or_condition">test_condition.py::test_shared_or_condition</h3>
<details><summary> <pre>test_condition.py::test_shared_or_condition</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0775f0c70>

    def test_shared_or_condition(env):
        timeout = [env.timeout(delay, value=delay) for delay in range(3)]
        c1 = timeout[0] | timeout[1]
        c2 = c1 | timeout[2]

        def p1(_, condition):
            results = yield condition
            assert results == {timeout[0]: 0}

        def p2(_, condition):
            results = yield condition
            assert results == {timeout[0]: 0}

        env.process(p1(env, c1))
        env.process(p2(env, c2))
>       env.run()

tests/test_condition.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0775f0c70>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_condition_value">test_condition.py::test_condition_value</h3>
<details><summary> <pre>test_condition.py::test_condition_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0765f14b0>

    def test_condition_value(env):
        """The value of a condition behaves like a readonly dictionary."""
        timeouts = [env.timeout(delay, value=delay) for delay in range(3)]

        def p(env, timeouts):
            results = yield env.all_of(timeouts)
            assert list(results) == timeouts
            assert list(results.keys()) == timeouts
            assert list(results.values()) == [0, 1, 2]
            assert list(results.items()) == list(zip(timeouts, [0, 1, 2]))
            assert timeouts[0] in results
            assert results[timeouts[0]] == 0
            assert results == results  # noqa: PLR0124
            assert results == results.todict()

        env.process(p(env, timeouts))
>       env.run()

tests/test_condition.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0765f14b0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_result_order">test_condition.py::test_result_order</h3>
<details><summary> <pre>test_condition.py::test_result_order</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076efcb80>

    def test_result_order(env):
        """The order of a conditions result is based on the order in which the
        events have been specified."""
        timeouts = list(reversed([env.timeout(delay) for delay in range(3)]))

        def p(env, timeouts):
            results = yield env.all_of(timeouts)
            assert list(results.keys()) == timeouts

        env.process(p(env, timeouts))
>       env.run()

tests/test_condition.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076efcb80>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_nested_result_order">test_condition.py::test_nested_result_order</h3>
<details><summary> <pre>test_condition.py::test_nested_result_order</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe077527430>

    def test_nested_result_order(env):
        """The order of a conditions result is based on the order in which the
        events have been specified (even if nested)."""
        timeouts = [env.timeout(delay) for delay in range(3)]
        condition = (timeouts[0] | timeouts[1]) & timeouts[2]

        def p(_, timeouts):
            results = yield condition
            assert list(results.keys()) == timeouts

        env.process(p(env, timeouts))
>       env.run()

tests/test_condition.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe077527430>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_environmentpytest_event_queue_empty">test_environment.py::test_event_queue_empty</h3>
<details><summary> <pre>test_environment.py::test_event_queue_empty</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07752b9d0>, log = []

    def test_event_queue_empty(env, log):
        """The simulation should stop if there are no more events, that means, no
        more active process."""

        def pem(env, log):
            while env.now < 2:
                log.append(env.now)
                yield env.timeout(1)

        env.process(pem(env, log))
>       env.run(10)

tests/test_environment.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07752b9d0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_environmentpytest_run_negative_until">test_environment.py::test_run_negative_until</h3>
<details><summary> <pre>test_environment.py::test_run_negative_until</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0763e6110>

    def test_run_negative_until(env):
        """Test passing a negative time to run."""
>       with pytest.raises(
            ValueError, match='must be greater than the current simulation time'
        ):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/test_environment.py:26: Failed
</pre>
</details>
<h3 id="test_environmentpytest_run_resume">test_environment.py::test_run_resume</h3>
<details><summary> <pre>test_environment.py::test_run_resume</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0776bac20>

    def test_run_resume(env):
        """Stopped simulation can be resumed."""
        events = [env.timeout(t) for t in (5, 10, 15)]

        assert env.now == 0
        assert not any(event.processed for event in events)

>       env.run(until=10)

tests/test_environment.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0776bac20>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Timeout' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_environmentpytest_run_until_value">test_environment.py::test_run_until_value</h3>
<details><summary> <pre>test_environment.py::test_run_until_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0772b1810>

    def test_run_until_value(env):
        """Anything that can be converted to a float is a valid until value."""
>       env.run(until='3.141592')

tests/test_environment.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0772b1810>, until = '3.141592'

    def run(self, until: Optional[Union[SimTime, Event]]=None) ->Optional[Any]:
        """Executes :meth:`step()` until the given criterion *until* is met.

        - If it is ``None`` (which is the default), this method will return
          when there are no further events to be processed.

        - If it is an :class:`~simpy.events.Event`, the method will continue
          stepping until this event has been triggered and will return its
          value.  Raises a :exc:`RuntimeError` if there are no further events
          to be processed and the *until* event was not triggered.

        - If it is a number, the method will continue stepping
          until the environment's time reaches *until*.

        """
        if until is None:
            while True:
                try:
                    self.step()
                except EmptySchedule:
                    return None
        elif isinstance(until, Event):
            until.callbacks.append(StopSimulation.callback)
            try:
                while not until.triggered:
                    self.step()
            except StopSimulation:
                return until.value
            except EmptySchedule:
                if not until.triggered:
                    raise RuntimeError('No scheduled events left but "until" event was not triggered')
        elif isinstance(until, (int, float)):
            try:
                while self._now < until:
                    self.step()
            except EmptySchedule:
                return None
        else:
>           raise ValueError('Invalid until parameter type')
E           ValueError: Invalid until parameter type

src/simpy/core.py:196: ValueError
</pre>
</details>
<h3 id="test_environmentpytest_run_with_processed_event">test_environment.py::test_run_with_processed_event</h3>
<details><summary> <pre>test_environment.py::test_run_with_processed_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe077862110>

    def test_run_with_processed_event(env):
        """An already processed event may also be passed as until value."""
        timeout = env.timeout(1, value='spam')
>       assert env.run(until=timeout) == 'spam'
E       AssertionError: assert None == 'spam'
E        +  where None = run(until=<Timeout(1, value='spam') object at 0x7fe077862980>)
E        +    where run = <simpy.core.Environment object at 0x7fe077862110>.run

tests/test_environment.py:63: AssertionError
</pre>
</details>
<h3 id="test_environmentpytest_run_with_untriggered_event">test_environment.py::test_run_with_untriggered_event</h3>
<details><summary> <pre>test_environment.py::test_run_with_untriggered_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076e84130>

    def test_run_with_untriggered_event(env):
        excinfo = pytest.raises(RuntimeError, env.run, until=env.event())
>       assert str(excinfo.value).startswith(
            'No scheduled events left but "until" event was not triggered:'
        )
E       assert False
E        +  where False = <built-in method startswith of str object at 0x7fe0765b7de0>('No scheduled events left but "until" event was not triggered:')
E        +    where <built-in method startswith of str object at 0x7fe0765b7de0> = 'No scheduled events left but "until" event was not triggered'.startswith
E        +      where 'No scheduled events left but "until" event was not triggered' = str(RuntimeError('No scheduled events left but "until" event was not triggered'))
E        +        where RuntimeError('No scheduled events left but "until" event was not triggered') = <ExceptionInfo RuntimeError('No scheduled events left but "until" event was not triggered') tblen=2>.value

tests/test_environment.py:75: AssertionError
</pre>
</details>
<h3 id="test_eventpytest_succeed">test_event.py::test_succeed</h3>
<details><summary> <pre>test_event.py::test_succeed</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe077860c40>

    def test_succeed(env):
        """Test for the Environment.event() helper function."""

        def child(env, event):
            value = yield event
            assert value == 'ohai'
            assert env.now == 5

        def parent(env):
            event = env.event()
            env.process(child(env, event))
            yield env.timeout(5)
            event.succeed('ohai')

        env.process(parent(env))
>       env.run()

tests/test_event.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe077860c40>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_fail">test_event.py::test_fail</h3>
<details><summary> <pre>test_event.py::test_fail</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07647a560>

    def test_fail(env):
        """Test for the Environment.event() helper function."""

        def child(env, event):
            with pytest.raises(ValueError, match='ohai'):
                yield event
            assert env.now == 5

        def parent(env):
            event = env.event()
            env.process(child(env, event))
            yield env.timeout(5)
            event.fail(ValueError('ohai'))

        env.process(parent(env))
>       env.run()

tests/test_event.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07647a560>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_value">test_event.py::test_value</h3>
<details><summary> <pre>test_event.py::test_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07702ebf0>

    def test_value(env):
        """After an event has been triggered, its value becomes accessible."""
        event = env.timeout(0, 'I am the value')

>       env.run()

tests/test_event.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07702ebf0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Timeout' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_unavailable_value">test_event.py::test_unavailable_value</h3>
<details><summary> <pre>test_event.py::test_unavailable_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe077079ed0>

    def test_unavailable_value(env):
        """If an event has not yet been triggered, its value is not available and
        trying to access it will result in a AttributeError."""
        event = env.event()

        with pytest.raises(AttributeError, match='.* is not yet available$'):
>           _ = event.value

tests/test_event.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Event() object at 0x7fe077078760>

    @property
    def value(self) ->Optional[Any]:
        """The value of the event if it is available.

        The value is available when the event has been triggered.

        Raises :exc:`AttributeError` if the value is not yet available.

        """
        if self._value is PENDING:
>           raise AttributeError('Value not yet available')
E           AttributeError: Value not yet available. Did you mean: '_value'?

src/simpy/events.py:132: AttributeError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7fe077079ed0>

    def test_unavailable_value(env):
        """If an event has not yet been triggered, its value is not available and
        trying to access it will result in a AttributeError."""
        event = env.event()

>       with pytest.raises(AttributeError, match='.* is not yet available$'):
E       AssertionError: Regex pattern did not match.
E        Regex: '.* is not yet available$'
E        Input: 'Value not yet available'

tests/test_event.py:82: AssertionError
</pre>
</details>
<h3 id="test_eventpytest_triggered">test_event.py::test_triggered</h3>
<details><summary> <pre>test_event.py::test_triggered</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe077524fd0>

    def test_triggered(env):
        def pem(env, event):
            value = yield event
            return value

        event = env.event()
        event.succeed('i was already done')

>       result = env.run(env.process(pem(env, event)))

tests/test_event.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe077524fd0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_condition_callback_removal">test_event.py::test_condition_callback_removal</h3>
<details><summary> <pre>test_event.py::test_condition_callback_removal</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07752aa40>

    def test_condition_callback_removal(env):
        """A condition will remove all outstanding callbacks from its events."""
        a, b = env.event(), env.event()
        a.succeed()
>       env.run(until=a | b)

tests/test_event.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07752aa40>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_condition_nested_callback_removal">test_event.py::test_condition_nested_callback_removal</h3>
<details><summary> <pre>test_event.py::test_condition_nested_callback_removal</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076e86290>

    def test_condition_nested_callback_removal(env):
        """A condition will remove all outstanding callbacks from its events (even
        if nested)."""
        a, b, c = env.event(), env.event(), env.event()
        b_and_c = b & c
        a_or_b_and_c = a | b_and_c
        a.succeed()
>       env.run(until=a_or_b_and_c)

tests/test_event.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076e86290>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_error_forwarding">test_exceptions.py::test_error_forwarding</h3>
<details><summary> <pre>test_exceptions.py::test_error_forwarding</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076fa3700>

    def test_error_forwarding(env):
        """Exceptions are forwarded from child to parent processes if there
        are any.

        """

        def child(env):
            raise ValueError('Onoes!')
            yield env.timeout(1)

        def parent(env):
            with pytest.raises(ValueError, match='Onoes!'):
                yield env.process(child(env))

        env.process(parent(env))
>       env.run()

tests/test_exceptions.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076fa3700>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_no_parent_process">test_exceptions.py::test_no_parent_process</h3>
<details><summary> <pre>test_exceptions.py::test_no_parent_process</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0772b2590>

    def test_no_parent_process(env):
        """Exceptions should be normally raised if there are no processes waiting
        for the one that raises something.

        """

        def child(env):
            raise ValueError('Onoes!')
            yield env.timeout(1)

        def parent(env):
            try:
                env.process(child(env))
                yield env.timeout(1)
            except Exception as err:
                pytest.fail(f'There should be no error ({err}).')

        env.process(parent(env))
        with pytest.raises(ValueError, match='Onoes!'):
>           env.run()

tests/test_exceptions.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0772b2590>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_crashing_child_traceback">test_exceptions.py::test_crashing_child_traceback</h3>
<details><summary> <pre>test_exceptions.py::test_crashing_child_traceback</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07752a740>

    def test_crashing_child_traceback(env):
        def panic(env):
            yield env.timeout(1)
            raise RuntimeError('Oh noes, roflcopter incoming... BOOM!')

        def root(env):
            try:
                yield env.process(panic(env))
                pytest.fail("Hey, where's the roflcopter?")
            except RuntimeError:
                # The current frame must be visible in the stacktrace.
                stacktrace = traceback.format_exc()
                assert 'yield env.process(panic(env))' in stacktrace
                assert "raise RuntimeError('Oh noes," in stacktrace

        env.process(root(env))
>       env.run()

tests/test_exceptions.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07752a740>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_exception_chaining">test_exceptions.py::test_exception_chaining</h3>
<details><summary> <pre>test_exceptions.py::test_exception_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076e85ab0>

    def test_exception_chaining(env):
        """Unhandled exceptions pass through the entire event stack. This must be
        visible in the stacktrace of the exception.

        """

        def child(env):
            yield env.timeout(1)
            raise RuntimeError('foo')

        def parent(env):
            child_proc = env.process(child(env))
            yield child_proc

        def grandparent(env):
            parent_proc = env.process(parent(env))
            yield parent_proc

        env.process(grandparent(env))
        try:
>           env.run()

tests/test_exceptions.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076e85ab0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_invalid_event">test_exceptions.py::test_invalid_event</h3>
<details><summary> <pre>test_exceptions.py::test_invalid_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07647a9e0>

    def test_invalid_event(env):
        """Invalid yield values will cause the simulation to fail."""

        def root(_):
            yield None

        env.process(root(env))
        with pytest.raises(RuntimeError, match='Invalid yield value "None"'):
>           env.run()

tests/test_exceptions.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07647a9e0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_exception_handling">test_exceptions.py::test_exception_handling</h3>
<details><summary> <pre>test_exceptions.py::test_exception_handling</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07702d0c0>

    def test_exception_handling(env):
        """If failed events are not defused (which is the default) the simulation
        crashes."""

        event = env.event()
        event.fail(RuntimeError())
        with pytest.raises(RuntimeError):
>           env.run(until=1)

tests/test_exceptions.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07702d0c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_callback_exception_handling">test_exceptions.py::test_callback_exception_handling</h3>
<details><summary> <pre>test_exceptions.py::test_callback_exception_handling</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076e0d4b0>

    def test_callback_exception_handling(env):
        """Callbacks of events may handle exception by setting the ``defused``
        attribute of ``event`` to ``True``."""

        def callback(event):
            event.defused = True

        event = env.event()
        event.callbacks.append(callback)
        event.fail(RuntimeError())
        assert not event.defused, 'Event has been defused immediately'
>       env.run(until=1)

tests/test_exceptions.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076e0d4b0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_process_exception_handling">test_exceptions.py::test_process_exception_handling</h3>
<details><summary> <pre>test_exceptions.py::test_process_exception_handling</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0776ba950>

    def test_process_exception_handling(env):
        """Processes can't ignore failed events and auto-handle exceptions."""

        def pem(_, event):
            try:
                yield event
                pytest.fail('Hey, the event should fail!')
            except RuntimeError:
                pass

        event = env.event()
        env.process(pem(env, event))
        event.fail(RuntimeError())

        assert not event.defused, 'Event has been defused immediately'
>       env.run(until=1)

tests/test_exceptions.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0776ba950>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_process_exception_chaining">test_exceptions.py::test_process_exception_chaining</h3>
<details><summary> <pre>test_exceptions.py::test_process_exception_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe077582f50>

    def test_process_exception_chaining(env):
        """Because multiple processes can be waiting for an event, exceptions of
        failed events are copied before being thrown into a process. Otherwise, the
        traceback of the exception gets modified by a process.

        See https://bitbucket.org/simpy/simpy/issue/60 for more details."""
        import traceback

        def process_a(event):
            try:
                yield event
            except RuntimeError:
                stacktrace = traceback.format_exc()
                assert 'process_b' not in stacktrace

        def process_b(event):
            try:
                yield event
            except RuntimeError:
                stacktrace = traceback.format_exc()
                assert 'process_a' not in stacktrace

        event = env.event()
        event.fail(RuntimeError('foo'))

        env.process(process_a(event))
        env.process(process_b(event))

>       env.run()

tests/test_exceptions.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe077582f50>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_sys_excepthook">test_exceptions.py::test_sys_excepthook</h3>
<details><summary> <pre>test_exceptions.py::test_sys_excepthook</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076e85210>

    def test_sys_excepthook(env):
        """Check that the default exception hook reports exception chains."""

        def process_a(event):
            yield event

        def process_b(event):
            yield event

        event = env.event()
        event.fail(RuntimeError('foo'))

        env.process(process_b(env.process(process_a(event))))

        try:
>           env.run()

tests/test_exceptions.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076e85210>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7fe076e85210>

    def test_sys_excepthook(env):
        """Check that the default exception hook reports exception chains."""

        def process_a(event):
            yield event

        def process_b(event):
            yield event

        event = env.event()
        event.fail(RuntimeError('foo'))

        env.process(process_b(env.process(process_a(event))))

        try:
            env.run()
        except BaseException:
            # Let the default exception hook print the traceback to the redirected
            # standard error channel.
            import sys
            from io import StringIO

            stderr, sys.stderr = sys.stderr, StringIO()

            typ, e, tb = sys.exc_info()
            assert typ is not None
            assert e is not None
            sys.excepthook(typ, e, tb)

            traceback = sys.stderr.getvalue()

            sys.stderr = stderr

            # Check if frames of process_a and process_b are visible in the
            # traceback.
>           assert 'process_a' in traceback
E           assert 'process_a' in 'Traceback (most recent call last):\n  File "/testbed/tests/test_exceptions.py", line 244, in test_sys_excepthook\n   ..._callback(event)\nAttributeError: \'Initialize\' object has no attribute \'_callback\'. Did you mean: \'callbacks\'?\n'

tests/test_exceptions.py:264: AssertionError
</pre>
</details>
<h3 id="test_interruptspytest_interruption">test_interrupts.py::test_interruption</h3>
<details><summary> <pre>test_interrupts.py::test_interruption</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0776ba500>

    def test_interruption(env):
        """Processes can be interrupted while waiting for other events."""

        def interruptee(env):
            with pytest.raises(simpy.Interrupt, match='interrupt!'):
                yield env.timeout(10)

        def interruptor(env):
            child_process = env.process(interruptee(env))
            yield env.timeout(5)
            child_process.interrupt('interrupt!')

        env.process(interruptor(env))
>       env.run()

tests/test_interrupts.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0776ba500>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_concurrent_interrupts">test_interrupts.py::test_concurrent_interrupts</h3>
<details><summary> <pre>test_interrupts.py::test_concurrent_interrupts</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe077079990>, log = []

    def test_concurrent_interrupts(env, log):
        """Concurrent interrupts are scheduled in the order in which they
        occurred.

        """

        def fox(env, log):
            while True:
                try:
                    yield env.timeout(10)
                except simpy.Interrupt as interrupt:
                    log.append((env.now, interrupt.cause))

        def farmer(env, name, fox):
            fox.interrupt(name)
            yield env.timeout(1)

        fantastic_mr_fox = env.process(fox(env, log))
        for name in ('boggis', 'bunce', 'beans'):
            env.process(farmer(env, name, fantastic_mr_fox))

>       env.run(20)

tests/test_interrupts.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe077079990>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_concurrent_interrupts_and_events">test_interrupts.py::test_concurrent_interrupts_and_events</h3>
<details><summary> <pre>test_interrupts.py::test_concurrent_interrupts_and_events</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0763e4a60>, log = []

    def test_concurrent_interrupts_and_events(env, log):
        """Interrupts interrupt a process while waiting for an event. Even if the
        event has happened concurrently with the interrupt."""

        def fox(env, coup, log):
            while True:
                try:
                    yield coup
                    log.append(f'coup completed at {env.now}')
                except simpy.Interrupt:
                    log.append(f'coup interrupted at {env.now}')
                else:
                    return

        def master_plan(env, fox, coup):
            yield env.timeout(1)
            # Succeed and interrupt concurrently.
            coup.succeed()
            fox.interrupt()

        coup = env.event()
        fantastic_mr_fox = env.process(fox(env, coup, log))
        env.process(master_plan(env, fantastic_mr_fox, coup))

>       env.run(5)

tests/test_interrupts.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0763e4a60>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_init_interrupt">test_interrupts.py::test_init_interrupt</h3>
<details><summary> <pre>test_interrupts.py::test_init_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0776ba7a0>

    def test_init_interrupt(env):
        """An interrupt should always be executed after the Initialize event at the
        same time."""

        def child(env):
            try:
                yield env.timeout(10)
                pytest.fail('Should have been interrupted.')
            except simpy.Interrupt:
                assert env.now == 0

        def root(env):
            child_proc = env.process(child(env))
            child_proc.interrupt()

            yield env.timeout(1)

        env.process(root(env))
>       env.run()

tests/test_interrupts.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0776ba7a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_interrupt_terminated_process">test_interrupts.py::test_interrupt_terminated_process</h3>
<details><summary> <pre>test_interrupts.py::test_interrupt_terminated_process</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076eff310>

    def test_interrupt_terminated_process(env):
        """Dead processes cannot be interrupted."""

        def child(env):
            yield env.timeout(1)

        def parent(env):
            child_proc = env.process(child(env))

            # Wait long enough so that child_proc terminates.
            yield env.timeout(2)
            ei = pytest.raises(RuntimeError, child_proc.interrupt)
            assert re.match(
                r'<Process\(child\) object at 0x.*> has terminated '
                r'and cannot be interrupted.',
                ei.value.args[0],
            )

            yield env.timeout(1)

        env.process(parent(env))
>       env.run()

tests/test_interrupts.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076eff310>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_multiple_interrupts">test_interrupts.py::test_multiple_interrupts</h3>
<details><summary> <pre>test_interrupts.py::test_multiple_interrupts</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076fa1e70>

    def test_multiple_interrupts(env):
        """Interrupts on dead processes are discarded. If there are multiple
        concurrent interrupts on a process and the latter dies after
        handling the first interrupt, the remaining ones are silently
        ignored.

        """

        def child(env):
            try:
                yield env.timeout(1)
            except simpy.Interrupt as i:
                return i.cause

        def parent(env):
            c = env.process(child(env))
            yield env.timeout(0)
            c.interrupt(1)
            c.interrupt(2)
            result = yield c
            assert result == 1

        env.process(parent(env))
>       env.run()

tests/test_interrupts.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076fa1e70>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_interrupt_self">test_interrupts.py::test_interrupt_self</h3>
<details><summary> <pre>test_interrupts.py::test_interrupt_self</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07647a500>

    def test_interrupt_self(env):
        """A process should not be able to interrupt itself."""

        def pem(env):
            pytest.raises(RuntimeError, env.active_process.interrupt)
            yield env.timeout(0)

        env.process(pem(env))
>       env.run()

tests/test_interrupts.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07647a500>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_immediate_interrupt">test_interrupts.py::test_immediate_interrupt</h3>
<details><summary> <pre>test_interrupts.py::test_immediate_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0765f3730>, log = []

    def test_immediate_interrupt(env, log):
        """Processes are immediately interruptable."""

        def child(env, log):
            try:
                yield env.event()
            except simpy.Interrupt:
                log.append(env.now)

        def parent(env, log):
            child_proc = env.process(child(env, log))
            child_proc.interrupt()
            return
            yield

        env.process(parent(env, log))
>       env.run()

tests/test_interrupts.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0765f3730>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_interrupt_event">test_interrupts.py::test_interrupt_event</h3>
<details><summary> <pre>test_interrupts.py::test_interrupt_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0772adb40>

    def test_interrupt_event(env):
        """A process should be interruptable while waiting for an Event."""

        def child(env):
            try:
                yield env.event()
            except simpy.Interrupt:
                assert env.now == 5

        def parent(env):
            child_proc = env.process(child(env))
            yield env.timeout(5)
            child_proc.interrupt()

        env.process(parent(env))
>       env.run()

tests/test_interrupts.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0772adb40>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_concurrent_behaviour">test_interrupts.py::test_concurrent_behaviour</h3>
<details><summary> <pre>test_interrupts.py::test_concurrent_behaviour</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe077078940>

    def test_concurrent_behaviour(env):
        def proc_a(env):
            timeouts = [env.timeout(0) for i in range(2)]
            while timeouts:
                with pytest.raises(simpy.Interrupt):
                    yield timeouts.pop(0)

        def proc_b(_, proc_a):
            for _ in range(2):
                proc_a.interrupt()
            return
            yield

        proc_a = env.process(proc_a(env))
        env.process(proc_b(env, proc_a))

>       env.run()

tests/test_interrupts.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe077078940>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_get_state">test_process.py::test_get_state</h3>
<details><summary> <pre>test_process.py::test_get_state</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07702d930>

    def test_get_state(env):
        """A process is alive until it's generator has not terminated."""

        def pem_a(env):
            yield env.timeout(3)

        def pem_b(env, pem_a):
            yield env.timeout(1)
            assert pem_a.is_alive

            yield env.timeout(3)
            assert not pem_a.is_alive

        proc_a = env.process(pem_a(env))
        env.process(pem_b(env, proc_a))
>       env.run()

tests/test_process.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07702d930>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_target">test_process.py::test_target</h3>
<details><summary> <pre>test_process.py::test_target</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076fa3160>

    def test_target(env):
        def pem(env, event):
            yield event

        event = env.timeout(5)
        proc = env.process(pem(env, event))

        # Wait until "proc" is initialized and yielded the event
        while env.peek() < 5:
>           env.step()

tests/test_process.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076fa3160>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_wait_for_proc">test_process.py::test_wait_for_proc</h3>
<details><summary> <pre>test_process.py::test_wait_for_proc</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076479ff0>

    def test_wait_for_proc(env):
        """A process can wait until another process finishes."""

        def finisher(env):
            yield env.timeout(5)

        def waiter(env, finisher):
            proc = env.process(finisher(env))
            yield proc  # Waits until "proc" finishes

            assert env.now == 5

        env.process(waiter(env, finisher))
>       env.run()

tests/test_process.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076479ff0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_return_value">test_process.py::test_return_value</h3>
<details><summary> <pre>test_process.py::test_return_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe077862680>

    def test_return_value(env):
        """Processes can set a return value."""

        def child(env):
            yield env.timeout(1)
            return env.now

        def parent(env):
            result1 = yield env.process(child(env))
            result2 = yield env.process(child(env))

            assert [result1, result2] == [1, 2]

        env.process(parent(env))
>       env.run()

tests/test_process.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe077862680>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_child_exception">test_process.py::test_child_exception</h3>
<details><summary> <pre>test_process.py::test_child_exception</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07727c880>

    def test_child_exception(env):
        """A child catches an exception and sends it to its parent."""

        def child(env):
            yield env.timeout(1)
            return RuntimeError('Onoes!')

        def parent(env):
            result = yield env.process(child(env))
            assert isinstance(result, Exception)

        env.process(parent(env))
>       env.run()

tests/test_process.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07727c880>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_interrupted_join">test_process.py::test_interrupted_join</h3>
<details><summary> <pre>test_process.py::test_interrupted_join</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0765f3220>

    def test_interrupted_join(env):
        """Interrupts remove a process from the callbacks of its target."""

        def interruptor(env, process):
            yield env.timeout(1)
            process.interrupt()

        def child(env):
            yield env.timeout(2)

        def parent(env):
            child_proc = env.process(child(env))
            try:
                yield child_proc
                pytest.fail('Did not receive an interrupt.')
            except Interrupt:
                assert env.now == 1
                assert child_proc.is_alive

                # We should not get resumed when child terminates.
                yield env.timeout(5)
                assert env.now == 6

        parent_proc = env.process(parent(env))
        env.process(interruptor(env, parent_proc))
>       env.run()

tests/test_process.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0765f3220>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_interrupted_join_and_rejoin">test_process.py::test_interrupted_join_and_rejoin</h3>
<details><summary> <pre>test_process.py::test_interrupted_join_and_rejoin</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe077527fd0>

    def test_interrupted_join_and_rejoin(env):
        """Tests that interrupts are raised while the victim is waiting for
        another process. The victim tries to join again.

        """

        def interruptor(env, process):
            yield env.timeout(1)
            process.interrupt()

        def child(env):
            yield env.timeout(2)

        def parent(env):
            child_proc = env.process(child(env))
            try:
                yield child_proc
                pytest.fail('Did not receive an interrupt.')
            except Interrupt:
                assert env.now == 1
                assert child_proc.is_alive

                yield child_proc
                assert env.now == 2

        parent_proc = env.process(parent(env))
        env.process(interruptor(env, parent_proc))
>       env.run()

tests/test_process.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe077527fd0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource">test_resources.py::test_resource</h3>
<details><summary> <pre>test_resources.py::test_resource</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0776bad40>, log = []

    def test_resource(env, log):
        """A *resource* is something with a limited numer of slots that need
        to be requested before and released after the usage (e.g., gas pumps
        at a gas station).

        """

        def pem(env, name, resource, log):
            req = resource.request()
            yield req
            assert resource.count == 1

            yield env.timeout(1)
            resource.release(req)

            log.append((name, env.now))

        resource = simpy.Resource(env, capacity=1)
        assert resource.capacity == 1
        assert resource.count == 0
        env.process(pem(env, 'a', resource, log))
        env.process(pem(env, 'b', resource, log))
>       env.run()

tests/test_resources.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0776bad40>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_context_manager">test_resources.py::test_resource_context_manager</h3>
<details><summary> <pre>test_resources.py::test_resource_context_manager</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0765f2bf0>, log = []

    def test_resource_context_manager(env, log):
        """The event that ``Resource.request()`` returns can be used as
        Context Manager."""

        def pem(env, name, resource, log):
            with resource.request() as request:
                yield request
                yield env.timeout(1)

            log.append((name, env.now))

        resource = simpy.Resource(env, capacity=1)
        env.process(pem(env, 'a', resource, log))
        env.process(pem(env, 'b', resource, log))
>       env.run()

tests/test_resources.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0765f2bf0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_slots">test_resources.py::test_resource_slots</h3>
<details><summary> <pre>test_resources.py::test_resource_slots</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07786fdf0>, log = []

    def test_resource_slots(env, log):
        def pem(env, name, resource, log):
            with resource.request() as req:
                yield req
                log.append((name, env.now))
                yield env.timeout(1)

        resource = simpy.Resource(env, capacity=3)
        for i in range(9):
            env.process(pem(env, str(i), resource, log))
>       env.run()

tests/test_resources.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07786fdf0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_continue_after_interrupt">test_resources.py::test_resource_continue_after_interrupt</h3>
<details><summary> <pre>test_resources.py::test_resource_continue_after_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0775f2890>

    def test_resource_continue_after_interrupt(env):
        """A process may be interrupted while waiting for a resource but
        should be able to continue waiting afterwards."""

        def pem(env, res):
            with res.request() as req:
                yield req
                yield env.timeout(1)

        def victim(env, res):
            evt = res.request()
            try:
                yield evt
                pytest.fail('Should not have gotten the resource.')
            except simpy.Interrupt:
                yield evt
                res.release(evt)
                assert env.now == 1

        def interruptor(proc):
            proc.interrupt()
            return 0
            yield

        res = simpy.Resource(env, 1)
        env.process(pem(env, res))
        proc = env.process(victim(env, res))
        env.process(interruptor(proc))
>       env.run()

tests/test_resources.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0775f2890>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_release_after_interrupt">test_resources.py::test_resource_release_after_interrupt</h3>
<details><summary> <pre>test_resources.py::test_resource_release_after_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07786f340>

    def test_resource_release_after_interrupt(env):
        """A process needs to release a resource, even if it was interrupted
        and does not continue to wait for it."""

        def blocker(env, res):
            with res.request() as req:
                yield req
                yield env.timeout(1)

        def victim(env, res):
            evt = res.request()
            try:
                yield evt
                pytest.fail('Should not have gotten the resource.')
            except simpy.Interrupt:
                # Don't wait for the resource
                res.release(evt)
                assert env.now == 0

        def interruptor(proc):
            proc.interrupt()
            return 0
            yield

        res = simpy.Resource(env, 1)
        env.process(blocker(env, res))
        victim_proc = env.process(victim(env, res))
        env.process(interruptor(victim_proc))
>       env.run()

tests/test_resources.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07786f340>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_immediate_requests">test_resources.py::test_resource_immediate_requests</h3>
<details><summary> <pre>test_resources.py::test_resource_immediate_requests</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07635e470>

    def test_resource_immediate_requests(env):
        """A process must not acquire a resource if it releases it and immediately
        requests it again while there are already other requesting processes."""

        def child(env, res):
            result = []
            for _ in range(3):
                with res.request() as req:
                    yield req
                    result.append(env.now)
                    yield env.timeout(1)
            return result

        def parent(env):
            res = simpy.Resource(env, 1)
            child_a = env.process(child(env, res))
            child_b = env.process(child(env, res))

            a_acquire_times = yield child_a
            b_acquire_times = yield child_b

            assert a_acquire_times == [0, 2, 4]
            assert b_acquire_times == [1, 3, 5]

        env.process(parent(env))
>       env.run()

tests/test_resources.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07635e470>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_cm_exception">test_resources.py::test_resource_cm_exception</h3>
<details><summary> <pre>test_resources.py::test_resource_cm_exception</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0776b8dc0>, log = []

    def test_resource_cm_exception(env, log):
        """Resource with context manager receives an exception."""

        def process(env, resource, log, raise_):
            with resource.request() as req:
                yield req
                yield env.timeout(1)
                log.append(env.now)
                if raise_:
                    with pytest.raises(ValueError, match='Foo'):
                        raise ValueError('Foo')

        resource = simpy.Resource(env, 1)
        env.process(process(env, resource, log, True))
        # The second process is used to check if it was able to access the
        # resource:
        env.process(process(env, resource, log, False))
>       env.run()

tests/test_resources.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0776b8dc0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_with_condition">test_resources.py::test_resource_with_condition</h3>
<details><summary> <pre>test_resources.py::test_resource_with_condition</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07635e1d0>

    def test_resource_with_condition(env):
        def process(env, resource):
            with resource.request() as res_event:
                result = yield res_event | env.timeout(1)
                assert res_event in result

        resource = simpy.Resource(env, 1)
        env.process(process(env, resource))
>       env.run()

tests/test_resources.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07635e1d0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_with_priority_queue">test_resources.py::test_resource_with_priority_queue</h3>
<details><summary> <pre>test_resources.py::test_resource_with_priority_queue</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0778601c0>

    def test_resource_with_priority_queue(env):
        def process(env, delay, resource, priority, res_time):
            yield env.timeout(delay)
            req = resource.request(priority=priority)
            yield req
            assert env.now == res_time
            yield env.timeout(5)
            resource.release(req)

        resource = simpy.PriorityResource(env, capacity=1)
        env.process(process(env, 0, resource, 2, 0))
        env.process(process(env, 2, resource, 3, 10))
        env.process(process(env, 2, resource, 3, 15))  # Test equal priority
        env.process(process(env, 4, resource, 1, 5))
>       env.run()

tests/test_resources.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0778601c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_sorted_queue_maxlen">test_resources.py::test_sorted_queue_maxlen</h3>
<details><summary> <pre>test_resources.py::test_sorted_queue_maxlen</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0762ed8d0>

    def test_sorted_queue_maxlen(env):
        """Requests must fail if more than *maxlen* requests happen
        concurrently."""
        resource = simpy.PriorityResource(env, capacity=1)
        resource.put_queue.maxlen = 1  # pyright: ignore

        def process(env, resource):
            # The first request immediately triggered and does not enter the queue.
            resource.request(priority=1)
            # The second request is enqueued.
            resource.request(priority=1)
            with pytest.raises(RuntimeError, match='Cannot append event. Queue is full.'):
                # The third request will now fail.
                resource.request(priority=1)
            yield env.timeout(0)

        env.process(process(env, resource))
>       env.run()

tests/test_resources.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0762ed8d0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_get_users">test_resources.py::test_get_users</h3>
<details><summary> <pre>test_resources.py::test_get_users</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076e85f30>

    def test_get_users(env):
        def process(env, resource):
            with resource.request() as req:
                yield req
                yield env.timeout(1)

        resource = simpy.Resource(env, 1)
        procs = [env.process(process(env, resource)) for _ in range(3)]
>       env.run(until=1)

tests/test_resources.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076e85f30>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_preemptive_resource">test_resources.py::test_preemptive_resource</h3>
<details><summary> <pre>test_resources.py::test_preemptive_resource</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0771f73d0>

    def test_preemptive_resource(env):
        """Processes with a higher priority may preempt requests of lower priority
        processes. Note that higher priorities are indicated by a lower number
        value."""

        def proc_a(_, resource, prio):
            try:
                with resource.request(priority=prio) as req:
                    yield req
                    pytest.fail('Should have received an interrupt/preemption.')
            except simpy.Interrupt:
                pass

        def proc_b(_, resource, prio):
            with resource.request(priority=prio) as req:
                yield req

        resource = simpy.PreemptiveResource(env, 1)
        env.process(proc_a(env, resource, 1))
        env.process(proc_b(env, resource, 0))

>       env.run()

tests/test_resources.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0771f73d0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_preemptive_resource_timeout_0">test_resources.py::test_preemptive_resource_timeout_0</h3>
<details><summary> <pre>test_resources.py::test_preemptive_resource_timeout_0</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe077529ed0>

    def test_preemptive_resource_timeout_0(env):
        def proc_a(env, resource, prio):
            with resource.request(priority=prio) as req:
                try:
                    yield req
                    yield env.timeout(1)
                    pytest.fail('Should have received an interrupt/preemption.')
                except simpy.Interrupt:
                    pass
            yield env.event()

        def proc_b(_, resource, prio):
            with resource.request(priority=prio) as req:
                yield req

        resource = simpy.PreemptiveResource(env, 1)
        env.process(proc_a(env, resource, 1))
        env.process(proc_b(env, resource, 0))

>       env.run()

tests/test_resources.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe077529ed0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_mixed_preemption">test_resources.py::test_mixed_preemption</h3>
<details><summary> <pre>test_resources.py::test_mixed_preemption</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0772f0e80>, log = []

    def test_mixed_preemption(env, log):
        def p(id, env, res, delay, prio, preempt, log):
            yield env.timeout(delay)
            with res.request(priority=prio, preempt=preempt) as req:
                try:
                    yield req
                    yield env.timeout(2)
                    log.append((env.now, id))
                except simpy.Interrupt as ir:
                    assert ir is not None  # noqa: PT017
                    assert isinstance(ir.cause, Preempted)  # noqa: PT017
                    log.append((env.now, id, (ir.cause.by, ir.cause.usage_since)))

        res = simpy.PreemptiveResource(env, 1)
        # p0: First user:
        env.process(p(0, env, res, delay=0, prio=2, preempt=True, log=log))
        # p1: Waits (cannot preempt):
        env.process(p(1, env, res, delay=0, prio=2, preempt=True, log=log))
        # p2: Waits later, but has a higher prio:
        env.process(p(2, env, res, delay=1, prio=1, preempt=False, log=log))
        # p3: Preempt the above proc:
        p3 = env.process(p(3, env, res, delay=3, prio=0, preempt=True, log=log))
        # p4: Wait again:
        env.process(p(4, env, res, delay=4, prio=3, preempt=True, log=log))

>       env.run()

tests/test_resources.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0772f0e80>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_nested_preemption">test_resources.py::test_nested_preemption</h3>
<details><summary> <pre>test_resources.py::test_nested_preemption</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07707b4c0>, log = []

    def test_nested_preemption(env, log):
        def process(id, env, res, delay, prio, preempt, log):
            yield env.timeout(delay)
            with res.request(priority=prio, preempt=preempt) as req:
                try:
                    yield req
                    yield env.timeout(5)
                    log.append((env.now, id))
                except simpy.Interrupt as ir:
                    assert isinstance(ir.cause, Preempted)  # noqa: PT017
                    log.append((env.now, id, (ir.cause.by, ir.cause.usage_since)))

        def process2(id, env, res0, res1, delay, prio, preempt, log):
            yield env.timeout(delay)
            with res0.request(priority=prio, preempt=preempt) as req0:
                try:
                    yield req0
                    with res1.request(priority=prio, preempt=preempt) as req1:
                        try:
                            yield req1
                            yield env.timeout(5)
                            log.append((env.now, id))
                        except simpy.Interrupt as ir:
                            assert isinstance(ir.cause, Preempted)  # noqa: PT017
                            log.append(
                                (
                                    env.now,
                                    id,
                                    (ir.cause.by, ir.cause.usage_since, ir.cause.resource),
                                )
                            )
                except simpy.Interrupt as ir:
                    assert isinstance(ir.cause, Preempted)  # noqa: PT017
                    log.append(
                        (
                            env.now,
                            id,
                            (ir.cause.by, ir.cause.usage_since, ir.cause.resource),
                        )
                    )

        res0 = simpy.PreemptiveResource(env, 1)
        res1 = simpy.PreemptiveResource(env, 1)

        env.process(process2(0, env, res0, res1, 0, -1, True, log))
        p1 = env.process(process(1, env, res1, 1, -2, True, log))

        env.process(process2(2, env, res0, res1, 20, -1, True, log))
        p3 = env.process(process(3, env, res0, 21, -2, True, log))

        env.process(process2(4, env, res0, res1, 21, -1, True, log))

>       env.run()

tests/test_resources.py:406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07707b4c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_container">test_resources.py::test_container</h3>
<details><summary> <pre>test_resources.py::test_container</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07636a1d0>, log = []

    def test_container(env, log):
        """A *container* is a resource (of optionally limited capacity) where
        you can put in our take-out a discrete or continuous amount of
        things (e.g., a box of lump sugar or a can of milk).  The *put* and
        *get* operations block if the buffer is to full or to empty. If they
        return, the process knows that the *put* or *get* operation was
        successful.

        """

        def putter(env, buf, log):
            yield env.timeout(1)
            while True:
                yield buf.put(2)
                log.append(('p', env.now))
                yield env.timeout(1)

        def getter(env, buf, log):
            yield buf.get(1)
            log.append(('g', env.now))

            yield env.timeout(1)
            yield buf.get(1)
            log.append(('g', env.now))

        buf = simpy.Container(env, init=0, capacity=2)
        env.process(putter(env, buf, log))
        env.process(getter(env, buf, log))
>       env.run(until=5)

tests/test_resources.py:450: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07636a1d0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_container_get_queued">test_resources.py::test_container_get_queued</h3>
<details><summary> <pre>test_resources.py::test_container_get_queued</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0772b27a0>

    def test_container_get_queued(env):
        def proc(env, wait, container, what):
            yield env.timeout(wait)
            with getattr(container, what)(1) as req:
                yield req

        container = simpy.Container(env, 1)
        p0 = env.process(proc(env, 0, container, 'get'))
        env.process(proc(env, 1, container, 'put'))
        env.process(proc(env, 1, container, 'put'))
        p3 = env.process(proc(env, 1, container, 'put'))

>       env.run(until=1)

tests/test_resources.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0772b27a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_store">test_resources.py::test_store</h3>
<details><summary> <pre>test_resources.py::test_store</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076effe20>

    def test_store(env):
        """A store models the production and consumption of concrete python
        objects (in contrast to containers, where you only now if the *put*
        or *get* operations were successful but don't get concrete
        objects).

        """

        def putter(_, store, item):
            yield store.put(item)

        def getter(_, store, orig_item):
            item = yield store.get()
            assert item is orig_item

        store = simpy.Store(env, capacity=2)
        item = object()

        # NOTE: Does the start order matter? Need to test this.
        env.process(putter(env, store, item))
        env.process(getter(env, store, item))
>       env.run()

tests/test_resources.py:535: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076effe20>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_store_capacity">test_resources.py::test_store_capacity</h3>
<details><summary> <pre>test_resources.py::test_store_capacity</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0762cfc40>

    def test_store_capacity(env):
        with pytest.raises(ValueError, match='"capacity" must be > 0'):
            simpy.Store(env, 0)
        with pytest.raises(ValueError, match='"capacity" must be > 0'):
            simpy.Store(env, -1)

        capacity = 2
        store = simpy.Store(env, capacity)
        env.process(store.put(i) for i in range(capacity + 1))
>       env.run()

tests/test_resources.py:559: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0762cfc40>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_store_cancel">test_resources.py::test_store_cancel</h3>
<details><summary> <pre>test_resources.py::test_store_cancel</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07636a770>

    def test_store_cancel(env):
        store = simpy.Store(env, capacity=1)

        def acquire_implicit_cancel():
            with store.get():
                yield env.timeout(1)
                # implicit cancel() when exiting with-block

        env.process(acquire_implicit_cancel())
>       env.run()

tests/test_resources.py:574: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07636a770>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_priority_store_item_priority">test_resources.py::test_priority_store_item_priority</h3>
<details><summary> <pre>test_resources.py::test_priority_store_item_priority</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076e87fd0>

    def test_priority_store_item_priority(env):
        pstore = simpy.PriorityStore(env, 3)
        log = []

        def getter(wait):
            yield env.timeout(wait)
            item = yield pstore.get()
            log.append(item)

        # Do not specify priority; the items themselves will be compared to
        # determine priority.
        env.process(pstore.put(s) for s in 'bcadefg')
        env.process(getter(1))
        env.process(getter(2))
        env.process(getter(3))
>       env.run()

tests/test_resources.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076e87fd0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_priority_store_stable_order">test_resources.py::test_priority_store_stable_order</h3>
<details><summary> <pre>test_resources.py::test_priority_store_stable_order</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07635d5a0>

    def test_priority_store_stable_order(env):
        pstore = simpy.PriorityStore(env, 3)
        log = []

        def getter(wait):
            yield env.timeout(wait)
            _, item = yield pstore.get()
            log.append(item)

        items = [object() for _ in range(3)]

        # Unorderable items are inserted with same priority.
        env.process(pstore.put(simpy.PriorityItem(0, item)) for item in items)
        env.process(getter(1))
        env.process(getter(2))
        env.process(getter(3))
>       env.run()

tests/test_resources.py:612: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07635d5a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_filter_store">test_resources.py::test_filter_store</h3>
<details><summary> <pre>test_resources.py::test_filter_store</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076357700>

    def test_filter_store(env):
        def pem(env):
            store = simpy.FilterStore(env, capacity=2)

            get_event = store.get(lambda item: item == 'b')
            yield store.put('a')
            assert not get_event.triggered
            yield store.put('b')
            assert get_event.triggered

        env.process(pem(env))
>       env.run()

tests/test_resources.py:630: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076357700>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_filter_store_get_after_mismatch">test_resources.py::test_filter_store_get_after_mismatch</h3>
<details><summary> <pre>test_resources.py::test_filter_store_get_after_mismatch</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076f03ca0>

    def test_filter_store_get_after_mismatch(env):
        """Regression test for issue #49.

        Triggering get-events after a put in FilterStore wrongly breaks after the
        first mismatch.

        """

        def putter(env, store):
            # The order of putting 'spam' before 'eggs' is important here.
            yield store.put('spam')
            yield env.timeout(1)
            yield store.put('eggs')

        def getter(store):
            # The order of requesting 'eggs' before 'spam' is important here.
            eggs = store.get(lambda i: i == 'eggs')
            spam = store.get(lambda i: i == 'spam')

            ret = yield spam | eggs
            assert spam in ret
            assert eggs not in ret
            assert env.now == 0

            yield eggs
            assert env.now == 1

        store = simpy.FilterStore(env, capacity=2)
        env.process(getter(store))
        env.process(putter(env, store))
>       env.run()

tests/test_resources.py:663: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076f03ca0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_filter_calls_best_case">test_resources.py::test_filter_calls_best_case</h3>
<details><summary> <pre>test_resources.py::test_filter_calls_best_case</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0772f1990>

    def test_filter_calls_best_case(env):
        """The filter function is called every item in the store until a match is
        found. In the best case the first item already matches."""
        log = []

        def log_filter(item):
            log.append(f'check {item}')
            return True

        store = simpy.FilterStore(env)
        store.items = [1, 2, 3]

        def getter(store):
            log.append(f'get {yield store.get(log_filter)}')
            log.append(f'get {yield store.get(log_filter)}')
            log.append(f'get {yield store.get(log_filter)}')

        env.process(getter(store))
>       env.run()

tests/test_resources.py:684: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0772f1990>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_filter_calls_worst_case">test_resources.py::test_filter_calls_worst_case</h3>
<details><summary> <pre>test_resources.py::test_filter_calls_worst_case</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe077524a90>

    def test_filter_calls_worst_case(env):
        """In the worst case the filter function is being called for items multiple
        times."""

        log = []
        store = simpy.FilterStore(env)

        def putter(store):
            for i in range(4):
                log.append(f'put {i}')
                yield store.put(i)

        def log_filter(item):
            log.append(f'check {item}')
            return item >= 3

        def getter(store):
            log.append(f'get {yield store.get(log_filter)}')

        env.process(getter(store))
        env.process(putter(store))
>       env.run()

tests/test_resources.py:710: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe077524a90>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_immediate_put_request">test_resources.py::test_immediate_put_request</h3>
<details><summary> <pre>test_resources.py::test_immediate_put_request</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0765a8af0>

    def test_immediate_put_request(env):
        """Put requests that can be fulfilled immediately do not enter the put
        queue."""
        resource = simpy.Resource(env, capacity=1)
        assert len(resource.users) == 0
        assert len(resource.queue) == 0

        # The resource is empty, the first request will succeed immediately without
        # entering the queue.
>       request = resource.request()

tests/test_resources.py:733: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/resources/resource.py:74: in __init__
    super().__init__(resource)
src/simpy/resources/base.py:39: in __init__
    resource._trigger_put(None)
src/simpy/resources/base.py:199: in _trigger_put
    if not self._do_put(put_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.resource.Resource object at 0x7fe07786ded0>
event = <Event() object at 0x7fe07786c250>

    def _do_put(self, event: PutType) ->Optional[bool]:
        """Perform the *put* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the put *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_put` for every event in the
        :attr:`put_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("The _do_put() method has to be implemented by subclasses.")
E       NotImplementedError: The _do_put() method has to be implemented by subclasses.

src/simpy/resources/base.py:186: NotImplementedError
</pre>
</details>
<h3 id="test_resourcespytest_immediate_get_request">test_resources.py::test_immediate_get_request</h3>
<details><summary> <pre>test_resources.py::test_immediate_get_request</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076fa24a0>

    def test_immediate_get_request(env):
        """Get requests that can be fulfilled immediately do not enter the get
        queue."""
        container = simpy.Container(env)
        # Put something in the container, this request is triggered immediately
        # without entering the queue.
>       request = container.put(1)

tests/test_resources.py:751: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/resources/container.py:30: in __init__
    super().__init__(container)
src/simpy/resources/base.py:39: in __init__
    resource._trigger_put(None)
src/simpy/resources/base.py:199: in _trigger_put
    if not self._do_put(put_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.container.Container object at 0x7fe076fa2140>
event = <Event() object at 0x7fe076fa3a90>

    def _do_put(self, event: PutType) ->Optional[bool]:
        """Perform the *put* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the put *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_put` for every event in the
        :attr:`put_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("The _do_put() method has to be implemented by subclasses.")
E       NotImplementedError: The _do_put() method has to be implemented by subclasses.

src/simpy/resources/base.py:186: NotImplementedError
</pre>
</details>
<h3 id="test_rtpytest_rt01">test_rt.py::test_rt[0.1]</h3>
<details><summary> <pre>test_rt.py::test_rt[0.1]</pre></summary><pre>
log = [], factor = 0.1

    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])
    def test_rt(log, factor):
        """Basic tests for run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=factor)
        env.process(process(env, log, 0.01, 1))
        env.process(process(env, log, 0.02, 1))

>       env.run(2)

tests/test_rt.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7fe0776b8640>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_rt005">test_rt.py::test_rt[0.05]</h3>
<details><summary> <pre>test_rt.py::test_rt[0.05]</pre></summary><pre>
log = [], factor = 0.05

    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])
    def test_rt(log, factor):
        """Basic tests for run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=factor)
        env.process(process(env, log, 0.01, 1))
        env.process(process(env, log, 0.02, 1))

>       env.run(2)

tests/test_rt.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7fe076478910>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_rt015">test_rt.py::test_rt[0.15]</h3>
<details><summary> <pre>test_rt.py::test_rt[0.15]</pre></summary><pre>
log = [], factor = 0.15

    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])
    def test_rt(log, factor):
        """Basic tests for run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=factor)
        env.process(process(env, log, 0.01, 1))
        env.process(process(env, log, 0.02, 1))

>       env.run(2)

tests/test_rt.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7fe076375a50>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_rt_multiple_call">test_rt.py::test_rt_multiple_call</h3>
<details><summary> <pre>test_rt.py::test_rt_multiple_call</pre></summary><pre>
log = []

    def test_rt_multiple_call(log):
        """Test multiple calls to run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=0.05)

        env.process(process(env, log, 0.01, 2))
        env.process(process(env, log, 0.01, 3))

>       env.run(5)

tests/test_rt.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7fe0775f0d00>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_rt_slow_sim_default_behavior">test_rt.py::test_rt_slow_sim_default_behavior</h3>
<details><summary> <pre>test_rt.py::test_rt_slow_sim_default_behavior</pre></summary><pre>
log = []

    def test_rt_slow_sim_default_behavior(log):
        """By default, SimPy should raise an error if a simulation is too
        slow for the selected real-time factor."""
        env = RealtimeEnvironment(factor=0.05)
        env.process(process(env, log, 0.1, 1))

        err = pytest.raises(RuntimeError, env.run, 3)
>       assert 'Simulation too slow for real time' in str(err.value)
E       AssertionError: assert 'Simulation too slow for real time' in 'Simulation too slow: 0.000 seconds late'
E        +  where 'Simulation too slow: 0.000 seconds late' = str(RuntimeError('Simulation too slow: 0.000 seconds late'))
E        +    where RuntimeError('Simulation too slow: 0.000 seconds late') = <ExceptionInfo RuntimeError('Simulation too slow: 0.000 seconds late') tblen=3>.value

tests/test_rt.py:68: AssertionError
</pre>
</details>
<h3 id="test_rtpytest_rt_slow_sim_no_error">test_rt.py::test_rt_slow_sim_no_error</h3>
<details><summary> <pre>test_rt.py::test_rt_slow_sim_no_error</pre></summary><pre>
log = []

    def test_rt_slow_sim_no_error(log):
        """Test ignoring slow simulations."""
        start = monotonic()
        env = RealtimeEnvironment(factor=0.05, strict=False)
        env.process(process(env, log, 0.1, 1))

>       env.run(2)

tests/test_rt.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
src/simpy/rt.py:76: in step
    super().step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7fe0772b3070>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_rtpytest_rt_illegal_until">test_rt.py::test_rt_illegal_until</h3>
<details><summary> <pre>test_rt.py::test_rt_illegal_until</pre></summary><pre>
def test_rt_illegal_until():
        """Test illegal value for *until*."""
        env = RealtimeEnvironment()
>       with pytest.raises(
            ValueError,
            match=r'until \(-1\) must be greater than the current simulation time',
        ):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/test_rt.py:88: Failed
</pre>
</details>
<h3 id="test_rtpytest_rt_sync">test_rt.py::test_rt_sync</h3>
<details><summary> <pre>test_rt.py::test_rt_sync</pre></summary><pre>
log = []

    def test_rt_sync(log):
        """Test resetting the internal wall-clock reference time."""
        env = RealtimeEnvironment(factor=0.05)
        env.process(process(env, log, 0.01))
        sleep(0.06)  # Simulate massive workload :-)
        env.sync()
>       env.run(3)

tests/test_rt.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7fe07647bee0>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_run_with_untriggered_event">test_rt.py::test_run_with_untriggered_event</h3>
<details><summary> <pre>test_rt.py::test_run_with_untriggered_event</pre></summary><pre>
env = <simpy.rt.RealtimeEnvironment object at 0x7fe0772b25c0>

    def test_run_with_untriggered_event(env):
        env = RealtimeEnvironment(factor=0.05)
>       excinfo = pytest.raises(RuntimeError, env.run, until=env.event())

tests/test_rt.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7fe0772b25c0>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
>           sleep(expected_real_time - real_time)
E           OverflowError: timestamp too large to convert to C _PyTime_t

src/simpy/rt.py:72: OverflowError
</pre>
</details>
<h3 id="test_timeoutpytest_discrete_time_steps">test_timeout.py::test_discrete_time_steps</h3>
<details><summary> <pre>test_timeout.py::test_discrete_time_steps</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07647ac80>, log = []

    def test_discrete_time_steps(env, log):
        """envple envulation with discrete time steps."""

        def pem(env, log):
            while True:
                log.append(env.now)
                yield env.timeout(delay=1)

        env.process(pem(env, log))
>       env.run(until=3)

tests/test_timeout.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07647ac80>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_timeoutpytest_negative_timeout">test_timeout.py::test_negative_timeout</h3>
<details><summary> <pre>test_timeout.py::test_negative_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe077862380>

    def test_negative_timeout(env):
        """Don't allow negative timeout times."""

        def pem(env):
            yield env.timeout(-1)

        env.process(pem(env))
        with pytest.raises(ValueError, match='Negative delay'):
>           env.run()

tests/test_timeout.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe077862380>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_timeoutpytest_timeout_value">test_timeout.py::test_timeout_value</h3>
<details><summary> <pre>test_timeout.py::test_timeout_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0763740d0>

    def test_timeout_value(env):
        """You can pass an additional *value* to *timeout* which will be
        directly yielded back into the PEM. This is useful to implement some
        kinds of resources or other additions.

        See :class:`envpy.resources.Store` for an example.

        """

        def pem(env):
            val = yield env.timeout(1, 'ohai')
            assert val == 'ohai'

        env.process(pem(env))
>       env.run()

tests/test_timeout.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0763740d0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_timeoutpytest_shared_timeout">test_timeout.py::test_shared_timeout</h3>
<details><summary> <pre>test_timeout.py::test_shared_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076369060>, log = []

    def test_shared_timeout(env, log):
        def child(env, timeout, id, log):
            yield timeout
            log.append((id, env.now))

        timeout = env.timeout(1)
        for i in range(3):
            env.process(child(env, timeout, i, log))

>       env.run()

tests/test_timeout.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076369060>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_timeoutpytest_triggered_timeout">test_timeout.py::test_triggered_timeout</h3>
<details><summary> <pre>test_timeout.py::test_triggered_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07752a620>

    def test_triggered_timeout(env):
        def process(env):
            def child(env, event):
                value = yield event
                return value

            event = env.timeout(1, 'i was already done')
            # Start the child after the timeout has already happened.
            yield env.timeout(2)
            value = yield env.process(child(env, event))
            assert value == 'i was already done'

>       env.run(env.process(process(env)))

tests/test_timeout.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07752a620>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_start_delayed">test_util.py::test_start_delayed</h3>
<details><summary> <pre>test_util.py::test_start_delayed</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0772b2a40>

    def test_start_delayed(env):
        def pem(env):
            assert env.now == 5
            yield env.timeout(1)

        start_delayed(env, pem(env), delay=5)
>       env.run()

tests/test_util.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0772b2a40>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe">test_util.py::test_subscribe</h3>
<details><summary> <pre>test_util.py::test_subscribe</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076375570>

    def test_subscribe(env):
        """Check async. interrupt if a process terminates."""

        def child(env):
            yield env.timeout(3)
            return 'ohai'

        def parent(env):
            child_proc = env.process(child(env))
            subscribe_at(child_proc)

            try:
                yield env.event()
            except Interrupt as interrupt:
                assert interrupt.cause is not None  # noqa: PT017
                assert interrupt.cause[0] is child_proc  # noqa: PT017
                assert interrupt.cause[1] == 'ohai'  # noqa: PT017
                assert env.now == 3

        env.process(parent(env))
>       env.run()

tests/test_util.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076375570>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_terminated_proc">test_util.py::test_subscribe_terminated_proc</h3>
<details><summary> <pre>test_util.py::test_subscribe_terminated_proc</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07639af80>

    def test_subscribe_terminated_proc(env):
        """subscribe() proc should send a signal immediately if
        "other" has already terminated.

        """

        def child(env):
            yield env.timeout(1)

        def parent(env):
            child_proc = env.process(child(env))
            yield env.timeout(2)
            pytest.raises(RuntimeError, subscribe_at, child_proc)

        env.process(parent(env))
>       env.run()

tests/test_util.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07639af80>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_with_join">test_util.py::test_subscribe_with_join</h3>
<details><summary> <pre>test_util.py::test_subscribe_with_join</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0775f2050>

    def test_subscribe_with_join(env):
        """Test that subscribe() works if a process waits for another one."""

        def child(env, i):
            yield env.timeout(i)

        def parent(env):
            child_proc1 = env.process(child(env, 1))
            child_proc2 = env.process(child(env, 2))
            try:
                subscribe_at(child_proc1)
                yield child_proc2
            except Interrupt as interrupt:
                assert env.now == 1
                assert interrupt.cause is not None  # noqa: PT017
                assert interrupt.cause[0] is child_proc1  # noqa: PT017
                assert child_proc2.is_alive

        env.process(parent(env))
>       env.run()

tests/test_util.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0775f2050>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_at_timeout">test_util.py::test_subscribe_at_timeout</h3>
<details><summary> <pre>test_util.py::test_subscribe_at_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076357580>

    def test_subscribe_at_timeout(env):
        """You should be able to subscribe at arbitrary events."""

        def pem(env):
            to = env.timeout(2)
            subscribe_at(to)
            try:
                yield env.timeout(10)
            except Interrupt as interrupt:
                assert interrupt.cause == (to, None)  # noqa: PT017
                assert env.now == 2

        env.process(pem(env))
>       env.run()

tests/test_util.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076357580>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_at_timeout_with_value">test_util.py::test_subscribe_at_timeout_with_value</h3>
<details><summary> <pre>test_util.py::test_subscribe_at_timeout_with_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0764792a0>

    def test_subscribe_at_timeout_with_value(env):
        """An event's value should be accessible via the interrupt cause."""

        def pem(env):
            val = 'ohai'
            to = env.timeout(2, value=val)
            subscribe_at(to)
            try:
                yield env.timeout(10)
            except Interrupt as interrupt:
                assert interrupt.cause == (to, val)  # noqa: PT017
                assert env.now == 2

        env.process(pem(env))
>       env.run()

tests/test_util.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0764792a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of">test_util.py::test_all_of</h3>
<details><summary> <pre>test_util.py::test_all_of</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076091360>

    def test_all_of(env):
        """Wait for all events to be triggered."""

        def parent(env):
            # Start 10 events.
            events = [env.timeout(i, value=i) for i in range(10)]
            results = yield env.all_of(events)

            assert results == {events[i]: i for i in range(10)}
            assert env.now == 9

        env.process(parent(env))
>       env.run()

tests/test_util.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076091360>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_generator">test_util.py::test_all_of_generator</h3>
<details><summary> <pre>test_util.py::test_all_of_generator</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe077862140>

    def test_all_of_generator(env):
        """Conditions also work with generators."""

        def parent(env):
            # Start 10 events.
            events = (env.timeout(i, value=i) for i in range(10))
            results = yield env.all_of(events)

            assert list(results.values()) == list(range(10))
            assert env.now == 9

        env.process(parent(env))
>       env.run()

tests/test_util.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe077862140>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_wait_for_all_with_errors">test_util.py::test_wait_for_all_with_errors</h3>
<details><summary> <pre>test_util.py::test_wait_for_all_with_errors</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0763a8d60>

    def test_wait_for_all_with_errors(env):
        """On default AllOf should fail immediately if one of its events
        fails."""

        def child_with_error(env, value):
            yield env.timeout(value)
            raise RuntimeError('crashing')

        def parent(env):
            events = [
                env.timeout(1, value=1),
                env.process(child_with_error(env, 2)),
                env.timeout(3, value=3),
            ]

            condition = env.all_of(events)
            with pytest.raises(RuntimeError, match='crashing'):
                yield condition

            # Although the condition has failed, interim values are available.
            assert condition._events[0].value == 1
            assert condition._events[1].value.args[0] == 'crashing'
            # The last child has not terminated yet.
            assert not events[2].processed

        env.process(parent(env))
>       env.run()

tests/test_util.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0763a8d60>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_chaining">test_util.py::test_all_of_chaining</h3>
<details><summary> <pre>test_util.py::test_all_of_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076369f30>

    def test_all_of_chaining(env):
        """If a wait_for_all condition A is chained to a wait_for_all condition B,
        B will be merged into A."""

        def parent(env):
            condition_a = env.all_of([env.timeout(i, value=i) for i in range(2)])
            condition_b = env.all_of([env.timeout(i, value=i) for i in range(2)])

            condition_a &= condition_b

            results = yield condition_a
            assert list(results.values()) == [0, 1, 0, 1]

        env.process(parent(env))
>       env.run()

tests/test_util.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076369f30>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_chaining_intermediate_results">test_util.py::test_all_of_chaining_intermediate_results</h3>
<details><summary> <pre>test_util.py::test_all_of_chaining_intermediate_results</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076091ea0>

    def test_all_of_chaining_intermediate_results(env):
        """If a wait_for_all condition A with intermediate results is merged into
        another wait_for_all condition B, the results are copied into condition
        A."""

        def parent(env):
            condition_a = env.all_of([env.timeout(i, value=i) for i in range(2)])
            condition_b = env.all_of([env.timeout(i, value=i) for i in range(2)])

            yield env.timeout(0)

            condition = condition_a & condition_b
            result = ConditionValue()
            condition._populate_value(result)
            assert list(result.values()) == [0, 0]

            results = yield condition
            assert list(results.values()) == [0, 1, 0, 1]

        env.process(parent(env))
>       env.run()

tests/test_util.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076091ea0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_with_triggered_events">test_util.py::test_all_of_with_triggered_events</h3>
<details><summary> <pre>test_util.py::test_all_of_with_triggered_events</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07702ce80>

    def test_all_of_with_triggered_events(env):
        """Processed events can be added to a condition. Confirm this with
        all_of."""

        def parent(env):
            events = [env.timeout(0, value='spam'), env.timeout(1, value='eggs')]
            yield env.timeout(2)

            values = list((yield env.all_of(events)).values())
            assert values == ['spam', 'eggs']

        env.process(parent(env))
>       env.run()

tests/test_util.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07702ce80>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of">test_util.py::test_any_of</h3>
<details><summary> <pre>test_util.py::test_any_of</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe076090f70>

    def test_any_of(env):
        """Wait for any event to be triggered."""

        def parent(env):
            # Start 10 events.
            events = [env.timeout(i, value=i) for i in range(10)]
            results = yield env.any_of(events)

            assert results == {events[0]: 0}
            assert env.now == 0

        env.process(parent(env))
>       env.run()

tests/test_util.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe076090f70>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of_with_errors">test_util.py::test_any_of_with_errors</h3>
<details><summary> <pre>test_util.py::test_any_of_with_errors</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07752b040>

    def test_any_of_with_errors(env):
        """On default any_of should fail if the event has failed too."""

        def child_with_error(env, value):
            yield env.timeout(value)
            raise RuntimeError('crashing')

        def parent(env):
            events = [env.process(child_with_error(env, 1)), env.timeout(2, value=2)]
            condition = env.any_of(events)
            with pytest.raises(RuntimeError, match='crashing'):
                yield condition

            assert condition._events[0].value.args[0] == 'crashing'
            # The last event has not terminated yet.
            assert not events[1].processed

        env.process(parent(env))
>       env.run()

tests/test_util.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07752b040>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of_chaining">test_util.py::test_any_of_chaining</h3>
<details><summary> <pre>test_util.py::test_any_of_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0763563e0>

    def test_any_of_chaining(env):
        """If a any_of condition A is chained to a any_of condition B,
        B will be merged into A."""

        def parent(env):
            condition_a = env.any_of([env.timeout(2, value='a')])
            condition_b = env.any_of([env.timeout(1, value='b')])

            condition_a |= condition_b

            results = yield condition_a
            assert list(results.values()) == ['b']

        env.process(parent(env))
>       env.run()

tests/test_util.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0763563e0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of_with_triggered_events">test_util.py::test_any_of_with_triggered_events</h3>
<details><summary> <pre>test_util.py::test_any_of_with_triggered_events</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0763ac370>

    def test_any_of_with_triggered_events(env):
        """Processed events can be added to a condition. Confirm this with
        all_of."""

        def parent(env):
            events = [env.timeout(0, value='spam'), env.timeout(1, value='eggs')]
            yield env.timeout(2)

            values = list((yield env.any_of(events)).values())
            assert values == ['spam', 'eggs']

        env.process(parent(env))
>       env.run()

tests/test_util.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0763ac370>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_empty_any_of">test_util.py::test_empty_any_of</h3>
<details><summary> <pre>test_util.py::test_empty_any_of</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0760912a0>

    def test_empty_any_of(env):
        """AnyOf will trigger immediately if there are no events."""

        def parent(env):
            results = yield env.any_of([])
            assert results == {}

        env.process(parent(env))
>       env.run()

tests/test_util.py:317: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0760912a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_empty_all_of">test_util.py::test_empty_all_of</h3>
<details><summary> <pre>test_util.py::test_empty_all_of</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe07786ed40>

    def test_empty_all_of(env):
        """AllOf will trigger immediately if there are no events."""

        def parent(env):
            results = yield env.all_of([])
            assert results == {}

        env.process(parent(env))
>       env.run()

tests/test_util.py:328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe07786ed40>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_expansion">test_util.py::test_all_of_expansion</h3>
<details><summary> <pre>test_util.py::test_all_of_expansion</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fe0763786a0>

    def test_all_of_expansion(env):
        """The result of AllOf is an OrderedDict, which allows to expand its values
        directly into variables."""

        def p(env):
            timeouts = [env.timeout(d, d) for d in [3, 2, 1]]
            a, b, c = (yield env.all_of(timeouts)).values()
            assert a == 3
            assert b == 2
            assert c == 1

        env.process(p(env))
>       env.run()

tests/test_util.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fe0763786a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/simpy/core.py b/src/simpy/core.py</span>
<span class="gh">index 10c88fb..b39ddef 100644</span>
<span class="gd">--- a/src/simpy/core.py</span>
<span class="gi">+++ b/src/simpy/core.py</span>
<span class="gu">@@ -34,7 +34,10 @@ class BoundClass(Generic[T]):</span>
<span class="w"> </span>    def bind_early(instance: object) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Bind all :class:`BoundClass` attributes of the *instance&#39;s* class
<span class="w"> </span>        to the instance itself to increase performance.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cls = type(instance)</span>
<span class="gi">+        for name, obj in cls.__dict__.items():</span>
<span class="gi">+            if isinstance(obj, BoundClass):</span>
<span class="gi">+                setattr(instance, name, obj.__get__(instance, cls))</span>


<span class="w"> </span>class EmptySchedule(Exception):
<span class="gu">@@ -49,7 +52,7 @@ class StopSimulation(Exception):</span>
<span class="w"> </span>    def callback(cls, event: Event) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Used as callback in :meth:`Environment.run()` to stop the simulation
<span class="w"> </span>        when the *until* event occurred.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise cls()</span>


<span class="w"> </span>SimTime = Union[int, float]
<span class="gu">@@ -77,12 +80,12 @@ class Environment:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def now(self) -&gt;SimTime:
<span class="w"> </span>        &quot;&quot;&quot;The current simulation time.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._now</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def active_process(self) -&gt;Optional[Process]:
<span class="w"> </span>        &quot;&quot;&quot;The currently active process of the environment.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._active_proc</span>
<span class="w"> </span>    if TYPE_CHECKING:

<span class="w"> </span>        def process(self, generator: ProcessGenerator) -&gt;Process:
<span class="gu">@@ -121,12 +124,15 @@ class Environment:</span>
<span class="w"> </span>    def schedule(self, event: Event, priority: EventPriority=NORMAL, delay:
<span class="w"> </span>        SimTime=0) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Schedule an *event* with a given *priority* and a *delay*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        heappush(self._queue, (self._now + delay, priority, next(self._eid), event))</span>

<span class="w"> </span>    def peek(self) -&gt;SimTime:
<span class="w"> </span>        &quot;&quot;&quot;Get the time of the next scheduled event. Return
<span class="w"> </span>        :data:`~simpy.core.Infinity` if there is no further event.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._queue[0][0]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            return Infinity</span>

<span class="w"> </span>    def step(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Process the next event.
<span class="gu">@@ -134,7 +140,20 @@ class Environment:</span>
<span class="w"> </span>        Raise an :exc:`EmptySchedule` if no further events are available.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._now, _, _, event = heappop(self._queue)</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            raise EmptySchedule()</span>
<span class="gi">+</span>
<span class="gi">+        # Process the event</span>
<span class="gi">+        event._ok = True</span>
<span class="gi">+        event._value = event._callback(event)</span>
<span class="gi">+        event._processed = True</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(event, Process):</span>
<span class="gi">+            self._active_proc = event</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._active_proc = None</span>

<span class="w"> </span>    def run(self, until: Optional[Union[SimTime, Event]]=None) -&gt;Optional[Any]:
<span class="w"> </span>        &quot;&quot;&quot;Executes :meth:`step()` until the given criterion *until* is met.
<span class="gu">@@ -151,4 +170,27 @@ class Environment:</span>
<span class="w"> </span>          until the environment&#39;s time reaches *until*.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if until is None:</span>
<span class="gi">+            while True:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self.step()</span>
<span class="gi">+                except EmptySchedule:</span>
<span class="gi">+                    return None</span>
<span class="gi">+        elif isinstance(until, Event):</span>
<span class="gi">+            until.callbacks.append(StopSimulation.callback)</span>
<span class="gi">+            try:</span>
<span class="gi">+                while not until.triggered:</span>
<span class="gi">+                    self.step()</span>
<span class="gi">+            except StopSimulation:</span>
<span class="gi">+                return until.value</span>
<span class="gi">+            except EmptySchedule:</span>
<span class="gi">+                if not until.triggered:</span>
<span class="gi">+                    raise RuntimeError(&#39;No scheduled events left but &quot;until&quot; event was not triggered&#39;)</span>
<span class="gi">+        elif isinstance(until, (int, float)):</span>
<span class="gi">+            try:</span>
<span class="gi">+                while self._now &lt; until:</span>
<span class="gi">+                    self.step()</span>
<span class="gi">+            except EmptySchedule:</span>
<span class="gi">+                return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&#39;Invalid until parameter type&#39;)</span>
<span class="gh">diff --git a/src/simpy/events.py b/src/simpy/events.py</span>
<span class="gh">index 128ed75..2781b3f 100644</span>
<span class="gd">--- a/src/simpy/events.py</span>
<span class="gi">+++ b/src/simpy/events.py</span>
<span class="gu">@@ -75,19 +75,19 @@ class Event:</span>

<span class="w"> </span>    def _desc(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return a string *Event()*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &#39;Event()&#39;</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def triggered(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Becomes ``True`` if the event has been triggered and its callbacks
<span class="w"> </span>        are about to be invoked.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._value is not PENDING</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def processed(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Becomes ``True`` if the event has been processed (e.g., its
<span class="w"> </span>        callbacks have been invoked).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.callbacks is None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def ok(self) -&gt;bool:
<span class="gu">@@ -98,7 +98,9 @@ class Event:</span>
<span class="w"> </span>        :raises AttributeError: if accessed before the event is triggered.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value is PENDING:</span>
<span class="gi">+            raise AttributeError(&#39;Event has not yet been triggered&#39;)</span>
<span class="gi">+        return self._ok</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def defused(self) -&gt;bool:
<span class="gu">@@ -115,7 +117,7 @@ class Event:</span>
<span class="w"> </span>        processed by the :class:`~simpy.core.Environment`.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._defused</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def value(self) -&gt;Optional[Any]:
<span class="gu">@@ -126,7 +128,9 @@ class Event:</span>
<span class="w"> </span>        Raises :exc:`AttributeError` if the value is not yet available.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value is PENDING:</span>
<span class="gi">+            raise AttributeError(&#39;Value not yet available&#39;)</span>
<span class="gi">+        return self._value</span>

<span class="w"> </span>    def trigger(self, event: Event) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Trigger the event with the state and value of the provided *event*.
<span class="gu">@@ -136,7 +140,10 @@ class Event:</span>
<span class="w"> </span>        chain reactions.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._ok = event._ok</span>
<span class="gi">+        self._value = event._value</span>
<span class="gi">+        self._defused = event._defused</span>
<span class="gi">+        self.env.schedule(self)</span>

<span class="w"> </span>    def succeed(self, value: Optional[Any]=None) -&gt;Event:
<span class="w"> </span>        &quot;&quot;&quot;Set the event&#39;s value, mark it as successful and schedule it for
<span class="gu">@@ -145,7 +152,12 @@ class Event:</span>
<span class="w"> </span>        Raises :exc:`RuntimeError` if this event has already been triggerd.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value is not PENDING:</span>
<span class="gi">+            raise RuntimeError(&#39;Event has already been triggered&#39;)</span>
<span class="gi">+        self._ok = True</span>
<span class="gi">+        self._value = value</span>
<span class="gi">+        self.env.schedule(self)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def fail(self, exception: Exception) -&gt;Event:
<span class="w"> </span>        &quot;&quot;&quot;Set *exception* as the events value, mark it as failed and schedule
<span class="gu">@@ -156,7 +168,15 @@ class Event:</span>
<span class="w"> </span>        Raises :exc:`RuntimeError` if this event has already been triggered.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(exception, Exception):</span>
<span class="gi">+            raise TypeError(&#39;exception must be an Exception instance&#39;)</span>
<span class="gi">+        if self._value is not PENDING:</span>
<span class="gi">+            raise RuntimeError(&#39;Event has already been triggered&#39;)</span>
<span class="gi">+        self._ok = False</span>
<span class="gi">+        self._value = exception</span>
<span class="gi">+        self._defused = False</span>
<span class="gi">+        self.env.schedule(self)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def __and__(self, other: Event) -&gt;Condition:
<span class="w"> </span>        &quot;&quot;&quot;Return a :class:`~simpy.events.Condition` that will be triggered if
<span class="gu">@@ -197,7 +217,8 @@ class Timeout(Event):</span>

<span class="w"> </span>    def _desc(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return a string *Timeout(delay[, value=value])*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        value_str = f&#39;, value={self._value!r}&#39; if self._value is not None else &#39;&#39;</span>
<span class="gi">+        return f&#39;Timeout({self._delay}{value_str})&#39;</span>


<span class="w"> </span>class Initialize(Event):
<span class="gu">@@ -267,7 +288,7 @@ class Process(Event):</span>

<span class="w"> </span>    def _desc(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return a string *Process(process_func_name)*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&#39;Process({self._generator.__name__})&#39;</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def target(self) -&gt;Event:
<span class="gu">@@ -277,17 +298,17 @@ class Process(Event):</span>
<span class="w"> </span>        interrupted.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._target</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def name(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Name of the function used to start the process.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._generator.__name__</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def is_alive(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;``True`` until the process generator exits.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._value is PENDING</span>

<span class="w"> </span>    def interrupt(self, cause: Optional[Any]=None) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Interrupt this process optionally providing a *cause*.
<span class="gu">@@ -297,7 +318,12 @@ class Process(Event):</span>
<span class="w"> </span>        cases.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.is_alive:</span>
<span class="gi">+            raise RuntimeError(f&#39;{self} has terminated and cannot be interrupted.&#39;)</span>
<span class="gi">+        if self is self.env.active_process:</span>
<span class="gi">+            raise RuntimeError(&#39;A process is not allowed to interrupt itself.&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        Interruption(self, cause)</span>

<span class="w"> </span>    def _resume(self, event: Event) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Resumes the execution of the process with the value of *event*. If
<span class="gu">@@ -383,16 +409,24 @@ class Condition(Event):</span>

<span class="w"> </span>    def _desc(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return a string *Condition(evaluate, [events])*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&#39;Condition({self._evaluate.__name__}, {self._events})&#39;</span>

<span class="w"> </span>    def _populate_value(self, value: ConditionValue) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Populate the *value* by recursively visiting all nested
<span class="w"> </span>        conditions.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for event in self._events:</span>
<span class="gi">+            if isinstance(event, Condition):</span>
<span class="gi">+                event._populate_value(value)</span>
<span class="gi">+            elif event.callbacks is None:</span>
<span class="gi">+                value.events.append(event)</span>

<span class="w"> </span>    def _build_value(self, event: Event) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Build the value of this condition.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._ok:</span>
<span class="gi">+            return</span>
<span class="gi">+        value = ConditionValue()</span>
<span class="gi">+        self._populate_value(value)</span>
<span class="gi">+        self._value = value</span>

<span class="w"> </span>    def _remove_check_callbacks(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Remove _check() callbacks from events recursively.
<span class="gu">@@ -403,24 +437,36 @@ class Condition(Event):</span>
<span class="w"> </span>        untriggered events.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for event in self._events:</span>
<span class="gi">+            if event.callbacks and self._check in event.callbacks:</span>
<span class="gi">+                event.callbacks.remove(self._check)</span>
<span class="gi">+            if isinstance(event, Condition):</span>
<span class="gi">+                event._remove_check_callbacks()</span>

<span class="w"> </span>    def _check(self, event: Event) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if the condition was already met and schedule the *event* if
<span class="w"> </span>        so.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value is not PENDING:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self._count += 1</span>
<span class="gi">+</span>
<span class="gi">+        if self._evaluate(self._events, self._count):</span>
<span class="gi">+            self._ok = True</span>
<span class="gi">+            self.env.schedule(self)</span>
<span class="gi">+            self._remove_check_callbacks()</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def all_events(events: Tuple[Event, ...], count: int) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;An evaluation function that returns ``True`` if all *events* have
<span class="w"> </span>        been triggered.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(events) == count</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def any_events(events: Tuple[Event, ...], count: int) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;An evaluation function that returns ``True`` if at least one of
<span class="w"> </span>        *events* has been triggered.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return count &gt; 0</span>


<span class="w"> </span>class AllOf(Condition):
<span class="gu">@@ -447,4 +493,7 @@ class AnyOf(Condition):</span>

<span class="w"> </span>def _describe_frame(frame: FrameType) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Print filename, line number and function name of a stack frame.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    filename = frame.f_code.co_filename</span>
<span class="gi">+    lineno = frame.f_lineno</span>
<span class="gi">+    funcname = frame.f_code.co_name</span>
<span class="gi">+    return f&#39;{filename}:{lineno}, in {funcname}&#39;</span>
<span class="gh">diff --git a/src/simpy/exceptions.py b/src/simpy/exceptions.py</span>
<span class="gh">index d45300e..beef1b2 100644</span>
<span class="gd">--- a/src/simpy/exceptions.py</span>
<span class="gi">+++ b/src/simpy/exceptions.py</span>
<span class="gu">@@ -31,4 +31,4 @@ class Interrupt(SimPyException):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def cause(self) -&gt;Optional[Any]:
<span class="w"> </span>        &quot;&quot;&quot;The cause of the interrupt or ``None`` if no cause was provided.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.args[0] if self.args else None</span>
<span class="gh">diff --git a/src/simpy/resources/base.py b/src/simpy/resources/base.py</span>
<span class="gh">index a7d0b96..ccedb56 100644</span>
<span class="gd">--- a/src/simpy/resources/base.py</span>
<span class="gi">+++ b/src/simpy/resources/base.py</span>
<span class="gu">@@ -58,7 +58,8 @@ class Put(Event, ContextManager[&#39;Put&#39;], Generic[ResourceType]):</span>
<span class="w"> </span>        method is called automatically.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.triggered:</span>
<span class="gi">+            self.resource.put_queue.remove(self)</span>


<span class="w"> </span>class Get(Event, ContextManager[&#39;Get&#39;], Generic[ResourceType]):
<span class="gu">@@ -104,7 +105,8 @@ class Get(Event, ContextManager[&#39;Get&#39;], Generic[ResourceType]):</span>
<span class="w"> </span>        method is called automatically.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.triggered:</span>
<span class="gi">+            self.resource.get_queue.remove(self)</span>


<span class="w"> </span>PutType = TypeVar(&#39;PutType&#39;, bound=Put)
<span class="gu">@@ -152,7 +154,7 @@ class BaseResource(Generic[PutType, GetType]):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def capacity(self) -&gt;Union[float, int]:
<span class="w"> </span>        &quot;&quot;&quot;Maximum capacity of the resource.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._capacity</span>
<span class="w"> </span>    if TYPE_CHECKING:

<span class="w"> </span>        def put(self) -&gt;Put:
<span class="gu">@@ -181,7 +183,7 @@ class BaseResource(Generic[PutType, GetType]):</span>
<span class="w"> </span>        :attr:`put_queue`, as long as the return value does not evaluate
<span class="w"> </span>        ``False``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;The _do_put() method has to be implemented by subclasses.&quot;)</span>

<span class="w"> </span>    def _trigger_put(self, get_event: Optional[GetType]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;This method is called once a new put event has been created or a get
<span class="gu">@@ -191,7 +193,12 @@ class BaseResource(Generic[PutType, GetType]):</span>
<span class="w"> </span>        calls :meth:`_do_put` to check if the conditions for the event are met.
<span class="w"> </span>        If :meth:`_do_put` returns ``False``, the iteration is stopped early.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        idx = 0</span>
<span class="gi">+        while idx &lt; len(self.put_queue):</span>
<span class="gi">+            put_event = self.put_queue[idx]</span>
<span class="gi">+            if not self._do_put(put_event):</span>
<span class="gi">+                break</span>
<span class="gi">+            idx += 1</span>

<span class="w"> </span>    def _do_get(self, event: GetType) -&gt;Optional[bool]:
<span class="w"> </span>        &quot;&quot;&quot;Perform the *get* operation.
<span class="gu">@@ -204,7 +211,7 @@ class BaseResource(Generic[PutType, GetType]):</span>
<span class="w"> </span>        :attr:`get_queue`, as long as the return value does not evaluate
<span class="w"> </span>        ``False``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;The _do_get() method has to be implemented by subclasses.&quot;)</span>

<span class="w"> </span>    def _trigger_get(self, put_event: Optional[PutType]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Trigger get events.
<span class="gu">@@ -216,4 +223,9 @@ class BaseResource(Generic[PutType, GetType]):</span>
<span class="w"> </span>        calls :meth:`_do_get` to check if the conditions for the event are met.
<span class="w"> </span>        If :meth:`_do_get` returns ``False``, the iteration is stopped early.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        idx = 0</span>
<span class="gi">+        while idx &lt; len(self.get_queue):</span>
<span class="gi">+            get_event = self.get_queue[idx]</span>
<span class="gi">+            if not self._do_get(get_event):</span>
<span class="gi">+                break</span>
<span class="gi">+            idx += 1</span>
<span class="gh">diff --git a/src/simpy/resources/container.py b/src/simpy/resources/container.py</span>
<span class="gh">index 00aa6de..fe7bce5 100644</span>
<span class="gd">--- a/src/simpy/resources/container.py</span>
<span class="gi">+++ b/src/simpy/resources/container.py</span>
<span class="gu">@@ -77,16 +77,16 @@ class Container(base.BaseResource):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def level(self) -&gt;ContainerAmount:
<span class="w"> </span>        &quot;&quot;&quot;The current amount of the matter in the container.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._level</span>
<span class="w"> </span>    if TYPE_CHECKING:

<span class="w"> </span>        def put(self, amount: ContainerAmount) -&gt;ContainerPut:
<span class="w"> </span>            &quot;&quot;&quot;Request to put *amount* of matter into the container.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return ContainerPut(self, amount)</span>

<span class="w"> </span>        def get(self, amount: ContainerAmount) -&gt;ContainerGet:
<span class="w"> </span>            &quot;&quot;&quot;Request to get *amount* of matter out of the container.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return ContainerGet(self, amount)</span>
<span class="w"> </span>    else:
<span class="w"> </span>        put = BoundClass(ContainerPut)
<span class="w"> </span>        get = BoundClass(ContainerGet)
<span class="gh">diff --git a/src/simpy/resources/resource.py b/src/simpy/resources/resource.py</span>
<span class="gh">index 2c4f6dd..fa35618 100644</span>
<span class="gd">--- a/src/simpy/resources/resource.py</span>
<span class="gi">+++ b/src/simpy/resources/resource.py</span>
<span class="gu">@@ -70,6 +70,15 @@ class Request(base.Put):</span>
<span class="w"> </span>    resource: Resource
<span class="w"> </span>    usage_since: Optional[SimTime] = None

<span class="gi">+    def __init__(self, resource: Resource):</span>
<span class="gi">+        super().__init__(resource)</span>
<span class="gi">+        self.resource = resource</span>
<span class="gi">+        self.usage_since = None</span>
<span class="gi">+</span>
<span class="gi">+    def __enter__(self):</span>
<span class="gi">+        self.usage_since = self.env.now</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="w"> </span>    def __exit__(self, exc_type: Optional[Type[BaseException]], exc_value:
<span class="w"> </span>        Optional[BaseException], traceback: Optional[TracebackType]
<span class="w"> </span>        ) -&gt;Optional[bool]:
<span class="gu">@@ -90,6 +99,13 @@ class Release(base.Get):</span>
<span class="w"> </span>        &quot;&quot;&quot;The request (:class:`Request`) that is to be released.&quot;&quot;&quot;
<span class="w"> </span>        super().__init__(resource)

<span class="gi">+    def __call__(self):</span>
<span class="gi">+        if self.request in self.resource.users:</span>
<span class="gi">+            self.resource.users.remove(self.request)</span>
<span class="gi">+            self.succeed()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.fail(ValueError(&quot;This request is not in the resource&#39;s users.&quot;))</span>
<span class="gi">+</span>

<span class="w"> </span>class PriorityRequest(Request):
<span class="w"> </span>    &quot;&quot;&quot;Request the usage of *resource* with a given *priority*. If the
<span class="gu">@@ -138,7 +154,10 @@ class SortedQueue(list):</span>
<span class="w"> </span>        Raise a :exc:`RuntimeError` if the queue is full.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.maxlen is not None and len(self) &gt;= self.maxlen:</span>
<span class="gi">+            raise RuntimeError(&quot;Queue is full&quot;)</span>
<span class="gi">+        super().append(item)</span>
<span class="gi">+        self.sort(key=lambda x: x.key)</span>


<span class="w"> </span>class Resource(base.BaseResource):
<span class="gu">@@ -168,7 +187,7 @@ class Resource(base.BaseResource):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def count(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Number of users currently using the resource.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self.users)</span>
<span class="w"> </span>    if TYPE_CHECKING:

<span class="w"> </span>        def request(self) -&gt;Request:
<span class="gh">diff --git a/src/simpy/resources/store.py b/src/simpy/resources/store.py</span>
<span class="gh">index 5875e6d..379e325 100644</span>
<span class="gd">--- a/src/simpy/resources/store.py</span>
<span class="gi">+++ b/src/simpy/resources/store.py</span>
<span class="gu">@@ -73,11 +73,11 @@ class Store(base.BaseResource):</span>

<span class="w"> </span>        def put(self, item: Any) -&gt;StorePut:
<span class="w"> </span>            &quot;&quot;&quot;Request to put *item* into the store.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return StorePut(self, item)</span>

<span class="w"> </span>        def get(self) -&gt;StoreGet:
<span class="w"> </span>            &quot;&quot;&quot;Request to get an *item* out of the store.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return StoreGet(self)</span>
<span class="w"> </span>    else:
<span class="w"> </span>        put = BoundClass(StorePut)
<span class="w"> </span>        get = BoundClass(StoreGet)
<span class="gu">@@ -111,6 +111,31 @@ class PriorityStore(Store):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def __init__(self, env: Environment, capacity: Union[float, int]=float(&#39;inf&#39;)):</span>
<span class="gi">+        super().__init__(env, capacity)</span>
<span class="gi">+        self.items = []  # Use a list as a heap</span>
<span class="gi">+</span>
<span class="gi">+    if TYPE_CHECKING:</span>
<span class="gi">+        def put(self, item: Any) -&gt; StorePut:</span>
<span class="gi">+            &quot;&quot;&quot;Request to put *item* into the store.&quot;&quot;&quot;</span>
<span class="gi">+            return StorePut(self, item)</span>
<span class="gi">+</span>
<span class="gi">+        def get(self) -&gt; StoreGet:</span>
<span class="gi">+            &quot;&quot;&quot;Request to get the highest priority *item* from the store.&quot;&quot;&quot;</span>
<span class="gi">+            return StoreGet(self)</span>
<span class="gi">+    else:</span>
<span class="gi">+        put = BoundClass(StorePut)</span>
<span class="gi">+        get = BoundClass(StoreGet)</span>
<span class="gi">+</span>
<span class="gi">+    def _do_put(self, event: StorePut) -&gt; None:</span>
<span class="gi">+        if len(self.items) &lt; self.capacity:</span>
<span class="gi">+            heappush(self.items, event.item)</span>
<span class="gi">+            event.succeed()</span>
<span class="gi">+</span>
<span class="gi">+    def _do_get(self, event: StoreGet) -&gt; None:</span>
<span class="gi">+        if self.items:</span>
<span class="gi">+            event.succeed(heappop(self.items))</span>
<span class="gi">+</span>

<span class="w"> </span>class FilterStore(Store):
<span class="w"> </span>    &quot;&quot;&quot;Resource with *capacity* slots for storing arbitrary objects supporting
<span class="gu">@@ -139,6 +164,13 @@ class FilterStore(Store):</span>
<span class="w"> </span>            ) -&gt;FilterStoreGet:
<span class="w"> </span>            &quot;&quot;&quot;Request to get an *item*, for which *filter* returns ``True``,
<span class="w"> </span>            out of the store.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return FilterStoreGet(self, filter)</span>
<span class="w"> </span>    else:
<span class="w"> </span>        get = BoundClass(FilterStoreGet)
<span class="gi">+</span>
<span class="gi">+    def _do_get(self, event: FilterStoreGet) -&gt; None:</span>
<span class="gi">+        for item in self.items:</span>
<span class="gi">+            if event.filter(item):</span>
<span class="gi">+                self.items.remove(item)</span>
<span class="gi">+                event.succeed(item)</span>
<span class="gi">+                break</span>
<span class="gh">diff --git a/src/simpy/rt.py b/src/simpy/rt.py</span>
<span class="gh">index 9d99392..e3c068c 100644</span>
<span class="gd">--- a/src/simpy/rt.py</span>
<span class="gi">+++ b/src/simpy/rt.py</span>
<span class="gu">@@ -31,14 +31,14 @@ class RealtimeEnvironment(Environment):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def factor(self) -&gt;float:
<span class="w"> </span>        &quot;&quot;&quot;Scaling factor of the real-time.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._factor</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def strict(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Running mode of the environment. :meth:`step()` will raise a
<span class="w"> </span>        :exc:`RuntimeError` if this is set to ``True`` and the processing of
<span class="w"> </span>        events takes too long.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._strict</span>

<span class="w"> </span>    def sync(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Synchronize the internal time with the current wall-clock time.
<span class="gu">@@ -48,7 +48,8 @@ class RealtimeEnvironment(Environment):</span>
<span class="w"> </span>        calling :meth:`run()` or :meth:`step()`.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.real_start = monotonic()</span>
<span class="gi">+        self.env_start = self._now</span>

<span class="w"> </span>    def step(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Process the next event after enough real-time has passed for the
<span class="gu">@@ -59,4 +60,17 @@ class RealtimeEnvironment(Environment):</span>
<span class="w"> </span>        the event is processed too slowly.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            evt_time = self.peek()</span>
<span class="gi">+        except EmptySchedule:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        real_time = monotonic()</span>
<span class="gi">+        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor</span>
<span class="gi">+</span>
<span class="gi">+        if real_time &lt; expected_real_time:</span>
<span class="gi">+            sleep(expected_real_time - real_time)</span>
<span class="gi">+        elif self._strict and real_time &gt; expected_real_time:</span>
<span class="gi">+            raise RuntimeError(f&#39;Simulation too slow: {real_time - expected_real_time:.3f} seconds late&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        super().step()</span>
<span class="gh">diff --git a/src/simpy/util.py b/src/simpy/util.py</span>
<span class="gh">index 5e3a81a..bb287ec 100644</span>
<span class="gd">--- a/src/simpy/util.py</span>
<span class="gi">+++ b/src/simpy/util.py</span>
<span class="gu">@@ -33,7 +33,14 @@ def start_delayed(env: Environment, generator: ProcessGenerator, delay: SimTime</span>
<span class="w"> </span>    Raise a :exc:`ValueError` if ``delay &lt;= 0``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if delay &lt;= 0:</span>
<span class="gi">+        raise ValueError(&quot;delay must be &gt; 0&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    def delayed_process():</span>
<span class="gi">+        yield env.timeout(delay)</span>
<span class="gi">+        yield from generator</span>
<span class="gi">+</span>
<span class="gi">+    return env.process(delayed_process())</span>


<span class="w"> </span>def subscribe_at(event: Event) -&gt;None:
<span class="gu">@@ -45,4 +52,11 @@ def subscribe_at(event: Event) -&gt;None:</span>
<span class="w"> </span>    Raise a :exc:`RuntimeError` if ``event`` has already occurred.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if event.triggered:</span>
<span class="gi">+        raise RuntimeError(&quot;Cannot subscribe to an event that has already occurred&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    def interrupt_callback(event):</span>
<span class="gi">+        import simpy</span>
<span class="gi">+        simpy.exceptions.Interrupt(event.value)</span>
<span class="gi">+</span>
<span class="gi">+    event.callbacks.append(interrupt_callback)</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>