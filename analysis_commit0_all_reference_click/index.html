
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference click - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-click" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference click
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_chainpytest_multicommand_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_chain.py::test_multicommand_chaining
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-click"><strong>Reference (Gold)</strong>: click</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">589</td>
</tr>
<tr>
<td style="text-align: left;">xfailed</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">21</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">611</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">611</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_chainpytest_multicommand_chaining">test_chain.py::test_multicommand_chaining</h3>
<details><summary> <pre>test_chain.py::test_multicommand_chaining</pre></summary><pre>
runner = <click.testing.CliRunner object at 0x7fe095889150>

    @pytest.mark.xfail
    def test_multicommand_chaining(runner):
        @click.group(chain=True)
        def cli():
            debug()

        @cli.group()
>       def l1a():

tests/test_chain.py:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/click/core.py:1942: in decorator
    self.add_command(cmd)
src/click/core.py:1842: in add_command
    _check_multicommand(self, name, cmd, register=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_command = <Group cli>, cmd_name = 'l1a', cmd = <Group l1a>, register = True

    def _check_multicommand(
        base_command: "MultiCommand", cmd_name: str, cmd: "Command", register: bool = False
    ) -> None:
        if not base_command.chain or not isinstance(cmd, MultiCommand):
            return
        if register:
            hint = (
                "It is not possible to add multi commands as children to"
                " another multi command that is in chain mode."
            )
        else:
            hint = (
                "Found a multi command as subcommand to a multi command"
                " that is in chain mode. This is not supported."
            )
>       raise RuntimeError(
            f"{hint}. Command {base_command.name!r} is set to chain and"
            f" {cmd_name!r} was added as a subcommand but it in itself is a"
            f" multi command. ({cmd_name!r} is a {type(cmd).__name__}"
            f" within a chained {type(base_command).__name__} named"
            f" {base_command.name!r})."
        )
E       RuntimeError: It is not possible to add multi commands as children to another multi command that is in chain mode.. Command 'cli' is set to chain and 'l1a' was added as a subcommand but it in itself is a multi command. ('l1a' is a Group within a chained Group named 'cli').

src/click/core.py:82: RuntimeError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/click/_compat.py b/src/click/_compat.py</span>
<span class="gh">index 7f5b9af..23f8866 100644</span>
<span class="gd">--- a/src/click/_compat.py</span>
<span class="gi">+++ b/src/click/_compat.py</span>
<span class="gu">@@ -5,37 +5,75 @@ import re</span>
<span class="w"> </span>import sys
<span class="w"> </span>import typing as t
<span class="w"> </span>from weakref import WeakKeyDictionary
<span class="gd">-CYGWIN = sys.platform.startswith(&#39;cygwin&#39;)</span>
<span class="gd">-WIN = sys.platform.startswith(&#39;win&#39;)</span>
<span class="gi">+</span>
<span class="gi">+CYGWIN = sys.platform.startswith(&quot;cygwin&quot;)</span>
<span class="gi">+WIN = sys.platform.startswith(&quot;win&quot;)</span>
<span class="w"> </span>auto_wrap_for_ansi: t.Optional[t.Callable[[t.TextIO], t.TextIO]] = None
<span class="gd">-_ansi_re = re.compile(&#39;\\033\\[[;?0-9]*[a-zA-Z]&#39;)</span>
<span class="gi">+_ansi_re = re.compile(r&quot;\033\[[;?0-9]*[a-zA-Z]&quot;)</span>
<span class="gi">+</span>

<span class="gi">+def _make_text_stream(</span>
<span class="gi">+    stream: t.BinaryIO,</span>
<span class="gi">+    encoding: t.Optional[str],</span>
<span class="gi">+    errors: t.Optional[str],</span>
<span class="gi">+    force_readable: bool = False,</span>
<span class="gi">+    force_writable: bool = False,</span>
<span class="gi">+) -&gt; t.TextIO:</span>
<span class="gi">+    if encoding is None:</span>
<span class="gi">+        encoding = get_best_encoding(stream)</span>
<span class="gi">+    if errors is None:</span>
<span class="gi">+        errors = &quot;replace&quot;</span>
<span class="gi">+    return _NonClosingTextIOWrapper(</span>
<span class="gi">+        stream,</span>
<span class="gi">+        encoding,</span>
<span class="gi">+        errors,</span>
<span class="gi">+        line_buffering=True,</span>
<span class="gi">+        force_readable=force_readable,</span>
<span class="gi">+        force_writable=force_writable,</span>
<span class="gi">+    )</span>

<span class="gd">-def is_ascii_encoding(encoding: str) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+def is_ascii_encoding(encoding: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Checks if a given encoding is ascii.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return codecs.lookup(encoding).name == &quot;ascii&quot;</span>
<span class="gi">+    except LookupError:</span>
<span class="gi">+        return False</span>


<span class="gd">-def get_best_encoding(stream: t.IO[t.Any]) -&gt;str:</span>
<span class="gi">+def get_best_encoding(stream: t.IO[t.Any]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the default stream encoding if not found.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rv = getattr(stream, &quot;encoding&quot;, None) or sys.getdefaultencoding()</span>
<span class="gi">+    if is_ascii_encoding(rv):</span>
<span class="gi">+        return &quot;utf-8&quot;</span>
<span class="gi">+    return rv</span>


<span class="w"> </span>class _NonClosingTextIOWrapper(io.TextIOWrapper):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, stream: t.BinaryIO, encoding: t.Optional[str],</span>
<span class="gd">-        errors: t.Optional[str], force_readable: bool=False, force_writable:</span>
<span class="gd">-        bool=False, **extra: t.Any) -&gt;None:</span>
<span class="gd">-        self._stream = stream = t.cast(t.BinaryIO, _FixupStream(stream,</span>
<span class="gd">-            force_readable, force_writable))</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        stream: t.BinaryIO,</span>
<span class="gi">+        encoding: t.Optional[str],</span>
<span class="gi">+        errors: t.Optional[str],</span>
<span class="gi">+        force_readable: bool = False,</span>
<span class="gi">+        force_writable: bool = False,</span>
<span class="gi">+        **extra: t.Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self._stream = stream = t.cast(</span>
<span class="gi">+            t.BinaryIO, _FixupStream(stream, force_readable, force_writable)</span>
<span class="gi">+        )</span>
<span class="w"> </span>        super().__init__(stream, encoding, errors, **extra)

<span class="gd">-    def __del__(self) -&gt;None:</span>
<span class="gi">+    def __del__(self) -&gt; None:</span>
<span class="w"> </span>        try:
<span class="w"> </span>            self.detach()
<span class="w"> </span>        except Exception:
<span class="w"> </span>            pass

<span class="gi">+    def isatty(self) -&gt; bool:</span>
<span class="gi">+        # https://bitbucket.org/pypy/pypy/issue/1803</span>
<span class="gi">+        return self._stream.isatty()</span>
<span class="gi">+</span>

<span class="w"> </span>class _FixupStream:
<span class="w"> </span>    &quot;&quot;&quot;The new io interface needs more from streams than streams
<span class="gu">@@ -47,86 +85,539 @@ class _FixupStream:</span>
<span class="w"> </span>    of jupyter notebook).
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, stream: t.BinaryIO, force_readable: bool=False,</span>
<span class="gd">-        force_writable: bool=False):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        stream: t.BinaryIO,</span>
<span class="gi">+        force_readable: bool = False,</span>
<span class="gi">+        force_writable: bool = False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self._stream = stream
<span class="w"> </span>        self._force_readable = force_readable
<span class="w"> </span>        self._force_writable = force_writable

<span class="gd">-    def __getattr__(self, name: str) -&gt;t.Any:</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; t.Any:</span>
<span class="w"> </span>        return getattr(self._stream, name)

<span class="gi">+    def read1(self, size: int) -&gt; bytes:</span>
<span class="gi">+        f = getattr(self._stream, &quot;read1&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        if f is not None:</span>
<span class="gi">+            return t.cast(bytes, f(size))</span>
<span class="gi">+</span>
<span class="gi">+        return self._stream.read(size)</span>
<span class="gi">+</span>
<span class="gi">+    def readable(self) -&gt; bool:</span>
<span class="gi">+        if self._force_readable:</span>
<span class="gi">+            return True</span>
<span class="gi">+        x = getattr(self._stream, &quot;readable&quot;, None)</span>
<span class="gi">+        if x is not None:</span>
<span class="gi">+            return t.cast(bool, x())</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._stream.read(0)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def writable(self) -&gt; bool:</span>
<span class="gi">+        if self._force_writable:</span>
<span class="gi">+            return True</span>
<span class="gi">+        x = getattr(self._stream, &quot;writable&quot;, None)</span>
<span class="gi">+        if x is not None:</span>
<span class="gi">+            return t.cast(bool, x())</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._stream.write(&quot;&quot;)  # type: ignore</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._stream.write(b&quot;&quot;)</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def seekable(self) -&gt; bool:</span>
<span class="gi">+        x = getattr(self._stream, &quot;seekable&quot;, None)</span>
<span class="gi">+        if x is not None:</span>
<span class="gi">+            return t.cast(bool, x())</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._stream.seek(self._stream.tell())</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_binary_reader(stream: t.IO[t.Any], default: bool = False) -&gt; bool:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return isinstance(stream.read(0), bytes)</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return default</span>
<span class="gi">+        # This happens in some cases where the stream was already</span>
<span class="gi">+        # closed.  In this case, we assume the default.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_binary_writer(stream: t.IO[t.Any], default: bool = False) -&gt; bool:</span>
<span class="gi">+    try:</span>
<span class="gi">+        stream.write(b&quot;&quot;)</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        try:</span>
<span class="gi">+            stream.write(&quot;&quot;)</span>
<span class="gi">+            return False</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return default</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_binary_reader(stream: t.IO[t.Any]) -&gt; t.Optional[t.BinaryIO]:</span>
<span class="gi">+    # We need to figure out if the given stream is already binary.</span>
<span class="gi">+    # This can happen because the official docs recommend detaching</span>
<span class="gi">+    # the streams to get binary streams.  Some code might do this, so</span>
<span class="gi">+    # we need to deal with this case explicitly.</span>
<span class="gi">+    if _is_binary_reader(stream, False):</span>
<span class="gi">+        return t.cast(t.BinaryIO, stream)</span>
<span class="gi">+</span>
<span class="gi">+    buf = getattr(stream, &quot;buffer&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+    # Same situation here; this time we assume that the buffer is</span>
<span class="gi">+    # actually binary in case it&#39;s closed.</span>
<span class="gi">+    if buf is not None and _is_binary_reader(buf, True):</span>
<span class="gi">+        return t.cast(t.BinaryIO, buf)</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_binary_writer(stream: t.IO[t.Any]) -&gt; t.Optional[t.BinaryIO]:</span>
<span class="gi">+    # We need to figure out if the given stream is already binary.</span>
<span class="gi">+    # This can happen because the official docs recommend detaching</span>
<span class="gi">+    # the streams to get binary streams.  Some code might do this, so</span>
<span class="gi">+    # we need to deal with this case explicitly.</span>
<span class="gi">+    if _is_binary_writer(stream, False):</span>
<span class="gi">+        return t.cast(t.BinaryIO, stream)</span>

<span class="gd">-def _stream_is_misconfigured(stream: t.TextIO) -&gt;bool:</span>
<span class="gi">+    buf = getattr(stream, &quot;buffer&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+    # Same situation here; this time we assume that the buffer is</span>
<span class="gi">+    # actually binary in case it&#39;s closed.</span>
<span class="gi">+    if buf is not None and _is_binary_writer(buf, True):</span>
<span class="gi">+        return t.cast(t.BinaryIO, buf)</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _stream_is_misconfigured(stream: t.TextIO) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;A stream is misconfigured if its encoding is ASCII.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # If the stream does not have an encoding set, we assume it&#39;s set</span>
<span class="gi">+    # to ASCII.  This appears to happen in certain unittest</span>
<span class="gi">+    # environments.  It&#39;s not quite clear what the correct behavior is</span>
<span class="gi">+    # but this at least will force Click to recover somehow.</span>
<span class="gi">+    return is_ascii_encoding(getattr(stream, &quot;encoding&quot;, None) or &quot;ascii&quot;)</span>


<span class="gd">-def _is_compat_stream_attr(stream: t.TextIO, attr: str, value: t.Optional[str]</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+def _is_compat_stream_attr(stream: t.TextIO, attr: str, value: t.Optional[str]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;A stream attribute is compatible if it is equal to the
<span class="w"> </span>    desired value or the desired value is unset and the attribute
<span class="w"> </span>    has a value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    stream_value = getattr(stream, attr, None)</span>
<span class="gi">+    return stream_value == value or (value is None and stream_value is not None)</span>


<span class="gd">-def _is_compatible_text_stream(stream: t.TextIO, encoding: t.Optional[str],</span>
<span class="gd">-    errors: t.Optional[str]) -&gt;bool:</span>
<span class="gi">+def _is_compatible_text_stream(</span>
<span class="gi">+    stream: t.TextIO, encoding: t.Optional[str], errors: t.Optional[str]</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if a stream&#39;s encoding and errors attributes are
<span class="w"> </span>    compatible with the desired values.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _is_compat_stream_attr(</span>
<span class="gi">+        stream, &quot;encoding&quot;, encoding</span>
<span class="gi">+    ) and _is_compat_stream_attr(stream, &quot;errors&quot;, errors)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _force_correct_text_stream(</span>
<span class="gi">+    text_stream: t.IO[t.Any],</span>
<span class="gi">+    encoding: t.Optional[str],</span>
<span class="gi">+    errors: t.Optional[str],</span>
<span class="gi">+    is_binary: t.Callable[[t.IO[t.Any], bool], bool],</span>
<span class="gi">+    find_binary: t.Callable[[t.IO[t.Any]], t.Optional[t.BinaryIO]],</span>
<span class="gi">+    force_readable: bool = False,</span>
<span class="gi">+    force_writable: bool = False,</span>
<span class="gi">+) -&gt; t.TextIO:</span>
<span class="gi">+    if is_binary(text_stream, False):</span>
<span class="gi">+        binary_reader = t.cast(t.BinaryIO, text_stream)</span>
<span class="gi">+    else:</span>
<span class="gi">+        text_stream = t.cast(t.TextIO, text_stream)</span>
<span class="gi">+        # If the stream looks compatible, and won&#39;t default to a</span>
<span class="gi">+        # misconfigured ascii encoding, return it as-is.</span>
<span class="gi">+        if _is_compatible_text_stream(text_stream, encoding, errors) and not (</span>
<span class="gi">+            encoding is None and _stream_is_misconfigured(text_stream)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return text_stream</span>
<span class="gi">+</span>
<span class="gi">+        # Otherwise, get the underlying binary reader.</span>
<span class="gi">+        possible_binary_reader = find_binary(text_stream)</span>
<span class="gi">+</span>
<span class="gi">+        # If that&#39;s not possible, silently use the original reader</span>
<span class="gi">+        # and get mojibake instead of exceptions.</span>
<span class="gi">+        if possible_binary_reader is None:</span>
<span class="gi">+            return text_stream</span>
<span class="gi">+</span>
<span class="gi">+        binary_reader = possible_binary_reader</span>
<span class="gi">+</span>
<span class="gi">+    # Default errors to replace instead of strict in order to get</span>
<span class="gi">+    # something that works.</span>
<span class="gi">+    if errors is None:</span>
<span class="gi">+        errors = &quot;replace&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Wrap the binary stream in a text stream with the correct</span>
<span class="gi">+    # encoding parameters.</span>
<span class="gi">+    return _make_text_stream(</span>
<span class="gi">+        binary_reader,</span>
<span class="gi">+        encoding,</span>
<span class="gi">+        errors,</span>
<span class="gi">+        force_readable=force_readable,</span>
<span class="gi">+        force_writable=force_writable,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _force_correct_text_reader(</span>
<span class="gi">+    text_reader: t.IO[t.Any],</span>
<span class="gi">+    encoding: t.Optional[str],</span>
<span class="gi">+    errors: t.Optional[str],</span>
<span class="gi">+    force_readable: bool = False,</span>
<span class="gi">+) -&gt; t.TextIO:</span>
<span class="gi">+    return _force_correct_text_stream(</span>
<span class="gi">+        text_reader,</span>
<span class="gi">+        encoding,</span>
<span class="gi">+        errors,</span>
<span class="gi">+        _is_binary_reader,</span>
<span class="gi">+        _find_binary_reader,</span>
<span class="gi">+        force_readable=force_readable,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _force_correct_text_writer(</span>
<span class="gi">+    text_writer: t.IO[t.Any],</span>
<span class="gi">+    encoding: t.Optional[str],</span>
<span class="gi">+    errors: t.Optional[str],</span>
<span class="gi">+    force_writable: bool = False,</span>
<span class="gi">+) -&gt; t.TextIO:</span>
<span class="gi">+    return _force_correct_text_stream(</span>
<span class="gi">+        text_writer,</span>
<span class="gi">+        encoding,</span>
<span class="gi">+        errors,</span>
<span class="gi">+        _is_binary_writer,</span>
<span class="gi">+        _find_binary_writer,</span>
<span class="gi">+        force_writable=force_writable,</span>
<span class="gi">+    )</span>


<span class="gd">-def _wrap_io_open(file: t.Union[str, &#39;os.PathLike[str]&#39;, int], mode: str,</span>
<span class="gd">-    encoding: t.Optional[str], errors: t.Optional[str]) -&gt;t.IO[t.Any]:</span>
<span class="gi">+def get_binary_stdin() -&gt; t.BinaryIO:</span>
<span class="gi">+    reader = _find_binary_reader(sys.stdin)</span>
<span class="gi">+    if reader is None:</span>
<span class="gi">+        raise RuntimeError(&quot;Was not able to determine binary stream for sys.stdin.&quot;)</span>
<span class="gi">+    return reader</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_binary_stdout() -&gt; t.BinaryIO:</span>
<span class="gi">+    writer = _find_binary_writer(sys.stdout)</span>
<span class="gi">+    if writer is None:</span>
<span class="gi">+        raise RuntimeError(&quot;Was not able to determine binary stream for sys.stdout.&quot;)</span>
<span class="gi">+    return writer</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_binary_stderr() -&gt; t.BinaryIO:</span>
<span class="gi">+    writer = _find_binary_writer(sys.stderr)</span>
<span class="gi">+    if writer is None:</span>
<span class="gi">+        raise RuntimeError(&quot;Was not able to determine binary stream for sys.stderr.&quot;)</span>
<span class="gi">+    return writer</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_text_stdin(</span>
<span class="gi">+    encoding: t.Optional[str] = None, errors: t.Optional[str] = None</span>
<span class="gi">+) -&gt; t.TextIO:</span>
<span class="gi">+    rv = _get_windows_console_stream(sys.stdin, encoding, errors)</span>
<span class="gi">+    if rv is not None:</span>
<span class="gi">+        return rv</span>
<span class="gi">+    return _force_correct_text_reader(sys.stdin, encoding, errors, force_readable=True)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_text_stdout(</span>
<span class="gi">+    encoding: t.Optional[str] = None, errors: t.Optional[str] = None</span>
<span class="gi">+) -&gt; t.TextIO:</span>
<span class="gi">+    rv = _get_windows_console_stream(sys.stdout, encoding, errors)</span>
<span class="gi">+    if rv is not None:</span>
<span class="gi">+        return rv</span>
<span class="gi">+    return _force_correct_text_writer(sys.stdout, encoding, errors, force_writable=True)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_text_stderr(</span>
<span class="gi">+    encoding: t.Optional[str] = None, errors: t.Optional[str] = None</span>
<span class="gi">+) -&gt; t.TextIO:</span>
<span class="gi">+    rv = _get_windows_console_stream(sys.stderr, encoding, errors)</span>
<span class="gi">+    if rv is not None:</span>
<span class="gi">+        return rv</span>
<span class="gi">+    return _force_correct_text_writer(sys.stderr, encoding, errors, force_writable=True)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _wrap_io_open(</span>
<span class="gi">+    file: t.Union[str, &quot;os.PathLike[str]&quot;, int],</span>
<span class="gi">+    mode: str,</span>
<span class="gi">+    encoding: t.Optional[str],</span>
<span class="gi">+    errors: t.Optional[str],</span>
<span class="gi">+) -&gt; t.IO[t.Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Handles not passing ``encoding`` and ``errors`` in binary mode.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &quot;b&quot; in mode:</span>
<span class="gi">+        return open(file, mode)</span>

<span class="gi">+    return open(file, mode, encoding=encoding, errors=errors)</span>

<span class="gd">-class _AtomicFile:</span>

<span class="gd">-    def __init__(self, f: t.IO[t.Any], tmp_filename: str, real_filename: str</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+def open_stream(</span>
<span class="gi">+    filename: &quot;t.Union[str, os.PathLike[str]]&quot;,</span>
<span class="gi">+    mode: str = &quot;r&quot;,</span>
<span class="gi">+    encoding: t.Optional[str] = None,</span>
<span class="gi">+    errors: t.Optional[str] = &quot;strict&quot;,</span>
<span class="gi">+    atomic: bool = False,</span>
<span class="gi">+) -&gt; t.Tuple[t.IO[t.Any], bool]:</span>
<span class="gi">+    binary = &quot;b&quot; in mode</span>
<span class="gi">+    filename = os.fspath(filename)</span>
<span class="gi">+</span>
<span class="gi">+    # Standard streams first. These are simple because they ignore the</span>
<span class="gi">+    # atomic flag. Use fsdecode to handle Path(&quot;-&quot;).</span>
<span class="gi">+    if os.fsdecode(filename) == &quot;-&quot;:</span>
<span class="gi">+        if any(m in mode for m in [&quot;w&quot;, &quot;a&quot;, &quot;x&quot;]):</span>
<span class="gi">+            if binary:</span>
<span class="gi">+                return get_binary_stdout(), False</span>
<span class="gi">+            return get_text_stdout(encoding=encoding, errors=errors), False</span>
<span class="gi">+        if binary:</span>
<span class="gi">+            return get_binary_stdin(), False</span>
<span class="gi">+        return get_text_stdin(encoding=encoding, errors=errors), False</span>
<span class="gi">+</span>
<span class="gi">+    # Non-atomic writes directly go out through the regular open functions.</span>
<span class="gi">+    if not atomic:</span>
<span class="gi">+        return _wrap_io_open(filename, mode, encoding, errors), True</span>
<span class="gi">+</span>
<span class="gi">+    # Some usability stuff for atomic writes</span>
<span class="gi">+    if &quot;a&quot; in mode:</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            &quot;Appending to an existing file is not supported, because that&quot;</span>
<span class="gi">+            &quot; would involve an expensive `copy`-operation to a temporary&quot;</span>
<span class="gi">+            &quot; file. Open the file in normal `w`-mode and copy explicitly&quot;</span>
<span class="gi">+            &quot; if that&#39;s what you&#39;re after.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    if &quot;x&quot; in mode:</span>
<span class="gi">+        raise ValueError(&quot;Use the `overwrite`-parameter instead.&quot;)</span>
<span class="gi">+    if &quot;w&quot; not in mode:</span>
<span class="gi">+        raise ValueError(&quot;Atomic writes only make sense with `w`-mode.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Atomic writes are more complicated.  They work by opening a file</span>
<span class="gi">+    # as a proxy in the same folder and then using the fdopen</span>
<span class="gi">+    # functionality to wrap it in a Python file.  Then we wrap it in an</span>
<span class="gi">+    # atomic file that moves the file over on close.</span>
<span class="gi">+    import errno</span>
<span class="gi">+    import random</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        perm: t.Optional[int] = os.stat(filename).st_mode</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        perm = None</span>
<span class="gi">+</span>
<span class="gi">+    flags = os.O_RDWR | os.O_CREAT | os.O_EXCL</span>
<span class="gi">+</span>
<span class="gi">+    if binary:</span>
<span class="gi">+        flags |= getattr(os, &quot;O_BINARY&quot;, 0)</span>
<span class="gi">+</span>
<span class="gi">+    while True:</span>
<span class="gi">+        tmp_filename = os.path.join(</span>
<span class="gi">+            os.path.dirname(filename),</span>
<span class="gi">+            f&quot;.__atomic-write{random.randrange(1 &lt;&lt; 32):08x}&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        try:</span>
<span class="gi">+            fd = os.open(tmp_filename, flags, 0o666 if perm is None else perm)</span>
<span class="gi">+            break</span>
<span class="gi">+        except OSError as e:</span>
<span class="gi">+            if e.errno == errno.EEXIST or (</span>
<span class="gi">+                os.name == &quot;nt&quot;</span>
<span class="gi">+                and e.errno == errno.EACCES</span>
<span class="gi">+                and os.path.isdir(e.filename)</span>
<span class="gi">+                and os.access(e.filename, os.W_OK)</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+    if perm is not None:</span>
<span class="gi">+        os.chmod(tmp_filename, perm)  # in case perm includes bits in umask</span>
<span class="gi">+</span>
<span class="gi">+    f = _wrap_io_open(fd, mode, encoding, errors)</span>
<span class="gi">+    af = _AtomicFile(f, tmp_filename, os.path.realpath(filename))</span>
<span class="gi">+    return t.cast(t.IO[t.Any], af), True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class _AtomicFile:</span>
<span class="gi">+    def __init__(self, f: t.IO[t.Any], tmp_filename: str, real_filename: str) -&gt; None:</span>
<span class="w"> </span>        self._f = f
<span class="w"> </span>        self._tmp_filename = tmp_filename
<span class="w"> </span>        self._real_filename = real_filename
<span class="w"> </span>        self.closed = False

<span class="gd">-    def __getattr__(self, name: str) -&gt;t.Any:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; str:</span>
<span class="gi">+        return self._real_filename</span>
<span class="gi">+</span>
<span class="gi">+    def close(self, delete: bool = False) -&gt; None:</span>
<span class="gi">+        if self.closed:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._f.close()</span>
<span class="gi">+        os.replace(self._tmp_filename, self._real_filename)</span>
<span class="gi">+        self.closed = True</span>
<span class="gi">+</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; t.Any:</span>
<span class="w"> </span>        return getattr(self._f, name)

<span class="gd">-    def __enter__(self) -&gt;&#39;_AtomicFile&#39;:</span>
<span class="gi">+    def __enter__(self) -&gt; &quot;_AtomicFile&quot;:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __exit__(self, exc_type: t.Optional[t.Type[BaseException]], *_: t.Any</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __exit__(self, exc_type: t.Optional[t.Type[BaseException]], *_: t.Any) -&gt; None:</span>
<span class="w"> </span>        self.close(delete=exc_type is not None)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return repr(self._f)


<span class="gd">-if sys.platform.startswith(&#39;win&#39;) and WIN:</span>
<span class="gi">+def strip_ansi(value: str) -&gt; str:</span>
<span class="gi">+    return _ansi_re.sub(&quot;&quot;, value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_jupyter_kernel_output(stream: t.IO[t.Any]) -&gt; bool:</span>
<span class="gi">+    while isinstance(stream, (_FixupStream, _NonClosingTextIOWrapper)):</span>
<span class="gi">+        stream = stream._stream</span>
<span class="gi">+</span>
<span class="gi">+    return stream.__class__.__module__.startswith(&quot;ipykernel.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def should_strip_ansi(</span>
<span class="gi">+    stream: t.Optional[t.IO[t.Any]] = None, color: t.Optional[bool] = None</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    if color is None:</span>
<span class="gi">+        if stream is None:</span>
<span class="gi">+            stream = sys.stdin</span>
<span class="gi">+        return not isatty(stream) and not _is_jupyter_kernel_output(stream)</span>
<span class="gi">+    return not color</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# On Windows, wrap the output streams with colorama to support ANSI</span>
<span class="gi">+# color codes.</span>
<span class="gi">+# NOTE: double check is needed so mypy does not analyze this on Linux</span>
<span class="gi">+if sys.platform.startswith(&quot;win&quot;) and WIN:</span>
<span class="w"> </span>    from ._winconsole import _get_windows_console_stream
<span class="gd">-    _ansi_stream_wrappers: t.MutableMapping[t.TextIO, t.TextIO</span>
<span class="gd">-        ] = WeakKeyDictionary()</span>

<span class="gd">-    def auto_wrap_for_ansi(stream: t.TextIO, color: t.Optional[bool]=None</span>
<span class="gd">-        ) -&gt;t.TextIO:</span>
<span class="gi">+    def _get_argv_encoding() -&gt; str:</span>
<span class="gi">+        import locale</span>
<span class="gi">+</span>
<span class="gi">+        return locale.getpreferredencoding()</span>
<span class="gi">+</span>
<span class="gi">+    _ansi_stream_wrappers: t.MutableMapping[t.TextIO, t.TextIO] = WeakKeyDictionary()</span>
<span class="gi">+</span>
<span class="gi">+    def auto_wrap_for_ansi(  # noqa: F811</span>
<span class="gi">+        stream: t.TextIO, color: t.Optional[bool] = None</span>
<span class="gi">+    ) -&gt; t.TextIO:</span>
<span class="w"> </span>        &quot;&quot;&quot;Support ANSI color and style codes on Windows by wrapping a
<span class="w"> </span>        stream with colorama.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-_default_text_stdin = _make_cached_stream_func(lambda : sys.stdin,</span>
<span class="gd">-    get_text_stdin)</span>
<span class="gd">-_default_text_stdout = _make_cached_stream_func(lambda : sys.stdout,</span>
<span class="gd">-    get_text_stdout)</span>
<span class="gd">-_default_text_stderr = _make_cached_stream_func(lambda : sys.stderr,</span>
<span class="gd">-    get_text_stderr)</span>
<span class="gd">-binary_streams: t.Mapping[str, t.Callable[[], t.BinaryIO]] = {&#39;stdin&#39;:</span>
<span class="gd">-    get_binary_stdin, &#39;stdout&#39;: get_binary_stdout, &#39;stderr&#39;: get_binary_stderr}</span>
<span class="gd">-text_streams: t.Mapping[str, t.Callable[[t.Optional[str], t.Optional[str]],</span>
<span class="gd">-    t.TextIO]] = {&#39;stdin&#39;: get_text_stdin, &#39;stdout&#39;: get_text_stdout,</span>
<span class="gd">-    &#39;stderr&#39;: get_text_stderr}</span>
<span class="gi">+        try:</span>
<span class="gi">+            cached = _ansi_stream_wrappers.get(stream)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            cached = None</span>
<span class="gi">+</span>
<span class="gi">+        if cached is not None:</span>
<span class="gi">+            return cached</span>
<span class="gi">+</span>
<span class="gi">+        import colorama</span>
<span class="gi">+</span>
<span class="gi">+        strip = should_strip_ansi(stream, color)</span>
<span class="gi">+        ansi_wrapper = colorama.AnsiToWin32(stream, strip=strip)</span>
<span class="gi">+        rv = t.cast(t.TextIO, ansi_wrapper.stream)</span>
<span class="gi">+        _write = rv.write</span>
<span class="gi">+</span>
<span class="gi">+        def _safe_write(s):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return _write(s)</span>
<span class="gi">+            except BaseException:</span>
<span class="gi">+                ansi_wrapper.reset_all()</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+        rv.write = _safe_write</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            _ansi_stream_wrappers[stream] = rv</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+else:</span>
<span class="gi">+</span>
<span class="gi">+    def _get_argv_encoding() -&gt; str:</span>
<span class="gi">+        return getattr(sys.stdin, &quot;encoding&quot;, None) or sys.getfilesystemencoding()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_windows_console_stream(</span>
<span class="gi">+        f: t.TextIO, encoding: t.Optional[str], errors: t.Optional[str]</span>
<span class="gi">+    ) -&gt; t.Optional[t.TextIO]:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def term_len(x: str) -&gt; int:</span>
<span class="gi">+    return len(strip_ansi(x))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def isatty(stream: t.IO[t.Any]) -&gt; bool:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return stream.isatty()</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_cached_stream_func(</span>
<span class="gi">+    src_func: t.Callable[[], t.Optional[t.TextIO]],</span>
<span class="gi">+    wrapper_func: t.Callable[[], t.TextIO],</span>
<span class="gi">+) -&gt; t.Callable[[], t.Optional[t.TextIO]]:</span>
<span class="gi">+    cache: t.MutableMapping[t.TextIO, t.TextIO] = WeakKeyDictionary()</span>
<span class="gi">+</span>
<span class="gi">+    def func() -&gt; t.Optional[t.TextIO]:</span>
<span class="gi">+        stream = src_func()</span>
<span class="gi">+</span>
<span class="gi">+        if stream is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            rv = cache.get(stream)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            rv = None</span>
<span class="gi">+        if rv is not None:</span>
<span class="gi">+            return rv</span>
<span class="gi">+        rv = wrapper_func()</span>
<span class="gi">+        try:</span>
<span class="gi">+            cache[stream] = rv</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    return func</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_default_text_stdin = _make_cached_stream_func(lambda: sys.stdin, get_text_stdin)</span>
<span class="gi">+_default_text_stdout = _make_cached_stream_func(lambda: sys.stdout, get_text_stdout)</span>
<span class="gi">+_default_text_stderr = _make_cached_stream_func(lambda: sys.stderr, get_text_stderr)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+binary_streams: t.Mapping[str, t.Callable[[], t.BinaryIO]] = {</span>
<span class="gi">+    &quot;stdin&quot;: get_binary_stdin,</span>
<span class="gi">+    &quot;stdout&quot;: get_binary_stdout,</span>
<span class="gi">+    &quot;stderr&quot;: get_binary_stderr,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+text_streams: t.Mapping[</span>
<span class="gi">+    str, t.Callable[[t.Optional[str], t.Optional[str]], t.TextIO]</span>
<span class="gi">+] = {</span>
<span class="gi">+    &quot;stdin&quot;: get_text_stdin,</span>
<span class="gi">+    &quot;stdout&quot;: get_text_stdout,</span>
<span class="gi">+    &quot;stderr&quot;: get_text_stderr,</span>
<span class="gi">+}</span>
<span class="gh">diff --git a/src/click/_termui_impl.py b/src/click/_termui_impl.py</span>
<span class="gh">index 4ed4097..f744657 100644</span>
<span class="gd">--- a/src/click/_termui_impl.py</span>
<span class="gi">+++ b/src/click/_termui_impl.py</span>
<span class="gu">@@ -12,6 +12,7 @@ import typing as t</span>
<span class="w"> </span>from gettext import gettext as _
<span class="w"> </span>from io import StringIO
<span class="w"> </span>from types import TracebackType
<span class="gi">+</span>
<span class="w"> </span>from ._compat import _default_text_stdout
<span class="w"> </span>from ._compat import CYGWIN
<span class="w"> </span>from ._compat import get_best_encoding
<span class="gu">@@ -22,25 +23,36 @@ from ._compat import term_len</span>
<span class="w"> </span>from ._compat import WIN
<span class="w"> </span>from .exceptions import ClickException
<span class="w"> </span>from .utils import echo
<span class="gd">-V = t.TypeVar(&#39;V&#39;)</span>
<span class="gd">-if os.name == &#39;nt&#39;:</span>
<span class="gd">-    BEFORE_BAR = &#39;\r&#39;</span>
<span class="gd">-    AFTER_BAR = &#39;\n&#39;</span>
<span class="gi">+</span>
<span class="gi">+V = t.TypeVar(&quot;V&quot;)</span>
<span class="gi">+</span>
<span class="gi">+if os.name == &quot;nt&quot;:</span>
<span class="gi">+    BEFORE_BAR = &quot;\r&quot;</span>
<span class="gi">+    AFTER_BAR = &quot;\n&quot;</span>
<span class="w"> </span>else:
<span class="gd">-    BEFORE_BAR = &#39;\r\x1b[?25l&#39;</span>
<span class="gd">-    AFTER_BAR = &#39;\x1b[?25h\n&#39;</span>
<span class="gi">+    BEFORE_BAR = &quot;\r\033[?25l&quot;</span>
<span class="gi">+    AFTER_BAR = &quot;\033[?25h\n&quot;</span>


<span class="w"> </span>class ProgressBar(t.Generic[V]):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, iterable: t.Optional[t.Iterable[V]], length: t.</span>
<span class="gd">-        Optional[int]=None, fill_char: str=&#39;#&#39;, empty_char: str=&#39; &#39;,</span>
<span class="gd">-        bar_template: str=&#39;%(bar)s&#39;, info_sep: str=&#39;  &#39;, show_eta: bool=</span>
<span class="gd">-        True, show_percent: t.Optional[bool]=None, show_pos: bool=False,</span>
<span class="gd">-        item_show_func: t.Optional[t.Callable[[t.Optional[V]], t.Optional[</span>
<span class="gd">-        str]]]=None, label: t.Optional[str]=None, file: t.Optional[t.TextIO</span>
<span class="gd">-        ]=None, color: t.Optional[bool]=None, update_min_steps: int=1,</span>
<span class="gd">-        width: int=30) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        iterable: t.Optional[t.Iterable[V]],</span>
<span class="gi">+        length: t.Optional[int] = None,</span>
<span class="gi">+        fill_char: str = &quot;#&quot;,</span>
<span class="gi">+        empty_char: str = &quot; &quot;,</span>
<span class="gi">+        bar_template: str = &quot;%(bar)s&quot;,</span>
<span class="gi">+        info_sep: str = &quot;  &quot;,</span>
<span class="gi">+        show_eta: bool = True,</span>
<span class="gi">+        show_percent: t.Optional[bool] = None,</span>
<span class="gi">+        show_pos: bool = False,</span>
<span class="gi">+        item_show_func: t.Optional[t.Callable[[t.Optional[V]], t.Optional[str]]] = None,</span>
<span class="gi">+        label: t.Optional[str] = None,</span>
<span class="gi">+        file: t.Optional[t.TextIO] = None,</span>
<span class="gi">+        color: t.Optional[bool] = None,</span>
<span class="gi">+        update_min_steps: int = 1,</span>
<span class="gi">+        width: int = 30,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.fill_char = fill_char
<span class="w"> </span>        self.empty_char = empty_char
<span class="w"> </span>        self.bar_template = bar_template
<span class="gu">@@ -49,25 +61,33 @@ class ProgressBar(t.Generic[V]):</span>
<span class="w"> </span>        self.show_percent = show_percent
<span class="w"> </span>        self.show_pos = show_pos
<span class="w"> </span>        self.item_show_func = item_show_func
<span class="gd">-        self.label: str = label or &#39;&#39;</span>
<span class="gi">+        self.label: str = label or &quot;&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        if file is None:
<span class="w"> </span>            file = _default_text_stdout()
<span class="gi">+</span>
<span class="gi">+            # There are no standard streams attached to write to. For example,</span>
<span class="gi">+            # pythonw on Windows.</span>
<span class="w"> </span>            if file is None:
<span class="w"> </span>                file = StringIO()
<span class="gi">+</span>
<span class="w"> </span>        self.file = file
<span class="w"> </span>        self.color = color
<span class="w"> </span>        self.update_min_steps = update_min_steps
<span class="w"> </span>        self._completed_intervals = 0
<span class="w"> </span>        self.width: int = width
<span class="w"> </span>        self.autowidth: bool = width == 0
<span class="gi">+</span>
<span class="w"> </span>        if length is None:
<span class="w"> </span>            from operator import length_hint
<span class="gi">+</span>
<span class="w"> </span>            length = length_hint(iterable, -1)
<span class="gi">+</span>
<span class="w"> </span>            if length == -1:
<span class="w"> </span>                length = None
<span class="w"> </span>        if iterable is None:
<span class="w"> </span>            if length is None:
<span class="gd">-                raise TypeError(&#39;iterable or length is required&#39;)</span>
<span class="gi">+                raise TypeError(&quot;iterable or length is required&quot;)</span>
<span class="w"> </span>            iterable = t.cast(t.Iterable[V], range(length))
<span class="w"> </span>        self.iter: t.Iterable[V] = iter(iterable)
<span class="w"> </span>        self.length = length
<span class="gu">@@ -84,27 +104,195 @@ class ProgressBar(t.Generic[V]):</span>
<span class="w"> </span>        self.is_hidden: bool = not isatty(self.file)
<span class="w"> </span>        self._last_line: t.Optional[str] = None

<span class="gd">-    def __enter__(self) -&gt;&#39;ProgressBar[V]&#39;:</span>
<span class="gi">+    def __enter__(self) -&gt; &quot;ProgressBar[V]&quot;:</span>
<span class="w"> </span>        self.entered = True
<span class="w"> </span>        self.render_progress()
<span class="w"> </span>        return self

<span class="gd">-    def __exit__(self, exc_type: t.Optional[t.Type[BaseException]],</span>
<span class="gd">-        exc_value: t.Optional[BaseException], tb: t.Optional[TracebackType]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exc_type: t.Optional[t.Type[BaseException]],</span>
<span class="gi">+        exc_value: t.Optional[BaseException],</span>
<span class="gi">+        tb: t.Optional[TracebackType],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.render_finish()

<span class="gd">-    def __iter__(self) -&gt;t.Iterator[V]:</span>
<span class="gi">+    def __iter__(self) -&gt; t.Iterator[V]:</span>
<span class="w"> </span>        if not self.entered:
<span class="gd">-            raise RuntimeError(&#39;You need to use progress bars in a with block.&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise RuntimeError(&quot;You need to use progress bars in a with block.&quot;)</span>
<span class="w"> </span>        self.render_progress()
<span class="w"> </span>        return self.generator()

<span class="gd">-    def __next__(self) -&gt;V:</span>
<span class="gi">+    def __next__(self) -&gt; V:</span>
<span class="gi">+        # Iteration is defined in terms of a generator function,</span>
<span class="gi">+        # returned by iter(self); use that to define next(). This works</span>
<span class="gi">+        # because `self.iter` is an iterable consumed by that generator,</span>
<span class="gi">+        # so it is re-entry safe. Calling `next(self.generator())`</span>
<span class="gi">+        # twice works and does &quot;what you want&quot;.</span>
<span class="w"> </span>        return next(iter(self))

<span class="gd">-    def update(self, n_steps: int, current_item: t.Optional[V]=None) -&gt;None:</span>
<span class="gi">+    def render_finish(self) -&gt; None:</span>
<span class="gi">+        if self.is_hidden:</span>
<span class="gi">+            return</span>
<span class="gi">+        self.file.write(AFTER_BAR)</span>
<span class="gi">+        self.file.flush()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def pct(self) -&gt; float:</span>
<span class="gi">+        if self.finished:</span>
<span class="gi">+            return 1.0</span>
<span class="gi">+        return min(self.pos / (float(self.length or 1) or 1), 1.0)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def time_per_iteration(self) -&gt; float:</span>
<span class="gi">+        if not self.avg:</span>
<span class="gi">+            return 0.0</span>
<span class="gi">+        return sum(self.avg) / float(len(self.avg))</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def eta(self) -&gt; float:</span>
<span class="gi">+        if self.length is not None and not self.finished:</span>
<span class="gi">+            return self.time_per_iteration * (self.length - self.pos)</span>
<span class="gi">+        return 0.0</span>
<span class="gi">+</span>
<span class="gi">+    def format_eta(self) -&gt; str:</span>
<span class="gi">+        if self.eta_known:</span>
<span class="gi">+            t = int(self.eta)</span>
<span class="gi">+            seconds = t % 60</span>
<span class="gi">+            t //= 60</span>
<span class="gi">+            minutes = t % 60</span>
<span class="gi">+            t //= 60</span>
<span class="gi">+            hours = t % 24</span>
<span class="gi">+            t //= 24</span>
<span class="gi">+            if t &gt; 0:</span>
<span class="gi">+                return f&quot;{t}d {hours:02}:{minutes:02}:{seconds:02}&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                return f&quot;{hours:02}:{minutes:02}:{seconds:02}&quot;</span>
<span class="gi">+        return &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def format_pos(self) -&gt; str:</span>
<span class="gi">+        pos = str(self.pos)</span>
<span class="gi">+        if self.length is not None:</span>
<span class="gi">+            pos += f&quot;/{self.length}&quot;</span>
<span class="gi">+        return pos</span>
<span class="gi">+</span>
<span class="gi">+    def format_pct(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{int(self.pct * 100): 4}%&quot;[1:]</span>
<span class="gi">+</span>
<span class="gi">+    def format_bar(self) -&gt; str:</span>
<span class="gi">+        if self.length is not None:</span>
<span class="gi">+            bar_length = int(self.pct * self.width)</span>
<span class="gi">+            bar = self.fill_char * bar_length</span>
<span class="gi">+            bar += self.empty_char * (self.width - bar_length)</span>
<span class="gi">+        elif self.finished:</span>
<span class="gi">+            bar = self.fill_char * self.width</span>
<span class="gi">+        else:</span>
<span class="gi">+            chars = list(self.empty_char * (self.width or 1))</span>
<span class="gi">+            if self.time_per_iteration != 0:</span>
<span class="gi">+                chars[</span>
<span class="gi">+                    int(</span>
<span class="gi">+                        (math.cos(self.pos * self.time_per_iteration) / 2.0 + 0.5)</span>
<span class="gi">+                        * self.width</span>
<span class="gi">+                    )</span>
<span class="gi">+                ] = self.fill_char</span>
<span class="gi">+            bar = &quot;&quot;.join(chars)</span>
<span class="gi">+        return bar</span>
<span class="gi">+</span>
<span class="gi">+    def format_progress_line(self) -&gt; str:</span>
<span class="gi">+        show_percent = self.show_percent</span>
<span class="gi">+</span>
<span class="gi">+        info_bits = []</span>
<span class="gi">+        if self.length is not None and show_percent is None:</span>
<span class="gi">+            show_percent = not self.show_pos</span>
<span class="gi">+</span>
<span class="gi">+        if self.show_pos:</span>
<span class="gi">+            info_bits.append(self.format_pos())</span>
<span class="gi">+        if show_percent:</span>
<span class="gi">+            info_bits.append(self.format_pct())</span>
<span class="gi">+        if self.show_eta and self.eta_known and not self.finished:</span>
<span class="gi">+            info_bits.append(self.format_eta())</span>
<span class="gi">+        if self.item_show_func is not None:</span>
<span class="gi">+            item_info = self.item_show_func(self.current_item)</span>
<span class="gi">+            if item_info is not None:</span>
<span class="gi">+                info_bits.append(item_info)</span>
<span class="gi">+</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.bar_template</span>
<span class="gi">+            % {</span>
<span class="gi">+                &quot;label&quot;: self.label,</span>
<span class="gi">+                &quot;bar&quot;: self.format_bar(),</span>
<span class="gi">+                &quot;info&quot;: self.info_sep.join(info_bits),</span>
<span class="gi">+            }</span>
<span class="gi">+        ).rstrip()</span>
<span class="gi">+</span>
<span class="gi">+    def render_progress(self) -&gt; None:</span>
<span class="gi">+        import shutil</span>
<span class="gi">+</span>
<span class="gi">+        if self.is_hidden:</span>
<span class="gi">+            # Only output the label as it changes if the output is not a</span>
<span class="gi">+            # TTY. Use file=stderr if you expect to be piping stdout.</span>
<span class="gi">+            if self._last_line != self.label:</span>
<span class="gi">+                self._last_line = self.label</span>
<span class="gi">+                echo(self.label, file=self.file, color=self.color)</span>
<span class="gi">+</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        buf = []</span>
<span class="gi">+        # Update width in case the terminal has been resized</span>
<span class="gi">+        if self.autowidth:</span>
<span class="gi">+            old_width = self.width</span>
<span class="gi">+            self.width = 0</span>
<span class="gi">+            clutter_length = term_len(self.format_progress_line())</span>
<span class="gi">+            new_width = max(0, shutil.get_terminal_size().columns - clutter_length)</span>
<span class="gi">+            if new_width &lt; old_width:</span>
<span class="gi">+                buf.append(BEFORE_BAR)</span>
<span class="gi">+                buf.append(&quot; &quot; * self.max_width)  # type: ignore</span>
<span class="gi">+                self.max_width = new_width</span>
<span class="gi">+            self.width = new_width</span>
<span class="gi">+</span>
<span class="gi">+        clear_width = self.width</span>
<span class="gi">+        if self.max_width is not None:</span>
<span class="gi">+            clear_width = self.max_width</span>
<span class="gi">+</span>
<span class="gi">+        buf.append(BEFORE_BAR)</span>
<span class="gi">+        line = self.format_progress_line()</span>
<span class="gi">+        line_len = term_len(line)</span>
<span class="gi">+        if self.max_width is None or self.max_width &lt; line_len:</span>
<span class="gi">+            self.max_width = line_len</span>
<span class="gi">+</span>
<span class="gi">+        buf.append(line)</span>
<span class="gi">+        buf.append(&quot; &quot; * (clear_width - line_len))</span>
<span class="gi">+        line = &quot;&quot;.join(buf)</span>
<span class="gi">+        # Render the line only if it changed.</span>
<span class="gi">+</span>
<span class="gi">+        if line != self._last_line:</span>
<span class="gi">+            self._last_line = line</span>
<span class="gi">+            echo(line, file=self.file, color=self.color, nl=False)</span>
<span class="gi">+            self.file.flush()</span>
<span class="gi">+</span>
<span class="gi">+    def make_step(self, n_steps: int) -&gt; None:</span>
<span class="gi">+        self.pos += n_steps</span>
<span class="gi">+        if self.length is not None and self.pos &gt;= self.length:</span>
<span class="gi">+            self.finished = True</span>
<span class="gi">+</span>
<span class="gi">+        if (time.time() - self.last_eta) &lt; 1.0:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.last_eta = time.time()</span>
<span class="gi">+</span>
<span class="gi">+        # self.avg is a rolling list of length &lt;= 7 of steps where steps are</span>
<span class="gi">+        # defined as time elapsed divided by the total progress through</span>
<span class="gi">+        # self.length.</span>
<span class="gi">+        if self.pos:</span>
<span class="gi">+            step = (time.time() - self.start) / self.pos</span>
<span class="gi">+        else:</span>
<span class="gi">+            step = time.time() - self.start</span>
<span class="gi">+</span>
<span class="gi">+        self.avg = self.avg[-6:] + [step]</span>
<span class="gi">+</span>
<span class="gi">+        self.eta_known = self.length is not None</span>
<span class="gi">+</span>
<span class="gi">+    def update(self, n_steps: int, current_item: t.Optional[V] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update the progress bar by advancing a specified number of
<span class="w"> </span>        steps, and optionally set the ``current_item`` for this new
<span class="w"> </span>        position.
<span class="gu">@@ -120,54 +308,432 @@ class ProgressBar(t.Generic[V]):</span>
<span class="w"> </span>            Only render when the number of steps meets the
<span class="w"> </span>            ``update_min_steps`` threshold.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if current_item is not None:</span>
<span class="gi">+            self.current_item = current_item</span>
<span class="gi">+</span>
<span class="gi">+        self._completed_intervals += n_steps</span>

<span class="gd">-    def generator(self) -&gt;t.Iterator[V]:</span>
<span class="gi">+        if self._completed_intervals &gt;= self.update_min_steps:</span>
<span class="gi">+            self.make_step(self._completed_intervals)</span>
<span class="gi">+            self.render_progress()</span>
<span class="gi">+            self._completed_intervals = 0</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        self.eta_known = False</span>
<span class="gi">+        self.current_item = None</span>
<span class="gi">+        self.finished = True</span>
<span class="gi">+</span>
<span class="gi">+    def generator(self) -&gt; t.Iterator[V]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a generator which yields the items added to the bar
<span class="w"> </span>        during construction, and updates the progress bar *after* the
<span class="w"> </span>        yielded block returns.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # WARNING: the iterator interface for `ProgressBar` relies on</span>
<span class="gi">+        # this and only works because this is a simple generator which</span>
<span class="gi">+        # doesn&#39;t create or manage additional state. If this function</span>
<span class="gi">+        # changes, the impact should be evaluated both against</span>
<span class="gi">+        # `iter(bar)` and `next(bar)`. `next()` in particular may call</span>
<span class="gi">+        # `self.generator()` repeatedly, and this must remain safe in</span>
<span class="gi">+        # order for that interface to work.</span>
<span class="gi">+        if not self.entered:</span>
<span class="gi">+            raise RuntimeError(&quot;You need to use progress bars in a with block.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if self.is_hidden:</span>
<span class="gi">+            yield from self.iter</span>
<span class="gi">+        else:</span>
<span class="gi">+            for rv in self.iter:</span>
<span class="gi">+                self.current_item = rv</span>
<span class="gi">+</span>
<span class="gi">+                # This allows show_item_func to be updated before the</span>
<span class="gi">+                # item is processed. Only trigger at the beginning of</span>
<span class="gi">+                # the update interval.</span>
<span class="gi">+                if self._completed_intervals == 0:</span>
<span class="gi">+                    self.render_progress()</span>
<span class="gi">+</span>
<span class="gi">+                yield rv</span>
<span class="gi">+                self.update(1)</span>

<span class="gi">+            self.finish()</span>
<span class="gi">+            self.render_progress()</span>

<span class="gd">-def pager(generator: t.Iterable[str], color: t.Optional[bool]=None) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def pager(generator: t.Iterable[str], color: t.Optional[bool] = None) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Decide what method to use for paging through text.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    stdout = _default_text_stdout()</span>
<span class="gi">+</span>
<span class="gi">+    # There are no standard streams attached to write to. For example,</span>
<span class="gi">+    # pythonw on Windows.</span>
<span class="gi">+    if stdout is None:</span>
<span class="gi">+        stdout = StringIO()</span>
<span class="gi">+</span>
<span class="gi">+    if not isatty(sys.stdin) or not isatty(stdout):</span>
<span class="gi">+        return _nullpager(stdout, generator, color)</span>
<span class="gi">+    pager_cmd = (os.environ.get(&quot;PAGER&quot;, None) or &quot;&quot;).strip()</span>
<span class="gi">+    if pager_cmd:</span>
<span class="gi">+        if WIN:</span>
<span class="gi">+            return _tempfilepager(generator, pager_cmd, color)</span>
<span class="gi">+        return _pipepager(generator, pager_cmd, color)</span>
<span class="gi">+    if os.environ.get(&quot;TERM&quot;) in (&quot;dumb&quot;, &quot;emacs&quot;):</span>
<span class="gi">+        return _nullpager(stdout, generator, color)</span>
<span class="gi">+    if WIN or sys.platform.startswith(&quot;os2&quot;):</span>
<span class="gi">+        return _tempfilepager(generator, &quot;more &lt;&quot;, color)</span>
<span class="gi">+    if hasattr(os, &quot;system&quot;) and os.system(&quot;(less) 2&gt;/dev/null&quot;) == 0:</span>
<span class="gi">+        return _pipepager(generator, &quot;less&quot;, color)</span>

<span class="gi">+    import tempfile</span>

<span class="gd">-def _pipepager(generator: t.Iterable[str], cmd: str, color: t.Optional[bool]</span>
<span class="gd">-    ) -&gt;None:</span>
<span class="gi">+    fd, filename = tempfile.mkstemp()</span>
<span class="gi">+    os.close(fd)</span>
<span class="gi">+    try:</span>
<span class="gi">+        if hasattr(os, &quot;system&quot;) and os.system(f&#39;more &quot;{filename}&quot;&#39;) == 0:</span>
<span class="gi">+            return _pipepager(generator, &quot;more&quot;, color)</span>
<span class="gi">+        return _nullpager(stdout, generator, color)</span>
<span class="gi">+    finally:</span>
<span class="gi">+        os.unlink(filename)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _pipepager(generator: t.Iterable[str], cmd: str, color: t.Optional[bool]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Page through text by feeding it to another program.  Invoking a
<span class="w"> </span>    pager through this might support colors.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import subprocess</span>
<span class="gi">+</span>
<span class="gi">+    env = dict(os.environ)</span>

<span class="gi">+    # If we&#39;re piping to less we might support colors under the</span>
<span class="gi">+    # condition that</span>
<span class="gi">+    cmd_detail = cmd.rsplit(&quot;/&quot;, 1)[-1].split()</span>
<span class="gi">+    if color is None and cmd_detail[0] == &quot;less&quot;:</span>
<span class="gi">+        less_flags = f&quot;{os.environ.get(&#39;LESS&#39;, &#39;&#39;)}{&#39; &#39;.join(cmd_detail[1:])}&quot;</span>
<span class="gi">+        if not less_flags:</span>
<span class="gi">+            env[&quot;LESS&quot;] = &quot;-R&quot;</span>
<span class="gi">+            color = True</span>
<span class="gi">+        elif &quot;r&quot; in less_flags or &quot;R&quot; in less_flags:</span>
<span class="gi">+            color = True</span>

<span class="gd">-def _tempfilepager(generator: t.Iterable[str], cmd: str, color: t.Optional[</span>
<span class="gd">-    bool]) -&gt;None:</span>
<span class="gi">+    c = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, env=env)</span>
<span class="gi">+    stdin = t.cast(t.BinaryIO, c.stdin)</span>
<span class="gi">+    encoding = get_best_encoding(stdin)</span>
<span class="gi">+    try:</span>
<span class="gi">+        for text in generator:</span>
<span class="gi">+            if not color:</span>
<span class="gi">+                text = strip_ansi(text)</span>
<span class="gi">+</span>
<span class="gi">+            stdin.write(text.encode(encoding, &quot;replace&quot;))</span>
<span class="gi">+    except (OSError, KeyboardInterrupt):</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        stdin.close()</span>
<span class="gi">+</span>
<span class="gi">+    # Less doesn&#39;t respect ^C, but catches it for its own UI purposes (aborting</span>
<span class="gi">+    # search or other commands inside less).</span>
<span class="gi">+    #</span>
<span class="gi">+    # That means when the user hits ^C, the parent process (click) terminates,</span>
<span class="gi">+    # but less is still alive, paging the output and messing up the terminal.</span>
<span class="gi">+    #</span>
<span class="gi">+    # If the user wants to make the pager exit on ^C, they should set</span>
<span class="gi">+    # `LESS=&#39;-K&#39;`. It&#39;s not our decision to make.</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            c.wait()</span>
<span class="gi">+        except KeyboardInterrupt:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _tempfilepager(</span>
<span class="gi">+    generator: t.Iterable[str], cmd: str, color: t.Optional[bool]</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Page through text by invoking a program on a temporary file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import tempfile</span>
<span class="gi">+</span>
<span class="gi">+    fd, filename = tempfile.mkstemp()</span>
<span class="gi">+    # TODO: This never terminates if the passed generator never terminates.</span>
<span class="gi">+    text = &quot;&quot;.join(generator)</span>
<span class="gi">+    if not color:</span>
<span class="gi">+        text = strip_ansi(text)</span>
<span class="gi">+    encoding = get_best_encoding(sys.stdout)</span>
<span class="gi">+    with open_stream(filename, &quot;wb&quot;)[0] as f:</span>
<span class="gi">+        f.write(text.encode(encoding))</span>
<span class="gi">+    try:</span>
<span class="gi">+        os.system(f&#39;{cmd} &quot;{filename}&quot;&#39;)</span>
<span class="gi">+    finally:</span>
<span class="gi">+        os.close(fd)</span>
<span class="gi">+        os.unlink(filename)</span>


<span class="gd">-def _nullpager(stream: t.TextIO, generator: t.Iterable[str], color: t.</span>
<span class="gd">-    Optional[bool]) -&gt;None:</span>
<span class="gi">+def _nullpager(</span>
<span class="gi">+    stream: t.TextIO, generator: t.Iterable[str], color: t.Optional[bool]</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Simply print unformatted text.  This is the ultimate fallback.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for text in generator:</span>
<span class="gi">+        if not color:</span>
<span class="gi">+            text = strip_ansi(text)</span>
<span class="gi">+        stream.write(text)</span>


<span class="w"> </span>class Editor:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, editor: t.Optional[str]=None, env: t.Optional[t.</span>
<span class="gd">-        Mapping[str, str]]=None, require_save: bool=True, extension: str=&#39;.txt&#39;</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        editor: t.Optional[str] = None,</span>
<span class="gi">+        env: t.Optional[t.Mapping[str, str]] = None,</span>
<span class="gi">+        require_save: bool = True,</span>
<span class="gi">+        extension: str = &quot;.txt&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.editor = editor
<span class="w"> </span>        self.env = env
<span class="w"> </span>        self.require_save = require_save
<span class="w"> </span>        self.extension = extension

<span class="gi">+    def get_editor(self) -&gt; str:</span>
<span class="gi">+        if self.editor is not None:</span>
<span class="gi">+            return self.editor</span>
<span class="gi">+        for key in &quot;VISUAL&quot;, &quot;EDITOR&quot;:</span>
<span class="gi">+            rv = os.environ.get(key)</span>
<span class="gi">+            if rv:</span>
<span class="gi">+                return rv</span>
<span class="gi">+        if WIN:</span>
<span class="gi">+            return &quot;notepad&quot;</span>
<span class="gi">+        for editor in &quot;sensible-editor&quot;, &quot;vim&quot;, &quot;nano&quot;:</span>
<span class="gi">+            if os.system(f&quot;which {editor} &gt;/dev/null 2&gt;&amp;1&quot;) == 0:</span>
<span class="gi">+                return editor</span>
<span class="gi">+        return &quot;vi&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def edit_file(self, filename: str) -&gt; None:</span>
<span class="gi">+        import subprocess</span>
<span class="gi">+</span>
<span class="gi">+        editor = self.get_editor()</span>
<span class="gi">+        environ: t.Optional[t.Dict[str, str]] = None</span>
<span class="gi">+</span>
<span class="gi">+        if self.env:</span>
<span class="gi">+            environ = os.environ.copy()</span>
<span class="gi">+            environ.update(self.env)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            c = subprocess.Popen(f&#39;{editor} &quot;{filename}&quot;&#39;, env=environ, shell=True)</span>
<span class="gi">+            exit_code = c.wait()</span>
<span class="gi">+            if exit_code != 0:</span>
<span class="gi">+                raise ClickException(</span>
<span class="gi">+                    _(&quot;{editor}: Editing failed&quot;).format(editor=editor)</span>
<span class="gi">+                )</span>
<span class="gi">+        except OSError as e:</span>
<span class="gi">+            raise ClickException(</span>
<span class="gi">+                _(&quot;{editor}: Editing failed: {e}&quot;).format(editor=editor, e=e)</span>
<span class="gi">+            ) from e</span>
<span class="gi">+</span>
<span class="gi">+    def edit(self, text: t.Optional[t.AnyStr]) -&gt; t.Optional[t.AnyStr]:</span>
<span class="gi">+        import tempfile</span>
<span class="gi">+</span>
<span class="gi">+        if not text:</span>
<span class="gi">+            data = b&quot;&quot;</span>
<span class="gi">+        elif isinstance(text, (bytes, bytearray)):</span>
<span class="gi">+            data = text</span>
<span class="gi">+        else:</span>
<span class="gi">+            if text and not text.endswith(&quot;\n&quot;):</span>
<span class="gi">+                text += &quot;\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if WIN:</span>
<span class="gi">+                data = text.replace(&quot;\n&quot;, &quot;\r\n&quot;).encode(&quot;utf-8-sig&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                data = text.encode(&quot;utf-8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        fd, name = tempfile.mkstemp(prefix=&quot;editor-&quot;, suffix=self.extension)</span>
<span class="gi">+        f: t.BinaryIO</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            with os.fdopen(fd, &quot;wb&quot;) as f:</span>
<span class="gi">+                f.write(data)</span>
<span class="gi">+</span>
<span class="gi">+            # If the filesystem resolution is 1 second, like Mac OS</span>
<span class="gi">+            # 10.12 Extended, or 2 seconds, like FAT32, and the editor</span>
<span class="gi">+            # closes very fast, require_save can fail. Set the modified</span>
<span class="gi">+            # time to be 2 seconds in the past to work around this.</span>
<span class="gi">+            os.utime(name, (os.path.getatime(name), os.path.getmtime(name) - 2))</span>
<span class="gi">+            # Depending on the resolution, the exact value might not be</span>
<span class="gi">+            # recorded, so get the new recorded value.</span>
<span class="gi">+            timestamp = os.path.getmtime(name)</span>
<span class="gi">+</span>
<span class="gi">+            self.edit_file(name)</span>
<span class="gi">+</span>
<span class="gi">+            if self.require_save and os.path.getmtime(name) == timestamp:</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+            with open(name, &quot;rb&quot;) as f:</span>
<span class="gi">+                rv = f.read()</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(text, (bytes, bytearray)):</span>
<span class="gi">+                return rv</span>
<span class="gi">+</span>
<span class="gi">+            return rv.decode(&quot;utf-8-sig&quot;).replace(&quot;\r\n&quot;, &quot;\n&quot;)  # type: ignore</span>
<span class="gi">+        finally:</span>
<span class="gi">+            os.unlink(name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def open_url(url: str, wait: bool = False, locate: bool = False) -&gt; int:</span>
<span class="gi">+    import subprocess</span>
<span class="gi">+</span>
<span class="gi">+    def _unquote_file(url: str) -&gt; str:</span>
<span class="gi">+        from urllib.parse import unquote</span>
<span class="gi">+</span>
<span class="gi">+        if url.startswith(&quot;file://&quot;):</span>
<span class="gi">+            url = unquote(url[7:])</span>
<span class="gi">+</span>
<span class="gi">+        return url</span>
<span class="gi">+</span>
<span class="gi">+    if sys.platform == &quot;darwin&quot;:</span>
<span class="gi">+        args = [&quot;open&quot;]</span>
<span class="gi">+        if wait:</span>
<span class="gi">+            args.append(&quot;-W&quot;)</span>
<span class="gi">+        if locate:</span>
<span class="gi">+            args.append(&quot;-R&quot;)</span>
<span class="gi">+        args.append(_unquote_file(url))</span>
<span class="gi">+        null = open(&quot;/dev/null&quot;, &quot;w&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return subprocess.Popen(args, stderr=null).wait()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            null.close()</span>
<span class="gi">+    elif WIN:</span>
<span class="gi">+        if locate:</span>
<span class="gi">+            url = _unquote_file(url.replace(&#39;&quot;&#39;, &quot;&quot;))</span>
<span class="gi">+            args = f&#39;explorer /select,&quot;{url}&quot;&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            url = url.replace(&#39;&quot;&#39;, &quot;&quot;)</span>
<span class="gi">+            wait_str = &quot;/WAIT&quot; if wait else &quot;&quot;</span>
<span class="gi">+            args = f&#39;start {wait_str} &quot;&quot; &quot;{url}&quot;&#39;</span>
<span class="gi">+        return os.system(args)</span>
<span class="gi">+    elif CYGWIN:</span>
<span class="gi">+        if locate:</span>
<span class="gi">+            url = os.path.dirname(_unquote_file(url).replace(&#39;&quot;&#39;, &quot;&quot;))</span>
<span class="gi">+            args = f&#39;cygstart &quot;{url}&quot;&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            url = url.replace(&#39;&quot;&#39;, &quot;&quot;)</span>
<span class="gi">+            wait_str = &quot;-w&quot; if wait else &quot;&quot;</span>
<span class="gi">+            args = f&#39;cygstart {wait_str} &quot;{url}&quot;&#39;</span>
<span class="gi">+        return os.system(args)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        if locate:</span>
<span class="gi">+            url = os.path.dirname(_unquote_file(url)) or &quot;.&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            url = _unquote_file(url)</span>
<span class="gi">+        c = subprocess.Popen([&quot;xdg-open&quot;, url])</span>
<span class="gi">+        if wait:</span>
<span class="gi">+            return c.wait()</span>
<span class="gi">+        return 0</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        if url.startswith((&quot;http://&quot;, &quot;https://&quot;)) and not locate and not wait:</span>
<span class="gi">+            import webbrowser</span>
<span class="gi">+</span>
<span class="gi">+            webbrowser.open(url)</span>
<span class="gi">+            return 0</span>
<span class="gi">+        return 1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _translate_ch_to_exc(ch: str) -&gt; t.Optional[BaseException]:</span>
<span class="gi">+    if ch == &quot;\x03&quot;:</span>
<span class="gi">+        raise KeyboardInterrupt()</span>
<span class="gi">+</span>
<span class="gi">+    if ch == &quot;\x04&quot; and not WIN:  # Unix-like, Ctrl+D</span>
<span class="gi">+        raise EOFError()</span>
<span class="gi">+</span>
<span class="gi">+    if ch == &quot;\x1a&quot; and WIN:  # Windows, Ctrl+Z</span>
<span class="gi">+        raise EOFError()</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>

<span class="w"> </span>if WIN:
<span class="w"> </span>    import msvcrt
<span class="gi">+</span>
<span class="gi">+    @contextlib.contextmanager</span>
<span class="gi">+    def raw_terminal() -&gt; t.Iterator[int]:</span>
<span class="gi">+        yield -1</span>
<span class="gi">+</span>
<span class="gi">+    def getchar(echo: bool) -&gt; str:</span>
<span class="gi">+        # The function `getch` will return a bytes object corresponding to</span>
<span class="gi">+        # the pressed character. Since Windows 10 build 1803, it will also</span>
<span class="gi">+        # return \x00 when called a second time after pressing a regular key.</span>
<span class="gi">+        #</span>
<span class="gi">+        # `getwch` does not share this probably-bugged behavior. Moreover, it</span>
<span class="gi">+        # returns a Unicode object by default, which is what we want.</span>
<span class="gi">+        #</span>
<span class="gi">+        # Either of these functions will return \x00 or \xe0 to indicate</span>
<span class="gi">+        # a special key, and you need to call the same function again to get</span>
<span class="gi">+        # the &quot;rest&quot; of the code. The fun part is that \u00e0 is</span>
<span class="gi">+        # &quot;latin small letter a with grave&quot;, so if you type that on a French</span>
<span class="gi">+        # keyboard, you _also_ get a \xe0.</span>
<span class="gi">+        # E.g., consider the Up arrow. This returns \xe0 and then \x48. The</span>
<span class="gi">+        # resulting Unicode string reads as &quot;a with grave&quot; + &quot;capital H&quot;.</span>
<span class="gi">+        # This is indistinguishable from when the user actually types</span>
<span class="gi">+        # &quot;a with grave&quot; and then &quot;capital H&quot;.</span>
<span class="gi">+        #</span>
<span class="gi">+        # When \xe0 is returned, we assume it&#39;s part of a special-key sequence</span>
<span class="gi">+        # and call `getwch` again, but that means that when the user types</span>
<span class="gi">+        # the \u00e0 character, `getchar` doesn&#39;t return until a second</span>
<span class="gi">+        # character is typed.</span>
<span class="gi">+        # The alternative is returning immediately, but that would mess up</span>
<span class="gi">+        # cross-platform handling of arrow keys and others that start with</span>
<span class="gi">+        # \xe0. Another option is using `getch`, but then we can&#39;t reliably</span>
<span class="gi">+        # read non-ASCII characters, because return values of `getch` are</span>
<span class="gi">+        # limited to the current 8-bit codepage.</span>
<span class="gi">+        #</span>
<span class="gi">+        # Anyway, Click doesn&#39;t claim to do this Right(tm), and using `getwch`</span>
<span class="gi">+        # is doing the right thing in more situations than with `getch`.</span>
<span class="gi">+        func: t.Callable[[], str]</span>
<span class="gi">+</span>
<span class="gi">+        if echo:</span>
<span class="gi">+            func = msvcrt.getwche  # type: ignore</span>
<span class="gi">+        else:</span>
<span class="gi">+            func = msvcrt.getwch  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        rv = func()</span>
<span class="gi">+</span>
<span class="gi">+        if rv in (&quot;\x00&quot;, &quot;\xe0&quot;):</span>
<span class="gi">+            # \x00 and \xe0 are control characters that indicate special key,</span>
<span class="gi">+            # see above.</span>
<span class="gi">+            rv += func()</span>
<span class="gi">+</span>
<span class="gi">+        _translate_ch_to_exc(rv)</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="w"> </span>    import tty
<span class="w"> </span>    import termios
<span class="gi">+</span>
<span class="gi">+    @contextlib.contextmanager</span>
<span class="gi">+    def raw_terminal() -&gt; t.Iterator[int]:</span>
<span class="gi">+        f: t.Optional[t.TextIO]</span>
<span class="gi">+        fd: int</span>
<span class="gi">+</span>
<span class="gi">+        if not isatty(sys.stdin):</span>
<span class="gi">+            f = open(&quot;/dev/tty&quot;)</span>
<span class="gi">+            fd = f.fileno()</span>
<span class="gi">+        else:</span>
<span class="gi">+            fd = sys.stdin.fileno()</span>
<span class="gi">+            f = None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            old_settings = termios.tcgetattr(fd)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                tty.setraw(fd)</span>
<span class="gi">+                yield fd</span>
<span class="gi">+            finally:</span>
<span class="gi">+                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)</span>
<span class="gi">+                sys.stdout.flush()</span>
<span class="gi">+</span>
<span class="gi">+                if f is not None:</span>
<span class="gi">+                    f.close()</span>
<span class="gi">+        except termios.error:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    def getchar(echo: bool) -&gt; str:</span>
<span class="gi">+        with raw_terminal() as fd:</span>
<span class="gi">+            ch = os.read(fd, 32).decode(get_best_encoding(sys.stdin), &quot;replace&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if echo and isatty(sys.stdout):</span>
<span class="gi">+                sys.stdout.write(ch)</span>
<span class="gi">+</span>
<span class="gi">+            _translate_ch_to_exc(ch)</span>
<span class="gi">+            return ch</span>
<span class="gh">diff --git a/src/click/_textwrap.py b/src/click/_textwrap.py</span>
<span class="gh">index 681ea25..b47dcbd 100644</span>
<span class="gd">--- a/src/click/_textwrap.py</span>
<span class="gi">+++ b/src/click/_textwrap.py</span>
<span class="gu">@@ -4,4 +4,46 @@ from contextlib import contextmanager</span>


<span class="w"> </span>class TextWrapper(textwrap.TextWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    def _handle_long_word(</span>
<span class="gi">+        self,</span>
<span class="gi">+        reversed_chunks: t.List[str],</span>
<span class="gi">+        cur_line: t.List[str],</span>
<span class="gi">+        cur_len: int,</span>
<span class="gi">+        width: int,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        space_left = max(width - cur_len, 1)</span>
<span class="gi">+</span>
<span class="gi">+        if self.break_long_words:</span>
<span class="gi">+            last = reversed_chunks[-1]</span>
<span class="gi">+            cut = last[:space_left]</span>
<span class="gi">+            res = last[space_left:]</span>
<span class="gi">+            cur_line.append(cut)</span>
<span class="gi">+            reversed_chunks[-1] = res</span>
<span class="gi">+        elif not cur_line:</span>
<span class="gi">+            cur_line.append(reversed_chunks.pop())</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def extra_indent(self, indent: str) -&gt; t.Iterator[None]:</span>
<span class="gi">+        old_initial_indent = self.initial_indent</span>
<span class="gi">+        old_subsequent_indent = self.subsequent_indent</span>
<span class="gi">+        self.initial_indent += indent</span>
<span class="gi">+        self.subsequent_indent += indent</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.initial_indent = old_initial_indent</span>
<span class="gi">+            self.subsequent_indent = old_subsequent_indent</span>
<span class="gi">+</span>
<span class="gi">+    def indent_only(self, text: str) -&gt; str:</span>
<span class="gi">+        rv = []</span>
<span class="gi">+</span>
<span class="gi">+        for idx, line in enumerate(text.splitlines()):</span>
<span class="gi">+            indent = self.initial_indent</span>
<span class="gi">+</span>
<span class="gi">+            if idx &gt; 0:</span>
<span class="gi">+                indent = self.subsequent_indent</span>
<span class="gi">+</span>
<span class="gi">+            rv.append(f&quot;{indent}{line}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return &quot;\n&quot;.join(rv)</span>
<span class="gh">diff --git a/src/click/_winconsole.py b/src/click/_winconsole.py</span>
<span class="gh">index 514d97e..6b20df3 100644</span>
<span class="gd">--- a/src/click/_winconsole.py</span>
<span class="gi">+++ b/src/click/_winconsole.py</span>
<span class="gu">@@ -1,3 +1,11 @@</span>
<span class="gi">+# This module is based on the excellent work by Adam Barto who</span>
<span class="gi">+# provided a lot of what went into the implementation here in</span>
<span class="gi">+# the discussion to issue1602 in the Python bug tracker.</span>
<span class="gi">+#</span>
<span class="gi">+# There are some general differences in regards to how this works</span>
<span class="gi">+# compared to the original patches as we do not need to patch</span>
<span class="gi">+# the entire interpreter but just work in our little world of</span>
<span class="gi">+# echo and prompt.</span>
<span class="w"> </span>import io
<span class="w"> </span>import sys
<span class="w"> </span>import time
<span class="gu">@@ -16,78 +24,256 @@ from ctypes.wintypes import DWORD</span>
<span class="w"> </span>from ctypes.wintypes import HANDLE
<span class="w"> </span>from ctypes.wintypes import LPCWSTR
<span class="w"> </span>from ctypes.wintypes import LPWSTR
<span class="gi">+</span>
<span class="w"> </span>from ._compat import _NonClosingTextIOWrapper
<span class="gd">-assert sys.platform == &#39;win32&#39;</span>
<span class="gd">-import msvcrt</span>
<span class="gd">-from ctypes import windll</span>
<span class="gd">-from ctypes import WINFUNCTYPE</span>
<span class="gi">+</span>
<span class="gi">+assert sys.platform == &quot;win32&quot;</span>
<span class="gi">+import msvcrt  # noqa: E402</span>
<span class="gi">+from ctypes import windll  # noqa: E402</span>
<span class="gi">+from ctypes import WINFUNCTYPE  # noqa: E402</span>
<span class="gi">+</span>
<span class="w"> </span>c_ssize_p = POINTER(c_ssize_t)
<span class="gi">+</span>
<span class="w"> </span>kernel32 = windll.kernel32
<span class="w"> </span>GetStdHandle = kernel32.GetStdHandle
<span class="w"> </span>ReadConsoleW = kernel32.ReadConsoleW
<span class="w"> </span>WriteConsoleW = kernel32.WriteConsoleW
<span class="w"> </span>GetConsoleMode = kernel32.GetConsoleMode
<span class="w"> </span>GetLastError = kernel32.GetLastError
<span class="gd">-GetCommandLineW = WINFUNCTYPE(LPWSTR)((&#39;GetCommandLineW&#39;, windll.kernel32))</span>
<span class="gd">-CommandLineToArgvW = WINFUNCTYPE(POINTER(LPWSTR), LPCWSTR, POINTER(c_int))((</span>
<span class="gd">-    &#39;CommandLineToArgvW&#39;, windll.shell32))</span>
<span class="gd">-LocalFree = WINFUNCTYPE(c_void_p, c_void_p)((&#39;LocalFree&#39;, windll.kernel32))</span>
<span class="gi">+GetCommandLineW = WINFUNCTYPE(LPWSTR)((&quot;GetCommandLineW&quot;, windll.kernel32))</span>
<span class="gi">+CommandLineToArgvW = WINFUNCTYPE(POINTER(LPWSTR), LPCWSTR, POINTER(c_int))(</span>
<span class="gi">+    (&quot;CommandLineToArgvW&quot;, windll.shell32)</span>
<span class="gi">+)</span>
<span class="gi">+LocalFree = WINFUNCTYPE(c_void_p, c_void_p)((&quot;LocalFree&quot;, windll.kernel32))</span>
<span class="gi">+</span>
<span class="w"> </span>STDIN_HANDLE = GetStdHandle(-10)
<span class="w"> </span>STDOUT_HANDLE = GetStdHandle(-11)
<span class="w"> </span>STDERR_HANDLE = GetStdHandle(-12)
<span class="gi">+</span>
<span class="w"> </span>PyBUF_SIMPLE = 0
<span class="w"> </span>PyBUF_WRITABLE = 1
<span class="gi">+</span>
<span class="w"> </span>ERROR_SUCCESS = 0
<span class="w"> </span>ERROR_NOT_ENOUGH_MEMORY = 8
<span class="w"> </span>ERROR_OPERATION_ABORTED = 995
<span class="gi">+</span>
<span class="w"> </span>STDIN_FILENO = 0
<span class="w"> </span>STDOUT_FILENO = 1
<span class="w"> </span>STDERR_FILENO = 2
<span class="gd">-EOF = b&#39;\x1a&#39;</span>
<span class="gi">+</span>
<span class="gi">+EOF = b&quot;\x1a&quot;</span>
<span class="w"> </span>MAX_BYTES_WRITTEN = 32767
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from ctypes import pythonapi
<span class="w"> </span>except ImportError:
<span class="gi">+    # On PyPy we cannot get buffers so our ability to operate here is</span>
<span class="gi">+    # severely limited.</span>
<span class="w"> </span>    get_buffer = None
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    class Py_buffer(Structure):
<span class="gd">-        _fields_ = [(&#39;buf&#39;, c_void_p), (&#39;obj&#39;, py_object), (&#39;len&#39;,</span>
<span class="gd">-            c_ssize_t), (&#39;itemsize&#39;, c_ssize_t), (&#39;readonly&#39;, c_int), (</span>
<span class="gd">-            &#39;ndim&#39;, c_int), (&#39;format&#39;, c_char_p), (&#39;shape&#39;, c_ssize_p), (</span>
<span class="gd">-            &#39;strides&#39;, c_ssize_p), (&#39;suboffsets&#39;, c_ssize_p), (&#39;internal&#39;,</span>
<span class="gd">-            c_void_p)]</span>
<span class="gi">+        _fields_ = [</span>
<span class="gi">+            (&quot;buf&quot;, c_void_p),</span>
<span class="gi">+            (&quot;obj&quot;, py_object),</span>
<span class="gi">+            (&quot;len&quot;, c_ssize_t),</span>
<span class="gi">+            (&quot;itemsize&quot;, c_ssize_t),</span>
<span class="gi">+            (&quot;readonly&quot;, c_int),</span>
<span class="gi">+            (&quot;ndim&quot;, c_int),</span>
<span class="gi">+            (&quot;format&quot;, c_char_p),</span>
<span class="gi">+            (&quot;shape&quot;, c_ssize_p),</span>
<span class="gi">+            (&quot;strides&quot;, c_ssize_p),</span>
<span class="gi">+            (&quot;suboffsets&quot;, c_ssize_p),</span>
<span class="gi">+            (&quot;internal&quot;, c_void_p),</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="w"> </span>    PyObject_GetBuffer = pythonapi.PyObject_GetBuffer
<span class="w"> </span>    PyBuffer_Release = pythonapi.PyBuffer_Release

<span class="gi">+    def get_buffer(obj, writable=False):</span>
<span class="gi">+        buf = Py_buffer()</span>
<span class="gi">+        flags = PyBUF_WRITABLE if writable else PyBUF_SIMPLE</span>
<span class="gi">+        PyObject_GetBuffer(py_object(obj), byref(buf), flags)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            buffer_type = c_char * buf.len</span>
<span class="gi">+            return buffer_type.from_address(buf.buf)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            PyBuffer_Release(byref(buf))</span>

<span class="gd">-class _WindowsConsoleRawIOBase(io.RawIOBase):</span>

<span class="gi">+class _WindowsConsoleRawIOBase(io.RawIOBase):</span>
<span class="w"> </span>    def __init__(self, handle):
<span class="w"> </span>        self.handle = handle

<span class="gi">+    def isatty(self):</span>
<span class="gi">+        super().isatty()</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>

<span class="w"> </span>class _WindowsConsoleReader(_WindowsConsoleRawIOBase):
<span class="gd">-    pass</span>
<span class="gi">+    def readable(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def readinto(self, b):</span>
<span class="gi">+        bytes_to_be_read = len(b)</span>
<span class="gi">+        if not bytes_to_be_read:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        elif bytes_to_be_read % 2:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;cannot read odd number of bytes from UTF-16-LE encoded console&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        buffer = get_buffer(b, writable=True)</span>
<span class="gi">+        code_units_to_be_read = bytes_to_be_read // 2</span>
<span class="gi">+        code_units_read = c_ulong()</span>
<span class="gi">+</span>
<span class="gi">+        rv = ReadConsoleW(</span>
<span class="gi">+            HANDLE(self.handle),</span>
<span class="gi">+            buffer,</span>
<span class="gi">+            code_units_to_be_read,</span>
<span class="gi">+            byref(code_units_read),</span>
<span class="gi">+            None,</span>
<span class="gi">+        )</span>
<span class="gi">+        if GetLastError() == ERROR_OPERATION_ABORTED:</span>
<span class="gi">+            # wait for KeyboardInterrupt</span>
<span class="gi">+            time.sleep(0.1)</span>
<span class="gi">+        if not rv:</span>
<span class="gi">+            raise OSError(f&quot;Windows error: {GetLastError()}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if buffer[0] == EOF:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        return 2 * code_units_read.value</span>


<span class="w"> </span>class _WindowsConsoleWriter(_WindowsConsoleRawIOBase):
<span class="gd">-    pass</span>
<span class="gi">+    def writable(self):</span>
<span class="gi">+        return True</span>

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _get_error_message(errno):</span>
<span class="gi">+        if errno == ERROR_SUCCESS:</span>
<span class="gi">+            return &quot;ERROR_SUCCESS&quot;</span>
<span class="gi">+        elif errno == ERROR_NOT_ENOUGH_MEMORY:</span>
<span class="gi">+            return &quot;ERROR_NOT_ENOUGH_MEMORY&quot;</span>
<span class="gi">+        return f&quot;Windows error {errno}&quot;</span>

<span class="gd">-class ConsoleStream:</span>
<span class="gi">+    def write(self, b):</span>
<span class="gi">+        bytes_to_be_written = len(b)</span>
<span class="gi">+        buf = get_buffer(b)</span>
<span class="gi">+        code_units_to_be_written = min(bytes_to_be_written, MAX_BYTES_WRITTEN) // 2</span>
<span class="gi">+        code_units_written = c_ulong()</span>
<span class="gi">+</span>
<span class="gi">+        WriteConsoleW(</span>
<span class="gi">+            HANDLE(self.handle),</span>
<span class="gi">+            buf,</span>
<span class="gi">+            code_units_to_be_written,</span>
<span class="gi">+            byref(code_units_written),</span>
<span class="gi">+            None,</span>
<span class="gi">+        )</span>
<span class="gi">+        bytes_written = 2 * code_units_written.value</span>

<span class="gd">-    def __init__(self, text_stream: t.TextIO, byte_stream: t.BinaryIO) -&gt;None:</span>
<span class="gi">+        if bytes_written == 0 and bytes_to_be_written &gt; 0:</span>
<span class="gi">+            raise OSError(self._get_error_message(GetLastError()))</span>
<span class="gi">+        return bytes_written</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ConsoleStream:</span>
<span class="gi">+    def __init__(self, text_stream: t.TextIO, byte_stream: t.BinaryIO) -&gt; None:</span>
<span class="w"> </span>        self._text_stream = text_stream
<span class="w"> </span>        self.buffer = byte_stream

<span class="gd">-    def __getattr__(self, name: str) -&gt;t.Any:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; str:</span>
<span class="gi">+        return self.buffer.name</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, x: t.AnyStr) -&gt; int:</span>
<span class="gi">+        if isinstance(x, str):</span>
<span class="gi">+            return self._text_stream.write(x)</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.flush()</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return self.buffer.write(x)</span>
<span class="gi">+</span>
<span class="gi">+    def writelines(self, lines: t.Iterable[t.AnyStr]) -&gt; None:</span>
<span class="gi">+        for line in lines:</span>
<span class="gi">+            self.write(line)</span>
<span class="gi">+</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; t.Any:</span>
<span class="w"> </span>        return getattr(self._text_stream, name)

<span class="gi">+    def isatty(self) -&gt; bool:</span>
<span class="gi">+        return self.buffer.isatty()</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;&lt;ConsoleStream name={self.name!r} encoding={self.encoding!r}&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;ConsoleStream name={self.name!r} encoding={self.encoding!r}&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_text_stdin(buffer_stream: t.BinaryIO) -&gt; t.TextIO:</span>
<span class="gi">+    text_stream = _NonClosingTextIOWrapper(</span>
<span class="gi">+        io.BufferedReader(_WindowsConsoleReader(STDIN_HANDLE)),</span>
<span class="gi">+        &quot;utf-16-le&quot;,</span>
<span class="gi">+        &quot;strict&quot;,</span>
<span class="gi">+        line_buffering=True,</span>
<span class="gi">+    )</span>
<span class="gi">+    return t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_text_stdout(buffer_stream: t.BinaryIO) -&gt; t.TextIO:</span>
<span class="gi">+    text_stream = _NonClosingTextIOWrapper(</span>
<span class="gi">+        io.BufferedWriter(_WindowsConsoleWriter(STDOUT_HANDLE)),</span>
<span class="gi">+        &quot;utf-16-le&quot;,</span>
<span class="gi">+        &quot;strict&quot;,</span>
<span class="gi">+        line_buffering=True,</span>
<span class="gi">+    )</span>
<span class="gi">+    return t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_text_stderr(buffer_stream: t.BinaryIO) -&gt; t.TextIO:</span>
<span class="gi">+    text_stream = _NonClosingTextIOWrapper(</span>
<span class="gi">+        io.BufferedWriter(_WindowsConsoleWriter(STDERR_HANDLE)),</span>
<span class="gi">+        &quot;utf-16-le&quot;,</span>
<span class="gi">+        &quot;strict&quot;,</span>
<span class="gi">+        line_buffering=True,</span>
<span class="gi">+    )</span>
<span class="gi">+    return t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_stream_factories: t.Mapping[int, t.Callable[[t.BinaryIO], t.TextIO]] = {</span>
<span class="gi">+    0: _get_text_stdin,</span>
<span class="gi">+    1: _get_text_stdout,</span>
<span class="gi">+    2: _get_text_stderr,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_console(f: t.TextIO) -&gt; bool:</span>
<span class="gi">+    if not hasattr(f, &quot;fileno&quot;):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        fileno = f.fileno()</span>
<span class="gi">+    except (OSError, io.UnsupportedOperation):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    handle = msvcrt.get_osfhandle(fileno)</span>
<span class="gi">+    return bool(GetConsoleMode(handle, byref(DWORD())))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_windows_console_stream(</span>
<span class="gi">+    f: t.TextIO, encoding: t.Optional[str], errors: t.Optional[str]</span>
<span class="gi">+) -&gt; t.Optional[t.TextIO]:</span>
<span class="gi">+    if (</span>
<span class="gi">+        get_buffer is not None</span>
<span class="gi">+        and encoding in {&quot;utf-16-le&quot;, None}</span>
<span class="gi">+        and errors in {&quot;strict&quot;, None}</span>
<span class="gi">+        and _is_console(f)</span>
<span class="gi">+    ):</span>
<span class="gi">+        func = _stream_factories.get(f.fileno())</span>
<span class="gi">+        if func is not None:</span>
<span class="gi">+            b = getattr(f, &quot;buffer&quot;, None)</span>

<span class="gi">+            if b is None:</span>
<span class="gi">+                return None</span>

<span class="gd">-_stream_factories: t.Mapping[int, t.Callable[[t.BinaryIO], t.TextIO]] = {(0</span>
<span class="gd">-    ): _get_text_stdin, (1): _get_text_stdout, (2): _get_text_stderr}</span>
<span class="gi">+            return func(b)</span>
<span class="gh">diff --git a/src/click/core.py b/src/click/core.py</span>
<span class="gh">index 354452a..cc65e89 100644</span>
<span class="gd">--- a/src/click/core.py</span>
<span class="gi">+++ b/src/click/core.py</span>
<span class="gu">@@ -12,6 +12,7 @@ from gettext import gettext as _</span>
<span class="w"> </span>from gettext import ngettext
<span class="w"> </span>from itertools import repeat
<span class="w"> </span>from types import TracebackType
<span class="gi">+</span>
<span class="w"> </span>from . import types
<span class="w"> </span>from .exceptions import Abort
<span class="w"> </span>from .exceptions import BadParameter
<span class="gu">@@ -35,38 +36,99 @@ from .utils import echo</span>
<span class="w"> </span>from .utils import make_default_short_help
<span class="w"> </span>from .utils import make_str
<span class="w"> </span>from .utils import PacifyFlushWrapper
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="w"> </span>    from .shell_completion import CompletionItem
<span class="gd">-F = t.TypeVar(&#39;F&#39;, bound=t.Callable[..., t.Any])</span>
<span class="gd">-V = t.TypeVar(&#39;V&#39;)</span>
<span class="gi">+</span>
<span class="gi">+F = t.TypeVar(&quot;F&quot;, bound=t.Callable[..., t.Any])</span>
<span class="gi">+V = t.TypeVar(&quot;V&quot;)</span>


<span class="gd">-def _complete_visible_commands(ctx: &#39;Context&#39;, incomplete: str) -&gt;t.Iterator[t</span>
<span class="gd">-    .Tuple[str, &#39;Command&#39;]]:</span>
<span class="gi">+def _complete_visible_commands(</span>
<span class="gi">+    ctx: &quot;Context&quot;, incomplete: str</span>
<span class="gi">+) -&gt; t.Iterator[t.Tuple[str, &quot;Command&quot;]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;List all the subcommands of a group that start with the
<span class="w"> </span>    incomplete value and aren&#39;t hidden.

<span class="w"> </span>    :param ctx: Invocation context for the group.
<span class="w"> </span>    :param incomplete: Value being completed. May be empty.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    multi = t.cast(MultiCommand, ctx.command)</span>
<span class="gi">+</span>
<span class="gi">+    for name in multi.list_commands(ctx):</span>
<span class="gi">+        if name.startswith(incomplete):</span>
<span class="gi">+            command = multi.get_command(ctx, name)</span>
<span class="gi">+</span>
<span class="gi">+            if command is not None and not command.hidden:</span>
<span class="gi">+                yield name, command</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_multicommand(</span>
<span class="gi">+    base_command: &quot;MultiCommand&quot;, cmd_name: str, cmd: &quot;Command&quot;, register: bool = False</span>
<span class="gi">+) -&gt; None:</span>
<span class="gi">+    if not base_command.chain or not isinstance(cmd, MultiCommand):</span>
<span class="gi">+        return</span>
<span class="gi">+    if register:</span>
<span class="gi">+        hint = (</span>
<span class="gi">+            &quot;It is not possible to add multi commands as children to&quot;</span>
<span class="gi">+            &quot; another multi command that is in chain mode.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        hint = (</span>
<span class="gi">+            &quot;Found a multi command as subcommand to a multi command&quot;</span>
<span class="gi">+            &quot; that is in chain mode. This is not supported.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    raise RuntimeError(</span>
<span class="gi">+        f&quot;{hint}. Command {base_command.name!r} is set to chain and&quot;</span>
<span class="gi">+        f&quot; {cmd_name!r} was added as a subcommand but it in itself is a&quot;</span>
<span class="gi">+        f&quot; multi command. ({cmd_name!r} is a {type(cmd).__name__}&quot;</span>
<span class="gi">+        f&quot; within a chained {type(base_command).__name__} named&quot;</span>
<span class="gi">+        f&quot; {base_command.name!r}).&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def batch(iterable: t.Iterable[V], batch_size: int) -&gt; t.List[t.Tuple[V, ...]]:</span>
<span class="gi">+    return list(zip(*repeat(iter(iterable), batch_size)))</span>


<span class="w"> </span>@contextmanager
<span class="gd">-def augment_usage_errors(ctx: &#39;Context&#39;, param: t.Optional[&#39;Parameter&#39;]=None</span>
<span class="gd">-    ) -&gt;t.Iterator[None]:</span>
<span class="gi">+def augment_usage_errors(</span>
<span class="gi">+    ctx: &quot;Context&quot;, param: t.Optional[&quot;Parameter&quot;] = None</span>
<span class="gi">+) -&gt; t.Iterator[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Context manager that attaches extra information to exceptions.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def iter_params_for_processing(invocation_order: t.Sequence[&#39;Parameter&#39;],</span>
<span class="gd">-    declaration_order: t.Sequence[&#39;Parameter&#39;]) -&gt;t.List[&#39;Parameter&#39;]:</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    except BadParameter as e:</span>
<span class="gi">+        if e.ctx is None:</span>
<span class="gi">+            e.ctx = ctx</span>
<span class="gi">+        if param is not None and e.param is None:</span>
<span class="gi">+            e.param = param</span>
<span class="gi">+        raise</span>
<span class="gi">+    except UsageError as e:</span>
<span class="gi">+        if e.ctx is None:</span>
<span class="gi">+            e.ctx = ctx</span>
<span class="gi">+        raise</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def iter_params_for_processing(</span>
<span class="gi">+    invocation_order: t.Sequence[&quot;Parameter&quot;],</span>
<span class="gi">+    declaration_order: t.Sequence[&quot;Parameter&quot;],</span>
<span class="gi">+) -&gt; t.List[&quot;Parameter&quot;]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Given a sequence of parameters in the order as should be considered
<span class="w"> </span>    for processing and an iterable of parameters that exist, this returns
<span class="w"> </span>    a list in the correct order as they should be processed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def sort_key(item: &quot;Parameter&quot;) -&gt; t.Tuple[bool, float]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            idx: float = invocation_order.index(item)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            idx = float(&quot;inf&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return not item.is_eager, idx</span>
<span class="gi">+</span>
<span class="gi">+    return sorted(declaration_order, key=sort_key)</span>


<span class="w"> </span>class ParameterSource(enum.Enum):
<span class="gu">@@ -82,6 +144,7 @@ class ParameterSource(enum.Enum):</span>
<span class="w"> </span>    .. versionchanged:: 8.0
<span class="w"> </span>        Added the ``PROMPT`` value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    COMMANDLINE = enum.auto()
<span class="w"> </span>    &quot;&quot;&quot;The value was provided by the command line args.&quot;&quot;&quot;
<span class="w"> </span>    ENVIRONMENT = enum.auto()
<span class="gu">@@ -188,85 +251,185 @@ class Context:</span>
<span class="w"> </span>        Added the ``resilient_parsing``, ``help_option_names``, and
<span class="w"> </span>        ``token_normalize_func`` parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    formatter_class: t.Type[&#39;HelpFormatter&#39;] = HelpFormatter</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, command: &#39;Command&#39;, parent: t.Optional[&#39;Context&#39;]=</span>
<span class="gd">-        None, info_name: t.Optional[str]=None, obj: t.Optional[t.Any]=None,</span>
<span class="gd">-        auto_envvar_prefix: t.Optional[str]=None, default_map: t.Optional[t</span>
<span class="gd">-        .MutableMapping[str, t.Any]]=None, terminal_width: t.Optional[int]=</span>
<span class="gd">-        None, max_content_width: t.Optional[int]=None, resilient_parsing:</span>
<span class="gd">-        bool=False, allow_extra_args: t.Optional[bool]=None,</span>
<span class="gd">-        allow_interspersed_args: t.Optional[bool]=None,</span>
<span class="gd">-        ignore_unknown_options: t.Optional[bool]=None, help_option_names: t</span>
<span class="gd">-        .Optional[t.List[str]]=None, token_normalize_func: t.Optional[t.</span>
<span class="gd">-        Callable[[str], str]]=None, color: t.Optional[bool]=None,</span>
<span class="gd">-        show_default: t.Optional[bool]=None) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    #: The formatter class to create with :meth:`make_formatter`.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 8.0</span>
<span class="gi">+    formatter_class: t.Type[&quot;HelpFormatter&quot;] = HelpFormatter</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        command: &quot;Command&quot;,</span>
<span class="gi">+        parent: t.Optional[&quot;Context&quot;] = None,</span>
<span class="gi">+        info_name: t.Optional[str] = None,</span>
<span class="gi">+        obj: t.Optional[t.Any] = None,</span>
<span class="gi">+        auto_envvar_prefix: t.Optional[str] = None,</span>
<span class="gi">+        default_map: t.Optional[t.MutableMapping[str, t.Any]] = None,</span>
<span class="gi">+        terminal_width: t.Optional[int] = None,</span>
<span class="gi">+        max_content_width: t.Optional[int] = None,</span>
<span class="gi">+        resilient_parsing: bool = False,</span>
<span class="gi">+        allow_extra_args: t.Optional[bool] = None,</span>
<span class="gi">+        allow_interspersed_args: t.Optional[bool] = None,</span>
<span class="gi">+        ignore_unknown_options: t.Optional[bool] = None,</span>
<span class="gi">+        help_option_names: t.Optional[t.List[str]] = None,</span>
<span class="gi">+        token_normalize_func: t.Optional[t.Callable[[str], str]] = None,</span>
<span class="gi">+        color: t.Optional[bool] = None,</span>
<span class="gi">+        show_default: t.Optional[bool] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        #: the parent context or `None` if none exists.</span>
<span class="w"> </span>        self.parent = parent
<span class="gi">+        #: the :class:`Command` for this context.</span>
<span class="w"> </span>        self.command = command
<span class="gi">+        #: the descriptive information name</span>
<span class="w"> </span>        self.info_name = info_name
<span class="gi">+        #: Map of parameter names to their parsed values. Parameters</span>
<span class="gi">+        #: with ``expose_value=False`` are not stored.</span>
<span class="w"> </span>        self.params: t.Dict[str, t.Any] = {}
<span class="gi">+        #: the leftover arguments.</span>
<span class="w"> </span>        self.args: t.List[str] = []
<span class="gi">+        #: protected arguments.  These are arguments that are prepended</span>
<span class="gi">+        #: to `args` when certain parsing scenarios are encountered but</span>
<span class="gi">+        #: must be never propagated to another arguments.  This is used</span>
<span class="gi">+        #: to implement nested parsing.</span>
<span class="w"> </span>        self.protected_args: t.List[str] = []
<span class="gd">-        self._opt_prefixes: t.Set[str] = set(parent._opt_prefixes</span>
<span class="gd">-            ) if parent else set()</span>
<span class="gi">+        #: the collected prefixes of the command&#39;s options.</span>
<span class="gi">+        self._opt_prefixes: t.Set[str] = set(parent._opt_prefixes) if parent else set()</span>
<span class="gi">+</span>
<span class="w"> </span>        if obj is None and parent is not None:
<span class="w"> </span>            obj = parent.obj
<span class="gi">+</span>
<span class="gi">+        #: the user object stored.</span>
<span class="w"> </span>        self.obj: t.Any = obj
<span class="gd">-        self._meta: t.Dict[str, t.Any] = getattr(parent, &#39;meta&#39;, {})</span>
<span class="gd">-        if (default_map is None and info_name is not None and parent is not</span>
<span class="gd">-            None and parent.default_map is not None):</span>
<span class="gi">+        self._meta: t.Dict[str, t.Any] = getattr(parent, &quot;meta&quot;, {})</span>
<span class="gi">+</span>
<span class="gi">+        #: A dictionary (-like object) with defaults for parameters.</span>
<span class="gi">+        if (</span>
<span class="gi">+            default_map is None</span>
<span class="gi">+            and info_name is not None</span>
<span class="gi">+            and parent is not None</span>
<span class="gi">+            and parent.default_map is not None</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            default_map = parent.default_map.get(info_name)
<span class="gd">-        self.default_map: t.Optional[t.MutableMapping[str, t.Any]</span>
<span class="gd">-            ] = default_map</span>
<span class="gi">+</span>
<span class="gi">+        self.default_map: t.Optional[t.MutableMapping[str, t.Any]] = default_map</span>
<span class="gi">+</span>
<span class="gi">+        #: This flag indicates if a subcommand is going to be executed. A</span>
<span class="gi">+        #: group callback can use this information to figure out if it&#39;s</span>
<span class="gi">+        #: being executed directly or because the execution flow passes</span>
<span class="gi">+        #: onwards to a subcommand. By default it&#39;s None, but it can be</span>
<span class="gi">+        #: the name of the subcommand to execute.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: If chaining is enabled this will be set to ``&#39;*&#39;`` in case</span>
<span class="gi">+        #: any commands are executed.  It is however not possible to</span>
<span class="gi">+        #: figure out which ones.  If you require this knowledge you</span>
<span class="gi">+        #: should use a :func:`result_callback`.</span>
<span class="w"> </span>        self.invoked_subcommand: t.Optional[str] = None
<span class="gi">+</span>
<span class="w"> </span>        if terminal_width is None and parent is not None:
<span class="w"> </span>            terminal_width = parent.terminal_width
<span class="gi">+</span>
<span class="gi">+        #: The width of the terminal (None is autodetection).</span>
<span class="w"> </span>        self.terminal_width: t.Optional[int] = terminal_width
<span class="gi">+</span>
<span class="w"> </span>        if max_content_width is None and parent is not None:
<span class="w"> </span>            max_content_width = parent.max_content_width
<span class="gi">+</span>
<span class="gi">+        #: The maximum width of formatted content (None implies a sensible</span>
<span class="gi">+        #: default which is 80 for most things).</span>
<span class="w"> </span>        self.max_content_width: t.Optional[int] = max_content_width
<span class="gi">+</span>
<span class="w"> </span>        if allow_extra_args is None:
<span class="w"> </span>            allow_extra_args = command.allow_extra_args
<span class="gi">+</span>
<span class="gi">+        #: Indicates if the context allows extra args or if it should</span>
<span class="gi">+        #: fail on parsing.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: .. versionadded:: 3.0</span>
<span class="w"> </span>        self.allow_extra_args = allow_extra_args
<span class="gi">+</span>
<span class="w"> </span>        if allow_interspersed_args is None:
<span class="w"> </span>            allow_interspersed_args = command.allow_interspersed_args
<span class="gi">+</span>
<span class="gi">+        #: Indicates if the context allows mixing of arguments and</span>
<span class="gi">+        #: options or not.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: .. versionadded:: 3.0</span>
<span class="w"> </span>        self.allow_interspersed_args: bool = allow_interspersed_args
<span class="gi">+</span>
<span class="w"> </span>        if ignore_unknown_options is None:
<span class="w"> </span>            ignore_unknown_options = command.ignore_unknown_options
<span class="gi">+</span>
<span class="gi">+        #: Instructs click to ignore options that a command does not</span>
<span class="gi">+        #: understand and will store it on the context for later</span>
<span class="gi">+        #: processing.  This is primarily useful for situations where you</span>
<span class="gi">+        #: want to call into external programs.  Generally this pattern is</span>
<span class="gi">+        #: strongly discouraged because it&#39;s not possibly to losslessly</span>
<span class="gi">+        #: forward all arguments.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: .. versionadded:: 4.0</span>
<span class="w"> </span>        self.ignore_unknown_options: bool = ignore_unknown_options
<span class="gi">+</span>
<span class="w"> </span>        if help_option_names is None:
<span class="w"> </span>            if parent is not None:
<span class="w"> </span>                help_option_names = parent.help_option_names
<span class="w"> </span>            else:
<span class="gd">-                help_option_names = [&#39;--help&#39;]</span>
<span class="gi">+                help_option_names = [&quot;--help&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        #: The names for the help options.</span>
<span class="w"> </span>        self.help_option_names: t.List[str] = help_option_names
<span class="gi">+</span>
<span class="w"> </span>        if token_normalize_func is None and parent is not None:
<span class="w"> </span>            token_normalize_func = parent.token_normalize_func
<span class="gd">-        self.token_normalize_func: t.Optional[t.Callable[[str], str]</span>
<span class="gd">-            ] = token_normalize_func</span>
<span class="gi">+</span>
<span class="gi">+        #: An optional normalization function for tokens.  This is</span>
<span class="gi">+        #: options, choices, commands etc.</span>
<span class="gi">+        self.token_normalize_func: t.Optional[</span>
<span class="gi">+            t.Callable[[str], str]</span>
<span class="gi">+        ] = token_normalize_func</span>
<span class="gi">+</span>
<span class="gi">+        #: Indicates if resilient parsing is enabled.  In that case Click</span>
<span class="gi">+        #: will do its best to not cause any failures and default values</span>
<span class="gi">+        #: will be ignored. Useful for completion.</span>
<span class="w"> </span>        self.resilient_parsing: bool = resilient_parsing
<span class="gi">+</span>
<span class="gi">+        # If there is no envvar prefix yet, but the parent has one and</span>
<span class="gi">+        # the command on this level has a name, we can expand the envvar</span>
<span class="gi">+        # prefix automatically.</span>
<span class="w"> </span>        if auto_envvar_prefix is None:
<span class="gd">-            if (parent is not None and parent.auto_envvar_prefix is not</span>
<span class="gd">-                None and self.info_name is not None):</span>
<span class="gi">+            if (</span>
<span class="gi">+                parent is not None</span>
<span class="gi">+                and parent.auto_envvar_prefix is not None</span>
<span class="gi">+                and self.info_name is not None</span>
<span class="gi">+            ):</span>
<span class="w"> </span>                auto_envvar_prefix = (
<span class="gd">-                    f&#39;{parent.auto_envvar_prefix}_{self.info_name.upper()}&#39;)</span>
<span class="gi">+                    f&quot;{parent.auto_envvar_prefix}_{self.info_name.upper()}&quot;</span>
<span class="gi">+                )</span>
<span class="w"> </span>        else:
<span class="w"> </span>            auto_envvar_prefix = auto_envvar_prefix.upper()
<span class="gi">+</span>
<span class="w"> </span>        if auto_envvar_prefix is not None:
<span class="gd">-            auto_envvar_prefix = auto_envvar_prefix.replace(&#39;-&#39;, &#39;_&#39;)</span>
<span class="gi">+            auto_envvar_prefix = auto_envvar_prefix.replace(&quot;-&quot;, &quot;_&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.auto_envvar_prefix: t.Optional[str] = auto_envvar_prefix
<span class="gi">+</span>
<span class="w"> </span>        if color is None and parent is not None:
<span class="w"> </span>            color = parent.color
<span class="gi">+</span>
<span class="gi">+        #: Controls if styling output is wanted or not.</span>
<span class="w"> </span>        self.color: t.Optional[bool] = color
<span class="gi">+</span>
<span class="w"> </span>        if show_default is None and parent is not None:
<span class="w"> </span>            show_default = parent.show_default
<span class="gi">+</span>
<span class="gi">+        #: Show option default values when formatting help text.</span>
<span class="w"> </span>        self.show_default: t.Optional[bool] = show_default
<span class="gi">+</span>
<span class="w"> </span>        self._close_callbacks: t.List[t.Callable[[], t.Any]] = []
<span class="w"> </span>        self._depth = 0
<span class="w"> </span>        self._parameter_source: t.Dict[str, ParameterSource] = {}
<span class="w"> </span>        self._exit_stack = ExitStack()

<span class="gd">-    def to_info_dict(self) -&gt;t.Dict[str, t.Any]:</span>
<span class="gi">+    def to_info_dict(self) -&gt; t.Dict[str, t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Gather information that could be useful for a tool generating
<span class="w"> </span>        user-facing documentation. This traverses the entire CLI
<span class="w"> </span>        structure.
<span class="gu">@@ -278,23 +441,33 @@ class Context:</span>

<span class="w"> </span>        .. versionadded:: 8.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __enter__(self) -&gt;&#39;Context&#39;:</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;command&quot;: self.command.to_info_dict(self),</span>
<span class="gi">+            &quot;info_name&quot;: self.info_name,</span>
<span class="gi">+            &quot;allow_extra_args&quot;: self.allow_extra_args,</span>
<span class="gi">+            &quot;allow_interspersed_args&quot;: self.allow_interspersed_args,</span>
<span class="gi">+            &quot;ignore_unknown_options&quot;: self.ignore_unknown_options,</span>
<span class="gi">+            &quot;auto_envvar_prefix&quot;: self.auto_envvar_prefix,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def __enter__(self) -&gt; &quot;Context&quot;:</span>
<span class="w"> </span>        self._depth += 1
<span class="w"> </span>        push_context(self)
<span class="w"> </span>        return self

<span class="gd">-    def __exit__(self, exc_type: t.Optional[t.Type[BaseException]],</span>
<span class="gd">-        exc_value: t.Optional[BaseException], tb: t.Optional[TracebackType]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exc_type: t.Optional[t.Type[BaseException]],</span>
<span class="gi">+        exc_value: t.Optional[BaseException],</span>
<span class="gi">+        tb: t.Optional[TracebackType],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._depth -= 1
<span class="w"> </span>        if self._depth == 0:
<span class="w"> </span>            self.close()
<span class="w"> </span>        pop_context()

<span class="w"> </span>    @contextmanager
<span class="gd">-    def scope(self, cleanup: bool=True) -&gt;t.Iterator[&#39;Context&#39;]:</span>
<span class="gi">+    def scope(self, cleanup: bool = True) -&gt; t.Iterator[&quot;Context&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;This helper method can be used with the context object to promote
<span class="w"> </span>        it to the current thread local (see :func:`get_current_context`).
<span class="w"> </span>        The default behavior of this is to invoke the cleanup functions which
<span class="gu">@@ -322,10 +495,17 @@ class Context:</span>
<span class="w"> </span>                        temporarily pushed in which case this can be disabled.
<span class="w"> </span>                        Nested pushes automatically defer the cleanup.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not cleanup:</span>
<span class="gi">+            self._depth += 1</span>
<span class="gi">+        try:</span>
<span class="gi">+            with self as rv:</span>
<span class="gi">+                yield rv</span>
<span class="gi">+        finally:</span>
<span class="gi">+            if not cleanup:</span>
<span class="gi">+                self._depth -= 1</span>

<span class="w"> </span>    @property
<span class="gd">-    def meta(self) -&gt;t.Dict[str, t.Any]:</span>
<span class="gi">+    def meta(self) -&gt; t.Dict[str, t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;This is a dictionary which is shared with all the contexts
<span class="w"> </span>        that are nested.  It exists so that click utilities can store some
<span class="w"> </span>        state here if they need to.  It is however the responsibility of
<span class="gu">@@ -350,9 +530,9 @@ class Context:</span>

<span class="w"> </span>        .. versionadded:: 5.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._meta</span>

<span class="gd">-    def make_formatter(self) -&gt;HelpFormatter:</span>
<span class="gi">+    def make_formatter(self) -&gt; HelpFormatter:</span>
<span class="w"> </span>        &quot;&quot;&quot;Creates the :class:`~click.HelpFormatter` for the help and
<span class="w"> </span>        usage output.

<span class="gu">@@ -362,9 +542,11 @@ class Context:</span>
<span class="w"> </span>        .. versionchanged:: 8.0
<span class="w"> </span>            Added the :attr:`formatter_class` attribute.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.formatter_class(</span>
<span class="gi">+            width=self.terminal_width, max_width=self.max_content_width</span>
<span class="gi">+        )</span>

<span class="gd">-    def with_resource(self, context_manager: t.ContextManager[V]) -&gt;V:</span>
<span class="gi">+    def with_resource(self, context_manager: t.ContextManager[V]) -&gt; V:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a resource as if it were used in a ``with``
<span class="w"> </span>        statement. The resource will be cleaned up when the context is
<span class="w"> </span>        popped.
<span class="gu">@@ -391,10 +573,9 @@ class Context:</span>

<span class="w"> </span>        .. versionadded:: 8.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._exit_stack.enter_context(context_manager)</span>

<span class="gd">-    def call_on_close(self, f: t.Callable[..., t.Any]) -&gt;t.Callable[..., t.Any</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def call_on_close(self, f: t.Callable[..., t.Any]) -&gt; t.Callable[..., t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a function to be called when the context tears down.

<span class="w"> </span>        This can be used to close resources opened during the script
<span class="gu">@@ -404,38 +585,77 @@ class Context:</span>

<span class="w"> </span>        :param f: The function to execute on teardown.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._exit_stack.callback(f)</span>

<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Invoke all close callbacks registered with
<span class="w"> </span>        :meth:`call_on_close`, and exit all context managers entered
<span class="w"> </span>        with :meth:`with_resource`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._exit_stack.close()</span>
<span class="gi">+        # In case the context is reused, create a new exit stack.</span>
<span class="gi">+        self._exit_stack = ExitStack()</span>

<span class="w"> </span>    @property
<span class="gd">-    def command_path(self) -&gt;str:</span>
<span class="gi">+    def command_path(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;The computed command path.  This is used for the ``usage``
<span class="w"> </span>        information on the help page.  It&#39;s automatically created by
<span class="w"> </span>        combining the info names of the chain of contexts to the root.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = &quot;&quot;</span>
<span class="gi">+        if self.info_name is not None:</span>
<span class="gi">+            rv = self.info_name</span>
<span class="gi">+        if self.parent is not None:</span>
<span class="gi">+            parent_command_path = [self.parent.command_path]</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(self.parent.command, Command):</span>
<span class="gi">+                for param in self.parent.command.get_params(self):</span>
<span class="gi">+                    parent_command_path.extend(param.get_usage_pieces(self))</span>

<span class="gd">-    def find_root(self) -&gt;&#39;Context&#39;:</span>
<span class="gi">+            rv = f&quot;{&#39; &#39;.join(parent_command_path)} {rv}&quot;</span>
<span class="gi">+        return rv.lstrip()</span>
<span class="gi">+</span>
<span class="gi">+    def find_root(self) -&gt; &quot;Context&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Finds the outermost context.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        node = self</span>
<span class="gi">+        while node.parent is not None:</span>
<span class="gi">+            node = node.parent</span>
<span class="gi">+        return node</span>

<span class="gd">-    def find_object(self, object_type: t.Type[V]) -&gt;t.Optional[V]:</span>
<span class="gi">+    def find_object(self, object_type: t.Type[V]) -&gt; t.Optional[V]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Finds the closest object of a given type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        node: t.Optional[&quot;Context&quot;] = self</span>

<span class="gd">-    def ensure_object(self, object_type: t.Type[V]) -&gt;V:</span>
<span class="gi">+        while node is not None:</span>
<span class="gi">+            if isinstance(node.obj, object_type):</span>
<span class="gi">+                return node.obj</span>
<span class="gi">+</span>
<span class="gi">+            node = node.parent</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def ensure_object(self, object_type: t.Type[V]) -&gt; V:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like :meth:`find_object` but sets the innermost object to a
<span class="w"> </span>        new instance of `object_type` if it does not exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def lookup_default(self, name: str, call: bool=True) -&gt;t.Optional[t.Any]:</span>
<span class="gi">+        rv = self.find_object(object_type)</span>
<span class="gi">+        if rv is None:</span>
<span class="gi">+            self.obj = rv = object_type()</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    @t.overload</span>
<span class="gi">+    def lookup_default(</span>
<span class="gi">+        self, name: str, call: &quot;te.Literal[True]&quot; = True</span>
<span class="gi">+    ) -&gt; t.Optional[t.Any]:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @t.overload</span>
<span class="gi">+    def lookup_default(</span>
<span class="gi">+        self, name: str, call: &quot;te.Literal[False]&quot; = ...</span>
<span class="gi">+    ) -&gt; t.Optional[t.Union[t.Any, t.Callable[[], t.Any]]]:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    def lookup_default(self, name: str, call: bool = True) -&gt; t.Optional[t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the default for a parameter from :attr:`default_map`.

<span class="w"> </span>        :param name: Name of the parameter.
<span class="gu">@@ -445,46 +665,76 @@ class Context:</span>
<span class="w"> </span>        .. versionchanged:: 8.0
<span class="w"> </span>            Added the ``call`` parameter.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.default_map is not None:</span>
<span class="gi">+            value = self.default_map.get(name)</span>
<span class="gi">+</span>
<span class="gi">+            if call and callable(value):</span>
<span class="gi">+                return value()</span>
<span class="gi">+</span>
<span class="gi">+            return value</span>

<span class="gd">-    def fail(self, message: str) -&gt;&#39;te.NoReturn&#39;:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def fail(self, message: str) -&gt; &quot;te.NoReturn&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Aborts the execution of the program with a specific error
<span class="w"> </span>        message.

<span class="w"> </span>        :param message: the error message to fail with.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise UsageError(message, self)</span>

<span class="gd">-    def abort(self) -&gt;&#39;te.NoReturn&#39;:</span>
<span class="gi">+    def abort(self) -&gt; &quot;te.NoReturn&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Aborts the script.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise Abort()</span>

<span class="gd">-    def exit(self, code: int=0) -&gt;&#39;te.NoReturn&#39;:</span>
<span class="gi">+    def exit(self, code: int = 0) -&gt; &quot;te.NoReturn&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Exits the application with a given exit code.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise Exit(code)</span>

<span class="gd">-    def get_usage(self) -&gt;str:</span>
<span class="gi">+    def get_usage(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Helper method to get formatted usage string for the current
<span class="w"> </span>        context and command.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.command.get_usage(self)</span>

<span class="gd">-    def get_help(self) -&gt;str:</span>
<span class="gi">+    def get_help(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Helper method to get formatted help page for the current
<span class="w"> </span>        context and command.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.command.get_help(self)</span>

<span class="gd">-    def _make_sub_context(self, command: &#39;Command&#39;) -&gt;&#39;Context&#39;:</span>
<span class="gi">+    def _make_sub_context(self, command: &quot;Command&quot;) -&gt; &quot;Context&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new context of the same type as this context, but
<span class="w"> </span>        for a new command.

<span class="w"> </span>        :meta private:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def invoke(__self, __callback: t.Union[&#39;Command&#39;, &#39;t.Callable[..., V]&#39;],</span>
<span class="gd">-        *args: t.Any, **kwargs: t.Any) -&gt;t.Union[t.Any, V]:</span>
<span class="gi">+        return type(self)(command, info_name=command.name, parent=self)</span>
<span class="gi">+</span>
<span class="gi">+    @t.overload</span>
<span class="gi">+    def invoke(</span>
<span class="gi">+        __self,  # noqa: B902</span>
<span class="gi">+        __callback: &quot;t.Callable[..., V]&quot;,</span>
<span class="gi">+        *args: t.Any,</span>
<span class="gi">+        **kwargs: t.Any,</span>
<span class="gi">+    ) -&gt; V:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @t.overload</span>
<span class="gi">+    def invoke(</span>
<span class="gi">+        __self,  # noqa: B902</span>
<span class="gi">+        __callback: &quot;Command&quot;,</span>
<span class="gi">+        *args: t.Any,</span>
<span class="gi">+        **kwargs: t.Any,</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    def invoke(</span>
<span class="gi">+        __self,  # noqa: B902</span>
<span class="gi">+        __callback: t.Union[&quot;Command&quot;, &quot;t.Callable[..., V]&quot;],</span>
<span class="gi">+        *args: t.Any,</span>
<span class="gi">+        **kwargs: t.Any,</span>
<span class="gi">+    ) -&gt; t.Union[t.Any, V]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Invokes a command callback in exactly the way it expects.  There
<span class="w"> </span>        are two ways to invoke this method:

<span class="gu">@@ -504,10 +754,37 @@ class Context:</span>
<span class="w"> </span>            All ``kwargs`` are tracked in :attr:`params` so they will be
<span class="w"> </span>            passed if :meth:`forward` is called at multiple levels.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(__callback, Command):</span>
<span class="gi">+            other_cmd = __callback</span>
<span class="gi">+</span>
<span class="gi">+            if other_cmd.callback is None:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    &quot;The given command does not have a callback that can be invoked.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                __callback = t.cast(&quot;t.Callable[..., V]&quot;, other_cmd.callback)</span>
<span class="gi">+</span>
<span class="gi">+            ctx = __self._make_sub_context(other_cmd)</span>
<span class="gi">+</span>
<span class="gi">+            for param in other_cmd.params:</span>
<span class="gi">+                if param.name not in kwargs and param.expose_value:</span>
<span class="gi">+                    kwargs[param.name] = param.type_cast_value(  # type: ignore</span>
<span class="gi">+                        ctx, param.get_default(ctx)</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+            # Track all kwargs as params, so that forward() will pass</span>
<span class="gi">+            # them on in subsequent calls.</span>
<span class="gi">+            ctx.params.update(kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            ctx = __self</span>
<span class="gi">+</span>
<span class="gi">+        with augment_usage_errors(__self):</span>
<span class="gi">+            with ctx:</span>
<span class="gi">+                return __callback(*args, **kwargs)</span>

<span class="gd">-    def forward(__self, __cmd: &#39;Command&#39;, *args: t.Any, **kwargs: t.Any</span>
<span class="gd">-        ) -&gt;t.Any:</span>
<span class="gi">+    def forward(</span>
<span class="gi">+        __self, __cmd: &quot;Command&quot;, *args: t.Any, **kwargs: t.Any  # noqa: B902</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Similar to :meth:`invoke` but fills in default keyword
<span class="w"> </span>        arguments from the current context if the other command expects
<span class="w"> </span>        it.  This cannot invoke callbacks directly, only other commands.
<span class="gu">@@ -516,18 +793,26 @@ class Context:</span>
<span class="w"> </span>            All ``kwargs`` are tracked in :attr:`params` so they will be
<span class="w"> </span>            passed if ``forward`` is called at multiple levels.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Can only forward to other commands, not direct callbacks.</span>
<span class="gi">+        if not isinstance(__cmd, Command):</span>
<span class="gi">+            raise TypeError(&quot;Callback is not a command.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        for param in __self.params:</span>
<span class="gi">+            if param not in kwargs:</span>
<span class="gi">+                kwargs[param] = __self.params[param]</span>
<span class="gi">+</span>
<span class="gi">+        return __self.invoke(__cmd, *args, **kwargs)</span>

<span class="gd">-    def set_parameter_source(self, name: str, source: ParameterSource) -&gt;None:</span>
<span class="gi">+    def set_parameter_source(self, name: str, source: ParameterSource) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the source of a parameter. This indicates the location
<span class="w"> </span>        from which the value of the parameter was obtained.

<span class="w"> </span>        :param name: The name of the parameter.
<span class="w"> </span>        :param source: A member of :class:`~click.core.ParameterSource`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._parameter_source[name] = source</span>

<span class="gd">-    def get_parameter_source(self, name: str) -&gt;t.Optional[ParameterSource]:</span>
<span class="gi">+    def get_parameter_source(self, name: str) -&gt; t.Optional[ParameterSource]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the source of a parameter. This indicates the location
<span class="w"> </span>        from which the value of the parameter was obtained.

<span class="gu">@@ -543,7 +828,7 @@ class Context:</span>
<span class="w"> </span>            Returns ``None`` if the parameter was not provided from any
<span class="w"> </span>            source.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._parameter_source.get(name)</span>


<span class="w"> </span>class BaseCommand:
<span class="gu">@@ -567,19 +852,36 @@ class BaseCommand:</span>
<span class="w"> </span>    :param context_settings: an optional dictionary with defaults that are
<span class="w"> </span>                             passed to the context object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    #: The context class to create with :meth:`make_context`.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 8.0</span>
<span class="w"> </span>    context_class: t.Type[Context] = Context
<span class="gi">+    #: the default for the :attr:`Context.allow_extra_args` flag.</span>
<span class="w"> </span>    allow_extra_args = False
<span class="gi">+    #: the default for the :attr:`Context.allow_interspersed_args` flag.</span>
<span class="w"> </span>    allow_interspersed_args = True
<span class="gi">+    #: the default for the :attr:`Context.ignore_unknown_options` flag.</span>
<span class="w"> </span>    ignore_unknown_options = False

<span class="gd">-    def __init__(self, name: t.Optional[str], context_settings: t.Optional[</span>
<span class="gd">-        t.MutableMapping[str, t.Any]]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: t.Optional[str],</span>
<span class="gi">+        context_settings: t.Optional[t.MutableMapping[str, t.Any]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        #: the name the command thinks it has.  Upon registering a command</span>
<span class="gi">+        #: on a :class:`Group` the group will default the command name</span>
<span class="gi">+        #: with this information.  You should instead use the</span>
<span class="gi">+        #: :class:`Context`\&#39;s :attr:`~Context.info_name` attribute.</span>
<span class="w"> </span>        self.name = name
<span class="gi">+</span>
<span class="w"> </span>        if context_settings is None:
<span class="w"> </span>            context_settings = {}
<span class="gi">+</span>
<span class="gi">+        #: an optional dictionary with defaults passed to the context.</span>
<span class="w"> </span>        self.context_settings: t.MutableMapping[str, t.Any] = context_settings

<span class="gd">-    def to_info_dict(self, ctx: Context) -&gt;t.Dict[str, t.Any]:</span>
<span class="gi">+    def to_info_dict(self, ctx: Context) -&gt; t.Dict[str, t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Gather information that could be useful for a tool generating
<span class="w"> </span>        user-facing documentation. This traverses the entire structure
<span class="w"> </span>        below this command.
<span class="gu">@@ -591,13 +893,24 @@ class BaseCommand:</span>

<span class="w"> </span>        .. versionadded:: 8.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {&quot;name&quot;: self.name}</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{self.__class__.__name__} {self.name}&gt;&quot;</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;{self.__class__.__name__} {self.name}&gt;&#39;</span>
<span class="gi">+    def get_usage(self, ctx: Context) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError(&quot;Base commands cannot get usage&quot;)</span>

<span class="gd">-    def make_context(self, info_name: t.Optional[str], args: t.List[str],</span>
<span class="gd">-        parent: t.Optional[Context]=None, **extra: t.Any) -&gt;Context:</span>
<span class="gi">+    def get_help(self, ctx: Context) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError(&quot;Base commands cannot get help&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def make_context(</span>
<span class="gi">+        self,</span>
<span class="gi">+        info_name: t.Optional[str],</span>
<span class="gi">+        args: t.List[str],</span>
<span class="gi">+        parent: t.Optional[Context] = None,</span>
<span class="gi">+        **extra: t.Any,</span>
<span class="gi">+    ) -&gt; Context:</span>
<span class="w"> </span>        &quot;&quot;&quot;This function when given an info name and arguments will kick
<span class="w"> </span>        off the parsing and create a new :class:`Context`.  It does not
<span class="w"> </span>        invoke the actual command callback though.
<span class="gu">@@ -618,23 +931,32 @@ class BaseCommand:</span>
<span class="w"> </span>        .. versionchanged:: 8.0
<span class="w"> </span>            Added the :attr:`context_class` attribute.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for key, value in self.context_settings.items():</span>
<span class="gi">+            if key not in extra:</span>
<span class="gi">+                extra[key] = value</span>
<span class="gi">+</span>
<span class="gi">+        ctx = self.context_class(</span>
<span class="gi">+            self, info_name=info_name, parent=parent, **extra  # type: ignore</span>
<span class="gi">+        )</span>

<span class="gd">-    def parse_args(self, ctx: Context, args: t.List[str]) -&gt;t.List[str]:</span>
<span class="gi">+        with ctx.scope(cleanup=False):</span>
<span class="gi">+            self.parse_args(ctx, args)</span>
<span class="gi">+        return ctx</span>
<span class="gi">+</span>
<span class="gi">+    def parse_args(self, ctx: Context, args: t.List[str]) -&gt; t.List[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given a context and a list of arguments this creates the parser
<span class="w"> </span>        and parses the arguments, then modifies the context as necessary.
<span class="w"> </span>        This is automatically invoked by :meth:`make_context`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;Base commands do not know how to parse arguments.&quot;)</span>

<span class="gd">-    def invoke(self, ctx: Context) -&gt;t.Any:</span>
<span class="gi">+    def invoke(self, ctx: Context) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given a context, this invokes the command.  The default
<span class="w"> </span>        implementation is raising a not implemented error.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;Base commands are not invocable by default&quot;)</span>

<span class="gd">-    def shell_complete(self, ctx: Context, incomplete: str) -&gt;t.List[</span>
<span class="gd">-        &#39;CompletionItem&#39;]:</span>
<span class="gi">+    def shell_complete(self, ctx: Context, incomplete: str) -&gt; t.List[&quot;CompletionItem&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of completions for the incomplete value. Looks
<span class="w"> </span>        at the names of chained multi-commands.

<span class="gu">@@ -647,12 +969,53 @@ class BaseCommand:</span>

<span class="w"> </span>        .. versionadded:: 8.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def main(self, args: t.Optional[t.Sequence[str]]=None, prog_name: t.</span>
<span class="gd">-        Optional[str]=None, complete_var: t.Optional[str]=None,</span>
<span class="gd">-        standalone_mode: bool=True, windows_expand_args: bool=True, **extra:</span>
<span class="gd">-        t.Any) -&gt;t.Any:</span>
<span class="gi">+        from click.shell_completion import CompletionItem</span>
<span class="gi">+</span>
<span class="gi">+        results: t.List[&quot;CompletionItem&quot;] = []</span>
<span class="gi">+</span>
<span class="gi">+        while ctx.parent is not None:</span>
<span class="gi">+            ctx = ctx.parent</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(ctx.command, MultiCommand) and ctx.command.chain:</span>
<span class="gi">+                results.extend(</span>
<span class="gi">+                    CompletionItem(name, help=command.get_short_help_str())</span>
<span class="gi">+                    for name, command in _complete_visible_commands(ctx, incomplete)</span>
<span class="gi">+                    if name not in ctx.protected_args</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        return results</span>
<span class="gi">+</span>
<span class="gi">+    @t.overload</span>
<span class="gi">+    def main(</span>
<span class="gi">+        self,</span>
<span class="gi">+        args: t.Optional[t.Sequence[str]] = None,</span>
<span class="gi">+        prog_name: t.Optional[str] = None,</span>
<span class="gi">+        complete_var: t.Optional[str] = None,</span>
<span class="gi">+        standalone_mode: &quot;te.Literal[True]&quot; = True,</span>
<span class="gi">+        **extra: t.Any,</span>
<span class="gi">+    ) -&gt; &quot;te.NoReturn&quot;:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @t.overload</span>
<span class="gi">+    def main(</span>
<span class="gi">+        self,</span>
<span class="gi">+        args: t.Optional[t.Sequence[str]] = None,</span>
<span class="gi">+        prog_name: t.Optional[str] = None,</span>
<span class="gi">+        complete_var: t.Optional[str] = None,</span>
<span class="gi">+        standalone_mode: bool = ...,</span>
<span class="gi">+        **extra: t.Any,</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    def main(</span>
<span class="gi">+        self,</span>
<span class="gi">+        args: t.Optional[t.Sequence[str]] = None,</span>
<span class="gi">+        prog_name: t.Optional[str] = None,</span>
<span class="gi">+        complete_var: t.Optional[str] = None,</span>
<span class="gi">+        standalone_mode: bool = True,</span>
<span class="gi">+        windows_expand_args: bool = True,</span>
<span class="gi">+        **extra: t.Any,</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;This is the way to invoke a script with all the bells and
<span class="w"> </span>        whistles as a command line application.  This will always terminate
<span class="w"> </span>        the application after a call.  If this is not wanted, ``SystemExit``
<span class="gu">@@ -695,10 +1058,74 @@ class BaseCommand:</span>
<span class="w"> </span>        .. versionchanged:: 3.0
<span class="w"> </span>           Added the ``standalone_mode`` parameter.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if args is None:</span>
<span class="gi">+            args = sys.argv[1:]</span>

<span class="gd">-    def _main_shell_completion(self, ctx_args: t.MutableMapping[str, t.Any],</span>
<span class="gd">-        prog_name: str, complete_var: t.Optional[str]=None) -&gt;None:</span>
<span class="gi">+            if os.name == &quot;nt&quot; and windows_expand_args:</span>
<span class="gi">+                args = _expand_args(args)</span>
<span class="gi">+        else:</span>
<span class="gi">+            args = list(args)</span>
<span class="gi">+</span>
<span class="gi">+        if prog_name is None:</span>
<span class="gi">+            prog_name = _detect_program_name()</span>
<span class="gi">+</span>
<span class="gi">+        # Process shell completion requests and exit early.</span>
<span class="gi">+        self._main_shell_completion(extra, prog_name, complete_var)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            try:</span>
<span class="gi">+                with self.make_context(prog_name, args, **extra) as ctx:</span>
<span class="gi">+                    rv = self.invoke(ctx)</span>
<span class="gi">+                    if not standalone_mode:</span>
<span class="gi">+                        return rv</span>
<span class="gi">+                    # it&#39;s not safe to `ctx.exit(rv)` here!</span>
<span class="gi">+                    # note that `rv` may actually contain data like &quot;1&quot; which</span>
<span class="gi">+                    # has obvious effects</span>
<span class="gi">+                    # more subtle case: `rv=[None, None]` can come out of</span>
<span class="gi">+                    # chained commands which all returned `None` -- so it&#39;s not</span>
<span class="gi">+                    # even always obvious that `rv` indicates success/failure</span>
<span class="gi">+                    # by its truthiness/falsiness</span>
<span class="gi">+                    ctx.exit()</span>
<span class="gi">+            except (EOFError, KeyboardInterrupt) as e:</span>
<span class="gi">+                echo(file=sys.stderr)</span>
<span class="gi">+                raise Abort() from e</span>
<span class="gi">+            except ClickException as e:</span>
<span class="gi">+                if not standalone_mode:</span>
<span class="gi">+                    raise</span>
<span class="gi">+                e.show()</span>
<span class="gi">+                sys.exit(e.exit_code)</span>
<span class="gi">+            except OSError as e:</span>
<span class="gi">+                if e.errno == errno.EPIPE:</span>
<span class="gi">+                    sys.stdout = t.cast(t.TextIO, PacifyFlushWrapper(sys.stdout))</span>
<span class="gi">+                    sys.stderr = t.cast(t.TextIO, PacifyFlushWrapper(sys.stderr))</span>
<span class="gi">+                    sys.exit(1)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise</span>
<span class="gi">+        except Exit as e:</span>
<span class="gi">+            if standalone_mode:</span>
<span class="gi">+                sys.exit(e.exit_code)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # in non-standalone mode, return the exit code</span>
<span class="gi">+                # note that this is only reached if `self.invoke` above raises</span>
<span class="gi">+                # an Exit explicitly -- thus bypassing the check there which</span>
<span class="gi">+                # would return its result</span>
<span class="gi">+                # the results of non-standalone execution may therefore be</span>
<span class="gi">+                # somewhat ambiguous: if there are codepaths which lead to</span>
<span class="gi">+                # `ctx.exit(1)` and to `return 1`, the caller won&#39;t be able to</span>
<span class="gi">+                # tell the difference between the two</span>
<span class="gi">+                return e.exit_code</span>
<span class="gi">+        except Abort:</span>
<span class="gi">+            if not standalone_mode:</span>
<span class="gi">+                raise</span>
<span class="gi">+            echo(_(&quot;Aborted!&quot;), file=sys.stderr)</span>
<span class="gi">+            sys.exit(1)</span>
<span class="gi">+</span>
<span class="gi">+    def _main_shell_completion(</span>
<span class="gi">+        self,</span>
<span class="gi">+        ctx_args: t.MutableMapping[str, t.Any],</span>
<span class="gi">+        prog_name: str,</span>
<span class="gi">+        complete_var: t.Optional[str] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the shell is asking for tab completion, process
<span class="w"> </span>        that, then exit early. Called from :meth:`main` before the
<span class="w"> </span>        program is invoked.
<span class="gu">@@ -711,9 +1138,21 @@ class BaseCommand:</span>
<span class="w"> </span>        .. versionchanged:: 8.2.0
<span class="w"> </span>            Dots (``.``) in ``prog_name`` are replaced with underscores (``_``).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if complete_var is None:</span>
<span class="gi">+            complete_name = prog_name.replace(&quot;-&quot;, &quot;_&quot;).replace(&quot;.&quot;, &quot;_&quot;)</span>
<span class="gi">+            complete_var = f&quot;_{complete_name}_COMPLETE&quot;.upper()</span>
<span class="gi">+</span>
<span class="gi">+        instruction = os.environ.get(complete_var)</span>
<span class="gi">+</span>
<span class="gi">+        if not instruction:</span>
<span class="gi">+            return</span>

<span class="gd">-    def __call__(self, *args: t.Any, **kwargs: t.Any) -&gt;t.Any:</span>
<span class="gi">+        from .shell_completion import shell_complete</span>
<span class="gi">+</span>
<span class="gi">+        rv = shell_complete(self, ctx_args, prog_name, complete_var, instruction)</span>
<span class="gi">+        sys.exit(rv)</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(self, *args: t.Any, **kwargs: t.Any) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Alias for :meth:`main`.&quot;&quot;&quot;
<span class="w"> </span>        return self.main(*args, **kwargs)

<span class="gu">@@ -760,16 +1199,29 @@ class Command(BaseCommand):</span>
<span class="w"> </span>        Added the ``context_settings`` parameter.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, name: t.Optional[str], context_settings: t.Optional[</span>
<span class="gd">-        t.MutableMapping[str, t.Any]]=None, callback: t.Optional[t.Callable</span>
<span class="gd">-        [..., t.Any]]=None, params: t.Optional[t.List[&#39;Parameter&#39;]]=None,</span>
<span class="gd">-        help: t.Optional[str]=None, epilog: t.Optional[str]=None,</span>
<span class="gd">-        short_help: t.Optional[str]=None, options_metavar: t.Optional[str]=</span>
<span class="gd">-        &#39;[OPTIONS]&#39;, add_help_option: bool=True, no_args_is_help: bool=</span>
<span class="gd">-        False, hidden: bool=False, deprecated: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: t.Optional[str],</span>
<span class="gi">+        context_settings: t.Optional[t.MutableMapping[str, t.Any]] = None,</span>
<span class="gi">+        callback: t.Optional[t.Callable[..., t.Any]] = None,</span>
<span class="gi">+        params: t.Optional[t.List[&quot;Parameter&quot;]] = None,</span>
<span class="gi">+        help: t.Optional[str] = None,</span>
<span class="gi">+        epilog: t.Optional[str] = None,</span>
<span class="gi">+        short_help: t.Optional[str] = None,</span>
<span class="gi">+        options_metavar: t.Optional[str] = &quot;[OPTIONS]&quot;,</span>
<span class="gi">+        add_help_option: bool = True,</span>
<span class="gi">+        no_args_is_help: bool = False,</span>
<span class="gi">+        hidden: bool = False,</span>
<span class="gi">+        deprecated: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(name, context_settings)
<span class="gi">+        #: the callback to execute when the command fires.  This might be</span>
<span class="gi">+        #: `None` in which case nothing happens.</span>
<span class="w"> </span>        self.callback = callback
<span class="gd">-        self.params: t.List[&#39;Parameter&#39;] = params or []</span>
<span class="gi">+        #: the list of parameters for this command in the order they</span>
<span class="gi">+        #: should show up in the help page and execute.  Eager parameters</span>
<span class="gi">+        #: will automatically be handled before non eager ones.</span>
<span class="gi">+        self.params: t.List[&quot;Parameter&quot;] = params or []</span>
<span class="w"> </span>        self.help = help
<span class="w"> </span>        self.epilog = epilog
<span class="w"> </span>        self.options_metavar = options_metavar
<span class="gu">@@ -779,52 +1231,117 @@ class Command(BaseCommand):</span>
<span class="w"> </span>        self.hidden = hidden
<span class="w"> </span>        self.deprecated = deprecated

<span class="gd">-    def get_usage(self, ctx: Context) -&gt;str:</span>
<span class="gi">+    def to_info_dict(self, ctx: Context) -&gt; t.Dict[str, t.Any]:</span>
<span class="gi">+        info_dict = super().to_info_dict(ctx)</span>
<span class="gi">+        info_dict.update(</span>
<span class="gi">+            params=[param.to_info_dict() for param in self.get_params(ctx)],</span>
<span class="gi">+            help=self.help,</span>
<span class="gi">+            epilog=self.epilog,</span>
<span class="gi">+            short_help=self.short_help,</span>
<span class="gi">+            hidden=self.hidden,</span>
<span class="gi">+            deprecated=self.deprecated,</span>
<span class="gi">+        )</span>
<span class="gi">+        return info_dict</span>
<span class="gi">+</span>
<span class="gi">+    def get_usage(self, ctx: Context) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Formats the usage line into a string and returns it.

<span class="w"> </span>        Calls :meth:`format_usage` internally.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        formatter = ctx.make_formatter()</span>
<span class="gi">+        self.format_usage(ctx, formatter)</span>
<span class="gi">+        return formatter.getvalue().rstrip(&quot;\n&quot;)</span>

<span class="gd">-    def format_usage(self, ctx: Context, formatter: HelpFormatter) -&gt;None:</span>
<span class="gi">+    def get_params(self, ctx: Context) -&gt; t.List[&quot;Parameter&quot;]:</span>
<span class="gi">+        rv = self.params</span>
<span class="gi">+        help_option = self.get_help_option(ctx)</span>
<span class="gi">+</span>
<span class="gi">+        if help_option is not None:</span>
<span class="gi">+            rv = [*rv, help_option]</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def format_usage(self, ctx: Context, formatter: HelpFormatter) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Writes the usage line into the formatter.

<span class="w"> </span>        This is a low-level method called by :meth:`get_usage`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pieces = self.collect_usage_pieces(ctx)</span>
<span class="gi">+        formatter.write_usage(ctx.command_path, &quot; &quot;.join(pieces))</span>

<span class="gd">-    def collect_usage_pieces(self, ctx: Context) -&gt;t.List[str]:</span>
<span class="gi">+    def collect_usage_pieces(self, ctx: Context) -&gt; t.List[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns all the pieces that go into the usage line and returns
<span class="w"> </span>        it as a list of strings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = [self.options_metavar] if self.options_metavar else []</span>

<span class="gd">-    def get_help_option_names(self, ctx: Context) -&gt;t.List[str]:</span>
<span class="gi">+        for param in self.get_params(ctx):</span>
<span class="gi">+            rv.extend(param.get_usage_pieces(ctx))</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def get_help_option_names(self, ctx: Context) -&gt; t.List[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the names for the help option.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        all_names = set(ctx.help_option_names)</span>
<span class="gi">+        for param in self.params:</span>
<span class="gi">+            all_names.difference_update(param.opts)</span>
<span class="gi">+            all_names.difference_update(param.secondary_opts)</span>
<span class="gi">+        return list(all_names)</span>

<span class="gd">-    def get_help_option(self, ctx: Context) -&gt;t.Optional[&#39;Option&#39;]:</span>
<span class="gi">+    def get_help_option(self, ctx: Context) -&gt; t.Optional[&quot;Option&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the help option object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def make_parser(self, ctx: Context) -&gt;OptionParser:</span>
<span class="gi">+        help_options = self.get_help_option_names(ctx)</span>
<span class="gi">+</span>
<span class="gi">+        if not help_options or not self.add_help_option:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        def show_help(ctx: Context, param: &quot;Parameter&quot;, value: str) -&gt; None:</span>
<span class="gi">+            if value and not ctx.resilient_parsing:</span>
<span class="gi">+                echo(ctx.get_help(), color=ctx.color)</span>
<span class="gi">+                ctx.exit()</span>
<span class="gi">+</span>
<span class="gi">+        return Option(</span>
<span class="gi">+            help_options,</span>
<span class="gi">+            is_flag=True,</span>
<span class="gi">+            is_eager=True,</span>
<span class="gi">+            expose_value=False,</span>
<span class="gi">+            callback=show_help,</span>
<span class="gi">+            help=_(&quot;Show this message and exit.&quot;),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def make_parser(self, ctx: Context) -&gt; OptionParser:</span>
<span class="w"> </span>        &quot;&quot;&quot;Creates the underlying option parser for this command.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parser = OptionParser(ctx)</span>
<span class="gi">+        for param in self.get_params(ctx):</span>
<span class="gi">+            param.add_to_parser(parser, ctx)</span>
<span class="gi">+        return parser</span>

<span class="gd">-    def get_help(self, ctx: Context) -&gt;str:</span>
<span class="gi">+    def get_help(self, ctx: Context) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Formats the help into a string and returns it.

<span class="w"> </span>        Calls :meth:`format_help` internally.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        formatter = ctx.make_formatter()</span>
<span class="gi">+        self.format_help(ctx, formatter)</span>
<span class="gi">+        return formatter.getvalue().rstrip(&quot;\n&quot;)</span>

<span class="gd">-    def get_short_help_str(self, limit: int=45) -&gt;str:</span>
<span class="gi">+    def get_short_help_str(self, limit: int = 45) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Gets short help for the command or makes it by shortening the
<span class="w"> </span>        long help string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.short_help:</span>
<span class="gi">+            text = inspect.cleandoc(self.short_help)</span>
<span class="gi">+        elif self.help:</span>
<span class="gi">+            text = make_default_short_help(self.help, limit)</span>
<span class="gi">+        else:</span>
<span class="gi">+            text = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if self.deprecated:</span>
<span class="gi">+            text = _(&quot;(Deprecated) {text}&quot;).format(text=text)</span>
<span class="gi">+</span>
<span class="gi">+        return text.strip()</span>

<span class="gd">-    def format_help(self, ctx: Context, formatter: HelpFormatter) -&gt;None:</span>
<span class="gi">+    def format_help(self, ctx: Context, formatter: HelpFormatter) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Writes the help into the formatter if it exists.

<span class="w"> </span>        This is a low-level method called by :meth:`get_help`.
<span class="gu">@@ -836,28 +1353,87 @@ class Command(BaseCommand):</span>
<span class="w"> </span>        -   :meth:`format_options`
<span class="w"> </span>        -   :meth:`format_epilog`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.format_usage(ctx, formatter)</span>
<span class="gi">+        self.format_help_text(ctx, formatter)</span>
<span class="gi">+        self.format_options(ctx, formatter)</span>
<span class="gi">+        self.format_epilog(ctx, formatter)</span>

<span class="gd">-    def format_help_text(self, ctx: Context, formatter: HelpFormatter) -&gt;None:</span>
<span class="gi">+    def format_help_text(self, ctx: Context, formatter: HelpFormatter) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Writes the help text to the formatter if it exists.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.help is not None:</span>
<span class="gi">+            # truncate the help text to the first form feed</span>
<span class="gi">+            text = inspect.cleandoc(self.help).partition(&quot;\f&quot;)[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            text = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if self.deprecated:</span>
<span class="gi">+            text = _(&quot;(Deprecated) {text}&quot;).format(text=text)</span>
<span class="gi">+</span>
<span class="gi">+        if text:</span>
<span class="gi">+            formatter.write_paragraph()</span>
<span class="gi">+</span>
<span class="gi">+            with formatter.indentation():</span>
<span class="gi">+                formatter.write_text(text)</span>

<span class="gd">-    def format_options(self, ctx: Context, formatter: HelpFormatter) -&gt;None:</span>
<span class="gi">+    def format_options(self, ctx: Context, formatter: HelpFormatter) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Writes all the options into the formatter if they exist.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        opts = []</span>
<span class="gi">+        for param in self.get_params(ctx):</span>
<span class="gi">+            rv = param.get_help_record(ctx)</span>
<span class="gi">+            if rv is not None:</span>
<span class="gi">+                opts.append(rv)</span>

<span class="gd">-    def format_epilog(self, ctx: Context, formatter: HelpFormatter) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Writes the epilog into the formatter if it exists.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        if opts:</span>
<span class="gi">+            with formatter.section(_(&quot;Options&quot;)):</span>
<span class="gi">+                formatter.write_dl(opts)</span>

<span class="gd">-    def invoke(self, ctx: Context) -&gt;t.Any:</span>
<span class="gi">+    def format_epilog(self, ctx: Context, formatter: HelpFormatter) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Writes the epilog into the formatter if it exists.&quot;&quot;&quot;</span>
<span class="gi">+        if self.epilog:</span>
<span class="gi">+            epilog = inspect.cleandoc(self.epilog)</span>
<span class="gi">+            formatter.write_paragraph()</span>
<span class="gi">+</span>
<span class="gi">+            with formatter.indentation():</span>
<span class="gi">+                formatter.write_text(epilog)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_args(self, ctx: Context, args: t.List[str]) -&gt; t.List[str]:</span>
<span class="gi">+        if not args and self.no_args_is_help and not ctx.resilient_parsing:</span>
<span class="gi">+            echo(ctx.get_help(), color=ctx.color)</span>
<span class="gi">+            ctx.exit()</span>
<span class="gi">+</span>
<span class="gi">+        parser = self.make_parser(ctx)</span>
<span class="gi">+        opts, args, param_order = parser.parse_args(args=args)</span>
<span class="gi">+</span>
<span class="gi">+        for param in iter_params_for_processing(param_order, self.get_params(ctx)):</span>
<span class="gi">+            value, args = param.handle_parse_result(ctx, opts, args)</span>
<span class="gi">+</span>
<span class="gi">+        if args and not ctx.allow_extra_args and not ctx.resilient_parsing:</span>
<span class="gi">+            ctx.fail(</span>
<span class="gi">+                ngettext(</span>
<span class="gi">+                    &quot;Got unexpected extra argument ({args})&quot;,</span>
<span class="gi">+                    &quot;Got unexpected extra arguments ({args})&quot;,</span>
<span class="gi">+                    len(args),</span>
<span class="gi">+                ).format(args=&quot; &quot;.join(map(str, args)))</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        ctx.args = args</span>
<span class="gi">+        ctx._opt_prefixes.update(parser._opt_prefixes)</span>
<span class="gi">+        return args</span>
<span class="gi">+</span>
<span class="gi">+    def invoke(self, ctx: Context) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given a context, this invokes the attached callback (if it exists)
<span class="w"> </span>        in the right way.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.deprecated:</span>
<span class="gi">+            message = _(</span>
<span class="gi">+                &quot;DeprecationWarning: The command {name!r} is deprecated.&quot;</span>
<span class="gi">+            ).format(name=self.name)</span>
<span class="gi">+            echo(style(message, fg=&quot;red&quot;), err=True)</span>

<span class="gd">-    def shell_complete(self, ctx: Context, incomplete: str) -&gt;t.List[</span>
<span class="gd">-        &#39;CompletionItem&#39;]:</span>
<span class="gi">+        if self.callback is not None:</span>
<span class="gi">+            return ctx.invoke(self.callback, **ctx.params)</span>
<span class="gi">+</span>
<span class="gi">+    def shell_complete(self, ctx: Context, incomplete: str) -&gt; t.List[&quot;CompletionItem&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of completions for the incomplete value. Looks
<span class="w"> </span>        at the names of options and chained multi-commands.

<span class="gu">@@ -866,7 +1442,31 @@ class Command(BaseCommand):</span>

<span class="w"> </span>        .. versionadded:: 8.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from click.shell_completion import CompletionItem</span>
<span class="gi">+</span>
<span class="gi">+        results: t.List[&quot;CompletionItem&quot;] = []</span>
<span class="gi">+</span>
<span class="gi">+        if incomplete and not incomplete[0].isalnum():</span>
<span class="gi">+            for param in self.get_params(ctx):</span>
<span class="gi">+                if (</span>
<span class="gi">+                    not isinstance(param, Option)</span>
<span class="gi">+                    or param.hidden</span>
<span class="gi">+                    or (</span>
<span class="gi">+                        not param.multiple</span>
<span class="gi">+                        and ctx.get_parameter_source(param.name)  # type: ignore</span>
<span class="gi">+                        is ParameterSource.COMMANDLINE</span>
<span class="gi">+                    )</span>
<span class="gi">+                ):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                results.extend(</span>
<span class="gi">+                    CompletionItem(name, help=param.help)</span>
<span class="gi">+                    for name in [*param.opts, *param.secondary_opts]</span>
<span class="gi">+                    if name.startswith(incomplete)</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        results.extend(super().shell_complete(ctx, incomplete))</span>
<span class="gi">+        return results</span>


<span class="w"> </span>class MultiCommand(Command):
<span class="gu">@@ -894,36 +1494,76 @@ class MultiCommand(Command):</span>
<span class="w"> </span>        :meth:`result_callback` decorator.
<span class="w"> </span>    :param attrs: Other command arguments described in :class:`Command`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    allow_extra_args = True
<span class="w"> </span>    allow_interspersed_args = False

<span class="gd">-    def __init__(self, name: t.Optional[str]=None, invoke_without_command:</span>
<span class="gd">-        bool=False, no_args_is_help: t.Optional[bool]=None,</span>
<span class="gd">-        subcommand_metavar: t.Optional[str]=None, chain: bool=False,</span>
<span class="gd">-        result_callback: t.Optional[t.Callable[..., t.Any]]=None, **attrs:</span>
<span class="gd">-        t.Any) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: t.Optional[str] = None,</span>
<span class="gi">+        invoke_without_command: bool = False,</span>
<span class="gi">+        no_args_is_help: t.Optional[bool] = None,</span>
<span class="gi">+        subcommand_metavar: t.Optional[str] = None,</span>
<span class="gi">+        chain: bool = False,</span>
<span class="gi">+        result_callback: t.Optional[t.Callable[..., t.Any]] = None,</span>
<span class="gi">+        **attrs: t.Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(name, **attrs)
<span class="gi">+</span>
<span class="w"> </span>        if no_args_is_help is None:
<span class="w"> </span>            no_args_is_help = not invoke_without_command
<span class="gi">+</span>
<span class="w"> </span>        self.no_args_is_help = no_args_is_help
<span class="w"> </span>        self.invoke_without_command = invoke_without_command
<span class="gi">+</span>
<span class="w"> </span>        if subcommand_metavar is None:
<span class="w"> </span>            if chain:
<span class="gd">-                subcommand_metavar = (</span>
<span class="gd">-                    &#39;COMMAND1 [ARGS]... [COMMAND2 [ARGS]...]...&#39;)</span>
<span class="gi">+                subcommand_metavar = &quot;COMMAND1 [ARGS]... [COMMAND2 [ARGS]...]...&quot;</span>
<span class="w"> </span>            else:
<span class="gd">-                subcommand_metavar = &#39;COMMAND [ARGS]...&#39;</span>
<span class="gi">+                subcommand_metavar = &quot;COMMAND [ARGS]...&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        self.subcommand_metavar = subcommand_metavar
<span class="w"> </span>        self.chain = chain
<span class="gi">+        # The result callback that is stored. This can be set or</span>
<span class="gi">+        # overridden with the :func:`result_callback` decorator.</span>
<span class="w"> </span>        self._result_callback = result_callback
<span class="gi">+</span>
<span class="w"> </span>        if self.chain:
<span class="w"> </span>            for param in self.params:
<span class="w"> </span>                if isinstance(param, Argument) and not param.required:
<span class="w"> </span>                    raise RuntimeError(
<span class="gd">-                        &#39;Multi commands in chain mode cannot have optional arguments.&#39;</span>
<span class="gd">-                        )</span>
<span class="gi">+                        &quot;Multi commands in chain mode cannot have&quot;</span>
<span class="gi">+                        &quot; optional arguments.&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+    def to_info_dict(self, ctx: Context) -&gt; t.Dict[str, t.Any]:</span>
<span class="gi">+        info_dict = super().to_info_dict(ctx)</span>
<span class="gi">+        commands = {}</span>
<span class="gi">+</span>
<span class="gi">+        for name in self.list_commands(ctx):</span>
<span class="gi">+            command = self.get_command(ctx, name)</span>
<span class="gi">+</span>
<span class="gi">+            if command is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            sub_ctx = ctx._make_sub_context(command)</span>

<span class="gd">-    def result_callback(self, replace: bool=False) -&gt;t.Callable[[F], F]:</span>
<span class="gi">+            with sub_ctx.scope(cleanup=False):</span>
<span class="gi">+                commands[name] = command.to_info_dict(sub_ctx)</span>
<span class="gi">+</span>
<span class="gi">+        info_dict.update(commands=commands, chain=self.chain)</span>
<span class="gi">+        return info_dict</span>
<span class="gi">+</span>
<span class="gi">+    def collect_usage_pieces(self, ctx: Context) -&gt; t.List[str]:</span>
<span class="gi">+        rv = super().collect_usage_pieces(ctx)</span>
<span class="gi">+        rv.append(self.subcommand_metavar)</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def format_options(self, ctx: Context, formatter: HelpFormatter) -&gt; None:</span>
<span class="gi">+        super().format_options(ctx, formatter)</span>
<span class="gi">+        self.format_commands(ctx, formatter)</span>
<span class="gi">+</span>
<span class="gi">+    def result_callback(self, replace: bool = False) -&gt; t.Callable[[F], F]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds a result callback to the command.  By default if a
<span class="w"> </span>        result callback is already registered this will chain them but
<span class="w"> </span>        this can be disabled with the `replace` parameter.  The result
<span class="gu">@@ -951,28 +1591,174 @@ class MultiCommand(Command):</span>

<span class="w"> </span>        .. versionadded:: 3.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def format_commands(self, ctx: Context, formatter: HelpFormatter) -&gt;None:</span>
<span class="gi">+        def decorator(f: F) -&gt; F:</span>
<span class="gi">+            old_callback = self._result_callback</span>
<span class="gi">+</span>
<span class="gi">+            if old_callback is None or replace:</span>
<span class="gi">+                self._result_callback = f</span>
<span class="gi">+                return f</span>
<span class="gi">+</span>
<span class="gi">+            def function(__value, *args, **kwargs):  # type: ignore</span>
<span class="gi">+                inner = old_callback(__value, *args, **kwargs)</span>
<span class="gi">+                return f(inner, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            self._result_callback = rv = update_wrapper(t.cast(F, function), f)</span>
<span class="gi">+            return rv</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>
<span class="gi">+</span>
<span class="gi">+    def format_commands(self, ctx: Context, formatter: HelpFormatter) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Extra format methods for multi methods that adds all the commands
<span class="w"> </span>        after the options.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        commands = []</span>
<span class="gi">+        for subcommand in self.list_commands(ctx):</span>
<span class="gi">+            cmd = self.get_command(ctx, subcommand)</span>
<span class="gi">+            # What is this, the tool lied about a command.  Ignore it</span>
<span class="gi">+            if cmd is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if cmd.hidden:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            commands.append((subcommand, cmd))</span>
<span class="gi">+</span>
<span class="gi">+        # allow for 3 times the default spacing</span>
<span class="gi">+        if len(commands):</span>
<span class="gi">+            limit = formatter.width - 6 - max(len(cmd[0]) for cmd in commands)</span>
<span class="gi">+</span>
<span class="gi">+            rows = []</span>
<span class="gi">+            for subcommand, cmd in commands:</span>
<span class="gi">+                help = cmd.get_short_help_str(limit)</span>
<span class="gi">+                rows.append((subcommand, help))</span>
<span class="gi">+</span>
<span class="gi">+            if rows:</span>
<span class="gi">+                with formatter.section(_(&quot;Commands&quot;)):</span>
<span class="gi">+                    formatter.write_dl(rows)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_args(self, ctx: Context, args: t.List[str]) -&gt; t.List[str]:</span>
<span class="gi">+        if not args and self.no_args_is_help and not ctx.resilient_parsing:</span>
<span class="gi">+            echo(ctx.get_help(), color=ctx.color)</span>
<span class="gi">+            ctx.exit()</span>

<span class="gd">-    def get_command(self, ctx: Context, cmd_name: str) -&gt;t.Optional[Command]:</span>
<span class="gi">+        rest = super().parse_args(ctx, args)</span>
<span class="gi">+</span>
<span class="gi">+        if self.chain:</span>
<span class="gi">+            ctx.protected_args = rest</span>
<span class="gi">+            ctx.args = []</span>
<span class="gi">+        elif rest:</span>
<span class="gi">+            ctx.protected_args, ctx.args = rest[:1], rest[1:]</span>
<span class="gi">+</span>
<span class="gi">+        return ctx.args</span>
<span class="gi">+</span>
<span class="gi">+    def invoke(self, ctx: Context) -&gt; t.Any:</span>
<span class="gi">+        def _process_result(value: t.Any) -&gt; t.Any:</span>
<span class="gi">+            if self._result_callback is not None:</span>
<span class="gi">+                value = ctx.invoke(self._result_callback, value, **ctx.params)</span>
<span class="gi">+            return value</span>
<span class="gi">+</span>
<span class="gi">+        if not ctx.protected_args:</span>
<span class="gi">+            if self.invoke_without_command:</span>
<span class="gi">+                # No subcommand was invoked, so the result callback is</span>
<span class="gi">+                # invoked with the group return value for regular</span>
<span class="gi">+                # groups, or an empty list for chained groups.</span>
<span class="gi">+                with ctx:</span>
<span class="gi">+                    rv = super().invoke(ctx)</span>
<span class="gi">+                    return _process_result([] if self.chain else rv)</span>
<span class="gi">+            ctx.fail(_(&quot;Missing command.&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        # Fetch args back out</span>
<span class="gi">+        args = [*ctx.protected_args, *ctx.args]</span>
<span class="gi">+        ctx.args = []</span>
<span class="gi">+        ctx.protected_args = []</span>
<span class="gi">+</span>
<span class="gi">+        # If we&#39;re not in chain mode, we only allow the invocation of a</span>
<span class="gi">+        # single command but we also inform the current context about the</span>
<span class="gi">+        # name of the command to invoke.</span>
<span class="gi">+        if not self.chain:</span>
<span class="gi">+            # Make sure the context is entered so we do not clean up</span>
<span class="gi">+            # resources until the result processor has worked.</span>
<span class="gi">+            with ctx:</span>
<span class="gi">+                cmd_name, cmd, args = self.resolve_command(ctx, args)</span>
<span class="gi">+                assert cmd is not None</span>
<span class="gi">+                ctx.invoked_subcommand = cmd_name</span>
<span class="gi">+                super().invoke(ctx)</span>
<span class="gi">+                sub_ctx = cmd.make_context(cmd_name, args, parent=ctx)</span>
<span class="gi">+                with sub_ctx:</span>
<span class="gi">+                    return _process_result(sub_ctx.command.invoke(sub_ctx))</span>
<span class="gi">+</span>
<span class="gi">+        # In chain mode we create the contexts step by step, but after the</span>
<span class="gi">+        # base command has been invoked.  Because at that point we do not</span>
<span class="gi">+        # know the subcommands yet, the invoked subcommand attribute is</span>
<span class="gi">+        # set to ``*`` to inform the command that subcommands are executed</span>
<span class="gi">+        # but nothing else.</span>
<span class="gi">+        with ctx:</span>
<span class="gi">+            ctx.invoked_subcommand = &quot;*&quot; if args else None</span>
<span class="gi">+            super().invoke(ctx)</span>
<span class="gi">+</span>
<span class="gi">+            # Otherwise we make every single context and invoke them in a</span>
<span class="gi">+            # chain.  In that case the return value to the result processor</span>
<span class="gi">+            # is the list of all invoked subcommand&#39;s results.</span>
<span class="gi">+            contexts = []</span>
<span class="gi">+            while args:</span>
<span class="gi">+                cmd_name, cmd, args = self.resolve_command(ctx, args)</span>
<span class="gi">+                assert cmd is not None</span>
<span class="gi">+                sub_ctx = cmd.make_context(</span>
<span class="gi">+                    cmd_name,</span>
<span class="gi">+                    args,</span>
<span class="gi">+                    parent=ctx,</span>
<span class="gi">+                    allow_extra_args=True,</span>
<span class="gi">+                    allow_interspersed_args=False,</span>
<span class="gi">+                )</span>
<span class="gi">+                contexts.append(sub_ctx)</span>
<span class="gi">+                args, sub_ctx.args = sub_ctx.args, []</span>
<span class="gi">+</span>
<span class="gi">+            rv = []</span>
<span class="gi">+            for sub_ctx in contexts:</span>
<span class="gi">+                with sub_ctx:</span>
<span class="gi">+                    rv.append(sub_ctx.command.invoke(sub_ctx))</span>
<span class="gi">+            return _process_result(rv)</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_command(</span>
<span class="gi">+        self, ctx: Context, args: t.List[str]</span>
<span class="gi">+    ) -&gt; t.Tuple[t.Optional[str], t.Optional[Command], t.List[str]]:</span>
<span class="gi">+        cmd_name = make_str(args[0])</span>
<span class="gi">+        original_cmd_name = cmd_name</span>
<span class="gi">+</span>
<span class="gi">+        # Get the command</span>
<span class="gi">+        cmd = self.get_command(ctx, cmd_name)</span>
<span class="gi">+</span>
<span class="gi">+        # If we can&#39;t find the command but there is a normalization</span>
<span class="gi">+        # function available, we try with that one.</span>
<span class="gi">+        if cmd is None and ctx.token_normalize_func is not None:</span>
<span class="gi">+            cmd_name = ctx.token_normalize_func(cmd_name)</span>
<span class="gi">+            cmd = self.get_command(ctx, cmd_name)</span>
<span class="gi">+</span>
<span class="gi">+        # If we don&#39;t find the command we want to show an error message</span>
<span class="gi">+        # to the user that it was not provided.  However, there is</span>
<span class="gi">+        # something else we should do: if the first argument looks like</span>
<span class="gi">+        # an option we want to kick off parsing again for arguments to</span>
<span class="gi">+        # resolve things like --help which now should go to the main</span>
<span class="gi">+        # place.</span>
<span class="gi">+        if cmd is None and not ctx.resilient_parsing:</span>
<span class="gi">+            if split_opt(cmd_name)[0]:</span>
<span class="gi">+                self.parse_args(ctx, ctx.args)</span>
<span class="gi">+            ctx.fail(_(&quot;No such command {name!r}.&quot;).format(name=original_cmd_name))</span>
<span class="gi">+        return cmd_name if cmd else None, cmd, args[1:]</span>
<span class="gi">+</span>
<span class="gi">+    def get_command(self, ctx: Context, cmd_name: str) -&gt; t.Optional[Command]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given a context and a command name, this returns a
<span class="w"> </span>        :class:`Command` object if it exists or returns `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def list_commands(self, ctx: Context) -&gt;t.List[str]:</span>
<span class="gi">+    def list_commands(self, ctx: Context) -&gt; t.List[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a list of subcommand names in the order they should
<span class="w"> </span>        appear.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>

<span class="gd">-    def shell_complete(self, ctx: Context, incomplete: str) -&gt;t.List[</span>
<span class="gd">-        &#39;CompletionItem&#39;]:</span>
<span class="gi">+    def shell_complete(self, ctx: Context, incomplete: str) -&gt; t.List[&quot;CompletionItem&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of completions for the incomplete value. Looks
<span class="w"> </span>        at the names of options, subcommands, and chained
<span class="w"> </span>        multi-commands.
<span class="gu">@@ -982,7 +1768,14 @@ class MultiCommand(Command):</span>

<span class="w"> </span>        .. versionadded:: 8.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from click.shell_completion import CompletionItem</span>
<span class="gi">+</span>
<span class="gi">+        results = [</span>
<span class="gi">+            CompletionItem(name, help=command.get_short_help_str())</span>
<span class="gi">+            for name, command in _complete_visible_commands(ctx, incomplete)</span>
<span class="gi">+        ]</span>
<span class="gi">+        results.extend(super().shell_complete(ctx, incomplete))</span>
<span class="gi">+        return results</span>


<span class="w"> </span>class Group(MultiCommand):
<span class="gu">@@ -1000,27 +1793,68 @@ class Group(MultiCommand):</span>
<span class="w"> </span>    .. versionchanged:: 8.0
<span class="w"> </span>        The ``commands`` argument can be a list of command objects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    #: If set, this is used by the group&#39;s :meth:`command` decorator</span>
<span class="gi">+    #: as the default :class:`Command` class. This is useful to make all</span>
<span class="gi">+    #: subcommands use a custom command class.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 8.0</span>
<span class="w"> </span>    command_class: t.Optional[t.Type[Command]] = None
<span class="gd">-    group_class: t.Optional[t.Union[t.Type[&#39;Group&#39;], t.Type[type]]] = None</span>

<span class="gd">-    def __init__(self, name: t.Optional[str]=None, commands: t.Optional[t.</span>
<span class="gd">-        Union[t.MutableMapping[str, Command], t.Sequence[Command]]]=None,</span>
<span class="gd">-        **attrs: t.Any) -&gt;None:</span>
<span class="gi">+    #: If set, this is used by the group&#39;s :meth:`group` decorator</span>
<span class="gi">+    #: as the default :class:`Group` class. This is useful to make all</span>
<span class="gi">+    #: subgroups use a custom group class.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: If set to the special value :class:`type` (literally</span>
<span class="gi">+    #: ``group_class = type``), this group&#39;s class will be used as the</span>
<span class="gi">+    #: default class. This makes a custom group class continue to make</span>
<span class="gi">+    #: custom groups.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 8.0</span>
<span class="gi">+    group_class: t.Optional[t.Union[t.Type[&quot;Group&quot;], t.Type[type]]] = None</span>
<span class="gi">+    # Literal[type] isn&#39;t valid, so use Type[type]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: t.Optional[str] = None,</span>
<span class="gi">+        commands: t.Optional[</span>
<span class="gi">+            t.Union[t.MutableMapping[str, Command], t.Sequence[Command]]</span>
<span class="gi">+        ] = None,</span>
<span class="gi">+        **attrs: t.Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(name, **attrs)
<span class="gi">+</span>
<span class="w"> </span>        if commands is None:
<span class="w"> </span>            commands = {}
<span class="w"> </span>        elif isinstance(commands, abc.Sequence):
<span class="w"> </span>            commands = {c.name: c for c in commands if c.name is not None}
<span class="gi">+</span>
<span class="gi">+        #: The registered subcommands by their exported names.</span>
<span class="w"> </span>        self.commands: t.MutableMapping[str, Command] = commands

<span class="gd">-    def add_command(self, cmd: Command, name: t.Optional[str]=None) -&gt;None:</span>
<span class="gi">+    def add_command(self, cmd: Command, name: t.Optional[str] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Registers another :class:`Command` with this group.  If the name
<span class="w"> </span>        is not provided, the name of the command is used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def command(self, *args: t.Any, **kwargs: t.Any) -&gt;t.Union[t.Callable[[</span>
<span class="gd">-        t.Callable[..., t.Any]], Command], Command]:</span>
<span class="gi">+        name = name or cmd.name</span>
<span class="gi">+        if name is None:</span>
<span class="gi">+            raise TypeError(&quot;Command has no name.&quot;)</span>
<span class="gi">+        _check_multicommand(self, name, cmd, register=True)</span>
<span class="gi">+        self.commands[name] = cmd</span>
<span class="gi">+</span>
<span class="gi">+    @t.overload</span>
<span class="gi">+    def command(self, __func: t.Callable[..., t.Any]) -&gt; Command:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @t.overload</span>
<span class="gi">+    def command(</span>
<span class="gi">+        self, *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+    ) -&gt; t.Callable[[t.Callable[..., t.Any]], Command]:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    def command(</span>
<span class="gi">+        self, *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+    ) -&gt; t.Union[t.Callable[[t.Callable[..., t.Any]], Command], Command]:</span>
<span class="w"> </span>        &quot;&quot;&quot;A shortcut decorator for declaring and attaching a command to
<span class="w"> </span>        the group. This takes the same arguments as :func:`command` and
<span class="w"> </span>        immediately registers the created command with this group by
<span class="gu">@@ -1035,10 +1869,43 @@ class Group(MultiCommand):</span>
<span class="w"> </span>        .. versionchanged:: 8.0
<span class="w"> </span>            Added the :attr:`command_class` attribute.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .decorators import command</span>
<span class="gi">+</span>
<span class="gi">+        func: t.Optional[t.Callable[..., t.Any]] = None</span>
<span class="gi">+</span>
<span class="gi">+        if args and callable(args[0]):</span>
<span class="gi">+            assert (</span>
<span class="gi">+                len(args) == 1 and not kwargs</span>
<span class="gi">+            ), &quot;Use &#39;command(**kwargs)(callable)&#39; to provide arguments.&quot;</span>
<span class="gi">+            (func,) = args</span>
<span class="gi">+            args = ()</span>
<span class="gi">+</span>
<span class="gi">+        if self.command_class and kwargs.get(&quot;cls&quot;) is None:</span>
<span class="gi">+            kwargs[&quot;cls&quot;] = self.command_class</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(f: t.Callable[..., t.Any]) -&gt; Command:</span>
<span class="gi">+            cmd: Command = command(*args, **kwargs)(f)</span>
<span class="gi">+            self.add_command(cmd)</span>
<span class="gi">+            return cmd</span>
<span class="gi">+</span>
<span class="gi">+        if func is not None:</span>
<span class="gi">+            return decorator(func)</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>
<span class="gi">+</span>
<span class="gi">+    @t.overload</span>
<span class="gi">+    def group(self, __func: t.Callable[..., t.Any]) -&gt; &quot;Group&quot;:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @t.overload</span>
<span class="gi">+    def group(</span>
<span class="gi">+        self, *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+    ) -&gt; t.Callable[[t.Callable[..., t.Any]], &quot;Group&quot;]:</span>
<span class="gi">+        ...</span>

<span class="gd">-    def group(self, *args: t.Any, **kwargs: t.Any) -&gt;t.Union[t.Callable[[t.</span>
<span class="gd">-        Callable[..., t.Any]], &#39;Group&#39;], &#39;Group&#39;]:</span>
<span class="gi">+    def group(</span>
<span class="gi">+        self, *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+    ) -&gt; t.Union[t.Callable[[t.Callable[..., t.Any]], &quot;Group&quot;], &quot;Group&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;A shortcut decorator for declaring and attaching a group to
<span class="w"> </span>        the group. This takes the same arguments as :func:`group` and
<span class="w"> </span>        immediately registers the created group with this group by
<span class="gu">@@ -1053,7 +1920,38 @@ class Group(MultiCommand):</span>
<span class="w"> </span>        .. versionchanged:: 8.0
<span class="w"> </span>            Added the :attr:`group_class` attribute.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .decorators import group</span>
<span class="gi">+</span>
<span class="gi">+        func: t.Optional[t.Callable[..., t.Any]] = None</span>
<span class="gi">+</span>
<span class="gi">+        if args and callable(args[0]):</span>
<span class="gi">+            assert (</span>
<span class="gi">+                len(args) == 1 and not kwargs</span>
<span class="gi">+            ), &quot;Use &#39;group(**kwargs)(callable)&#39; to provide arguments.&quot;</span>
<span class="gi">+            (func,) = args</span>
<span class="gi">+            args = ()</span>
<span class="gi">+</span>
<span class="gi">+        if self.group_class is not None and kwargs.get(&quot;cls&quot;) is None:</span>
<span class="gi">+            if self.group_class is type:</span>
<span class="gi">+                kwargs[&quot;cls&quot;] = type(self)</span>
<span class="gi">+            else:</span>
<span class="gi">+                kwargs[&quot;cls&quot;] = self.group_class</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(f: t.Callable[..., t.Any]) -&gt; &quot;Group&quot;:</span>
<span class="gi">+            cmd: Group = group(*args, **kwargs)(f)</span>
<span class="gi">+            self.add_command(cmd)</span>
<span class="gi">+            return cmd</span>
<span class="gi">+</span>
<span class="gi">+        if func is not None:</span>
<span class="gi">+            return decorator(func)</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>
<span class="gi">+</span>
<span class="gi">+    def get_command(self, ctx: Context, cmd_name: str) -&gt; t.Optional[Command]:</span>
<span class="gi">+        return self.commands.get(cmd_name)</span>
<span class="gi">+</span>
<span class="gi">+    def list_commands(self, ctx: Context) -&gt; t.List[str]:</span>
<span class="gi">+        return sorted(self.commands)</span>


<span class="w"> </span>class CommandCollection(MultiCommand):
<span class="gu">@@ -1066,26 +1964,54 @@ class CommandCollection(MultiCommand):</span>
<span class="w"> </span>    ``name`` and ``attrs``.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, name: t.Optional[str]=None, sources: t.Optional[t.</span>
<span class="gd">-        List[MultiCommand]]=None, **attrs: t.Any) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: t.Optional[str] = None,</span>
<span class="gi">+        sources: t.Optional[t.List[MultiCommand]] = None,</span>
<span class="gi">+        **attrs: t.Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(name, **attrs)
<span class="gi">+        #: The list of registered multi commands.</span>
<span class="w"> </span>        self.sources: t.List[MultiCommand] = sources or []

<span class="gd">-    def add_source(self, multi_cmd: MultiCommand) -&gt;None:</span>
<span class="gi">+    def add_source(self, multi_cmd: MultiCommand) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds a new multi command to the chain dispatcher.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.sources.append(multi_cmd)</span>

<span class="gi">+    def get_command(self, ctx: Context, cmd_name: str) -&gt; t.Optional[Command]:</span>
<span class="gi">+        for source in self.sources:</span>
<span class="gi">+            rv = source.get_command(ctx, cmd_name)</span>

<span class="gd">-def _check_iter(value: t.Any) -&gt;t.Iterator[t.Any]:</span>
<span class="gi">+            if rv is not None:</span>
<span class="gi">+                if self.chain:</span>
<span class="gi">+                    _check_multicommand(self, cmd_name, rv)</span>
<span class="gi">+</span>
<span class="gi">+                return rv</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def list_commands(self, ctx: Context) -&gt; t.List[str]:</span>
<span class="gi">+        rv: t.Set[str] = set()</span>
<span class="gi">+</span>
<span class="gi">+        for source in self.sources:</span>
<span class="gi">+            rv.update(source.list_commands(ctx))</span>
<span class="gi">+</span>
<span class="gi">+        return sorted(rv)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_iter(value: t.Any) -&gt; t.Iterator[t.Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the value is iterable but not a string. Raises a type
<span class="w"> </span>    error, or return an iterator over the value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, str):</span>
<span class="gi">+        raise TypeError</span>
<span class="gi">+</span>
<span class="gi">+    return iter(value)</span>


<span class="w"> </span>class Parameter:
<span class="gd">-    &quot;&quot;&quot;A parameter to a command comes in two versions: they are either</span>
<span class="gd">-    :class:`Option`\\s or :class:`Argument`\\s.  Other subclasses are currently</span>
<span class="gi">+    r&quot;&quot;&quot;A parameter to a command comes in two versions: they are either</span>
<span class="gi">+    :class:`Option`\s or :class:`Argument`\s.  Other subclasses are currently</span>
<span class="w"> </span>    not supported by design as some of the internals for parsing are
<span class="w"> </span>    intentionally not finalized.

<span class="gu">@@ -1156,28 +2082,45 @@ class Parameter:</span>
<span class="w"> </span>        parameter. The old callback format will still work, but it will
<span class="w"> </span>        raise a warning to give you a chance to migrate the code easier.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    param_type_name = &#39;parameter&#39;</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, param_decls: t.Optional[t.Sequence[str]]=None, type:</span>
<span class="gd">-        t.Optional[t.Union[types.ParamType, t.Any]]=None, required: bool=</span>
<span class="gd">-        False, default: t.Optional[t.Union[t.Any, t.Callable[[], t.Any]]]=</span>
<span class="gd">-        None, callback: t.Optional[t.Callable[[Context, &#39;Parameter&#39;, t.Any],</span>
<span class="gd">-        t.Any]]=None, nargs: t.Optional[int]=None, multiple: bool=False,</span>
<span class="gd">-        metavar: t.Optional[str]=None, expose_value: bool=True, is_eager:</span>
<span class="gd">-        bool=False, envvar: t.Optional[t.Union[str, t.Sequence[str]]]=None,</span>
<span class="gd">-        shell_complete: t.Optional[t.Callable[[Context, &#39;Parameter&#39;, str],</span>
<span class="gd">-        t.Union[t.List[&#39;CompletionItem&#39;], t.List[str]]]]=None) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    param_type_name = &quot;parameter&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        param_decls: t.Optional[t.Sequence[str]] = None,</span>
<span class="gi">+        type: t.Optional[t.Union[types.ParamType, t.Any]] = None,</span>
<span class="gi">+        required: bool = False,</span>
<span class="gi">+        default: t.Optional[t.Union[t.Any, t.Callable[[], t.Any]]] = None,</span>
<span class="gi">+        callback: t.Optional[t.Callable[[Context, &quot;Parameter&quot;, t.Any], t.Any]] = None,</span>
<span class="gi">+        nargs: t.Optional[int] = None,</span>
<span class="gi">+        multiple: bool = False,</span>
<span class="gi">+        metavar: t.Optional[str] = None,</span>
<span class="gi">+        expose_value: bool = True,</span>
<span class="gi">+        is_eager: bool = False,</span>
<span class="gi">+        envvar: t.Optional[t.Union[str, t.Sequence[str]]] = None,</span>
<span class="gi">+        shell_complete: t.Optional[</span>
<span class="gi">+            t.Callable[</span>
<span class="gi">+                [Context, &quot;Parameter&quot;, str],</span>
<span class="gi">+                t.Union[t.List[&quot;CompletionItem&quot;], t.List[str]],</span>
<span class="gi">+            ]</span>
<span class="gi">+        ] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.name: t.Optional[str]
<span class="w"> </span>        self.opts: t.List[str]
<span class="w"> </span>        self.secondary_opts: t.List[str]
<span class="w"> </span>        self.name, self.opts, self.secondary_opts = self._parse_decls(
<span class="gd">-            param_decls or (), expose_value)</span>
<span class="gi">+            param_decls or (), expose_value</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.type: types.ParamType = types.convert_type(type, default)
<span class="gi">+</span>
<span class="gi">+        # Default nargs to what the type tells us if we have that</span>
<span class="gi">+        # information available.</span>
<span class="w"> </span>        if nargs is None:
<span class="w"> </span>            if self.type.is_composite:
<span class="w"> </span>                nargs = self.type.arity
<span class="w"> </span>            else:
<span class="w"> </span>                nargs = 1
<span class="gi">+</span>
<span class="w"> </span>        self.required = required
<span class="w"> </span>        self.callback = callback
<span class="w"> </span>        self.nargs = nargs
<span class="gu">@@ -1188,38 +2131,49 @@ class Parameter:</span>
<span class="w"> </span>        self.metavar = metavar
<span class="w"> </span>        self.envvar = envvar
<span class="w"> </span>        self._custom_shell_complete = shell_complete
<span class="gi">+</span>
<span class="w"> </span>        if __debug__:
<span class="w"> </span>            if self.type.is_composite and nargs != self.type.arity:
<span class="w"> </span>                raise ValueError(
<span class="gd">-                    f&quot;&#39;nargs&#39; must be {self.type.arity} (or None) for type {self.type!r}, but it was {nargs}.&quot;</span>
<span class="gd">-                    )</span>
<span class="gi">+                    f&quot;&#39;nargs&#39; must be {self.type.arity} (or None) for&quot;</span>
<span class="gi">+                    f&quot; type {self.type!r}, but it was {nargs}.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            # Skip no default or callable default.</span>
<span class="w"> </span>            check_default = default if not callable(default) else None
<span class="gi">+</span>
<span class="w"> </span>            if check_default is not None:
<span class="w"> </span>                if multiple:
<span class="w"> </span>                    try:
<span class="gi">+                        # Only check the first value against nargs.</span>
<span class="w"> </span>                        check_default = next(_check_iter(check_default), None)
<span class="w"> </span>                    except TypeError:
<span class="w"> </span>                        raise ValueError(
<span class="w"> </span>                            &quot;&#39;default&#39; must be a list when &#39;multiple&#39; is true.&quot;
<span class="gd">-                            ) from None</span>
<span class="gi">+                        ) from None</span>
<span class="gi">+</span>
<span class="gi">+                # Can be None for multiple with empty default.</span>
<span class="w"> </span>                if nargs != 1 and check_default is not None:
<span class="w"> </span>                    try:
<span class="w"> </span>                        _check_iter(check_default)
<span class="w"> </span>                    except TypeError:
<span class="w"> </span>                        if multiple:
<span class="w"> </span>                            message = (
<span class="gd">-                                &quot;&#39;default&#39; must be a list of lists when &#39;multiple&#39; is true and &#39;nargs&#39; != 1.&quot;</span>
<span class="gd">-                                )</span>
<span class="gi">+                                &quot;&#39;default&#39; must be a list of lists when &#39;multiple&#39; is&quot;</span>
<span class="gi">+                                &quot; true and &#39;nargs&#39; != 1.&quot;</span>
<span class="gi">+                            )</span>
<span class="w"> </span>                        else:
<span class="gd">-                            message = (</span>
<span class="gd">-                                &quot;&#39;default&#39; must be a list when &#39;nargs&#39; != 1.&quot;)</span>
<span class="gi">+                            message = &quot;&#39;default&#39; must be a list when &#39;nargs&#39; != 1.&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>                        raise ValueError(message) from None
<span class="gi">+</span>
<span class="w"> </span>                    if nargs &gt; 1 and len(check_default) != nargs:
<span class="gd">-                        subject = &#39;item length&#39; if multiple else &#39;length&#39;</span>
<span class="gi">+                        subject = &quot;item length&quot; if multiple else &quot;length&quot;</span>
<span class="w"> </span>                        raise ValueError(
<span class="gd">-                            f&quot;&#39;default&#39; {subject} must match nargs={nargs}.&quot;)</span>
<span class="gi">+                            f&quot;&#39;default&#39; {subject} must match nargs={nargs}.&quot;</span>
<span class="gi">+                        )</span>

<span class="gd">-    def to_info_dict(self) -&gt;t.Dict[str, t.Any]:</span>
<span class="gi">+    def to_info_dict(self) -&gt; t.Dict[str, t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Gather information that could be useful for a tool generating
<span class="w"> </span>        user-facing documentation.

<span class="gu">@@ -1228,20 +2182,63 @@ class Parameter:</span>

<span class="w"> </span>        .. versionadded:: 8.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;{self.__class__.__name__} {self.name}&gt;&#39;</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;name&quot;: self.name,</span>
<span class="gi">+            &quot;param_type_name&quot;: self.param_type_name,</span>
<span class="gi">+            &quot;opts&quot;: self.opts,</span>
<span class="gi">+            &quot;secondary_opts&quot;: self.secondary_opts,</span>
<span class="gi">+            &quot;type&quot;: self.type.to_info_dict(),</span>
<span class="gi">+            &quot;required&quot;: self.required,</span>
<span class="gi">+            &quot;nargs&quot;: self.nargs,</span>
<span class="gi">+            &quot;multiple&quot;: self.multiple,</span>
<span class="gi">+            &quot;default&quot;: self.default,</span>
<span class="gi">+            &quot;envvar&quot;: self.envvar,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{self.__class__.__name__} {self.name}&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_decls(</span>
<span class="gi">+        self, decls: t.Sequence[str], expose_value: bool</span>
<span class="gi">+    ) -&gt; t.Tuple[t.Optional[str], t.List[str], t.List[str]]:</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    @property
<span class="gd">-    def human_readable_name(self) -&gt;str:</span>
<span class="gi">+    def human_readable_name(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the human readable name of this parameter.  This is the
<span class="w"> </span>        same as the name for options, but the metavar for arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.name  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def make_metavar(self) -&gt; str:</span>
<span class="gi">+        if self.metavar is not None:</span>
<span class="gi">+            return self.metavar</span>
<span class="gi">+</span>
<span class="gi">+        metavar = self.type.get_metavar(self)</span>
<span class="gi">+</span>
<span class="gi">+        if metavar is None:</span>
<span class="gi">+            metavar = self.type.name.upper()</span>
<span class="gi">+</span>
<span class="gi">+        if self.nargs != 1:</span>
<span class="gi">+            metavar += &quot;...&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return metavar</span>

<span class="gd">-    def get_default(self, ctx: Context, call: bool=True) -&gt;t.Optional[t.</span>
<span class="gd">-        Union[t.Any, t.Callable[[], t.Any]]]:</span>
<span class="gi">+    @t.overload</span>
<span class="gi">+    def get_default(</span>
<span class="gi">+        self, ctx: Context, call: &quot;te.Literal[True]&quot; = True</span>
<span class="gi">+    ) -&gt; t.Optional[t.Any]:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @t.overload</span>
<span class="gi">+    def get_default(</span>
<span class="gi">+        self, ctx: Context, call: bool = ...</span>
<span class="gi">+    ) -&gt; t.Optional[t.Union[t.Any, t.Callable[[], t.Any]]]:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    def get_default(</span>
<span class="gi">+        self, ctx: Context, call: bool = True</span>
<span class="gi">+    ) -&gt; t.Optional[t.Union[t.Any, t.Callable[[], t.Any]]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the default for the parameter. Tries
<span class="w"> </span>        :meth:`Context.lookup_default` first, then the local default.

<span class="gu">@@ -1262,22 +2259,170 @@ class Parameter:</span>
<span class="w"> </span>        .. versionchanged:: 8.0
<span class="w"> </span>            Added the ``call`` parameter.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        value = ctx.lookup_default(self.name, call=False)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            value = self.default</span>
<span class="gi">+</span>
<span class="gi">+        if call and callable(value):</span>
<span class="gi">+            value = value()</span>

<span class="gd">-    def type_cast_value(self, ctx: Context, value: t.Any) -&gt;t.Any:</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    def add_to_parser(self, parser: OptionParser, ctx: Context) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def consume_value(</span>
<span class="gi">+        self, ctx: Context, opts: t.Mapping[str, t.Any]</span>
<span class="gi">+    ) -&gt; t.Tuple[t.Any, ParameterSource]:</span>
<span class="gi">+        value = opts.get(self.name)  # type: ignore</span>
<span class="gi">+        source = ParameterSource.COMMANDLINE</span>
<span class="gi">+</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            value = self.value_from_envvar(ctx)</span>
<span class="gi">+            source = ParameterSource.ENVIRONMENT</span>
<span class="gi">+</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            value = ctx.lookup_default(self.name)  # type: ignore</span>
<span class="gi">+            source = ParameterSource.DEFAULT_MAP</span>
<span class="gi">+</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            value = self.get_default(ctx)</span>
<span class="gi">+            source = ParameterSource.DEFAULT</span>
<span class="gi">+</span>
<span class="gi">+        return value, source</span>
<span class="gi">+</span>
<span class="gi">+    def type_cast_value(self, ctx: Context, value: t.Any) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert and validate a value against the option&#39;s
<span class="w"> </span>        :attr:`type`, :attr:`multiple`, and :attr:`nargs`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        if value is None:</span>
<span class="gi">+            return () if self.multiple or self.nargs == -1 else None</span>
<span class="gi">+</span>
<span class="gi">+        def check_iter(value: t.Any) -&gt; t.Iterator[t.Any]:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return _check_iter(value)</span>
<span class="gi">+            except TypeError:</span>
<span class="gi">+                # This should only happen when passing in args manually,</span>
<span class="gi">+                # the parser should construct an iterable when parsing</span>
<span class="gi">+                # the command line.</span>
<span class="gi">+                raise BadParameter(</span>
<span class="gi">+                    _(&quot;Value must be an iterable.&quot;), ctx=ctx, param=self</span>
<span class="gi">+                ) from None</span>
<span class="gi">+</span>
<span class="gi">+        if self.nargs == 1 or self.type.is_composite:</span>
<span class="gi">+</span>
<span class="gi">+            def convert(value: t.Any) -&gt; t.Any:</span>
<span class="gi">+                return self.type(value, param=self, ctx=ctx)</span>
<span class="gi">+</span>
<span class="gi">+        elif self.nargs == -1:</span>
<span class="gi">+</span>
<span class="gi">+            def convert(value: t.Any) -&gt; t.Any:  # t.Tuple[t.Any, ...]</span>
<span class="gi">+                return tuple(self.type(x, self, ctx) for x in check_iter(value))</span>
<span class="gi">+</span>
<span class="gi">+        else:  # nargs &gt; 1</span>
<span class="gi">+</span>
<span class="gi">+            def convert(value: t.Any) -&gt; t.Any:  # t.Tuple[t.Any, ...]</span>
<span class="gi">+                value = tuple(check_iter(value))</span>
<span class="gi">+</span>
<span class="gi">+                if len(value) != self.nargs:</span>
<span class="gi">+                    raise BadParameter(</span>
<span class="gi">+                        ngettext(</span>
<span class="gi">+                            &quot;Takes {nargs} values but 1 was given.&quot;,</span>
<span class="gi">+                            &quot;Takes {nargs} values but {len} were given.&quot;,</span>
<span class="gi">+                            len(value),</span>
<span class="gi">+                        ).format(nargs=self.nargs, len=len(value)),</span>
<span class="gi">+                        ctx=ctx,</span>
<span class="gi">+                        param=self,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                return tuple(self.type(x, self, ctx) for x in value)</span>
<span class="gi">+</span>
<span class="gi">+        if self.multiple:</span>
<span class="gi">+            return tuple(convert(x) for x in check_iter(value))</span>
<span class="gi">+</span>
<span class="gi">+        return convert(value)</span>
<span class="gi">+</span>
<span class="gi">+    def value_is_missing(self, value: t.Any) -&gt; bool:</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        if (self.nargs != 1 or self.multiple) and value == ():</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def process_value(self, ctx: Context, value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        value = self.type_cast_value(ctx, value)</span>
<span class="gi">+</span>
<span class="gi">+        if self.required and self.value_is_missing(value):</span>
<span class="gi">+            raise MissingParameter(ctx=ctx, param=self)</span>
<span class="gi">+</span>
<span class="gi">+        if self.callback is not None:</span>
<span class="gi">+            value = self.callback(ctx, self, value)</span>
<span class="gi">+</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_envvar_value(self, ctx: Context) -&gt; t.Optional[str]:</span>
<span class="gi">+        if self.envvar is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(self.envvar, str):</span>
<span class="gi">+            rv = os.environ.get(self.envvar)</span>
<span class="gi">+</span>
<span class="gi">+            if rv:</span>
<span class="gi">+                return rv</span>
<span class="gi">+        else:</span>
<span class="gi">+            for envvar in self.envvar:</span>
<span class="gi">+                rv = os.environ.get(envvar)</span>
<span class="gi">+</span>
<span class="gi">+                if rv:</span>
<span class="gi">+                    return rv</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def value_from_envvar(self, ctx: Context) -&gt; t.Optional[t.Any]:</span>
<span class="gi">+        rv: t.Optional[t.Any] = self.resolve_envvar_value(ctx)</span>
<span class="gi">+</span>
<span class="gi">+        if rv is not None and self.nargs != 1:</span>
<span class="gi">+            rv = self.type.split_envvar_value(rv)</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def handle_parse_result(</span>
<span class="gi">+        self, ctx: Context, opts: t.Mapping[str, t.Any], args: t.List[str]</span>
<span class="gi">+    ) -&gt; t.Tuple[t.Any, t.List[str]]:</span>
<span class="gi">+        with augment_usage_errors(ctx, param=self):</span>
<span class="gi">+            value, source = self.consume_value(ctx, opts)</span>
<span class="gi">+            ctx.set_parameter_source(self.name, source)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                value = self.process_value(ctx, value)</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                if not ctx.resilient_parsing:</span>
<span class="gi">+                    raise</span>
<span class="gi">+</span>
<span class="gi">+                value = None</span>
<span class="gi">+</span>
<span class="gi">+        if self.expose_value:</span>
<span class="gi">+            ctx.params[self.name] = value  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        return value, args</span>
<span class="gi">+</span>
<span class="gi">+    def get_help_record(self, ctx: Context) -&gt; t.Optional[t.Tuple[str, str]]:</span>
<span class="w"> </span>        pass

<span class="gd">-    def get_error_hint(self, ctx: Context) -&gt;str:</span>
<span class="gi">+    def get_usage_pieces(self, ctx: Context) -&gt; t.List[str]:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def get_error_hint(self, ctx: Context) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get a stringified version of the param for use in error messages to
<span class="w"> </span>        indicate which param caused the error.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hint_list = self.opts or [self.human_readable_name]</span>
<span class="gi">+        return &quot; / &quot;.join(f&quot;&#39;{x}&#39;&quot; for x in hint_list)</span>

<span class="gd">-    def shell_complete(self, ctx: Context, incomplete: str) -&gt;t.List[</span>
<span class="gd">-        &#39;CompletionItem&#39;]:</span>
<span class="gi">+    def shell_complete(self, ctx: Context, incomplete: str) -&gt; t.List[&quot;CompletionItem&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of completions for the incomplete value. If a
<span class="w"> </span>        ``shell_complete`` function was given during init, it is used.
<span class="w"> </span>        Otherwise, the :attr:`type`
<span class="gu">@@ -1288,7 +2433,17 @@ class Parameter:</span>

<span class="w"> </span>        .. versionadded:: 8.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._custom_shell_complete is not None:</span>
<span class="gi">+            results = self._custom_shell_complete(ctx, self, incomplete)</span>
<span class="gi">+</span>
<span class="gi">+            if results and isinstance(results[0], str):</span>
<span class="gi">+                from click.shell_completion import CompletionItem</span>
<span class="gi">+</span>
<span class="gi">+                results = [CompletionItem(c) for c in results]</span>
<span class="gi">+</span>
<span class="gi">+            return t.cast(t.List[&quot;CompletionItem&quot;], results)</span>
<span class="gi">+</span>
<span class="gi">+        return self.type.shell_complete(ctx, self, incomplete)</span>


<span class="w"> </span>class Option(Parameter):
<span class="gu">@@ -1351,98 +2506,464 @@ class Option(Parameter):</span>
<span class="w"> </span>    .. versionchanged:: 8.0.1
<span class="w"> </span>        ``type`` is detected from ``flag_value`` if given.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    param_type_name = &#39;option&#39;</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, param_decls: t.Optional[t.Sequence[str]]=None,</span>
<span class="gd">-        show_default: t.Union[bool, str, None]=None, prompt: t.Union[bool,</span>
<span class="gd">-        str]=False, confirmation_prompt: t.Union[bool, str]=False,</span>
<span class="gd">-        prompt_required: bool=True, hide_input: bool=False, is_flag: t.</span>
<span class="gd">-        Optional[bool]=None, flag_value: t.Optional[t.Any]=None, multiple:</span>
<span class="gd">-        bool=False, count: bool=False, allow_from_autoenv: bool=True, type:</span>
<span class="gd">-        t.Optional[t.Union[types.ParamType, t.Any]]=None, help: t.Optional[</span>
<span class="gd">-        str]=None, hidden: bool=False, show_choices: bool=True, show_envvar:</span>
<span class="gd">-        bool=False, **attrs: t.Any) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    param_type_name = &quot;option&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        param_decls: t.Optional[t.Sequence[str]] = None,</span>
<span class="gi">+        show_default: t.Union[bool, str, None] = None,</span>
<span class="gi">+        prompt: t.Union[bool, str] = False,</span>
<span class="gi">+        confirmation_prompt: t.Union[bool, str] = False,</span>
<span class="gi">+        prompt_required: bool = True,</span>
<span class="gi">+        hide_input: bool = False,</span>
<span class="gi">+        is_flag: t.Optional[bool] = None,</span>
<span class="gi">+        flag_value: t.Optional[t.Any] = None,</span>
<span class="gi">+        multiple: bool = False,</span>
<span class="gi">+        count: bool = False,</span>
<span class="gi">+        allow_from_autoenv: bool = True,</span>
<span class="gi">+        type: t.Optional[t.Union[types.ParamType, t.Any]] = None,</span>
<span class="gi">+        help: t.Optional[str] = None,</span>
<span class="gi">+        hidden: bool = False,</span>
<span class="gi">+        show_choices: bool = True,</span>
<span class="gi">+        show_envvar: bool = False,</span>
<span class="gi">+        **attrs: t.Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if help:
<span class="w"> </span>            help = inspect.cleandoc(help)
<span class="gd">-        default_is_missing = &#39;default&#39; not in attrs</span>
<span class="gi">+</span>
<span class="gi">+        default_is_missing = &quot;default&quot; not in attrs</span>
<span class="w"> </span>        super().__init__(param_decls, type=type, multiple=multiple, **attrs)
<span class="gi">+</span>
<span class="w"> </span>        if prompt is True:
<span class="w"> </span>            if self.name is None:
<span class="w"> </span>                raise TypeError(&quot;&#39;name&#39; is required with &#39;prompt=True&#39;.&quot;)
<span class="gd">-            prompt_text: t.Optional[str] = self.name.replace(&#39;_&#39;, &#39; &#39;</span>
<span class="gd">-                ).capitalize()</span>
<span class="gi">+</span>
<span class="gi">+            prompt_text: t.Optional[str] = self.name.replace(&quot;_&quot;, &quot; &quot;).capitalize()</span>
<span class="w"> </span>        elif prompt is False:
<span class="w"> </span>            prompt_text = None
<span class="w"> </span>        else:
<span class="w"> </span>            prompt_text = prompt
<span class="gi">+</span>
<span class="w"> </span>        self.prompt = prompt_text
<span class="w"> </span>        self.confirmation_prompt = confirmation_prompt
<span class="w"> </span>        self.prompt_required = prompt_required
<span class="w"> </span>        self.hide_input = hide_input
<span class="w"> </span>        self.hidden = hidden
<span class="gd">-        self._flag_needs_value = (self.prompt is not None and not self.</span>
<span class="gd">-            prompt_required)</span>
<span class="gi">+</span>
<span class="gi">+        # If prompt is enabled but not required, then the option can be</span>
<span class="gi">+        # used as a flag to indicate using prompt or flag_value.</span>
<span class="gi">+        self._flag_needs_value = self.prompt is not None and not self.prompt_required</span>
<span class="gi">+</span>
<span class="w"> </span>        if is_flag is None:
<span class="w"> </span>            if flag_value is not None:
<span class="gi">+                # Implicitly a flag because flag_value was set.</span>
<span class="w"> </span>                is_flag = True
<span class="w"> </span>            elif self._flag_needs_value:
<span class="gi">+                # Not a flag, but when used as a flag it shows a prompt.</span>
<span class="w"> </span>                is_flag = False
<span class="w"> </span>            else:
<span class="gi">+                # Implicitly a flag because flag options were given.</span>
<span class="w"> </span>                is_flag = bool(self.secondary_opts)
<span class="w"> </span>        elif is_flag is False and not self._flag_needs_value:
<span class="gi">+            # Not a flag, and prompt is not enabled, can be used as a</span>
<span class="gi">+            # flag if flag_value is set.</span>
<span class="w"> </span>            self._flag_needs_value = flag_value is not None
<span class="gi">+</span>
<span class="w"> </span>        self.default: t.Union[t.Any, t.Callable[[], t.Any]]
<span class="gi">+</span>
<span class="w"> </span>        if is_flag and default_is_missing and not self.required:
<span class="w"> </span>            if multiple:
<span class="w"> </span>                self.default = ()
<span class="w"> </span>            else:
<span class="w"> </span>                self.default = False
<span class="gi">+</span>
<span class="w"> </span>        if flag_value is None:
<span class="w"> </span>            flag_value = not self.default
<span class="gi">+</span>
<span class="w"> </span>        self.type: types.ParamType
<span class="w"> </span>        if is_flag and type is None:
<span class="gi">+            # Re-guess the type from the flag value instead of the</span>
<span class="gi">+            # default.</span>
<span class="w"> </span>            self.type = types.convert_type(None, flag_value)
<span class="gi">+</span>
<span class="w"> </span>        self.is_flag: bool = is_flag
<span class="gd">-        self.is_bool_flag: bool = is_flag and isinstance(self.type, types.</span>
<span class="gd">-            BoolParamType)</span>
<span class="gi">+        self.is_bool_flag: bool = is_flag and isinstance(self.type, types.BoolParamType)</span>
<span class="w"> </span>        self.flag_value: t.Any = flag_value
<span class="gi">+</span>
<span class="gi">+        # Counting</span>
<span class="w"> </span>        self.count = count
<span class="w"> </span>        if count:
<span class="w"> </span>            if type is None:
<span class="w"> </span>                self.type = types.IntRange(min=0)
<span class="w"> </span>            if default_is_missing:
<span class="w"> </span>                self.default = 0
<span class="gi">+</span>
<span class="w"> </span>        self.allow_from_autoenv = allow_from_autoenv
<span class="w"> </span>        self.help = help
<span class="w"> </span>        self.show_default = show_default
<span class="w"> </span>        self.show_choices = show_choices
<span class="w"> </span>        self.show_envvar = show_envvar
<span class="gi">+</span>
<span class="w"> </span>        if __debug__:
<span class="w"> </span>            if self.nargs == -1:
<span class="gd">-                raise TypeError(&#39;nargs=-1 is not supported for options.&#39;)</span>
<span class="gi">+                raise TypeError(&quot;nargs=-1 is not supported for options.&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>            if self.prompt and self.is_flag and not self.is_bool_flag:
<span class="w"> </span>                raise TypeError(&quot;&#39;prompt&#39; is not valid for non-boolean flag.&quot;)
<span class="gi">+</span>
<span class="w"> </span>            if not self.is_bool_flag and self.secondary_opts:
<span class="gd">-                raise TypeError(</span>
<span class="gd">-                    &#39;Secondary flag is not valid for non-boolean flag.&#39;)</span>
<span class="gd">-            if (self.is_bool_flag and self.hide_input and self.prompt is not</span>
<span class="gd">-                None):</span>
<span class="gi">+                raise TypeError(&quot;Secondary flag is not valid for non-boolean flag.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if self.is_bool_flag and self.hide_input and self.prompt is not None:</span>
<span class="w"> </span>                raise TypeError(
<span class="w"> </span>                    &quot;&#39;prompt&#39; with &#39;hide_input&#39; is not valid for boolean flag.&quot;
<span class="gd">-                    )</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="w"> </span>            if self.count:
<span class="w"> </span>                if self.multiple:
<span class="w"> </span>                    raise TypeError(&quot;&#39;count&#39; is not valid with &#39;multiple&#39;.&quot;)
<span class="gi">+</span>
<span class="w"> </span>                if self.is_flag:
<span class="w"> </span>                    raise TypeError(&quot;&#39;count&#39; is not valid with &#39;is_flag&#39;.&quot;)

<span class="gd">-    def prompt_for_value(self, ctx: Context) -&gt;t.Any:</span>
<span class="gi">+    def to_info_dict(self) -&gt; t.Dict[str, t.Any]:</span>
<span class="gi">+        info_dict = super().to_info_dict()</span>
<span class="gi">+        info_dict.update(</span>
<span class="gi">+            help=self.help,</span>
<span class="gi">+            prompt=self.prompt,</span>
<span class="gi">+            is_flag=self.is_flag,</span>
<span class="gi">+            flag_value=self.flag_value,</span>
<span class="gi">+            count=self.count,</span>
<span class="gi">+            hidden=self.hidden,</span>
<span class="gi">+        )</span>
<span class="gi">+        return info_dict</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_decls(</span>
<span class="gi">+        self, decls: t.Sequence[str], expose_value: bool</span>
<span class="gi">+    ) -&gt; t.Tuple[t.Optional[str], t.List[str], t.List[str]]:</span>
<span class="gi">+        opts = []</span>
<span class="gi">+        secondary_opts = []</span>
<span class="gi">+        name = None</span>
<span class="gi">+        possible_names = []</span>
<span class="gi">+</span>
<span class="gi">+        for decl in decls:</span>
<span class="gi">+            if decl.isidentifier():</span>
<span class="gi">+                if name is not None:</span>
<span class="gi">+                    raise TypeError(f&quot;Name &#39;{name}&#39; defined twice&quot;)</span>
<span class="gi">+                name = decl</span>
<span class="gi">+            else:</span>
<span class="gi">+                split_char = &quot;;&quot; if decl[:1] == &quot;/&quot; else &quot;/&quot;</span>
<span class="gi">+                if split_char in decl:</span>
<span class="gi">+                    first, second = decl.split(split_char, 1)</span>
<span class="gi">+                    first = first.rstrip()</span>
<span class="gi">+                    if first:</span>
<span class="gi">+                        possible_names.append(split_opt(first))</span>
<span class="gi">+                        opts.append(first)</span>
<span class="gi">+                    second = second.lstrip()</span>
<span class="gi">+                    if second:</span>
<span class="gi">+                        secondary_opts.append(second.lstrip())</span>
<span class="gi">+                    if first == second:</span>
<span class="gi">+                        raise ValueError(</span>
<span class="gi">+                            f&quot;Boolean option {decl!r} cannot use the&quot;</span>
<span class="gi">+                            &quot; same flag for true/false.&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    possible_names.append(split_opt(decl))</span>
<span class="gi">+                    opts.append(decl)</span>
<span class="gi">+</span>
<span class="gi">+        if name is None and possible_names:</span>
<span class="gi">+            possible_names.sort(key=lambda x: -len(x[0]))  # group long options first</span>
<span class="gi">+            name = possible_names[0][1].replace(&quot;-&quot;, &quot;_&quot;).lower()</span>
<span class="gi">+            if not name.isidentifier():</span>
<span class="gi">+                name = None</span>
<span class="gi">+</span>
<span class="gi">+        if name is None:</span>
<span class="gi">+            if not expose_value:</span>
<span class="gi">+                return None, opts, secondary_opts</span>
<span class="gi">+            raise TypeError(&quot;Could not determine name for option&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not opts and not secondary_opts:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                f&quot;No options defined but a name was passed ({name}).&quot;</span>
<span class="gi">+                &quot; Did you mean to declare an argument instead? Did&quot;</span>
<span class="gi">+                f&quot; you mean to pass &#39;--{name}&#39;?&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return name, opts, secondary_opts</span>
<span class="gi">+</span>
<span class="gi">+    def add_to_parser(self, parser: OptionParser, ctx: Context) -&gt; None:</span>
<span class="gi">+        if self.multiple:</span>
<span class="gi">+            action = &quot;append&quot;</span>
<span class="gi">+        elif self.count:</span>
<span class="gi">+            action = &quot;count&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            action = &quot;store&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if self.is_flag:</span>
<span class="gi">+            action = f&quot;{action}_const&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if self.is_bool_flag and self.secondary_opts:</span>
<span class="gi">+                parser.add_option(</span>
<span class="gi">+                    obj=self, opts=self.opts, dest=self.name, action=action, const=True</span>
<span class="gi">+                )</span>
<span class="gi">+                parser.add_option(</span>
<span class="gi">+                    obj=self,</span>
<span class="gi">+                    opts=self.secondary_opts,</span>
<span class="gi">+                    dest=self.name,</span>
<span class="gi">+                    action=action,</span>
<span class="gi">+                    const=False,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                parser.add_option(</span>
<span class="gi">+                    obj=self,</span>
<span class="gi">+                    opts=self.opts,</span>
<span class="gi">+                    dest=self.name,</span>
<span class="gi">+                    action=action,</span>
<span class="gi">+                    const=self.flag_value,</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            parser.add_option(</span>
<span class="gi">+                obj=self,</span>
<span class="gi">+                opts=self.opts,</span>
<span class="gi">+                dest=self.name,</span>
<span class="gi">+                action=action,</span>
<span class="gi">+                nargs=self.nargs,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def get_help_record(self, ctx: Context) -&gt; t.Optional[t.Tuple[str, str]]:</span>
<span class="gi">+        if self.hidden:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        any_prefix_is_slash = False</span>
<span class="gi">+</span>
<span class="gi">+        def _write_opts(opts: t.Sequence[str]) -&gt; str:</span>
<span class="gi">+            nonlocal any_prefix_is_slash</span>
<span class="gi">+</span>
<span class="gi">+            rv, any_slashes = join_options(opts)</span>
<span class="gi">+</span>
<span class="gi">+            if any_slashes:</span>
<span class="gi">+                any_prefix_is_slash = True</span>
<span class="gi">+</span>
<span class="gi">+            if not self.is_flag and not self.count:</span>
<span class="gi">+                rv += f&quot; {self.make_metavar()}&quot;</span>
<span class="gi">+</span>
<span class="gi">+            return rv</span>
<span class="gi">+</span>
<span class="gi">+        rv = [_write_opts(self.opts)]</span>
<span class="gi">+</span>
<span class="gi">+        if self.secondary_opts:</span>
<span class="gi">+            rv.append(_write_opts(self.secondary_opts))</span>
<span class="gi">+</span>
<span class="gi">+        help = self.help or &quot;&quot;</span>
<span class="gi">+        extra = []</span>
<span class="gi">+</span>
<span class="gi">+        if self.show_envvar:</span>
<span class="gi">+            envvar = self.envvar</span>
<span class="gi">+</span>
<span class="gi">+            if envvar is None:</span>
<span class="gi">+                if (</span>
<span class="gi">+                    self.allow_from_autoenv</span>
<span class="gi">+                    and ctx.auto_envvar_prefix is not None</span>
<span class="gi">+                    and self.name is not None</span>
<span class="gi">+                ):</span>
<span class="gi">+                    envvar = f&quot;{ctx.auto_envvar_prefix}_{self.name.upper()}&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if envvar is not None:</span>
<span class="gi">+                var_str = (</span>
<span class="gi">+                    envvar</span>
<span class="gi">+                    if isinstance(envvar, str)</span>
<span class="gi">+                    else &quot;, &quot;.join(str(d) for d in envvar)</span>
<span class="gi">+                )</span>
<span class="gi">+                extra.append(_(&quot;env var: {var}&quot;).format(var=var_str))</span>
<span class="gi">+</span>
<span class="gi">+        # Temporarily enable resilient parsing to avoid type casting</span>
<span class="gi">+        # failing for the default. Might be possible to extend this to</span>
<span class="gi">+        # help formatting in general.</span>
<span class="gi">+        resilient = ctx.resilient_parsing</span>
<span class="gi">+        ctx.resilient_parsing = True</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            default_value = self.get_default(ctx, call=False)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            ctx.resilient_parsing = resilient</span>
<span class="gi">+</span>
<span class="gi">+        show_default = False</span>
<span class="gi">+        show_default_is_str = False</span>
<span class="gi">+</span>
<span class="gi">+        if self.show_default is not None:</span>
<span class="gi">+            if isinstance(self.show_default, str):</span>
<span class="gi">+                show_default_is_str = show_default = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                show_default = self.show_default</span>
<span class="gi">+        elif ctx.show_default is not None:</span>
<span class="gi">+            show_default = ctx.show_default</span>
<span class="gi">+</span>
<span class="gi">+        if show_default_is_str or (show_default and (default_value is not None)):</span>
<span class="gi">+            if show_default_is_str:</span>
<span class="gi">+                default_string = f&quot;({self.show_default})&quot;</span>
<span class="gi">+            elif isinstance(default_value, (list, tuple)):</span>
<span class="gi">+                default_string = &quot;, &quot;.join(str(d) for d in default_value)</span>
<span class="gi">+            elif inspect.isfunction(default_value):</span>
<span class="gi">+                default_string = _(&quot;(dynamic)&quot;)</span>
<span class="gi">+            elif self.is_bool_flag and self.secondary_opts:</span>
<span class="gi">+                # For boolean flags that have distinct True/False opts,</span>
<span class="gi">+                # use the opt without prefix instead of the value.</span>
<span class="gi">+                default_string = split_opt(</span>
<span class="gi">+                    (self.opts if self.default else self.secondary_opts)[0]</span>
<span class="gi">+                )[1]</span>
<span class="gi">+            elif self.is_bool_flag and not self.secondary_opts and not default_value:</span>
<span class="gi">+                default_string = &quot;&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                default_string = str(default_value)</span>
<span class="gi">+</span>
<span class="gi">+            if default_string:</span>
<span class="gi">+                extra.append(_(&quot;default: {default}&quot;).format(default=default_string))</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(self.type, types._NumberRangeBase)</span>
<span class="gi">+            # skip count with default range type</span>
<span class="gi">+            and not (self.count and self.type.min == 0 and self.type.max is None)</span>
<span class="gi">+        ):</span>
<span class="gi">+            range_str = self.type._describe_range()</span>
<span class="gi">+</span>
<span class="gi">+            if range_str:</span>
<span class="gi">+                extra.append(range_str)</span>
<span class="gi">+</span>
<span class="gi">+        if self.required:</span>
<span class="gi">+            extra.append(_(&quot;required&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        if extra:</span>
<span class="gi">+            extra_str = &quot;; &quot;.join(extra)</span>
<span class="gi">+            help = f&quot;{help}  [{extra_str}]&quot; if help else f&quot;[{extra_str}]&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return (&quot;; &quot; if any_prefix_is_slash else &quot; / &quot;).join(rv), help</span>
<span class="gi">+</span>
<span class="gi">+    @t.overload</span>
<span class="gi">+    def get_default(</span>
<span class="gi">+        self, ctx: Context, call: &quot;te.Literal[True]&quot; = True</span>
<span class="gi">+    ) -&gt; t.Optional[t.Any]:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @t.overload</span>
<span class="gi">+    def get_default(</span>
<span class="gi">+        self, ctx: Context, call: bool = ...</span>
<span class="gi">+    ) -&gt; t.Optional[t.Union[t.Any, t.Callable[[], t.Any]]]:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    def get_default(</span>
<span class="gi">+        self, ctx: Context, call: bool = True</span>
<span class="gi">+    ) -&gt; t.Optional[t.Union[t.Any, t.Callable[[], t.Any]]]:</span>
<span class="gi">+        # If we&#39;re a non boolean flag our default is more complex because</span>
<span class="gi">+        # we need to look at all flags in the same group to figure out</span>
<span class="gi">+        # if we&#39;re the default one in which case we return the flag</span>
<span class="gi">+        # value as default.</span>
<span class="gi">+        if self.is_flag and not self.is_bool_flag:</span>
<span class="gi">+            for param in ctx.command.params:</span>
<span class="gi">+                if param.name == self.name and param.default:</span>
<span class="gi">+                    return t.cast(Option, param).flag_value</span>
<span class="gi">+</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        return super().get_default(ctx, call=call)</span>
<span class="gi">+</span>
<span class="gi">+    def prompt_for_value(self, ctx: Context) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;This is an alternative flow that can be activated in the full
<span class="w"> </span>        value processing if a value does not exist.  It will prompt the
<span class="w"> </span>        user until a valid value exists and then returns the processed
<span class="w"> </span>        value as result.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert self.prompt is not None</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate the default before prompting anything to be stable.</span>
<span class="gi">+        default = self.get_default(ctx)</span>
<span class="gi">+</span>
<span class="gi">+        # If this is a prompt for a flag we need to handle this</span>
<span class="gi">+        # differently.</span>
<span class="gi">+        if self.is_bool_flag:</span>
<span class="gi">+            return confirm(self.prompt, default)</span>
<span class="gi">+</span>
<span class="gi">+        return prompt(</span>
<span class="gi">+            self.prompt,</span>
<span class="gi">+            default=default,</span>
<span class="gi">+            type=self.type,</span>
<span class="gi">+            hide_input=self.hide_input,</span>
<span class="gi">+            show_choices=self.show_choices,</span>
<span class="gi">+            confirmation_prompt=self.confirmation_prompt,</span>
<span class="gi">+            value_proc=lambda x: self.process_value(ctx, x),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_envvar_value(self, ctx: Context) -&gt; t.Optional[str]:</span>
<span class="gi">+        rv = super().resolve_envvar_value(ctx)</span>
<span class="gi">+</span>
<span class="gi">+        if rv is not None:</span>
<span class="gi">+            return rv</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.allow_from_autoenv</span>
<span class="gi">+            and ctx.auto_envvar_prefix is not None</span>
<span class="gi">+            and self.name is not None</span>
<span class="gi">+        ):</span>
<span class="gi">+            envvar = f&quot;{ctx.auto_envvar_prefix}_{self.name.upper()}&quot;</span>
<span class="gi">+            rv = os.environ.get(envvar)</span>
<span class="gi">+</span>
<span class="gi">+            if rv:</span>
<span class="gi">+                return rv</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def value_from_envvar(self, ctx: Context) -&gt; t.Optional[t.Any]:</span>
<span class="gi">+        rv: t.Optional[t.Any] = self.resolve_envvar_value(ctx)</span>
<span class="gi">+</span>
<span class="gi">+        if rv is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        value_depth = (self.nargs != 1) + bool(self.multiple)</span>
<span class="gi">+</span>
<span class="gi">+        if value_depth &gt; 0:</span>
<span class="gi">+            rv = self.type.split_envvar_value(rv)</span>
<span class="gi">+</span>
<span class="gi">+            if self.multiple and self.nargs != 1:</span>
<span class="gi">+                rv = batch(rv, self.nargs)</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def consume_value(</span>
<span class="gi">+        self, ctx: Context, opts: t.Mapping[str, &quot;Parameter&quot;]</span>
<span class="gi">+    ) -&gt; t.Tuple[t.Any, ParameterSource]:</span>
<span class="gi">+        value, source = super().consume_value(ctx, opts)</span>
<span class="gi">+</span>
<span class="gi">+        # The parser will emit a sentinel value if the option can be</span>
<span class="gi">+        # given as a flag without a value. This is different from None</span>
<span class="gi">+        # to distinguish from the flag not being given at all.</span>
<span class="gi">+        if value is _flag_needs_value:</span>
<span class="gi">+            if self.prompt is not None and not ctx.resilient_parsing:</span>
<span class="gi">+                value = self.prompt_for_value(ctx)</span>
<span class="gi">+                source = ParameterSource.PROMPT</span>
<span class="gi">+            else:</span>
<span class="gi">+                value = self.flag_value</span>
<span class="gi">+                source = ParameterSource.COMMANDLINE</span>
<span class="gi">+</span>
<span class="gi">+        elif (</span>
<span class="gi">+            self.multiple</span>
<span class="gi">+            and value is not None</span>
<span class="gi">+            and any(v is _flag_needs_value for v in value)</span>
<span class="gi">+        ):</span>
<span class="gi">+            value = [self.flag_value if v is _flag_needs_value else v for v in value]</span>
<span class="gi">+            source = ParameterSource.COMMANDLINE</span>
<span class="gi">+</span>
<span class="gi">+        # The value wasn&#39;t set, or used the param&#39;s default, prompt if</span>
<span class="gi">+        # prompting is enabled.</span>
<span class="gi">+        elif (</span>
<span class="gi">+            source in {None, ParameterSource.DEFAULT}</span>
<span class="gi">+            and self.prompt is not None</span>
<span class="gi">+            and (self.required or self.prompt_required)</span>
<span class="gi">+            and not ctx.resilient_parsing</span>
<span class="gi">+        ):</span>
<span class="gi">+            value = self.prompt_for_value(ctx)</span>
<span class="gi">+            source = ParameterSource.PROMPT</span>
<span class="gi">+</span>
<span class="gi">+        return value, source</span>


<span class="w"> </span>class Argument(Parameter):
<span class="gu">@@ -1452,19 +2973,70 @@ class Argument(Parameter):</span>

<span class="w"> </span>    All parameters are passed onwards to the constructor of :class:`Parameter`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    param_type_name = &#39;argument&#39;</span>

<span class="gd">-    def __init__(self, param_decls: t.Sequence[str], required: t.Optional[</span>
<span class="gd">-        bool]=None, **attrs: t.Any) -&gt;None:</span>
<span class="gi">+    param_type_name = &quot;argument&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        param_decls: t.Sequence[str],</span>
<span class="gi">+        required: t.Optional[bool] = None,</span>
<span class="gi">+        **attrs: t.Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if required is None:
<span class="gd">-            if attrs.get(&#39;default&#39;) is not None:</span>
<span class="gi">+            if attrs.get(&quot;default&quot;) is not None:</span>
<span class="w"> </span>                required = False
<span class="w"> </span>            else:
<span class="gd">-                required = attrs.get(&#39;nargs&#39;, 1) &gt; 0</span>
<span class="gd">-        if &#39;multiple&#39; in attrs:</span>
<span class="gd">-            raise TypeError(</span>
<span class="gd">-                &quot;__init__() got an unexpected keyword argument &#39;multiple&#39;.&quot;)</span>
<span class="gi">+                required = attrs.get(&quot;nargs&quot;, 1) &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;multiple&quot; in attrs:</span>
<span class="gi">+            raise TypeError(&quot;__init__() got an unexpected keyword argument &#39;multiple&#39;.&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(param_decls, required=required, **attrs)
<span class="gi">+</span>
<span class="w"> </span>        if __debug__:
<span class="w"> </span>            if self.default is not None and self.nargs == -1:
<span class="w"> </span>                raise TypeError(&quot;&#39;default&#39; is not supported for nargs=-1.&quot;)
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def human_readable_name(self) -&gt; str:</span>
<span class="gi">+        if self.metavar is not None:</span>
<span class="gi">+            return self.metavar</span>
<span class="gi">+        return self.name.upper()  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def make_metavar(self) -&gt; str:</span>
<span class="gi">+        if self.metavar is not None:</span>
<span class="gi">+            return self.metavar</span>
<span class="gi">+        var = self.type.get_metavar(self)</span>
<span class="gi">+        if not var:</span>
<span class="gi">+            var = self.name.upper()  # type: ignore</span>
<span class="gi">+        if not self.required:</span>
<span class="gi">+            var = f&quot;[{var}]&quot;</span>
<span class="gi">+        if self.nargs != 1:</span>
<span class="gi">+            var += &quot;...&quot;</span>
<span class="gi">+        return var</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_decls(</span>
<span class="gi">+        self, decls: t.Sequence[str], expose_value: bool</span>
<span class="gi">+    ) -&gt; t.Tuple[t.Optional[str], t.List[str], t.List[str]]:</span>
<span class="gi">+        if not decls:</span>
<span class="gi">+            if not expose_value:</span>
<span class="gi">+                return None, [], []</span>
<span class="gi">+            raise TypeError(&quot;Could not determine name for argument&quot;)</span>
<span class="gi">+        if len(decls) == 1:</span>
<span class="gi">+            name = arg = decls[0]</span>
<span class="gi">+            name = name.replace(&quot;-&quot;, &quot;_&quot;).lower()</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Arguments take exactly one parameter declaration, got&quot;</span>
<span class="gi">+                f&quot; {len(decls)}.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        return name, [arg], []</span>
<span class="gi">+</span>
<span class="gi">+    def get_usage_pieces(self, ctx: Context) -&gt; t.List[str]:</span>
<span class="gi">+        return [self.make_metavar()]</span>
<span class="gi">+</span>
<span class="gi">+    def get_error_hint(self, ctx: Context) -&gt; str:</span>
<span class="gi">+        return f&quot;&#39;{self.make_metavar()}&#39;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def add_to_parser(self, parser: OptionParser, ctx: Context) -&gt; None:</span>
<span class="gi">+        parser.add_argument(dest=self.name, nargs=self.nargs, obj=self)</span>
<span class="gh">diff --git a/src/click/decorators.py b/src/click/decorators.py</span>
<span class="gh">index ec1bfc9..d9bba95 100644</span>
<span class="gd">--- a/src/click/decorators.py</span>
<span class="gi">+++ b/src/click/decorators.py</span>
<span class="gu">@@ -3,6 +3,7 @@ import types</span>
<span class="w"> </span>import typing as t
<span class="w"> </span>from functools import update_wrapper
<span class="w"> </span>from gettext import gettext as _
<span class="gi">+</span>
<span class="w"> </span>from .core import Argument
<span class="w"> </span>from .core import Command
<span class="w"> </span>from .core import Context
<span class="gu">@@ -11,35 +12,44 @@ from .core import Option</span>
<span class="w"> </span>from .core import Parameter
<span class="w"> </span>from .globals import get_current_context
<span class="w"> </span>from .utils import echo
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="gd">-    P = te.ParamSpec(&#39;P&#39;)</span>
<span class="gd">-R = t.TypeVar(&#39;R&#39;)</span>
<span class="gd">-T = t.TypeVar(&#39;T&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    P = te.ParamSpec(&quot;P&quot;)</span>
<span class="gi">+</span>
<span class="gi">+R = t.TypeVar(&quot;R&quot;)</span>
<span class="gi">+T = t.TypeVar(&quot;T&quot;)</span>
<span class="w"> </span>_AnyCallable = t.Callable[..., t.Any]
<span class="gd">-FC = t.TypeVar(&#39;FC&#39;, bound=t.Union[_AnyCallable, Command])</span>
<span class="gi">+FC = t.TypeVar(&quot;FC&quot;, bound=t.Union[_AnyCallable, Command])</span>


<span class="gd">-def pass_context(f: &#39;t.Callable[te.Concatenate[Context, P], R]&#39;</span>
<span class="gd">-    ) -&gt;&#39;t.Callable[P, R]&#39;:</span>
<span class="gi">+def pass_context(f: &quot;t.Callable[te.Concatenate[Context, P], R]&quot;) -&gt; &quot;t.Callable[P, R]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Marks a callback as wanting to receive the current context
<span class="w"> </span>    object as first argument.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def new_func(*args: &quot;P.args&quot;, **kwargs: &quot;P.kwargs&quot;) -&gt; &quot;R&quot;:</span>
<span class="gi">+        return f(get_current_context(), *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    return update_wrapper(new_func, f)</span>

<span class="gd">-def pass_obj(f: &#39;t.Callable[te.Concatenate[t.Any, P], R]&#39;</span>
<span class="gd">-    ) -&gt;&#39;t.Callable[P, R]&#39;:</span>
<span class="gi">+</span>
<span class="gi">+def pass_obj(f: &quot;t.Callable[te.Concatenate[t.Any, P], R]&quot;) -&gt; &quot;t.Callable[P, R]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Similar to :func:`pass_context`, but only pass the object on the
<span class="w"> </span>    context onwards (:attr:`Context.obj`).  This is useful if that object
<span class="w"> </span>    represents the state of a nested system.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def new_func(*args: &quot;P.args&quot;, **kwargs: &quot;P.kwargs&quot;) -&gt; &quot;R&quot;:</span>
<span class="gi">+        return f(get_current_context().obj, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    return update_wrapper(new_func, f)</span>

<span class="gd">-def make_pass_decorator(object_type: t.Type[T], ensure: bool=False</span>
<span class="gd">-    ) -&gt;t.Callable[[&#39;t.Callable[te.Concatenate[T, P], R]&#39;], &#39;t.Callable[P, R]&#39;</span>
<span class="gd">-    ]:</span>
<span class="gi">+</span>
<span class="gi">+def make_pass_decorator(</span>
<span class="gi">+    object_type: t.Type[T], ensure: bool = False</span>
<span class="gi">+) -&gt; t.Callable[[&quot;t.Callable[te.Concatenate[T, P], R]&quot;], &quot;t.Callable[P, R]&quot;]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Given an object type this creates a decorator that will work
<span class="w"> </span>    similar to :func:`pass_obj` but instead of passing the object of the
<span class="w"> </span>    current context, it will find the innermost context of type
<span class="gu">@@ -61,11 +71,34 @@ def make_pass_decorator(object_type: t.Type[T], ensure: bool=False</span>
<span class="w"> </span>    :param ensure: if set to `True`, a new object will be created and
<span class="w"> </span>                   remembered on the context if it&#39;s not there yet.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def decorator(f: &quot;t.Callable[te.Concatenate[T, P], R]&quot;) -&gt; &quot;t.Callable[P, R]&quot;:</span>
<span class="gi">+        def new_func(*args: &quot;P.args&quot;, **kwargs: &quot;P.kwargs&quot;) -&gt; &quot;R&quot;:</span>
<span class="gi">+            ctx = get_current_context()</span>

<span class="gd">-def pass_meta_key(key: str, *, doc_description: t.Optional[str]=None</span>
<span class="gd">-    ) -&gt;&#39;t.Callable[[t.Callable[te.Concatenate[t.Any, P], R]], t.Callable[P, R]]&#39;:</span>
<span class="gi">+            obj: t.Optional[T]</span>
<span class="gi">+            if ensure:</span>
<span class="gi">+                obj = ctx.ensure_object(object_type)</span>
<span class="gi">+            else:</span>
<span class="gi">+                obj = ctx.find_object(object_type)</span>
<span class="gi">+</span>
<span class="gi">+            if obj is None:</span>
<span class="gi">+                raise RuntimeError(</span>
<span class="gi">+                    &quot;Managed to invoke callback without a context&quot;</span>
<span class="gi">+                    f&quot; object of type {object_type.__name__!r}&quot;</span>
<span class="gi">+                    &quot; existing.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            return ctx.invoke(f, obj, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        return update_wrapper(new_func, f)</span>
<span class="gi">+</span>
<span class="gi">+    return decorator  # type: ignore[return-value]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pass_meta_key(</span>
<span class="gi">+    key: str, *, doc_description: t.Optional[str] = None</span>
<span class="gi">+) -&gt; &quot;t.Callable[[t.Callable[te.Concatenate[t.Any, P], R]], t.Callable[P, R]]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a decorator that passes a key from
<span class="w"> </span>    :attr:`click.Context.meta` as the first argument to the decorated
<span class="w"> </span>    function.
<span class="gu">@@ -77,18 +110,72 @@ def pass_meta_key(key: str, *, doc_description: t.Optional[str]=None</span>

<span class="w"> </span>    .. versionadded:: 8.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def decorator(f: &quot;t.Callable[te.Concatenate[t.Any, P], R]&quot;) -&gt; &quot;t.Callable[P, R]&quot;:</span>
<span class="gi">+        def new_func(*args: &quot;P.args&quot;, **kwargs: &quot;P.kwargs&quot;) -&gt; R:</span>
<span class="gi">+            ctx = get_current_context()</span>
<span class="gi">+            obj = ctx.meta[key]</span>
<span class="gi">+            return ctx.invoke(f, obj, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        return update_wrapper(new_func, f)</span>
<span class="gi">+</span>
<span class="gi">+    if doc_description is None:</span>
<span class="gi">+        doc_description = f&quot;the {key!r} key from :attr:`click.Context.meta`&quot;</span>

<span class="gd">-CmdType = t.TypeVar(&#39;CmdType&#39;, bound=Command)</span>
<span class="gi">+    decorator.__doc__ = (</span>
<span class="gi">+        f&quot;Decorator that passes {doc_description} as the first argument&quot;</span>
<span class="gi">+        &quot; to the decorated function.&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    return decorator  # type: ignore[return-value]</span>


<span class="gd">-def command(name: t.Union[t.Optional[str], _AnyCallable]=None, cls: t.</span>
<span class="gd">-    Optional[t.Type[CmdType]]=None, **attrs: t.Any) -&gt;t.Union[Command, t.</span>
<span class="gd">-    Callable[[_AnyCallable], t.Union[Command, CmdType]]]:</span>
<span class="gd">-    &quot;&quot;&quot;Creates a new :class:`Command` and uses the decorated function as</span>
<span class="gi">+CmdType = t.TypeVar(&quot;CmdType&quot;, bound=Command)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# variant: no call, directly as decorator for a function.</span>
<span class="gi">+@t.overload</span>
<span class="gi">+def command(name: _AnyCallable) -&gt; Command:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# variant: with positional name and with positional or keyword cls argument:</span>
<span class="gi">+# @command(namearg, CommandCls, ...) or @command(namearg, cls=CommandCls, ...)</span>
<span class="gi">+@t.overload</span>
<span class="gi">+def command(</span>
<span class="gi">+    name: t.Optional[str],</span>
<span class="gi">+    cls: t.Type[CmdType],</span>
<span class="gi">+    **attrs: t.Any,</span>
<span class="gi">+) -&gt; t.Callable[[_AnyCallable], CmdType]:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# variant: name omitted, cls _must_ be a keyword argument, @command(cls=CommandCls, ...)</span>
<span class="gi">+@t.overload</span>
<span class="gi">+def command(</span>
<span class="gi">+    name: None = None,</span>
<span class="gi">+    *,</span>
<span class="gi">+    cls: t.Type[CmdType],</span>
<span class="gi">+    **attrs: t.Any,</span>
<span class="gi">+) -&gt; t.Callable[[_AnyCallable], CmdType]:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# variant: with optional string name, no cls argument provided.</span>
<span class="gi">+@t.overload</span>
<span class="gi">+def command(</span>
<span class="gi">+    name: t.Optional[str] = ..., cls: None = None, **attrs: t.Any</span>
<span class="gi">+) -&gt; t.Callable[[_AnyCallable], Command]:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def command(</span>
<span class="gi">+    name: t.Union[t.Optional[str], _AnyCallable] = None,</span>
<span class="gi">+    cls: t.Optional[t.Type[CmdType]] = None,</span>
<span class="gi">+    **attrs: t.Any,</span>
<span class="gi">+) -&gt; t.Union[Command, t.Callable[[_AnyCallable], t.Union[Command, CmdType]]]:</span>
<span class="gi">+    r&quot;&quot;&quot;Creates a new :class:`Command` and uses the decorated function as</span>
<span class="w"> </span>    callback.  This will also automatically attach all decorated
<span class="gd">-    :func:`option`\\s and :func:`argument`\\s as parameters to the command.</span>
<span class="gi">+    :func:`option`\s and :func:`argument`\s as parameters to the command.</span>

<span class="w"> </span>    The name of the command defaults to the name of the function with
<span class="w"> </span>    underscores replaced by dashes.  If you want to change that, you can
<span class="gu">@@ -114,15 +201,99 @@ def command(name: t.Union[t.Optional[str], _AnyCallable]=None, cls: t.</span>
<span class="w"> </span>        The ``params`` argument can be used. Decorated params are
<span class="w"> </span>        appended to the end of the list.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    func: t.Optional[t.Callable[[_AnyCallable], t.Any]] = None</span>
<span class="gi">+</span>
<span class="gi">+    if callable(name):</span>
<span class="gi">+        func = name</span>
<span class="gi">+        name = None</span>
<span class="gi">+        assert cls is None, &quot;Use &#39;command(cls=cls)(callable)&#39; to specify a class.&quot;</span>
<span class="gi">+        assert not attrs, &quot;Use &#39;command(**kwargs)(callable)&#39; to provide arguments.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if cls is None:</span>
<span class="gi">+        cls = t.cast(t.Type[CmdType], Command)</span>
<span class="gi">+</span>
<span class="gi">+    def decorator(f: _AnyCallable) -&gt; CmdType:</span>
<span class="gi">+        if isinstance(f, Command):</span>
<span class="gi">+            raise TypeError(&quot;Attempted to convert a callback into a command twice.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        attr_params = attrs.pop(&quot;params&quot;, None)</span>
<span class="gi">+        params = attr_params if attr_params is not None else []</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            decorator_params = f.__click_params__  # type: ignore</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            del f.__click_params__  # type: ignore</span>
<span class="gi">+            params.extend(reversed(decorator_params))</span>
<span class="gi">+</span>
<span class="gi">+        if attrs.get(&quot;help&quot;) is None:</span>
<span class="gi">+            attrs[&quot;help&quot;] = f.__doc__</span>

<span class="gd">-GrpType = t.TypeVar(&#39;GrpType&#39;, bound=Group)</span>
<span class="gi">+        if t.TYPE_CHECKING:</span>
<span class="gi">+            assert cls is not None</span>
<span class="gi">+            assert not callable(name)</span>

<span class="gi">+        cmd = cls(</span>
<span class="gi">+            name=name or f.__name__.lower().replace(&quot;_&quot;, &quot;-&quot;),</span>
<span class="gi">+            callback=f,</span>
<span class="gi">+            params=params,</span>
<span class="gi">+            **attrs,</span>
<span class="gi">+        )</span>
<span class="gi">+        cmd.__doc__ = f.__doc__</span>
<span class="gi">+        return cmd</span>

<span class="gd">-def group(name: t.Union[str, _AnyCallable, None]=None, cls: t.Optional[t.</span>
<span class="gd">-    Type[GrpType]]=None, **attrs: t.Any) -&gt;t.Union[Group, t.Callable[[</span>
<span class="gd">-    _AnyCallable], t.Union[Group, GrpType]]]:</span>
<span class="gi">+    if func is not None:</span>
<span class="gi">+        return decorator(func)</span>
<span class="gi">+</span>
<span class="gi">+    return decorator</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+GrpType = t.TypeVar(&quot;GrpType&quot;, bound=Group)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# variant: no call, directly as decorator for a function.</span>
<span class="gi">+@t.overload</span>
<span class="gi">+def group(name: _AnyCallable) -&gt; Group:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# variant: with positional name and with positional or keyword cls argument:</span>
<span class="gi">+# @group(namearg, GroupCls, ...) or @group(namearg, cls=GroupCls, ...)</span>
<span class="gi">+@t.overload</span>
<span class="gi">+def group(</span>
<span class="gi">+    name: t.Optional[str],</span>
<span class="gi">+    cls: t.Type[GrpType],</span>
<span class="gi">+    **attrs: t.Any,</span>
<span class="gi">+) -&gt; t.Callable[[_AnyCallable], GrpType]:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# variant: name omitted, cls _must_ be a keyword argument, @group(cmd=GroupCls, ...)</span>
<span class="gi">+@t.overload</span>
<span class="gi">+def group(</span>
<span class="gi">+    name: None = None,</span>
<span class="gi">+    *,</span>
<span class="gi">+    cls: t.Type[GrpType],</span>
<span class="gi">+    **attrs: t.Any,</span>
<span class="gi">+) -&gt; t.Callable[[_AnyCallable], GrpType]:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# variant: with optional string name, no cls argument provided.</span>
<span class="gi">+@t.overload</span>
<span class="gi">+def group(</span>
<span class="gi">+    name: t.Optional[str] = ..., cls: None = None, **attrs: t.Any</span>
<span class="gi">+) -&gt; t.Callable[[_AnyCallable], Group]:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def group(</span>
<span class="gi">+    name: t.Union[str, _AnyCallable, None] = None,</span>
<span class="gi">+    cls: t.Optional[t.Type[GrpType]] = None,</span>
<span class="gi">+    **attrs: t.Any,</span>
<span class="gi">+) -&gt; t.Union[Group, t.Callable[[_AnyCallable], t.Union[Group, GrpType]]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Creates a new :class:`Group` with a function as callback.  This
<span class="w"> </span>    works otherwise the same as :func:`command` just that the `cls`
<span class="w"> </span>    parameter is set to :class:`Group`.
<span class="gu">@@ -130,11 +301,28 @@ def group(name: t.Union[str, _AnyCallable, None]=None, cls: t.Optional[t.</span>
<span class="w"> </span>    .. versionchanged:: 8.1
<span class="w"> </span>        This decorator can be applied without parentheses.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cls is None:</span>
<span class="gi">+        cls = t.cast(t.Type[GrpType], Group)</span>
<span class="gi">+</span>
<span class="gi">+    if callable(name):</span>
<span class="gi">+        return command(cls=cls, **attrs)(name)</span>
<span class="gi">+</span>
<span class="gi">+    return command(name, cls, **attrs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _param_memo(f: t.Callable[..., t.Any], param: Parameter) -&gt; None:</span>
<span class="gi">+    if isinstance(f, Command):</span>
<span class="gi">+        f.params.append(param)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if not hasattr(f, &quot;__click_params__&quot;):</span>
<span class="gi">+            f.__click_params__ = []  # type: ignore</span>

<span class="gi">+        f.__click_params__.append(param)  # type: ignore</span>

<span class="gd">-def argument(*param_decls: str, cls: t.Optional[t.Type[Argument]]=None, **</span>
<span class="gd">-    attrs: t.Any) -&gt;t.Callable[[FC], FC]:</span>
<span class="gi">+</span>
<span class="gi">+def argument(</span>
<span class="gi">+    *param_decls: str, cls: t.Optional[t.Type[Argument]] = None, **attrs: t.Any</span>
<span class="gi">+) -&gt; t.Callable[[FC], FC]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Attaches an argument to the command.  All positional arguments are
<span class="w"> </span>    passed as parameter declarations to :class:`Argument`; all keyword
<span class="w"> </span>    arguments are forwarded unchanged (except ``cls``).
<span class="gu">@@ -150,11 +338,19 @@ def argument(*param_decls: str, cls: t.Optional[t.Type[Argument]]=None, **</span>
<span class="w"> </span>        ``cls``.
<span class="w"> </span>    :param attrs: Passed as keyword arguments to the constructor of ``cls``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cls is None:</span>
<span class="gi">+        cls = Argument</span>
<span class="gi">+</span>
<span class="gi">+    def decorator(f: FC) -&gt; FC:</span>
<span class="gi">+        _param_memo(f, cls(param_decls, **attrs))</span>
<span class="gi">+        return f</span>

<span class="gi">+    return decorator</span>

<span class="gd">-def option(*param_decls: str, cls: t.Optional[t.Type[Option]]=None, **attrs:</span>
<span class="gd">-    t.Any) -&gt;t.Callable[[FC], FC]:</span>
<span class="gi">+</span>
<span class="gi">+def option(</span>
<span class="gi">+    *param_decls: str, cls: t.Optional[t.Type[Option]] = None, **attrs: t.Any</span>
<span class="gi">+) -&gt; t.Callable[[FC], FC]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Attaches an option to the command.  All positional arguments are
<span class="w"> </span>    passed as parameter declarations to :class:`Option`; all keyword
<span class="w"> </span>    arguments are forwarded unchanged (except ``cls``).
<span class="gu">@@ -170,11 +366,17 @@ def option(*param_decls: str, cls: t.Optional[t.Type[Option]]=None, **attrs:</span>
<span class="w"> </span>        ``cls``.
<span class="w"> </span>    :param attrs: Passed as keyword arguments to the constructor of ``cls``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cls is None:</span>
<span class="gi">+        cls = Option</span>
<span class="gi">+</span>
<span class="gi">+    def decorator(f: FC) -&gt; FC:</span>
<span class="gi">+        _param_memo(f, cls(param_decls, **attrs))</span>
<span class="gi">+        return f</span>

<span class="gi">+    return decorator</span>

<span class="gd">-def confirmation_option(*param_decls: str, **kwargs: t.Any) -&gt;t.Callable[[</span>
<span class="gd">-    FC], FC]:</span>
<span class="gi">+</span>
<span class="gi">+def confirmation_option(*param_decls: str, **kwargs: t.Any) -&gt; t.Callable[[FC], FC]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Add a ``--yes`` option which shows a prompt before continuing if
<span class="w"> </span>    not passed. If the prompt is declined, the program will exit.

<span class="gu">@@ -182,10 +384,23 @@ def confirmation_option(*param_decls: str, **kwargs: t.Any) -&gt;t.Callable[[</span>
<span class="w"> </span>        value ``&quot;--yes&quot;``.
<span class="w"> </span>    :param kwargs: Extra arguments are passed to :func:`option`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def callback(ctx: Context, param: Parameter, value: bool) -&gt; None:</span>
<span class="gi">+        if not value:</span>
<span class="gi">+            ctx.abort()</span>
<span class="gi">+</span>
<span class="gi">+    if not param_decls:</span>
<span class="gi">+        param_decls = (&quot;--yes&quot;,)</span>
<span class="gi">+</span>
<span class="gi">+    kwargs.setdefault(&quot;is_flag&quot;, True)</span>
<span class="gi">+    kwargs.setdefault(&quot;callback&quot;, callback)</span>
<span class="gi">+    kwargs.setdefault(&quot;expose_value&quot;, False)</span>
<span class="gi">+    kwargs.setdefault(&quot;prompt&quot;, &quot;Do you want to continue?&quot;)</span>
<span class="gi">+    kwargs.setdefault(&quot;help&quot;, &quot;Confirm the action without prompting.&quot;)</span>
<span class="gi">+    return option(*param_decls, **kwargs)</span>


<span class="gd">-def password_option(*param_decls: str, **kwargs: t.Any) -&gt;t.Callable[[FC], FC]:</span>
<span class="gi">+def password_option(*param_decls: str, **kwargs: t.Any) -&gt; t.Callable[[FC], FC]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Add a ``--password`` option which prompts for a password, hiding
<span class="w"> </span>    input and asking to enter the value again for confirmation.

<span class="gu">@@ -193,12 +408,23 @@ def password_option(*param_decls: str, **kwargs: t.Any) -&gt;t.Callable[[FC], FC]:</span>
<span class="w"> </span>        value ``&quot;--password&quot;``.
<span class="w"> </span>    :param kwargs: Extra arguments are passed to :func:`option`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def version_option(version: t.Optional[str]=None, *param_decls: str,</span>
<span class="gd">-    package_name: t.Optional[str]=None, prog_name: t.Optional[str]=None,</span>
<span class="gd">-    message: t.Optional[str]=None, **kwargs: t.Any) -&gt;t.Callable[[FC], FC]:</span>
<span class="gi">+    if not param_decls:</span>
<span class="gi">+        param_decls = (&quot;--password&quot;,)</span>
<span class="gi">+</span>
<span class="gi">+    kwargs.setdefault(&quot;prompt&quot;, True)</span>
<span class="gi">+    kwargs.setdefault(&quot;confirmation_prompt&quot;, True)</span>
<span class="gi">+    kwargs.setdefault(&quot;hide_input&quot;, True)</span>
<span class="gi">+    return option(*param_decls, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def version_option(</span>
<span class="gi">+    version: t.Optional[str] = None,</span>
<span class="gi">+    *param_decls: str,</span>
<span class="gi">+    package_name: t.Optional[str] = None,</span>
<span class="gi">+    prog_name: t.Optional[str] = None,</span>
<span class="gi">+    message: t.Optional[str] = None,</span>
<span class="gi">+    **kwargs: t.Any,</span>
<span class="gi">+) -&gt; t.Callable[[FC], FC]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Add a ``--version`` option which immediately prints the version
<span class="w"> </span>    number and exits the program.

<span class="gu">@@ -235,10 +461,76 @@ def version_option(version: t.Optional[str]=None, *param_decls: str,</span>
<span class="w"> </span>        point name. The Python package name must match the installed
<span class="w"> </span>        package name, or be passed with ``package_name=``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def help_option(*param_decls: str, **kwargs: t.Any) -&gt;t.Callable[[FC], FC]:</span>
<span class="gi">+    if message is None:</span>
<span class="gi">+        message = _(&quot;%(prog)s, version %(version)s&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if version is None and package_name is None:</span>
<span class="gi">+        frame = inspect.currentframe()</span>
<span class="gi">+        f_back = frame.f_back if frame is not None else None</span>
<span class="gi">+        f_globals = f_back.f_globals if f_back is not None else None</span>
<span class="gi">+        # break reference cycle</span>
<span class="gi">+        # https://docs.python.org/3/library/inspect.html#the-interpreter-stack</span>
<span class="gi">+        del frame</span>
<span class="gi">+</span>
<span class="gi">+        if f_globals is not None:</span>
<span class="gi">+            package_name = f_globals.get(&quot;__name__&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if package_name == &quot;__main__&quot;:</span>
<span class="gi">+                package_name = f_globals.get(&quot;__package__&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if package_name:</span>
<span class="gi">+                package_name = package_name.partition(&quot;.&quot;)[0]</span>
<span class="gi">+</span>
<span class="gi">+    def callback(ctx: Context, param: Parameter, value: bool) -&gt; None:</span>
<span class="gi">+        if not value or ctx.resilient_parsing:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        nonlocal prog_name</span>
<span class="gi">+        nonlocal version</span>
<span class="gi">+</span>
<span class="gi">+        if prog_name is None:</span>
<span class="gi">+            prog_name = ctx.find_root().info_name</span>
<span class="gi">+</span>
<span class="gi">+        if version is None and package_name is not None:</span>
<span class="gi">+            metadata: t.Optional[types.ModuleType]</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                from importlib import metadata  # type: ignore</span>
<span class="gi">+            except ImportError:</span>
<span class="gi">+                # Python &lt; 3.8</span>
<span class="gi">+                import importlib_metadata as metadata  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                version = metadata.version(package_name)  # type: ignore</span>
<span class="gi">+            except metadata.PackageNotFoundError:  # type: ignore</span>
<span class="gi">+                raise RuntimeError(</span>
<span class="gi">+                    f&quot;{package_name!r} is not installed. Try passing&quot;</span>
<span class="gi">+                    &quot; &#39;package_name&#39; instead.&quot;</span>
<span class="gi">+                ) from None</span>
<span class="gi">+</span>
<span class="gi">+        if version is None:</span>
<span class="gi">+            raise RuntimeError(</span>
<span class="gi">+                f&quot;Could not determine the version for {package_name!r} automatically.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        echo(</span>
<span class="gi">+            message % {&quot;prog&quot;: prog_name, &quot;package&quot;: package_name, &quot;version&quot;: version},</span>
<span class="gi">+            color=ctx.color,</span>
<span class="gi">+        )</span>
<span class="gi">+        ctx.exit()</span>
<span class="gi">+</span>
<span class="gi">+    if not param_decls:</span>
<span class="gi">+        param_decls = (&quot;--version&quot;,)</span>
<span class="gi">+</span>
<span class="gi">+    kwargs.setdefault(&quot;is_flag&quot;, True)</span>
<span class="gi">+    kwargs.setdefault(&quot;expose_value&quot;, False)</span>
<span class="gi">+    kwargs.setdefault(&quot;is_eager&quot;, True)</span>
<span class="gi">+    kwargs.setdefault(&quot;help&quot;, _(&quot;Show the version and exit.&quot;))</span>
<span class="gi">+    kwargs[&quot;callback&quot;] = callback</span>
<span class="gi">+    return option(*param_decls, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def help_option(*param_decls: str, **kwargs: t.Any) -&gt; t.Callable[[FC], FC]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Add a ``--help`` option which immediately prints the help page
<span class="w"> </span>    and exits the program.

<span class="gu">@@ -250,4 +542,20 @@ def help_option(*param_decls: str, **kwargs: t.Any) -&gt;t.Callable[[FC], FC]:</span>
<span class="w"> </span>        value ``&quot;--help&quot;``.
<span class="w"> </span>    :param kwargs: Extra arguments are passed to :func:`option`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def callback(ctx: Context, param: Parameter, value: bool) -&gt; None:</span>
<span class="gi">+        if not value or ctx.resilient_parsing:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        echo(ctx.get_help(), color=ctx.color)</span>
<span class="gi">+        ctx.exit()</span>
<span class="gi">+</span>
<span class="gi">+    if not param_decls:</span>
<span class="gi">+        param_decls = (&quot;--help&quot;,)</span>
<span class="gi">+</span>
<span class="gi">+    kwargs.setdefault(&quot;is_flag&quot;, True)</span>
<span class="gi">+    kwargs.setdefault(&quot;expose_value&quot;, False)</span>
<span class="gi">+    kwargs.setdefault(&quot;is_eager&quot;, True)</span>
<span class="gi">+    kwargs.setdefault(&quot;help&quot;, _(&quot;Show this message and exit.&quot;))</span>
<span class="gi">+    kwargs[&quot;callback&quot;] = callback</span>
<span class="gi">+    return option(*param_decls, **kwargs)</span>
<span class="gh">diff --git a/src/click/exceptions.py b/src/click/exceptions.py</span>
<span class="gh">index 3ce2a80..fe68a36 100644</span>
<span class="gd">--- a/src/click/exceptions.py</span>
<span class="gi">+++ b/src/click/exceptions.py</span>
<span class="gu">@@ -1,26 +1,48 @@</span>
<span class="w"> </span>import typing as t
<span class="w"> </span>from gettext import gettext as _
<span class="w"> </span>from gettext import ngettext
<span class="gi">+</span>
<span class="w"> </span>from ._compat import get_text_stderr
<span class="w"> </span>from .utils import echo
<span class="w"> </span>from .utils import format_filename
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    from .core import Command
<span class="w"> </span>    from .core import Context
<span class="w"> </span>    from .core import Parameter


<span class="gi">+def _join_param_hints(</span>
<span class="gi">+    param_hint: t.Optional[t.Union[t.Sequence[str], str]]</span>
<span class="gi">+) -&gt; t.Optional[str]:</span>
<span class="gi">+    if param_hint is not None and not isinstance(param_hint, str):</span>
<span class="gi">+        return &quot; / &quot;.join(repr(x) for x in param_hint)</span>
<span class="gi">+</span>
<span class="gi">+    return param_hint</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class ClickException(Exception):
<span class="w"> </span>    &quot;&quot;&quot;An exception that Click can handle and show to the user.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    #: The exit code for this exception.</span>
<span class="w"> </span>    exit_code = 1

<span class="gd">-    def __init__(self, message: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str) -&gt; None:</span>
<span class="w"> </span>        super().__init__(message)
<span class="w"> </span>        self.message = message

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def format_message(self) -&gt; str:</span>
<span class="w"> </span>        return self.message

<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return self.message</span>
<span class="gi">+</span>
<span class="gi">+    def show(self, file: t.Optional[t.IO[t.Any]] = None) -&gt; None:</span>
<span class="gi">+        if file is None:</span>
<span class="gi">+            file = get_text_stderr()</span>
<span class="gi">+</span>
<span class="gi">+        echo(_(&quot;Error: {message}&quot;).format(message=self.format_message()), file=file)</span>
<span class="gi">+</span>

<span class="w"> </span>class UsageError(ClickException):
<span class="w"> </span>    &quot;&quot;&quot;An internal exception that signals a usage error.  This typically
<span class="gu">@@ -30,13 +52,35 @@ class UsageError(ClickException):</span>
<span class="w"> </span>    :param ctx: optionally the context that caused this error.  Click will
<span class="w"> </span>                fill in the context automatically in some situations.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    exit_code = 2

<span class="gd">-    def __init__(self, message: str, ctx: t.Optional[&#39;Context&#39;]=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str, ctx: t.Optional[&quot;Context&quot;] = None) -&gt; None:</span>
<span class="w"> </span>        super().__init__(message)
<span class="w"> </span>        self.ctx = ctx
<span class="gd">-        self.cmd: t.Optional[&#39;Command&#39;</span>
<span class="gd">-            ] = self.ctx.command if self.ctx else None</span>
<span class="gi">+        self.cmd: t.Optional[&quot;Command&quot;] = self.ctx.command if self.ctx else None</span>
<span class="gi">+</span>
<span class="gi">+    def show(self, file: t.Optional[t.IO[t.Any]] = None) -&gt; None:</span>
<span class="gi">+        if file is None:</span>
<span class="gi">+            file = get_text_stderr()</span>
<span class="gi">+        color = None</span>
<span class="gi">+        hint = &quot;&quot;</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.ctx is not None</span>
<span class="gi">+            and self.ctx.command.get_help_option(self.ctx) is not None</span>
<span class="gi">+        ):</span>
<span class="gi">+            hint = _(&quot;Try &#39;{command} {option}&#39; for help.&quot;).format(</span>
<span class="gi">+                command=self.ctx.command_path, option=self.ctx.help_option_names[0]</span>
<span class="gi">+            )</span>
<span class="gi">+            hint = f&quot;{hint}\n&quot;</span>
<span class="gi">+        if self.ctx is not None:</span>
<span class="gi">+            color = self.ctx.color</span>
<span class="gi">+            echo(f&quot;{self.ctx.get_usage()}\n{hint}&quot;, file=file, color=color)</span>
<span class="gi">+        echo(</span>
<span class="gi">+            _(&quot;Error: {message}&quot;).format(message=self.format_message()),</span>
<span class="gi">+            file=file,</span>
<span class="gi">+            color=color,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class BadParameter(UsageError):
<span class="gu">@@ -57,12 +101,29 @@ class BadParameter(UsageError):</span>
<span class="w"> </span>                       each item is quoted and separated.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str, ctx: t.Optional[&#39;Context&#39;]=None, param:</span>
<span class="gd">-        t.Optional[&#39;Parameter&#39;]=None, param_hint: t.Optional[str]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        message: str,</span>
<span class="gi">+        ctx: t.Optional[&quot;Context&quot;] = None,</span>
<span class="gi">+        param: t.Optional[&quot;Parameter&quot;] = None,</span>
<span class="gi">+        param_hint: t.Optional[str] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(message, ctx)
<span class="w"> </span>        self.param = param
<span class="w"> </span>        self.param_hint = param_hint

<span class="gi">+    def format_message(self) -&gt; str:</span>
<span class="gi">+        if self.param_hint is not None:</span>
<span class="gi">+            param_hint = self.param_hint</span>
<span class="gi">+        elif self.param is not None:</span>
<span class="gi">+            param_hint = self.param.get_error_hint(self.ctx)  # type: ignore</span>
<span class="gi">+        else:</span>
<span class="gi">+            return _(&quot;Invalid value: {message}&quot;).format(message=self.message)</span>
<span class="gi">+</span>
<span class="gi">+        return _(&quot;Invalid value for {param_hint}: {message}&quot;).format(</span>
<span class="gi">+            param_hint=_join_param_hints(param_hint), message=self.message</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="w"> </span>class MissingParameter(BadParameter):
<span class="w"> </span>    &quot;&quot;&quot;Raised if click required an option or argument but it was not
<span class="gu">@@ -76,17 +137,59 @@ class MissingParameter(BadParameter):</span>
<span class="w"> </span>                       ``&#39;option&#39;`` or ``&#39;argument&#39;``.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: t.Optional[str]=None, ctx: t.Optional[</span>
<span class="gd">-        &#39;Context&#39;]=None, param: t.Optional[&#39;Parameter&#39;]=None, param_hint: t</span>
<span class="gd">-        .Optional[str]=None, param_type: t.Optional[str]=None) -&gt;None:</span>
<span class="gd">-        super().__init__(message or &#39;&#39;, ctx, param, param_hint)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        message: t.Optional[str] = None,</span>
<span class="gi">+        ctx: t.Optional[&quot;Context&quot;] = None,</span>
<span class="gi">+        param: t.Optional[&quot;Parameter&quot;] = None,</span>
<span class="gi">+        param_hint: t.Optional[str] = None,</span>
<span class="gi">+        param_type: t.Optional[str] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        super().__init__(message or &quot;&quot;, ctx, param, param_hint)</span>
<span class="w"> </span>        self.param_type = param_type

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def format_message(self) -&gt; str:</span>
<span class="gi">+        if self.param_hint is not None:</span>
<span class="gi">+            param_hint: t.Optional[str] = self.param_hint</span>
<span class="gi">+        elif self.param is not None:</span>
<span class="gi">+            param_hint = self.param.get_error_hint(self.ctx)  # type: ignore</span>
<span class="gi">+        else:</span>
<span class="gi">+            param_hint = None</span>
<span class="gi">+</span>
<span class="gi">+        param_hint = _join_param_hints(param_hint)</span>
<span class="gi">+        param_hint = f&quot; {param_hint}&quot; if param_hint else &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        param_type = self.param_type</span>
<span class="gi">+        if param_type is None and self.param is not None:</span>
<span class="gi">+            param_type = self.param.param_type_name</span>
<span class="gi">+</span>
<span class="gi">+        msg = self.message</span>
<span class="gi">+        if self.param is not None:</span>
<span class="gi">+            msg_extra = self.param.type.get_missing_message(self.param)</span>
<span class="gi">+            if msg_extra:</span>
<span class="gi">+                if msg:</span>
<span class="gi">+                    msg += f&quot;. {msg_extra}&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    msg = msg_extra</span>
<span class="gi">+</span>
<span class="gi">+        msg = f&quot; {msg}&quot; if msg else &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Translate param_type for known types.</span>
<span class="gi">+        if param_type == &quot;argument&quot;:</span>
<span class="gi">+            missing = _(&quot;Missing argument&quot;)</span>
<span class="gi">+        elif param_type == &quot;option&quot;:</span>
<span class="gi">+            missing = _(&quot;Missing option&quot;)</span>
<span class="gi">+        elif param_type == &quot;parameter&quot;:</span>
<span class="gi">+            missing = _(&quot;Missing parameter&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            missing = _(&quot;Missing {param_type}&quot;).format(param_type=param_type)</span>
<span class="gi">+</span>
<span class="gi">+        return f&quot;{missing}{param_hint}.{msg}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        if not self.message:
<span class="w"> </span>            param_name = self.param.name if self.param else None
<span class="gd">-            return _(&#39;Missing parameter: {param_name}&#39;).format(param_name=</span>
<span class="gd">-                param_name)</span>
<span class="gi">+            return _(&quot;Missing parameter: {param_name}&quot;).format(param_name=param_name)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            return self.message

<span class="gu">@@ -98,15 +201,32 @@ class NoSuchOption(UsageError):</span>
<span class="w"> </span>    .. versionadded:: 4.0
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, option_name: str, message: t.Optional[str]=None,</span>
<span class="gd">-        possibilities: t.Optional[t.Sequence[str]]=None, ctx: t.Optional[</span>
<span class="gd">-        &#39;Context&#39;]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        option_name: str,</span>
<span class="gi">+        message: t.Optional[str] = None,</span>
<span class="gi">+        possibilities: t.Optional[t.Sequence[str]] = None,</span>
<span class="gi">+        ctx: t.Optional[&quot;Context&quot;] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if message is None:
<span class="gd">-            message = _(&#39;No such option: {name}&#39;).format(name=option_name)</span>
<span class="gi">+            message = _(&quot;No such option: {name}&quot;).format(name=option_name)</span>
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(message, ctx)
<span class="w"> </span>        self.option_name = option_name
<span class="w"> </span>        self.possibilities = possibilities

<span class="gi">+    def format_message(self) -&gt; str:</span>
<span class="gi">+        if not self.possibilities:</span>
<span class="gi">+            return self.message</span>
<span class="gi">+</span>
<span class="gi">+        possibility_str = &quot;, &quot;.join(sorted(self.possibilities))</span>
<span class="gi">+        suggest = ngettext(</span>
<span class="gi">+            &quot;Did you mean {possibility}?&quot;,</span>
<span class="gi">+            &quot;(Possible options: {possibilities})&quot;,</span>
<span class="gi">+            len(self.possibilities),</span>
<span class="gi">+        ).format(possibility=possibility_str, possibilities=possibility_str)</span>
<span class="gi">+        return f&quot;{self.message} {suggest}&quot;</span>
<span class="gi">+</span>

<span class="w"> </span>class BadOptionUsage(UsageError):
<span class="w"> </span>    &quot;&quot;&quot;Raised if an option is generally supplied but the use of the option
<span class="gu">@@ -118,8 +238,9 @@ class BadOptionUsage(UsageError):</span>
<span class="w"> </span>    :param option_name: the name of the option being used incorrectly.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, option_name: str, message: str, ctx: t.Optional[</span>
<span class="gd">-        &#39;Context&#39;]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, option_name: str, message: str, ctx: t.Optional[&quot;Context&quot;] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(message, ctx)
<span class="w"> </span>        self.option_name = option_name

<span class="gu">@@ -136,13 +257,19 @@ class BadArgumentUsage(UsageError):</span>
<span class="w"> </span>class FileError(ClickException):
<span class="w"> </span>    &quot;&quot;&quot;Raised if a file cannot be opened.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, filename: str, hint: t.Optional[str]=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, filename: str, hint: t.Optional[str] = None) -&gt; None:</span>
<span class="w"> </span>        if hint is None:
<span class="gd">-            hint = _(&#39;unknown error&#39;)</span>
<span class="gi">+            hint = _(&quot;unknown error&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(hint)
<span class="w"> </span>        self.ui_filename: str = format_filename(filename)
<span class="w"> </span>        self.filename = filename

<span class="gi">+    def format_message(self) -&gt; str:</span>
<span class="gi">+        return _(&quot;Could not open file {filename!r}: {message}&quot;).format(</span>
<span class="gi">+            filename=self.ui_filename, message=self.message</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="w"> </span>class Abort(RuntimeError):
<span class="w"> </span>    &quot;&quot;&quot;An internal signalling exception that signals Click to abort.&quot;&quot;&quot;
<span class="gu">@@ -154,7 +281,8 @@ class Exit(RuntimeError):</span>

<span class="w"> </span>    :param code: the status code to exit with.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;exit_code&#39;,</span>

<span class="gd">-    def __init__(self, code: int=0) -&gt;None:</span>
<span class="gi">+    __slots__ = (&quot;exit_code&quot;,)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, code: int = 0) -&gt; None:</span>
<span class="w"> </span>        self.exit_code: int = code
<span class="gh">diff --git a/src/click/formatting.py b/src/click/formatting.py</span>
<span class="gh">index 2586652..ddd2a2f 100644</span>
<span class="gd">--- a/src/click/formatting.py</span>
<span class="gi">+++ b/src/click/formatting.py</span>
<span class="gu">@@ -1,13 +1,38 @@</span>
<span class="w"> </span>import typing as t
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from gettext import gettext as _
<span class="gi">+</span>
<span class="w"> </span>from ._compat import term_len
<span class="w"> </span>from .parser import split_opt
<span class="gi">+</span>
<span class="gi">+# Can force a width.  This is used by the test system</span>
<span class="w"> </span>FORCED_WIDTH: t.Optional[int] = None


<span class="gd">-def wrap_text(text: str, width: int=78, initial_indent: str=&#39;&#39;,</span>
<span class="gd">-    subsequent_indent: str=&#39;&#39;, preserve_paragraphs: bool=False) -&gt;str:</span>
<span class="gi">+def measure_table(rows: t.Iterable[t.Tuple[str, str]]) -&gt; t.Tuple[int, ...]:</span>
<span class="gi">+    widths: t.Dict[int, int] = {}</span>
<span class="gi">+</span>
<span class="gi">+    for row in rows:</span>
<span class="gi">+        for idx, col in enumerate(row):</span>
<span class="gi">+            widths[idx] = max(widths.get(idx, 0), term_len(col))</span>
<span class="gi">+</span>
<span class="gi">+    return tuple(y for x, y in sorted(widths.items()))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def iter_rows(</span>
<span class="gi">+    rows: t.Iterable[t.Tuple[str, str]], col_count: int</span>
<span class="gi">+) -&gt; t.Iterator[t.Tuple[str, ...]]:</span>
<span class="gi">+    for row in rows:</span>
<span class="gi">+        yield row + (&quot;&quot;,) * (col_count - len(row))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def wrap_text(</span>
<span class="gi">+    text: str,</span>
<span class="gi">+    width: int = 78,</span>
<span class="gi">+    initial_indent: str = &quot;&quot;,</span>
<span class="gi">+    subsequent_indent: str = &quot;&quot;,</span>
<span class="gi">+    preserve_paragraphs: bool = False,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;A helper function that intelligently wraps text.  By default, it
<span class="w"> </span>    assumes that it operates on a single paragraph of text but if the
<span class="w"> </span>    `preserve_paragraphs` parameter is provided it will intelligently
<span class="gu">@@ -26,7 +51,52 @@ def wrap_text(text: str, width: int=78, initial_indent: str=&#39;&#39;,</span>
<span class="w"> </span>    :param preserve_paragraphs: if this flag is set then the wrapping will
<span class="w"> </span>                                intelligently handle paragraphs.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ._textwrap import TextWrapper</span>
<span class="gi">+</span>
<span class="gi">+    text = text.expandtabs()</span>
<span class="gi">+    wrapper = TextWrapper(</span>
<span class="gi">+        width,</span>
<span class="gi">+        initial_indent=initial_indent,</span>
<span class="gi">+        subsequent_indent=subsequent_indent,</span>
<span class="gi">+        replace_whitespace=False,</span>
<span class="gi">+    )</span>
<span class="gi">+    if not preserve_paragraphs:</span>
<span class="gi">+        return wrapper.fill(text)</span>
<span class="gi">+</span>
<span class="gi">+    p: t.List[t.Tuple[int, bool, str]] = []</span>
<span class="gi">+    buf: t.List[str] = []</span>
<span class="gi">+    indent = None</span>
<span class="gi">+</span>
<span class="gi">+    def _flush_par() -&gt; None:</span>
<span class="gi">+        if not buf:</span>
<span class="gi">+            return</span>
<span class="gi">+        if buf[0].strip() == &quot;\b&quot;:</span>
<span class="gi">+            p.append((indent or 0, True, &quot;\n&quot;.join(buf[1:])))</span>
<span class="gi">+        else:</span>
<span class="gi">+            p.append((indent or 0, False, &quot; &quot;.join(buf)))</span>
<span class="gi">+        del buf[:]</span>
<span class="gi">+</span>
<span class="gi">+    for line in text.splitlines():</span>
<span class="gi">+        if not line:</span>
<span class="gi">+            _flush_par()</span>
<span class="gi">+            indent = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            if indent is None:</span>
<span class="gi">+                orig_len = term_len(line)</span>
<span class="gi">+                line = line.lstrip()</span>
<span class="gi">+                indent = orig_len - term_len(line)</span>
<span class="gi">+            buf.append(line)</span>
<span class="gi">+    _flush_par()</span>
<span class="gi">+</span>
<span class="gi">+    rv = []</span>
<span class="gi">+    for indent, raw, text in p:</span>
<span class="gi">+        with wrapper.extra_indent(&quot; &quot; * indent):</span>
<span class="gi">+            if raw:</span>
<span class="gi">+                rv.append(wrapper.indent_only(text))</span>
<span class="gi">+            else:</span>
<span class="gi">+                rv.append(wrapper.fill(text))</span>
<span class="gi">+</span>
<span class="gi">+    return &quot;\n\n&quot;.join(rv)</span>


<span class="w"> </span>class HelpFormatter:
<span class="gu">@@ -41,35 +111,40 @@ class HelpFormatter:</span>
<span class="w"> </span>                  width clamped to a maximum of 78.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, indent_increment: int=2, width: t.Optional[int]=None,</span>
<span class="gd">-        max_width: t.Optional[int]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        indent_increment: int = 2,</span>
<span class="gi">+        width: t.Optional[int] = None,</span>
<span class="gi">+        max_width: t.Optional[int] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        import shutil
<span class="gi">+</span>
<span class="w"> </span>        self.indent_increment = indent_increment
<span class="w"> </span>        if max_width is None:
<span class="w"> </span>            max_width = 80
<span class="w"> </span>        if width is None:
<span class="w"> </span>            width = FORCED_WIDTH
<span class="w"> </span>            if width is None:
<span class="gd">-                width = max(min(shutil.get_terminal_size().columns,</span>
<span class="gd">-                    max_width) - 2, 50)</span>
<span class="gi">+                width = max(min(shutil.get_terminal_size().columns, max_width) - 2, 50)</span>
<span class="w"> </span>        self.width = width
<span class="w"> </span>        self.current_indent = 0
<span class="w"> </span>        self.buffer: t.List[str] = []

<span class="gd">-    def write(self, string: str) -&gt;None:</span>
<span class="gi">+    def write(self, string: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Writes a unicode string into the internal buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.buffer.append(string)</span>

<span class="gd">-    def indent(self) -&gt;None:</span>
<span class="gi">+    def indent(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Increases the indentation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.current_indent += self.indent_increment</span>

<span class="gd">-    def dedent(self) -&gt;None:</span>
<span class="gi">+    def dedent(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Decreases the indentation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.current_indent -= self.indent_increment</span>

<span class="gd">-    def write_usage(self, prog: str, args: str=&#39;&#39;, prefix: t.Optional[str]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def write_usage(</span>
<span class="gi">+        self, prog: str, args: str = &quot;&quot;, prefix: t.Optional[str] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Writes a usage line into the buffer.

<span class="w"> </span>        :param prog: the program name.
<span class="gu">@@ -77,24 +152,67 @@ class HelpFormatter:</span>
<span class="w"> </span>        :param prefix: The prefix for the first line. Defaults to
<span class="w"> </span>            ``&quot;Usage: &quot;``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if prefix is None:</span>
<span class="gi">+            prefix = f&quot;{_(&#39;Usage:&#39;)} &quot;</span>
<span class="gi">+</span>
<span class="gi">+        usage_prefix = f&quot;{prefix:&gt;{self.current_indent}}{prog} &quot;</span>
<span class="gi">+        text_width = self.width - self.current_indent</span>
<span class="gi">+</span>
<span class="gi">+        if text_width &gt;= (term_len(usage_prefix) + 20):</span>
<span class="gi">+            # The arguments will fit to the right of the prefix.</span>
<span class="gi">+            indent = &quot; &quot; * term_len(usage_prefix)</span>
<span class="gi">+            self.write(</span>
<span class="gi">+                wrap_text(</span>
<span class="gi">+                    args,</span>
<span class="gi">+                    text_width,</span>
<span class="gi">+                    initial_indent=usage_prefix,</span>
<span class="gi">+                    subsequent_indent=indent,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            # The prefix is too long, put the arguments on the next line.</span>
<span class="gi">+            self.write(usage_prefix)</span>
<span class="gi">+            self.write(&quot;\n&quot;)</span>
<span class="gi">+            indent = &quot; &quot; * (max(self.current_indent, term_len(prefix)) + 4)</span>
<span class="gi">+            self.write(</span>
<span class="gi">+                wrap_text(</span>
<span class="gi">+                    args, text_width, initial_indent=indent, subsequent_indent=indent</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        self.write(&quot;\n&quot;)</span>

<span class="gd">-    def write_heading(self, heading: str) -&gt;None:</span>
<span class="gi">+    def write_heading(self, heading: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Writes a heading into the buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write(f&quot;{&#39;&#39;:&gt;{self.current_indent}}{heading}:\n&quot;)</span>

<span class="gd">-    def write_paragraph(self) -&gt;None:</span>
<span class="gi">+    def write_paragraph(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Writes a paragraph into the buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.buffer:</span>
<span class="gi">+            self.write(&quot;\n&quot;)</span>

<span class="gd">-    def write_text(self, text: str) -&gt;None:</span>
<span class="gi">+    def write_text(self, text: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Writes re-indented text into the buffer.  This rewraps and
<span class="w"> </span>        preserves paragraphs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        indent = &quot; &quot; * self.current_indent</span>
<span class="gi">+        self.write(</span>
<span class="gi">+            wrap_text(</span>
<span class="gi">+                text,</span>
<span class="gi">+                self.width,</span>
<span class="gi">+                initial_indent=indent,</span>
<span class="gi">+                subsequent_indent=indent,</span>
<span class="gi">+                preserve_paragraphs=True,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        self.write(&quot;\n&quot;)</span>

<span class="gd">-    def write_dl(self, rows: t.Sequence[t.Tuple[str, str]], col_max: int=30,</span>
<span class="gd">-        col_spacing: int=2) -&gt;None:</span>
<span class="gi">+    def write_dl(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rows: t.Sequence[t.Tuple[str, str]],</span>
<span class="gi">+        col_max: int = 30,</span>
<span class="gi">+        col_spacing: int = 2,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Writes a definition list into the buffer.  This is how options
<span class="w"> </span>        and commands are usually formatted.

<span class="gu">@@ -103,31 +221,81 @@ class HelpFormatter:</span>
<span class="w"> </span>        :param col_spacing: the number of spaces between the first and
<span class="w"> </span>                            second column.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rows = list(rows)</span>
<span class="gi">+        widths = measure_table(rows)</span>
<span class="gi">+        if len(widths) != 2:</span>
<span class="gi">+            raise TypeError(&quot;Expected two columns for definition list&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        first_col = min(widths[0], col_max) + col_spacing</span>
<span class="gi">+</span>
<span class="gi">+        for first, second in iter_rows(rows, len(widths)):</span>
<span class="gi">+            self.write(f&quot;{&#39;&#39;:&gt;{self.current_indent}}{first}&quot;)</span>
<span class="gi">+            if not second:</span>
<span class="gi">+                self.write(&quot;\n&quot;)</span>
<span class="gi">+                continue</span>
<span class="gi">+            if term_len(first) &lt;= first_col - col_spacing:</span>
<span class="gi">+                self.write(&quot; &quot; * (first_col - term_len(first)))</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.write(&quot;\n&quot;)</span>
<span class="gi">+                self.write(&quot; &quot; * (first_col + self.current_indent))</span>
<span class="gi">+</span>
<span class="gi">+            text_width = max(self.width - first_col - 2, 10)</span>
<span class="gi">+            wrapped_text = wrap_text(second, text_width, preserve_paragraphs=True)</span>
<span class="gi">+            lines = wrapped_text.splitlines()</span>
<span class="gi">+</span>
<span class="gi">+            if lines:</span>
<span class="gi">+                self.write(f&quot;{lines[0]}\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                for line in lines[1:]:</span>
<span class="gi">+                    self.write(f&quot;{&#39;&#39;:&gt;{first_col + self.current_indent}}{line}\n&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.write(&quot;\n&quot;)</span>

<span class="w"> </span>    @contextmanager
<span class="gd">-    def section(self, name: str) -&gt;t.Iterator[None]:</span>
<span class="gi">+    def section(self, name: str) -&gt; t.Iterator[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Helpful context manager that writes a paragraph, a heading,
<span class="w"> </span>        and the indents.

<span class="w"> </span>        :param name: the section name that is written as heading.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write_paragraph()</span>
<span class="gi">+        self.write_heading(name)</span>
<span class="gi">+        self.indent()</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.dedent()</span>

<span class="w"> </span>    @contextmanager
<span class="gd">-    def indentation(self) -&gt;t.Iterator[None]:</span>
<span class="gi">+    def indentation(self) -&gt; t.Iterator[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;A context manager that increases the indentation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.indent()</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.dedent()</span>

<span class="gd">-    def getvalue(self) -&gt;str:</span>
<span class="gi">+    def getvalue(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the buffer contents.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &quot;&quot;.join(self.buffer)</span>


<span class="gd">-def join_options(options: t.Sequence[str]) -&gt;t.Tuple[str, bool]:</span>
<span class="gi">+def join_options(options: t.Sequence[str]) -&gt; t.Tuple[str, bool]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Given a list of option strings this joins them in the most appropriate
<span class="w"> </span>    way and returns them in the form ``(formatted_string,
<span class="w"> </span>    any_prefix_is_slash)`` where the second item in the tuple is a flag that
<span class="w"> </span>    indicates if any of the option prefixes was a slash.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rv = []</span>
<span class="gi">+    any_prefix_is_slash = False</span>
<span class="gi">+</span>
<span class="gi">+    for opt in options:</span>
<span class="gi">+        prefix = split_opt(opt)[0]</span>
<span class="gi">+</span>
<span class="gi">+        if prefix == &quot;/&quot;:</span>
<span class="gi">+            any_prefix_is_slash = True</span>
<span class="gi">+</span>
<span class="gi">+        rv.append((len(prefix), opt))</span>
<span class="gi">+</span>
<span class="gi">+    rv.sort(key=lambda x: x[0])</span>
<span class="gi">+    return &quot;, &quot;.join(x[1] for x in rv), any_prefix_is_slash</span>
<span class="gh">diff --git a/src/click/globals.py b/src/click/globals.py</span>
<span class="gh">index ca86d44..480058f 100644</span>
<span class="gd">--- a/src/click/globals.py</span>
<span class="gi">+++ b/src/click/globals.py</span>
<span class="gu">@@ -1,12 +1,24 @@</span>
<span class="w"> </span>import typing as t
<span class="w"> </span>from threading import local
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="w"> </span>    from .core import Context
<span class="gi">+</span>
<span class="w"> </span>_local = local()


<span class="gd">-def get_current_context(silent: bool=False) -&gt;t.Optional[&#39;Context&#39;]:</span>
<span class="gi">+@t.overload</span>
<span class="gi">+def get_current_context(silent: &quot;te.Literal[False]&quot; = False) -&gt; &quot;Context&quot;:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@t.overload</span>
<span class="gi">+def get_current_context(silent: bool = ...) -&gt; t.Optional[&quot;Context&quot;]:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_current_context(silent: bool = False) -&gt; t.Optional[&quot;Context&quot;]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the current click context.  This can be used as a way to
<span class="w"> </span>    access the current context object from anywhere.  This is a more implicit
<span class="w"> </span>    alternative to the :func:`pass_context` decorator.  This function is
<span class="gu">@@ -21,22 +33,36 @@ def get_current_context(silent: bool=False) -&gt;t.Optional[&#39;Context&#39;]:</span>
<span class="w"> </span>                   is available.  The default behavior is to raise a
<span class="w"> </span>                   :exc:`RuntimeError`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return t.cast(&quot;Context&quot;, _local.stack[-1])</span>
<span class="gi">+    except (AttributeError, IndexError) as e:</span>
<span class="gi">+        if not silent:</span>
<span class="gi">+            raise RuntimeError(&quot;There is no active click context.&quot;) from e</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>


<span class="gd">-def push_context(ctx: &#39;Context&#39;) -&gt;None:</span>
<span class="gi">+def push_context(ctx: &quot;Context&quot;) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Pushes a new context to the current stack.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _local.__dict__.setdefault(&quot;stack&quot;, []).append(ctx)</span>


<span class="gd">-def pop_context() -&gt;None:</span>
<span class="gi">+def pop_context() -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Removes the top level from the stack.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _local.stack.pop()</span>


<span class="gd">-def resolve_color_default(color: t.Optional[bool]=None) -&gt;t.Optional[bool]:</span>
<span class="gi">+def resolve_color_default(color: t.Optional[bool] = None) -&gt; t.Optional[bool]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Internal helper to get the default value of the color flag.  If a
<span class="w"> </span>    value is passed it&#39;s returned unchanged, otherwise it&#39;s looked up from
<span class="w"> </span>    the current context.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if color is not None:</span>
<span class="gi">+        return color</span>
<span class="gi">+</span>
<span class="gi">+    ctx = get_current_context(silent=True)</span>
<span class="gi">+</span>
<span class="gi">+    if ctx is not None:</span>
<span class="gi">+        return ctx.color</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>
<span class="gh">diff --git a/src/click/parser.py b/src/click/parser.py</span>
<span class="gh">index 5baffed..5fa7adf 100644</span>
<span class="gd">--- a/src/click/parser.py</span>
<span class="gi">+++ b/src/click/parser.py</span>
<span class="gu">@@ -17,26 +17,38 @@ by the Python Software Foundation. This is limited to code in parser.py.</span>
<span class="w"> </span>Copyright 2001-2006 Gregory P. Ward. All rights reserved.
<span class="w"> </span>Copyright 2002-2006 Python Software Foundation. All rights reserved.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+# This code uses parts of optparse written by Gregory P. Ward and</span>
<span class="gi">+# maintained by the Python Software Foundation.</span>
<span class="gi">+# Copyright 2001-2006 Gregory P. Ward</span>
<span class="gi">+# Copyright 2002-2006 Python Software Foundation</span>
<span class="w"> </span>import typing as t
<span class="w"> </span>from collections import deque
<span class="w"> </span>from gettext import gettext as _
<span class="w"> </span>from gettext import ngettext
<span class="gi">+</span>
<span class="w"> </span>from .exceptions import BadArgumentUsage
<span class="w"> </span>from .exceptions import BadOptionUsage
<span class="w"> </span>from .exceptions import NoSuchOption
<span class="w"> </span>from .exceptions import UsageError
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="w"> </span>    from .core import Argument as CoreArgument
<span class="w"> </span>    from .core import Context
<span class="w"> </span>    from .core import Option as CoreOption
<span class="w"> </span>    from .core import Parameter as CoreParameter
<span class="gd">-V = t.TypeVar(&#39;V&#39;)</span>
<span class="gi">+</span>
<span class="gi">+V = t.TypeVar(&quot;V&quot;)</span>
<span class="gi">+</span>
<span class="gi">+# Sentinel value that indicates an option was passed as a flag without a</span>
<span class="gi">+# value but is not a flag option. Option.consume_value uses this to</span>
<span class="gi">+# prompt or use the flag_value.</span>
<span class="w"> </span>_flag_needs_value = object()


<span class="gd">-def _unpack_args(args: t.Sequence[str], nargs_spec: t.Sequence[int]) -&gt;t.Tuple[</span>
<span class="gd">-    t.Sequence[t.Union[str, t.Sequence[t.Optional[str]], None]], t.List[str]]:</span>
<span class="gi">+def _unpack_args(</span>
<span class="gi">+    args: t.Sequence[str], nargs_spec: t.Sequence[int]</span>
<span class="gi">+) -&gt; t.Tuple[t.Sequence[t.Union[str, t.Sequence[t.Optional[str]], None]], t.List[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Given an iterable of arguments and an iterable of nargs specifications,
<span class="w"> </span>    it returns a tuple with all the unpacked arguments at the first index
<span class="w"> </span>    and all remaining arguments as the second.
<span class="gu">@@ -46,10 +58,71 @@ def _unpack_args(args: t.Sequence[str], nargs_spec: t.Sequence[int]) -&gt;t.Tuple[</span>

<span class="w"> </span>    Missing items are filled with `None`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    args = deque(args)</span>
<span class="gi">+    nargs_spec = deque(nargs_spec)</span>
<span class="gi">+    rv: t.List[t.Union[str, t.Tuple[t.Optional[str], ...], None]] = []</span>
<span class="gi">+    spos: t.Optional[int] = None</span>
<span class="gi">+</span>
<span class="gi">+    def _fetch(c: &quot;te.Deque[V]&quot;) -&gt; t.Optional[V]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if spos is None:</span>
<span class="gi">+                return c.popleft()</span>
<span class="gi">+            else:</span>
<span class="gi">+                return c.pop()</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    while nargs_spec:</span>
<span class="gi">+        nargs = _fetch(nargs_spec)</span>
<span class="gi">+</span>
<span class="gi">+        if nargs is None:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if nargs == 1:</span>
<span class="gi">+            rv.append(_fetch(args))</span>
<span class="gi">+        elif nargs &gt; 1:</span>
<span class="gi">+            x = [_fetch(args) for _ in range(nargs)]</span>
<span class="gi">+</span>
<span class="gi">+            # If we&#39;re reversed, we&#39;re pulling in the arguments in reverse,</span>
<span class="gi">+            # so we need to turn them around.</span>
<span class="gi">+            if spos is not None:</span>
<span class="gi">+                x.reverse()</span>
<span class="gi">+</span>
<span class="gi">+            rv.append(tuple(x))</span>
<span class="gi">+        elif nargs &lt; 0:</span>
<span class="gi">+            if spos is not None:</span>
<span class="gi">+                raise TypeError(&quot;Cannot have two nargs &lt; 0&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            spos = len(rv)</span>
<span class="gi">+            rv.append(None)</span>

<span class="gi">+    # spos is the position of the wildcard (star).  If it&#39;s not `None`,</span>
<span class="gi">+    # we fill it with the remainder.</span>
<span class="gi">+    if spos is not None:</span>
<span class="gi">+        rv[spos] = tuple(args)</span>
<span class="gi">+        args = []</span>
<span class="gi">+        rv[spos + 1 :] = reversed(rv[spos + 1 :])</span>

<span class="gd">-def split_arg_string(string: str) -&gt;t.List[str]:</span>
<span class="gi">+    return tuple(rv), list(args)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def split_opt(opt: str) -&gt; t.Tuple[str, str]:</span>
<span class="gi">+    first = opt[:1]</span>
<span class="gi">+    if first.isalnum():</span>
<span class="gi">+        return &quot;&quot;, opt</span>
<span class="gi">+    if opt[1:2] == first:</span>
<span class="gi">+        return opt[:2], opt[2:]</span>
<span class="gi">+    return first, opt[1:]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def normalize_opt(opt: str, ctx: t.Optional[&quot;Context&quot;]) -&gt; str:</span>
<span class="gi">+    if ctx is None or ctx.token_normalize_func is None:</span>
<span class="gi">+        return opt</span>
<span class="gi">+    prefix, opt = split_opt(opt)</span>
<span class="gi">+    return f&quot;{prefix}{ctx.token_normalize_func(opt)}&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def split_arg_string(string: str) -&gt; t.List[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Split an argument string as with :func:`shlex.split`, but don&#39;t
<span class="w"> </span>    fail if the string is incomplete. Ignores a missing closing quote or
<span class="w"> </span>    incomplete escape sequence and uses the partial token as-is.
<span class="gu">@@ -64,52 +137,117 @@ def split_arg_string(string: str) -&gt;t.List[str]:</span>

<span class="w"> </span>    :param string: String to split.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import shlex</span>

<span class="gi">+    lex = shlex.shlex(string, posix=True)</span>
<span class="gi">+    lex.whitespace_split = True</span>
<span class="gi">+    lex.commenters = &quot;&quot;</span>
<span class="gi">+    out = []</span>

<span class="gd">-class Option:</span>
<span class="gi">+    try:</span>
<span class="gi">+        for token in lex:</span>
<span class="gi">+            out.append(token)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        # Raised when end-of-string is reached in an invalid state. Use</span>
<span class="gi">+        # the partial token as-is. The quote or escape character is in</span>
<span class="gi">+        # lex.state, not lex.token.</span>
<span class="gi">+        out.append(lex.token)</span>
<span class="gi">+</span>
<span class="gi">+    return out</span>

<span class="gd">-    def __init__(self, obj: &#39;CoreOption&#39;, opts: t.Sequence[str], dest: t.</span>
<span class="gd">-        Optional[str], action: t.Optional[str]=None, nargs: int=1, const: t</span>
<span class="gd">-        .Optional[t.Any]=None):</span>
<span class="gi">+</span>
<span class="gi">+class Option:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        obj: &quot;CoreOption&quot;,</span>
<span class="gi">+        opts: t.Sequence[str],</span>
<span class="gi">+        dest: t.Optional[str],</span>
<span class="gi">+        action: t.Optional[str] = None,</span>
<span class="gi">+        nargs: int = 1,</span>
<span class="gi">+        const: t.Optional[t.Any] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self._short_opts = []
<span class="w"> </span>        self._long_opts = []
<span class="w"> </span>        self.prefixes: t.Set[str] = set()
<span class="gi">+</span>
<span class="w"> </span>        for opt in opts:
<span class="w"> </span>            prefix, value = split_opt(opt)
<span class="w"> </span>            if not prefix:
<span class="gd">-                raise ValueError(f&#39;Invalid start character for option ({opt})&#39;)</span>
<span class="gi">+                raise ValueError(f&quot;Invalid start character for option ({opt})&quot;)</span>
<span class="w"> </span>            self.prefixes.add(prefix[0])
<span class="w"> </span>            if len(prefix) == 1 and len(value) == 1:
<span class="w"> </span>                self._short_opts.append(opt)
<span class="w"> </span>            else:
<span class="w"> </span>                self._long_opts.append(opt)
<span class="w"> </span>                self.prefixes.add(prefix)
<span class="gi">+</span>
<span class="w"> </span>        if action is None:
<span class="gd">-            action = &#39;store&#39;</span>
<span class="gi">+            action = &quot;store&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        self.dest = dest
<span class="w"> </span>        self.action = action
<span class="w"> </span>        self.nargs = nargs
<span class="w"> </span>        self.const = const
<span class="w"> </span>        self.obj = obj

<span class="gi">+    @property</span>
<span class="gi">+    def takes_value(self) -&gt; bool:</span>
<span class="gi">+        return self.action in (&quot;store&quot;, &quot;append&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def process(self, value: t.Any, state: &quot;ParsingState&quot;) -&gt; None:</span>
<span class="gi">+        if self.action == &quot;store&quot;:</span>
<span class="gi">+            state.opts[self.dest] = value  # type: ignore</span>
<span class="gi">+        elif self.action == &quot;store_const&quot;:</span>
<span class="gi">+            state.opts[self.dest] = self.const  # type: ignore</span>
<span class="gi">+        elif self.action == &quot;append&quot;:</span>
<span class="gi">+            state.opts.setdefault(self.dest, []).append(value)  # type: ignore</span>
<span class="gi">+        elif self.action == &quot;append_const&quot;:</span>
<span class="gi">+            state.opts.setdefault(self.dest, []).append(self.const)  # type: ignore</span>
<span class="gi">+        elif self.action == &quot;count&quot;:</span>
<span class="gi">+            state.opts[self.dest] = state.opts.get(self.dest, 0) + 1  # type: ignore</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;unknown action &#39;{self.action}&#39;&quot;)</span>
<span class="gi">+        state.order.append(self.obj)</span>

<span class="gd">-class Argument:</span>

<span class="gd">-    def __init__(self, obj: &#39;CoreArgument&#39;, dest: t.Optional[str], nargs: int=1</span>
<span class="gd">-        ):</span>
<span class="gi">+class Argument:</span>
<span class="gi">+    def __init__(self, obj: &quot;CoreArgument&quot;, dest: t.Optional[str], nargs: int = 1):</span>
<span class="w"> </span>        self.dest = dest
<span class="w"> </span>        self.nargs = nargs
<span class="w"> </span>        self.obj = obj

<span class="gi">+    def process(</span>
<span class="gi">+        self,</span>
<span class="gi">+        value: t.Union[t.Optional[str], t.Sequence[t.Optional[str]]],</span>
<span class="gi">+        state: &quot;ParsingState&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if self.nargs &gt; 1:</span>
<span class="gi">+            assert value is not None</span>
<span class="gi">+            holes = sum(1 for x in value if x is None)</span>
<span class="gi">+            if holes == len(value):</span>
<span class="gi">+                value = None</span>
<span class="gi">+            elif holes != 0:</span>
<span class="gi">+                raise BadArgumentUsage(</span>
<span class="gi">+                    _(&quot;Argument {name!r} takes {nargs} values.&quot;).format(</span>
<span class="gi">+                        name=self.dest, nargs=self.nargs</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        if self.nargs == -1 and self.obj.envvar is not None and value == ():</span>
<span class="gi">+            # Replace empty tuple with None so that a value from the</span>
<span class="gi">+            # environment may be tried.</span>
<span class="gi">+            value = None</span>
<span class="gi">+</span>
<span class="gi">+        state.opts[self.dest] = value  # type: ignore</span>
<span class="gi">+        state.order.append(self.obj)</span>

<span class="gd">-class ParsingState:</span>

<span class="gd">-    def __init__(self, rargs: t.List[str]) -&gt;None:</span>
<span class="gi">+class ParsingState:</span>
<span class="gi">+    def __init__(self, rargs: t.List[str]) -&gt; None:</span>
<span class="w"> </span>        self.opts: t.Dict[str, t.Any] = {}
<span class="w"> </span>        self.largs: t.List[str] = []
<span class="w"> </span>        self.rargs = rargs
<span class="gd">-        self.order: t.List[&#39;CoreParameter&#39;] = []</span>
<span class="gi">+        self.order: t.List[&quot;CoreParameter&quot;] = []</span>


<span class="w"> </span>class OptionParser:
<span class="gu">@@ -126,21 +264,39 @@ class OptionParser:</span>
<span class="w"> </span>                should go with.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, ctx: t.Optional[&#39;Context&#39;]=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, ctx: t.Optional[&quot;Context&quot;] = None) -&gt; None:</span>
<span class="gi">+        #: The :class:`~click.Context` for this parser.  This might be</span>
<span class="gi">+        #: `None` for some advanced use cases.</span>
<span class="w"> </span>        self.ctx = ctx
<span class="gi">+        #: This controls how the parser deals with interspersed arguments.</span>
<span class="gi">+        #: If this is set to `False`, the parser will stop on the first</span>
<span class="gi">+        #: non-option.  Click uses this to implement nested subcommands</span>
<span class="gi">+        #: safely.</span>
<span class="w"> </span>        self.allow_interspersed_args: bool = True
<span class="gi">+        #: This tells the parser how to deal with unknown options.  By</span>
<span class="gi">+        #: default it will error out (which is sensible), but there is a</span>
<span class="gi">+        #: second mode where it will ignore it and continue processing</span>
<span class="gi">+        #: after shifting all the unknown options into the resulting args.</span>
<span class="w"> </span>        self.ignore_unknown_options: bool = False
<span class="gi">+</span>
<span class="w"> </span>        if ctx is not None:
<span class="w"> </span>            self.allow_interspersed_args = ctx.allow_interspersed_args
<span class="w"> </span>            self.ignore_unknown_options = ctx.ignore_unknown_options
<span class="gi">+</span>
<span class="w"> </span>        self._short_opt: t.Dict[str, Option] = {}
<span class="w"> </span>        self._long_opt: t.Dict[str, Option] = {}
<span class="gd">-        self._opt_prefixes = {&#39;-&#39;, &#39;--&#39;}</span>
<span class="gi">+        self._opt_prefixes = {&quot;-&quot;, &quot;--&quot;}</span>
<span class="w"> </span>        self._args: t.List[Argument] = []

<span class="gd">-    def add_option(self, obj: &#39;CoreOption&#39;, opts: t.Sequence[str], dest: t.</span>
<span class="gd">-        Optional[str], action: t.Optional[str]=None, nargs: int=1, const: t</span>
<span class="gd">-        .Optional[t.Any]=None) -&gt;None:</span>
<span class="gi">+    def add_option(</span>
<span class="gi">+        self,</span>
<span class="gi">+        obj: &quot;CoreOption&quot;,</span>
<span class="gi">+        opts: t.Sequence[str],</span>
<span class="gi">+        dest: t.Optional[str],</span>
<span class="gi">+        action: t.Optional[str] = None,</span>
<span class="gi">+        nargs: int = 1,</span>
<span class="gi">+        const: t.Optional[t.Any] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds a new option named `dest` to the parser.  The destination
<span class="w"> </span>        is not inferred (unlike with optparse) and needs to be explicitly
<span class="w"> </span>        provided.  Action can be any of ``store``, ``store_const``,
<span class="gu">@@ -149,23 +305,225 @@ class OptionParser:</span>
<span class="w"> </span>        The `obj` can be used to identify the option in the order list
<span class="w"> </span>        that is returned from the parser.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_argument(self, obj: &#39;CoreArgument&#39;, dest: t.Optional[str],</span>
<span class="gd">-        nargs: int=1) -&gt;None:</span>
<span class="gi">+        opts = [normalize_opt(opt, self.ctx) for opt in opts]</span>
<span class="gi">+        option = Option(obj, opts, dest, action=action, nargs=nargs, const=const)</span>
<span class="gi">+        self._opt_prefixes.update(option.prefixes)</span>
<span class="gi">+        for opt in option._short_opts:</span>
<span class="gi">+            self._short_opt[opt] = option</span>
<span class="gi">+        for opt in option._long_opts:</span>
<span class="gi">+            self._long_opt[opt] = option</span>
<span class="gi">+</span>
<span class="gi">+    def add_argument(</span>
<span class="gi">+        self, obj: &quot;CoreArgument&quot;, dest: t.Optional[str], nargs: int = 1</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds a positional argument named `dest` to the parser.

<span class="w"> </span>        The `obj` can be used to identify the option in the order list
<span class="w"> </span>        that is returned from the parser.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._args.append(Argument(obj, dest=dest, nargs=nargs))</span>

<span class="gd">-    def parse_args(self, args: t.List[str]) -&gt;t.Tuple[t.Dict[str, t.Any], t</span>
<span class="gd">-        .List[str], t.List[&#39;CoreParameter&#39;]]:</span>
<span class="gi">+    def parse_args(</span>
<span class="gi">+        self, args: t.List[str]</span>
<span class="gi">+    ) -&gt; t.Tuple[t.Dict[str, t.Any], t.List[str], t.List[&quot;CoreParameter&quot;]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parses positional arguments and returns ``(values, args, order)``
<span class="w"> </span>        for the parsed options and arguments as well as the leftover
<span class="w"> </span>        arguments if there are any.  The order is a list of objects as they
<span class="w"> </span>        appear on the command line.  If arguments appear multiple times they
<span class="w"> </span>        will be memorized multiple times as well.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        state = ParsingState(args)</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._process_args_for_options(state)</span>
<span class="gi">+            self._process_args_for_args(state)</span>
<span class="gi">+        except UsageError:</span>
<span class="gi">+            if self.ctx is None or not self.ctx.resilient_parsing:</span>
<span class="gi">+                raise</span>
<span class="gi">+        return state.opts, state.largs, state.order</span>
<span class="gi">+</span>
<span class="gi">+    def _process_args_for_args(self, state: ParsingState) -&gt; None:</span>
<span class="gi">+        pargs, args = _unpack_args(</span>
<span class="gi">+            state.largs + state.rargs, [x.nargs for x in self._args]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        for idx, arg in enumerate(self._args):</span>
<span class="gi">+            arg.process(pargs[idx], state)</span>
<span class="gi">+</span>
<span class="gi">+        state.largs = args</span>
<span class="gi">+        state.rargs = []</span>
<span class="gi">+</span>
<span class="gi">+    def _process_args_for_options(self, state: ParsingState) -&gt; None:</span>
<span class="gi">+        while state.rargs:</span>
<span class="gi">+            arg = state.rargs.pop(0)</span>
<span class="gi">+            arglen = len(arg)</span>
<span class="gi">+            # Double dashes always handled explicitly regardless of what</span>
<span class="gi">+            # prefixes are valid.</span>
<span class="gi">+            if arg == &quot;--&quot;:</span>
<span class="gi">+                return</span>
<span class="gi">+            elif arg[:1] in self._opt_prefixes and arglen &gt; 1:</span>
<span class="gi">+                self._process_opts(arg, state)</span>
<span class="gi">+            elif self.allow_interspersed_args:</span>
<span class="gi">+                state.largs.append(arg)</span>
<span class="gi">+            else:</span>
<span class="gi">+                state.rargs.insert(0, arg)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        # Say this is the original argument list:</span>
<span class="gi">+        # [arg0, arg1, ..., arg(i-1), arg(i), arg(i+1), ..., arg(N-1)]</span>
<span class="gi">+        #                            ^</span>
<span class="gi">+        # (we are about to process arg(i)).</span>
<span class="gi">+        #</span>
<span class="gi">+        # Then rargs is [arg(i), ..., arg(N-1)] and largs is a *subset* of</span>
<span class="gi">+        # [arg0, ..., arg(i-1)] (any options and their arguments will have</span>
<span class="gi">+        # been removed from largs).</span>
<span class="gi">+        #</span>
<span class="gi">+        # The while loop will usually consume 1 or more arguments per pass.</span>
<span class="gi">+        # If it consumes 1 (eg. arg is an option that takes no arguments),</span>
<span class="gi">+        # then after _process_arg() is done the situation is:</span>
<span class="gi">+        #</span>
<span class="gi">+        #   largs = subset of [arg0, ..., arg(i)]</span>
<span class="gi">+        #   rargs = [arg(i+1), ..., arg(N-1)]</span>
<span class="gi">+        #</span>
<span class="gi">+        # If allow_interspersed_args is false, largs will always be</span>
<span class="gi">+        # *empty* -- still a subset of [arg0, ..., arg(i-1)], but</span>
<span class="gi">+        # not a very interesting subset!</span>
<span class="gi">+</span>
<span class="gi">+    def _match_long_opt(</span>
<span class="gi">+        self, opt: str, explicit_value: t.Optional[str], state: ParsingState</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if opt not in self._long_opt:</span>
<span class="gi">+            from difflib import get_close_matches</span>
<span class="gi">+</span>
<span class="gi">+            possibilities = get_close_matches(opt, self._long_opt)</span>
<span class="gi">+            raise NoSuchOption(opt, possibilities=possibilities, ctx=self.ctx)</span>
<span class="gi">+</span>
<span class="gi">+        option = self._long_opt[opt]</span>
<span class="gi">+        if option.takes_value:</span>
<span class="gi">+            # At this point it&#39;s safe to modify rargs by injecting the</span>
<span class="gi">+            # explicit value, because no exception is raised in this</span>
<span class="gi">+            # branch.  This means that the inserted value will be fully</span>
<span class="gi">+            # consumed.</span>
<span class="gi">+            if explicit_value is not None:</span>
<span class="gi">+                state.rargs.insert(0, explicit_value)</span>
<span class="gi">+</span>
<span class="gi">+            value = self._get_value_from_state(opt, option, state)</span>
<span class="gi">+</span>
<span class="gi">+        elif explicit_value is not None:</span>
<span class="gi">+            raise BadOptionUsage(</span>
<span class="gi">+                opt, _(&quot;Option {name!r} does not take a value.&quot;).format(name=opt)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            value = None</span>
<span class="gi">+</span>
<span class="gi">+        option.process(value, state)</span>
<span class="gi">+</span>
<span class="gi">+    def _match_short_opt(self, arg: str, state: ParsingState) -&gt; None:</span>
<span class="gi">+        stop = False</span>
<span class="gi">+        i = 1</span>
<span class="gi">+        prefix = arg[0]</span>
<span class="gi">+        unknown_options = []</span>
<span class="gi">+</span>
<span class="gi">+        for ch in arg[1:]:</span>
<span class="gi">+            opt = normalize_opt(f&quot;{prefix}{ch}&quot;, self.ctx)</span>
<span class="gi">+            option = self._short_opt.get(opt)</span>
<span class="gi">+            i += 1</span>
<span class="gi">+</span>
<span class="gi">+            if not option:</span>
<span class="gi">+                if self.ignore_unknown_options:</span>
<span class="gi">+                    unknown_options.append(ch)</span>
<span class="gi">+                    continue</span>
<span class="gi">+                raise NoSuchOption(opt, ctx=self.ctx)</span>
<span class="gi">+            if option.takes_value:</span>
<span class="gi">+                # Any characters left in arg?  Pretend they&#39;re the</span>
<span class="gi">+                # next arg, and stop consuming characters of arg.</span>
<span class="gi">+                if i &lt; len(arg):</span>
<span class="gi">+                    state.rargs.insert(0, arg[i:])</span>
<span class="gi">+                    stop = True</span>
<span class="gi">+</span>
<span class="gi">+                value = self._get_value_from_state(opt, option, state)</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+                value = None</span>
<span class="gi">+</span>
<span class="gi">+            option.process(value, state)</span>
<span class="gi">+</span>
<span class="gi">+            if stop:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        # If we got any unknown options we recombine the string of the</span>
<span class="gi">+        # remaining options and re-attach the prefix, then report that</span>
<span class="gi">+        # to the state as new larg.  This way there is basic combinatorics</span>
<span class="gi">+        # that can be achieved while still ignoring unknown arguments.</span>
<span class="gi">+        if self.ignore_unknown_options and unknown_options:</span>
<span class="gi">+            state.largs.append(f&quot;{prefix}{&#39;&#39;.join(unknown_options)}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_value_from_state(</span>
<span class="gi">+        self, option_name: str, option: Option, state: ParsingState</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        nargs = option.nargs</span>
<span class="gi">+</span>
<span class="gi">+        if len(state.rargs) &lt; nargs:</span>
<span class="gi">+            if option.obj._flag_needs_value:</span>
<span class="gi">+                # Option allows omitting the value.</span>
<span class="gi">+                value = _flag_needs_value</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise BadOptionUsage(</span>
<span class="gi">+                    option_name,</span>
<span class="gi">+                    ngettext(</span>
<span class="gi">+                        &quot;Option {name!r} requires an argument.&quot;,</span>
<span class="gi">+                        &quot;Option {name!r} requires {nargs} arguments.&quot;,</span>
<span class="gi">+                        nargs,</span>
<span class="gi">+                    ).format(name=option_name, nargs=nargs),</span>
<span class="gi">+                )</span>
<span class="gi">+        elif nargs == 1:</span>
<span class="gi">+            next_rarg = state.rargs[0]</span>
<span class="gi">+</span>
<span class="gi">+            if (</span>
<span class="gi">+                option.obj._flag_needs_value</span>
<span class="gi">+                and isinstance(next_rarg, str)</span>
<span class="gi">+                and next_rarg[:1] in self._opt_prefixes</span>
<span class="gi">+                and len(next_rarg) &gt; 1</span>
<span class="gi">+            ):</span>
<span class="gi">+                # The next arg looks like the start of an option, don&#39;t</span>
<span class="gi">+                # use it as the value if omitting the value is allowed.</span>
<span class="gi">+                value = _flag_needs_value</span>
<span class="gi">+            else:</span>
<span class="gi">+                value = state.rargs.pop(0)</span>
<span class="gi">+        else:</span>
<span class="gi">+            value = tuple(state.rargs[:nargs])</span>
<span class="gi">+            del state.rargs[:nargs]</span>
<span class="gi">+</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    def _process_opts(self, arg: str, state: ParsingState) -&gt; None:</span>
<span class="gi">+        explicit_value = None</span>
<span class="gi">+        # Long option handling happens in two parts.  The first part is</span>
<span class="gi">+        # supporting explicitly attached values.  In any case, we will try</span>
<span class="gi">+        # to long match the option first.</span>
<span class="gi">+        if &quot;=&quot; in arg:</span>
<span class="gi">+            long_opt, explicit_value = arg.split(&quot;=&quot;, 1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            long_opt = arg</span>
<span class="gi">+        norm_long_opt = normalize_opt(long_opt, self.ctx)</span>
<span class="gi">+</span>
<span class="gi">+        # At this point we will match the (assumed) long option through</span>
<span class="gi">+        # the long option matching code.  Note that this allows options</span>
<span class="gi">+        # like &quot;-foo&quot; to be matched as long options.</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._match_long_opt(norm_long_opt, explicit_value, state)</span>
<span class="gi">+        except NoSuchOption:</span>
<span class="gi">+            # At this point the long option matching failed, and we need</span>
<span class="gi">+            # to try with short options.  However there is a special rule</span>
<span class="gi">+            # which says, that if we have a two character options prefix</span>
<span class="gi">+            # (applies to &quot;--foo&quot; for instance), we do not dispatch to the</span>
<span class="gi">+            # short option code and will instead raise the no option</span>
<span class="gi">+            # error.</span>
<span class="gi">+            if arg[:2] not in self._opt_prefixes:</span>
<span class="gi">+                self._match_short_opt(arg, state)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            if not self.ignore_unknown_options:</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+            state.largs.append(arg)</span>
<span class="gh">diff --git a/src/click/shell_completion.py b/src/click/shell_completion.py</span>
<span class="gh">index 6956829..dc9e00b 100644</span>
<span class="gd">--- a/src/click/shell_completion.py</span>
<span class="gi">+++ b/src/click/shell_completion.py</span>
<span class="gu">@@ -2,6 +2,7 @@ import os</span>
<span class="w"> </span>import re
<span class="w"> </span>import typing as t
<span class="w"> </span>from gettext import gettext as _
<span class="gi">+</span>
<span class="w"> </span>from .core import Argument
<span class="w"> </span>from .core import BaseCommand
<span class="w"> </span>from .core import Context
<span class="gu">@@ -13,8 +14,13 @@ from .parser import split_arg_string</span>
<span class="w"> </span>from .utils import echo


<span class="gd">-def shell_complete(cli: BaseCommand, ctx_args: t.MutableMapping[str, t.Any],</span>
<span class="gd">-    prog_name: str, complete_var: str, instruction: str) -&gt;int:</span>
<span class="gi">+def shell_complete(</span>
<span class="gi">+    cli: BaseCommand,</span>
<span class="gi">+    ctx_args: t.MutableMapping[str, t.Any],</span>
<span class="gi">+    prog_name: str,</span>
<span class="gi">+    complete_var: str,</span>
<span class="gi">+    instruction: str,</span>
<span class="gi">+) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Perform shell completion for the given CLI program.

<span class="w"> </span>    :param cli: Command being called.
<span class="gu">@@ -27,7 +33,23 @@ def shell_complete(cli: BaseCommand, ctx_args: t.MutableMapping[str, t.Any],</span>
<span class="w"> </span>        instruction and shell, in the form ``instruction_shell``.
<span class="w"> </span>    :return: Status code to exit with.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    shell, _, instruction = instruction.partition(&quot;_&quot;)</span>
<span class="gi">+    comp_cls = get_completion_class(shell)</span>
<span class="gi">+</span>
<span class="gi">+    if comp_cls is None:</span>
<span class="gi">+        return 1</span>
<span class="gi">+</span>
<span class="gi">+    comp = comp_cls(cli, ctx_args, prog_name, complete_var)</span>
<span class="gi">+</span>
<span class="gi">+    if instruction == &quot;source&quot;:</span>
<span class="gi">+        echo(comp.source())</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    if instruction == &quot;complete&quot;:</span>
<span class="gi">+        echo(comp.complete())</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    return 1</span>


<span class="w"> </span>class CompletionItem:
<span class="gu">@@ -48,24 +70,33 @@ class CompletionItem:</span>
<span class="w"> </span>        don&#39;t use this, but custom type completions paired with custom
<span class="w"> </span>        shell support could use it.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;value&#39;, &#39;type&#39;, &#39;help&#39;, &#39;_info&#39;</span>

<span class="gd">-    def __init__(self, value: t.Any, type: str=&#39;plain&#39;, help: t.Optional[</span>
<span class="gd">-        str]=None, **kwargs: t.Any) -&gt;None:</span>
<span class="gi">+    __slots__ = (&quot;value&quot;, &quot;type&quot;, &quot;help&quot;, &quot;_info&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        value: t.Any,</span>
<span class="gi">+        type: str = &quot;plain&quot;,</span>
<span class="gi">+        help: t.Optional[str] = None,</span>
<span class="gi">+        **kwargs: t.Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.value: t.Any = value
<span class="w"> </span>        self.type: str = type
<span class="w"> </span>        self.help: t.Optional[str] = help
<span class="w"> </span>        self._info = kwargs

<span class="gd">-    def __getattr__(self, name: str) -&gt;t.Any:</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; t.Any:</span>
<span class="w"> </span>        return self._info.get(name)


<span class="gd">-_SOURCE_BASH = &quot;&quot;&quot;%(complete_func)s() {</span>
<span class="gi">+# Only Bash &gt;= 4.4 has the nosort option.</span>
<span class="gi">+_SOURCE_BASH = &quot;&quot;&quot;\</span>
<span class="gi">+%(complete_func)s() {</span>
<span class="w"> </span>    local IFS=$&#39;\\n&#39;
<span class="w"> </span>    local response

<span class="gd">-    response=$(env COMP_WORDS=&quot;${COMP_WORDS[*]}&quot; COMP_CWORD=$COMP_CWORD %(complete_var)s=bash_complete $1)</span>
<span class="gi">+    response=$(env COMP_WORDS=&quot;${COMP_WORDS[*]}&quot; COMP_CWORD=$COMP_CWORD \</span>
<span class="gi">+%(complete_var)s=bash_complete $1)</span>

<span class="w"> </span>    for completion in $response; do
<span class="w"> </span>        IFS=&#39;,&#39; read type value &lt;&lt;&lt; &quot;$completion&quot;
<span class="gu">@@ -90,7 +121,9 @@ _SOURCE_BASH = &quot;&quot;&quot;%(complete_func)s() {</span>

<span class="w"> </span>%(complete_func)s_setup;
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-_SOURCE_ZSH = &quot;&quot;&quot;#compdef %(prog_name)s</span>
<span class="gi">+</span>
<span class="gi">+_SOURCE_ZSH = &quot;&quot;&quot;\</span>
<span class="gi">+#compdef %(prog_name)s</span>

<span class="w"> </span>%(complete_func)s() {
<span class="w"> </span>    local -a completions
<span class="gu">@@ -98,7 +131,8 @@ _SOURCE_ZSH = &quot;&quot;&quot;#compdef %(prog_name)s</span>
<span class="w"> </span>    local -a response
<span class="w"> </span>    (( ! $+commands[%(prog_name)s] )) &amp;&amp; return 1

<span class="gd">-    response=(&quot;${(@f)$(env COMP_WORDS=&quot;${words[*]}&quot; COMP_CWORD=$((CURRENT-1)) %(complete_var)s=zsh_complete %(prog_name)s)}&quot;)</span>
<span class="gi">+    response=(&quot;${(@f)$(env COMP_WORDS=&quot;${words[*]}&quot; COMP_CWORD=$((CURRENT-1)) \</span>
<span class="gi">+%(complete_var)s=zsh_complete %(prog_name)s)}&quot;)</span>

<span class="w"> </span>    for type key descr in ${response}; do
<span class="w"> </span>        if [[ &quot;$type&quot; == &quot;plain&quot; ]]; then
<span class="gu">@@ -131,8 +165,11 @@ else</span>
<span class="w"> </span>    compdef %(complete_func)s %(prog_name)s
<span class="w"> </span>fi
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-_SOURCE_FISH = &quot;&quot;&quot;function %(complete_func)s;</span>
<span class="gd">-    set -l response (env %(complete_var)s=fish_complete COMP_WORDS=(commandline -cp) COMP_CWORD=(commandline -t) %(prog_name)s);</span>
<span class="gi">+</span>
<span class="gi">+_SOURCE_FISH = &quot;&quot;&quot;\</span>
<span class="gi">+function %(complete_func)s;</span>
<span class="gi">+    set -l response (env %(complete_var)s=fish_complete COMP_WORDS=(commandline -cp) \</span>
<span class="gi">+COMP_CWORD=(commandline -t) %(prog_name)s);</span>

<span class="w"> </span>    for completion in $response;
<span class="w"> </span>        set -l metadata (string split &quot;,&quot; $completion);
<span class="gu">@@ -147,7 +184,8 @@ _SOURCE_FISH = &quot;&quot;&quot;function %(complete_func)s;</span>
<span class="w"> </span>    end;
<span class="w"> </span>end;

<span class="gd">-complete --no-files --command %(prog_name)s --arguments &quot;(%(complete_func)s)&quot;;</span>
<span class="gi">+complete --no-files --command %(prog_name)s --arguments \</span>
<span class="gi">+&quot;(%(complete_func)s)&quot;;</span>
<span class="w"> </span>&quot;&quot;&quot;


<span class="gu">@@ -163,55 +201,68 @@ class ShellComplete:</span>

<span class="w"> </span>    .. versionadded:: 8.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name: t.ClassVar[str]
<span class="w"> </span>    &quot;&quot;&quot;Name to register the shell as with :func:`add_completion_class`.
<span class="w"> </span>    This is used in completion instructions (``{name}_source`` and
<span class="w"> </span>    ``{name}_complete``).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    source_template: t.ClassVar[str]
<span class="w"> </span>    &quot;&quot;&quot;Completion script template formatted by :meth:`source`. This must
<span class="w"> </span>    be provided by subclasses.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, cli: BaseCommand, ctx_args: t.MutableMapping[str, t.</span>
<span class="gd">-        Any], prog_name: str, complete_var: str) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        cli: BaseCommand,</span>
<span class="gi">+        ctx_args: t.MutableMapping[str, t.Any],</span>
<span class="gi">+        prog_name: str,</span>
<span class="gi">+        complete_var: str,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.cli = cli
<span class="w"> </span>        self.ctx_args = ctx_args
<span class="w"> </span>        self.prog_name = prog_name
<span class="w"> </span>        self.complete_var = complete_var

<span class="w"> </span>    @property
<span class="gd">-    def func_name(self) -&gt;str:</span>
<span class="gi">+    def func_name(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;The name of the shell function defined by the completion
<span class="w"> </span>        script.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        safe_name = re.sub(r&quot;\W*&quot;, &quot;&quot;, self.prog_name.replace(&quot;-&quot;, &quot;_&quot;), flags=re.ASCII)</span>
<span class="gi">+        return f&quot;_{safe_name}_completion&quot;</span>

<span class="gd">-    def source_vars(self) -&gt;t.Dict[str, t.Any]:</span>
<span class="gi">+    def source_vars(self) -&gt; t.Dict[str, t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Vars for formatting :attr:`source_template`.

<span class="w"> </span>        By default this provides ``complete_func``, ``complete_var``,
<span class="w"> </span>        and ``prog_name``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;complete_func&quot;: self.func_name,</span>
<span class="gi">+            &quot;complete_var&quot;: self.complete_var,</span>
<span class="gi">+            &quot;prog_name&quot;: self.prog_name,</span>
<span class="gi">+        }</span>

<span class="gd">-    def source(self) -&gt;str:</span>
<span class="gi">+    def source(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Produce the shell script that defines the completion
<span class="w"> </span>        function. By default this ``%``-style formats
<span class="w"> </span>        :attr:`source_template` with the dict returned by
<span class="w"> </span>        :meth:`source_vars`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.source_template % self.source_vars()</span>

<span class="gd">-    def get_completion_args(self) -&gt;t.Tuple[t.List[str], str]:</span>
<span class="gi">+    def get_completion_args(self) -&gt; t.Tuple[t.List[str], str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Use the env vars defined by the shell script to return a
<span class="w"> </span>        tuple of ``args, incomplete``. This must be implemented by
<span class="w"> </span>        subclasses.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def get_completions(self, args: t.List[str], incomplete: str) -&gt;t.List[</span>
<span class="gd">-        CompletionItem]:</span>
<span class="gi">+    def get_completions(</span>
<span class="gi">+        self, args: t.List[str], incomplete: str</span>
<span class="gi">+    ) -&gt; t.List[CompletionItem]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Determine the context and last complete command or parameter
<span class="w"> </span>        from the complete args. Call that object&#39;s ``shell_complete``
<span class="w"> </span>        method to get the completions for the incomplete value.
<span class="gu">@@ -219,51 +270,143 @@ class ShellComplete:</span>
<span class="w"> </span>        :param args: List of complete args before the incomplete value.
<span class="w"> </span>        :param incomplete: Value being completed. May be empty.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ctx = _resolve_context(self.cli, self.ctx_args, self.prog_name, args)</span>
<span class="gi">+        obj, incomplete = _resolve_incomplete(ctx, args, incomplete)</span>
<span class="gi">+        return obj.shell_complete(ctx, incomplete)</span>

<span class="gd">-    def format_completion(self, item: CompletionItem) -&gt;str:</span>
<span class="gi">+    def format_completion(self, item: CompletionItem) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Format a completion item into the form recognized by the
<span class="w"> </span>        shell script. This must be implemented by subclasses.

<span class="w"> </span>        :param item: Completion item to format.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def complete(self) -&gt;str:</span>
<span class="gi">+    def complete(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Produce the completion data to send back to the shell.

<span class="w"> </span>        By default this calls :meth:`get_completion_args`, gets the
<span class="w"> </span>        completions, then calls :meth:`format_completion` for each
<span class="w"> </span>        completion.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        args, incomplete = self.get_completion_args()</span>
<span class="gi">+        completions = self.get_completions(args, incomplete)</span>
<span class="gi">+        out = [self.format_completion(item) for item in completions]</span>
<span class="gi">+        return &quot;\n&quot;.join(out)</span>


<span class="w"> </span>class BashComplete(ShellComplete):
<span class="w"> </span>    &quot;&quot;&quot;Shell completion for Bash.&quot;&quot;&quot;
<span class="gd">-    name = &#39;bash&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;bash&quot;</span>
<span class="w"> </span>    source_template = _SOURCE_BASH

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _check_version() -&gt; None:</span>
<span class="gi">+        import subprocess</span>
<span class="gi">+</span>
<span class="gi">+        output = subprocess.run(</span>
<span class="gi">+            [&quot;bash&quot;, &quot;-c&quot;, &#39;echo &quot;${BASH_VERSION}&quot;&#39;], stdout=subprocess.PIPE</span>
<span class="gi">+        )</span>
<span class="gi">+        match = re.search(r&quot;^(\d+)\.(\d+)\.\d+&quot;, output.stdout.decode())</span>
<span class="gi">+</span>
<span class="gi">+        if match is not None:</span>
<span class="gi">+            major, minor = match.groups()</span>
<span class="gi">+</span>
<span class="gi">+            if major &lt; &quot;4&quot; or major == &quot;4&quot; and minor &lt; &quot;4&quot;:</span>
<span class="gi">+                echo(</span>
<span class="gi">+                    _(</span>
<span class="gi">+                        &quot;Shell completion is not supported for Bash&quot;</span>
<span class="gi">+                        &quot; versions older than 4.4.&quot;</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    err=True,</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            echo(</span>
<span class="gi">+                _(&quot;Couldn&#39;t detect Bash version, shell completion is not supported.&quot;),</span>
<span class="gi">+                err=True,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def source(self) -&gt; str:</span>
<span class="gi">+        self._check_version()</span>
<span class="gi">+        return super().source()</span>
<span class="gi">+</span>
<span class="gi">+    def get_completion_args(self) -&gt; t.Tuple[t.List[str], str]:</span>
<span class="gi">+        cwords = split_arg_string(os.environ[&quot;COMP_WORDS&quot;])</span>
<span class="gi">+        cword = int(os.environ[&quot;COMP_CWORD&quot;])</span>
<span class="gi">+        args = cwords[1:cword]</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            incomplete = cwords[cword]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            incomplete = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return args, incomplete</span>
<span class="gi">+</span>
<span class="gi">+    def format_completion(self, item: CompletionItem) -&gt; str:</span>
<span class="gi">+        return f&quot;{item.type},{item.value}&quot;</span>
<span class="gi">+</span>

<span class="w"> </span>class ZshComplete(ShellComplete):
<span class="w"> </span>    &quot;&quot;&quot;Shell completion for Zsh.&quot;&quot;&quot;
<span class="gd">-    name = &#39;zsh&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;zsh&quot;</span>
<span class="w"> </span>    source_template = _SOURCE_ZSH

<span class="gi">+    def get_completion_args(self) -&gt; t.Tuple[t.List[str], str]:</span>
<span class="gi">+        cwords = split_arg_string(os.environ[&quot;COMP_WORDS&quot;])</span>
<span class="gi">+        cword = int(os.environ[&quot;COMP_CWORD&quot;])</span>
<span class="gi">+        args = cwords[1:cword]</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            incomplete = cwords[cword]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            incomplete = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return args, incomplete</span>
<span class="gi">+</span>
<span class="gi">+    def format_completion(self, item: CompletionItem) -&gt; str:</span>
<span class="gi">+        return f&quot;{item.type}\n{item.value}\n{item.help if item.help else &#39;_&#39;}&quot;</span>
<span class="gi">+</span>

<span class="w"> </span>class FishComplete(ShellComplete):
<span class="w"> </span>    &quot;&quot;&quot;Shell completion for Fish.&quot;&quot;&quot;
<span class="gd">-    name = &#39;fish&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;fish&quot;</span>
<span class="w"> </span>    source_template = _SOURCE_FISH

<span class="gi">+    def get_completion_args(self) -&gt; t.Tuple[t.List[str], str]:</span>
<span class="gi">+        cwords = split_arg_string(os.environ[&quot;COMP_WORDS&quot;])</span>
<span class="gi">+        incomplete = os.environ[&quot;COMP_CWORD&quot;]</span>
<span class="gi">+        args = cwords[1:]</span>

<span class="gd">-ShellCompleteType = t.TypeVar(&#39;ShellCompleteType&#39;, bound=t.Type[ShellComplete])</span>
<span class="gd">-_available_shells: t.Dict[str, t.Type[ShellComplete]] = {&#39;bash&#39;:</span>
<span class="gd">-    BashComplete, &#39;fish&#39;: FishComplete, &#39;zsh&#39;: ZshComplete}</span>
<span class="gi">+        # Fish stores the partial word in both COMP_WORDS and</span>
<span class="gi">+        # COMP_CWORD, remove it from complete args.</span>
<span class="gi">+        if incomplete and args and args[-1] == incomplete:</span>
<span class="gi">+            args.pop()</span>

<span class="gi">+        return args, incomplete</span>

<span class="gd">-def add_completion_class(cls: ShellCompleteType, name: t.Optional[str]=None</span>
<span class="gd">-    ) -&gt;ShellCompleteType:</span>
<span class="gi">+    def format_completion(self, item: CompletionItem) -&gt; str:</span>
<span class="gi">+        if item.help:</span>
<span class="gi">+            return f&quot;{item.type},{item.value}\t{item.help}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return f&quot;{item.type},{item.value}&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+ShellCompleteType = t.TypeVar(&quot;ShellCompleteType&quot;, bound=t.Type[ShellComplete])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_available_shells: t.Dict[str, t.Type[ShellComplete]] = {</span>
<span class="gi">+    &quot;bash&quot;: BashComplete,</span>
<span class="gi">+    &quot;fish&quot;: FishComplete,</span>
<span class="gi">+    &quot;zsh&quot;: ZshComplete,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def add_completion_class(</span>
<span class="gi">+    cls: ShellCompleteType, name: t.Optional[str] = None</span>
<span class="gi">+) -&gt; ShellCompleteType:</span>
<span class="w"> </span>    &quot;&quot;&quot;Register a :class:`ShellComplete` subclass under the given name.
<span class="w"> </span>    The name will be provided by the completion instruction environment
<span class="w"> </span>    variable during completion.
<span class="gu">@@ -273,20 +416,25 @@ def add_completion_class(cls: ShellCompleteType, name: t.Optional[str]=None</span>
<span class="w"> </span>    :param name: Name to register the class under. Defaults to the
<span class="w"> </span>        class&#39;s ``name`` attribute.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if name is None:</span>
<span class="gi">+        name = cls.name</span>
<span class="gi">+</span>
<span class="gi">+    _available_shells[name] = cls</span>

<span class="gi">+    return cls</span>

<span class="gd">-def get_completion_class(shell: str) -&gt;t.Optional[t.Type[ShellComplete]]:</span>
<span class="gi">+</span>
<span class="gi">+def get_completion_class(shell: str) -&gt; t.Optional[t.Type[ShellComplete]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Look up a registered :class:`ShellComplete` subclass by the name
<span class="w"> </span>    provided by the completion instruction environment variable. If the
<span class="w"> </span>    name isn&#39;t registered, returns ``None``.

<span class="w"> </span>    :param shell: Name the class is registered under.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _available_shells.get(shell)</span>


<span class="gd">-def _is_incomplete_argument(ctx: Context, param: Parameter) -&gt;bool:</span>
<span class="gi">+def _is_incomplete_argument(ctx: Context, param: Parameter) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determine if the given parameter is an argument that can still
<span class="w"> </span>    accept values.

<span class="gu">@@ -294,26 +442,62 @@ def _is_incomplete_argument(ctx: Context, param: Parameter) -&gt;bool:</span>
<span class="w"> </span>        parsed complete args.
<span class="w"> </span>    :param param: Argument object being checked.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _start_of_option(ctx: Context, value: str) -&gt;bool:</span>
<span class="gi">+    if not isinstance(param, Argument):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    assert param.name is not None</span>
<span class="gi">+    # Will be None if expose_value is False.</span>
<span class="gi">+    value = ctx.params.get(param.name)</span>
<span class="gi">+    return (</span>
<span class="gi">+        param.nargs == -1</span>
<span class="gi">+        or ctx.get_parameter_source(param.name) is not ParameterSource.COMMANDLINE</span>
<span class="gi">+        or (</span>
<span class="gi">+            param.nargs &gt; 1</span>
<span class="gi">+            and isinstance(value, (tuple, list))</span>
<span class="gi">+            and len(value) &lt; param.nargs</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _start_of_option(ctx: Context, value: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the value looks like the start of an option.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not value:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    c = value[0]</span>
<span class="gi">+    return c in ctx._opt_prefixes</span>


<span class="gd">-def _is_incomplete_option(ctx: Context, args: t.List[str], param: Parameter</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+def _is_incomplete_option(ctx: Context, args: t.List[str], param: Parameter) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determine if the given parameter is an option that needs a value.

<span class="w"> </span>    :param args: List of complete args before the incomplete value.
<span class="w"> </span>    :param param: Option object being checked.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(param, Option):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if param.is_flag or param.count:</span>
<span class="gi">+        return False</span>

<span class="gi">+    last_option = None</span>

<span class="gd">-def _resolve_context(cli: BaseCommand, ctx_args: t.MutableMapping[str, t.</span>
<span class="gd">-    Any], prog_name: str, args: t.List[str]) -&gt;Context:</span>
<span class="gi">+    for index, arg in enumerate(reversed(args)):</span>
<span class="gi">+        if index + 1 &gt; param.nargs:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+        if _start_of_option(ctx, arg):</span>
<span class="gi">+            last_option = arg</span>
<span class="gi">+</span>
<span class="gi">+    return last_option is not None and last_option in param.opts</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _resolve_context(</span>
<span class="gi">+    cli: BaseCommand,</span>
<span class="gi">+    ctx_args: t.MutableMapping[str, t.Any],</span>
<span class="gi">+    prog_name: str,</span>
<span class="gi">+    args: t.List[str],</span>
<span class="gi">+) -&gt; Context:</span>
<span class="w"> </span>    &quot;&quot;&quot;Produce the context hierarchy starting with the command and
<span class="w"> </span>    traversing the complete arguments. This only follows the commands,
<span class="w"> </span>    it doesn&#39;t trigger input prompts or callbacks.
<span class="gu">@@ -322,11 +506,52 @@ def _resolve_context(cli: BaseCommand, ctx_args: t.MutableMapping[str, t.</span>
<span class="w"> </span>    :param prog_name: Name of the executable in the shell.
<span class="w"> </span>    :param args: List of complete args before the incomplete value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ctx_args[&quot;resilient_parsing&quot;] = True</span>
<span class="gi">+    ctx = cli.make_context(prog_name, args.copy(), **ctx_args)</span>
<span class="gi">+    args = ctx.protected_args + ctx.args</span>
<span class="gi">+</span>
<span class="gi">+    while args:</span>
<span class="gi">+        command = ctx.command</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(command, MultiCommand):</span>
<span class="gi">+            if not command.chain:</span>
<span class="gi">+                name, cmd, args = command.resolve_command(ctx, args)</span>
<span class="gi">+</span>
<span class="gi">+                if cmd is None:</span>
<span class="gi">+                    return ctx</span>
<span class="gi">+</span>
<span class="gi">+                ctx = cmd.make_context(name, args, parent=ctx, resilient_parsing=True)</span>
<span class="gi">+                args = ctx.protected_args + ctx.args</span>
<span class="gi">+            else:</span>
<span class="gi">+                sub_ctx = ctx</span>
<span class="gi">+</span>
<span class="gi">+                while args:</span>
<span class="gi">+                    name, cmd, args = command.resolve_command(ctx, args)</span>
<span class="gi">+</span>
<span class="gi">+                    if cmd is None:</span>
<span class="gi">+                        return ctx</span>
<span class="gi">+</span>
<span class="gi">+                    sub_ctx = cmd.make_context(</span>
<span class="gi">+                        name,</span>
<span class="gi">+                        args,</span>
<span class="gi">+                        parent=ctx,</span>
<span class="gi">+                        allow_extra_args=True,</span>
<span class="gi">+                        allow_interspersed_args=False,</span>
<span class="gi">+                        resilient_parsing=True,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    args = sub_ctx.args</span>
<span class="gi">+</span>
<span class="gi">+                ctx = sub_ctx</span>
<span class="gi">+                args = [*sub_ctx.protected_args, *sub_ctx.args]</span>
<span class="gi">+        else:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    return ctx</span>


<span class="gd">-def _resolve_incomplete(ctx: Context, args: t.List[str], incomplete: str</span>
<span class="gd">-    ) -&gt;t.Tuple[t.Union[BaseCommand, Parameter], str]:</span>
<span class="gi">+def _resolve_incomplete(</span>
<span class="gi">+    ctx: Context, args: t.List[str], incomplete: str</span>
<span class="gi">+) -&gt; t.Tuple[t.Union[BaseCommand, Parameter], str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find the Click object that will handle the completion of the
<span class="w"> </span>    incomplete value. Return the object and the incomplete value.

<span class="gu">@@ -335,4 +560,37 @@ def _resolve_incomplete(ctx: Context, args: t.List[str], incomplete: str</span>
<span class="w"> </span>    :param args: List of complete args before the incomplete value.
<span class="w"> </span>    :param incomplete: Value being completed. May be empty.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Different shells treat an &quot;=&quot; between a long option name and</span>
<span class="gi">+    # value differently. Might keep the value joined, return the &quot;=&quot;</span>
<span class="gi">+    # as a separate item, or return the split name and value. Always</span>
<span class="gi">+    # split and discard the &quot;=&quot; to make completion easier.</span>
<span class="gi">+    if incomplete == &quot;=&quot;:</span>
<span class="gi">+        incomplete = &quot;&quot;</span>
<span class="gi">+    elif &quot;=&quot; in incomplete and _start_of_option(ctx, incomplete):</span>
<span class="gi">+        name, _, incomplete = incomplete.partition(&quot;=&quot;)</span>
<span class="gi">+        args.append(name)</span>
<span class="gi">+</span>
<span class="gi">+    # The &quot;--&quot; marker tells Click to stop treating values as options</span>
<span class="gi">+    # even if they start with the option character. If it hasn&#39;t been</span>
<span class="gi">+    # given and the incomplete arg looks like an option, the current</span>
<span class="gi">+    # command will provide option name completions.</span>
<span class="gi">+    if &quot;--&quot; not in args and _start_of_option(ctx, incomplete):</span>
<span class="gi">+        return ctx.command, incomplete</span>
<span class="gi">+</span>
<span class="gi">+    params = ctx.command.get_params(ctx)</span>
<span class="gi">+</span>
<span class="gi">+    # If the last complete arg is an option name with an incomplete</span>
<span class="gi">+    # value, the option will provide value completions.</span>
<span class="gi">+    for param in params:</span>
<span class="gi">+        if _is_incomplete_option(ctx, args, param):</span>
<span class="gi">+            return param, incomplete</span>
<span class="gi">+</span>
<span class="gi">+    # It&#39;s not an option name or value. The first argument without a</span>
<span class="gi">+    # parsed value will provide value completions.</span>
<span class="gi">+    for param in params:</span>
<span class="gi">+        if _is_incomplete_argument(ctx, param):</span>
<span class="gi">+            return param, incomplete</span>
<span class="gi">+</span>
<span class="gi">+    # There were no unparsed arguments, the command may be a group that</span>
<span class="gi">+    # will provide command name completions.</span>
<span class="gi">+    return ctx.command, incomplete</span>
<span class="gh">diff --git a/src/click/termui.py b/src/click/termui.py</span>
<span class="gh">index 277721a..db7a4b2 100644</span>
<span class="gd">--- a/src/click/termui.py</span>
<span class="gi">+++ b/src/click/termui.py</span>
<span class="gu">@@ -4,6 +4,7 @@ import itertools</span>
<span class="w"> </span>import sys
<span class="w"> </span>import typing as t
<span class="w"> </span>from gettext import gettext as _
<span class="gi">+</span>
<span class="w"> </span>from ._compat import isatty
<span class="w"> </span>from ._compat import strip_ansi
<span class="w"> </span>from .exceptions import Abort
<span class="gu">@@ -14,23 +15,79 @@ from .types import convert_type</span>
<span class="w"> </span>from .types import ParamType
<span class="w"> </span>from .utils import echo
<span class="w"> </span>from .utils import LazyFile
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    from ._termui_impl import ProgressBar
<span class="gd">-V = t.TypeVar(&#39;V&#39;)</span>
<span class="gi">+</span>
<span class="gi">+V = t.TypeVar(&quot;V&quot;)</span>
<span class="gi">+</span>
<span class="gi">+# The prompt functions to use.  The doc tools currently override these</span>
<span class="gi">+# functions to customize how they work.</span>
<span class="w"> </span>visible_prompt_func: t.Callable[[str], str] = input
<span class="gd">-_ansi_colors = {&#39;black&#39;: 30, &#39;red&#39;: 31, &#39;green&#39;: 32, &#39;yellow&#39;: 33, &#39;blue&#39;: </span>
<span class="gd">-    34, &#39;magenta&#39;: 35, &#39;cyan&#39;: 36, &#39;white&#39;: 37, &#39;reset&#39;: 39, &#39;bright_black&#39;:</span>
<span class="gd">-    90, &#39;bright_red&#39;: 91, &#39;bright_green&#39;: 92, &#39;bright_yellow&#39;: 93,</span>
<span class="gd">-    &#39;bright_blue&#39;: 94, &#39;bright_magenta&#39;: 95, &#39;bright_cyan&#39;: 96,</span>
<span class="gd">-    &#39;bright_white&#39;: 97}</span>
<span class="gd">-_ansi_reset_all = &#39;\x1b[0m&#39;</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def prompt(text: str, default: t.Optional[t.Any]=None, hide_input: bool=</span>
<span class="gd">-    False, confirmation_prompt: t.Union[bool, str]=False, type: t.Optional[</span>
<span class="gd">-    t.Union[ParamType, t.Any]]=None, value_proc: t.Optional[t.Callable[[str</span>
<span class="gd">-    ], t.Any]]=None, prompt_suffix: str=&#39;: &#39;, show_default: bool=True, err:</span>
<span class="gd">-    bool=False, show_choices: bool=True) -&gt;t.Any:</span>
<span class="gi">+</span>
<span class="gi">+_ansi_colors = {</span>
<span class="gi">+    &quot;black&quot;: 30,</span>
<span class="gi">+    &quot;red&quot;: 31,</span>
<span class="gi">+    &quot;green&quot;: 32,</span>
<span class="gi">+    &quot;yellow&quot;: 33,</span>
<span class="gi">+    &quot;blue&quot;: 34,</span>
<span class="gi">+    &quot;magenta&quot;: 35,</span>
<span class="gi">+    &quot;cyan&quot;: 36,</span>
<span class="gi">+    &quot;white&quot;: 37,</span>
<span class="gi">+    &quot;reset&quot;: 39,</span>
<span class="gi">+    &quot;bright_black&quot;: 90,</span>
<span class="gi">+    &quot;bright_red&quot;: 91,</span>
<span class="gi">+    &quot;bright_green&quot;: 92,</span>
<span class="gi">+    &quot;bright_yellow&quot;: 93,</span>
<span class="gi">+    &quot;bright_blue&quot;: 94,</span>
<span class="gi">+    &quot;bright_magenta&quot;: 95,</span>
<span class="gi">+    &quot;bright_cyan&quot;: 96,</span>
<span class="gi">+    &quot;bright_white&quot;: 97,</span>
<span class="gi">+}</span>
<span class="gi">+_ansi_reset_all = &quot;\033[0m&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def hidden_prompt_func(prompt: str) -&gt; str:</span>
<span class="gi">+    import getpass</span>
<span class="gi">+</span>
<span class="gi">+    return getpass.getpass(prompt)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _build_prompt(</span>
<span class="gi">+    text: str,</span>
<span class="gi">+    suffix: str,</span>
<span class="gi">+    show_default: bool = False,</span>
<span class="gi">+    default: t.Optional[t.Any] = None,</span>
<span class="gi">+    show_choices: bool = True,</span>
<span class="gi">+    type: t.Optional[ParamType] = None,</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    prompt = text</span>
<span class="gi">+    if type is not None and show_choices and isinstance(type, Choice):</span>
<span class="gi">+        prompt += f&quot; ({&#39;, &#39;.join(map(str, type.choices))})&quot;</span>
<span class="gi">+    if default is not None and show_default:</span>
<span class="gi">+        prompt = f&quot;{prompt} [{_format_default(default)}]&quot;</span>
<span class="gi">+    return f&quot;{prompt}{suffix}&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _format_default(default: t.Any) -&gt; t.Any:</span>
<span class="gi">+    if isinstance(default, (io.IOBase, LazyFile)) and hasattr(default, &quot;name&quot;):</span>
<span class="gi">+        return default.name</span>
<span class="gi">+</span>
<span class="gi">+    return default</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def prompt(</span>
<span class="gi">+    text: str,</span>
<span class="gi">+    default: t.Optional[t.Any] = None,</span>
<span class="gi">+    hide_input: bool = False,</span>
<span class="gi">+    confirmation_prompt: t.Union[bool, str] = False,</span>
<span class="gi">+    type: t.Optional[t.Union[ParamType, t.Any]] = None,</span>
<span class="gi">+    value_proc: t.Optional[t.Callable[[str], t.Any]] = None,</span>
<span class="gi">+    prompt_suffix: str = &quot;: &quot;,</span>
<span class="gi">+    show_default: bool = True,</span>
<span class="gi">+    err: bool = False,</span>
<span class="gi">+    show_choices: bool = True,</span>
<span class="gi">+) -&gt; t.Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Prompts a user for input.  This is a convenience function that can
<span class="w"> </span>    be used to prompt a user for input later.

<span class="gu">@@ -71,11 +128,73 @@ def prompt(text: str, default: t.Optional[t.Any]=None, hide_input: bool=</span>
<span class="w"> </span>        Added the `err` parameter.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def confirm(text: str, default: t.Optional[bool]=False, abort: bool=False,</span>
<span class="gd">-    prompt_suffix: str=&#39;: &#39;, show_default: bool=True, err: bool=False) -&gt;bool:</span>
<span class="gi">+    def prompt_func(text: str) -&gt; str:</span>
<span class="gi">+        f = hidden_prompt_func if hide_input else visible_prompt_func</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Write the prompt separately so that we get nice</span>
<span class="gi">+            # coloring through colorama on Windows</span>
<span class="gi">+            echo(text.rstrip(&quot; &quot;), nl=False, err=err)</span>
<span class="gi">+            # Echo a space to stdout to work around an issue where</span>
<span class="gi">+            # readline causes backspace to clear the whole line.</span>
<span class="gi">+            return f(&quot; &quot;)</span>
<span class="gi">+        except (KeyboardInterrupt, EOFError):</span>
<span class="gi">+            # getpass doesn&#39;t print a newline if the user aborts input with ^C.</span>
<span class="gi">+            # Allegedly this behavior is inherited from getpass(3).</span>
<span class="gi">+            # A doc bug has been filed at https://bugs.python.org/issue24711</span>
<span class="gi">+            if hide_input:</span>
<span class="gi">+                echo(None, err=err)</span>
<span class="gi">+            raise Abort() from None</span>
<span class="gi">+</span>
<span class="gi">+    if value_proc is None:</span>
<span class="gi">+        value_proc = convert_type(type, default)</span>
<span class="gi">+</span>
<span class="gi">+    prompt = _build_prompt(</span>
<span class="gi">+        text, prompt_suffix, show_default, default, show_choices, type</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if confirmation_prompt:</span>
<span class="gi">+        if confirmation_prompt is True:</span>
<span class="gi">+            confirmation_prompt = _(&quot;Repeat for confirmation&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        confirmation_prompt = _build_prompt(confirmation_prompt, prompt_suffix)</span>
<span class="gi">+</span>
<span class="gi">+    while True:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            value = prompt_func(prompt)</span>
<span class="gi">+            if value:</span>
<span class="gi">+                break</span>
<span class="gi">+            elif default is not None:</span>
<span class="gi">+                value = default</span>
<span class="gi">+                break</span>
<span class="gi">+        try:</span>
<span class="gi">+            result = value_proc(value)</span>
<span class="gi">+        except UsageError as e:</span>
<span class="gi">+            if hide_input:</span>
<span class="gi">+                echo(_(&quot;Error: The value you entered was invalid.&quot;), err=err)</span>
<span class="gi">+            else:</span>
<span class="gi">+                echo(_(&quot;Error: {e.message}&quot;).format(e=e), err=err)  # noqa: B306</span>
<span class="gi">+            continue</span>
<span class="gi">+        if not confirmation_prompt:</span>
<span class="gi">+            return result</span>
<span class="gi">+        while True:</span>
<span class="gi">+            value2 = prompt_func(confirmation_prompt)</span>
<span class="gi">+            is_empty = not value and not value2</span>
<span class="gi">+            if value2 or is_empty:</span>
<span class="gi">+                break</span>
<span class="gi">+        if value == value2:</span>
<span class="gi">+            return result</span>
<span class="gi">+        echo(_(&quot;Error: The two entered values do not match.&quot;), err=err)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def confirm(</span>
<span class="gi">+    text: str,</span>
<span class="gi">+    default: t.Optional[bool] = False,</span>
<span class="gi">+    abort: bool = False,</span>
<span class="gi">+    prompt_suffix: str = &quot;: &quot;,</span>
<span class="gi">+    show_default: bool = True,</span>
<span class="gi">+    err: bool = False,</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Prompts for confirmation (yes/no question).

<span class="w"> </span>    If the user aborts the input by sending a interrupt signal this
<span class="gu">@@ -97,11 +216,42 @@ def confirm(text: str, default: t.Optional[bool]=False, abort: bool=False,</span>
<span class="w"> </span>    .. versionadded:: 4.0
<span class="w"> </span>        Added the ``err`` parameter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def echo_via_pager(text_or_generator: t.Union[t.Iterable[str], t.Callable[[</span>
<span class="gd">-    ], t.Iterable[str]], str], color: t.Optional[bool]=None) -&gt;None:</span>
<span class="gi">+    prompt = _build_prompt(</span>
<span class="gi">+        text,</span>
<span class="gi">+        prompt_suffix,</span>
<span class="gi">+        show_default,</span>
<span class="gi">+        &quot;y/n&quot; if default is None else (&quot;Y/n&quot; if default else &quot;y/N&quot;),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Write the prompt separately so that we get nice</span>
<span class="gi">+            # coloring through colorama on Windows</span>
<span class="gi">+            echo(prompt.rstrip(&quot; &quot;), nl=False, err=err)</span>
<span class="gi">+            # Echo a space to stdout to work around an issue where</span>
<span class="gi">+            # readline causes backspace to clear the whole line.</span>
<span class="gi">+            value = visible_prompt_func(&quot; &quot;).lower().strip()</span>
<span class="gi">+        except (KeyboardInterrupt, EOFError):</span>
<span class="gi">+            raise Abort() from None</span>
<span class="gi">+        if value in (&quot;y&quot;, &quot;yes&quot;):</span>
<span class="gi">+            rv = True</span>
<span class="gi">+        elif value in (&quot;n&quot;, &quot;no&quot;):</span>
<span class="gi">+            rv = False</span>
<span class="gi">+        elif default is not None and value == &quot;&quot;:</span>
<span class="gi">+            rv = default</span>
<span class="gi">+        else:</span>
<span class="gi">+            echo(_(&quot;Error: invalid input&quot;), err=err)</span>
<span class="gi">+            continue</span>
<span class="gi">+        break</span>
<span class="gi">+    if abort and not rv:</span>
<span class="gi">+        raise Abort()</span>
<span class="gi">+    return rv</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def echo_via_pager(</span>
<span class="gi">+    text_or_generator: t.Union[t.Iterable[str], t.Callable[[], t.Iterable[str]], str],</span>
<span class="gi">+    color: t.Optional[bool] = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;This function takes a text and shows it via an environment specific
<span class="w"> </span>    pager on stdout.

<span class="gu">@@ -113,17 +263,40 @@ def echo_via_pager(text_or_generator: t.Union[t.Iterable[str], t.Callable[[</span>
<span class="w"> </span>    :param color: controls if the pager supports ANSI colors or not.  The
<span class="w"> </span>                  default is autodetection.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def progressbar(iterable: t.Optional[t.Iterable[V]]=None, length: t.</span>
<span class="gd">-    Optional[int]=None, label: t.Optional[str]=None, show_eta: bool=True,</span>
<span class="gd">-    show_percent: t.Optional[bool]=None, show_pos: bool=False,</span>
<span class="gd">-    item_show_func: t.Optional[t.Callable[[t.Optional[V]], t.Optional[str]]</span>
<span class="gd">-    ]=None, fill_char: str=&#39;#&#39;, empty_char: str=&#39;-&#39;, bar_template: str=</span>
<span class="gd">-    &#39;%(label)s  [%(bar)s]  %(info)s&#39;, info_sep: str=&#39;  &#39;, width: int=36,</span>
<span class="gd">-    file: t.Optional[t.TextIO]=None, color: t.Optional[bool]=None,</span>
<span class="gd">-    update_min_steps: int=1) -&gt;&#39;ProgressBar[V]&#39;:</span>
<span class="gi">+    color = resolve_color_default(color)</span>
<span class="gi">+</span>
<span class="gi">+    if inspect.isgeneratorfunction(text_or_generator):</span>
<span class="gi">+        i = t.cast(t.Callable[[], t.Iterable[str]], text_or_generator)()</span>
<span class="gi">+    elif isinstance(text_or_generator, str):</span>
<span class="gi">+        i = [text_or_generator]</span>
<span class="gi">+    else:</span>
<span class="gi">+        i = iter(t.cast(t.Iterable[str], text_or_generator))</span>
<span class="gi">+</span>
<span class="gi">+    # convert every element of i to a text type if necessary</span>
<span class="gi">+    text_generator = (el if isinstance(el, str) else str(el) for el in i)</span>
<span class="gi">+</span>
<span class="gi">+    from ._termui_impl import pager</span>
<span class="gi">+</span>
<span class="gi">+    return pager(itertools.chain(text_generator, &quot;\n&quot;), color)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def progressbar(</span>
<span class="gi">+    iterable: t.Optional[t.Iterable[V]] = None,</span>
<span class="gi">+    length: t.Optional[int] = None,</span>
<span class="gi">+    label: t.Optional[str] = None,</span>
<span class="gi">+    show_eta: bool = True,</span>
<span class="gi">+    show_percent: t.Optional[bool] = None,</span>
<span class="gi">+    show_pos: bool = False,</span>
<span class="gi">+    item_show_func: t.Optional[t.Callable[[t.Optional[V]], t.Optional[str]]] = None,</span>
<span class="gi">+    fill_char: str = &quot;#&quot;,</span>
<span class="gi">+    empty_char: str = &quot;-&quot;,</span>
<span class="gi">+    bar_template: str = &quot;%(label)s  [%(bar)s]  %(info)s&quot;,</span>
<span class="gi">+    info_sep: str = &quot;  &quot;,</span>
<span class="gi">+    width: int = 36,</span>
<span class="gi">+    file: t.Optional[t.TextIO] = None,</span>
<span class="gi">+    color: t.Optional[bool] = None,</span>
<span class="gi">+    update_min_steps: int = 1,</span>
<span class="gi">+) -&gt; &quot;ProgressBar[V]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;This function creates an iterable context manager that can be used
<span class="w"> </span>    to iterate over something while showing a progress bar.  It will
<span class="w"> </span>    either iterate over the `iterable` or `length` items (that are counted
<span class="gu">@@ -237,26 +410,69 @@ def progressbar(iterable: t.Optional[t.Iterable[V]]=None, length: t.</span>

<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    from ._termui_impl import ProgressBar</span>

<span class="gd">-def clear() -&gt;None:</span>
<span class="gi">+    color = resolve_color_default(color)</span>
<span class="gi">+    return ProgressBar(</span>
<span class="gi">+        iterable=iterable,</span>
<span class="gi">+        length=length,</span>
<span class="gi">+        show_eta=show_eta,</span>
<span class="gi">+        show_percent=show_percent,</span>
<span class="gi">+        show_pos=show_pos,</span>
<span class="gi">+        item_show_func=item_show_func,</span>
<span class="gi">+        fill_char=fill_char,</span>
<span class="gi">+        empty_char=empty_char,</span>
<span class="gi">+        bar_template=bar_template,</span>
<span class="gi">+        info_sep=info_sep,</span>
<span class="gi">+        file=file,</span>
<span class="gi">+        label=label,</span>
<span class="gi">+        width=width,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        update_min_steps=update_min_steps,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def clear() -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Clears the terminal screen.  This will have the effect of clearing
<span class="w"> </span>    the whole visible space of the terminal and moving the cursor to the
<span class="w"> </span>    top left.  This does not do anything if not connected to a terminal.

<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def style(text: t.Any, fg: t.Optional[t.Union[int, t.Tuple[int, int, int],</span>
<span class="gd">-    str]]=None, bg: t.Optional[t.Union[int, t.Tuple[int, int, int], str]]=</span>
<span class="gd">-    None, bold: t.Optional[bool]=None, dim: t.Optional[bool]=None,</span>
<span class="gd">-    underline: t.Optional[bool]=None, overline: t.Optional[bool]=None,</span>
<span class="gd">-    italic: t.Optional[bool]=None, blink: t.Optional[bool]=None, reverse: t</span>
<span class="gd">-    .Optional[bool]=None, strikethrough: t.Optional[bool]=None, reset: bool</span>
<span class="gd">-    =True) -&gt;str:</span>
<span class="gi">+    if not isatty(sys.stdout):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # ANSI escape \033[2J clears the screen, \033[1;1H moves the cursor</span>
<span class="gi">+    echo(&quot;\033[2J\033[1;1H&quot;, nl=False)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _interpret_color(</span>
<span class="gi">+    color: t.Union[int, t.Tuple[int, int, int], str], offset: int = 0</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    if isinstance(color, int):</span>
<span class="gi">+        return f&quot;{38 + offset};5;{color:d}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(color, (tuple, list)):</span>
<span class="gi">+        r, g, b = color</span>
<span class="gi">+        return f&quot;{38 + offset};2;{r:d};{g:d};{b:d}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    return str(_ansi_colors[color] + offset)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def style(</span>
<span class="gi">+    text: t.Any,</span>
<span class="gi">+    fg: t.Optional[t.Union[int, t.Tuple[int, int, int], str]] = None,</span>
<span class="gi">+    bg: t.Optional[t.Union[int, t.Tuple[int, int, int], str]] = None,</span>
<span class="gi">+    bold: t.Optional[bool] = None,</span>
<span class="gi">+    dim: t.Optional[bool] = None,</span>
<span class="gi">+    underline: t.Optional[bool] = None,</span>
<span class="gi">+    overline: t.Optional[bool] = None,</span>
<span class="gi">+    italic: t.Optional[bool] = None,</span>
<span class="gi">+    blink: t.Optional[bool] = None,</span>
<span class="gi">+    reverse: t.Optional[bool] = None,</span>
<span class="gi">+    strikethrough: t.Optional[bool] = None,</span>
<span class="gi">+    reset: bool = True,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Styles a text with ANSI styles and returns the new string.  By
<span class="w"> </span>    default the styling is self contained which means that at the end
<span class="w"> </span>    of the string a reset code is issued.  This can be prevented by
<span class="gu">@@ -333,10 +549,46 @@ def style(text: t.Any, fg: t.Optional[t.Union[int, t.Tuple[int, int, int],</span>

<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def unstyle(text: str) -&gt;str:</span>
<span class="gi">+    if not isinstance(text, str):</span>
<span class="gi">+        text = str(text)</span>
<span class="gi">+</span>
<span class="gi">+    bits = []</span>
<span class="gi">+</span>
<span class="gi">+    if fg:</span>
<span class="gi">+        try:</span>
<span class="gi">+            bits.append(f&quot;\033[{_interpret_color(fg)}m&quot;)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            raise TypeError(f&quot;Unknown color {fg!r}&quot;) from None</span>
<span class="gi">+</span>
<span class="gi">+    if bg:</span>
<span class="gi">+        try:</span>
<span class="gi">+            bits.append(f&quot;\033[{_interpret_color(bg, 10)}m&quot;)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            raise TypeError(f&quot;Unknown color {bg!r}&quot;) from None</span>
<span class="gi">+</span>
<span class="gi">+    if bold is not None:</span>
<span class="gi">+        bits.append(f&quot;\033[{1 if bold else 22}m&quot;)</span>
<span class="gi">+    if dim is not None:</span>
<span class="gi">+        bits.append(f&quot;\033[{2 if dim else 22}m&quot;)</span>
<span class="gi">+    if underline is not None:</span>
<span class="gi">+        bits.append(f&quot;\033[{4 if underline else 24}m&quot;)</span>
<span class="gi">+    if overline is not None:</span>
<span class="gi">+        bits.append(f&quot;\033[{53 if overline else 55}m&quot;)</span>
<span class="gi">+    if italic is not None:</span>
<span class="gi">+        bits.append(f&quot;\033[{3 if italic else 23}m&quot;)</span>
<span class="gi">+    if blink is not None:</span>
<span class="gi">+        bits.append(f&quot;\033[{5 if blink else 25}m&quot;)</span>
<span class="gi">+    if reverse is not None:</span>
<span class="gi">+        bits.append(f&quot;\033[{7 if reverse else 27}m&quot;)</span>
<span class="gi">+    if strikethrough is not None:</span>
<span class="gi">+        bits.append(f&quot;\033[{9 if strikethrough else 29}m&quot;)</span>
<span class="gi">+    bits.append(text)</span>
<span class="gi">+    if reset:</span>
<span class="gi">+        bits.append(_ansi_reset_all)</span>
<span class="gi">+    return &quot;&quot;.join(bits)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def unstyle(text: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Removes ANSI styling information from a string.  Usually it&#39;s not
<span class="w"> </span>    necessary to use this function as Click&#39;s echo function will
<span class="w"> </span>    automatically remove styling if necessary.
<span class="gu">@@ -345,12 +597,17 @@ def unstyle(text: str) -&gt;str:</span>

<span class="w"> </span>    :param text: the text to remove style information from.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return strip_ansi(text)</span>


<span class="gd">-def secho(message: t.Optional[t.Any]=None, file: t.Optional[t.IO[t.AnyStr]]</span>
<span class="gd">-    =None, nl: bool=True, err: bool=False, color: t.Optional[bool]=None, **</span>
<span class="gd">-    styles: t.Any) -&gt;None:</span>
<span class="gi">+def secho(</span>
<span class="gi">+    message: t.Optional[t.Any] = None,</span>
<span class="gi">+    file: t.Optional[t.IO[t.AnyStr]] = None,</span>
<span class="gi">+    nl: bool = True,</span>
<span class="gi">+    err: bool = False,</span>
<span class="gi">+    color: t.Optional[bool] = None,</span>
<span class="gi">+    **styles: t.Any,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;This function combines :func:`echo` and :func:`style` into one
<span class="w"> </span>    call.  As such the following two calls are the same::

<span class="gu">@@ -371,14 +628,21 @@ def secho(message: t.Optional[t.Any]=None, file: t.Optional[t.IO[t.AnyStr]]</span>

<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if message is not None and not isinstance(message, (bytes, bytearray)):</span>
<span class="gi">+        message = style(message, **styles)</span>

<span class="gi">+    return echo(message, file=file, nl=nl, err=err, color=color)</span>

<span class="gd">-def edit(text: t.Optional[t.AnyStr]=None, editor: t.Optional[str]=None, env:</span>
<span class="gd">-    t.Optional[t.Mapping[str, str]]=None, require_save: bool=True,</span>
<span class="gd">-    extension: str=&#39;.txt&#39;, filename: t.Optional[str]=None) -&gt;t.Optional[t.</span>
<span class="gd">-    AnyStr]:</span>
<span class="gd">-    &quot;&quot;&quot;Edits the given text in the defined editor.  If an editor is given</span>
<span class="gi">+</span>
<span class="gi">+def edit(</span>
<span class="gi">+    text: t.Optional[t.AnyStr] = None,</span>
<span class="gi">+    editor: t.Optional[str] = None,</span>
<span class="gi">+    env: t.Optional[t.Mapping[str, str]] = None,</span>
<span class="gi">+    require_save: bool = True,</span>
<span class="gi">+    extension: str = &quot;.txt&quot;,</span>
<span class="gi">+    filename: t.Optional[str] = None,</span>
<span class="gi">+) -&gt; t.Optional[t.AnyStr]:</span>
<span class="gi">+    r&quot;&quot;&quot;Edits the given text in the defined editor.  If an editor is given</span>
<span class="w"> </span>    (should be the full path to the executable but the regular operating
<span class="w"> </span>    system search path is used for finding the executable) it overrides
<span class="w"> </span>    the detected editor.  Optionally, some environment variables can be
<span class="gu">@@ -390,7 +654,7 @@ def edit(text: t.Optional[t.AnyStr]=None, editor: t.Optional[str]=None, env:</span>

<span class="w"> </span>    Note for Windows: to simplify cross-platform usage, the newlines are
<span class="w"> </span>    automatically converted from POSIX to Windows and vice versa.  As such,
<span class="gd">-    the message here will have ``\\n`` as newline markers.</span>
<span class="gi">+    the message here will have ``\n`` as newline markers.</span>

<span class="w"> </span>    :param text: the text to edit.
<span class="w"> </span>    :param editor: optionally the editor to use.  Defaults to automatic
<span class="gu">@@ -405,10 +669,18 @@ def edit(text: t.Optional[t.AnyStr]=None, editor: t.Optional[str]=None, env:</span>
<span class="w"> </span>                     provided text contents.  It will not use a temporary
<span class="w"> </span>                     file as an indirection in that case.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ._termui_impl import Editor</span>
<span class="gi">+</span>
<span class="gi">+    ed = Editor(editor=editor, env=env, require_save=require_save, extension=extension)</span>

<span class="gi">+    if filename is None:</span>
<span class="gi">+        return ed.edit(text)</span>

<span class="gd">-def launch(url: str, wait: bool=False, locate: bool=False) -&gt;int:</span>
<span class="gi">+    ed.edit_file(filename)</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def launch(url: str, wait: bool = False, locate: bool = False) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;This function launches the given URL (or filename) in the default
<span class="w"> </span>    viewer application for this file type.  If this is an executable, it
<span class="w"> </span>    might launch the executable in a new session.  The return value is
<span class="gu">@@ -432,13 +704,17 @@ def launch(url: str, wait: bool=False, locate: bool=False) -&gt;int:</span>
<span class="w"> </span>                   might have weird effects if the URL does not point to
<span class="w"> </span>                   the filesystem.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ._termui_impl import open_url</span>
<span class="gi">+</span>
<span class="gi">+    return open_url(url, wait=wait, locate=locate)</span>


<span class="gi">+# If this is provided, getchar() calls into this instead.  This is used</span>
<span class="gi">+# for unittesting purposes.</span>
<span class="w"> </span>_getchar: t.Optional[t.Callable[[bool], str]] = None


<span class="gd">-def getchar(echo: bool=False) -&gt;str:</span>
<span class="gi">+def getchar(echo: bool = False) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Fetches a single character from the terminal and returns it.  This
<span class="w"> </span>    will always return a unicode character and under certain rare
<span class="w"> </span>    circumstances this might return more than one character.  The
<span class="gu">@@ -458,10 +734,23 @@ def getchar(echo: bool=False) -&gt;str:</span>
<span class="w"> </span>    :param echo: if set to `True`, the character read will also show up on
<span class="w"> </span>                 the terminal.  The default is to not show it.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _getchar</span>
<span class="gi">+</span>
<span class="gi">+    if _getchar is None:</span>
<span class="gi">+        from ._termui_impl import getchar as f</span>
<span class="gi">+</span>
<span class="gi">+        _getchar = f</span>
<span class="gi">+</span>
<span class="gi">+    return _getchar(echo)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def raw_terminal() -&gt; t.ContextManager[int]:</span>
<span class="gi">+    from ._termui_impl import raw_terminal as f</span>
<span class="gi">+</span>
<span class="gi">+    return f()</span>


<span class="gd">-def pause(info: t.Optional[str]=None, err: bool=False) -&gt;None:</span>
<span class="gi">+def pause(info: t.Optional[str] = None, err: bool = False) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;This command stops execution and waits for the user to press any
<span class="w"> </span>    key to continue.  This is similar to the Windows batch &quot;pause&quot;
<span class="w"> </span>    command.  If the program is not run through a terminal, this command
<span class="gu">@@ -477,4 +766,19 @@ def pause(info: t.Optional[str]=None, err: bool=False) -&gt;None:</span>
<span class="w"> </span>    :param err: if set to message goes to ``stderr`` instead of
<span class="w"> </span>                ``stdout``, the same as with echo.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isatty(sys.stdin) or not isatty(sys.stdout):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if info is None:</span>
<span class="gi">+        info = _(&quot;Press any key to continue...&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        if info:</span>
<span class="gi">+            echo(info, nl=False, err=err)</span>
<span class="gi">+        try:</span>
<span class="gi">+            getchar()</span>
<span class="gi">+        except (KeyboardInterrupt, EOFError):</span>
<span class="gi">+            pass</span>
<span class="gi">+    finally:</span>
<span class="gi">+        if info:</span>
<span class="gi">+            echo(err=err)</span>
<span class="gh">diff --git a/src/click/testing.py b/src/click/testing.py</span>
<span class="gh">index 320d223..e0df0d2 100644</span>
<span class="gd">--- a/src/click/testing.py</span>
<span class="gi">+++ b/src/click/testing.py</span>
<span class="gu">@@ -7,73 +7,153 @@ import sys</span>
<span class="w"> </span>import tempfile
<span class="w"> </span>import typing as t
<span class="w"> </span>from types import TracebackType
<span class="gi">+</span>
<span class="w"> </span>from . import formatting
<span class="w"> </span>from . import termui
<span class="w"> </span>from . import utils
<span class="w"> </span>from ._compat import _find_binary_reader
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    from .core import BaseCommand


<span class="w"> </span>class EchoingStdin:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, input: t.BinaryIO, output: t.BinaryIO) -&gt;None:</span>
<span class="gi">+    def __init__(self, input: t.BinaryIO, output: t.BinaryIO) -&gt; None:</span>
<span class="w"> </span>        self._input = input
<span class="w"> </span>        self._output = output
<span class="w"> </span>        self._paused = False

<span class="gd">-    def __getattr__(self, x: str) -&gt;t.Any:</span>
<span class="gi">+    def __getattr__(self, x: str) -&gt; t.Any:</span>
<span class="w"> </span>        return getattr(self._input, x)

<span class="gd">-    def __iter__(self) -&gt;t.Iterator[bytes]:</span>
<span class="gi">+    def _echo(self, rv: bytes) -&gt; bytes:</span>
<span class="gi">+        if not self._paused:</span>
<span class="gi">+            self._output.write(rv)</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def read(self, n: int = -1) -&gt; bytes:</span>
<span class="gi">+        return self._echo(self._input.read(n))</span>
<span class="gi">+</span>
<span class="gi">+    def read1(self, n: int = -1) -&gt; bytes:</span>
<span class="gi">+        return self._echo(self._input.read1(n))  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def readline(self, n: int = -1) -&gt; bytes:</span>
<span class="gi">+        return self._echo(self._input.readline(n))</span>
<span class="gi">+</span>
<span class="gi">+    def readlines(self) -&gt; t.List[bytes]:</span>
<span class="gi">+        return [self._echo(x) for x in self._input.readlines()]</span>
<span class="gi">+</span>
<span class="gi">+    def __iter__(self) -&gt; t.Iterator[bytes]:</span>
<span class="w"> </span>        return iter(self._echo(x) for x in self._input)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return repr(self._input)


<span class="gd">-class _NamedTextIOWrapper(io.TextIOWrapper):</span>
<span class="gi">+@contextlib.contextmanager</span>
<span class="gi">+def _pause_echo(stream: t.Optional[EchoingStdin]) -&gt; t.Iterator[None]:</span>
<span class="gi">+    if stream is None:</span>
<span class="gi">+        yield</span>
<span class="gi">+    else:</span>
<span class="gi">+        stream._paused = True</span>
<span class="gi">+        yield</span>
<span class="gi">+        stream._paused = False</span>
<span class="gi">+</span>

<span class="gd">-    def __init__(self, buffer: t.BinaryIO, name: str, mode: str, **kwargs:</span>
<span class="gd">-        t.Any) -&gt;None:</span>
<span class="gi">+class _NamedTextIOWrapper(io.TextIOWrapper):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, buffer: t.BinaryIO, name: str, mode: str, **kwargs: t.Any</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(buffer, **kwargs)
<span class="w"> </span>        self._name = name
<span class="w"> </span>        self._mode = mode

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; str:</span>
<span class="gi">+        return self._name</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def mode(self) -&gt; str:</span>
<span class="gi">+        return self._mode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_input_stream(</span>
<span class="gi">+    input: t.Optional[t.Union[str, bytes, t.IO[t.Any]]], charset: str</span>
<span class="gi">+) -&gt; t.BinaryIO:</span>
<span class="gi">+    # Is already an input stream.</span>
<span class="gi">+    if hasattr(input, &quot;read&quot;):</span>
<span class="gi">+        rv = _find_binary_reader(t.cast(t.IO[t.Any], input))</span>
<span class="gi">+</span>
<span class="gi">+        if rv is not None:</span>
<span class="gi">+            return rv</span>
<span class="gi">+</span>
<span class="gi">+        raise TypeError(&quot;Could not find binary reader for input stream.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if input is None:</span>
<span class="gi">+        input = b&quot;&quot;</span>
<span class="gi">+    elif isinstance(input, str):</span>
<span class="gi">+        input = input.encode(charset)</span>
<span class="gi">+</span>
<span class="gi">+    return io.BytesIO(input)</span>
<span class="gi">+</span>

<span class="w"> </span>class Result:
<span class="w"> </span>    &quot;&quot;&quot;Holds the captured result of an invoked CLI script.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, runner: &#39;CliRunner&#39;, stdout_bytes: bytes,</span>
<span class="gd">-        stderr_bytes: t.Optional[bytes], return_value: t.Any, exit_code:</span>
<span class="gd">-        int, exception: t.Optional[BaseException], exc_info: t.Optional[t.</span>
<span class="gd">-        Tuple[t.Type[BaseException], BaseException, TracebackType]]=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        runner: &quot;CliRunner&quot;,</span>
<span class="gi">+        stdout_bytes: bytes,</span>
<span class="gi">+        stderr_bytes: t.Optional[bytes],</span>
<span class="gi">+        return_value: t.Any,</span>
<span class="gi">+        exit_code: int,</span>
<span class="gi">+        exception: t.Optional[BaseException],</span>
<span class="gi">+        exc_info: t.Optional[</span>
<span class="gi">+            t.Tuple[t.Type[BaseException], BaseException, TracebackType]</span>
<span class="gi">+        ] = None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        #: The runner that created the result</span>
<span class="w"> </span>        self.runner = runner
<span class="gi">+        #: The standard output as bytes.</span>
<span class="w"> </span>        self.stdout_bytes = stdout_bytes
<span class="gi">+        #: The standard error as bytes, or None if not available</span>
<span class="w"> </span>        self.stderr_bytes = stderr_bytes
<span class="gi">+        #: The value returned from the invoked command.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: .. versionadded:: 8.0</span>
<span class="w"> </span>        self.return_value = return_value
<span class="gi">+        #: The exit code as integer.</span>
<span class="w"> </span>        self.exit_code = exit_code
<span class="gi">+        #: The exception that happened if one did.</span>
<span class="w"> </span>        self.exception = exception
<span class="gi">+        #: The traceback</span>
<span class="w"> </span>        self.exc_info = exc_info

<span class="w"> </span>    @property
<span class="gd">-    def output(self) -&gt;str:</span>
<span class="gi">+    def output(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;The (standard) output as unicode string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.stdout</span>

<span class="w"> </span>    @property
<span class="gd">-    def stdout(self) -&gt;str:</span>
<span class="gi">+    def stdout(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;The standard output as unicode string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.stdout_bytes.decode(self.runner.charset, &quot;replace&quot;).replace(</span>
<span class="gi">+            &quot;\r\n&quot;, &quot;\n&quot;</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @property
<span class="gd">-    def stderr(self) -&gt;str:</span>
<span class="gi">+    def stderr(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;The standard error as unicode string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.stderr_bytes is None:</span>
<span class="gi">+            raise ValueError(&quot;stderr not separately captured&quot;)</span>
<span class="gi">+        return self.stderr_bytes.decode(self.runner.charset, &quot;replace&quot;).replace(</span>
<span class="gi">+            &quot;\r\n&quot;, &quot;\n&quot;</span>
<span class="gi">+        )</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        exc_str = repr(self.exception) if self.exception else &#39;okay&#39;</span>
<span class="gd">-        return f&#39;&lt;{type(self).__name__} {exc_str}&gt;&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        exc_str = repr(self.exception) if self.exception else &quot;okay&quot;</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {exc_str}&gt;&quot;</span>


<span class="w"> </span>class CliRunner:
<span class="gu">@@ -95,30 +175,41 @@ class CliRunner:</span>
<span class="w"> </span>                       independently
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, charset: str=&#39;utf-8&#39;, env: t.Optional[t.Mapping[str,</span>
<span class="gd">-        t.Optional[str]]]=None, echo_stdin: bool=False, mix_stderr: bool=True</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        charset: str = &quot;utf-8&quot;,</span>
<span class="gi">+        env: t.Optional[t.Mapping[str, t.Optional[str]]] = None,</span>
<span class="gi">+        echo_stdin: bool = False,</span>
<span class="gi">+        mix_stderr: bool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.charset = charset
<span class="w"> </span>        self.env: t.Mapping[str, t.Optional[str]] = env or {}
<span class="w"> </span>        self.echo_stdin = echo_stdin
<span class="w"> </span>        self.mix_stderr = mix_stderr

<span class="gd">-    def get_default_prog_name(self, cli: &#39;BaseCommand&#39;) -&gt;str:</span>
<span class="gi">+    def get_default_prog_name(self, cli: &quot;BaseCommand&quot;) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given a command object it will return the default program name
<span class="w"> </span>        for it.  The default is the `name` attribute or ``&quot;root&quot;`` if not
<span class="w"> </span>        set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cli.name or &quot;root&quot;</span>

<span class="gd">-    def make_env(self, overrides: t.Optional[t.Mapping[str, t.Optional[str]</span>
<span class="gd">-        ]]=None) -&gt;t.Mapping[str, t.Optional[str]]:</span>
<span class="gi">+    def make_env(</span>
<span class="gi">+        self, overrides: t.Optional[t.Mapping[str, t.Optional[str]]] = None</span>
<span class="gi">+    ) -&gt; t.Mapping[str, t.Optional[str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the environment overrides for invoking a script.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = dict(self.env)</span>
<span class="gi">+        if overrides:</span>
<span class="gi">+            rv.update(overrides)</span>
<span class="gi">+        return rv</span>

<span class="w"> </span>    @contextlib.contextmanager
<span class="gd">-    def isolation(self, input: t.Optional[t.Union[str, bytes, t.IO[t.Any]]]</span>
<span class="gd">-        =None, env: t.Optional[t.Mapping[str, t.Optional[str]]]=None, color:</span>
<span class="gd">-        bool=False) -&gt;t.Iterator[t.Tuple[io.BytesIO, t.Optional[io.BytesIO]]]:</span>
<span class="gi">+    def isolation(</span>
<span class="gi">+        self,</span>
<span class="gi">+        input: t.Optional[t.Union[str, bytes, t.IO[t.Any]]] = None,</span>
<span class="gi">+        env: t.Optional[t.Mapping[str, t.Optional[str]]] = None,</span>
<span class="gi">+        color: bool = False,</span>
<span class="gi">+    ) -&gt; t.Iterator[t.Tuple[io.BytesIO, t.Optional[io.BytesIO]]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;A context manager that sets up the isolation for invoking of a
<span class="w"> </span>        command line tool.  This sets up stdin with the given input data
<span class="w"> </span>        and `os.environ` with the overrides from the given dictionary.
<span class="gu">@@ -139,13 +230,132 @@ class CliRunner:</span>
<span class="w"> </span>        .. versionchanged:: 4.0
<span class="w"> </span>            Added the ``color`` parameter.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def invoke(self, cli: &#39;BaseCommand&#39;, args: t.Optional[t.Union[str, t.</span>
<span class="gd">-        Sequence[str]]]=None, input: t.Optional[t.Union[str, bytes, t.IO[t.</span>
<span class="gd">-        Any]]]=None, env: t.Optional[t.Mapping[str, t.Optional[str]]]=None,</span>
<span class="gd">-        catch_exceptions: bool=True, color: bool=False, **extra: t.Any</span>
<span class="gd">-        ) -&gt;Result:</span>
<span class="gi">+        bytes_input = make_input_stream(input, self.charset)</span>
<span class="gi">+        echo_input = None</span>
<span class="gi">+</span>
<span class="gi">+        old_stdin = sys.stdin</span>
<span class="gi">+        old_stdout = sys.stdout</span>
<span class="gi">+        old_stderr = sys.stderr</span>
<span class="gi">+        old_forced_width = formatting.FORCED_WIDTH</span>
<span class="gi">+        formatting.FORCED_WIDTH = 80</span>
<span class="gi">+</span>
<span class="gi">+        env = self.make_env(env)</span>
<span class="gi">+</span>
<span class="gi">+        bytes_output = io.BytesIO()</span>
<span class="gi">+</span>
<span class="gi">+        if self.echo_stdin:</span>
<span class="gi">+            bytes_input = echo_input = t.cast(</span>
<span class="gi">+                t.BinaryIO, EchoingStdin(bytes_input, bytes_output)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        sys.stdin = text_input = _NamedTextIOWrapper(</span>
<span class="gi">+            bytes_input, encoding=self.charset, name=&quot;&lt;stdin&gt;&quot;, mode=&quot;r&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if self.echo_stdin:</span>
<span class="gi">+            # Force unbuffered reads, otherwise TextIOWrapper reads a</span>
<span class="gi">+            # large chunk which is echoed early.</span>
<span class="gi">+            text_input._CHUNK_SIZE = 1  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        sys.stdout = _NamedTextIOWrapper(</span>
<span class="gi">+            bytes_output, encoding=self.charset, name=&quot;&lt;stdout&gt;&quot;, mode=&quot;w&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        bytes_error = None</span>
<span class="gi">+        if self.mix_stderr:</span>
<span class="gi">+            sys.stderr = sys.stdout</span>
<span class="gi">+        else:</span>
<span class="gi">+            bytes_error = io.BytesIO()</span>
<span class="gi">+            sys.stderr = _NamedTextIOWrapper(</span>
<span class="gi">+                bytes_error,</span>
<span class="gi">+                encoding=self.charset,</span>
<span class="gi">+                name=&quot;&lt;stderr&gt;&quot;,</span>
<span class="gi">+                mode=&quot;w&quot;,</span>
<span class="gi">+                errors=&quot;backslashreplace&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        @_pause_echo(echo_input)  # type: ignore</span>
<span class="gi">+        def visible_input(prompt: t.Optional[str] = None) -&gt; str:</span>
<span class="gi">+            sys.stdout.write(prompt or &quot;&quot;)</span>
<span class="gi">+            val = text_input.readline().rstrip(&quot;\r\n&quot;)</span>
<span class="gi">+            sys.stdout.write(f&quot;{val}\n&quot;)</span>
<span class="gi">+            sys.stdout.flush()</span>
<span class="gi">+            return val</span>
<span class="gi">+</span>
<span class="gi">+        @_pause_echo(echo_input)  # type: ignore</span>
<span class="gi">+        def hidden_input(prompt: t.Optional[str] = None) -&gt; str:</span>
<span class="gi">+            sys.stdout.write(f&quot;{prompt or &#39;&#39;}\n&quot;)</span>
<span class="gi">+            sys.stdout.flush()</span>
<span class="gi">+            return text_input.readline().rstrip(&quot;\r\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        @_pause_echo(echo_input)  # type: ignore</span>
<span class="gi">+        def _getchar(echo: bool) -&gt; str:</span>
<span class="gi">+            char = sys.stdin.read(1)</span>
<span class="gi">+</span>
<span class="gi">+            if echo:</span>
<span class="gi">+                sys.stdout.write(char)</span>
<span class="gi">+</span>
<span class="gi">+            sys.stdout.flush()</span>
<span class="gi">+            return char</span>
<span class="gi">+</span>
<span class="gi">+        default_color = color</span>
<span class="gi">+</span>
<span class="gi">+        def should_strip_ansi(</span>
<span class="gi">+            stream: t.Optional[t.IO[t.Any]] = None, color: t.Optional[bool] = None</span>
<span class="gi">+        ) -&gt; bool:</span>
<span class="gi">+            if color is None:</span>
<span class="gi">+                return not default_color</span>
<span class="gi">+            return not color</span>
<span class="gi">+</span>
<span class="gi">+        old_visible_prompt_func = termui.visible_prompt_func</span>
<span class="gi">+        old_hidden_prompt_func = termui.hidden_prompt_func</span>
<span class="gi">+        old__getchar_func = termui._getchar</span>
<span class="gi">+        old_should_strip_ansi = utils.should_strip_ansi  # type: ignore</span>
<span class="gi">+        termui.visible_prompt_func = visible_input</span>
<span class="gi">+        termui.hidden_prompt_func = hidden_input</span>
<span class="gi">+        termui._getchar = _getchar</span>
<span class="gi">+        utils.should_strip_ansi = should_strip_ansi  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        old_env = {}</span>
<span class="gi">+        try:</span>
<span class="gi">+            for key, value in env.items():</span>
<span class="gi">+                old_env[key] = os.environ.get(key)</span>
<span class="gi">+                if value is None:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        del os.environ[key]</span>
<span class="gi">+                    except Exception:</span>
<span class="gi">+                        pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    os.environ[key] = value</span>
<span class="gi">+            yield (bytes_output, bytes_error)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            for key, value in old_env.items():</span>
<span class="gi">+                if value is None:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        del os.environ[key]</span>
<span class="gi">+                    except Exception:</span>
<span class="gi">+                        pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    os.environ[key] = value</span>
<span class="gi">+            sys.stdout = old_stdout</span>
<span class="gi">+            sys.stderr = old_stderr</span>
<span class="gi">+            sys.stdin = old_stdin</span>
<span class="gi">+            termui.visible_prompt_func = old_visible_prompt_func</span>
<span class="gi">+            termui.hidden_prompt_func = old_hidden_prompt_func</span>
<span class="gi">+            termui._getchar = old__getchar_func</span>
<span class="gi">+            utils.should_strip_ansi = old_should_strip_ansi  # type: ignore</span>
<span class="gi">+            formatting.FORCED_WIDTH = old_forced_width</span>
<span class="gi">+</span>
<span class="gi">+    def invoke(</span>
<span class="gi">+        self,</span>
<span class="gi">+        cli: &quot;BaseCommand&quot;,</span>
<span class="gi">+        args: t.Optional[t.Union[str, t.Sequence[str]]] = None,</span>
<span class="gi">+        input: t.Optional[t.Union[str, bytes, t.IO[t.Any]]] = None,</span>
<span class="gi">+        env: t.Optional[t.Mapping[str, t.Optional[str]]] = None,</span>
<span class="gi">+        catch_exceptions: bool = True,</span>
<span class="gi">+        color: bool = False,</span>
<span class="gi">+        **extra: t.Any,</span>
<span class="gi">+    ) -&gt; Result:</span>
<span class="w"> </span>        &quot;&quot;&quot;Invokes a command in an isolated environment.  The arguments are
<span class="w"> </span>        forwarded directly to the command line script, the `extra` keyword
<span class="w"> </span>        arguments are passed to the :meth:`~clickpkg.Command.main` function of
<span class="gu">@@ -180,11 +390,67 @@ class CliRunner:</span>
<span class="w"> </span>            The result object has the ``exc_info`` attribute with the
<span class="w"> </span>            traceback if available.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        exc_info = None</span>
<span class="gi">+        with self.isolation(input=input, env=env, color=color) as outstreams:</span>
<span class="gi">+            return_value = None</span>
<span class="gi">+            exception: t.Optional[BaseException] = None</span>
<span class="gi">+            exit_code = 0</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(args, str):</span>
<span class="gi">+                args = shlex.split(args)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                prog_name = extra.pop(&quot;prog_name&quot;)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                prog_name = self.get_default_prog_name(cli)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                return_value = cli.main(args=args or (), prog_name=prog_name, **extra)</span>
<span class="gi">+            except SystemExit as e:</span>
<span class="gi">+                exc_info = sys.exc_info()</span>
<span class="gi">+                e_code = t.cast(t.Optional[t.Union[int, t.Any]], e.code)</span>
<span class="gi">+</span>
<span class="gi">+                if e_code is None:</span>
<span class="gi">+                    e_code = 0</span>
<span class="gi">+</span>
<span class="gi">+                if e_code != 0:</span>
<span class="gi">+                    exception = e</span>
<span class="gi">+</span>
<span class="gi">+                if not isinstance(e_code, int):</span>
<span class="gi">+                    sys.stdout.write(str(e_code))</span>
<span class="gi">+                    sys.stdout.write(&quot;\n&quot;)</span>
<span class="gi">+                    e_code = 1</span>
<span class="gi">+</span>
<span class="gi">+                exit_code = e_code</span>
<span class="gi">+</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                if not catch_exceptions:</span>
<span class="gi">+                    raise</span>
<span class="gi">+                exception = e</span>
<span class="gi">+                exit_code = 1</span>
<span class="gi">+                exc_info = sys.exc_info()</span>
<span class="gi">+            finally:</span>
<span class="gi">+                sys.stdout.flush()</span>
<span class="gi">+                stdout = outstreams[0].getvalue()</span>
<span class="gi">+                if self.mix_stderr:</span>
<span class="gi">+                    stderr = None</span>
<span class="gi">+                else:</span>
<span class="gi">+                    stderr = outstreams[1].getvalue()  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        return Result(</span>
<span class="gi">+            runner=self,</span>
<span class="gi">+            stdout_bytes=stdout,</span>
<span class="gi">+            stderr_bytes=stderr,</span>
<span class="gi">+            return_value=return_value,</span>
<span class="gi">+            exit_code=exit_code,</span>
<span class="gi">+            exception=exception,</span>
<span class="gi">+            exc_info=exc_info,  # type: ignore</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @contextlib.contextmanager
<span class="gd">-    def isolated_filesystem(self, temp_dir: t.Optional[t.Union[str,</span>
<span class="gd">-        &#39;os.PathLike[str]&#39;]]=None) -&gt;t.Iterator[str]:</span>
<span class="gi">+    def isolated_filesystem(</span>
<span class="gi">+        self, temp_dir: t.Optional[t.Union[str, &quot;os.PathLike[str]&quot;]] = None</span>
<span class="gi">+    ) -&gt; t.Iterator[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;A context manager that creates a temporary directory and
<span class="w"> </span>        changes the current working directory to it. This isolates tests
<span class="w"> </span>        that affect the contents of the CWD to prevent them from
<span class="gu">@@ -197,4 +463,17 @@ class CliRunner:</span>
<span class="w"> </span>        .. versionchanged:: 8.0
<span class="w"> </span>            Added the ``temp_dir`` parameter.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cwd = os.getcwd()</span>
<span class="gi">+        dt = tempfile.mkdtemp(dir=temp_dir)</span>
<span class="gi">+        os.chdir(dt)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield dt</span>
<span class="gi">+        finally:</span>
<span class="gi">+            os.chdir(cwd)</span>
<span class="gi">+</span>
<span class="gi">+            if temp_dir is None:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    shutil.rmtree(dt)</span>
<span class="gi">+                except OSError:  # noqa: B014</span>
<span class="gi">+                    pass</span>
<span class="gh">diff --git a/src/click/types.py b/src/click/types.py</span>
<span class="gh">index 4527388..2b1d179 100644</span>
<span class="gd">--- a/src/click/types.py</span>
<span class="gi">+++ b/src/click/types.py</span>
<span class="gu">@@ -5,12 +5,14 @@ import typing as t</span>
<span class="w"> </span>from datetime import datetime
<span class="w"> </span>from gettext import gettext as _
<span class="w"> </span>from gettext import ngettext
<span class="gi">+</span>
<span class="w"> </span>from ._compat import _get_argv_encoding
<span class="w"> </span>from ._compat import open_stream
<span class="w"> </span>from .exceptions import BadParameter
<span class="w"> </span>from .utils import format_filename
<span class="w"> </span>from .utils import LazyFile
<span class="w"> </span>from .utils import safecall
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="w"> </span>    from .core import Context
<span class="gu">@@ -35,12 +37,22 @@ class ParamType:</span>
<span class="w"> </span>        arguments are ``None``. This can occur when converting prompt
<span class="w"> </span>        input.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    is_composite: t.ClassVar[bool] = False
<span class="w"> </span>    arity: t.ClassVar[int] = 1
<span class="gi">+</span>
<span class="gi">+    #: the descriptive name of this type</span>
<span class="w"> </span>    name: str
<span class="gi">+</span>
<span class="gi">+    #: if a list of this type is expected and the value is pulled from a</span>
<span class="gi">+    #: string environment variable, this is what splits it up.  `None`</span>
<span class="gi">+    #: means any whitespace.  For all parameters the general rule is that</span>
<span class="gi">+    #: whitespace splits them up.  The exception are paths and files which</span>
<span class="gi">+    #: are split by ``os.path.pathsep`` by default (&quot;:&quot; on Unix and &quot;;&quot; on</span>
<span class="gi">+    #: Windows).</span>
<span class="w"> </span>    envvar_list_splitter: t.ClassVar[t.Optional[str]] = None

<span class="gd">-    def to_info_dict(self) -&gt;t.Dict[str, t.Any]:</span>
<span class="gi">+    def to_info_dict(self) -&gt; t.Dict[str, t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Gather information that could be useful for a tool generating
<span class="w"> </span>        user-facing documentation.

<span class="gu">@@ -49,27 +61,40 @@ class ParamType:</span>

<span class="w"> </span>        .. versionadded:: 8.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # The class name without the &quot;ParamType&quot; suffix.</span>
<span class="gi">+        param_type = type(self).__name__.partition(&quot;ParamType&quot;)[0]</span>
<span class="gi">+        param_type = param_type.partition(&quot;ParameterType&quot;)[0]</span>

<span class="gd">-    def __call__(self, value: t.Any, param: t.Optional[&#39;Parameter&#39;]=None,</span>
<span class="gd">-        ctx: t.Optional[&#39;Context&#39;]=None) -&gt;t.Any:</span>
<span class="gi">+        # Custom subclasses might not remember to set a name.</span>
<span class="gi">+        if hasattr(self, &quot;name&quot;):</span>
<span class="gi">+            name = self.name</span>
<span class="gi">+        else:</span>
<span class="gi">+            name = param_type</span>
<span class="gi">+</span>
<span class="gi">+        return {&quot;param_type&quot;: param_type, &quot;name&quot;: name}</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        value: t.Any,</span>
<span class="gi">+        param: t.Optional[&quot;Parameter&quot;] = None,</span>
<span class="gi">+        ctx: t.Optional[&quot;Context&quot;] = None,</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="w"> </span>        if value is not None:
<span class="w"> </span>            return self.convert(value, param, ctx)

<span class="gd">-    def get_metavar(self, param: &#39;Parameter&#39;) -&gt;t.Optional[str]:</span>
<span class="gi">+    def get_metavar(self, param: &quot;Parameter&quot;) -&gt; t.Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the metavar default for this param if it provides one.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_missing_message(self, param: &#39;Parameter&#39;) -&gt;t.Optional[str]:</span>
<span class="gi">+    def get_missing_message(self, param: &quot;Parameter&quot;) -&gt; t.Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Optionally might return extra information about a missing
<span class="w"> </span>        parameter.

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def convert(self, value: t.Any, param: t.Optional[&#39;Parameter&#39;], ctx: t.</span>
<span class="gd">-        Optional[&#39;Context&#39;]) -&gt;t.Any:</span>
<span class="gi">+    def convert(</span>
<span class="gi">+        self, value: t.Any, param: t.Optional[&quot;Parameter&quot;], ctx: t.Optional[&quot;Context&quot;]</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert the value to the correct type. This is not called if
<span class="w"> </span>        the value is ``None`` (the missing value).

<span class="gu">@@ -89,9 +114,9 @@ class ParamType:</span>
<span class="w"> </span>        :param ctx: The current context that arrived at this value. May
<span class="w"> </span>            be ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return value</span>

<span class="gd">-    def split_envvar_value(self, rv: str) -&gt;t.Sequence[str]:</span>
<span class="gi">+    def split_envvar_value(self, rv: str) -&gt; t.Sequence[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given a value from an environment variable this splits it up
<span class="w"> </span>        into small chunks depending on the defined envvar list splitter.

<span class="gu">@@ -99,15 +124,20 @@ class ParamType:</span>
<span class="w"> </span>        then leading and trailing whitespace is ignored.  Otherwise, leading
<span class="w"> </span>        and trailing splitters usually lead to empty items being included.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def fail(self, message: str, param: t.Optional[&#39;Parameter&#39;]=None, ctx:</span>
<span class="gd">-        t.Optional[&#39;Context&#39;]=None) -&gt;&#39;t.NoReturn&#39;:</span>
<span class="gi">+        return (rv or &quot;&quot;).split(self.envvar_list_splitter)</span>
<span class="gi">+</span>
<span class="gi">+    def fail(</span>
<span class="gi">+        self,</span>
<span class="gi">+        message: str,</span>
<span class="gi">+        param: t.Optional[&quot;Parameter&quot;] = None,</span>
<span class="gi">+        ctx: t.Optional[&quot;Context&quot;] = None,</span>
<span class="gi">+    ) -&gt; &quot;t.NoReturn&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Helper method to fail with an invalid value message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise BadParameter(message, ctx=ctx, param=param)</span>

<span class="gd">-    def shell_complete(self, ctx: &#39;Context&#39;, param: &#39;Parameter&#39;, incomplete:</span>
<span class="gd">-        str) -&gt;t.List[&#39;CompletionItem&#39;]:</span>
<span class="gi">+    def shell_complete(</span>
<span class="gi">+        self, ctx: &quot;Context&quot;, param: &quot;Parameter&quot;, incomplete: str</span>
<span class="gi">+    ) -&gt; t.List[&quot;CompletionItem&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of
<span class="w"> </span>        :class:`~click.shell_completion.CompletionItem` objects for the
<span class="w"> </span>        incomplete value. Most types do not provide completions, but
<span class="gu">@@ -120,32 +150,77 @@ class ParamType:</span>

<span class="w"> </span>        .. versionadded:: 8.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>


<span class="w"> </span>class CompositeParamType(ParamType):
<span class="w"> </span>    is_composite = True

<span class="gi">+    @property</span>
<span class="gi">+    def arity(self) -&gt; int:  # type: ignore</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-class FuncParamType(ParamType):</span>

<span class="gd">-    def __init__(self, func: t.Callable[[t.Any], t.Any]) -&gt;None:</span>
<span class="gi">+class FuncParamType(ParamType):</span>
<span class="gi">+    def __init__(self, func: t.Callable[[t.Any], t.Any]) -&gt; None:</span>
<span class="w"> </span>        self.name: str = func.__name__
<span class="w"> </span>        self.func = func

<span class="gi">+    def to_info_dict(self) -&gt; t.Dict[str, t.Any]:</span>
<span class="gi">+        info_dict = super().to_info_dict()</span>
<span class="gi">+        info_dict[&quot;func&quot;] = self.func</span>
<span class="gi">+        return info_dict</span>
<span class="gi">+</span>
<span class="gi">+    def convert(</span>
<span class="gi">+        self, value: t.Any, param: t.Optional[&quot;Parameter&quot;], ctx: t.Optional[&quot;Context&quot;]</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.func(value)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            try:</span>
<span class="gi">+                value = str(value)</span>
<span class="gi">+            except UnicodeError:</span>
<span class="gi">+                value = value.decode(&quot;utf-8&quot;, &quot;replace&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            self.fail(value, param, ctx)</span>
<span class="gi">+</span>

<span class="w"> </span>class UnprocessedParamType(ParamType):
<span class="gd">-    name = &#39;text&#39;</span>
<span class="gi">+    name = &quot;text&quot;</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;UNPROCESSED&#39;</span>
<span class="gi">+    def convert(</span>
<span class="gi">+        self, value: t.Any, param: t.Optional[&quot;Parameter&quot;], ctx: t.Optional[&quot;Context&quot;]</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        return value</span>

<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;UNPROCESSED&quot;</span>

<span class="gd">-class StringParamType(ParamType):</span>
<span class="gd">-    name = &#39;text&#39;</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;STRING&#39;</span>
<span class="gi">+class StringParamType(ParamType):</span>
<span class="gi">+    name = &quot;text&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def convert(</span>
<span class="gi">+        self, value: t.Any, param: t.Optional[&quot;Parameter&quot;], ctx: t.Optional[&quot;Context&quot;]</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        if isinstance(value, bytes):</span>
<span class="gi">+            enc = _get_argv_encoding()</span>
<span class="gi">+            try:</span>
<span class="gi">+                value = value.decode(enc)</span>
<span class="gi">+            except UnicodeError:</span>
<span class="gi">+                fs_enc = sys.getfilesystemencoding()</span>
<span class="gi">+                if fs_enc != enc:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        value = value.decode(fs_enc)</span>
<span class="gi">+                    except UnicodeError:</span>
<span class="gi">+                        value = value.decode(&quot;utf-8&quot;, &quot;replace&quot;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    value = value.decode(&quot;utf-8&quot;, &quot;replace&quot;)</span>
<span class="gi">+            return value</span>
<span class="gi">+        return str(value)</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;STRING&quot;</span>


<span class="w"> </span>class Choice(ParamType):
<span class="gu">@@ -164,18 +239,76 @@ class Choice(ParamType):</span>
<span class="w"> </span>    :param case_sensitive: Set to false to make choices case
<span class="w"> </span>        insensitive. Defaults to true.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;choice&#39;</span>

<span class="gd">-    def __init__(self, choices: t.Sequence[str], case_sensitive: bool=True</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    name = &quot;choice&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, choices: t.Sequence[str], case_sensitive: bool = True) -&gt; None:</span>
<span class="w"> </span>        self.choices = choices
<span class="w"> </span>        self.case_sensitive = case_sensitive

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;Choice({list(self.choices)})&#39;</span>
<span class="gd">-</span>
<span class="gd">-    def shell_complete(self, ctx: &#39;Context&#39;, param: &#39;Parameter&#39;, incomplete:</span>
<span class="gd">-        str) -&gt;t.List[&#39;CompletionItem&#39;]:</span>
<span class="gi">+    def to_info_dict(self) -&gt; t.Dict[str, t.Any]:</span>
<span class="gi">+        info_dict = super().to_info_dict()</span>
<span class="gi">+        info_dict[&quot;choices&quot;] = self.choices</span>
<span class="gi">+        info_dict[&quot;case_sensitive&quot;] = self.case_sensitive</span>
<span class="gi">+        return info_dict</span>
<span class="gi">+</span>
<span class="gi">+    def get_metavar(self, param: &quot;Parameter&quot;) -&gt; str:</span>
<span class="gi">+        choices_str = &quot;|&quot;.join(self.choices)</span>
<span class="gi">+</span>
<span class="gi">+        # Use curly braces to indicate a required argument.</span>
<span class="gi">+        if param.required and param.param_type_name == &quot;argument&quot;:</span>
<span class="gi">+            return f&quot;{{{choices_str}}}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Use square braces to indicate an option or optional argument.</span>
<span class="gi">+        return f&quot;[{choices_str}]&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def get_missing_message(self, param: &quot;Parameter&quot;) -&gt; str:</span>
<span class="gi">+        return _(&quot;Choose from:\n\t{choices}&quot;).format(choices=&quot;,\n\t&quot;.join(self.choices))</span>
<span class="gi">+</span>
<span class="gi">+    def convert(</span>
<span class="gi">+        self, value: t.Any, param: t.Optional[&quot;Parameter&quot;], ctx: t.Optional[&quot;Context&quot;]</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        # Match through normalization and case sensitivity</span>
<span class="gi">+        # first do token_normalize_func, then lowercase</span>
<span class="gi">+        # preserve original `value` to produce an accurate message in</span>
<span class="gi">+        # `self.fail`</span>
<span class="gi">+        normed_value = value</span>
<span class="gi">+        normed_choices = {choice: choice for choice in self.choices}</span>
<span class="gi">+</span>
<span class="gi">+        if ctx is not None and ctx.token_normalize_func is not None:</span>
<span class="gi">+            normed_value = ctx.token_normalize_func(value)</span>
<span class="gi">+            normed_choices = {</span>
<span class="gi">+                ctx.token_normalize_func(normed_choice): original</span>
<span class="gi">+                for normed_choice, original in normed_choices.items()</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        if not self.case_sensitive:</span>
<span class="gi">+            normed_value = normed_value.casefold()</span>
<span class="gi">+            normed_choices = {</span>
<span class="gi">+                normed_choice.casefold(): original</span>
<span class="gi">+                for normed_choice, original in normed_choices.items()</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        if normed_value in normed_choices:</span>
<span class="gi">+            return normed_choices[normed_value]</span>
<span class="gi">+</span>
<span class="gi">+        choices_str = &quot;, &quot;.join(map(repr, self.choices))</span>
<span class="gi">+        self.fail(</span>
<span class="gi">+            ngettext(</span>
<span class="gi">+                &quot;{value!r} is not {choice}.&quot;,</span>
<span class="gi">+                &quot;{value!r} is not one of {choices}.&quot;,</span>
<span class="gi">+                len(self.choices),</span>
<span class="gi">+            ).format(value=value, choice=choices_str, choices=choices_str),</span>
<span class="gi">+            param,</span>
<span class="gi">+            ctx,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;Choice({list(self.choices)})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def shell_complete(</span>
<span class="gi">+        self, ctx: &quot;Context&quot;, param: &quot;Parameter&quot;, incomplete: str</span>
<span class="gi">+    ) -&gt; t.List[&quot;CompletionItem&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Complete choices that start with the incomplete value.

<span class="w"> </span>        :param ctx: Invocation context for this command.
<span class="gu">@@ -184,7 +317,17 @@ class Choice(ParamType):</span>

<span class="w"> </span>        .. versionadded:: 8.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from click.shell_completion import CompletionItem</span>
<span class="gi">+</span>
<span class="gi">+        str_choices = map(str, self.choices)</span>
<span class="gi">+</span>
<span class="gi">+        if self.case_sensitive:</span>
<span class="gi">+            matched = (c for c in str_choices if c.startswith(incomplete))</span>
<span class="gi">+        else:</span>
<span class="gi">+            incomplete = incomplete.lower()</span>
<span class="gi">+            matched = (c for c in str_choices if c.lower().startswith(incomplete))</span>
<span class="gi">+</span>
<span class="gi">+        return [CompletionItem(c) for c in matched]</span>


<span class="w"> </span>class DateTime(ParamType):
<span class="gu">@@ -207,33 +350,133 @@ class DateTime(ParamType):</span>
<span class="w"> </span>                    ``&#39;%Y-%m-%d&#39;``, ``&#39;%Y-%m-%dT%H:%M:%S&#39;``,
<span class="w"> </span>                    ``&#39;%Y-%m-%d %H:%M:%S&#39;``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;datetime&#39;</span>

<span class="gd">-    def __init__(self, formats: t.Optional[t.Sequence[str]]=None):</span>
<span class="gd">-        self.formats: t.Sequence[str] = formats or [&#39;%Y-%m-%d&#39;,</span>
<span class="gd">-            &#39;%Y-%m-%dT%H:%M:%S&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;]</span>
<span class="gi">+    name = &quot;datetime&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, formats: t.Optional[t.Sequence[str]] = None):</span>
<span class="gi">+        self.formats: t.Sequence[str] = formats or [</span>
<span class="gi">+            &quot;%Y-%m-%d&quot;,</span>
<span class="gi">+            &quot;%Y-%m-%dT%H:%M:%S&quot;,</span>
<span class="gi">+            &quot;%Y-%m-%d %H:%M:%S&quot;,</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def to_info_dict(self) -&gt; t.Dict[str, t.Any]:</span>
<span class="gi">+        info_dict = super().to_info_dict()</span>
<span class="gi">+        info_dict[&quot;formats&quot;] = self.formats</span>
<span class="gi">+        return info_dict</span>
<span class="gi">+</span>
<span class="gi">+    def get_metavar(self, param: &quot;Parameter&quot;) -&gt; str:</span>
<span class="gi">+        return f&quot;[{&#39;|&#39;.join(self.formats)}]&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _try_to_convert_date(self, value: t.Any, format: str) -&gt; t.Optional[datetime]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return datetime.strptime(value, format)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def convert(</span>
<span class="gi">+        self, value: t.Any, param: t.Optional[&quot;Parameter&quot;], ctx: t.Optional[&quot;Context&quot;]</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        if isinstance(value, datetime):</span>
<span class="gi">+            return value</span>
<span class="gi">+</span>
<span class="gi">+        for format in self.formats:</span>
<span class="gi">+            converted = self._try_to_convert_date(value, format)</span>
<span class="gi">+</span>
<span class="gi">+            if converted is not None:</span>
<span class="gi">+                return converted</span>
<span class="gi">+</span>
<span class="gi">+        formats_str = &quot;, &quot;.join(map(repr, self.formats))</span>
<span class="gi">+        self.fail(</span>
<span class="gi">+            ngettext(</span>
<span class="gi">+                &quot;{value!r} does not match the format {format}.&quot;,</span>
<span class="gi">+                &quot;{value!r} does not match the formats {formats}.&quot;,</span>
<span class="gi">+                len(self.formats),</span>
<span class="gi">+            ).format(value=value, format=formats_str, formats=formats_str),</span>
<span class="gi">+            param,</span>
<span class="gi">+            ctx,</span>
<span class="gi">+        )</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;DateTime&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;DateTime&quot;</span>


<span class="w"> </span>class _NumberParamTypeBase(ParamType):
<span class="w"> </span>    _number_class: t.ClassVar[t.Type[t.Any]]

<span class="gi">+    def convert(</span>
<span class="gi">+        self, value: t.Any, param: t.Optional[&quot;Parameter&quot;], ctx: t.Optional[&quot;Context&quot;]</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._number_class(value)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            self.fail(</span>
<span class="gi">+                _(&quot;{value!r} is not a valid {number_type}.&quot;).format(</span>
<span class="gi">+                    value=value, number_type=self.name</span>
<span class="gi">+                ),</span>
<span class="gi">+                param,</span>
<span class="gi">+                ctx,</span>
<span class="gi">+            )</span>

<span class="gd">-class _NumberRangeBase(_NumberParamTypeBase):</span>

<span class="gd">-    def __init__(self, min: t.Optional[float]=None, max: t.Optional[float]=</span>
<span class="gd">-        None, min_open: bool=False, max_open: bool=False, clamp: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+class _NumberRangeBase(_NumberParamTypeBase):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        min: t.Optional[float] = None,</span>
<span class="gi">+        max: t.Optional[float] = None,</span>
<span class="gi">+        min_open: bool = False,</span>
<span class="gi">+        max_open: bool = False,</span>
<span class="gi">+        clamp: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.min = min
<span class="w"> </span>        self.max = max
<span class="w"> </span>        self.min_open = min_open
<span class="w"> </span>        self.max_open = max_open
<span class="w"> </span>        self.clamp = clamp

<span class="gd">-    def _clamp(self, bound: float, dir: &#39;te.Literal[1, -1]&#39;, open: bool</span>
<span class="gd">-        ) -&gt;float:</span>
<span class="gi">+    def to_info_dict(self) -&gt; t.Dict[str, t.Any]:</span>
<span class="gi">+        info_dict = super().to_info_dict()</span>
<span class="gi">+        info_dict.update(</span>
<span class="gi">+            min=self.min,</span>
<span class="gi">+            max=self.max,</span>
<span class="gi">+            min_open=self.min_open,</span>
<span class="gi">+            max_open=self.max_open,</span>
<span class="gi">+            clamp=self.clamp,</span>
<span class="gi">+        )</span>
<span class="gi">+        return info_dict</span>
<span class="gi">+</span>
<span class="gi">+    def convert(</span>
<span class="gi">+        self, value: t.Any, param: t.Optional[&quot;Parameter&quot;], ctx: t.Optional[&quot;Context&quot;]</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        import operator</span>
<span class="gi">+</span>
<span class="gi">+        rv = super().convert(value, param, ctx)</span>
<span class="gi">+        lt_min: bool = self.min is not None and (</span>
<span class="gi">+            operator.le if self.min_open else operator.lt</span>
<span class="gi">+        )(rv, self.min)</span>
<span class="gi">+        gt_max: bool = self.max is not None and (</span>
<span class="gi">+            operator.ge if self.max_open else operator.gt</span>
<span class="gi">+        )(rv, self.max)</span>
<span class="gi">+</span>
<span class="gi">+        if self.clamp:</span>
<span class="gi">+            if lt_min:</span>
<span class="gi">+                return self._clamp(self.min, 1, self.min_open)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+            if gt_max:</span>
<span class="gi">+                return self._clamp(self.max, -1, self.max_open)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        if lt_min or gt_max:</span>
<span class="gi">+            self.fail(</span>
<span class="gi">+                _(&quot;{value} is not in the range {range}.&quot;).format(</span>
<span class="gi">+                    value=rv, range=self._describe_range()</span>
<span class="gi">+                ),</span>
<span class="gi">+                param,</span>
<span class="gi">+                ctx,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def _clamp(self, bound: float, dir: &quot;te.Literal[1, -1]&quot;, open: bool) -&gt; float:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find the valid value to clamp to bound in the given
<span class="w"> </span>        direction.

<span class="gu">@@ -241,23 +484,33 @@ class _NumberRangeBase(_NumberParamTypeBase):</span>
<span class="w"> </span>        :param dir: 1 or -1 indicating the direction to move.
<span class="w"> </span>        :param open: If true, the range does not include the bound.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def _describe_range(self) -&gt;str:</span>
<span class="gi">+    def _describe_range(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Describe the range for use in help text.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.min is None:</span>
<span class="gi">+            op = &quot;&lt;&quot; if self.max_open else &quot;&lt;=&quot;</span>
<span class="gi">+            return f&quot;x{op}{self.max}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if self.max is None:</span>
<span class="gi">+            op = &quot;&gt;&quot; if self.min_open else &quot;&gt;=&quot;</span>
<span class="gi">+            return f&quot;x{op}{self.min}&quot;</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        clamp = &#39; clamped&#39; if self.clamp else &#39;&#39;</span>
<span class="gd">-        return f&#39;&lt;{type(self).__name__} {self._describe_range()}{clamp}&gt;&#39;</span>
<span class="gi">+        lop = &quot;&lt;&quot; if self.min_open else &quot;&lt;=&quot;</span>
<span class="gi">+        rop = &quot;&lt;&quot; if self.max_open else &quot;&lt;=&quot;</span>
<span class="gi">+        return f&quot;{self.min}{lop}x{rop}{self.max}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        clamp = &quot; clamped&quot; if self.clamp else &quot;&quot;</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {self._describe_range()}{clamp}&gt;&quot;</span>


<span class="w"> </span>class IntParamType(_NumberParamTypeBase):
<span class="gd">-    name = &#39;integer&#39;</span>
<span class="gi">+    name = &quot;integer&quot;</span>
<span class="w"> </span>    _number_class = int

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;INT&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;INT&quot;</span>


<span class="w"> </span>class IntRange(_NumberRangeBase, IntParamType):
<span class="gu">@@ -274,15 +527,24 @@ class IntRange(_NumberRangeBase, IntParamType):</span>
<span class="w"> </span>    .. versionchanged:: 8.0
<span class="w"> </span>        Added the ``min_open`` and ``max_open`` parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;integer range&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;integer range&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _clamp(  # type: ignore</span>
<span class="gi">+        self, bound: int, dir: &quot;te.Literal[1, -1]&quot;, open: bool</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        if not open:</span>
<span class="gi">+            return bound</span>
<span class="gi">+</span>
<span class="gi">+        return bound + dir</span>


<span class="w"> </span>class FloatParamType(_NumberParamTypeBase):
<span class="gd">-    name = &#39;float&#39;</span>
<span class="gi">+    name = &quot;float&quot;</span>
<span class="w"> </span>    _number_class = float

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;FLOAT&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;FLOAT&quot;</span>


<span class="w"> </span>class FloatRange(_NumberRangeBase, FloatParamType):
<span class="gu">@@ -300,29 +562,81 @@ class FloatRange(_NumberRangeBase, FloatParamType):</span>
<span class="w"> </span>    .. versionchanged:: 8.0
<span class="w"> </span>        Added the ``min_open`` and ``max_open`` parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;float range&#39;</span>

<span class="gd">-    def __init__(self, min: t.Optional[float]=None, max: t.Optional[float]=</span>
<span class="gd">-        None, min_open: bool=False, max_open: bool=False, clamp: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gd">-        super().__init__(min=min, max=max, min_open=min_open, max_open=</span>
<span class="gd">-            max_open, clamp=clamp)</span>
<span class="gi">+    name = &quot;float range&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        min: t.Optional[float] = None,</span>
<span class="gi">+        max: t.Optional[float] = None,</span>
<span class="gi">+        min_open: bool = False,</span>
<span class="gi">+        max_open: bool = False,</span>
<span class="gi">+        clamp: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            min=min, max=max, min_open=min_open, max_open=max_open, clamp=clamp</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        if (min_open or max_open) and clamp:
<span class="gd">-            raise TypeError(&#39;Clamping is not supported for open bounds.&#39;)</span>
<span class="gi">+            raise TypeError(&quot;Clamping is not supported for open bounds.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _clamp(self, bound: float, dir: &quot;te.Literal[1, -1]&quot;, open: bool) -&gt; float:</span>
<span class="gi">+        if not open:</span>
<span class="gi">+            return bound</span>
<span class="gi">+</span>
<span class="gi">+        # Could use Python 3.9&#39;s math.nextafter here, but clamping an</span>
<span class="gi">+        # open float range doesn&#39;t seem to be particularly useful. It&#39;s</span>
<span class="gi">+        # left up to the user to write a callback to do it if needed.</span>
<span class="gi">+        raise RuntimeError(&quot;Clamping is not supported for open bounds.&quot;)</span>


<span class="w"> </span>class BoolParamType(ParamType):
<span class="gd">-    name = &#39;boolean&#39;</span>
<span class="gi">+    name = &quot;boolean&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def convert(</span>
<span class="gi">+        self, value: t.Any, param: t.Optional[&quot;Parameter&quot;], ctx: t.Optional[&quot;Context&quot;]</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        if value in {False, True}:</span>
<span class="gi">+            return bool(value)</span>
<span class="gi">+</span>
<span class="gi">+        norm = value.strip().lower()</span>
<span class="gi">+</span>
<span class="gi">+        if norm in {&quot;1&quot;, &quot;true&quot;, &quot;t&quot;, &quot;yes&quot;, &quot;y&quot;, &quot;on&quot;}:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        if norm in {&quot;0&quot;, &quot;false&quot;, &quot;f&quot;, &quot;no&quot;, &quot;n&quot;, &quot;off&quot;}:</span>
<span class="gi">+            return False</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;BOOL&#39;</span>
<span class="gi">+        self.fail(</span>
<span class="gi">+            _(&quot;{value!r} is not a valid boolean.&quot;).format(value=value), param, ctx</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;BOOL&quot;</span>


<span class="w"> </span>class UUIDParameterType(ParamType):
<span class="gd">-    name = &#39;uuid&#39;</span>
<span class="gi">+    name = &quot;uuid&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def convert(</span>
<span class="gi">+        self, value: t.Any, param: t.Optional[&quot;Parameter&quot;], ctx: t.Optional[&quot;Context&quot;]</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        import uuid</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(value, uuid.UUID):</span>
<span class="gi">+            return value</span>
<span class="gi">+</span>
<span class="gi">+        value = value.strip()</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return uuid.UUID(value)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            self.fail(</span>
<span class="gi">+                _(&quot;{value!r} is not a valid UUID.&quot;).format(value=value), param, ctx</span>
<span class="gi">+            )</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;UUID&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;UUID&quot;</span>


<span class="w"> </span>class File(ParamType):
<span class="gu">@@ -351,20 +665,84 @@ class File(ParamType):</span>

<span class="w"> </span>    See :ref:`file-args` for more information.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;filename&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;filename&quot;</span>
<span class="w"> </span>    envvar_list_splitter: t.ClassVar[str] = os.path.pathsep

<span class="gd">-    def __init__(self, mode: str=&#39;r&#39;, encoding: t.Optional[str]=None,</span>
<span class="gd">-        errors: t.Optional[str]=&#39;strict&#39;, lazy: t.Optional[bool]=None,</span>
<span class="gd">-        atomic: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        mode: str = &quot;r&quot;,</span>
<span class="gi">+        encoding: t.Optional[str] = None,</span>
<span class="gi">+        errors: t.Optional[str] = &quot;strict&quot;,</span>
<span class="gi">+        lazy: t.Optional[bool] = None,</span>
<span class="gi">+        atomic: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.mode = mode
<span class="w"> </span>        self.encoding = encoding
<span class="w"> </span>        self.errors = errors
<span class="w"> </span>        self.lazy = lazy
<span class="w"> </span>        self.atomic = atomic

<span class="gd">-    def shell_complete(self, ctx: &#39;Context&#39;, param: &#39;Parameter&#39;, incomplete:</span>
<span class="gd">-        str) -&gt;t.List[&#39;CompletionItem&#39;]:</span>
<span class="gi">+    def to_info_dict(self) -&gt; t.Dict[str, t.Any]:</span>
<span class="gi">+        info_dict = super().to_info_dict()</span>
<span class="gi">+        info_dict.update(mode=self.mode, encoding=self.encoding)</span>
<span class="gi">+        return info_dict</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_lazy_flag(self, value: &quot;t.Union[str, os.PathLike[str]]&quot;) -&gt; bool:</span>
<span class="gi">+        if self.lazy is not None:</span>
<span class="gi">+            return self.lazy</span>
<span class="gi">+        if os.fspath(value) == &quot;-&quot;:</span>
<span class="gi">+            return False</span>
<span class="gi">+        elif &quot;w&quot; in self.mode:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def convert(</span>
<span class="gi">+        self,</span>
<span class="gi">+        value: t.Union[str, &quot;os.PathLike[str]&quot;, t.IO[t.Any]],</span>
<span class="gi">+        param: t.Optional[&quot;Parameter&quot;],</span>
<span class="gi">+        ctx: t.Optional[&quot;Context&quot;],</span>
<span class="gi">+    ) -&gt; t.IO[t.Any]:</span>
<span class="gi">+        if _is_file_like(value):</span>
<span class="gi">+            return value</span>
<span class="gi">+</span>
<span class="gi">+        value = t.cast(&quot;t.Union[str, os.PathLike[str]]&quot;, value)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            lazy = self.resolve_lazy_flag(value)</span>
<span class="gi">+</span>
<span class="gi">+            if lazy:</span>
<span class="gi">+                lf = LazyFile(</span>
<span class="gi">+                    value, self.mode, self.encoding, self.errors, atomic=self.atomic</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                if ctx is not None:</span>
<span class="gi">+                    ctx.call_on_close(lf.close_intelligently)</span>
<span class="gi">+</span>
<span class="gi">+                return t.cast(t.IO[t.Any], lf)</span>
<span class="gi">+</span>
<span class="gi">+            f, should_close = open_stream(</span>
<span class="gi">+                value, self.mode, self.encoding, self.errors, atomic=self.atomic</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # If a context is provided, we automatically close the file</span>
<span class="gi">+            # at the end of the context execution (or flush out).  If a</span>
<span class="gi">+            # context does not exist, it&#39;s the caller&#39;s responsibility to</span>
<span class="gi">+            # properly close the file.  This for instance happens when the</span>
<span class="gi">+            # type is used with prompts.</span>
<span class="gi">+            if ctx is not None:</span>
<span class="gi">+                if should_close:</span>
<span class="gi">+                    ctx.call_on_close(safecall(f.close))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    ctx.call_on_close(safecall(f.flush))</span>
<span class="gi">+</span>
<span class="gi">+            return f</span>
<span class="gi">+        except OSError as e:  # noqa: B014</span>
<span class="gi">+            self.fail(f&quot;&#39;{format_filename(value)}&#39;: {e.strerror}&quot;, param, ctx)</span>
<span class="gi">+</span>
<span class="gi">+    def shell_complete(</span>
<span class="gi">+        self, ctx: &quot;Context&quot;, param: &quot;Parameter&quot;, incomplete: str</span>
<span class="gi">+    ) -&gt; t.List[&quot;CompletionItem&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a special completion marker that tells the completion
<span class="w"> </span>        system to use the shell to provide file path completions.

<span class="gu">@@ -374,7 +752,13 @@ class File(ParamType):</span>

<span class="w"> </span>        .. versionadded:: 8.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from click.shell_completion import CompletionItem</span>
<span class="gi">+</span>
<span class="gi">+        return [CompletionItem(incomplete, type=&quot;file&quot;)]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_file_like(value: t.Any) -&gt; &quot;te.TypeGuard[t.IO[t.Any]]&quot;:</span>
<span class="gi">+    return hasattr(value, &quot;read&quot;) or hasattr(value, &quot;write&quot;)</span>


<span class="w"> </span>class Path(ParamType):
<span class="gu">@@ -409,12 +793,21 @@ class Path(ParamType):</span>
<span class="w"> </span>    .. versionchanged:: 6.0
<span class="w"> </span>        Added the ``allow_dash`` parameter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    envvar_list_splitter: t.ClassVar[str] = os.path.pathsep

<span class="gd">-    def __init__(self, exists: bool=False, file_okay: bool=True, dir_okay:</span>
<span class="gd">-        bool=True, writable: bool=False, readable: bool=True, resolve_path:</span>
<span class="gd">-        bool=False, allow_dash: bool=False, path_type: t.Optional[t.Type[t.</span>
<span class="gd">-        Any]]=None, executable: bool=False):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exists: bool = False,</span>
<span class="gi">+        file_okay: bool = True,</span>
<span class="gi">+        dir_okay: bool = True,</span>
<span class="gi">+        writable: bool = False,</span>
<span class="gi">+        readable: bool = True,</span>
<span class="gi">+        resolve_path: bool = False,</span>
<span class="gi">+        allow_dash: bool = False,</span>
<span class="gi">+        path_type: t.Optional[t.Type[t.Any]] = None,</span>
<span class="gi">+        executable: bool = False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.exists = exists
<span class="w"> </span>        self.file_okay = file_okay
<span class="w"> </span>        self.dir_okay = dir_okay
<span class="gu">@@ -424,15 +817,119 @@ class Path(ParamType):</span>
<span class="w"> </span>        self.resolve_path = resolve_path
<span class="w"> </span>        self.allow_dash = allow_dash
<span class="w"> </span>        self.type = path_type
<span class="gi">+</span>
<span class="w"> </span>        if self.file_okay and not self.dir_okay:
<span class="gd">-            self.name: str = _(&#39;file&#39;)</span>
<span class="gi">+            self.name: str = _(&quot;file&quot;)</span>
<span class="w"> </span>        elif self.dir_okay and not self.file_okay:
<span class="gd">-            self.name = _(&#39;directory&#39;)</span>
<span class="gi">+            self.name = _(&quot;directory&quot;)</span>
<span class="w"> </span>        else:
<span class="gd">-            self.name = _(&#39;path&#39;)</span>
<span class="gd">-</span>
<span class="gd">-    def shell_complete(self, ctx: &#39;Context&#39;, param: &#39;Parameter&#39;, incomplete:</span>
<span class="gd">-        str) -&gt;t.List[&#39;CompletionItem&#39;]:</span>
<span class="gi">+            self.name = _(&quot;path&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def to_info_dict(self) -&gt; t.Dict[str, t.Any]:</span>
<span class="gi">+        info_dict = super().to_info_dict()</span>
<span class="gi">+        info_dict.update(</span>
<span class="gi">+            exists=self.exists,</span>
<span class="gi">+            file_okay=self.file_okay,</span>
<span class="gi">+            dir_okay=self.dir_okay,</span>
<span class="gi">+            writable=self.writable,</span>
<span class="gi">+            readable=self.readable,</span>
<span class="gi">+            allow_dash=self.allow_dash,</span>
<span class="gi">+        )</span>
<span class="gi">+        return info_dict</span>
<span class="gi">+</span>
<span class="gi">+    def coerce_path_result(</span>
<span class="gi">+        self, value: &quot;t.Union[str, os.PathLike[str]]&quot;</span>
<span class="gi">+    ) -&gt; &quot;t.Union[str, bytes, os.PathLike[str]]&quot;:</span>
<span class="gi">+        if self.type is not None and not isinstance(value, self.type):</span>
<span class="gi">+            if self.type is str:</span>
<span class="gi">+                return os.fsdecode(value)</span>
<span class="gi">+            elif self.type is bytes:</span>
<span class="gi">+                return os.fsencode(value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return t.cast(&quot;os.PathLike[str]&quot;, self.type(value))</span>
<span class="gi">+</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    def convert(</span>
<span class="gi">+        self,</span>
<span class="gi">+        value: &quot;t.Union[str, os.PathLike[str]]&quot;,</span>
<span class="gi">+        param: t.Optional[&quot;Parameter&quot;],</span>
<span class="gi">+        ctx: t.Optional[&quot;Context&quot;],</span>
<span class="gi">+    ) -&gt; &quot;t.Union[str, bytes, os.PathLike[str]]&quot;:</span>
<span class="gi">+        rv = value</span>
<span class="gi">+</span>
<span class="gi">+        is_dash = self.file_okay and self.allow_dash and rv in (b&quot;-&quot;, &quot;-&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not is_dash:</span>
<span class="gi">+            if self.resolve_path:</span>
<span class="gi">+                # os.path.realpath doesn&#39;t resolve symlinks on Windows</span>
<span class="gi">+                # until Python 3.8. Use pathlib for now.</span>
<span class="gi">+                import pathlib</span>
<span class="gi">+</span>
<span class="gi">+                rv = os.fsdecode(pathlib.Path(rv).resolve())</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                st = os.stat(rv)</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                if not self.exists:</span>
<span class="gi">+                    return self.coerce_path_result(rv)</span>
<span class="gi">+                self.fail(</span>
<span class="gi">+                    _(&quot;{name} {filename!r} does not exist.&quot;).format(</span>
<span class="gi">+                        name=self.name.title(), filename=format_filename(value)</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    param,</span>
<span class="gi">+                    ctx,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            if not self.file_okay and stat.S_ISREG(st.st_mode):</span>
<span class="gi">+                self.fail(</span>
<span class="gi">+                    _(&quot;{name} {filename!r} is a file.&quot;).format(</span>
<span class="gi">+                        name=self.name.title(), filename=format_filename(value)</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    param,</span>
<span class="gi">+                    ctx,</span>
<span class="gi">+                )</span>
<span class="gi">+            if not self.dir_okay and stat.S_ISDIR(st.st_mode):</span>
<span class="gi">+                self.fail(</span>
<span class="gi">+                    _(&quot;{name} &#39;{filename}&#39; is a directory.&quot;).format(</span>
<span class="gi">+                        name=self.name.title(), filename=format_filename(value)</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    param,</span>
<span class="gi">+                    ctx,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            if self.readable and not os.access(rv, os.R_OK):</span>
<span class="gi">+                self.fail(</span>
<span class="gi">+                    _(&quot;{name} {filename!r} is not readable.&quot;).format(</span>
<span class="gi">+                        name=self.name.title(), filename=format_filename(value)</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    param,</span>
<span class="gi">+                    ctx,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            if self.writable and not os.access(rv, os.W_OK):</span>
<span class="gi">+                self.fail(</span>
<span class="gi">+                    _(&quot;{name} {filename!r} is not writable.&quot;).format(</span>
<span class="gi">+                        name=self.name.title(), filename=format_filename(value)</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    param,</span>
<span class="gi">+                    ctx,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            if self.executable and not os.access(value, os.X_OK):</span>
<span class="gi">+                self.fail(</span>
<span class="gi">+                    _(&quot;{name} {filename!r} is not executable.&quot;).format(</span>
<span class="gi">+                        name=self.name.title(), filename=format_filename(value)</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    param,</span>
<span class="gi">+                    ctx,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        return self.coerce_path_result(rv)</span>
<span class="gi">+</span>
<span class="gi">+    def shell_complete(</span>
<span class="gi">+        self, ctx: &quot;Context&quot;, param: &quot;Parameter&quot;, incomplete: str</span>
<span class="gi">+    ) -&gt; t.List[&quot;CompletionItem&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a special completion marker that tells the completion
<span class="w"> </span>        system to use the shell to provide path completions for only
<span class="w"> </span>        directories or any paths.
<span class="gu">@@ -443,7 +940,10 @@ class Path(ParamType):</span>

<span class="w"> </span>        .. versionadded:: 8.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from click.shell_completion import CompletionItem</span>
<span class="gi">+</span>
<span class="gi">+        type = &quot;dir&quot; if self.dir_okay and not self.file_okay else &quot;file&quot;</span>
<span class="gi">+        return [CompletionItem(incomplete, type=type)]</span>


<span class="w"> </span>class Tuple(CompositeParamType):
<span class="gu">@@ -460,23 +960,130 @@ class Tuple(CompositeParamType):</span>
<span class="w"> </span>    :param types: a list of types that should be used for the tuple items.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, types: t.Sequence[t.Union[t.Type[t.Any], ParamType]]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, types: t.Sequence[t.Union[t.Type[t.Any], ParamType]]) -&gt; None:</span>
<span class="w"> </span>        self.types: t.Sequence[ParamType] = [convert_type(ty) for ty in types]

<span class="gi">+    def to_info_dict(self) -&gt; t.Dict[str, t.Any]:</span>
<span class="gi">+        info_dict = super().to_info_dict()</span>
<span class="gi">+        info_dict[&quot;types&quot;] = [t.to_info_dict() for t in self.types]</span>
<span class="gi">+        return info_dict</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; str:  # type: ignore</span>
<span class="gi">+        return f&quot;&lt;{&#39; &#39;.join(ty.name for ty in self.types)}&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def arity(self) -&gt; int:  # type: ignore</span>
<span class="gi">+        return len(self.types)</span>

<span class="gd">-def convert_type(ty: t.Optional[t.Any], default: t.Optional[t.Any]=None</span>
<span class="gd">-    ) -&gt;ParamType:</span>
<span class="gi">+    def convert(</span>
<span class="gi">+        self, value: t.Any, param: t.Optional[&quot;Parameter&quot;], ctx: t.Optional[&quot;Context&quot;]</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        len_type = len(self.types)</span>
<span class="gi">+        len_value = len(value)</span>
<span class="gi">+</span>
<span class="gi">+        if len_value != len_type:</span>
<span class="gi">+            self.fail(</span>
<span class="gi">+                ngettext(</span>
<span class="gi">+                    &quot;{len_type} values are required, but {len_value} was given.&quot;,</span>
<span class="gi">+                    &quot;{len_type} values are required, but {len_value} were given.&quot;,</span>
<span class="gi">+                    len_value,</span>
<span class="gi">+                ).format(len_type=len_type, len_value=len_value),</span>
<span class="gi">+                param=param,</span>
<span class="gi">+                ctx=ctx,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return tuple(ty(x, param, ctx) for ty, x in zip(self.types, value))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def convert_type(ty: t.Optional[t.Any], default: t.Optional[t.Any] = None) -&gt; ParamType:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find the most appropriate :class:`ParamType` for the given Python
<span class="w"> </span>    type. If the type isn&#39;t provided, it can be inferred from a default
<span class="w"> </span>    value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    guessed_type = False</span>
<span class="gi">+</span>
<span class="gi">+    if ty is None and default is not None:</span>
<span class="gi">+        if isinstance(default, (tuple, list)):</span>
<span class="gi">+            # If the default is empty, ty will remain None and will</span>
<span class="gi">+            # return STRING.</span>
<span class="gi">+            if default:</span>
<span class="gi">+                item = default[0]</span>
<span class="gi">+</span>
<span class="gi">+                # A tuple of tuples needs to detect the inner types.</span>
<span class="gi">+                # Can&#39;t call convert recursively because that would</span>
<span class="gi">+                # incorrectly unwind the tuple to a single type.</span>
<span class="gi">+                if isinstance(item, (tuple, list)):</span>
<span class="gi">+                    ty = tuple(map(type, item))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    ty = type(item)</span>
<span class="gi">+        else:</span>
<span class="gi">+            ty = type(default)</span>
<span class="gi">+</span>
<span class="gi">+        guessed_type = True</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(ty, tuple):</span>
<span class="gi">+        return Tuple(ty)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(ty, ParamType):</span>
<span class="gi">+        return ty</span>
<span class="gi">+</span>
<span class="gi">+    if ty is str or ty is None:</span>
<span class="gi">+        return STRING</span>
<span class="gi">+</span>
<span class="gi">+    if ty is int:</span>
<span class="gi">+        return INT</span>

<span class="gi">+    if ty is float:</span>
<span class="gi">+        return FLOAT</span>

<span class="gi">+    if ty is bool:</span>
<span class="gi">+        return BOOL</span>
<span class="gi">+</span>
<span class="gi">+    if guessed_type:</span>
<span class="gi">+        return STRING</span>
<span class="gi">+</span>
<span class="gi">+    if __debug__:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if issubclass(ty, ParamType):</span>
<span class="gi">+                raise AssertionError(</span>
<span class="gi">+                    f&quot;Attempted to use an uninstantiated parameter type ({ty}).&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            # ty is an instance (correct), so issubclass fails.</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    return FuncParamType(ty)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#: A dummy parameter type that just does nothing.  From a user&#39;s</span>
<span class="gi">+#: perspective this appears to just be the same as `STRING` but</span>
<span class="gi">+#: internally no string conversion takes place if the input was bytes.</span>
<span class="gi">+#: This is usually useful when working with file paths as they can</span>
<span class="gi">+#: appear in bytes and unicode.</span>
<span class="gi">+#:</span>
<span class="gi">+#: For path related uses the :class:`Path` type is a better choice but</span>
<span class="gi">+#: there are situations where an unprocessed type is useful which is why</span>
<span class="gi">+#: it is is provided.</span>
<span class="gi">+#:</span>
<span class="gi">+#: .. versionadded:: 4.0</span>
<span class="w"> </span>UNPROCESSED = UnprocessedParamType()
<span class="gi">+</span>
<span class="gi">+#: A unicode string parameter type which is the implicit default.  This</span>
<span class="gi">+#: can also be selected by using ``str`` as type.</span>
<span class="w"> </span>STRING = StringParamType()
<span class="gi">+</span>
<span class="gi">+#: An integer parameter.  This can also be selected by using ``int`` as</span>
<span class="gi">+#: type.</span>
<span class="w"> </span>INT = IntParamType()
<span class="gi">+</span>
<span class="gi">+#: A floating point value parameter.  This can also be selected by using</span>
<span class="gi">+#: ``float`` as type.</span>
<span class="w"> </span>FLOAT = FloatParamType()
<span class="gi">+</span>
<span class="gi">+#: A boolean parameter.  This is the default for boolean flags.  This can</span>
<span class="gi">+#: also be selected by using ``bool`` as a type.</span>
<span class="w"> </span>BOOL = BoolParamType()
<span class="gi">+</span>
<span class="gi">+#: A UUID parameter.</span>
<span class="w"> </span>UUID = UUIDParameterType()
<span class="gh">diff --git a/src/click/utils.py b/src/click/utils.py</span>
<span class="gh">index 0b2575c..d536434 100644</span>
<span class="gd">--- a/src/click/utils.py</span>
<span class="gi">+++ b/src/click/utils.py</span>
<span class="gu">@@ -5,6 +5,7 @@ import typing as t</span>
<span class="w"> </span>from functools import update_wrapper
<span class="w"> </span>from types import ModuleType
<span class="w"> </span>from types import TracebackType
<span class="gi">+</span>
<span class="w"> </span>from ._compat import _default_text_stderr
<span class="w"> </span>from ._compat import _default_text_stdout
<span class="w"> </span>from ._compat import _find_binary_writer
<span class="gu">@@ -16,25 +17,90 @@ from ._compat import strip_ansi</span>
<span class="w"> </span>from ._compat import text_streams
<span class="w"> </span>from ._compat import WIN
<span class="w"> </span>from .globals import resolve_color_default
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="gd">-    P = te.ParamSpec(&#39;P&#39;)</span>
<span class="gd">-R = t.TypeVar(&#39;R&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    P = te.ParamSpec(&quot;P&quot;)</span>
<span class="gi">+</span>
<span class="gi">+R = t.TypeVar(&quot;R&quot;)</span>


<span class="gd">-def safecall(func: &#39;t.Callable[P, R]&#39;) -&gt;&#39;t.Callable[P, t.Optional[R]]&#39;:</span>
<span class="gi">+def _posixify(name: str) -&gt; str:</span>
<span class="gi">+    return &quot;-&quot;.join(name.split()).lower()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def safecall(func: &quot;t.Callable[P, R]&quot;) -&gt; &quot;t.Callable[P, t.Optional[R]]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Wraps a function so that it swallows exceptions.&quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def wrapper(*args: &quot;P.args&quot;, **kwargs: &quot;P.kwargs&quot;) -&gt; t.Optional[R]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return func(*args, **kwargs)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    return update_wrapper(wrapper, func)</span>

<span class="gd">-def make_str(value: t.Any) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+def make_str(value: t.Any) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Converts a value into a valid string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, bytes):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return value.decode(sys.getfilesystemencoding())</span>
<span class="gi">+        except UnicodeError:</span>
<span class="gi">+            return value.decode(&quot;utf-8&quot;, &quot;replace&quot;)</span>
<span class="gi">+    return str(value)</span>


<span class="gd">-def make_default_short_help(help: str, max_length: int=45) -&gt;str:</span>
<span class="gi">+def make_default_short_help(help: str, max_length: int = 45) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a condensed version of help string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Consider only the first paragraph.</span>
<span class="gi">+    paragraph_end = help.find(&quot;\n\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if paragraph_end != -1:</span>
<span class="gi">+        help = help[:paragraph_end]</span>
<span class="gi">+</span>
<span class="gi">+    # Collapse newlines, tabs, and spaces.</span>
<span class="gi">+    words = help.split()</span>
<span class="gi">+</span>
<span class="gi">+    if not words:</span>
<span class="gi">+        return &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # The first paragraph started with a &quot;no rewrap&quot; marker, ignore it.</span>
<span class="gi">+    if words[0] == &quot;\b&quot;:</span>
<span class="gi">+        words = words[1:]</span>
<span class="gi">+</span>
<span class="gi">+    total_length = 0</span>
<span class="gi">+    last_index = len(words) - 1</span>
<span class="gi">+</span>
<span class="gi">+    for i, word in enumerate(words):</span>
<span class="gi">+        total_length += len(word) + (i &gt; 0)</span>
<span class="gi">+</span>
<span class="gi">+        if total_length &gt; max_length:  # too long, truncate</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+        if word[-1] == &quot;.&quot;:  # sentence end, truncate without &quot;...&quot;</span>
<span class="gi">+            return &quot; &quot;.join(words[: i + 1])</span>
<span class="gi">+</span>
<span class="gi">+        if total_length == max_length and i != last_index:</span>
<span class="gi">+            break  # not at sentence end, truncate with &quot;...&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return &quot; &quot;.join(words)  # no truncation needed</span>
<span class="gi">+</span>
<span class="gi">+    # Account for the length of the suffix.</span>
<span class="gi">+    total_length += len(&quot;...&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # remove words until the length is short enough</span>
<span class="gi">+    while i &gt; 0:</span>
<span class="gi">+        total_length -= len(words[i]) + (i &gt; 0)</span>
<span class="gi">+</span>
<span class="gi">+        if total_length &lt;= max_length:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+        i -= 1</span>
<span class="gi">+</span>
<span class="gi">+    return &quot; &quot;.join(words[:i]) + &quot;...&quot;</span>


<span class="w"> </span>class LazyFile:
<span class="gu">@@ -44,9 +110,14 @@ class LazyFile:</span>
<span class="w"> </span>    files for writing.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, filename: t.Union[str, &#39;os.PathLike[str]&#39;], mode:</span>
<span class="gd">-        str=&#39;r&#39;, encoding: t.Optional[str]=None, errors: t.Optional[str]=</span>
<span class="gd">-        &#39;strict&#39;, atomic: bool=False):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        filename: t.Union[str, &quot;os.PathLike[str]&quot;],</span>
<span class="gi">+        mode: str = &quot;r&quot;,</span>
<span class="gi">+        encoding: t.Optional[str] = None,</span>
<span class="gi">+        errors: t.Optional[str] = &quot;strict&quot;,</span>
<span class="gi">+        atomic: bool = False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.name: str = os.fspath(filename)
<span class="w"> </span>        self.mode = mode
<span class="w"> </span>        self.encoding = encoding
<span class="gu">@@ -54,78 +125,104 @@ class LazyFile:</span>
<span class="w"> </span>        self.atomic = atomic
<span class="w"> </span>        self._f: t.Optional[t.IO[t.Any]]
<span class="w"> </span>        self.should_close: bool
<span class="gd">-        if self.name == &#39;-&#39;:</span>
<span class="gd">-            self._f, self.should_close = open_stream(filename, mode,</span>
<span class="gd">-                encoding, errors)</span>
<span class="gi">+</span>
<span class="gi">+        if self.name == &quot;-&quot;:</span>
<span class="gi">+            self._f, self.should_close = open_stream(filename, mode, encoding, errors)</span>
<span class="w"> </span>        else:
<span class="gd">-            if &#39;r&#39; in mode:</span>
<span class="gi">+            if &quot;r&quot; in mode:</span>
<span class="gi">+                # Open and close the file in case we&#39;re opening it for</span>
<span class="gi">+                # reading so that we can catch at least some errors in</span>
<span class="gi">+                # some cases early.</span>
<span class="w"> </span>                open(filename, mode).close()
<span class="w"> </span>            self._f = None
<span class="w"> </span>            self.should_close = True

<span class="gd">-    def __getattr__(self, name: str) -&gt;t.Any:</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; t.Any:</span>
<span class="w"> </span>        return getattr(self.open(), name)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        if self._f is not None:
<span class="w"> </span>            return repr(self._f)
<span class="w"> </span>        return f&quot;&lt;unopened file &#39;{format_filename(self.name)}&#39; {self.mode}&gt;&quot;

<span class="gd">-    def open(self) -&gt;t.IO[t.Any]:</span>
<span class="gi">+    def open(self) -&gt; t.IO[t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Opens the file if it&#39;s not yet open.  This call might fail with
<span class="w"> </span>        a :exc:`FileError`.  Not handling this error will produce an error
<span class="w"> </span>        that Click shows.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gi">+        if self._f is not None:</span>
<span class="gi">+            return self._f</span>
<span class="gi">+        try:</span>
<span class="gi">+            rv, self.should_close = open_stream(</span>
<span class="gi">+                self.name, self.mode, self.encoding, self.errors, atomic=self.atomic</span>
<span class="gi">+            )</span>
<span class="gi">+        except OSError as e:  # noqa: E402</span>
<span class="gi">+            from .exceptions import FileError</span>
<span class="gi">+</span>
<span class="gi">+            raise FileError(self.name, hint=e.strerror) from e</span>
<span class="gi">+        self._f = rv</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Closes the underlying file, no matter what.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._f is not None:</span>
<span class="gi">+            self._f.close()</span>

<span class="gd">-    def close_intelligently(self) -&gt;None:</span>
<span class="gi">+    def close_intelligently(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;This function only closes the file if it was opened by the lazy
<span class="w"> </span>        file wrapper.  For instance this will never close stdin.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.should_close:</span>
<span class="gi">+            self.close()</span>

<span class="gd">-    def __enter__(self) -&gt;&#39;LazyFile&#39;:</span>
<span class="gi">+    def __enter__(self) -&gt; &quot;LazyFile&quot;:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __exit__(self, exc_type: t.Optional[t.Type[BaseException]],</span>
<span class="gd">-        exc_value: t.Optional[BaseException], tb: t.Optional[TracebackType]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exc_type: t.Optional[t.Type[BaseException]],</span>
<span class="gi">+        exc_value: t.Optional[BaseException],</span>
<span class="gi">+        tb: t.Optional[TracebackType],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.close_intelligently()

<span class="gd">-    def __iter__(self) -&gt;t.Iterator[t.AnyStr]:</span>
<span class="gi">+    def __iter__(self) -&gt; t.Iterator[t.AnyStr]:</span>
<span class="w"> </span>        self.open()
<span class="gd">-        return iter(self._f)</span>
<span class="gi">+        return iter(self._f)  # type: ignore</span>


<span class="w"> </span>class KeepOpenFile:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, file: t.IO[t.Any]) -&gt;None:</span>
<span class="gi">+    def __init__(self, file: t.IO[t.Any]) -&gt; None:</span>
<span class="w"> </span>        self._file: t.IO[t.Any] = file

<span class="gd">-    def __getattr__(self, name: str) -&gt;t.Any:</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; t.Any:</span>
<span class="w"> </span>        return getattr(self._file, name)

<span class="gd">-    def __enter__(self) -&gt;&#39;KeepOpenFile&#39;:</span>
<span class="gi">+    def __enter__(self) -&gt; &quot;KeepOpenFile&quot;:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __exit__(self, exc_type: t.Optional[t.Type[BaseException]],</span>
<span class="gd">-        exc_value: t.Optional[BaseException], tb: t.Optional[TracebackType]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exc_type: t.Optional[t.Type[BaseException]],</span>
<span class="gi">+        exc_value: t.Optional[BaseException],</span>
<span class="gi">+        tb: t.Optional[TracebackType],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return repr(self._file)

<span class="gd">-    def __iter__(self) -&gt;t.Iterator[t.AnyStr]:</span>
<span class="gi">+    def __iter__(self) -&gt; t.Iterator[t.AnyStr]:</span>
<span class="w"> </span>        return iter(self._file)


<span class="gd">-def echo(message: t.Optional[t.Any]=None, file: t.Optional[t.IO[t.Any]]=</span>
<span class="gd">-    None, nl: bool=True, err: bool=False, color: t.Optional[bool]=None) -&gt;None:</span>
<span class="gi">+def echo(</span>
<span class="gi">+    message: t.Optional[t.Any] = None,</span>
<span class="gi">+    file: t.Optional[t.IO[t.Any]] = None,</span>
<span class="gi">+    nl: bool = True,</span>
<span class="gi">+    err: bool = False,</span>
<span class="gi">+    color: t.Optional[bool] = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Print a message and newline to stdout or a file. This should be
<span class="w"> </span>    used instead of :func:`print` because it provides better support
<span class="w"> </span>    for different data, files, and environments.
<span class="gu">@@ -164,22 +261,81 @@ def echo(message: t.Optional[t.Any]=None, file: t.Optional[t.IO[t.Any]]=</span>
<span class="w"> </span>    .. versionchanged:: 2.0
<span class="w"> </span>        Support colors on Windows if colorama is installed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_binary_stream(name: &quot;te.Literal[&#39;stdin&#39;, &#39;stdout&#39;, &#39;stderr&#39;]&quot;</span>
<span class="gd">-    ) -&gt;t.BinaryIO:</span>
<span class="gi">+    if file is None:</span>
<span class="gi">+        if err:</span>
<span class="gi">+            file = _default_text_stderr()</span>
<span class="gi">+        else:</span>
<span class="gi">+            file = _default_text_stdout()</span>
<span class="gi">+</span>
<span class="gi">+        # There are no standard streams attached to write to. For example,</span>
<span class="gi">+        # pythonw on Windows.</span>
<span class="gi">+        if file is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+    # Convert non bytes/text into the native string type.</span>
<span class="gi">+    if message is not None and not isinstance(message, (str, bytes, bytearray)):</span>
<span class="gi">+        out: t.Optional[t.Union[str, bytes]] = str(message)</span>
<span class="gi">+    else:</span>
<span class="gi">+        out = message</span>
<span class="gi">+</span>
<span class="gi">+    if nl:</span>
<span class="gi">+        out = out or &quot;&quot;</span>
<span class="gi">+        if isinstance(out, str):</span>
<span class="gi">+            out += &quot;\n&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            out += b&quot;\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if not out:</span>
<span class="gi">+        file.flush()</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # If there is a message and the value looks like bytes, we manually</span>
<span class="gi">+    # need to find the binary stream and write the message in there.</span>
<span class="gi">+    # This is done separately so that most stream types will work as you</span>
<span class="gi">+    # would expect. Eg: you can write to StringIO for other cases.</span>
<span class="gi">+    if isinstance(out, (bytes, bytearray)):</span>
<span class="gi">+        binary_file = _find_binary_writer(file)</span>
<span class="gi">+</span>
<span class="gi">+        if binary_file is not None:</span>
<span class="gi">+            file.flush()</span>
<span class="gi">+            binary_file.write(out)</span>
<span class="gi">+            binary_file.flush()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+    # ANSI style code support. For no message or bytes, nothing happens.</span>
<span class="gi">+    # When outputting to a file instead of a terminal, strip codes.</span>
<span class="gi">+    else:</span>
<span class="gi">+        color = resolve_color_default(color)</span>
<span class="gi">+</span>
<span class="gi">+        if should_strip_ansi(file, color):</span>
<span class="gi">+            out = strip_ansi(out)</span>
<span class="gi">+        elif WIN:</span>
<span class="gi">+            if auto_wrap_for_ansi is not None:</span>
<span class="gi">+                file = auto_wrap_for_ansi(file)  # type: ignore</span>
<span class="gi">+            elif not color:</span>
<span class="gi">+                out = strip_ansi(out)</span>
<span class="gi">+</span>
<span class="gi">+    file.write(out)  # type: ignore</span>
<span class="gi">+    file.flush()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_binary_stream(name: &quot;te.Literal[&#39;stdin&#39;, &#39;stdout&#39;, &#39;stderr&#39;]&quot;) -&gt; t.BinaryIO:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a system stream for byte processing.

<span class="w"> </span>    :param name: the name of the stream to open.  Valid names are ``&#39;stdin&#39;``,
<span class="w"> </span>                 ``&#39;stdout&#39;`` and ``&#39;stderr&#39;``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    opener = binary_streams.get(name)</span>
<span class="gi">+    if opener is None:</span>
<span class="gi">+        raise TypeError(f&quot;Unknown standard stream &#39;{name}&#39;&quot;)</span>
<span class="gi">+    return opener()</span>


<span class="gd">-def get_text_stream(name: &quot;te.Literal[&#39;stdin&#39;, &#39;stdout&#39;, &#39;stderr&#39;]&quot;,</span>
<span class="gd">-    encoding: t.Optional[str]=None, errors: t.Optional[str]=&#39;strict&#39;</span>
<span class="gd">-    ) -&gt;t.TextIO:</span>
<span class="gi">+def get_text_stream(</span>
<span class="gi">+    name: &quot;te.Literal[&#39;stdin&#39;, &#39;stdout&#39;, &#39;stderr&#39;]&quot;,</span>
<span class="gi">+    encoding: t.Optional[str] = None,</span>
<span class="gi">+    errors: t.Optional[str] = &quot;strict&quot;,</span>
<span class="gi">+) -&gt; t.TextIO:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a system stream for text processing.  This usually returns
<span class="w"> </span>    a wrapped stream around a binary stream returned from
<span class="w"> </span>    :func:`get_binary_stream` but it also can take shortcuts for already
<span class="gu">@@ -190,12 +346,20 @@ def get_text_stream(name: &quot;te.Literal[&#39;stdin&#39;, &#39;stdout&#39;, &#39;stderr&#39;]&quot;,</span>
<span class="w"> </span>    :param encoding: overrides the detected default encoding.
<span class="w"> </span>    :param errors: overrides the default error mode.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def open_file(filename: str, mode: str=&#39;r&#39;, encoding: t.Optional[str]=None,</span>
<span class="gd">-    errors: t.Optional[str]=&#39;strict&#39;, lazy: bool=False, atomic: bool=False</span>
<span class="gd">-    ) -&gt;t.IO[t.Any]:</span>
<span class="gi">+    opener = text_streams.get(name)</span>
<span class="gi">+    if opener is None:</span>
<span class="gi">+        raise TypeError(f&quot;Unknown standard stream &#39;{name}&#39;&quot;)</span>
<span class="gi">+    return opener(encoding, errors)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def open_file(</span>
<span class="gi">+    filename: str,</span>
<span class="gi">+    mode: str = &quot;r&quot;,</span>
<span class="gi">+    encoding: t.Optional[str] = None,</span>
<span class="gi">+    errors: t.Optional[str] = &quot;strict&quot;,</span>
<span class="gi">+    lazy: bool = False,</span>
<span class="gi">+    atomic: bool = False,</span>
<span class="gi">+) -&gt; t.IO[t.Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Open a file, with extra behavior to handle ``&#39;-&#39;`` to indicate
<span class="w"> </span>    a standard stream, lazy open on write, and atomic write. Similar to
<span class="w"> </span>    the behavior of the :class:`~click.File` param type.
<span class="gu">@@ -224,12 +388,23 @@ def open_file(filename: str, mode: str=&#39;r&#39;, encoding: t.Optional[str]=None,</span>

<span class="w"> </span>    .. versionadded:: 3.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if lazy:</span>
<span class="gi">+        return t.cast(</span>
<span class="gi">+            t.IO[t.Any], LazyFile(filename, mode, encoding, errors, atomic=atomic)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    f, should_close = open_stream(filename, mode, encoding, errors, atomic=atomic)</span>
<span class="gi">+</span>
<span class="gi">+    if not should_close:</span>
<span class="gi">+        f = t.cast(t.IO[t.Any], KeepOpenFile(f))</span>
<span class="gi">+</span>
<span class="gi">+    return f</span>


<span class="gd">-def format_filename(filename:</span>
<span class="gd">-    &#39;t.Union[str, bytes, os.PathLike[str], os.PathLike[bytes]]&#39;, shorten:</span>
<span class="gd">-    bool=False) -&gt;str:</span>
<span class="gi">+def format_filename(</span>
<span class="gi">+    filename: &quot;t.Union[str, bytes, os.PathLike[str], os.PathLike[bytes]]&quot;,</span>
<span class="gi">+    shorten: bool = False,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Format a filename as a string for display. Ensures the filename can be
<span class="w"> </span>    displayed by replacing any invalid bytes or surrogate escapes in the name
<span class="w"> </span>    with the replacement character ````.
<span class="gu">@@ -253,12 +428,23 @@ def format_filename(filename:</span>
<span class="w"> </span>    :param shorten: this optionally shortens the filename to strip of the
<span class="w"> </span>                    path that leads up to it.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if shorten:</span>
<span class="gi">+        filename = os.path.basename(filename)</span>
<span class="gi">+    else:</span>
<span class="gi">+        filename = os.fspath(filename)</span>

<span class="gi">+    if isinstance(filename, bytes):</span>
<span class="gi">+        filename = filename.decode(sys.getfilesystemencoding(), &quot;replace&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        filename = filename.encode(&quot;utf-8&quot;, &quot;surrogateescape&quot;).decode(</span>
<span class="gi">+            &quot;utf-8&quot;, &quot;replace&quot;</span>
<span class="gi">+        )</span>

<span class="gd">-def get_app_dir(app_name: str, roaming: bool=True, force_posix: bool=False</span>
<span class="gd">-    ) -&gt;str:</span>
<span class="gd">-    &quot;&quot;&quot;Returns the config folder for the application.  The default behavior</span>
<span class="gi">+    return filename</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_app_dir(app_name: str, roaming: bool = True, force_posix: bool = False) -&gt; str:</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the config folder for the application.  The default behavior</span>
<span class="w"> </span>    is to return whatever is most appropriate for the operating system.

<span class="w"> </span>    To give you an idea, for an app called ``&quot;Foo Bar&quot;``, something like
<span class="gu">@@ -273,9 +459,9 @@ def get_app_dir(app_name: str, roaming: bool=True, force_posix: bool=False</span>
<span class="w"> </span>    Unix (POSIX):
<span class="w"> </span>      ``~/.foo-bar``
<span class="w"> </span>    Windows (roaming):
<span class="gd">-      ``C:\\Users\\&lt;user&gt;\\AppData\\Roaming\\Foo Bar``</span>
<span class="gi">+      ``C:\Users\&lt;user&gt;\AppData\Roaming\Foo Bar``</span>
<span class="w"> </span>    Windows (not roaming):
<span class="gd">-      ``C:\\Users\\&lt;user&gt;\\AppData\\Local\\Foo Bar``</span>
<span class="gi">+      ``C:\Users\&lt;user&gt;\AppData\Local\Foo Bar``</span>

<span class="w"> </span>    .. versionadded:: 2.0

<span class="gu">@@ -288,7 +474,22 @@ def get_app_dir(app_name: str, roaming: bool=True, force_posix: bool=False</span>
<span class="w"> </span>                        dot instead of the XDG config home or darwin&#39;s
<span class="w"> </span>                        application support folder.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if WIN:</span>
<span class="gi">+        key = &quot;APPDATA&quot; if roaming else &quot;LOCALAPPDATA&quot;</span>
<span class="gi">+        folder = os.environ.get(key)</span>
<span class="gi">+        if folder is None:</span>
<span class="gi">+            folder = os.path.expanduser(&quot;~&quot;)</span>
<span class="gi">+        return os.path.join(folder, app_name)</span>
<span class="gi">+    if force_posix:</span>
<span class="gi">+        return os.path.join(os.path.expanduser(f&quot;~/.{_posixify(app_name)}&quot;))</span>
<span class="gi">+    if sys.platform == &quot;darwin&quot;:</span>
<span class="gi">+        return os.path.join(</span>
<span class="gi">+            os.path.expanduser(&quot;~/Library/Application Support&quot;), app_name</span>
<span class="gi">+        )</span>
<span class="gi">+    return os.path.join(</span>
<span class="gi">+        os.environ.get(&quot;XDG_CONFIG_HOME&quot;, os.path.expanduser(&quot;~/.config&quot;)),</span>
<span class="gi">+        _posixify(app_name),</span>
<span class="gi">+    )</span>


<span class="w"> </span>class PacifyFlushWrapper:
<span class="gu">@@ -300,15 +501,25 @@ class PacifyFlushWrapper:</span>
<span class="w"> </span>    pipe, all calls and attributes are proxied.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, wrapped: t.IO[t.Any]) -&gt;None:</span>
<span class="gi">+    def __init__(self, wrapped: t.IO[t.Any]) -&gt; None:</span>
<span class="w"> </span>        self.wrapped = wrapped

<span class="gd">-    def __getattr__(self, attr: str) -&gt;t.Any:</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.wrapped.flush()</span>
<span class="gi">+        except OSError as e:</span>
<span class="gi">+            import errno</span>
<span class="gi">+</span>
<span class="gi">+            if e.errno != errno.EPIPE:</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+    def __getattr__(self, attr: str) -&gt; t.Any:</span>
<span class="w"> </span>        return getattr(self.wrapped, attr)


<span class="gd">-def _detect_program_name(path: t.Optional[str]=None, _main: t.Optional[</span>
<span class="gd">-    ModuleType]=None) -&gt;str:</span>
<span class="gi">+def _detect_program_name(</span>
<span class="gi">+    path: t.Optional[str] = None, _main: t.Optional[ModuleType] = None</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determine the command used to run the program, for use in help
<span class="w"> </span>    text. If a file or entry point was executed, the file name is
<span class="w"> </span>    returned. If ``python -m`` was used to execute a module or package,
<span class="gu">@@ -329,11 +540,45 @@ def _detect_program_name(path: t.Optional[str]=None, _main: t.Optional[</span>

<span class="w"> </span>    :meta private:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _expand_args(args: t.Iterable[str], *, user: bool=True, env: bool=True,</span>
<span class="gd">-    glob_recursive: bool=True) -&gt;t.List[str]:</span>
<span class="gi">+    if _main is None:</span>
<span class="gi">+        _main = sys.modules[&quot;__main__&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    if not path:</span>
<span class="gi">+        path = sys.argv[0]</span>
<span class="gi">+</span>
<span class="gi">+    # The value of __package__ indicates how Python was called. It may</span>
<span class="gi">+    # not exist if a setuptools script is installed as an egg. It may be</span>
<span class="gi">+    # set incorrectly for entry points created with pip on Windows.</span>
<span class="gi">+    # It is set to &quot;&quot; inside a Shiv or PEX zipapp.</span>
<span class="gi">+    if getattr(_main, &quot;__package__&quot;, None) in {None, &quot;&quot;} or (</span>
<span class="gi">+        os.name == &quot;nt&quot;</span>
<span class="gi">+        and _main.__package__ == &quot;&quot;</span>
<span class="gi">+        and not os.path.exists(path)</span>
<span class="gi">+        and os.path.exists(f&quot;{path}.exe&quot;)</span>
<span class="gi">+    ):</span>
<span class="gi">+        # Executed a file, like &quot;python app.py&quot;.</span>
<span class="gi">+        return os.path.basename(path)</span>
<span class="gi">+</span>
<span class="gi">+    # Executed a module, like &quot;python -m example&quot;.</span>
<span class="gi">+    # Rewritten by Python from &quot;-m script&quot; to &quot;/path/to/script.py&quot;.</span>
<span class="gi">+    # Need to look at main module to determine how it was executed.</span>
<span class="gi">+    py_module = t.cast(str, _main.__package__)</span>
<span class="gi">+    name = os.path.splitext(os.path.basename(path))[0]</span>
<span class="gi">+</span>
<span class="gi">+    # A submodule like &quot;example.cli&quot;.</span>
<span class="gi">+    if name != &quot;__main__&quot;:</span>
<span class="gi">+        py_module = f&quot;{py_module}.{name}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    return f&quot;python -m {py_module.lstrip(&#39;.&#39;)}&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _expand_args(</span>
<span class="gi">+    args: t.Iterable[str],</span>
<span class="gi">+    *,</span>
<span class="gi">+    user: bool = True,</span>
<span class="gi">+    env: bool = True,</span>
<span class="gi">+    glob_recursive: bool = True,</span>
<span class="gi">+) -&gt; t.List[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Simulate Unix shell expansion with Python functions.

<span class="w"> </span>    See :func:`glob.glob`, :func:`os.path.expanduser`, and
<span class="gu">@@ -355,4 +600,25 @@ def _expand_args(args: t.Iterable[str], *, user: bool=True, env: bool=True,</span>

<span class="w"> </span>    :meta private:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from glob import glob</span>
<span class="gi">+</span>
<span class="gi">+    out = []</span>
<span class="gi">+</span>
<span class="gi">+    for arg in args:</span>
<span class="gi">+        if user:</span>
<span class="gi">+            arg = os.path.expanduser(arg)</span>
<span class="gi">+</span>
<span class="gi">+        if env:</span>
<span class="gi">+            arg = os.path.expandvars(arg)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            matches = glob(arg, recursive=glob_recursive)</span>
<span class="gi">+        except re.error:</span>
<span class="gi">+            matches = []</span>
<span class="gi">+</span>
<span class="gi">+        if not matches:</span>
<span class="gi">+            out.append(arg)</span>
<span class="gi">+        else:</span>
<span class="gi">+            out.extend(matches)</span>
<span class="gi">+</span>
<span class="gi">+    return out</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>