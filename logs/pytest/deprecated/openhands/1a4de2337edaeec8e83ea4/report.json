{"created": 1732308257.3832922, "duration": 3.175534963607788, "exitcode": 1, "root": "/testbed", "environment": {}, "summary": {"passed": 17, "failed": 104, "error": 50, "total": 171, "collected": 171}, "collectors": [{"nodeid": "", "outcome": "passed", "result": [{"nodeid": "tests", "type": "Package"}]}, {"nodeid": "tests/test.py", "outcome": "passed", "result": [{"nodeid": "tests/test.py::test_deprecated_has_docstring", "type": "Function", "lineno": 6}, {"nodeid": "tests/test.py::test_deprecated_has_version", "type": "Function", "lineno": 12}]}, {"nodeid": "tests/test_deprecated.py", "outcome": "passed", "result": [{"nodeid": "tests/test_deprecated.py::test_classic_deprecated_function__warns[None]", "type": "Function", "lineno": 130}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function1]", "type": "Function", "lineno": 130}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function2]", "type": "Function", "lineno": 130}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function3]", "type": "Function", "lineno": 130}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function4]", "type": "Function", "lineno": 130}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function5]", "type": "Function", "lineno": 130}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function6]", "type": "Function", "lineno": 130}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class__warns[None]", "type": "Function", "lineno": 142}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class1]", "type": "Function", "lineno": 142}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class2]", "type": "Function", "lineno": 142}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class3]", "type": "Function", "lineno": 142}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class4]", "type": "Function", "lineno": 142}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class5]", "type": "Function", "lineno": 142}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class6]", "type": "Function", "lineno": 142}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_method__warns[None]", "type": "Function", "lineno": 154}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method1]", "type": "Function", "lineno": 154}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method2]", "type": "Function", "lineno": 154}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method3]", "type": "Function", "lineno": 154}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method4]", "type": "Function", "lineno": 154}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method5]", "type": "Function", "lineno": 154}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method6]", "type": "Function", "lineno": 154}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_static_method__warns[None]", "type": "Function", "lineno": 167}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method1]", "type": "Function", "lineno": 167}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method2]", "type": "Function", "lineno": 167}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method3]", "type": "Function", "lineno": 167}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method4]", "type": "Function", "lineno": 167}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method5]", "type": "Function", "lineno": 167}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method6]", "type": "Function", "lineno": 167}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class_method__warns[None]", "type": "Function", "lineno": 179}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method1]", "type": "Function", "lineno": 179}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method2]", "type": "Function", "lineno": 179}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method3]", "type": "Function", "lineno": 179}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method4]", "type": "Function", "lineno": 179}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method5]", "type": "Function", "lineno": 179}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method6]", "type": "Function", "lineno": 179}, {"nodeid": "tests/test_deprecated.py::test_should_raise_type_error", "type": "Function", "lineno": 194}, {"nodeid": "tests/test_deprecated.py::test_warning_msg_has_reason", "type": "Function", "lineno": 202}, {"nodeid": "tests/test_deprecated.py::test_warning_msg_has_version", "type": "Function", "lineno": 215}, {"nodeid": "tests/test_deprecated.py::test_warning_is_ignored", "type": "Function", "lineno": 228}, {"nodeid": "tests/test_deprecated.py::test_specific_warning_cls_is_used", "type": "Function", "lineno": 238}, {"nodeid": "tests/test_deprecated.py::test_respect_global_filter", "type": "Function", "lineno": 249}]}, {"nodeid": "tests/test_deprecated_class.py", "outcome": "passed", "result": [{"nodeid": "tests/test_deprecated_class.py::test_simple_class_deprecation", "type": "Function", "lineno": 10}, {"nodeid": "tests/test_deprecated_class.py::test_class_deprecation_using_wrapper", "type": "Function", "lineno": 31}, {"nodeid": "tests/test_deprecated_class.py::test_class_deprecation_using_a_simple_decorator", "type": "Function", "lineno": 60}, {"nodeid": "tests/test_deprecated_class.py::test_class_deprecation_using_deprecated_decorator", "type": "Function", "lineno": 90}, {"nodeid": "tests/test_deprecated_class.py::test_class_respect_global_filter", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_deprecated_class.py::test_subclass_deprecation_using_deprecated_decorator", "type": "Function", "lineno": 121}, {"nodeid": "tests/test_deprecated_class.py::test_simple_class_deprecation_with_args", "type": "Function", "lineno": 140}]}, {"nodeid": "tests/test_deprecated_metaclass.py", "outcome": "passed", "result": [{"nodeid": "tests/test_deprecated_metaclass.py::test_with_init", "type": "Function", "lineno": 23}, {"nodeid": "tests/test_deprecated_metaclass.py::test_with_new", "type": "Function", "lineno": 40}, {"nodeid": "tests/test_deprecated_metaclass.py::test_with_metaclass", "type": "Function", "lineno": 63}, {"nodeid": "tests/test_deprecated_metaclass.py::test_with_singleton_metaclass", "type": "Function", "lineno": 87}]}, {"nodeid": "tests/test_sphinx.py", "outcome": "passed", "result": [{"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionadded-reason&version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionadded-version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionchanged-reason&version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionchanged-version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-reason&version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionadded-reason&version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionadded-version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionchanged-reason&version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionchanged-version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-reason&version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionadded-reason&version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionadded-version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionchanged-reason&version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionchanged-version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-reason&version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionadded-reason&version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionadded-version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionchanged-reason&version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionchanged-version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-reason&version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-version]", "type": "Function", "lineno": 44}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionadded-reason&version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionadded-version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionchanged-reason&version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionchanged-version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-deprecated-reason&version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-deprecated-version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionadded-reason&version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionadded-version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionchanged-reason&version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionchanged-version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-deprecated-reason&version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-deprecated-version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionadded-reason&version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionadded-version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionchanged-reason&version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionchanged-version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-deprecated-reason&version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-deprecated-version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionadded-reason&version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionadded-version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionchanged-reason&version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionchanged-version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-deprecated-reason&version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-deprecated-version]", "type": "Function", "lineno": 108}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function0]", "type": "Function", "lineno": 247}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function1]", "type": "Function", "lineno": 247}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function2]", "type": "Function", "lineno": 247}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function3]", "type": "Function", "lineno": 247}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class0]", "type": "Function", "lineno": 258}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class1]", "type": "Function", "lineno": 258}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class2]", "type": "Function", "lineno": 258}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class3]", "type": "Function", "lineno": 258}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method0]", "type": "Function", "lineno": 272}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method1]", "type": "Function", "lineno": 272}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method2]", "type": "Function", "lineno": 272}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method3]", "type": "Function", "lineno": 272}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method0]", "type": "Function", "lineno": 284}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method1]", "type": "Function", "lineno": 284}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method2]", "type": "Function", "lineno": 284}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method3]", "type": "Function", "lineno": 284}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method0]", "type": "Function", "lineno": 295}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method1]", "type": "Function", "lineno": 295}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method2]", "type": "Function", "lineno": 295}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method3]", "type": "Function", "lineno": 295}, {"nodeid": "tests/test_sphinx.py::test_should_raise_type_error", "type": "Function", "lineno": 309}, {"nodeid": "tests/test_sphinx.py::test_warning_msg_has_reason", "type": "Function", "lineno": 320}, {"nodeid": "tests/test_sphinx.py::test_warning_msg_has_version", "type": "Function", "lineno": 333}, {"nodeid": "tests/test_sphinx.py::test_warning_is_ignored", "type": "Function", "lineno": 346}, {"nodeid": "tests/test_sphinx.py::test_specific_warning_cls_is_used", "type": "Function", "lineno": 356}, {"nodeid": "tests/test_sphinx.py::test_can_catch_warnings", "type": "Function", "lineno": 367}, {"nodeid": "tests/test_sphinx.py::test_sphinx_syntax_trimming[Use :function:`bar` instead-Use `bar` instead]", "type": "Function", "lineno": 374}, {"nodeid": "tests/test_sphinx.py::test_sphinx_syntax_trimming[Use :py:func:`bar` instead-Use `bar` instead]", "type": "Function", "lineno": 374}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :func:`bar` instead-Use `bar` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :function:`bar` instead-Use `bar` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :class:`Baz` instead-Use `Baz` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :exc:`Baz` instead-Use `Baz` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :exception:`Baz` instead-Use `Baz` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :meth:`Baz.bar` instead-Use `Baz.bar` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :method:`Baz.bar` instead-Use `Baz.bar` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :py:func:`bar` instead-Use `bar` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :cpp:func:`bar` instead-Use `bar` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :js:func:`bar` instead-Use `bar` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :func:`~pkg.mod.bar` instead-Use `~pkg.mod.bar` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :r:`` instead-Use `` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :d:r:`` instead-Use `` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :r:`foo` instead-Use `foo` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :d:r:`foo` instead-Use `foo` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use r:`bad` instead-Use r:`bad` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use ::`bad` instead-Use ::`bad` instead]", "type": "Function", "lineno": 393}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :::`bad` instead-Use :::`bad` instead]", "type": "Function", "lineno": 393}]}, {"nodeid": "tests/test_sphinx_adapter.py", "outcome": "passed", "result": [{"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter[versionchanged-wrapped]", "type": "Function", "lineno": 11}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter[versionchanged-long]", "type": "Function", "lineno": 11}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter[versionadded-wrapped]", "type": "Function", "lineno": 11}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter[versionadded-long]", "type": "Function", "lineno": 11}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter[deprecated-wrapped]", "type": "Function", "lineno": 11}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter[deprecated-long]", "type": "Function", "lineno": 11}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter__empty_docstring[versionchanged]", "type": "Function", "lineno": 72}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter__empty_docstring[versionadded]", "type": "Function", "lineno": 72}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter__empty_docstring[deprecated]", "type": "Function", "lineno": 72}, {"nodeid": "tests/test_sphinx_adapter.py::test_decorator_accept_line_length[versionadded-versionadded]", "type": "Function", "lineno": 101}, {"nodeid": "tests/test_sphinx_adapter.py::test_decorator_accept_line_length[versionchanged-versionchanged]", "type": "Function", "lineno": 101}, {"nodeid": "tests/test_sphinx_adapter.py::test_decorator_accept_line_length[deprecated-deprecated]", "type": "Function", "lineno": 101}]}, {"nodeid": "tests/test_sphinx_class.py", "outcome": "passed", "result": [{"nodeid": "tests/test_sphinx_class.py::test_class_deprecation_using_a_simple_decorator", "type": "Function", "lineno": 13}, {"nodeid": "tests/test_sphinx_class.py::test_class_deprecation_using_deprecated_decorator", "type": "Function", "lineno": 43}, {"nodeid": "tests/test_sphinx_class.py::test_subclass_deprecation_using_deprecated_decorator", "type": "Function", "lineno": 64}, {"nodeid": "tests/test_sphinx_class.py::test_isinstance_versionadded", "type": "Function", "lineno": 86}, {"nodeid": "tests/test_sphinx_class.py::test_isinstance_versionchanged", "type": "Function", "lineno": 104}, {"nodeid": "tests/test_sphinx_class.py::test_isinstance_deprecated", "type": "Function", "lineno": 121}, {"nodeid": "tests/test_sphinx_class.py::test_isinstance_versionadded_versionchanged", "type": "Function", "lineno": 138}]}, {"nodeid": "tests/test_sphinx_metaclass.py", "outcome": "passed", "result": [{"nodeid": "tests/test_sphinx_metaclass.py::test_with_init", "type": "Function", "lineno": 23}, {"nodeid": "tests/test_sphinx_metaclass.py::test_with_new", "type": "Function", "lineno": 40}, {"nodeid": "tests/test_sphinx_metaclass.py::test_with_metaclass", "type": "Function", "lineno": 63}, {"nodeid": "tests/test_sphinx_metaclass.py::test_with_singleton_metaclass", "type": "Function", "lineno": 87}]}, {"nodeid": "tests", "outcome": "passed", "result": [{"nodeid": "tests/test.py", "type": "Module"}, {"nodeid": "tests/test_deprecated.py", "type": "Module"}, {"nodeid": "tests/test_deprecated_class.py", "type": "Module"}, {"nodeid": "tests/test_deprecated_metaclass.py", "type": "Module"}, {"nodeid": "tests/test_sphinx.py", "type": "Module"}, {"nodeid": "tests/test_sphinx_adapter.py", "type": "Module"}, {"nodeid": "tests/test_sphinx_class.py", "type": "Module"}, {"nodeid": "tests/test_sphinx_metaclass.py", "type": "Module"}]}], "tests": [{"nodeid": "tests/test.py::test_deprecated_has_docstring", "lineno": 6, "outcome": "passed", "keywords": ["test_deprecated_has_docstring", "test.py", "tests", "testbed", ""], "setup": {"duration": 0.0031262509999994137, "outcome": "passed"}, "call": {"duration": 0.0025177049999998147, "outcome": "passed"}, "teardown": {"duration": 0.0023482609999998516, "outcome": "passed"}}, {"nodeid": "tests/test.py::test_deprecated_has_version", "lineno": 12, "outcome": "passed", "keywords": ["test_deprecated_has_version", "test.py", "tests", "testbed", ""], "setup": {"duration": 0.00043416099999937785, "outcome": "passed"}, "call": {"duration": 0.0016460330000001022, "outcome": "passed"}, "teardown": {"duration": 0.0009546650000000767, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_function__warns[None]", "lineno": 130, "outcome": "failed", "keywords": ["test_classic_deprecated_function__warns[None]", "None", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0009757559999998833, "outcome": "passed"}, "call": {"duration": 0.002762431999999926, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 134, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 134, "message": "TypeError"}], "longrepr": "classic_deprecated_function = None\n\n    def test_classic_deprecated_function__warns(classic_deprecated_function):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n>           classic_deprecated_function()\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:134: TypeError"}, "teardown": {"duration": 0.0008803729999993237, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function1]", "lineno": 130, "outcome": "error", "keywords": ["test_classic_deprecated_function__warns[classic_deprecated_function1]", "classic_deprecated_function1", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0011600100000004332, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 38, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 38, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_function' for <Function test_classic_deprecated_function__warns[classic_deprecated_function1]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_function(request):\n        if request.param is None:\n    \n            @deprecated.classic.deprecated\n            def foo1():\n                pass\n    \n            return foo1\n        else:\n            args, kwargs = request.param\n    \n            @deprecated.classic.deprecated(*args, **kwargs)\n>           def foo1():\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:38: TypeError"}, "teardown": {"duration": 0.0010352469999999059, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function2]", "lineno": 130, "outcome": "error", "keywords": ["test_classic_deprecated_function__warns[classic_deprecated_function2]", "classic_deprecated_function2", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0010524670000000569, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 38, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 38, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_function' for <Function test_classic_deprecated_function__warns[classic_deprecated_function2]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_function(request):\n        if request.param is None:\n    \n            @deprecated.classic.deprecated\n            def foo1():\n                pass\n    \n            return foo1\n        else:\n            args, kwargs = request.param\n    \n            @deprecated.classic.deprecated(*args, **kwargs)\n>           def foo1():\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:38: TypeError"}, "teardown": {"duration": 0.0010419270000001646, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function3]", "lineno": 130, "outcome": "error", "keywords": ["test_classic_deprecated_function__warns[classic_deprecated_function3]", "classic_deprecated_function3", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0024298429999998206, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 38, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 38, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_function' for <Function test_classic_deprecated_function__warns[classic_deprecated_function3]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_function(request):\n        if request.param is None:\n    \n            @deprecated.classic.deprecated\n            def foo1():\n                pass\n    \n            return foo1\n        else:\n            args, kwargs = request.param\n    \n            @deprecated.classic.deprecated(*args, **kwargs)\n>           def foo1():\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:38: TypeError"}, "teardown": {"duration": 0.0011811710000007025, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function4]", "lineno": 130, "outcome": "error", "keywords": ["test_classic_deprecated_function__warns[classic_deprecated_function4]", "classic_deprecated_function4", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.001297654000000037, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 38, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 38, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_function' for <Function test_classic_deprecated_function__warns[classic_deprecated_function4]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_function(request):\n        if request.param is None:\n    \n            @deprecated.classic.deprecated\n            def foo1():\n                pass\n    \n            return foo1\n        else:\n            args, kwargs = request.param\n    \n            @deprecated.classic.deprecated(*args, **kwargs)\n>           def foo1():\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:38: TypeError"}, "teardown": {"duration": 0.0007142780000002347, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function5]", "lineno": 130, "outcome": "error", "keywords": ["test_classic_deprecated_function__warns[classic_deprecated_function5]", "classic_deprecated_function5", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0009900859999998346, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 38, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 38, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_function' for <Function test_classic_deprecated_function__warns[classic_deprecated_function5]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_function(request):\n        if request.param is None:\n    \n            @deprecated.classic.deprecated\n            def foo1():\n                pass\n    \n            return foo1\n        else:\n            args, kwargs = request.param\n    \n            @deprecated.classic.deprecated(*args, **kwargs)\n>           def foo1():\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:38: TypeError"}, "teardown": {"duration": 0.0009809460000003156, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function6]", "lineno": 130, "outcome": "error", "keywords": ["test_classic_deprecated_function__warns[classic_deprecated_function6]", "classic_deprecated_function6", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0012518429999994751, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 38, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 38, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_function' for <Function test_classic_deprecated_function__warns[classic_deprecated_function6]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_function(request):\n        if request.param is None:\n    \n            @deprecated.classic.deprecated\n            def foo1():\n                pass\n    \n            return foo1\n        else:\n            args, kwargs = request.param\n    \n            @deprecated.classic.deprecated(*args, **kwargs)\n>           def foo1():\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:38: TypeError"}, "teardown": {"duration": 0.0008736320000002351, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class__warns[None]", "lineno": 142, "outcome": "failed", "keywords": ["test_classic_deprecated_class__warns[None]", "None", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0014010159999999772, "outcome": "passed"}, "call": {"duration": 0.0011885710000001382, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 146, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 146, "message": "TypeError"}], "longrepr": "classic_deprecated_class = None\n\n    def test_classic_deprecated_class__warns(classic_deprecated_class):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n>           classic_deprecated_class()\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:146: TypeError"}, "teardown": {"duration": 0.001165621000000172, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class1]", "lineno": 142, "outcome": "error", "keywords": ["test_classic_deprecated_class__warns[classic_deprecated_class1]", "classic_deprecated_class1", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0009326849999995446, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 57, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 57, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_class' for <Function test_classic_deprecated_class__warns[classic_deprecated_class1]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_class(request):\n        if request.param is None:\n    \n            @deprecated.classic.deprecated\n            class Foo2(object):\n                pass\n    \n            return Foo2\n        else:\n            args, kwargs = request.param\n    \n            @deprecated.classic.deprecated(*args, **kwargs)\n>           class Foo2(object):\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:57: TypeError"}, "teardown": {"duration": 0.0008781429999995538, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class2]", "lineno": 142, "outcome": "error", "keywords": ["test_classic_deprecated_class__warns[classic_deprecated_class2]", "classic_deprecated_class2", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0013015439999994882, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 57, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 57, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_class' for <Function test_classic_deprecated_class__warns[classic_deprecated_class2]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_class(request):\n        if request.param is None:\n    \n            @deprecated.classic.deprecated\n            class Foo2(object):\n                pass\n    \n            return Foo2\n        else:\n            args, kwargs = request.param\n    \n            @deprecated.classic.deprecated(*args, **kwargs)\n>           class Foo2(object):\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:57: TypeError"}, "teardown": {"duration": 0.0012845330000006427, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class3]", "lineno": 142, "outcome": "error", "keywords": ["test_classic_deprecated_class__warns[classic_deprecated_class3]", "classic_deprecated_class3", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0013796660000000571, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 57, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 57, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_class' for <Function test_classic_deprecated_class__warns[classic_deprecated_class3]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_class(request):\n        if request.param is None:\n    \n            @deprecated.classic.deprecated\n            class Foo2(object):\n                pass\n    \n            return Foo2\n        else:\n            args, kwargs = request.param\n    \n            @deprecated.classic.deprecated(*args, **kwargs)\n>           class Foo2(object):\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:57: TypeError"}, "teardown": {"duration": 0.000971365999999918, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class4]", "lineno": 142, "outcome": "error", "keywords": ["test_classic_deprecated_class__warns[classic_deprecated_class4]", "classic_deprecated_class4", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0012085410000004515, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 57, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 57, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_class' for <Function test_classic_deprecated_class__warns[classic_deprecated_class4]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_class(request):\n        if request.param is None:\n    \n            @deprecated.classic.deprecated\n            class Foo2(object):\n                pass\n    \n            return Foo2\n        else:\n            args, kwargs = request.param\n    \n            @deprecated.classic.deprecated(*args, **kwargs)\n>           class Foo2(object):\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:57: TypeError"}, "teardown": {"duration": 0.00103731699999976, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class5]", "lineno": 142, "outcome": "error", "keywords": ["test_classic_deprecated_class__warns[classic_deprecated_class5]", "classic_deprecated_class5", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0014400170000001822, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 57, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 57, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_class' for <Function test_classic_deprecated_class__warns[classic_deprecated_class5]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_class(request):\n        if request.param is None:\n    \n            @deprecated.classic.deprecated\n            class Foo2(object):\n                pass\n    \n            return Foo2\n        else:\n            args, kwargs = request.param\n    \n            @deprecated.classic.deprecated(*args, **kwargs)\n>           class Foo2(object):\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:57: TypeError"}, "teardown": {"duration": 0.0007958109999997021, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class6]", "lineno": 142, "outcome": "error", "keywords": ["test_classic_deprecated_class__warns[classic_deprecated_class6]", "classic_deprecated_class6", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0010980280000003617, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 57, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 57, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_class' for <Function test_classic_deprecated_class__warns[classic_deprecated_class6]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_class(request):\n        if request.param is None:\n    \n            @deprecated.classic.deprecated\n            class Foo2(object):\n                pass\n    \n            return Foo2\n        else:\n            args, kwargs = request.param\n    \n            @deprecated.classic.deprecated(*args, **kwargs)\n>           class Foo2(object):\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:57: TypeError"}, "teardown": {"duration": 0.0008897330000001702, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_method__warns[None]", "lineno": 154, "outcome": "failed", "keywords": ["test_classic_deprecated_method__warns[None]", "None", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0011592300000007327, "outcome": "passed"}, "call": {"duration": 0.0012660929999999126, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 159, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 159, "message": "TypeError"}], "longrepr": "classic_deprecated_method = <class 'tests.test_deprecated.classic_deprecated_method.<locals>.Foo3'>\n\n    def test_classic_deprecated_method__warns(classic_deprecated_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            obj = classic_deprecated_method()\n>           obj.foo3()\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:159: TypeError"}, "teardown": {"duration": 0.0009815760000000395, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method1]", "lineno": 154, "outcome": "error", "keywords": ["test_classic_deprecated_method__warns[classic_deprecated_method1]", "classic_deprecated_method1", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.001103989000000638, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 78, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 76, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 78, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_method' for <Function test_classic_deprecated_method__warns[classic_deprecated_method1]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_method(request):\n        if request.param is None:\n    \n            class Foo3(object):\n                @deprecated.classic.deprecated\n                def foo3(self):\n                    pass\n    \n            return Foo3\n        else:\n            args, kwargs = request.param\n    \n>           class Foo3(object):\n\ntests/test_deprecated.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo3(object):\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo3(self):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:78: TypeError"}, "teardown": {"duration": 0.0008628729999999862, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method2]", "lineno": 154, "outcome": "error", "keywords": ["test_classic_deprecated_method__warns[classic_deprecated_method2]", "classic_deprecated_method2", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.000988695000000206, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 78, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 76, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 78, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_method' for <Function test_classic_deprecated_method__warns[classic_deprecated_method2]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_method(request):\n        if request.param is None:\n    \n            class Foo3(object):\n                @deprecated.classic.deprecated\n                def foo3(self):\n                    pass\n    \n            return Foo3\n        else:\n            args, kwargs = request.param\n    \n>           class Foo3(object):\n\ntests/test_deprecated.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo3(object):\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo3(self):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:78: TypeError"}, "teardown": {"duration": 0.0007983409999994251, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method3]", "lineno": 154, "outcome": "error", "keywords": ["test_classic_deprecated_method__warns[classic_deprecated_method3]", "classic_deprecated_method3", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0011112589999999756, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 78, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 76, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 78, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_method' for <Function test_classic_deprecated_method__warns[classic_deprecated_method3]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_method(request):\n        if request.param is None:\n    \n            class Foo3(object):\n                @deprecated.classic.deprecated\n                def foo3(self):\n                    pass\n    \n            return Foo3\n        else:\n            args, kwargs = request.param\n    \n>           class Foo3(object):\n\ntests/test_deprecated.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo3(object):\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo3(self):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:78: TypeError"}, "teardown": {"duration": 0.0012982539999999432, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method4]", "lineno": 154, "outcome": "error", "keywords": ["test_classic_deprecated_method__warns[classic_deprecated_method4]", "classic_deprecated_method4", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0013362939999996826, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 78, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 76, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 78, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_method' for <Function test_classic_deprecated_method__warns[classic_deprecated_method4]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_method(request):\n        if request.param is None:\n    \n            class Foo3(object):\n                @deprecated.classic.deprecated\n                def foo3(self):\n                    pass\n    \n            return Foo3\n        else:\n            args, kwargs = request.param\n    \n>           class Foo3(object):\n\ntests/test_deprecated.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo3(object):\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo3(self):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:78: TypeError"}, "teardown": {"duration": 0.001172570999999678, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method5]", "lineno": 154, "outcome": "error", "keywords": ["test_classic_deprecated_method__warns[classic_deprecated_method5]", "classic_deprecated_method5", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0014239370000002083, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 78, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 76, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 78, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_method' for <Function test_classic_deprecated_method__warns[classic_deprecated_method5]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_method(request):\n        if request.param is None:\n    \n            class Foo3(object):\n                @deprecated.classic.deprecated\n                def foo3(self):\n                    pass\n    \n            return Foo3\n        else:\n            args, kwargs = request.param\n    \n>           class Foo3(object):\n\ntests/test_deprecated.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo3(object):\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo3(self):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:78: TypeError"}, "teardown": {"duration": 0.0009130739999996251, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method6]", "lineno": 154, "outcome": "error", "keywords": ["test_classic_deprecated_method__warns[classic_deprecated_method6]", "classic_deprecated_method6", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0011266189999998844, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 78, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 76, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 78, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_method' for <Function test_classic_deprecated_method__warns[classic_deprecated_method6]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_method(request):\n        if request.param is None:\n    \n            class Foo3(object):\n                @deprecated.classic.deprecated\n                def foo3(self):\n                    pass\n    \n            return Foo3\n        else:\n            args, kwargs = request.param\n    \n>           class Foo3(object):\n\ntests/test_deprecated.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo3(object):\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo3(self):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:78: TypeError"}, "teardown": {"duration": 0.0015698809999999952, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_static_method__warns[None]", "lineno": 167, "outcome": "failed", "keywords": ["test_classic_deprecated_static_method__warns[None]", "None", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0008534119999996648, "outcome": "passed"}, "call": {"duration": 0.0036809549999992086, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 171, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 171, "message": "TypeError"}], "longrepr": "classic_deprecated_static_method = None\n\n    def test_classic_deprecated_static_method__warns(classic_deprecated_static_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n>           classic_deprecated_static_method()\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:171: TypeError"}, "teardown": {"duration": 0.0005256129999997583, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method1]", "lineno": 167, "outcome": "error", "keywords": ["test_classic_deprecated_static_method__warns[classic_deprecated_static_method1]", "classic_deprecated_static_method1", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0005943959999994419, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 101, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 98, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 101, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_static_method' for <Function test_classic_deprecated_static_method__warns[classic_deprecated_static_method1]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_static_method(request):\n        if request.param is None:\n    \n            class Foo4(object):\n                @staticmethod\n                @deprecated.classic.deprecated\n                def foo4():\n                    pass\n    \n            return Foo4.foo4\n        else:\n            args, kwargs = request.param\n    \n>           class Foo4(object):\n\ntests/test_deprecated.py:98: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo4(object):\n        @staticmethod\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo4():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:101: TypeError"}, "teardown": {"duration": 0.000980574999999817, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method2]", "lineno": 167, "outcome": "error", "keywords": ["test_classic_deprecated_static_method__warns[classic_deprecated_static_method2]", "classic_deprecated_static_method2", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0011580499999999105, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 101, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 98, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 101, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_static_method' for <Function test_classic_deprecated_static_method__warns[classic_deprecated_static_method2]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_static_method(request):\n        if request.param is None:\n    \n            class Foo4(object):\n                @staticmethod\n                @deprecated.classic.deprecated\n                def foo4():\n                    pass\n    \n            return Foo4.foo4\n        else:\n            args, kwargs = request.param\n    \n>           class Foo4(object):\n\ntests/test_deprecated.py:98: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo4(object):\n        @staticmethod\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo4():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:101: TypeError"}, "teardown": {"duration": 0.0010203259999999048, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method3]", "lineno": 167, "outcome": "error", "keywords": ["test_classic_deprecated_static_method__warns[classic_deprecated_static_method3]", "classic_deprecated_static_method3", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0014740889999993456, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 101, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 98, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 101, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_static_method' for <Function test_classic_deprecated_static_method__warns[classic_deprecated_static_method3]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_static_method(request):\n        if request.param is None:\n    \n            class Foo4(object):\n                @staticmethod\n                @deprecated.classic.deprecated\n                def foo4():\n                    pass\n    \n            return Foo4.foo4\n        else:\n            args, kwargs = request.param\n    \n>           class Foo4(object):\n\ntests/test_deprecated.py:98: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo4(object):\n        @staticmethod\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo4():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:101: TypeError"}, "teardown": {"duration": 0.001232412000000238, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method4]", "lineno": 167, "outcome": "error", "keywords": ["test_classic_deprecated_static_method__warns[classic_deprecated_static_method4]", "classic_deprecated_static_method4", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.001429187000000276, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 101, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 98, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 101, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_static_method' for <Function test_classic_deprecated_static_method__warns[classic_deprecated_static_method4]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_static_method(request):\n        if request.param is None:\n    \n            class Foo4(object):\n                @staticmethod\n                @deprecated.classic.deprecated\n                def foo4():\n                    pass\n    \n            return Foo4.foo4\n        else:\n            args, kwargs = request.param\n    \n>           class Foo4(object):\n\ntests/test_deprecated.py:98: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo4(object):\n        @staticmethod\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo4():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:101: TypeError"}, "teardown": {"duration": 0.001089589000000224, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method5]", "lineno": 167, "outcome": "error", "keywords": ["test_classic_deprecated_static_method__warns[classic_deprecated_static_method5]", "classic_deprecated_static_method5", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0014265070000005764, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 101, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 98, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 101, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_static_method' for <Function test_classic_deprecated_static_method__warns[classic_deprecated_static_method5]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_static_method(request):\n        if request.param is None:\n    \n            class Foo4(object):\n                @staticmethod\n                @deprecated.classic.deprecated\n                def foo4():\n                    pass\n    \n            return Foo4.foo4\n        else:\n            args, kwargs = request.param\n    \n>           class Foo4(object):\n\ntests/test_deprecated.py:98: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo4(object):\n        @staticmethod\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo4():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:101: TypeError"}, "teardown": {"duration": 0.0014610380000004142, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method6]", "lineno": 167, "outcome": "error", "keywords": ["test_classic_deprecated_static_method__warns[classic_deprecated_static_method6]", "classic_deprecated_static_method6", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0016528629999994493, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 101, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 98, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 101, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_static_method' for <Function test_classic_deprecated_static_method__warns[classic_deprecated_static_method6]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_static_method(request):\n        if request.param is None:\n    \n            class Foo4(object):\n                @staticmethod\n                @deprecated.classic.deprecated\n                def foo4():\n                    pass\n    \n            return Foo4.foo4\n        else:\n            args, kwargs = request.param\n    \n>           class Foo4(object):\n\ntests/test_deprecated.py:98: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo4(object):\n        @staticmethod\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo4():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:101: TypeError"}, "teardown": {"duration": 0.0011690200000007422, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class_method__warns[None]", "lineno": 179, "outcome": "failed", "keywords": ["test_classic_deprecated_class_method__warns[None]", "None", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.001104919000000315, "outcome": "passed"}, "call": {"duration": 0.0007065089999995777, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 184, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 184, "message": "TypeError"}], "longrepr": "classic_deprecated_class_method = <class 'tests.test_deprecated.classic_deprecated_class_method.<locals>.Foo5'>\n\n    def test_classic_deprecated_class_method__warns(classic_deprecated_class_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            cls = classic_deprecated_class_method()\n>           cls.foo5()\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:184: TypeError"}, "teardown": {"duration": 0.0005230630000001568, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method1]", "lineno": 179, "outcome": "error", "keywords": ["test_classic_deprecated_class_method__warns[classic_deprecated_class_method1]", "classic_deprecated_class_method1", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0005920049999996735, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 124, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 121, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 124, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_class_method' for <Function test_classic_deprecated_class_method__warns[classic_deprecated_class_method1]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_class_method(request):\n        if request.param is None:\n    \n            class Foo5(object):\n                @classmethod\n                @deprecated.classic.deprecated\n                def foo5(cls):\n                    pass\n    \n            return Foo5\n        else:\n            args, kwargs = request.param\n    \n>           class Foo5(object):\n\ntests/test_deprecated.py:121: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo5(object):\n        @classmethod\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo5(cls):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:124: TypeError"}, "teardown": {"duration": 0.0017643560000006886, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method2]", "lineno": 179, "outcome": "error", "keywords": ["test_classic_deprecated_class_method__warns[classic_deprecated_class_method2]", "classic_deprecated_class_method2", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0010826879999994432, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 124, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 121, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 124, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_class_method' for <Function test_classic_deprecated_class_method__warns[classic_deprecated_class_method2]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_class_method(request):\n        if request.param is None:\n    \n            class Foo5(object):\n                @classmethod\n                @deprecated.classic.deprecated\n                def foo5(cls):\n                    pass\n    \n            return Foo5\n        else:\n            args, kwargs = request.param\n    \n>           class Foo5(object):\n\ntests/test_deprecated.py:121: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo5(object):\n        @classmethod\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo5(cls):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:124: TypeError"}, "teardown": {"duration": 0.0009910459999993293, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method3]", "lineno": 179, "outcome": "error", "keywords": ["test_classic_deprecated_class_method__warns[classic_deprecated_class_method3]", "classic_deprecated_class_method3", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0013084939999998824, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 124, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 121, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 124, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_class_method' for <Function test_classic_deprecated_class_method__warns[classic_deprecated_class_method3]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_class_method(request):\n        if request.param is None:\n    \n            class Foo5(object):\n                @classmethod\n                @deprecated.classic.deprecated\n                def foo5(cls):\n                    pass\n    \n            return Foo5\n        else:\n            args, kwargs = request.param\n    \n>           class Foo5(object):\n\ntests/test_deprecated.py:121: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo5(object):\n        @classmethod\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo5(cls):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:124: TypeError"}, "teardown": {"duration": 0.0018559180000004005, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method4]", "lineno": 179, "outcome": "error", "keywords": ["test_classic_deprecated_class_method__warns[classic_deprecated_class_method4]", "classic_deprecated_class_method4", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0010833980000004573, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 124, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 121, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 124, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_class_method' for <Function test_classic_deprecated_class_method__warns[classic_deprecated_class_method4]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_class_method(request):\n        if request.param is None:\n    \n            class Foo5(object):\n                @classmethod\n                @deprecated.classic.deprecated\n                def foo5(cls):\n                    pass\n    \n            return Foo5\n        else:\n            args, kwargs = request.param\n    \n>           class Foo5(object):\n\ntests/test_deprecated.py:121: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo5(object):\n        @classmethod\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo5(cls):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:124: TypeError"}, "teardown": {"duration": 0.0009634450000000072, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method5]", "lineno": 179, "outcome": "error", "keywords": ["test_classic_deprecated_class_method__warns[classic_deprecated_class_method5]", "classic_deprecated_class_method5", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0009828359999994873, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 124, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 121, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 124, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_class_method' for <Function test_classic_deprecated_class_method__warns[classic_deprecated_class_method5]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_class_method(request):\n        if request.param is None:\n    \n            class Foo5(object):\n                @classmethod\n                @deprecated.classic.deprecated\n                def foo5(cls):\n                    pass\n    \n            return Foo5\n        else:\n            args, kwargs = request.param\n    \n>           class Foo5(object):\n\ntests/test_deprecated.py:121: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo5(object):\n        @classmethod\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo5(cls):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:124: TypeError"}, "teardown": {"duration": 0.0011612400000000633, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method6]", "lineno": 179, "outcome": "error", "keywords": ["test_classic_deprecated_class_method__warns[classic_deprecated_class_method6]", "classic_deprecated_class_method6", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.000644755999999802, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 124, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 121, "message": ""}, {"path": "tests/test_deprecated.py", "lineno": 124, "message": "TypeError"}], "longrepr": "request = <SubRequest 'classic_deprecated_class_method' for <Function test_classic_deprecated_class_method__warns[classic_deprecated_class_method6]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_class_method(request):\n        if request.param is None:\n    \n            class Foo5(object):\n                @classmethod\n                @deprecated.classic.deprecated\n                def foo5(cls):\n                    pass\n    \n            return Foo5\n        else:\n            args, kwargs = request.param\n    \n>           class Foo5(object):\n\ntests/test_deprecated.py:121: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo5(object):\n        @classmethod\n        @deprecated.classic.deprecated(*args, **kwargs)\n>       def foo5(cls):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:124: TypeError"}, "teardown": {"duration": 0.001047676999999858, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_should_raise_type_error", "lineno": 194, "outcome": "failed", "keywords": ["test_should_raise_type_error", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0009415549999998163, "outcome": "passed"}, "call": {"duration": 0.0013705750000001515, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 198, "message": "AssertionError: TypeError not raised\nassert False"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 198, "message": "AssertionError"}], "longrepr": "def test_should_raise_type_error():\n        try:\n            deprecated.classic.deprecated(5)\n>           assert False, \"TypeError not raised\"\nE           AssertionError: TypeError not raised\nE           assert False\n\ntests/test_deprecated.py:198: AssertionError"}, "teardown": {"duration": 0.0015696509999996167, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_warning_msg_has_reason", "lineno": 202, "outcome": "failed", "keywords": ["test_warning_msg_has_reason", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0008673930000000496, "outcome": "passed"}, "call": {"duration": 0.0017291349999997152, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 207, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 207, "message": "TypeError"}], "longrepr": "def test_warning_msg_has_reason():\n        reason = \"Good reason\"\n    \n        @deprecated.classic.deprecated(reason=reason)\n>       def foo():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:207: TypeError"}, "teardown": {"duration": 0.0008625719999999504, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_warning_msg_has_version", "lineno": 215, "outcome": "failed", "keywords": ["test_warning_msg_has_version", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0008998029999993662, "outcome": "passed"}, "call": {"duration": 0.001191602000000458, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 220, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 220, "message": "TypeError"}], "longrepr": "def test_warning_msg_has_version():\n        version = \"1.2.3\"\n    \n        @deprecated.classic.deprecated(version=version)\n>       def foo():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:220: TypeError"}, "teardown": {"duration": 0.0014121969999996153, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_warning_is_ignored", "lineno": 228, "outcome": "failed", "keywords": ["test_warning_is_ignored", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0008328220000004549, "outcome": "passed"}, "call": {"duration": 0.00044969200000011256, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 231, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 231, "message": "TypeError"}], "longrepr": "def test_warning_is_ignored():\n        @deprecated.classic.deprecated(action='ignore')\n>       def foo():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:231: TypeError"}, "teardown": {"duration": 0.00143015699999971, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_specific_warning_cls_is_used", "lineno": 238, "outcome": "failed", "keywords": ["test_specific_warning_cls_is_used", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0007627000000001161, "outcome": "passed"}, "call": {"duration": 0.0009183840000002164, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 241, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 241, "message": "TypeError"}], "longrepr": "def test_specific_warning_cls_is_used():\n        @deprecated.classic.deprecated(category=MyDeprecationWarning)\n>       def foo():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:241: TypeError"}, "teardown": {"duration": 0.0009915560000006707, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated.py::test_respect_global_filter", "lineno": 249, "outcome": "failed", "keywords": ["test_respect_global_filter", "test_deprecated.py", "tests", "testbed", ""], "setup": {"duration": 0.0011737910000002572, "outcome": "passed"}, "call": {"duration": 0.0011382790000000753, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated.py", "lineno": 252, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated.py", "lineno": 252, "message": "TypeError"}], "longrepr": "def test_respect_global_filter():\n        @deprecated.classic.deprecated(version='1.2.1', reason=\"deprecated function\")\n>       def fun():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated.py:252: TypeError"}, "teardown": {"duration": 0.0012518630000002418, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated_class.py::test_simple_class_deprecation", "lineno": 10, "outcome": "passed", "keywords": ["test_simple_class_deprecation", "test_deprecated_class.py", "tests", "testbed", ""], "setup": {"duration": 0.0007037580000002208, "outcome": "passed"}, "call": {"duration": 0.0009648349999995531, "outcome": "passed"}, "teardown": {"duration": 0.0010363370000003869, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated_class.py::test_class_deprecation_using_wrapper", "lineno": 31, "outcome": "passed", "keywords": ["test_class_deprecation_using_wrapper", "test_deprecated_class.py", "tests", "testbed", ""], "setup": {"duration": 0.001073747999999597, "outcome": "passed"}, "call": {"duration": 0.0009004330000008665, "outcome": "passed"}, "teardown": {"duration": 0.0007121080000001001, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated_class.py::test_class_deprecation_using_a_simple_decorator", "lineno": 60, "outcome": "passed", "keywords": ["test_class_deprecation_using_a_simple_decorator", "test_deprecated_class.py", "tests", "testbed", ""], "setup": {"duration": 0.0007592499999997671, "outcome": "passed"}, "call": {"duration": 0.0008022209999998253, "outcome": "passed"}, "teardown": {"duration": 0.0008755129999995503, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated_class.py::test_class_deprecation_using_deprecated_decorator", "lineno": 90, "outcome": "failed", "keywords": ["test_class_deprecation_using_deprecated_decorator", "test_deprecated_class.py", "tests", "testbed", ""], "setup": {"duration": 0.001081287999999958, "outcome": "passed"}, "call": {"duration": 0.0010979979999996559, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated_class.py", "lineno": 96, "message": "TypeError: NoneType takes no arguments"}, "traceback": [{"path": "tests/test_deprecated_class.py", "lineno": 96, "message": "TypeError"}], "longrepr": "def test_class_deprecation_using_deprecated_decorator():\n        @deprecated.classic.deprecated\n        class MyBaseClass(object):\n            pass\n    \n>       class MySubClass(MyBaseClass):\nE       TypeError: NoneType takes no arguments\n\ntests/test_deprecated_class.py:96: TypeError"}, "teardown": {"duration": 0.0006709970000002841, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated_class.py::test_class_respect_global_filter", "lineno": 108, "outcome": "failed", "keywords": ["test_class_respect_global_filter", "test_deprecated_class.py", "tests", "testbed", ""], "setup": {"duration": 0.0009804060000000447, "outcome": "passed"}, "call": {"duration": 0.001295093999999608, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated_class.py", "lineno": 116, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated_class.py", "lineno": 116, "message": "TypeError"}], "longrepr": "def test_class_respect_global_filter():\n        @deprecated.classic.deprecated\n        class MyBaseClass(object):\n            pass\n    \n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"once\")\n>           obj = MyBaseClass()\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated_class.py:116: TypeError"}, "teardown": {"duration": 0.0010455270000004901, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated_class.py::test_subclass_deprecation_using_deprecated_decorator", "lineno": 121, "outcome": "failed", "keywords": ["test_subclass_deprecation_using_deprecated_decorator", "test_deprecated_class.py", "tests", "testbed", ""], "setup": {"duration": 0.0017093049999994392, "outcome": "passed"}, "call": {"duration": 0.0008689629999993898, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated_class.py", "lineno": 128, "message": "TypeError: NoneType takes no arguments"}, "traceback": [{"path": "tests/test_deprecated_class.py", "lineno": 128, "message": "TypeError"}], "longrepr": "def test_subclass_deprecation_using_deprecated_decorator():\n        @deprecated.classic.deprecated\n        class MyBaseClass(object):\n            pass\n    \n        @deprecated.classic.deprecated\n>       class MySubClass(MyBaseClass):\nE       TypeError: NoneType takes no arguments\n\ntests/test_deprecated_class.py:128: TypeError"}, "teardown": {"duration": 0.0012181020000001652, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated_class.py::test_simple_class_deprecation_with_args", "lineno": 140, "outcome": "failed", "keywords": ["test_simple_class_deprecation_with_args", "test_deprecated_class.py", "tests", "testbed", ""], "setup": {"duration": 0.0011276689999997203, "outcome": "passed"}, "call": {"duration": 0.0014582279999997283, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated_class.py", "lineno": 143, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated_class.py", "lineno": 143, "message": "TypeError"}], "longrepr": "def test_simple_class_deprecation_with_args():\n        @deprecated.classic.deprecated('kwargs class')\n>       class MyClass(object):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated_class.py:143: TypeError"}, "teardown": {"duration": 0.0010414069999997722, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated_metaclass.py::test_with_init", "lineno": 23, "outcome": "failed", "keywords": ["test_with_init", "test_deprecated_metaclass.py", "tests", "testbed", ""], "setup": {"duration": 0.0011235789999997081, "outcome": "passed"}, "call": {"duration": 0.001185149999999524, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated_metaclass.py", "lineno": 33, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated_metaclass.py", "lineno": 33, "message": "TypeError"}], "longrepr": "def test_with_init():\n        @deprecated.classic.deprecated\n        class MyClass(object):\n            def __init__(self, a, b=5):\n                self.a = a\n                self.b = b\n    \n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n>           obj = MyClass(\"five\")\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated_metaclass.py:33: TypeError"}, "teardown": {"duration": 0.0013434539999996886, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated_metaclass.py::test_with_new", "lineno": 40, "outcome": "failed", "keywords": ["test_with_new", "test_deprecated_metaclass.py", "tests", "testbed", ""], "setup": {"duration": 0.0008120910000002368, "outcome": "passed"}, "call": {"duration": 0.0011970410000001763, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated_metaclass.py", "lineno": 55, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated_metaclass.py", "lineno": 55, "message": "TypeError"}], "longrepr": "def test_with_new():\n        @deprecated.classic.deprecated\n        class MyClass(object):\n            def __new__(cls, a, b=5):\n                obj = super(MyClass, cls).__new__(cls)\n                obj.c = 3.14\n                return obj\n    \n            def __init__(self, a, b=5):\n                self.a = a\n                self.b = b\n    \n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n>           obj = MyClass(\"five\")\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated_metaclass.py:55: TypeError"}, "teardown": {"duration": 0.0013640459999999521, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated_metaclass.py::test_with_metaclass", "lineno": 63, "outcome": "failed", "keywords": ["test_with_metaclass", "test_deprecated_metaclass.py", "tests", "testbed", ""], "setup": {"duration": 0.0007071179999993404, "outcome": "passed"}, "call": {"duration": 0.0007913809999999799, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated_metaclass.py", "lineno": 79, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated_metaclass.py", "lineno": 79, "message": "TypeError"}], "longrepr": "def test_with_metaclass():\n        class Meta(type):\n            def __call__(cls, *args, **kwargs):\n                obj = super(Meta, cls).__call__(*args, **kwargs)\n                obj.c = 3.14\n                return obj\n    \n        @deprecated.classic.deprecated\n        class MyClass(with_metaclass(Meta)):\n            def __init__(self, a, b=5):\n                self.a = a\n                self.b = b\n    \n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n>           obj = MyClass(\"five\")\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated_metaclass.py:79: TypeError"}, "teardown": {"duration": 0.0011135290000003906, "outcome": "passed"}}, {"nodeid": "tests/test_deprecated_metaclass.py::test_with_singleton_metaclass", "lineno": 87, "outcome": "failed", "keywords": ["test_with_singleton_metaclass", "test_deprecated_metaclass.py", "tests", "testbed", ""], "setup": {"duration": 0.0007898800000001316, "outcome": "passed"}, "call": {"duration": 0.0007702499999995283, "outcome": "failed", "crash": {"path": "/testbed/tests/test_deprecated_metaclass.py", "lineno": 105, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_deprecated_metaclass.py", "lineno": 105, "message": "TypeError"}], "longrepr": "def test_with_singleton_metaclass():\n        class Singleton(type):\n            _instances = {}\n    \n            def __call__(cls, *args, **kwargs):\n                if cls not in cls._instances:\n                    cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n                return cls._instances[cls]\n    \n        @deprecated.classic.deprecated\n        class MyClass(with_metaclass(Singleton)):\n            def __init__(self, a, b=5):\n                self.a = a\n                self.b = b\n    \n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n>           obj1 = MyClass(\"five\")\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_deprecated_metaclass.py:105: TypeError"}, "teardown": {"duration": 0.001378436000000427, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionadded-reason&version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[no_docstring-versionadded-reason&version]", "parametrize", "pytestmark", "no_docstring-versionadded-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0010906789999998168, "outcome": "passed"}, "call": {"duration": 0.001343774999999603, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = None, directive = 'versionadded', reason = 'A good reason'\nversion = '1.2.0', expected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.001261142999999798, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionadded-version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[no_docstring-versionadded-version]", "parametrize", "pytestmark", "no_docstring-versionadded-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0012956929999994315, "outcome": "passed"}, "call": {"duration": 0.0011278489999995145, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = None, directive = 'versionadded', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.00123852199999952, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionadded-reason&version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[no_docstring-versionadded-reason&version]", "parametrize", "skipif", "pytestmark", "no_docstring-versionadded-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0013719249999999406, "outcome": "passed"}, "call": {"duration": 0.0006983680000001158, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = None, directive = 'versionadded', reason = 'A good reason'\nversion = '1.2.0', expected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0010549470000000838, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionadded-version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[no_docstring-versionadded-version]", "parametrize", "skipif", "pytestmark", "no_docstring-versionadded-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0010829179999998217, "outcome": "passed"}, "call": {"duration": 0.0011986509999992734, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = None, directive = 'versionadded', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.00129449400000059, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionchanged-reason&version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[no_docstring-versionchanged-reason&version]", "parametrize", "pytestmark", "no_docstring-versionchanged-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0011051389999998662, "outcome": "passed"}, "call": {"duration": 0.0010363670000002045, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = None, directive = 'versionchanged', reason = 'A good reason'\nversion = '1.2.0', expected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0016158820000002905, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionchanged-version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[no_docstring-versionchanged-version]", "parametrize", "pytestmark", "no_docstring-versionchanged-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0013443950000002758, "outcome": "passed"}, "call": {"duration": 0.0009019230000006928, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = None, directive = 'versionchanged', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.002068654000000336, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionchanged-reason&version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[no_docstring-versionchanged-reason&version]", "parametrize", "skipif", "pytestmark", "no_docstring-versionchanged-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0015100789999999975, "outcome": "passed"}, "call": {"duration": 0.0009843250000001191, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = None, directive = 'versionchanged', reason = 'A good reason'\nversion = '1.2.0', expected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0016994840000004174, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionchanged-version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[no_docstring-versionchanged-version]", "parametrize", "skipif", "pytestmark", "no_docstring-versionchanged-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.002425813000000332, "outcome": "passed"}, "call": {"duration": 0.0008920130000005244, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = None, directive = 'versionchanged', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0013483550000001898, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionchanged-reason&version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[short_docstring-versionchanged-reason&version]", "parametrize", "pytestmark", "short_docstring-versionchanged-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0008302310000001256, "outcome": "passed"}, "call": {"duration": 0.0034495390000000015, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.', directive = 'versionchanged'\nreason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0015026989999995521, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionchanged-version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[short_docstring-versionchanged-version]", "parametrize", "pytestmark", "short_docstring-versionchanged-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0014390280000000644, "outcome": "passed"}, "call": {"duration": 0.0008260020000001589, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.', directive = 'versionchanged'\nreason = None, version = '1.2.0', expected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0015197489999998481, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionchanged-reason&version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[short_docstring-versionchanged-reason&version]", "parametrize", "skipif", "pytestmark", "short_docstring-versionchanged-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0014426869999999425, "outcome": "passed"}, "call": {"duration": 0.0011804900000003116, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.', directive = 'versionchanged'\nreason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0012176010000004567, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionchanged-version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[short_docstring-versionchanged-version]", "parametrize", "skipif", "pytestmark", "short_docstring-versionchanged-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.005009290000000277, "outcome": "passed"}, "call": {"duration": 0.0010556580000002924, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.', directive = 'versionchanged'\nreason = None, version = '1.2.0', expected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0013864259999998296, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionadded-reason&version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[short_docstring-versionadded-reason&version]", "parametrize", "pytestmark", "short_docstring-versionadded-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0010597580000002438, "outcome": "passed"}, "call": {"duration": 0.0009486949999999439, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.', directive = 'versionadded'\nreason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0012692930000000047, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionadded-version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[short_docstring-versionadded-version]", "parametrize", "pytestmark", "short_docstring-versionadded-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0010036059999993796, "outcome": "passed"}, "call": {"duration": 0.0010083569999999042, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.', directive = 'versionadded'\nreason = None, version = '1.2.0', expected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0016430630000003887, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionadded-reason&version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[short_docstring-versionadded-reason&version]", "parametrize", "skipif", "pytestmark", "short_docstring-versionadded-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0016189519999993962, "outcome": "passed"}, "call": {"duration": 0.0011939209999995981, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.', directive = 'versionadded'\nreason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0010529070000000473, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionadded-version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[short_docstring-versionadded-version]", "parametrize", "skipif", "pytestmark", "short_docstring-versionadded-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0012432920000007286, "outcome": "passed"}, "call": {"duration": 0.0012207619999999864, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.', directive = 'versionadded'\nreason = None, version = '1.2.0', expected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0012538429999997547, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-reason&version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[short_docstring-deprecated-reason&version]", "parametrize", "pytestmark", "short_docstring-deprecated-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0006511570000000688, "outcome": "passed"}, "call": {"duration": 0.0035562829999999934, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.', directive = 'deprecated'\nreason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0011504900000005591, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[short_docstring-deprecated-version]", "parametrize", "pytestmark", "short_docstring-deprecated-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0010333070000001499, "outcome": "passed"}, "call": {"duration": 0.0006871680000006819, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.', directive = 'deprecated'\nreason = None, version = '1.2.0', expected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0012851529999995392, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-deprecated-reason&version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[short_docstring-deprecated-reason&version]", "parametrize", "skipif", "pytestmark", "short_docstring-deprecated-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0011357389999995249, "outcome": "passed"}, "call": {"duration": 0.0012770539999999997, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.', directive = 'deprecated'\nreason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.003354336999999319, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-deprecated-version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[short_docstring-deprecated-version]", "parametrize", "skipif", "pytestmark", "short_docstring-deprecated-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.001464709000000397, "outcome": "passed"}, "call": {"duration": 0.0020743139999996885, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.', directive = 'deprecated'\nreason = None, version = '1.2.0', expected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0012222519999998127, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-reason&version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[no_docstring-deprecated-reason&version]", "parametrize", "pytestmark", "no_docstring-deprecated-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0023247800000003593, "outcome": "passed"}, "call": {"duration": 0.0010340969999997895, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = None, directive = 'deprecated', reason = 'A good reason'\nversion = '1.2.0', expected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0014535469999996664, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[no_docstring-deprecated-version]", "parametrize", "pytestmark", "no_docstring-deprecated-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0012895839999993441, "outcome": "passed"}, "call": {"duration": 0.0012799640000000778, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = None, directive = 'deprecated', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0011845609999996398, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-deprecated-reason&version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[no_docstring-deprecated-reason&version]", "parametrize", "skipif", "pytestmark", "no_docstring-deprecated-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0014290470000002387, "outcome": "passed"}, "call": {"duration": 0.0012756329999996652, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = None, directive = 'deprecated', reason = 'A good reason'\nversion = '1.2.0', expected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.001217361000000139, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-deprecated-version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[no_docstring-deprecated-version]", "parametrize", "skipif", "pytestmark", "no_docstring-deprecated-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0013045839999996645, "outcome": "passed"}, "call": {"duration": 0.0012325019999996911, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = None, directive = 'deprecated', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0007124480000006983, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-reason&version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[D213_long_docstring-deprecated-reason&version]", "parametrize", "pytestmark", "D213_long_docstring-deprecated-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0005794249999997447, "outcome": "passed"}, "call": {"duration": 0.0005040129999995813, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = '\\n        This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'deprecated', reason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0012651129999996513, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[D213_long_docstring-deprecated-version]", "parametrize", "pytestmark", "D213_long_docstring-deprecated-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.000951935000000681, "outcome": "passed"}, "call": {"duration": 0.0010502770000000439, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = '\\n        This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'deprecated', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0012499529999994152, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-deprecated-reason&version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[D213_long_docstring-deprecated-reason&version]", "parametrize", "skipif", "pytestmark", "D213_long_docstring-deprecated-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0013729559999999807, "outcome": "passed"}, "call": {"duration": 0.0011609500000000494, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = '\\n        This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'deprecated', reason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0008837630000000374, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-deprecated-version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[D213_long_docstring-deprecated-version]", "parametrize", "skipif", "pytestmark", "D213_long_docstring-deprecated-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0016418829999995666, "outcome": "passed"}, "call": {"duration": 0.0013283739999998545, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = '\\n        This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'deprecated', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0010126059999997494, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionchanged-reason&version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[D213_long_docstring-versionchanged-reason&version]", "parametrize", "pytestmark", "D213_long_docstring-versionchanged-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0012122520000001913, "outcome": "passed"}, "call": {"duration": 0.0025489160000002897, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = '\\n        This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'versionchanged', reason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0009004639999998787, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionchanged-version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[D213_long_docstring-versionchanged-version]", "parametrize", "pytestmark", "D213_long_docstring-versionchanged-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0010235459999998753, "outcome": "passed"}, "call": {"duration": 0.0011554910000004526, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = '\\n        This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'versionchanged', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0009108429999997725, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionchanged-reason&version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[D213_long_docstring-versionchanged-reason&version]", "parametrize", "skipif", "pytestmark", "D213_long_docstring-versionchanged-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0010386769999994883, "outcome": "passed"}, "call": {"duration": 0.000943225000000325, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = '\\n        This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'versionchanged', reason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0016508629999991697, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionchanged-version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[D213_long_docstring-versionchanged-version]", "parametrize", "skipif", "pytestmark", "D213_long_docstring-versionchanged-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0031845730000004124, "outcome": "passed"}, "call": {"duration": 0.000730979000000076, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = '\\n        This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'versionchanged', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0011570899999995277, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionadded-reason&version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[D213_long_docstring-versionadded-reason&version]", "parametrize", "pytestmark", "D213_long_docstring-versionadded-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0033095060000007948, "outcome": "passed"}, "call": {"duration": 0.0011477200000005183, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = '\\n        This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'versionadded', reason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.001030606000000489, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionadded-version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[D213_long_docstring-versionadded-version]", "parametrize", "pytestmark", "D213_long_docstring-versionadded-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0012915629999996625, "outcome": "passed"}, "call": {"duration": 0.0011752400000002439, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = '\\n        This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'versionadded', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0011818510000001226, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionadded-reason&version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[D213_long_docstring-versionadded-reason&version]", "parametrize", "skipif", "pytestmark", "D213_long_docstring-versionadded-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0014582680000003734, "outcome": "passed"}, "call": {"duration": 0.0010696780000003514, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = '\\n        This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'versionadded', reason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0013016539999997079, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionadded-version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[D213_long_docstring-versionadded-version]", "parametrize", "skipif", "pytestmark", "D213_long_docstring-versionadded-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0013701550000000395, "outcome": "passed"}, "call": {"duration": 0.0012833639999998425, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = '\\n        This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'versionadded', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0012210619999999395, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-reason&version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[D212_long_docstring-deprecated-reason&version]", "parametrize", "pytestmark", "D212_long_docstring-deprecated-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.001416637000000165, "outcome": "passed"}, "call": {"duration": 0.0007091780000001435, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'deprecated', reason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0010988889999996587, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[D212_long_docstring-deprecated-version]", "parametrize", "pytestmark", "D212_long_docstring-deprecated-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.002045102999999493, "outcome": "passed"}, "call": {"duration": 0.0010485270000000213, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'deprecated', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0012066610000003308, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-deprecated-reason&version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[D212_long_docstring-deprecated-reason&version]", "parametrize", "skipif", "pytestmark", "D212_long_docstring-deprecated-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0025675369999991204, "outcome": "passed"}, "call": {"duration": 0.0003852799999997103, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'deprecated', reason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0025780170000002656, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-deprecated-version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[D212_long_docstring-deprecated-version]", "parametrize", "skipif", "pytestmark", "D212_long_docstring-deprecated-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0011292389999999486, "outcome": "passed"}, "call": {"duration": 0.0003466589999998604, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'deprecated', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0012535619999995973, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionchanged-reason&version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[D212_long_docstring-versionchanged-reason&version]", "parametrize", "pytestmark", "D212_long_docstring-versionchanged-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0015072690000001998, "outcome": "passed"}, "call": {"duration": 0.001748425999999803, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'versionchanged', reason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0009330439999999385, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionchanged-version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[D212_long_docstring-versionchanged-version]", "parametrize", "pytestmark", "D212_long_docstring-versionchanged-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0009219129999999964, "outcome": "passed"}, "call": {"duration": 0.0010319870000001785, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'versionchanged', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.0014495280000001998, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionchanged-reason&version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[D212_long_docstring-versionchanged-reason&version]", "parametrize", "skipif", "pytestmark", "D212_long_docstring-versionchanged-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0013001340000000638, "outcome": "passed"}, "call": {"duration": 0.0014705280000004706, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'versionchanged', reason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0012705020000005618, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionchanged-version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[D212_long_docstring-versionchanged-version]", "parametrize", "skipif", "pytestmark", "D212_long_docstring-versionchanged-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0014801089999991746, "outcome": "passed"}, "call": {"duration": 0.0011279189999999772, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'versionchanged', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0006629770000001756, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionadded-reason&version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[D212_long_docstring-versionadded-reason&version]", "parametrize", "pytestmark", "D212_long_docstring-versionadded-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0005915950000003889, "outcome": "passed"}, "call": {"duration": 0.0004043310000003686, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'versionadded', reason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.001551560999999424, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionadded-version]", "lineno": 44, "outcome": "failed", "keywords": ["test_has_sphinx_docstring[D212_long_docstring-versionadded-version]", "parametrize", "pytestmark", "D212_long_docstring-versionadded-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0019140900000005345, "outcome": "passed"}, "call": {"duration": 0.002139106000000446, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 81, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 81, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'versionadded', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n    \n        # with docstring:\n        foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:81: TypeError"}, "teardown": {"duration": 0.001256423000000062, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionadded-reason&version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[D212_long_docstring-versionadded-reason&version]", "parametrize", "skipif", "pytestmark", "D212_long_docstring-versionadded-reason&version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0012349519999999004, "outcome": "passed"}, "call": {"duration": 0.0015579099999998292, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'versionadded', reason = 'A good reason', version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n   {reason}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.001520550000000398, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionadded-version]", "lineno": 108, "outcome": "failed", "keywords": ["test_cls_has_sphinx_docstring[D212_long_docstring-versionadded-version]", "parametrize", "skipif", "pytestmark", "D212_long_docstring-versionadded-version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0018819090000006256, "outcome": "passed"}, "call": {"duration": 0.0007414099999998314, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 148, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 148, "message": "TypeError"}], "longrepr": "docstring = 'This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'versionadded', reason = None, version = '1.2.0'\nexpected = '.. {directive}:: {version}\\n'\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&version\", \"version\"],\n    )\n    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The class:\n        class Foo(object):\n            pass\n    \n        # with docstring:\n        Foo.__doc__ = docstring\n    \n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n>       Foo = decorator(Foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:148: TypeError"}, "teardown": {"duration": 0.0011727509999994723, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function0]", "lineno": 247, "outcome": "error", "keywords": ["test_sphinx_deprecated_function__warns[sphinx_deprecated_function0]", "sphinx_deprecated_function0", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0014393280000000175, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 192, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 192, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_function' for <Function test_sphinx_deprecated_function__warns[sphinx_deprecated_function0]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_function(request):\n        kwargs = request.param\n    \n        @deprecated.sphinx.deprecated(**kwargs)\n>       def foo1():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:192: TypeError"}, "teardown": {"duration": 0.0005605250000000339, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function1]", "lineno": 247, "outcome": "error", "keywords": ["test_sphinx_deprecated_function__warns[sphinx_deprecated_function1]", "sphinx_deprecated_function1", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0004634320000000969, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 192, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 192, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_function' for <Function test_sphinx_deprecated_function__warns[sphinx_deprecated_function1]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_function(request):\n        kwargs = request.param\n    \n        @deprecated.sphinx.deprecated(**kwargs)\n>       def foo1():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:192: TypeError"}, "teardown": {"duration": 0.0007723699999999667, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function2]", "lineno": 247, "outcome": "error", "keywords": ["test_sphinx_deprecated_function__warns[sphinx_deprecated_function2]", "sphinx_deprecated_function2", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.003590384000000668, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 192, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 192, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_function' for <Function test_sphinx_deprecated_function__warns[sphinx_deprecated_function2]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_function(request):\n        kwargs = request.param\n    \n        @deprecated.sphinx.deprecated(**kwargs)\n>       def foo1():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:192: TypeError"}, "teardown": {"duration": 0.0015118589999998377, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function3]", "lineno": 247, "outcome": "error", "keywords": ["test_sphinx_deprecated_function__warns[sphinx_deprecated_function3]", "sphinx_deprecated_function3", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0016475030000000501, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 192, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 192, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_function' for <Function test_sphinx_deprecated_function__warns[sphinx_deprecated_function3]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_function(request):\n        kwargs = request.param\n    \n        @deprecated.sphinx.deprecated(**kwargs)\n>       def foo1():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:192: TypeError"}, "teardown": {"duration": 0.0014369069999995432, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class0]", "lineno": 258, "outcome": "error", "keywords": ["test_sphinx_deprecated_class__warns[sphinx_deprecated_class0]", "skipif", "pytestmark", "sphinx_deprecated_class0", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0010177169999998625, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 203, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 203, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_class' for <Function test_sphinx_deprecated_class__warns[sphinx_deprecated_class0]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_class(request):\n        kwargs = request.param\n    \n        @deprecated.sphinx.deprecated(**kwargs)\n>       class Foo2(object):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:203: TypeError"}, "teardown": {"duration": 0.001454547999999889, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class1]", "lineno": 258, "outcome": "error", "keywords": ["test_sphinx_deprecated_class__warns[sphinx_deprecated_class1]", "skipif", "pytestmark", "sphinx_deprecated_class1", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0015022589999995617, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 203, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 203, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_class' for <Function test_sphinx_deprecated_class__warns[sphinx_deprecated_class1]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_class(request):\n        kwargs = request.param\n    \n        @deprecated.sphinx.deprecated(**kwargs)\n>       class Foo2(object):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:203: TypeError"}, "teardown": {"duration": 0.001554110000000719, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class2]", "lineno": 258, "outcome": "error", "keywords": ["test_sphinx_deprecated_class__warns[sphinx_deprecated_class2]", "skipif", "pytestmark", "sphinx_deprecated_class2", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.003285085000000798, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 203, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 203, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_class' for <Function test_sphinx_deprecated_class__warns[sphinx_deprecated_class2]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_class(request):\n        kwargs = request.param\n    \n        @deprecated.sphinx.deprecated(**kwargs)\n>       class Foo2(object):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:203: TypeError"}, "teardown": {"duration": 0.0013925959999996351, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class3]", "lineno": 258, "outcome": "error", "keywords": ["test_sphinx_deprecated_class__warns[sphinx_deprecated_class3]", "skipif", "pytestmark", "sphinx_deprecated_class3", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0014816789999994029, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 203, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 203, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_class' for <Function test_sphinx_deprecated_class__warns[sphinx_deprecated_class3]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_class(request):\n        kwargs = request.param\n    \n        @deprecated.sphinx.deprecated(**kwargs)\n>       class Foo2(object):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:203: TypeError"}, "teardown": {"duration": 0.001293813000000199, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method0]", "lineno": 272, "outcome": "error", "keywords": ["test_sphinx_deprecated_method__warns[sphinx_deprecated_method0]", "sphinx_deprecated_method0", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0023353210000003344, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 215, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 213, "message": ""}, {"path": "tests/test_sphinx.py", "lineno": 215, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_method' for <Function test_sphinx_deprecated_method__warns[sphinx_deprecated_method0]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_method(request):\n        kwargs = request.param\n    \n>       class Foo3(object):\n\ntests/test_sphinx.py:213: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo3(object):\n        @deprecated.sphinx.deprecated(**kwargs)\n>       def foo3(self):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:215: TypeError"}, "teardown": {"duration": 0.001338384999999498, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method1]", "lineno": 272, "outcome": "error", "keywords": ["test_sphinx_deprecated_method__warns[sphinx_deprecated_method1]", "sphinx_deprecated_method1", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0012921029999999334, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 215, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 213, "message": ""}, {"path": "tests/test_sphinx.py", "lineno": 215, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_method' for <Function test_sphinx_deprecated_method__warns[sphinx_deprecated_method1]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_method(request):\n        kwargs = request.param\n    \n>       class Foo3(object):\n\ntests/test_sphinx.py:213: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo3(object):\n        @deprecated.sphinx.deprecated(**kwargs)\n>       def foo3(self):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:215: TypeError"}, "teardown": {"duration": 0.0013390050000001708, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method2]", "lineno": 272, "outcome": "error", "keywords": ["test_sphinx_deprecated_method__warns[sphinx_deprecated_method2]", "sphinx_deprecated_method2", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0027361309999998085, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 215, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 213, "message": ""}, {"path": "tests/test_sphinx.py", "lineno": 215, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_method' for <Function test_sphinx_deprecated_method__warns[sphinx_deprecated_method2]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_method(request):\n        kwargs = request.param\n    \n>       class Foo3(object):\n\ntests/test_sphinx.py:213: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo3(object):\n        @deprecated.sphinx.deprecated(**kwargs)\n>       def foo3(self):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:215: TypeError"}, "teardown": {"duration": 0.0011138989999999183, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method3]", "lineno": 272, "outcome": "error", "keywords": ["test_sphinx_deprecated_method__warns[sphinx_deprecated_method3]", "sphinx_deprecated_method3", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0010571669999999145, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 215, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 213, "message": ""}, {"path": "tests/test_sphinx.py", "lineno": 215, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_method' for <Function test_sphinx_deprecated_method__warns[sphinx_deprecated_method3]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_method(request):\n        kwargs = request.param\n    \n>       class Foo3(object):\n\ntests/test_sphinx.py:213: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo3(object):\n        @deprecated.sphinx.deprecated(**kwargs)\n>       def foo3(self):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:215: TypeError"}, "teardown": {"duration": 0.0013097630000000748, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method0]", "lineno": 284, "outcome": "error", "keywords": ["test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method0]", "sphinx_deprecated_static_method0", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.001207050999999737, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 228, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 225, "message": ""}, {"path": "tests/test_sphinx.py", "lineno": 228, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_static_method' for <Function test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method0]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_static_method(request):\n        kwargs = request.param\n    \n>       class Foo4(object):\n\ntests/test_sphinx.py:225: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo4(object):\n        @staticmethod\n        @deprecated.sphinx.deprecated(**kwargs)\n>       def foo4():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:228: TypeError"}, "teardown": {"duration": 0.0011708209999996555, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method1]", "lineno": 284, "outcome": "error", "keywords": ["test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method1]", "sphinx_deprecated_static_method1", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.001305534000000108, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 228, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 225, "message": ""}, {"path": "tests/test_sphinx.py", "lineno": 228, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_static_method' for <Function test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method1]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_static_method(request):\n        kwargs = request.param\n    \n>       class Foo4(object):\n\ntests/test_sphinx.py:225: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo4(object):\n        @staticmethod\n        @deprecated.sphinx.deprecated(**kwargs)\n>       def foo4():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:228: TypeError"}, "teardown": {"duration": 0.0010826279999998079, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method2]", "lineno": 284, "outcome": "error", "keywords": ["test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method2]", "sphinx_deprecated_static_method2", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0012596029999993874, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 228, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 225, "message": ""}, {"path": "tests/test_sphinx.py", "lineno": 228, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_static_method' for <Function test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method2]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_static_method(request):\n        kwargs = request.param\n    \n>       class Foo4(object):\n\ntests/test_sphinx.py:225: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo4(object):\n        @staticmethod\n        @deprecated.sphinx.deprecated(**kwargs)\n>       def foo4():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:228: TypeError"}, "teardown": {"duration": 0.004697651999999941, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method3]", "lineno": 284, "outcome": "error", "keywords": ["test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method3]", "sphinx_deprecated_static_method3", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.003225244000000238, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 228, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 225, "message": ""}, {"path": "tests/test_sphinx.py", "lineno": 228, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_static_method' for <Function test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method3]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_static_method(request):\n        kwargs = request.param\n    \n>       class Foo4(object):\n\ntests/test_sphinx.py:225: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo4(object):\n        @staticmethod\n        @deprecated.sphinx.deprecated(**kwargs)\n>       def foo4():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:228: TypeError"}, "teardown": {"duration": 0.0012278609999993861, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method0]", "lineno": 295, "outcome": "error", "keywords": ["test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method0]", "sphinx_deprecated_class_method0", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0012169619999999881, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 241, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 238, "message": ""}, {"path": "tests/test_sphinx.py", "lineno": 241, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_class_method' for <Function test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method0]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_class_method(request):\n        kwargs = request.param\n    \n>       class Foo5(object):\n\ntests/test_sphinx.py:238: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo5(object):\n        @classmethod\n        @deprecated.sphinx.deprecated(**kwargs)\n>       def foo5(cls):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:241: TypeError"}, "teardown": {"duration": 0.002241798000000017, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method1]", "lineno": 295, "outcome": "error", "keywords": ["test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method1]", "sphinx_deprecated_class_method1", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0022147669999998953, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 241, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 238, "message": ""}, {"path": "tests/test_sphinx.py", "lineno": 241, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_class_method' for <Function test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method1]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_class_method(request):\n        kwargs = request.param\n    \n>       class Foo5(object):\n\ntests/test_sphinx.py:238: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo5(object):\n        @classmethod\n        @deprecated.sphinx.deprecated(**kwargs)\n>       def foo5(cls):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:241: TypeError"}, "teardown": {"duration": 0.0008074410000000753, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method2]", "lineno": 295, "outcome": "error", "keywords": ["test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method2]", "sphinx_deprecated_class_method2", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0008853429999993168, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 241, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 238, "message": ""}, {"path": "tests/test_sphinx.py", "lineno": 241, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_class_method' for <Function test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method2]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_class_method(request):\n        kwargs = request.param\n    \n>       class Foo5(object):\n\ntests/test_sphinx.py:238: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo5(object):\n        @classmethod\n        @deprecated.sphinx.deprecated(**kwargs)\n>       def foo5(cls):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:241: TypeError"}, "teardown": {"duration": 0.0009486750000000654, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method3]", "lineno": 295, "outcome": "error", "keywords": ["test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method3]", "sphinx_deprecated_class_method3", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.001375665999999498, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 241, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 238, "message": ""}, {"path": "tests/test_sphinx.py", "lineno": 241, "message": "TypeError"}], "longrepr": "request = <SubRequest 'sphinx_deprecated_class_method' for <Function test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method3]>>\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def sphinx_deprecated_class_method(request):\n        kwargs = request.param\n    \n>       class Foo5(object):\n\ntests/test_sphinx.py:238: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    class Foo5(object):\n        @classmethod\n        @deprecated.sphinx.deprecated(**kwargs)\n>       def foo5(cls):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:241: TypeError"}, "teardown": {"duration": 0.000943604999999792, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_should_raise_type_error", "lineno": 309, "outcome": "passed", "keywords": ["test_should_raise_type_error", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0007571699999999737, "outcome": "passed"}, "call": {"duration": 0.0005780250000002596, "outcome": "passed"}, "teardown": {"duration": 0.0009234439999996624, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_warning_msg_has_reason", "lineno": 320, "outcome": "failed", "keywords": ["test_warning_msg_has_reason", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.001220201999999837, "outcome": "passed"}, "call": {"duration": 0.0008479819999998028, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 325, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 325, "message": "TypeError"}], "longrepr": "def test_warning_msg_has_reason():\n        reason = \"Good reason\"\n    \n        @deprecated.sphinx.deprecated(version=\"4.5.6\", reason=reason)\n>       def foo():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:325: TypeError"}, "teardown": {"duration": 0.0009808260000001567, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_warning_msg_has_version", "lineno": 333, "outcome": "failed", "keywords": ["test_warning_msg_has_version", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0011828910000000192, "outcome": "passed"}, "call": {"duration": 0.0008657129999996016, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 338, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 338, "message": "TypeError"}], "longrepr": "def test_warning_msg_has_version():\n        version = \"1.2.3\"\n    \n        @deprecated.sphinx.deprecated(version=version)\n>       def foo():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:338: TypeError"}, "teardown": {"duration": 0.0013313749999994684, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_warning_is_ignored", "lineno": 346, "outcome": "failed", "keywords": ["test_warning_is_ignored", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0012305020000002997, "outcome": "passed"}, "call": {"duration": 0.0011384400000000738, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 349, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 349, "message": "TypeError"}], "longrepr": "def test_warning_is_ignored():\n        @deprecated.sphinx.deprecated(version=\"4.5.6\", action='ignore')\n>       def foo():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:349: TypeError"}, "teardown": {"duration": 0.0012844330000003623, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_specific_warning_cls_is_used", "lineno": 356, "outcome": "failed", "keywords": ["test_specific_warning_cls_is_used", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0012853840000000005, "outcome": "passed"}, "call": {"duration": 0.0011130890000004001, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 359, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 359, "message": "TypeError"}], "longrepr": "def test_specific_warning_cls_is_used():\n        @deprecated.sphinx.deprecated(version=\"4.5.6\", category=MyDeprecationWarning)\n>       def foo():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:359: TypeError"}, "teardown": {"duration": 0.002352451000000144, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_can_catch_warnings", "lineno": 367, "outcome": "passed", "keywords": ["test_can_catch_warnings", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0009485950000005516, "outcome": "passed"}, "call": {"duration": 0.0011226399999992864, "outcome": "passed"}, "teardown": {"duration": 0.0012311819999997198, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_syntax_trimming[Use :function:`bar` instead-Use `bar` instead]", "lineno": 374, "outcome": "failed", "keywords": ["test_sphinx_syntax_trimming[Use :function:`bar` instead-Use `bar` instead]", "parametrize", "pytestmark", "Use :function:`bar` instead-Use `bar` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.001086007999999694, "outcome": "passed"}, "call": {"duration": 0.0007789300000000665, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 384, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 384, "message": "TypeError"}], "longrepr": "reason = 'Use :function:`bar` instead', expected = 'Use `bar` instead'\n\n    @pytest.mark.parametrize(\n        [\"reason\", \"expected\"],\n        [\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n        ],\n    )\n    def test_sphinx_syntax_trimming(reason, expected):\n        @deprecated.sphinx.deprecated(version=\"4.5.6\", reason=reason)\n>       def foo():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:384: TypeError"}, "teardown": {"duration": 0.0005043329999994128, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_sphinx_syntax_trimming[Use :py:func:`bar` instead-Use `bar` instead]", "lineno": 374, "outcome": "failed", "keywords": ["test_sphinx_syntax_trimming[Use :py:func:`bar` instead-Use `bar` instead]", "parametrize", "pytestmark", "Use :py:func:`bar` instead-Use `bar` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0012633429999997503, "outcome": "passed"}, "call": {"duration": 0.001095848000000288, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 384, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 384, "message": "TypeError"}], "longrepr": "reason = 'Use :py:func:`bar` instead', expected = 'Use `bar` instead'\n\n    @pytest.mark.parametrize(\n        [\"reason\", \"expected\"],\n        [\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n        ],\n    )\n    def test_sphinx_syntax_trimming(reason, expected):\n        @deprecated.sphinx.deprecated(version=\"4.5.6\", reason=reason)\n>       def foo():\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx.py:384: TypeError"}, "teardown": {"duration": 0.0014032160000008176, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :func:`bar` instead-Use `bar` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use :func:`bar` instead-Use `bar` instead]", "parametrize", "pytestmark", "Use :func:`bar` instead-Use `bar` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0016289020000002097, "outcome": "passed"}, "call": {"duration": 0.0020797539999994896, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use :func:`bar` instead', expected = 'Use `bar` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.001516220000000068, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :function:`bar` instead-Use `bar` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use :function:`bar` instead-Use `bar` instead]", "parametrize", "pytestmark", "Use :function:`bar` instead-Use `bar` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0016446119999997677, "outcome": "passed"}, "call": {"duration": 0.0007619999999999294, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use :function:`bar` instead', expected = 'Use `bar` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.0012564330000000012, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :class:`Baz` instead-Use `Baz` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use :class:`Baz` instead-Use `Baz` instead]", "parametrize", "pytestmark", "Use :class:`Baz` instead-Use `Baz` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0012787930000000003, "outcome": "passed"}, "call": {"duration": 0.0011688799999998167, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use :class:`Baz` instead', expected = 'Use `Baz` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.0014259880000002667, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :exc:`Baz` instead-Use `Baz` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use :exc:`Baz` instead-Use `Baz` instead]", "parametrize", "pytestmark", "Use :exc:`Baz` instead-Use `Baz` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0013826259999998314, "outcome": "passed"}, "call": {"duration": 0.001373975999999999, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use :exc:`Baz` instead', expected = 'Use `Baz` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.0015227099999997051, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :exception:`Baz` instead-Use `Baz` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use :exception:`Baz` instead-Use `Baz` instead]", "parametrize", "pytestmark", "Use :exception:`Baz` instead-Use `Baz` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0013382650000002272, "outcome": "passed"}, "call": {"duration": 0.0006043460000002554, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use :exception:`Baz` instead', expected = 'Use `Baz` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.0012928529999998162, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :meth:`Baz.bar` instead-Use `Baz.bar` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use :meth:`Baz.bar` instead-Use `Baz.bar` instead]", "parametrize", "pytestmark", "Use :meth:`Baz.bar` instead-Use `Baz.bar` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0013024939999999319, "outcome": "passed"}, "call": {"duration": 0.0007541590000004206, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use :meth:`Baz.bar` instead', expected = 'Use `Baz.bar` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.00103731699999976, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :method:`Baz.bar` instead-Use `Baz.bar` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use :method:`Baz.bar` instead-Use `Baz.bar` instead]", "parametrize", "pytestmark", "Use :method:`Baz.bar` instead-Use `Baz.bar` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.000978646000000083, "outcome": "passed"}, "call": {"duration": 0.0008458620000002526, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use :method:`Baz.bar` instead', expected = 'Use `Baz.bar` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.001317754999999643, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :py:func:`bar` instead-Use `bar` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use :py:func:`bar` instead-Use `bar` instead]", "parametrize", "pytestmark", "Use :py:func:`bar` instead-Use `bar` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0013090039999994474, "outcome": "passed"}, "call": {"duration": 0.001211091000000053, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use :py:func:`bar` instead', expected = 'Use `bar` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.0014130659999995743, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :cpp:func:`bar` instead-Use `bar` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use :cpp:func:`bar` instead-Use `bar` instead]", "parametrize", "pytestmark", "Use :cpp:func:`bar` instead-Use `bar` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0013264340000000985, "outcome": "passed"}, "call": {"duration": 0.0012258520000001383, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use :cpp:func:`bar` instead', expected = 'Use `bar` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.0014165269999999452, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :js:func:`bar` instead-Use `bar` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use :js:func:`bar` instead-Use `bar` instead]", "parametrize", "pytestmark", "Use :js:func:`bar` instead-Use `bar` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0013716260000000702, "outcome": "passed"}, "call": {"duration": 0.0011845510000005888, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use :js:func:`bar` instead', expected = 'Use `bar` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.001283582999999311, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :func:`~pkg.mod.bar` instead-Use `~pkg.mod.bar` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use :func:`~pkg.mod.bar` instead-Use `~pkg.mod.bar` instead]", "parametrize", "pytestmark", "Use :func:`~pkg.mod.bar` instead-Use `~pkg.mod.bar` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0018905790000003364, "outcome": "passed"}, "call": {"duration": 0.0013197939999995967, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use :func:`~pkg.mod.bar` instead'\nexpected = 'Use `~pkg.mod.bar` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.0012945929999998995, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :r:`` instead-Use `` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use :r:`` instead-Use `` instead]", "parametrize", "pytestmark", "Use :r:`` instead-Use `` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.001387035999999675, "outcome": "passed"}, "call": {"duration": 0.0009647250000002217, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use :r:`` instead', expected = 'Use `` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.0014385670000001127, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :d:r:`` instead-Use `` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use :d:r:`` instead-Use `` instead]", "parametrize", "pytestmark", "Use :d:r:`` instead-Use `` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0014636580000004784, "outcome": "passed"}, "call": {"duration": 0.0007360990000000456, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use :d:r:`` instead', expected = 'Use `` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.0008476420000000928, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :r:`foo` instead-Use `foo` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use :r:`foo` instead-Use `foo` instead]", "parametrize", "pytestmark", "Use :r:`foo` instead-Use `foo` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.000942324000000383, "outcome": "passed"}, "call": {"duration": 0.0011487100000007189, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use :r:`foo` instead', expected = 'Use `foo` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.0011208489999994242, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :d:r:`foo` instead-Use `foo` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use :d:r:`foo` instead-Use `foo` instead]", "parametrize", "pytestmark", "Use :d:r:`foo` instead-Use `foo` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0013090340000001532, "outcome": "passed"}, "call": {"duration": 0.0009044039999999143, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use :d:r:`foo` instead', expected = 'Use `foo` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.0014258169999994408, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use r:`bad` instead-Use r:`bad` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use r:`bad` instead-Use r:`bad` instead]", "parametrize", "pytestmark", "Use r:`bad` instead-Use r:`bad` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0014127770000005313, "outcome": "passed"}, "call": {"duration": 0.0007366899999992071, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use r:`bad` instead', expected = 'Use r:`bad` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.0010304469999997679, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use ::`bad` instead-Use ::`bad` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use ::`bad` instead-Use ::`bad` instead]", "parametrize", "pytestmark", "Use ::`bad` instead-Use ::`bad` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.001254422000000588, "outcome": "passed"}, "call": {"duration": 0.001192690999999968, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use ::`bad` instead', expected = 'Use ::`bad` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.0009393639999997205, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx.py::test_get_deprecated_msg[Use :::`bad` instead-Use :::`bad` instead]", "lineno": 393, "outcome": "failed", "keywords": ["test_get_deprecated_msg[Use :::`bad` instead-Use :::`bad` instead]", "parametrize", "pytestmark", "Use :::`bad` instead-Use :::`bad` instead", "test_sphinx.py", "tests", "testbed", ""], "setup": {"duration": 0.0012700130000000698, "outcome": "passed"}, "call": {"duration": 0.0011082190000006875, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx.py", "lineno": 424, "message": "TypeError: argument of type 'NoneType' is not iterable"}, "traceback": [{"path": "tests/test_sphinx.py", "lineno": 424, "message": "TypeError"}], "longrepr": "reason = 'Use :::`bad` instead', expected = 'Use :::`bad` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n>       assert expected in actual\nE       TypeError: argument of type 'NoneType' is not iterable\n\ntests/test_sphinx.py:424: TypeError"}, "teardown": {"duration": 0.0010152560000005195, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter[versionchanged-wrapped]", "lineno": 11, "outcome": "passed", "keywords": ["test_sphinx_adapter[versionchanged-wrapped]", "parametrize", "pytestmark", "versionchanged-wrapped", "test_sphinx_adapter.py", "tests", "testbed", ""], "setup": {"duration": 0.0005013130000000032, "outcome": "passed"}, "call": {"duration": 0.0016875130000002514, "outcome": "passed"}, "teardown": {"duration": 0.0007848500000005032, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter[versionchanged-long]", "lineno": 11, "outcome": "passed", "keywords": ["test_sphinx_adapter[versionchanged-long]", "parametrize", "pytestmark", "versionchanged-long", "test_sphinx_adapter.py", "tests", "testbed", ""], "setup": {"duration": 0.000850891999999881, "outcome": "passed"}, "call": {"duration": 0.00241468200000039, "outcome": "passed"}, "teardown": {"duration": 0.0007318989999998138, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter[versionadded-wrapped]", "lineno": 11, "outcome": "passed", "keywords": ["test_sphinx_adapter[versionadded-wrapped]", "parametrize", "pytestmark", "versionadded-wrapped", "test_sphinx_adapter.py", "tests", "testbed", ""], "setup": {"duration": 0.0008232310000000354, "outcome": "passed"}, "call": {"duration": 0.000848241999999999, "outcome": "passed"}, "teardown": {"duration": 0.000693828000000174, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter[versionadded-long]", "lineno": 11, "outcome": "passed", "keywords": ["test_sphinx_adapter[versionadded-long]", "parametrize", "pytestmark", "versionadded-long", "test_sphinx_adapter.py", "tests", "testbed", ""], "setup": {"duration": 0.0006866080000005326, "outcome": "passed"}, "call": {"duration": 0.00047477299999965084, "outcome": "passed"}, "teardown": {"duration": 0.00024539699999959197, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter[deprecated-wrapped]", "lineno": 11, "outcome": "passed", "keywords": ["test_sphinx_adapter[deprecated-wrapped]", "parametrize", "pytestmark", "deprecated-wrapped", "test_sphinx_adapter.py", "tests", "testbed", ""], "setup": {"duration": 0.0013296149999995066, "outcome": "passed"}, "call": {"duration": 0.001196271000000415, "outcome": "passed"}, "teardown": {"duration": 0.0010437759999994967, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter[deprecated-long]", "lineno": 11, "outcome": "passed", "keywords": ["test_sphinx_adapter[deprecated-long]", "parametrize", "pytestmark", "deprecated-long", "test_sphinx_adapter.py", "tests", "testbed", ""], "setup": {"duration": 0.0011920210000004872, "outcome": "passed"}, "call": {"duration": 0.0009714660000001984, "outcome": "passed"}, "teardown": {"duration": 0.0010603170000003104, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter__empty_docstring[versionchanged]", "lineno": 72, "outcome": "passed", "keywords": ["test_sphinx_adapter__empty_docstring[versionchanged]", "parametrize", "pytestmark", "versionchanged", "test_sphinx_adapter.py", "tests", "testbed", ""], "setup": {"duration": 0.000321197999999967, "outcome": "passed"}, "call": {"duration": 0.0003811999999996374, "outcome": "passed"}, "teardown": {"duration": 0.00026591800000019816, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter__empty_docstring[versionadded]", "lineno": 72, "outcome": "passed", "keywords": ["test_sphinx_adapter__empty_docstring[versionadded]", "parametrize", "pytestmark", "versionadded", "test_sphinx_adapter.py", "tests", "testbed", ""], "setup": {"duration": 0.0002817870000004774, "outcome": "passed"}, "call": {"duration": 0.0005066730000002906, "outcome": "passed"}, "teardown": {"duration": 0.00019179600000018837, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_adapter.py::test_sphinx_adapter__empty_docstring[deprecated]", "lineno": 72, "outcome": "passed", "keywords": ["test_sphinx_adapter__empty_docstring[deprecated]", "parametrize", "pytestmark", "deprecated", "test_sphinx_adapter.py", "tests", "testbed", ""], "setup": {"duration": 0.00032302800000039156, "outcome": "passed"}, "call": {"duration": 0.0003185690000000463, "outcome": "passed"}, "teardown": {"duration": 0.0002454360000001543, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_adapter.py::test_decorator_accept_line_length[versionadded-versionadded]", "lineno": 101, "outcome": "failed", "keywords": ["test_decorator_accept_line_length[versionadded-versionadded]", "parametrize", "pytestmark", "versionadded-versionadded", "test_sphinx_adapter.py", "tests", "testbed", ""], "setup": {"duration": 0.0002733870000000138, "outcome": "passed"}, "call": {"duration": 0.00021440500000036167, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx_adapter.py", "lineno": 117, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx_adapter.py", "lineno": 117, "message": "TypeError"}], "longrepr": "decorator_factory = <function versionadded at 0x7ecfdf3d2dd0>\ndirective = 'versionadded'\n\n    @pytest.mark.parametrize(\n        \"decorator_factory, directive\",\n        [\n            (versionadded, \"versionadded\"),\n            (versionchanged, \"versionchanged\"),\n            (deprecated, \"deprecated\"),\n        ],\n    )\n    def test_decorator_accept_line_length(decorator_factory, directive):\n        reason = \"bar \" * 30\n        decorator = decorator_factory(reason=reason, version=\"1.2.3\", line_length=50)\n    \n        def foo():\n            pass\n    \n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx_adapter.py:117: TypeError"}, "teardown": {"duration": 0.0014976589999999845, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_adapter.py::test_decorator_accept_line_length[versionchanged-versionchanged]", "lineno": 101, "outcome": "failed", "keywords": ["test_decorator_accept_line_length[versionchanged-versionchanged]", "parametrize", "pytestmark", "versionchanged-versionchanged", "test_sphinx_adapter.py", "tests", "testbed", ""], "setup": {"duration": 0.0006524570000001617, "outcome": "passed"}, "call": {"duration": 0.00032600800000004426, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx_adapter.py", "lineno": 117, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx_adapter.py", "lineno": 117, "message": "TypeError"}], "longrepr": "decorator_factory = <function versionchanged at 0x7ecfdf3d2b90>\ndirective = 'versionchanged'\n\n    @pytest.mark.parametrize(\n        \"decorator_factory, directive\",\n        [\n            (versionadded, \"versionadded\"),\n            (versionchanged, \"versionchanged\"),\n            (deprecated, \"deprecated\"),\n        ],\n    )\n    def test_decorator_accept_line_length(decorator_factory, directive):\n        reason = \"bar \" * 30\n        decorator = decorator_factory(reason=reason, version=\"1.2.3\", line_length=50)\n    \n        def foo():\n            pass\n    \n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx_adapter.py:117: TypeError"}, "teardown": {"duration": 0.0006831380000003051, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_adapter.py::test_decorator_accept_line_length[deprecated-deprecated]", "lineno": 101, "outcome": "failed", "keywords": ["test_decorator_accept_line_length[deprecated-deprecated]", "parametrize", "pytestmark", "deprecated-deprecated", "test_sphinx_adapter.py", "tests", "testbed", ""], "setup": {"duration": 0.0005493939999992037, "outcome": "passed"}, "call": {"duration": 0.00048437199999984415, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx_adapter.py", "lineno": 117, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx_adapter.py", "lineno": 117, "message": "TypeError"}], "longrepr": "decorator_factory = <function deprecated at 0x7ecfdf3d31c0>\ndirective = 'deprecated'\n\n    @pytest.mark.parametrize(\n        \"decorator_factory, directive\",\n        [\n            (versionadded, \"versionadded\"),\n            (versionchanged, \"versionchanged\"),\n            (deprecated, \"deprecated\"),\n        ],\n    )\n    def test_decorator_accept_line_length(decorator_factory, directive):\n        reason = \"bar \" * 30\n        decorator = decorator_factory(reason=reason, version=\"1.2.3\", line_length=50)\n    \n        def foo():\n            pass\n    \n>       foo = decorator(foo)\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx_adapter.py:117: TypeError"}, "teardown": {"duration": 0.0009894959999998676, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_class.py::test_class_deprecation_using_a_simple_decorator", "lineno": 13, "outcome": "passed", "keywords": ["test_class_deprecation_using_a_simple_decorator", "test_sphinx_class.py", "tests", "testbed", ""], "setup": {"duration": 0.0003552689999999359, "outcome": "passed"}, "call": {"duration": 0.0017078750000001364, "outcome": "passed"}, "teardown": {"duration": 0.0011042090000001892, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_class.py::test_class_deprecation_using_deprecated_decorator", "lineno": 43, "outcome": "failed", "keywords": ["test_class_deprecation_using_deprecated_decorator", "skipif", "pytestmark", "test_sphinx_class.py", "tests", "testbed", ""], "setup": {"duration": 0.0014030470000001571, "outcome": "passed"}, "call": {"duration": 0.001186360000000164, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx_class.py", "lineno": 49, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx_class.py", "lineno": 49, "message": "TypeError"}], "longrepr": "@pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    def test_class_deprecation_using_deprecated_decorator():\n        @deprecated.sphinx.deprecated(version=\"7.8.9\")\n>       class MyBaseClass(object):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx_class.py:49: TypeError"}, "teardown": {"duration": 0.0009821649999999238, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_class.py::test_subclass_deprecation_using_deprecated_decorator", "lineno": 64, "outcome": "failed", "keywords": ["test_subclass_deprecation_using_deprecated_decorator", "skipif", "pytestmark", "test_sphinx_class.py", "tests", "testbed", ""], "setup": {"duration": 0.0011295089999991959, "outcome": "passed"}, "call": {"duration": 0.0011308800000007224, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx_class.py", "lineno": 70, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx_class.py", "lineno": 70, "message": "TypeError"}], "longrepr": "@pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    def test_subclass_deprecation_using_deprecated_decorator():\n        @deprecated.sphinx.deprecated(version=\"7.8.9\")\n>       class MyBaseClass(object):\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx_class.py:70: TypeError"}, "teardown": {"duration": 0.0012381220000001747, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_class.py::test_isinstance_versionadded", "lineno": 86, "outcome": "failed", "keywords": ["test_isinstance_versionadded", "skipif", "pytestmark", "test_sphinx_class.py", "tests", "testbed", ""], "setup": {"duration": 0.001291793000000041, "outcome": "passed"}, "call": {"duration": 0.000942833999999948, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx_class.py", "lineno": 93, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx_class.py", "lineno": 93, "message": "TypeError"}], "longrepr": "@pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    def test_isinstance_versionadded():\n        # https://github.com/tantale/deprecated/issues/48\n        @deprecated.sphinx.versionadded(version=\"X.Y\", reason=\"some reason\")\n>       class VersionAddedCls:\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx_class.py:93: TypeError"}, "teardown": {"duration": 0.001010996999999847, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_class.py::test_isinstance_versionchanged", "lineno": 104, "outcome": "failed", "keywords": ["test_isinstance_versionchanged", "skipif", "pytestmark", "test_sphinx_class.py", "tests", "testbed", ""], "setup": {"duration": 0.00092814399999952, "outcome": "passed"}, "call": {"duration": 0.001251951999999612, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx_class.py", "lineno": 110, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx_class.py", "lineno": 110, "message": "TypeError"}], "longrepr": "@pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    def test_isinstance_versionchanged():\n        @deprecated.sphinx.versionchanged(version=\"X.Y\", reason=\"some reason\")\n>       class VersionChangedCls:\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx_class.py:110: TypeError"}, "teardown": {"duration": 0.0021001449999999977, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_class.py::test_isinstance_deprecated", "lineno": 121, "outcome": "failed", "keywords": ["test_isinstance_deprecated", "skipif", "pytestmark", "test_sphinx_class.py", "tests", "testbed", ""], "setup": {"duration": 0.001401395999999444, "outcome": "passed"}, "call": {"duration": 0.0015236899999999665, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx_class.py", "lineno": 127, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx_class.py", "lineno": 127, "message": "TypeError"}], "longrepr": "@pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    def test_isinstance_deprecated():\n        @deprecated.sphinx.deprecated(version=\"X.Y\", reason=\"some reason\")\n>       class DeprecatedCls:\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx_class.py:127: TypeError"}, "teardown": {"duration": 0.0012922929999996668, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_class.py::test_isinstance_versionadded_versionchanged", "lineno": 138, "outcome": "failed", "keywords": ["test_isinstance_versionadded_versionchanged", "skipif", "pytestmark", "test_sphinx_class.py", "tests", "testbed", ""], "setup": {"duration": 0.0011954409999992421, "outcome": "passed"}, "call": {"duration": 0.001295844000000379, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx_class.py", "lineno": 145, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx_class.py", "lineno": 145, "message": "TypeError"}], "longrepr": "@pytest.mark.skipif(\n        sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n    )\n    def test_isinstance_versionadded_versionchanged():\n        @deprecated.sphinx.versionadded(version=\"X.Y\")\n        @deprecated.sphinx.versionchanged(version=\"X.Y.Z\")\n>       class AddedChangedCls:\nE       TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx_class.py:145: TypeError"}, "teardown": {"duration": 0.002151656000000557, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_metaclass.py::test_with_init", "lineno": 23, "outcome": "failed", "keywords": ["test_with_init", "test_sphinx_metaclass.py", "tests", "testbed", ""], "setup": {"duration": 0.0008004010000002282, "outcome": "passed"}, "call": {"duration": 0.0010761180000002923, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx_metaclass.py", "lineno": 33, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx_metaclass.py", "lineno": 33, "message": "TypeError"}], "longrepr": "def test_with_init():\n        @deprecated.classic.deprecated\n        class MyClass(object):\n            def __init__(self, a, b=5):\n                self.a = a\n                self.b = b\n    \n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n>           obj = MyClass(\"five\")\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx_metaclass.py:33: TypeError"}, "teardown": {"duration": 0.0009519249999998536, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_metaclass.py::test_with_new", "lineno": 40, "outcome": "failed", "keywords": ["test_with_new", "test_sphinx_metaclass.py", "tests", "testbed", ""], "setup": {"duration": 0.000945374999999693, "outcome": "passed"}, "call": {"duration": 0.001697784000000091, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx_metaclass.py", "lineno": 55, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx_metaclass.py", "lineno": 55, "message": "TypeError"}], "longrepr": "def test_with_new():\n        @deprecated.classic.deprecated\n        class MyClass(object):\n            def __new__(cls, a, b=5):\n                obj = super(MyClass, cls).__new__(cls)\n                obj.c = 3.14\n                return obj\n    \n            def __init__(self, a, b=5):\n                self.a = a\n                self.b = b\n    \n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n>           obj = MyClass(\"five\")\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx_metaclass.py:55: TypeError"}, "teardown": {"duration": 0.0012762539999995326, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_metaclass.py::test_with_metaclass", "lineno": 63, "outcome": "failed", "keywords": ["test_with_metaclass", "test_sphinx_metaclass.py", "tests", "testbed", ""], "setup": {"duration": 0.001112648000000327, "outcome": "passed"}, "call": {"duration": 0.0011299289999993078, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx_metaclass.py", "lineno": 79, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx_metaclass.py", "lineno": 79, "message": "TypeError"}], "longrepr": "def test_with_metaclass():\n        class Meta(type):\n            def __call__(cls, *args, **kwargs):\n                obj = super(Meta, cls).__call__(*args, **kwargs)\n                obj.c = 3.14\n                return obj\n    \n        @deprecated.classic.deprecated\n        class MyClass(with_metaclass(Meta)):\n            def __init__(self, a, b=5):\n                self.a = a\n                self.b = b\n    \n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n>           obj = MyClass(\"five\")\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx_metaclass.py:79: TypeError"}, "teardown": {"duration": 0.0006626970000001009, "outcome": "passed"}}, {"nodeid": "tests/test_sphinx_metaclass.py::test_with_singleton_metaclass", "lineno": 87, "outcome": "failed", "keywords": ["test_with_singleton_metaclass", "test_sphinx_metaclass.py", "tests", "testbed", ""], "setup": {"duration": 0.00040679099999962887, "outcome": "passed"}, "call": {"duration": 0.0004910430000002464, "outcome": "failed", "crash": {"path": "/testbed/tests/test_sphinx_metaclass.py", "lineno": 105, "message": "TypeError: 'NoneType' object is not callable"}, "traceback": [{"path": "tests/test_sphinx_metaclass.py", "lineno": 105, "message": "TypeError"}], "longrepr": "def test_with_singleton_metaclass():\n        class Singleton(type):\n            _instances = {}\n    \n            def __call__(cls, *args, **kwargs):\n                if cls not in cls._instances:\n                    cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n                return cls._instances[cls]\n    \n        @deprecated.classic.deprecated\n        class MyClass(with_metaclass(Singleton)):\n            def __init__(self, a, b=5):\n                self.a = a\n                self.b = b\n    \n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n>           obj1 = MyClass(\"five\")\nE           TypeError: 'NoneType' object is not callable\n\ntests/test_sphinx_metaclass.py:105: TypeError"}, "teardown": {"duration": 0.0003295180000000286, "outcome": "passed"}}], "warnings": [{"message": "pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html", "category": "DeprecationWarning", "when": "collect", "filename": "/testbed/tests/test.py", "lineno": 2}, {"message": "Deprecated call to `pkg_resources.declare_namespace('sphinxcontrib')`.\nImplementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages", "category": "DeprecationWarning", "when": "collect", "filename": "/testbed/.venv/lib/python3.10/site-packages/pkg_resources/__init__.py", "lineno": 3154}]}