diff --git a/jwt/algorithms.py b/jwt/algorithms.py
index b3897bf..0a18f4e 100644
--- a/jwt/algorithms.py
+++ b/jwt/algorithms.py
@@ -38,7 +38,28 @@ def get_default_algorithms() -> dict[str, Algorithm]:
     """
     Returns the algorithms that are implemented by the library.
     """
-    pass
+    default_algorithms = {
+        'none': NoneAlgorithm(),
+        'HS256': HMACAlgorithm(HMACAlgorithm.SHA256),
+        'HS384': HMACAlgorithm(HMACAlgorithm.SHA384),
+        'HS512': HMACAlgorithm(HMACAlgorithm.SHA512),
+    }
+
+    if has_crypto:
+        default_algorithms.update({
+            'RS256': RSAAlgorithm(RSAAlgorithm.SHA256),
+            'RS384': RSAAlgorithm(RSAAlgorithm.SHA384),
+            'RS512': RSAAlgorithm(RSAAlgorithm.SHA512),
+            'ES256': ECAlgorithm(ECAlgorithm.SHA256),
+            'ES384': ECAlgorithm(ECAlgorithm.SHA384),
+            'ES512': ECAlgorithm(ECAlgorithm.SHA512),
+            'PS256': RSAPSSAlgorithm(RSAPSSAlgorithm.SHA256),
+            'PS384': RSAPSSAlgorithm(RSAPSSAlgorithm.SHA384),
+            'PS512': RSAPSSAlgorithm(RSAPSSAlgorithm.SHA512),
+            'EdDSA': OKPAlgorithm(),
+        })
+
+    return default_algorithms
 
 class Algorithm(ABC):
     """
@@ -51,7 +72,17 @@ class Algorithm(ABC):
 
         If there is no hash algorithm, raises a NotImplementedError.
         """
-        pass
+        if not hasattr(self, 'hash_alg'):
+            raise NotImplementedError('Algorithm does not have a hash algorithm')
+        
+        if has_crypto and isinstance(self.hash_alg, type) and issubclass(self.hash_alg, hashes.HashAlgorithm):
+            h = hashes.Hash(self.hash_alg(), backend=default_backend())
+            h.update(bytestr)
+            return h.finalize()
+        else:
+            h = self.hash_alg()
+            h.update(bytestr)
+            return h.digest()
 
     @abstractmethod
     def prepare_key(self, key: Any) -> Any:
@@ -98,6 +129,24 @@ class NoneAlgorithm(Algorithm):
     Placeholder for use when no signing or verification
     operations are required.
     """
+    def prepare_key(self, key: Any) -> None:
+        if key not in [None, '', 'none']:
+            raise InvalidKeyError('When alg = "none", key must be empty or "none"')
+        return None
+
+    def sign(self, msg: bytes, key: Any) -> bytes:
+        return b''
+
+    def verify(self, msg: bytes, key: Any, sig: bytes) -> bool:
+        return sig == b''
+
+    @staticmethod
+    def to_jwk(key_obj: Any, as_dict: bool = False) -> NoReturn:
+        raise NotImplementedError('Algorithm "none" can\'t be exported as JWK')
+
+    @staticmethod
+    def from_jwk(jwk: str | JWKDict) -> NoReturn:
+        raise NotImplementedError('Algorithm "none" can\'t be imported from JWK')
 
 class HMACAlgorithm(Algorithm):
     """
@@ -110,6 +159,51 @@ class HMACAlgorithm(Algorithm):
 
     def __init__(self, hash_alg: HashlibHash) -> None:
         self.hash_alg = hash_alg
+
+    def prepare_key(self, key: Union[str, bytes]) -> bytes:
+        if not isinstance(key, (str, bytes)):
+            raise TypeError('Expected a string value')
+        key = force_bytes(key)
+        if is_pem_format(key) or is_ssh_key(key):
+            raise InvalidKeyError('The specified key is an asymmetric key or x509 certificate and should not be used as an HMAC secret.')
+        return key
+
+    def sign(self, msg: bytes, key: Union[str, bytes]) -> bytes:
+        key = self.prepare_key(key)
+        h = hmac.new(key, msg, self.hash_alg)
+        return h.digest()
+
+    def verify(self, msg: bytes, key: Union[str, bytes], sig: bytes) -> bool:
+        key = self.prepare_key(key)
+        h = hmac.new(key, msg, self.hash_alg)
+        try:
+            return hmac.compare_digest(sig, h.digest())
+        except TypeError:
+            return False
+
+    @staticmethod
+    def to_jwk(key_obj: Union[str, bytes], as_dict: bool = False) -> Union[str, JWKDict]:
+        key_bytes = force_bytes(key_obj)
+        jwk = {
+            'kty': 'oct',
+            'k': base64url_encode(key_bytes).decode('ascii')
+        }
+        if as_dict:
+            return jwk
+        return json.dumps(jwk)
+
+    @staticmethod
+    def from_jwk(jwk: Union[str, JWKDict]) -> bytes:
+        if isinstance(jwk, str):
+            jwk = json.loads(jwk)
+        if not isinstance(jwk, dict):
+            raise InvalidKeyError('Key must be a dict or a string')
+        if jwk.get('kty') != 'oct':
+            raise InvalidKeyError('Not an HMAC key')
+        k = jwk.get('k')
+        if not k:
+            raise InvalidKeyError('k parameter is required')
+        return base64url_decode(k)
 if has_crypto:
 
     class RSAAlgorithm(Algorithm):
@@ -124,6 +218,107 @@ if has_crypto:
         def __init__(self, hash_alg: type[hashes.HashAlgorithm]) -> None:
             self.hash_alg = hash_alg
 
+        def prepare_key(self, key: Union[str, bytes, RSAPrivateKey, RSAPublicKey]) -> Union[RSAPrivateKey, RSAPublicKey]:
+            if isinstance(key, (RSAPrivateKey, RSAPublicKey)):
+                return key
+
+            key = force_bytes(key)
+            if is_pem_format(key):
+                try:
+                    return load_pem_private_key(key, password=None, backend=default_backend())
+                except ValueError:
+                    try:
+                        return load_pem_public_key(key, backend=default_backend())
+                    except ValueError:
+                        raise InvalidKeyError('Invalid PEM format')
+            elif is_ssh_key(key):
+                try:
+                    return load_ssh_public_key(key, backend=default_backend())
+                except ValueError:
+                    raise InvalidKeyError('Invalid SSH key format')
+            else:
+                raise InvalidKeyError('Invalid key format')
+
+        def sign(self, msg: bytes, key: Union[str, bytes, RSAPrivateKey]) -> bytes:
+            key_obj = self.prepare_key(key)
+            if not isinstance(key_obj, RSAPrivateKey):
+                raise TypeError('Key must be an RSAPrivateKey instance')
+
+            padder = padding.PKCS1v15()
+            return key_obj.sign(msg, padder, self.hash_alg())
+
+        def verify(self, msg: bytes, key: Union[str, bytes, RSAPrivateKey, RSAPublicKey], sig: bytes) -> bool:
+            key_obj = self.prepare_key(key)
+            if not isinstance(key_obj, (RSAPrivateKey, RSAPublicKey)):
+                raise TypeError('Key must be an RSA key instance')
+
+            verifier = key_obj if isinstance(key_obj, RSAPublicKey) else key_obj.public_key()
+            padder = padding.PKCS1v15()
+            try:
+                verifier.verify(sig, msg, padder, self.hash_alg())
+                return True
+            except InvalidSignature:
+                return False
+
+        @staticmethod
+        def to_jwk(key_obj: Union[RSAPrivateKey, RSAPublicKey], as_dict: bool = False) -> Union[str, JWKDict]:
+            if isinstance(key_obj, RSAPrivateKey):
+                numbers = key_obj.private_numbers()
+                jwk = {
+                    'kty': 'RSA',
+                    'n': to_base64url_uint(numbers.public_numbers.n).decode('ascii'),
+                    'e': to_base64url_uint(numbers.public_numbers.e).decode('ascii'),
+                    'd': to_base64url_uint(numbers.d).decode('ascii'),
+                    'p': to_base64url_uint(numbers.p).decode('ascii'),
+                    'q': to_base64url_uint(numbers.q).decode('ascii'),
+                    'dp': to_base64url_uint(numbers.dmp1).decode('ascii'),
+                    'dq': to_base64url_uint(numbers.dmq1).decode('ascii'),
+                    'qi': to_base64url_uint(numbers.iqmp).decode('ascii')
+                }
+            else:
+                numbers = key_obj.public_numbers()
+                jwk = {
+                    'kty': 'RSA',
+                    'n': to_base64url_uint(numbers.n).decode('ascii'),
+                    'e': to_base64url_uint(numbers.e).decode('ascii')
+                }
+
+            if as_dict:
+                return jwk
+            return json.dumps(jwk)
+
+        @staticmethod
+        def from_jwk(jwk: Union[str, JWKDict]) -> Union[RSAPrivateKey, RSAPublicKey]:
+            if isinstance(jwk, str):
+                jwk = json.loads(jwk)
+            if not isinstance(jwk, dict):
+                raise InvalidKeyError('Key must be a dict or a string')
+            if jwk.get('kty') != 'RSA':
+                raise InvalidKeyError('Not an RSA key')
+
+            if 'd' in jwk and 'p' in jwk and 'q' in jwk:
+                # Private key
+                numbers = RSAPrivateNumbers(
+                    d=from_base64url_uint(jwk['d']),
+                    p=from_base64url_uint(jwk['p']),
+                    q=from_base64url_uint(jwk['q']),
+                    dmp1=from_base64url_uint(jwk['dp']),
+                    dmq1=from_base64url_uint(jwk['dq']),
+                    iqmp=from_base64url_uint(jwk['qi']),
+                    public_numbers=RSAPublicNumbers(
+                        e=from_base64url_uint(jwk['e']),
+                        n=from_base64url_uint(jwk['n'])
+                    )
+                )
+                return numbers.private_key(backend=default_backend())
+            else:
+                # Public key
+                numbers = RSAPublicNumbers(
+                    e=from_base64url_uint(jwk['e']),
+                    n=from_base64url_uint(jwk['n'])
+                )
+                return numbers.public_key(backend=default_backend())
+
     class ECAlgorithm(Algorithm):
         """
         Performs signing and verification operations using
@@ -136,10 +331,150 @@ if has_crypto:
         def __init__(self, hash_alg: type[hashes.HashAlgorithm]) -> None:
             self.hash_alg = hash_alg
 
+        def prepare_key(self, key: Union[str, bytes, EllipticCurvePrivateKey, EllipticCurvePublicKey]) -> Union[EllipticCurvePrivateKey, EllipticCurvePublicKey]:
+            if isinstance(key, (EllipticCurvePrivateKey, EllipticCurvePublicKey)):
+                return key
+
+            key = force_bytes(key)
+            if is_pem_format(key):
+                try:
+                    return load_pem_private_key(key, password=None, backend=default_backend())
+                except ValueError:
+                    try:
+                        return load_pem_public_key(key, backend=default_backend())
+                    except ValueError:
+                        raise InvalidKeyError('Invalid PEM format')
+            elif is_ssh_key(key):
+                try:
+                    return load_ssh_public_key(key, backend=default_backend())
+                except ValueError:
+                    raise InvalidKeyError('Invalid SSH key format')
+            else:
+                raise InvalidKeyError('Invalid key format')
+
+        def sign(self, msg: bytes, key: Union[str, bytes, EllipticCurvePrivateKey]) -> bytes:
+            key_obj = self.prepare_key(key)
+            if not isinstance(key_obj, EllipticCurvePrivateKey):
+                raise TypeError('Key must be an EllipticCurvePrivateKey instance')
+
+            signature = key_obj.sign(msg, ECDSA(self.hash_alg()))
+            return der_to_raw_signature(signature, key_obj.curve)
+
+        def verify(self, msg: bytes, key: Union[str, bytes, EllipticCurvePrivateKey, EllipticCurvePublicKey], sig: bytes) -> bool:
+            key_obj = self.prepare_key(key)
+            if not isinstance(key_obj, (EllipticCurvePrivateKey, EllipticCurvePublicKey)):
+                raise TypeError('Key must be an EC key instance')
+
+            verifier = key_obj if isinstance(key_obj, EllipticCurvePublicKey) else key_obj.public_key()
+            curve = verifier.curve
+
+            try:
+                der_sig = raw_to_der_signature(sig, curve)
+                verifier.verify(der_sig, msg, ECDSA(self.hash_alg()))
+                return True
+            except (InvalidSignature, ValueError):
+                return False
+
+        @staticmethod
+        def to_jwk(key_obj: Union[EllipticCurvePrivateKey, EllipticCurvePublicKey], as_dict: bool = False) -> Union[str, JWKDict]:
+            if isinstance(key_obj, EllipticCurvePrivateKey):
+                numbers = key_obj.private_numbers()
+                jwk = {
+                    'kty': 'EC',
+                    'crv': {
+                        SECP256K1: 'P-256K',
+                        SECP256R1: 'P-256',
+                        SECP384R1: 'P-384',
+                        SECP521R1: 'P-521'
+                    }[type(numbers.public_numbers.curve)],
+                    'x': to_base64url_uint(numbers.public_numbers.x).decode('ascii'),
+                    'y': to_base64url_uint(numbers.public_numbers.y).decode('ascii'),
+                    'd': to_base64url_uint(numbers.private_value).decode('ascii')
+                }
+            else:
+                numbers = key_obj.public_numbers()
+                jwk = {
+                    'kty': 'EC',
+                    'crv': {
+                        SECP256K1: 'P-256K',
+                        SECP256R1: 'P-256',
+                        SECP384R1: 'P-384',
+                        SECP521R1: 'P-521'
+                    }[type(numbers.curve)],
+                    'x': to_base64url_uint(numbers.x).decode('ascii'),
+                    'y': to_base64url_uint(numbers.y).decode('ascii')
+                }
+
+            if as_dict:
+                return jwk
+            return json.dumps(jwk)
+
+        @staticmethod
+        def from_jwk(jwk: Union[str, JWKDict]) -> Union[EllipticCurvePrivateKey, EllipticCurvePublicKey]:
+            if isinstance(jwk, str):
+                jwk = json.loads(jwk)
+            if not isinstance(jwk, dict):
+                raise InvalidKeyError('Key must be a dict or a string')
+            if jwk.get('kty') != 'EC':
+                raise InvalidKeyError('Not an EC key')
+
+            curve = {
+                'P-256K': SECP256K1,
+                'P-256': SECP256R1,
+                'P-384': SECP384R1,
+                'P-521': SECP521R1
+            }[jwk['crv']]()
+
+            if 'd' in jwk:
+                # Private key
+                numbers = EllipticCurvePrivateNumbers(
+                    private_value=from_base64url_uint(jwk['d']),
+                    public_numbers=EllipticCurvePublicNumbers(
+                        x=from_base64url_uint(jwk['x']),
+                        y=from_base64url_uint(jwk['y']),
+                        curve=curve
+                    )
+                )
+                return numbers.private_key(backend=default_backend())
+            else:
+                # Public key
+                numbers = EllipticCurvePublicNumbers(
+                    x=from_base64url_uint(jwk['x']),
+                    y=from_base64url_uint(jwk['y']),
+                    curve=curve
+                )
+                return numbers.public_key(backend=default_backend())
+
     class RSAPSSAlgorithm(RSAAlgorithm):
         """
         Performs a signature using RSASSA-PSS with MGF1
         """
+        def sign(self, msg: bytes, key: Union[str, bytes, RSAPrivateKey]) -> bytes:
+            key_obj = self.prepare_key(key)
+            if not isinstance(key_obj, RSAPrivateKey):
+                raise TypeError('Key must be an RSAPrivateKey instance')
+
+            padder = padding.PSS(
+                mgf=padding.MGF1(self.hash_alg()),
+                salt_length=padding.PSS.MAX_LENGTH
+            )
+            return key_obj.sign(msg, padder, self.hash_alg())
+
+        def verify(self, msg: bytes, key: Union[str, bytes, RSAPrivateKey, RSAPublicKey], sig: bytes) -> bool:
+            key_obj = self.prepare_key(key)
+            if not isinstance(key_obj, (RSAPrivateKey, RSAPublicKey)):
+                raise TypeError('Key must be an RSA key instance')
+
+            verifier = key_obj if isinstance(key_obj, RSAPublicKey) else key_obj.public_key()
+            padder = padding.PSS(
+                mgf=padding.MGF1(self.hash_alg()),
+                salt_length=padding.PSS.MAX_LENGTH
+            )
+            try:
+                verifier.verify(sig, msg, padder, self.hash_alg())
+                return True
+            except InvalidSignature:
+                return False
 
     class OKPAlgorithm(Algorithm):
         """
@@ -151,6 +486,27 @@ if has_crypto:
         def __init__(self, **kwargs: Any) -> None:
             pass
 
+        def prepare_key(self, key: Union[str, bytes, AllowedOKPKeys]) -> AllowedOKPKeys:
+            if isinstance(key, (Ed25519PrivateKey, Ed25519PublicKey, Ed448PrivateKey, Ed448PublicKey)):
+                return key
+
+            key = force_bytes(key)
+            if is_pem_format(key):
+                try:
+                    return load_pem_private_key(key, password=None, backend=default_backend())
+                except ValueError:
+                    try:
+                        return load_pem_public_key(key, backend=default_backend())
+                    except ValueError:
+                        raise InvalidKeyError('Invalid PEM format')
+            elif is_ssh_key(key):
+                try:
+                    return load_ssh_public_key(key, backend=default_backend())
+                except ValueError:
+                    raise InvalidKeyError('Invalid SSH key format')
+            else:
+                raise InvalidKeyError('Invalid key format')
+
         def sign(self, msg: str | bytes, key: Ed25519PrivateKey | Ed448PrivateKey) -> bytes:
             """
             Sign a message ``msg`` using the EdDSA private key ``key``
@@ -159,7 +515,11 @@ if has_crypto:
                 or :class:`.Ed448PrivateKey` isinstance
             :return bytes signature: The signature, as bytes
             """
-            pass
+            msg_bytes = force_bytes(msg)
+            key_obj = self.prepare_key(key)
+            if not isinstance(key_obj, (Ed25519PrivateKey, Ed448PrivateKey)):
+                raise TypeError('Key must be an Ed25519PrivateKey or Ed448PrivateKey instance')
+            return key_obj.sign(msg_bytes)
 
         def verify(self, msg: str | bytes, key: AllowedOKPKeys, sig: str | bytes) -> bool:
             """
@@ -171,4 +531,85 @@ if has_crypto:
                 A private or public EdDSA key instance
             :return bool verified: True if signature is valid, False if not.
             """
-            pass
\ No newline at end of file
+            msg_bytes = force_bytes(msg)
+            sig_bytes = force_bytes(sig)
+            key_obj = self.prepare_key(key)
+
+            if isinstance(key_obj, (Ed25519PrivateKey, Ed448PrivateKey)):
+                verifier = key_obj.public_key()
+            else:
+                verifier = key_obj
+
+            try:
+                verifier.verify(sig_bytes, msg_bytes)
+                return True
+            except InvalidSignature:
+                return False
+
+        @staticmethod
+        def to_jwk(key_obj: AllowedOKPKeys, as_dict: bool = False) -> Union[str, JWKDict]:
+            if isinstance(key_obj, (Ed25519PrivateKey, Ed25519PublicKey)):
+                crv = 'Ed25519'
+            elif isinstance(key_obj, (Ed448PrivateKey, Ed448PublicKey)):
+                crv = 'Ed448'
+            else:
+                raise TypeError('Key must be an EdDSA key instance')
+
+            if isinstance(key_obj, (Ed25519PrivateKey, Ed448PrivateKey)):
+                private_bytes = key_obj.private_bytes(
+                    encoding=Encoding.Raw,
+                    format=PrivateFormat.Raw,
+                    encryption_algorithm=NoEncryption()
+                )
+                public_bytes = key_obj.public_key().public_bytes(
+                    encoding=Encoding.Raw,
+                    format=PublicFormat.Raw
+                )
+                jwk = {
+                    'kty': 'OKP',
+                    'crv': crv,
+                    'x': base64url_encode(public_bytes).decode('ascii'),
+                    'd': base64url_encode(private_bytes).decode('ascii')
+                }
+            else:
+                public_bytes = key_obj.public_bytes(
+                    encoding=Encoding.Raw,
+                    format=PublicFormat.Raw
+                )
+                jwk = {
+                    'kty': 'OKP',
+                    'crv': crv,
+                    'x': base64url_encode(public_bytes).decode('ascii')
+                }
+
+            if as_dict:
+                return jwk
+            return json.dumps(jwk)
+
+        @staticmethod
+        def from_jwk(jwk: Union[str, JWKDict]) -> AllowedOKPKeys:
+            if isinstance(jwk, str):
+                jwk = json.loads(jwk)
+            if not isinstance(jwk, dict):
+                raise InvalidKeyError('Key must be a dict or a string')
+            if jwk.get('kty') != 'OKP':
+                raise InvalidKeyError('Not an OKP key')
+
+            curve = jwk.get('crv')
+            if curve not in ['Ed25519', 'Ed448']:
+                raise InvalidKeyError('Invalid curve')
+
+            x = base64url_decode(jwk['x'])
+            if 'd' in jwk:
+                # Private key
+                d = base64url_decode(jwk['d'])
+                if curve == 'Ed25519':
+                    return Ed25519PrivateKey.from_private_bytes(d)
+                else:
+                    return Ed448PrivateKey.from_private_bytes(d)
+            else:
+                # Public key
+                if curve == 'Ed25519':
+                    return Ed25519PublicKey.from_public_bytes(x)
+                else:
+                    return Ed448PublicKey.from_public_bytes(x)
\ No newline at end of file
diff --git a/jwt/api_jwk.py b/jwt/api_jwk.py
index 1d55501..89f1902 100644
--- a/jwt/api_jwk.py
+++ b/jwt/api_jwk.py
@@ -49,6 +49,34 @@ class PyJWK:
             raise PyJWKError(f'Unable to find an algorithm for key: {self._jwk_data}')
         self.key = self.Algorithm.from_jwk(self._jwk_data)
 
+    @property
+    def key_id(self) -> str | None:
+        return self._jwk_data.get('kid')
+
+    @property
+    def public_key_use(self) -> str | None:
+        return self._jwk_data.get('use')
+
+    @property
+    def key_type(self) -> str:
+        return self._jwk_data.get('kty')
+
+    @classmethod
+    def from_dict(cls, obj: JWKDict, algorithm: str | None=None) -> 'PyJWK':
+        """Creates a PyJWK from a dict object."""
+        if not isinstance(obj, dict):
+            raise InvalidKeyError('Invalid JWK format')
+        return cls(obj, algorithm)
+
+    @classmethod
+    def from_json(cls, data: str, algorithm: str | None=None) -> 'PyJWK':
+        """Creates a PyJWK from a JSON-encoded string."""
+        try:
+            obj = json.loads(data)
+        except ValueError as e:
+            raise InvalidKeyError(f'Invalid JWK format: {str(e)}')
+        return cls.from_dict(obj, algorithm)
+
 class PyJWKSet:
 
     def __init__(self, keys: list[JWKDict]) -> None:
@@ -71,8 +99,25 @@ class PyJWKSet:
                 return key
         raise KeyError(f'keyset has no key for kid: {kid}')
 
+    @classmethod
+    def from_dict(cls, obj: dict[str, Any]) -> 'PyJWKSet':
+        """Creates a PyJWKSet from a dict object."""
+        if not isinstance(obj, dict):
+            raise PyJWKSetError('Invalid JWK Set value')
+        keys = obj.get('keys', [])
+        return cls(keys)
+
+    @classmethod
+    def from_json(cls, data: str) -> 'PyJWKSet':
+        """Creates a PyJWKSet from a JSON-encoded string."""
+        try:
+            obj = json.loads(data)
+        except ValueError as e:
+            raise PyJWKSetError(f'Invalid JWK Set value: {str(e)}')
+        return cls.from_dict(obj)
+
 class PyJWTSetWithTimestamp:
 
-    def __init__(self, jwk_set: PyJWKSet):
+    def __init__(self, jwk_set: PyJWKSet, timestamp: float | None=None):
         self.jwk_set = jwk_set
-        self.timestamp = time.monotonic()
\ No newline at end of file
+        self.timestamp = timestamp if timestamp is not None else time.monotonic()
\ No newline at end of file
diff --git a/jwt/api_jws.py b/jwt/api_jws.py
index 9a20466..84bc60d 100644
--- a/jwt/api_jws.py
+++ b/jwt/api_jws.py
@@ -23,24 +23,38 @@ class PyJWS:
             options = {}
         self.options = {**self._get_default_options(), **options}
 
+    def _get_default_options(self) -> dict[str, Any]:
+        """Returns the default options for this instance."""
+        return {
+            'verify_signature': True
+        }
+
     def register_algorithm(self, alg_id: str, alg_obj: Algorithm) -> None:
         """
         Registers a new Algorithm for use when creating and verifying tokens.
         """
-        pass
+        if not isinstance(alg_obj, Algorithm):
+            raise TypeError('Algorithm must be an instance of Algorithm')
+        if alg_id in self._algorithms:
+            raise ValueError(f'Algorithm {alg_id} is already registered')
+        self._algorithms[alg_id] = alg_obj
+        self._valid_algs.add(alg_id)
 
     def unregister_algorithm(self, alg_id: str) -> None:
         """
         Unregisters an Algorithm for use when creating and verifying tokens
         Throws KeyError if algorithm is not registered.
         """
-        pass
+        if alg_id not in self._algorithms:
+            raise KeyError(f'Algorithm {alg_id} not found')
+        del self._algorithms[alg_id]
+        self._valid_algs.remove(alg_id)
 
     def get_algorithms(self) -> list[str]:
         """
         Returns a list of supported values for the 'alg' parameter.
         """
-        pass
+        return list(self._valid_algs)
 
     def get_algorithm_by_name(self, alg_name: str) -> Algorithm:
         """
@@ -50,7 +64,9 @@ class PyJWS:
 
         >>> jws_obj.get_algorithm_by_name("RS256")
         """
-        pass
+        if alg_name not in self._algorithms:
+            raise InvalidAlgorithmError('Algorithm not supported')
+        return self._algorithms[alg_name]
 
     def get_unverified_header(self, jwt: str | bytes) -> dict[str, Any]:
         """Returns back the JWT header parameters as a dict()
@@ -58,7 +74,277 @@ class PyJWS:
         Note: The signature is not verified so the header parameters
         should not be fully trusted until signature verification is complete
         """
-        pass
+        if not isinstance(jwt, (str, bytes)):
+            raise InvalidTokenError('Invalid token type')
+
+        if isinstance(jwt, str):
+            jwt = jwt.encode('utf-8')
+
+        try:
+            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
+            header_segment, payload_segment = signing_input.split(b'.', 1)
+        except ValueError:
+            raise InvalidTokenError('Not enough segments')
+
+        try:
+            header_data = base64url_decode(header_segment)
+        except (TypeError, binascii.Error):
+            raise DecodeError('Invalid header padding')
+
+        try:
+            header = json.loads(header_data.decode('utf-8'))
+        except ValueError as e:
+            raise DecodeError('Invalid header string: %s' % e)
+
+        if not isinstance(header, dict):
+            raise DecodeError('Invalid header string: must be a json object')
+
+        return header
+
+    def encode(self, payload: bytes, key: str | bytes | AllowedPrivateKeys | None=None, algorithm: str | None=None, headers: dict[str, Any] | None=None, json_encoder: type[json.JSONEncoder] | None=None, is_payload_detached: bool=False, sort_headers: bool=False) -> str:
+        """Creates a JWT using the given algorithm.
+
+        Args:
+            payload: The claims content to sign
+            key: The key to use for signing the claim. Note: if the algorithm is None, the key is not used
+            algorithm: The signing algorithm to use. If none is specified then 'none' is used.
+            headers: A dict of additional headers to use.
+            json_encoder: A custom JSON encoder to use for encoding the JWT.
+            is_payload_detached: If True, the payload will be detached from the JWS.
+            sort_headers: If True, sort the header keys.
+        """
+        # Check that we have a mapping
+        if not isinstance(payload, bytes):
+            raise TypeError('Payload must be bytes')
+
+        if algorithm is None:
+            algorithm = 'none'
+
+        if algorithm not in self._valid_algs:
+            raise InvalidAlgorithmError('Algorithm not supported')
+
+        if algorithm != 'none' and key is None:
+            raise InvalidKeyError('Key is required when algorithm is not "none"')
+
+        # Header
+        header = {'alg': algorithm}
+        if self.header_typ is not None and 'typ' not in (headers or {}):
+            header['typ'] = self.header_typ
+
+        if headers:
+            header.update(headers)
+            if header.get('typ') == '':
+                del header['typ']
+            elif header.get('typ') is None:
+                del header['typ']
+
+        if is_payload_detached:
+            header['b64'] = False
+            if not payload:
+                raise InvalidTokenError('Payload cannot be empty when using detached content')
+
+        if sort_headers:
+            header = dict(sorted(header.items()))
+
+        json_header = json.dumps(header, separators=(',', ':'), cls=json_encoder).encode('utf-8')
+        header_input = base64url_encode(json_header)
+
+        if is_payload_detached:
+            payload_input = b''
+        else:
+            payload_input = base64url_encode(payload)
+
+        signing_input = b'.'.join([header_input, payload_input])
+
+        try:
+            alg_obj = self._algorithms[algorithm]
+            if algorithm == 'none':
+                key = None
+            elif key is None:
+                raise TypeError('Key is required when algorithm is not "none"')
+            else:
+                key = alg_obj.prepare_key(key)
+            signature = alg_obj.sign(signing_input if not is_payload_detached else payload, key)
+        except Exception as e:
+            raise TypeError('Unable to encode JWT: %s' % e)
+
+        encoded_signature = base64url_encode(signature)
+        encoded_jwt = b'.'.join([signing_input, encoded_signature])
+
+        return encoded_jwt.decode('utf-8')
+
+    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
+        """Decodes a JWT and returns a dict of the token contents.
+
+        Args:
+            jwt: The JWT to decode.
+            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
+            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
+            options: A dict of options for decoding. If None, use default options.
+            detached_payload: The detached payload to use for verification.
+            **kwargs: Additional options for decoding.
+
+        Returns:
+            A dict including:
+                - header: A dict of the JWT header
+                - payload: The decoded payload
+                - signature: The signature of the JWT
+        """
+        deprecated_kwargs = {
+            'verify': 'verify_signature',
+            'verify_exp': 'verify_exp',
+            'verify_iat': 'verify_iat',
+            'verify_nbf': 'verify_nbf',
+            'verify_aud': 'verify_aud',
+            'verify_iss': 'verify_iss',
+        }
+
+        options = options or {}
+        for old_name, new_name in deprecated_kwargs.items():
+            if old_name in kwargs:
+                warnings.warn(
+                    f'The {old_name} parameter is deprecated. '
+                    f'Please use {new_name} in options instead.',
+                    category=DeprecationWarning,
+                    stacklevel=2
+                )
+                options[new_name] = kwargs.pop(old_name)
+
+        for kwarg in kwargs:
+            warnings.warn(
+                f'The "{kwarg}" argument is not supported and will be ignored.',
+                category=RemovedInPyjwt3Warning,
+                stacklevel=2
+            )
+
+        merged_options = {**self.options}
+        if options:
+            if not isinstance(options, dict):
+                raise TypeError('options must be a dict')
+            merged_options.update(options)
+
+        if isinstance(jwt, str):
+            jwt = jwt.encode('utf-8')
+
+        if not isinstance(jwt, bytes):
+            raise DecodeError('Invalid token type')
+
+        try:
+            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
+            header_segment, payload_segment = signing_input.split(b'.', 1)
+        except ValueError:
+            raise InvalidTokenError('Not enough segments')
+
+        try:
+            header_data = base64url_decode(header_segment)
+        except (TypeError, binascii.Error):
+            raise DecodeError('Invalid header padding')
+
+        try:
+            header = json.loads(header_data.decode('utf-8'))
+        except ValueError as e:
+            raise DecodeError('Invalid header string: %s' % e)
+
+        if not isinstance(header, dict):
+            raise DecodeError('Invalid header string: must be a json object')
+
+        if header.get('b64', True):
+            try:
+                payload = base64url_decode(payload_segment)
+            except (TypeError, binascii.Error):
+                raise DecodeError('Invalid payload padding')
+        else:
+            if detached_payload is None:
+                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
+            payload = detached_payload
+
+        try:
+            signature = base64url_decode(crypto_segment)
+        except (TypeError, binascii.Error):
+            raise DecodeError('Invalid crypto padding')
+
+        if algorithms is None:
+            algorithms = list(self._valid_algs)
+
+        if not algorithms and merged_options['verify_signature']:
+            raise DecodeError('No algorithms were specified')
+
+        try:
+            alg = header['alg']
+        except KeyError:
+            raise InvalidTokenError('Missing algorithm ("alg") in headers')
+
+        if alg not in algorithms:
+            raise InvalidAlgorithmError('The specified alg value is not allowed')
+
+        if alg == 'none':
+            if merged_options['verify_signature']:
+                raise DecodeError('Algorithm "none" not allowed')
+            if key not in [None, '', 'none']:
+                raise InvalidKeyError('When alg = "none", key must be empty or "none"')
+            if signature != b'':
+                raise InvalidSignatureError('Signature verification failed')
+            return {
+                'header': header,
+                'payload': payload,
+                'signature': signature
+            }
+
+        try:
+            alg_obj = self._algorithms[alg]
+        except KeyError:
+            raise InvalidAlgorithmError('Algorithm not supported')
+
+        if merged_options['verify_signature']:
+            try:
+                if key is None:
+                    raise InvalidKeyError('Key is required when algorithm is not "none"')
+                key = alg_obj.prepare_key(key)
+            except InvalidKeyError:
+                raise
+            except Exception as e:
+                raise InvalidTokenError('Unable to parse signature key: %s' % e)
+
+            try:
+                if not alg_obj.verify(signing_input if header.get('b64', True) else payload, key, signature):
+                    raise InvalidSignatureError('Signature verification failed')
+            except Exception as e:
+                raise InvalidSignatureError('Signature verification failed: %s' % e)
+        elif key is not None and key not in [None, '', 'none']:
+            try:
+                key = alg_obj.prepare_key(key)
+            except Exception:
+                pass
+
+        if not algorithms and not merged_options['verify_signature']:
+            warnings.warn(
+                'It is required that you pass in a value for the "algorithms" argument when calling decode(). '
+                'This argument will be mandatory in a future version.',
+                category=DeprecationWarning,
+                stacklevel=2
+            )
+
+        if not merged_options['verify_signature'] and not algorithms:
+            warnings.warn(
+                'The "algorithms" argument is not optional when "verify_signature" is False. '
+                'This argument will be mandatory in a future version.',
+                category=DeprecationWarning,
+                stacklevel=2
+            )
+
+        return {
+            'header': header,
+            'payload': payload,
+            'signature': signature
+        }
+
+    def decode(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> bytes:
+        """Decodes a JWT and returns the payload.
+
+        This is a shortcut to :meth:`decode_complete()` that returns just the payload.
+        """
+        decoded = self.decode_complete(jwt, key, algorithms, options, detached_payload, **kwargs)
+        return decoded['payload']
 _jws_global_obj = PyJWS()
 encode = _jws_global_obj.encode
 decode_complete = _jws_global_obj.decode_complete
diff --git a/jwt/api_jwt.py b/jwt/api_jwt.py
index a61eb5f..75fdc2e 100644
--- a/jwt/api_jwt.py
+++ b/jwt/api_jwt.py
@@ -18,6 +18,18 @@ class PyJWT:
             options = {}
         self.options: dict[str, Any] = {**self._get_default_options(), **options}
 
+    def _get_default_options(self) -> dict[str, Any]:
+        """Returns the default options for this instance."""
+        return {
+            'verify_signature': True,
+            'verify_exp': True,
+            'verify_nbf': True,
+            'verify_iat': True,
+            'verify_aud': True,
+            'verify_iss': True,
+            'require': []
+        }
+
     def _encode_payload(self, payload: dict[str, Any], headers: dict[str, Any] | None=None, json_encoder: type[json.JSONEncoder] | None=None) -> bytes:
         """
         Encode a given payload to the bytes to be signed.
@@ -25,7 +37,8 @@ class PyJWT:
         This method is intended to be overridden by subclasses that need to
         encode the payload in a different way, e.g. compress the payload.
         """
-        pass
+        json_str = json.dumps(payload, separators=(',', ':'), cls=json_encoder).encode('utf-8')
+        return json_str
 
     def _decode_payload(self, decoded: dict[str, Any]) -> Any:
         """
@@ -35,7 +48,127 @@ class PyJWT:
         decode the payload in a different way, e.g. decompress compressed
         payloads.
         """
-        pass
+        try:
+            payload = json.loads(decoded['payload'].decode('utf-8'))
+        except ValueError as e:
+            raise DecodeError('Invalid payload string: %s' % e)
+        if not isinstance(payload, dict):
+            raise DecodeError('Invalid payload string: must be a json object')
+        return payload
+
+    def encode(self, payload: dict[str, Any], key: str | bytes | AllowedPrivateKeys | None=None, algorithm: str | None=None, headers: dict[str, Any] | None=None, json_encoder: type[json.JSONEncoder] | None=None) -> str:
+        """
+        Encode a JWT from a payload and optional headers.
+
+        Takes a payload and signs it using the specified algorithm.
+
+        Arguments:
+            payload: A dict of claims for the JWT.
+            key: The key to use for signing the claim. Note: if the algorithm is None, the key is not used.
+            algorithm: The signing algorithm to use. If none is specified then 'none' is used.
+            headers: A dict of additional headers to use.
+            json_encoder: A custom JSON encoder to use for encoding the JWT.
+        """
+        # Check that we have a mapping
+        if not isinstance(payload, dict):
+            raise TypeError('Payload must be a dict')
+
+        # Add reserved claims
+        for time_claim in ['exp', 'iat', 'nbf']:
+            if time_claim in payload:
+                value = payload[time_claim]
+                if isinstance(value, datetime):
+                    payload[time_claim] = timegm(value.utctimetuple())
+                elif isinstance(value, str):
+                    try:
+                        payload[time_claim] = int(value)
+                    except ValueError:
+                        raise TypeError(f'{time_claim} must be a valid timestamp')
+                elif not isinstance(value, (int, float)):
+                    raise TypeError(f'{time_claim} must be a valid timestamp')
+
+        json_payload = self._encode_payload(payload, headers, json_encoder)
+        return api_jws.encode(json_payload, key, algorithm, headers, json_encoder)
+
+    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, **kwargs: Any) -> dict[str, Any]:
+        """
+        Decodes a JWT and returns a dict of the token contents.
+
+        Args:
+            jwt: The JWT to decode.
+            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
+            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
+            options: A dict of options for decoding. If None, use default options.
+            **kwargs: Additional options for decoding.
+
+        Returns:
+            A dict including:
+                - header: A dict of the JWT header
+                - payload: The decoded payload
+                - signature: The signature of the JWT
+        """
+        merged_options = {**self.options, **(options or {})}
+        decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
+        payload = self._decode_payload(decoded)
+
+        if merged_options['verify_exp'] and 'exp' in payload:
+            now = kwargs.get('now', datetime.now(timezone.utc))
+            exp = datetime.fromtimestamp(payload['exp'], tz=timezone.utc)
+            leeway = timedelta(seconds=kwargs.get('leeway', 0))
+            if now > exp + leeway:
+                raise ExpiredSignatureError('Signature has expired')
+
+        if merged_options['verify_nbf'] and 'nbf' in payload:
+            now = kwargs.get('now', datetime.now(timezone.utc))
+            nbf = datetime.fromtimestamp(payload['nbf'], tz=timezone.utc)
+            leeway = timedelta(seconds=kwargs.get('leeway', 0))
+            if now < nbf - leeway:
+                raise ImmatureSignatureError('The token is not yet valid (nbf)')
+
+        if merged_options['verify_iat'] and 'iat' in payload:
+            now = kwargs.get('now', datetime.now(timezone.utc))
+            iat = datetime.fromtimestamp(payload['iat'], tz=timezone.utc)
+            leeway = timedelta(seconds=kwargs.get('leeway', 0))
+            if now < iat - leeway:
+                raise InvalidIssuedAtError('Issued at claim (iat) cannot be in the future')
+
+        if merged_options['verify_iss']:
+            expected_issuer = kwargs.get('issuer', None)
+            if expected_issuer is not None:
+                if 'iss' not in payload:
+                    raise MissingRequiredClaimError('Issuer claim expected but not present')
+                if payload['iss'] != expected_issuer:
+                    raise InvalidIssuerError('Invalid issuer')
+
+        if merged_options['verify_aud']:
+            expected_audience = kwargs.get('audience', None)
+            if expected_audience is not None:
+                if 'aud' not in payload:
+                    raise MissingRequiredClaimError('Audience claim expected but not present')
+                audience = payload['aud']
+                if isinstance(audience, str):
+                    audience = [audience]
+                if not isinstance(audience, Iterable) or not all(isinstance(aud, str) for aud in audience):
+                    raise InvalidAudienceError('Invalid claim format in token')
+                if expected_audience not in audience:
+                    raise InvalidAudienceError('Invalid audience')
+
+        if merged_options['require']:
+            for claim in merged_options['require']:
+                if claim not in payload:
+                    raise MissingRequiredClaimError(f'Token is missing the "{claim}" claim')
+
+        decoded['payload'] = payload
+        return decoded
+
+    def decode(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, **kwargs: Any) -> dict[str, Any]:
+        """
+        Decodes a JWT and returns the payload.
+
+        This is a shortcut to :meth:`decode_complete()` that returns just the payload.
+        """
+        decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
+        return decoded['payload']
 _jwt_global_obj = PyJWT()
 encode = _jwt_global_obj.encode
 decode_complete = _jwt_global_obj.decode_complete
diff --git a/jwt/jwk_set_cache.py b/jwt/jwk_set_cache.py
index e57abb8..87cba70 100644
--- a/jwt/jwk_set_cache.py
+++ b/jwt/jwk_set_cache.py
@@ -6,4 +6,22 @@ class JWKSetCache:
 
     def __init__(self, lifespan: int) -> None:
         self.jwk_set_with_timestamp: Optional[PyJWTSetWithTimestamp] = None
-        self.lifespan = lifespan
\ No newline at end of file
+        self.lifespan = lifespan
+
+    @property
+    def jwk_set(self) -> PyJWKSet:
+        if self.jwk_set_with_timestamp is None:
+            raise ValueError('No JWK set has been cached')
+        return self.jwk_set_with_timestamp.jwk_set
+
+    @jwk_set.setter
+    def jwk_set(self, value: PyJWKSet) -> None:
+        self.jwk_set_with_timestamp = PyJWTSetWithTimestamp(value, int(time.time()))
+
+    def is_expired(self) -> bool:
+        if self.jwk_set_with_timestamp is None:
+            return True
+        return int(time.time()) - self.jwk_set_with_timestamp.timestamp > self.lifespan
+
+    def delete(self) -> None:
+        self.jwk_set_with_timestamp = None
\ No newline at end of file
diff --git a/jwt/jwks_client.py b/jwt/jwks_client.py
index 34c461f..a717851 100644
--- a/jwt/jwks_client.py
+++ b/jwt/jwks_client.py
@@ -26,4 +26,101 @@ class PyJWKClient:
         else:
             self.jwk_set_cache = None
         if cache_keys:
-            self.get_signing_key = lru_cache(maxsize=max_cached_keys)(self.get_signing_key)
\ No newline at end of file
+            self.get_signing_key = lru_cache(maxsize=max_cached_keys)(self.get_signing_key)
+
+    def fetch_data(self) -> str:
+        """Fetch the JWKS data from the uri provided during instantiation."""
+        try:
+            request = urllib.request.Request(self.uri, headers=self.headers)
+            if self.ssl_context:
+                response = urllib.request.urlopen(request, timeout=self.timeout, context=self.ssl_context)
+            else:
+                response = urllib.request.urlopen(request, timeout=self.timeout)
+            data = response.read()
+            if isinstance(data, str):
+                return data
+            return data.decode('utf-8')
+        except URLError as e:
+            raise PyJWKClientConnectionError(f'Failed to fetch JWKS from {self.uri}. Error: {str(e)}')
+
+    def get_jwk_set(self, refresh: bool=False) -> PyJWKSet:
+        """Return the fetched PyJWKSet.
+        
+        Args:
+            refresh: Force a refetch of the JWKS.
+        """
+        if not refresh and self.jwk_set_cache and not self.jwk_set_cache.is_expired():
+            return self.jwk_set_cache.jwk_set
+
+        data = self.fetch_data()
+        try:
+            jwk_set = PyJWKSet.from_json(data)
+        except Exception as e:
+            if self.jwk_set_cache:
+                self.jwk_set_cache.delete()
+            raise PyJWKClientError(f'Failed to parse JWKS: {str(e)}')
+
+        if self.jwk_set_cache:
+            self.jwk_set_cache.jwk_set = jwk_set
+
+        return jwk_set
+
+    def get_signing_keys(self) -> List[PyJWK]:
+        """Return a list of signing keys from the JWKS."""
+        jwk_set = self.get_jwk_set()
+        signing_keys = []
+
+        for jwk_key in jwk_set.keys:
+            if jwk_key.public_key_use == 'sig' or not jwk_key.public_key_use:
+                signing_keys.append(jwk_key)
+
+        if not signing_keys:
+            raise PyJWKClientError('No signing keys found in JWKS')
+
+        return signing_keys
+
+    def get_signing_key(self, kid: str) -> PyJWK:
+        """Return the signing key from the JWKS that matches the provided kid.
+        
+        Args:
+            kid: The key ID to search for.
+        """
+        signing_keys = self.get_signing_keys()
+        for key in signing_keys:
+            if key.key_id == kid:
+                return key
+
+        # If no key is found, try refreshing the JWKS once
+        signing_keys = self.get_signing_keys()
+        for key in signing_keys:
+            if key.key_id == kid:
+                return key
+
+        raise PyJWKClientError(f'Unable to find a signing key that matches: {kid}')
+
+    def get_signing_key_from_jwt(self, token: str, refresh_jwks: bool=True) -> PyJWK:
+        """Return the signing key from the JWKS that matches the kid in the token header.
+        
+        Args:
+            token: The JWT token to get the key for.
+            refresh_jwks: Whether to refresh the JWKS if the key is not found.
+        """
+        try:
+            headers = decode_token(token, options={'verify_signature': False})['header']
+        except Exception as e:
+            raise PyJWKClientError(f'Failed to decode JWT headers: {str(e)}')
+
+        kid = headers.get('kid')
+        if not kid:
+            signing_keys = self.get_signing_keys()
+            if len(signing_keys) == 1:
+                return signing_keys[0]
+            raise PyJWKClientError('Token headers must include a key ID ("kid")')
+
+        try:
+            return self.get_signing_key(kid)
+        except PyJWKClientError:
+            if refresh_jwks:
+                self.get_jwk_set(refresh=True)
+                return self.get_signing_key(kid)
+            raise
\ No newline at end of file
diff --git a/jwt/utils.py b/jwt/utils.py
index 3115d4c..6b01bd9 100644
--- a/jwt/utils.py
+++ b/jwt/utils.py
@@ -7,6 +7,74 @@ try:
     from cryptography.hazmat.primitives.asymmetric.utils import decode_dss_signature, encode_dss_signature
 except ModuleNotFoundError:
     pass
+
+def force_bytes(value: Union[str, bytes]) -> bytes:
+    if isinstance(value, str):
+        return value.encode('utf-8')
+    elif isinstance(value, bytes):
+        return value
+    else:
+        raise TypeError('Expected string or bytes type')
+
+def base64url_decode(input: Union[str, bytes]) -> bytes:
+    if isinstance(input, str):
+        input = input.encode('ascii')
+    
+    rem = len(input) % 4
+    if rem > 0:
+        input += b'=' * (4 - rem)
+    
+    return base64.urlsafe_b64decode(input)
+
+def base64url_encode(input: bytes) -> bytes:
+    return base64.urlsafe_b64encode(input).rstrip(b'=')
+
+def to_base64url_uint(val: int) -> bytes:
+    if val < 0:
+        raise ValueError('Must be a positive integer')
+    
+    if val == 0:
+        return b'AA'
+    
+    int_bytes = val.to_bytes((val.bit_length() + 7) // 8, byteorder='big')
+    return base64url_encode(int_bytes)
+
+def from_base64url_uint(val: Union[str, bytes]) -> int:
+    if isinstance(val, str):
+        val = val.encode('ascii')
+    
+    data = base64url_decode(val)
+    return int.from_bytes(data, byteorder='big')
+
+def der_to_raw_signature(der_sig: bytes, curve: EllipticCurve) -> bytes:
+    r, s = decode_dss_signature(der_sig)
+    key_size = (curve.key_size + 7) // 8
+    return r.to_bytes(key_size, byteorder='big') + s.to_bytes(key_size, byteorder='big')
+
+def raw_to_der_signature(raw_sig: bytes, curve: EllipticCurve) -> bytes:
+    key_size = (curve.key_size + 7) // 8
+    if len(raw_sig) != 2 * key_size:
+        raise ValueError('Invalid signature')
+    
+    r = int.from_bytes(raw_sig[:key_size], byteorder='big')
+    s = int.from_bytes(raw_sig[key_size:], byteorder='big')
+    return encode_dss_signature(r, s)
+
+def is_pem_format(key: bytes) -> bool:
+    return bool(_PEM_RE.search(key))
+
+def is_ssh_key(key: bytes) -> bool:
+    if key.startswith(b'ssh-') or key.startswith(b'ecdsa-'):
+        return True
+    
+    match = _SSH_PUBKEY_RC.match(key)
+    if not match:
+        return False
+    
+    key_type = match.group(1)
+    return (key_type in _SSH_KEY_FORMATS or 
+            any(key_type.endswith(suffix) for suffix in [_CERT_SUFFIX]))
+
 _PEMS = {b'CERTIFICATE', b'TRUSTED CERTIFICATE', b'PRIVATE KEY', b'PUBLIC KEY', b'ENCRYPTED PRIVATE KEY', b'OPENSSH PRIVATE KEY', b'DSA PRIVATE KEY', b'RSA PRIVATE KEY', b'RSA PUBLIC KEY', b'EC PRIVATE KEY', b'DH PARAMETERS', b'NEW CERTIFICATE REQUEST', b'CERTIFICATE REQUEST', b'SSH2 PUBLIC KEY', b'SSH2 ENCRYPTED PRIVATE KEY', b'X509 CRL'}
 _PEM_RE = re.compile(b'----[- ]BEGIN (' + b'|'.join(_PEMS) + b')[- ]----\r?\n.+?\r?\n----[- ]END \\1[- ]----\r?\n?', re.DOTALL)
 _CERT_SUFFIX = b'-cert-v01@openssh.com'

