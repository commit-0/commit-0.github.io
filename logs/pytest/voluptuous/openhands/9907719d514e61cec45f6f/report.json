{"created": 1732308254.3252683, "duration": 0.24399495124816895, "exitcode": 1, "root": "/testbed", "environment": {}, "summary": {"error": 1, "total": 1, "collected": 1}, "collectors": [{"nodeid": "", "outcome": "passed", "result": [{"nodeid": "voluptuous/tests", "type": "Package"}]}, {"nodeid": "voluptuous/tests/tests.md", "outcome": "passed", "result": [{"nodeid": "voluptuous/tests/tests.md::tests.md", "type": "DoctestItem", "lineno": 0}]}, {"nodeid": "voluptuous/tests/tests.py", "outcome": "failed", "result": [], "longrepr": "ImportError while importing test module '/testbed/voluptuous/tests/tests.py'.\nHint: make sure your test modules/packages have valid Python names.\nTraceback:\n/usr/lib/python3.10/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\nvoluptuous/__init__.py:80: in <module>\n    from voluptuous.util import *\nvoluptuous/util.py:2: in <module>\n    from voluptuous import validators\nvoluptuous/validators.py:10: in <module>\n    from voluptuous.schema_builder import Schema, Schemable, message, raises\nE   ImportError: cannot import name 'raises' from 'voluptuous.schema_builder' (/testbed/voluptuous/schema_builder.py)"}, {"nodeid": "voluptuous/tests", "outcome": "passed", "result": [{"nodeid": "voluptuous/tests/tests.md", "type": "DoctestTextfile"}, {"nodeid": "voluptuous/tests/tests.py", "type": "Module"}]}], "tests": [{"nodeid": "voluptuous/tests/tests.md::tests.md", "lineno": 0, "outcome": "error", "keywords": ["tests.md", "tests", "voluptuous", "testbed", ""], "setup": {"duration": 0.014263474999999914, "outcome": "failed", "crash": {"path": "/testbed/.venv/lib/python3.10/site-packages/_pytest/python.py", "lineno": 523, "message": "_pytest.nodes.Collector.CollectError: ImportError while importing test module '/testbed/voluptuous/__init__.py'.\nHint: make sure your test modules/packages have valid Python names.\nTraceback:\n/usr/lib/python3.10/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\nvoluptuous/__init__.py:80: in <module>\n    from voluptuous.util import *\nvoluptuous/util.py:2: in <module>\n    from voluptuous import validators\nvoluptuous/validators.py:10: in <module>\n    from voluptuous.schema_builder import Schema, Schemable, message, raises\nE   ImportError: cannot import name 'raises' from 'voluptuous.schema_builder' (/testbed/voluptuous/schema_builder.py)"}, "traceback": [{"path": ".venv/lib/python3.10/site-packages/_pytest/runner.py", "lineno": 341, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/_pytest/runner.py", "lineno": 242, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/pluggy/_hooks.py", "lineno": 513, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/pluggy/_manager.py", "lineno": 120, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/pluggy/_callers.py", "lineno": 182, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/pluggy/_result.py", "lineno": 100, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/pluggy/_callers.py", "lineno": 167, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/_pytest/unraisableexception.py", "lineno": 90, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/_pytest/unraisableexception.py", "lineno": 70, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/pluggy/_callers.py", "lineno": 167, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/_pytest/logging.py", "lineno": 840, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/_pytest/logging.py", "lineno": 829, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/pluggy/_callers.py", "lineno": 167, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/_pytest/capture.py", "lineno": 875, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/pluggy/_callers.py", "lineno": 167, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/_pytest/threadexception.py", "lineno": 87, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/_pytest/threadexception.py", "lineno": 68, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/pluggy/_callers.py", "lineno": 103, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/_pytest/runner.py", "lineno": 160, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/_pytest/runner.py", "lineno": 514, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/_pytest/python.py", "lineno": 663, "message": ""}, {"path": ".venv/lib/python3.10/site-packages/_pytest/python.py", "lineno": 523, "message": "CollectError"}], "longrepr": "path = PosixPath('/testbed/voluptuous/__init__.py')\nconfig = <_pytest.config.Config object at 0x7edf8c964820>\n\n    def importtestmodule(\n        path: Path,\n        config: Config,\n    ):\n        # We assume we are only called once per module.\n        importmode = config.getoption(\"--import-mode\")\n        try:\n>           mod = import_path(\n                path,\n                mode=importmode,\n                root=config.rootpath,\n                consider_namespace_packages=config.getini(\"consider_namespace_packages\"),\n            )\n\n.venv/lib/python3.10/site-packages/_pytest/python.py:493: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath = PosixPath('/testbed/voluptuous/__init__.py')\n\n    def import_path(\n        path: str | os.PathLike[str],\n        *,\n        mode: str | ImportMode = ImportMode.prepend,\n        root: Path,\n        consider_namespace_packages: bool,\n    ) -> ModuleType:\n        \"\"\"\n        Import and return a module from the given path, which can be a file (a module) or\n        a directory (a package).\n    \n        :param path:\n            Path to the file to import.\n    \n        :param mode:\n            Controls the underlying import mechanism that will be used:\n    \n            * ImportMode.prepend: the directory containing the module (or package, taking\n              `__init__.py` files into account) will be put at the *start* of `sys.path` before\n              being imported with `importlib.import_module`.\n    \n            * ImportMode.append: same as `prepend`, but the directory will be appended\n              to the end of `sys.path`, if not already in `sys.path`.\n    \n            * ImportMode.importlib: uses more fine control mechanisms provided by `importlib`\n              to import the module, which avoids having to muck with `sys.path` at all. It effectively\n              allows having same-named test modules in different places.\n    \n        :param root:\n            Used as an anchor when mode == ImportMode.importlib to obtain\n            a unique name for the module being imported so it can safely be stored\n            into ``sys.modules``.\n    \n        :param consider_namespace_packages:\n            If True, consider namespace packages when resolving module names.\n    \n        :raises ImportPathMismatchError:\n            If after importing the given `path` and the module `__file__`\n            are different. Only raised in `prepend` and `append` modes.\n        \"\"\"\n        path = Path(path)\n        mode = ImportMode(mode)\n    \n        if not path.exists():\n            raise ImportError(path)\n    \n        if mode is ImportMode.importlib:\n            # Try to import this module using the standard import mechanisms, but\n            # without touching sys.path.\n            try:\n                pkg_root, module_name = resolve_pkg_root_and_module_name(\n                    path, consider_namespace_packages=consider_namespace_packages\n                )\n            except CouldNotResolvePathError:\n                pass\n            else:\n                # If the given module name is already in sys.modules, do not import it again.\n                with contextlib.suppress(KeyError):\n                    return sys.modules[module_name]\n    \n                mod = _import_module_using_spec(\n                    module_name, path, pkg_root, insert_modules=False\n                )\n                if mod is not None:\n                    return mod\n    \n            # Could not import the module with the current sys.path, so we fall back\n            # to importing the file as a single module, not being a part of a package.\n            module_name = module_name_from_path(path, root)\n            with contextlib.suppress(KeyError):\n                return sys.modules[module_name]\n    \n            mod = _import_module_using_spec(\n                module_name, path, path.parent, insert_modules=True\n            )\n            if mod is None:\n                raise ImportError(f\"Can't find module {module_name} at location {path}\")\n            return mod\n    \n        try:\n            pkg_root, module_name = resolve_pkg_root_and_module_name(\n                path, consider_namespace_packages=consider_namespace_packages\n            )\n        except CouldNotResolvePathError:\n            pkg_root, module_name = path.parent, path.stem\n    \n        # Change sys.path permanently: restoring it at the end of this function would cause surprising\n        # problems because of delayed imports: for example, a conftest.py file imported by this function\n        # might have local imports, which would fail at runtime if we restored sys.path.\n        if mode is ImportMode.append:\n            if str(pkg_root) not in sys.path:\n                sys.path.append(str(pkg_root))\n        elif mode is ImportMode.prepend:\n            if str(pkg_root) != sys.path[0]:\n                sys.path.insert(0, str(pkg_root))\n        else:\n            assert_never(mode)\n    \n>       importlib.import_module(module_name)\n\n.venv/lib/python3.10/site-packages/_pytest/pathlib.py:582: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = 'voluptuous', package = None\n\n    def import_module(name, package=None):\n        \"\"\"Import a module.\n    \n        The 'package' argument is required when performing a relative import. It\n        specifies the package to use as the anchor point from which to resolve the\n        relative import to an absolute import.\n    \n        \"\"\"\n        level = 0\n        if name.startswith('.'):\n            if not package:\n                msg = (\"the 'package' argument is required to perform a relative \"\n                       \"import for {!r}\")\n                raise TypeError(msg.format(name))\n            for character in name:\n                if character != '.':\n                    break\n                level += 1\n>       return _bootstrap._gcd_import(name[level:], package, level)\n\n/usr/lib/python3.10/importlib/__init__.py:126: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = 'voluptuous', package = None, level = 0\n\n>   ???\n\n<frozen importlib._bootstrap>:1050: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = 'voluptuous', import_ = <function _gcd_import at 0x7edf8d163400>\n\n>   ???\n\n<frozen importlib._bootstrap>:1027: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = 'voluptuous', import_ = <function _gcd_import at 0x7edf8d163400>\n\n>   ???\n\n<frozen importlib._bootstrap>:1006: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nspec = ModuleSpec(name='voluptuous', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7edf8c833c40>, origin='/testbed/voluptuous/__init__.py', submodule_search_locations=['/testbed/voluptuous'])\n\n>   ???\n\n<frozen importlib._bootstrap>:688: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_frozen_importlib_external.SourceFileLoader object at 0x7edf8c833c40>\nmodule = <module 'voluptuous' from '/testbed/voluptuous/__init__.py'>\n\n>   ???\n\n<frozen importlib._bootstrap_external>:883: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nf = <built-in function exec>\nargs = (<code object <module> at 0x7edf8bd11630, file \"/testbed/voluptuous/__init__.py\", line 1>, {'ALLOW_EXTRA': 1, 'Default...ing.Any]], 'Error': <class 'voluptuous.error.Error'>, 'Exclusive': <class 'voluptuous.schema_builder.Exclusive'>, ...})\nkwds = {}\n\n>   ???\n\n<frozen importlib._bootstrap>:241: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \"\"\"Schema validation for Python data structures.\n    \n    Given eg. a nested data structure like this:\n    \n        {\n            'exclude': ['Users', 'Uptime'],\n            'include': [],\n            'set': {\n                'snmp_community': 'public',\n                'snmp_timeout': 15,\n                'snmp_version': '2c',\n            },\n            'targets': {\n                'localhost': {\n                    'exclude': ['Uptime'],\n                    'features': {\n                        'Uptime': {\n                            'retries': 3,\n                        },\n                        'Users': {\n                            'snmp_community': 'monkey',\n                            'snmp_port': 15,\n                        },\n                    },\n                    'include': ['Users'],\n                    'set': {\n                        'snmp_community': 'monkeys',\n                    },\n                },\n            },\n        }\n    \n    A schema like this:\n    \n        >>> settings = {\n        ...   'snmp_community': str,\n        ...   'retries': int,\n        ...   'snmp_version': All(Coerce(str), Any('3', '2c', '1')),\n        ... }\n        >>> features = ['Ping', 'Uptime', 'Http']\n        >>> schema = Schema({\n        ...    'exclude': features,\n        ...    'include': features,\n        ...    'set': settings,\n        ...    'targets': {\n        ...      'exclude': features,\n        ...      'include': features,\n        ...      'features': {\n        ...        str: settings,\n        ...      },\n        ...    },\n        ... })\n    \n    Validate like so:\n    \n        >>> schema({\n        ...   'set': {\n        ...     'snmp_community': 'public',\n        ...     'snmp_version': '2c',\n        ...   },\n        ...   'targets': {\n        ...     'exclude': ['Ping'],\n        ...     'features': {\n        ...       'Uptime': {'retries': 3},\n        ...       'Users': {'snmp_community': 'monkey'},\n        ...     },\n        ...   },\n        ... }) == {\n        ...   'set': {'snmp_version': '2c', 'snmp_community': 'public'},\n        ...   'targets': {\n        ...     'exclude': ['Ping'],\n        ...     'features': {'Uptime': {'retries': 3},\n        ...                  'Users': {'snmp_community': 'monkey'}}}}\n        True\n    \"\"\"\n    \n    # flake8: noqa\n    # fmt: off\n    from voluptuous.schema_builder import *\n>   from voluptuous.util import *\n\nvoluptuous/__init__.py:80: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    import typing\n>   from voluptuous import validators\n\nvoluptuous/util.py:2: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    from __future__ import annotations\n    import datetime\n    import os\n    import re\n    import sys\n    import typing\n    from decimal import Decimal, InvalidOperation\n    from functools import wraps\n    from voluptuous.error import AllInvalid, AnyInvalid, BooleanInvalid, CoerceInvalid, ContainsInvalid, DateInvalid, DatetimeInvalid, DirInvalid, EmailInvalid, ExactSequenceInvalid, FalseInvalid, FileInvalid, InInvalid, Invalid, LengthInvalid, MatchInvalid, MultipleInvalid, NotEnoughValid, NotInInvalid, PathInvalid, RangeInvalid, TooManyValid, TrueInvalid, TypeInvalid, UrlInvalid\n>   from voluptuous.schema_builder import Schema, Schemable, message, raises\nE   ImportError: cannot import name 'raises' from 'voluptuous.schema_builder' (/testbed/voluptuous/schema_builder.py)\n\nvoluptuous/validators.py:10: ImportError\n\nThe above exception was the direct cause of the following exception:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_and_report.<locals>.<lambda> at 0x7edf8bcefe20>\nwhen = 'setup'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,\n    ) -> CallInfo[TResult]:\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :type func: Callable[[], _pytest.runner.TResult]\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        start = timing.time()\n        precise_start = timing.perf_counter()\n        try:\n>           result: TResult | None = func()\n\n.venv/lib/python3.10/site-packages/_pytest/runner.py:341: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>       lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n    )\n\n.venv/lib/python3.10/site-packages/_pytest/runner.py:242: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HookCaller 'pytest_runtest_setup'>\nkwargs = {'item': <DoctestItem tests.md>}, firstresult = False\n\n    def __call__(self, **kwargs: object) -> Any:\n        \"\"\"Call the hook.\n    \n        Only accepts keyword arguments, which should match the hook\n        specification.\n    \n        Returns the result(s) of calling all registered plugins, see\n        :ref:`calling`.\n        \"\"\"\n        assert (\n            not self.is_historic()\n        ), \"Cannot directly call a historic hook - use call_historic instead.\"\n        self._verify_all_args_are_provided(kwargs)\n        firstresult = self.spec.opts.get(\"firstresult\", False) if self.spec else False\n        # Copy because plugins may register other plugins during iteration (#438).\n>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n\n.venv/lib/python3.10/site-packages/pluggy/_hooks.py:513: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_pytest.config.PytestPluginManager object at 0x7edf8cefff40>\nhook_name = 'pytest_runtest_setup'\nmethods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/testbed/.venv/lib/python3.10/site-packages/_py...64ac0>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7edf8c5be8f0>>, ...]\nkwargs = {'item': <DoctestItem tests.md>}, firstresult = False\n\n    def _hookexec(\n        self,\n        hook_name: str,\n        methods: Sequence[HookImpl],\n        kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        # called from all hookcaller instances.\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\n>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n\n.venv/lib/python3.10/site-packages/pluggy/_manager.py:120: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_setup'\nhook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/testbed/.venv/lib/python3.10/site-packages/_py...64ac0>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7edf8c5be8f0>>, ...]\ncaller_kwargs = {'item': <DoctestItem tests.md>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        only_new_style_wrappers = True\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n    \n                    if hook_impl.hookwrapper:\n                        only_new_style_wrappers = False\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            wrapper_gen = cast(Generator[None, Result[object], None], res)\n                            next(wrapper_gen)  # first yield\n                            teardowns.append((wrapper_gen, hook_impl))\n                        except StopIteration:\n                            _raise_wrapfail(wrapper_gen, \"did not yield\")\n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            # Fast path - only new-style wrappers, no Result.\n            if only_new_style_wrappers:\n                if firstresult:  # first result hooks return a single value\n                    result = results[0] if results else None\n                else:\n                    result = results\n    \n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    try:\n                        if exception is not None:\n                            teardown.throw(exception)  # type: ignore[union-attr]\n                        else:\n                            teardown.send(result)  # type: ignore[union-attr]\n                        # Following is unreachable for a well behaved hook wrapper.\n                        # Try to force finalizers otherwise postponed till GC action.\n                        # Note: close() may raise if generator handles GeneratorExit.\n                        teardown.close()  # type: ignore[union-attr]\n                    except StopIteration as si:\n                        result = si.value\n                        exception = None\n                        continue\n                    except BaseException as e:\n                        exception = e\n                        continue\n                    _raise_wrapfail(teardown, \"has second yield\")  # type: ignore[arg-type]\n    \n                if exception is not None:\n                    raise exception.with_traceback(exception.__traceback__)\n                else:\n                    return result\n    \n            # Slow path - need to support old-style wrappers.\n            else:\n                if firstresult:  # first result hooks return a single value\n                    outcome: Result[object | list[object]] = Result(\n                        results[0] if results else None, exception\n                    )\n                else:\n                    outcome = Result(results, exception)\n    \n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    if isinstance(teardown, tuple):\n                        try:\n                            teardown[0].send(outcome)\n                        except StopIteration:\n                            pass\n                        except BaseException as e:\n                            _warn_teardown_exception(hook_name, teardown[1], e)\n                            raise\n                        else:\n                            _raise_wrapfail(teardown[0], \"has second yield\")\n                    else:\n                        try:\n                            if outcome._exception is not None:\n                                teardown.throw(outcome._exception)\n                            else:\n                                teardown.send(outcome._result)\n                            # Following is unreachable for a well behaved hook wrapper.\n                            # Try to force finalizers otherwise postponed till GC action.\n                            # Note: close() may raise if generator handles GeneratorExit.\n                            teardown.close()\n                        except StopIteration as si:\n                            outcome.force_result(si.value)\n                            continue\n                        except BaseException as e:\n                            outcome.force_exception(e)\n                            continue\n                        _raise_wrapfail(teardown, \"has second yield\")\n    \n>               return outcome.get_result()\n\n.venv/lib/python3.10/site-packages/pluggy/_callers.py:182: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pluggy._result.Result object at 0x7edf8c9cc430>\n\n    def get_result(self) -> ResultType:\n        \"\"\"Get the result(s) for this hook call.\n    \n        If the hook was marked as a ``firstresult`` only a single value\n        will be returned, otherwise a list of results.\n        \"\"\"\n        __tracebackhide__ = True\n        exc = self._exception\n        if exc is None:\n            return cast(ResultType, self._result)\n        else:\n>           raise exc.with_traceback(exc.__traceback__)\n\n.venv/lib/python3.10/site-packages/pluggy/_result.py:100: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_setup'\nhook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/testbed/.venv/lib/python3.10/site-packages/_py...64ac0>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7edf8c5be8f0>>, ...]\ncaller_kwargs = {'item': <DoctestItem tests.md>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        only_new_style_wrappers = True\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n    \n                    if hook_impl.hookwrapper:\n                        only_new_style_wrappers = False\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            wrapper_gen = cast(Generator[None, Result[object], None], res)\n                            next(wrapper_gen)  # first yield\n                            teardowns.append((wrapper_gen, hook_impl))\n                        except StopIteration:\n                            _raise_wrapfail(wrapper_gen, \"did not yield\")\n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            # Fast path - only new-style wrappers, no Result.\n            if only_new_style_wrappers:\n                if firstresult:  # first result hooks return a single value\n                    result = results[0] if results else None\n                else:\n                    result = results\n    \n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    try:\n                        if exception is not None:\n                            teardown.throw(exception)  # type: ignore[union-attr]\n                        else:\n                            teardown.send(result)  # type: ignore[union-attr]\n                        # Following is unreachable for a well behaved hook wrapper.\n                        # Try to force finalizers otherwise postponed till GC action.\n                        # Note: close() may raise if generator handles GeneratorExit.\n                        teardown.close()  # type: ignore[union-attr]\n                    except StopIteration as si:\n                        result = si.value\n                        exception = None\n                        continue\n                    except BaseException as e:\n                        exception = e\n                        continue\n                    _raise_wrapfail(teardown, \"has second yield\")  # type: ignore[arg-type]\n    \n                if exception is not None:\n                    raise exception.with_traceback(exception.__traceback__)\n                else:\n                    return result\n    \n            # Slow path - need to support old-style wrappers.\n            else:\n                if firstresult:  # first result hooks return a single value\n                    outcome: Result[object | list[object]] = Result(\n                        results[0] if results else None, exception\n                    )\n                else:\n                    outcome = Result(results, exception)\n    \n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    if isinstance(teardown, tuple):\n                        try:\n                            teardown[0].send(outcome)\n                        except StopIteration:\n                            pass\n                        except BaseException as e:\n                            _warn_teardown_exception(hook_name, teardown[1], e)\n                            raise\n                        else:\n                            _raise_wrapfail(teardown[0], \"has second yield\")\n                    else:\n                        try:\n                            if outcome._exception is not None:\n>                               teardown.throw(outcome._exception)\n\n.venv/lib/python3.10/site-packages/pluggy/_callers.py:167: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    @pytest.hookimpl(wrapper=True, tryfirst=True)\n    def pytest_runtest_setup() -> Generator[None]:\n>       yield from unraisable_exception_runtest_hook()\n\n.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:90: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def unraisable_exception_runtest_hook() -> Generator[None]:\n        with catch_unraisable_exception() as cm:\n            try:\n>               yield\n\n.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:70: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_setup'\nhook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/testbed/.venv/lib/python3.10/site-packages/_py...64ac0>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7edf8c5be8f0>>, ...]\ncaller_kwargs = {'item': <DoctestItem tests.md>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        only_new_style_wrappers = True\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n    \n                    if hook_impl.hookwrapper:\n                        only_new_style_wrappers = False\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            wrapper_gen = cast(Generator[None, Result[object], None], res)\n                            next(wrapper_gen)  # first yield\n                            teardowns.append((wrapper_gen, hook_impl))\n                        except StopIteration:\n                            _raise_wrapfail(wrapper_gen, \"did not yield\")\n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            # Fast path - only new-style wrappers, no Result.\n            if only_new_style_wrappers:\n                if firstresult:  # first result hooks return a single value\n                    result = results[0] if results else None\n                else:\n                    result = results\n    \n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    try:\n                        if exception is not None:\n                            teardown.throw(exception)  # type: ignore[union-attr]\n                        else:\n                            teardown.send(result)  # type: ignore[union-attr]\n                        # Following is unreachable for a well behaved hook wrapper.\n                        # Try to force finalizers otherwise postponed till GC action.\n                        # Note: close() may raise if generator handles GeneratorExit.\n                        teardown.close()  # type: ignore[union-attr]\n                    except StopIteration as si:\n                        result = si.value\n                        exception = None\n                        continue\n                    except BaseException as e:\n                        exception = e\n                        continue\n                    _raise_wrapfail(teardown, \"has second yield\")  # type: ignore[arg-type]\n    \n                if exception is not None:\n                    raise exception.with_traceback(exception.__traceback__)\n                else:\n                    return result\n    \n            # Slow path - need to support old-style wrappers.\n            else:\n                if firstresult:  # first result hooks return a single value\n                    outcome: Result[object | list[object]] = Result(\n                        results[0] if results else None, exception\n                    )\n                else:\n                    outcome = Result(results, exception)\n    \n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    if isinstance(teardown, tuple):\n                        try:\n                            teardown[0].send(outcome)\n                        except StopIteration:\n                            pass\n                        except BaseException as e:\n                            _warn_teardown_exception(hook_name, teardown[1], e)\n                            raise\n                        else:\n                            _raise_wrapfail(teardown[0], \"has second yield\")\n                    else:\n                        try:\n                            if outcome._exception is not None:\n>                               teardown.throw(outcome._exception)\n\n.venv/lib/python3.10/site-packages/pluggy/_callers.py:167: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_pytest.logging.LoggingPlugin object at 0x7edf8c5be8f0>\nitem = <DoctestItem tests.md>\n\n    @hookimpl(wrapper=True)\n    def pytest_runtest_setup(self, item: nodes.Item) -> Generator[None]:\n        self.log_cli_handler.set_when(\"setup\")\n    \n        empty: dict[str, list[logging.LogRecord]] = {}\n        item.stash[caplog_records_key] = empty\n>       yield from self._runtest_for(item, \"setup\")\n\n.venv/lib/python3.10/site-packages/_pytest/logging.py:840: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_pytest.logging.LoggingPlugin object at 0x7edf8c5be8f0>\nitem = <DoctestItem tests.md>, when = 'setup'\n\n    def _runtest_for(self, item: nodes.Item, when: str) -> Generator[None]:\n        \"\"\"Implement the internals of the pytest_runtest_xxx() hooks.\"\"\"\n        with catching_logs(\n            self.caplog_handler,\n            level=self.log_level,\n        ) as caplog_handler, catching_logs(\n            self.report_handler,\n            level=self.log_level,\n        ) as report_handler:\n            caplog_handler.reset()\n            report_handler.reset()\n            item.stash[caplog_records_key][when] = caplog_handler.records\n            item.stash[caplog_handler_key] = caplog_handler\n    \n            try:\n>               yield\n\n.venv/lib/python3.10/site-packages/_pytest/logging.py:829: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_setup'\nhook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/testbed/.venv/lib/python3.10/site-packages/_py...64ac0>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7edf8c5be8f0>>, ...]\ncaller_kwargs = {'item': <DoctestItem tests.md>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        only_new_style_wrappers = True\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n    \n                    if hook_impl.hookwrapper:\n                        only_new_style_wrappers = False\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            wrapper_gen = cast(Generator[None, Result[object], None], res)\n                            next(wrapper_gen)  # first yield\n                            teardowns.append((wrapper_gen, hook_impl))\n                        except StopIteration:\n                            _raise_wrapfail(wrapper_gen, \"did not yield\")\n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            # Fast path - only new-style wrappers, no Result.\n            if only_new_style_wrappers:\n                if firstresult:  # first result hooks return a single value\n                    result = results[0] if results else None\n                else:\n                    result = results\n    \n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    try:\n                        if exception is not None:\n                            teardown.throw(exception)  # type: ignore[union-attr]\n                        else:\n                            teardown.send(result)  # type: ignore[union-attr]\n                        # Following is unreachable for a well behaved hook wrapper.\n                        # Try to force finalizers otherwise postponed till GC action.\n                        # Note: close() may raise if generator handles GeneratorExit.\n                        teardown.close()  # type: ignore[union-attr]\n                    except StopIteration as si:\n                        result = si.value\n                        exception = None\n                        continue\n                    except BaseException as e:\n                        exception = e\n                        continue\n                    _raise_wrapfail(teardown, \"has second yield\")  # type: ignore[arg-type]\n    \n                if exception is not None:\n                    raise exception.with_traceback(exception.__traceback__)\n                else:\n                    return result\n    \n            # Slow path - need to support old-style wrappers.\n            else:\n                if firstresult:  # first result hooks return a single value\n                    outcome: Result[object | list[object]] = Result(\n                        results[0] if results else None, exception\n                    )\n                else:\n                    outcome = Result(results, exception)\n    \n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    if isinstance(teardown, tuple):\n                        try:\n                            teardown[0].send(outcome)\n                        except StopIteration:\n                            pass\n                        except BaseException as e:\n                            _warn_teardown_exception(hook_name, teardown[1], e)\n                            raise\n                        else:\n                            _raise_wrapfail(teardown[0], \"has second yield\")\n                    else:\n                        try:\n                            if outcome._exception is not None:\n>                               teardown.throw(outcome._exception)\n\n.venv/lib/python3.10/site-packages/pluggy/_callers.py:167: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>\nitem = <DoctestItem tests.md>\n\n    @hookimpl(wrapper=True)\n    def pytest_runtest_setup(self, item: Item) -> Generator[None]:\n        with self.item_capture(\"setup\", item):\n>           return (yield)\n\n.venv/lib/python3.10/site-packages/_pytest/capture.py:875: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_setup'\nhook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/testbed/.venv/lib/python3.10/site-packages/_py...64ac0>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7edf8c5be8f0>>, ...]\ncaller_kwargs = {'item': <DoctestItem tests.md>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        only_new_style_wrappers = True\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n    \n                    if hook_impl.hookwrapper:\n                        only_new_style_wrappers = False\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            wrapper_gen = cast(Generator[None, Result[object], None], res)\n                            next(wrapper_gen)  # first yield\n                            teardowns.append((wrapper_gen, hook_impl))\n                        except StopIteration:\n                            _raise_wrapfail(wrapper_gen, \"did not yield\")\n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            # Fast path - only new-style wrappers, no Result.\n            if only_new_style_wrappers:\n                if firstresult:  # first result hooks return a single value\n                    result = results[0] if results else None\n                else:\n                    result = results\n    \n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    try:\n                        if exception is not None:\n                            teardown.throw(exception)  # type: ignore[union-attr]\n                        else:\n                            teardown.send(result)  # type: ignore[union-attr]\n                        # Following is unreachable for a well behaved hook wrapper.\n                        # Try to force finalizers otherwise postponed till GC action.\n                        # Note: close() may raise if generator handles GeneratorExit.\n                        teardown.close()  # type: ignore[union-attr]\n                    except StopIteration as si:\n                        result = si.value\n                        exception = None\n                        continue\n                    except BaseException as e:\n                        exception = e\n                        continue\n                    _raise_wrapfail(teardown, \"has second yield\")  # type: ignore[arg-type]\n    \n                if exception is not None:\n                    raise exception.with_traceback(exception.__traceback__)\n                else:\n                    return result\n    \n            # Slow path - need to support old-style wrappers.\n            else:\n                if firstresult:  # first result hooks return a single value\n                    outcome: Result[object | list[object]] = Result(\n                        results[0] if results else None, exception\n                    )\n                else:\n                    outcome = Result(results, exception)\n    \n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    if isinstance(teardown, tuple):\n                        try:\n                            teardown[0].send(outcome)\n                        except StopIteration:\n                            pass\n                        except BaseException as e:\n                            _warn_teardown_exception(hook_name, teardown[1], e)\n                            raise\n                        else:\n                            _raise_wrapfail(teardown[0], \"has second yield\")\n                    else:\n                        try:\n                            if outcome._exception is not None:\n>                               teardown.throw(outcome._exception)\n\n.venv/lib/python3.10/site-packages/pluggy/_callers.py:167: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    @pytest.hookimpl(wrapper=True, trylast=True)\n    def pytest_runtest_setup() -> Generator[None]:\n>       yield from thread_exception_runtest_hook()\n\n.venv/lib/python3.10/site-packages/_pytest/threadexception.py:87: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def thread_exception_runtest_hook() -> Generator[None]:\n        with catch_threading_exception() as cm:\n            try:\n>               yield\n\n.venv/lib/python3.10/site-packages/_pytest/threadexception.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_setup'\nhook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/testbed/.venv/lib/python3.10/site-packages/_py...64ac0>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7edf8c5be8f0>>, ...]\ncaller_kwargs = {'item': <DoctestItem tests.md>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        only_new_style_wrappers = True\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n    \n                    if hook_impl.hookwrapper:\n                        only_new_style_wrappers = False\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            wrapper_gen = cast(Generator[None, Result[object], None], res)\n                            next(wrapper_gen)  # first yield\n                            teardowns.append((wrapper_gen, hook_impl))\n                        except StopIteration:\n                            _raise_wrapfail(wrapper_gen, \"did not yield\")\n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n>                       res = hook_impl.function(*args)\n\n.venv/lib/python3.10/site-packages/pluggy/_callers.py:103: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nitem = <DoctestItem tests.md>\n\n    def pytest_runtest_setup(item: Item) -> None:\n        _update_current_test_var(item, \"setup\")\n>       item.session._setupstate.setup(item)\n\n.venv/lib/python3.10/site-packages/_pytest/runner.py:160: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_pytest.runner.SetupState object at 0x7edf8c5bc100>\nitem = <DoctestItem tests.md>\n\n    def setup(self, item: Item) -> None:\n        \"\"\"Setup objects along the collector chain to the item.\"\"\"\n        needed_collectors = item.listchain()\n    \n        # If a collector fails its setup, fail its entire subtree of items.\n        # The setup is not retried for each item - the same exception is used.\n        for col, (finalizers, exc) in self.stack.items():\n            assert col in needed_collectors, \"previous item was not torn down properly\"\n            if exc:\n                raise exc[0].with_traceback(exc[1])\n    \n        for col in needed_collectors[len(self.stack) :]:\n            assert col not in self.stack\n            # Push onto the stack.\n            self.stack[col] = ([col.teardown], None)\n            try:\n>               col.setup()\n\n.venv/lib/python3.10/site-packages/_pytest/runner.py:514: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Package voluptuous>\n\n    def setup(self) -> None:\n>       init_mod = importtestmodule(self.path / \"__init__.py\", self.config)\n\n.venv/lib/python3.10/site-packages/_pytest/python.py:663: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath = PosixPath('/testbed/voluptuous/__init__.py')\nconfig = <_pytest.config.Config object at 0x7edf8c964820>\n\n    def importtestmodule(\n        path: Path,\n        config: Config,\n    ):\n        # We assume we are only called once per module.\n        importmode = config.getoption(\"--import-mode\")\n        try:\n            mod = import_path(\n                path,\n                mode=importmode,\n                root=config.rootpath,\n                consider_namespace_packages=config.getini(\"consider_namespace_packages\"),\n            )\n        except SyntaxError as e:\n            raise nodes.Collector.CollectError(\n                ExceptionInfo.from_current().getrepr(style=\"short\")\n            ) from e\n        except ImportPathMismatchError as e:\n            raise nodes.Collector.CollectError(\n                \"import file mismatch:\\n\"\n                \"imported module {!r} has this __file__ attribute:\\n\"\n                \"  {}\\n\"\n                \"which is not the same as the test file we want to collect:\\n\"\n                \"  {}\\n\"\n                \"HINT: remove __pycache__ / .pyc files and/or use a \"\n                \"unique basename for your test file modules\".format(*e.args)\n            ) from e\n        except ImportError as e:\n            exc_info = ExceptionInfo.from_current()\n            if config.get_verbosity() < 2:\n                exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\")\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n>           raise nodes.Collector.CollectError(\n                f\"ImportError while importing test module '{path}'.\\n\"\n                \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n                \"Traceback:\\n\"\n                f\"{formatted_tb}\"\n            ) from e\nE           _pytest.nodes.Collector.CollectError: ImportError while importing test module '/testbed/voluptuous/__init__.py'.\nE           Hint: make sure your test modules/packages have valid Python names.\nE           Traceback:\nE           /usr/lib/python3.10/importlib/__init__.py:126: in import_module\nE               return _bootstrap._gcd_import(name[level:], package, level)\nE           voluptuous/__init__.py:80: in <module>\nE               from voluptuous.util import *\nE           voluptuous/util.py:2: in <module>\nE               from voluptuous import validators\nE           voluptuous/validators.py:10: in <module>\nE               from voluptuous.schema_builder import Schema, Schemable, message, raises\nE           E   ImportError: cannot import name 'raises' from 'voluptuous.schema_builder' (/testbed/voluptuous/schema_builder.py)\n\n.venv/lib/python3.10/site-packages/_pytest/python.py:523: CollectError"}, "teardown": {"duration": 0.00033962399999998283, "outcome": "passed"}}]}