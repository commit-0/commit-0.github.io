============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0
rootdir: /testbed
configfile: setup.cfg
plugins: metadata-3.1.1, json-report-1.5.0, cov-5.0.0
collected 214 items / 17 errors / 1 skipped

tests/test_core.py FFFF.FFFFF.FF....FFF                                  [  9%]
tests/test_languages.py FF                                               [ 10%]
tests/test_lists.py FF                                                   [ 11%]
tests/test_localedata.py FFFFFFFFF.FFs                                   [ 17%]
tests/test_numbers.py FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 40%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 74%]
FFFFFFFFFF                                                               [ 78%]
tests/test_plural.py FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF       [100%]

==================================== ERRORS ====================================
_______________ ERROR collecting tests/messages/test_catalog.py ________________
ImportError while importing test module '/testbed/tests/messages/test_catalog.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests/messages/test_catalog.py:18: in <module>
    from babel.dates import UTC, format_datetime
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
babel/localtime/_unix.py:4: in <module>
    from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)
_______________ ERROR collecting tests/messages/test_checkers.py _______________
ImportError while importing test module '/testbed/tests/messages/test_checkers.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests/messages/test_checkers.py:19: in <module>
    from babel.dates import format_datetime
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
babel/localtime/_unix.py:4: in <module>
    from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)
_______________ ERROR collecting tests/messages/test_extract.py ________________
ImportError while importing test module '/testbed/tests/messages/test_extract.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests/messages/test_extract.py:20: in <module>
    from babel.messages import extract
babel/messages/__init__.py:11: in <module>
    from babel.messages.catalog import (
babel/messages/catalog.py:22: in <module>
    from babel.dates import format_datetime
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
babel/localtime/_unix.py:4: in <module>
    from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)
_______________ ERROR collecting tests/messages/test_frontend.py _______________
ImportError while importing test module '/testbed/tests/messages/test_frontend.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests/messages/test_frontend.py:27: in <module>
    from babel.dates import format_datetime
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
babel/localtime/_unix.py:4: in <module>
    from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)
______________ ERROR collecting tests/messages/test_js_extract.py ______________
ImportError while importing test module '/testbed/tests/messages/test_js_extract.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests/messages/test_js_extract.py:5: in <module>
    from babel.messages import extract
babel/messages/__init__.py:11: in <module>
    from babel.messages.catalog import (
babel/messages/catalog.py:22: in <module>
    from babel.dates import format_datetime
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
babel/localtime/_unix.py:4: in <module>
    from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)
_______________ ERROR collecting tests/messages/test_jslexer.py ________________
ImportError while importing test module '/testbed/tests/messages/test_jslexer.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests/messages/test_jslexer.py:1: in <module>
    from babel.messages import jslexer
babel/messages/__init__.py:11: in <module>
    from babel.messages.catalog import (
babel/messages/catalog.py:22: in <module>
    from babel.dates import format_datetime
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
babel/localtime/_unix.py:4: in <module>
    from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)
________________ ERROR collecting tests/messages/test_mofile.py ________________
ImportError while importing test module '/testbed/tests/messages/test_mofile.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests/messages/test_mofile.py:17: in <module>
    from babel.messages import Catalog, mofile
babel/messages/__init__.py:11: in <module>
    from babel.messages.catalog import (
babel/messages/catalog.py:22: in <module>
    from babel.dates import format_datetime
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
babel/localtime/_unix.py:4: in <module>
    from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)
__________ ERROR collecting tests/messages/test_normalized_string.py ___________
ImportError while importing test module '/testbed/tests/messages/test_normalized_string.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests/messages/test_normalized_string.py:1: in <module>
    from babel.messages.pofile import _NormalizedString
babel/messages/__init__.py:11: in <module>
    from babel.messages.catalog import (
babel/messages/catalog.py:22: in <module>
    from babel.dates import format_datetime
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
babel/localtime/_unix.py:4: in <module>
    from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)
_______________ ERROR collecting tests/messages/test_plurals.py ________________
ImportError while importing test module '/testbed/tests/messages/test_plurals.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests/messages/test_plurals.py:15: in <module>
    from babel.messages import plurals
babel/messages/__init__.py:11: in <module>
    from babel.messages.catalog import (
babel/messages/catalog.py:22: in <module>
    from babel.dates import format_datetime
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
babel/localtime/_unix.py:4: in <module>
    from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)
________________ ERROR collecting tests/messages/test_pofile.py ________________
ImportError while importing test module '/testbed/tests/messages/test_pofile.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests/messages/test_pofile.py:20: in <module>
    from babel.messages import pofile
babel/messages/__init__.py:11: in <module>
    from babel.messages.catalog import (
babel/messages/catalog.py:22: in <module>
    from babel.dates import format_datetime
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
babel/localtime/_unix.py:4: in <module>
    from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)
_____________________ ERROR collecting tests/test_core.py ______________________
.venv/lib/python3.10/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
.venv/lib/python3.10/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
.venv/lib/python3.10/site-packages/_pytest/python.py:245: in pytest_pycollect_makeitem
    return list(collector._genfunctions(name, obj))
.venv/lib/python3.10/site-packages/_pytest/python.py:462: in _genfunctions
    self.ihook.pytest_generate_tests.call_extra(methods, dict(metafunc=metafunc))
.venv/lib/python3.10/site-packages/pluggy/_hooks.py:574: in call_extra
    return self._hookexec(self.name, hookimpls, kwargs, firstresult)
.venv/lib/python3.10/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
tests/conftest.py:31: in pytest_generate_tests
    metafunc.parametrize("locale", list(locale_identifiers()))
E   TypeError: 'NoneType' object is not iterable
________________ ERROR collecting tests/test_date_intervals.py _________________
ImportError while importing test module '/testbed/tests/test_date_intervals.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests/test_date_intervals.py:3: in <module>
    from babel import dates
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
babel/localtime/_unix.py:4: in <module>
    from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)
_____________________ ERROR collecting tests/test_dates.py _____________________
ImportError while importing test module '/testbed/tests/test_dates.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests/test_dates.py:19: in <module>
    from babel import Locale, dates
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
babel/localtime/_unix.py:4: in <module>
    from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)
__________________ ERROR collecting tests/test_day_periods.py __________________
ImportError while importing test module '/testbed/tests/test_day_periods.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests/test_day_periods.py:5: in <module>
    import babel.dates as dates
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
babel/localtime/_unix.py:4: in <module>
    from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)
_____________________ ERROR collecting tests/test_smoke.py _____________________
ImportError while importing test module '/testbed/tests/test_smoke.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests/test_smoke.py:12: in <module>
    from babel import Locale, dates, numbers, units
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
babel/localtime/_unix.py:4: in <module>
    from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)
____________________ ERROR collecting tests/test_support.py ____________________
ImportError while importing test module '/testbed/tests/test_support.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests/test_support.py:25: in <module>
    from babel import support
babel/support.py:21: in <module>
    from babel.dates import format_date, format_datetime, format_time, format_timedelta
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
babel/localtime/_unix.py:4: in <module>
    from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)
_____________________ ERROR collecting tests/test_util.py ______________________
ImportError while importing test module '/testbed/tests/test_util.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests/test_util.py:20: in <module>
    from babel import util
babel/util.py:19: in <module>
    from babel import dates, localtime
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
babel/localtime/_unix.py:4: in <module>
    from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)
=================================== FAILURES ===================================
_______________ test_locale_provides_access_to_cldr_locale_data ________________

    def test_locale_provides_access_to_cldr_locale_data():
>       locale = Locale('en', 'US')

tests/test_core.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Locale('en', territory='US'), language = 'en', territory = 'US'
script = None, variant = None, modifier = None

    def __init__(self, language: str, territory: (str | None)=None, script:
        (str | None)=None, variant: (str | None)=None, modifier: (str |
        None)=None) ->None:
        """Initialize the locale object from the given identifier components.
    
        >>> locale = Locale('en', 'US')
        >>> locale.language
        'en'
        >>> locale.territory
        'US'
    
        :param language: the language code
        :param territory: the territory (country or region) code
        :param script: the script code
        :param variant: the variant code
        :param modifier: a modifier (following the '@' symbol, sometimes called '@variant')
        :raise `UnknownLocaleError`: if no locale data is available for the
                                     requested locale
        """
        self.language = language
        self.territory = territory
        self.script = script
        self.variant = variant
        self.modifier = modifier
        self.__data: localedata.LocaleDataDict | None = None
>       identifier = str(self)
E       TypeError: __str__ returned non-string (type NoneType)

babel/core.py:151: TypeError
_______________________________ test_locale_repr _______________________________

    def test_locale_repr():
>       assert repr(Locale('en', 'US')) == "Locale('en', territory='US')"

tests/test_core.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Locale('en', territory='US'), language = 'en', territory = 'US'
script = None, variant = None, modifier = None

    def __init__(self, language: str, territory: (str | None)=None, script:
        (str | None)=None, variant: (str | None)=None, modifier: (str |
        None)=None) ->None:
        """Initialize the locale object from the given identifier components.
    
        >>> locale = Locale('en', 'US')
        >>> locale.language
        'en'
        >>> locale.territory
        'US'
    
        :param language: the language code
        :param territory: the territory (country or region) code
        :param script: the script code
        :param variant: the variant code
        :param modifier: a modifier (following the '@' symbol, sometimes called '@variant')
        :raise `UnknownLocaleError`: if no locale data is available for the
                                     requested locale
        """
        self.language = language
        self.territory = territory
        self.script = script
        self.variant = variant
        self.modifier = modifier
        self.__data: localedata.LocaleDataDict | None = None
>       identifier = str(self)
E       TypeError: __str__ returned non-string (type NoneType)

babel/core.py:151: TypeError
____________________________ test_locale_comparison ____________________________

    def test_locale_comparison():
>       en_US = Locale('en', 'US')

tests/test_core.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Locale('en', territory='US'), language = 'en', territory = 'US'
script = None, variant = None, modifier = None

    def __init__(self, language: str, territory: (str | None)=None, script:
        (str | None)=None, variant: (str | None)=None, modifier: (str |
        None)=None) ->None:
        """Initialize the locale object from the given identifier components.
    
        >>> locale = Locale('en', 'US')
        >>> locale.language
        'en'
        >>> locale.territory
        'US'
    
        :param language: the language code
        :param territory: the territory (country or region) code
        :param script: the script code
        :param variant: the variant code
        :param modifier: a modifier (following the '@' symbol, sometimes called '@variant')
        :raise `UnknownLocaleError`: if no locale data is available for the
                                     requested locale
        """
        self.language = language
        self.territory = territory
        self.script = script
        self.variant = variant
        self.modifier = modifier
        self.__data: localedata.LocaleDataDict | None = None
>       identifier = str(self)
E       TypeError: __str__ returned non-string (type NoneType)

babel/core.py:151: TypeError
________________________ test_can_return_default_locale ________________________

os_environ = {'BLIS_NUM_THREADS': '1', 'CFLAGS': '-g0', 'HOME': '/root', 'LC_CTYPE': 'C.UTF-8', ...}

    def test_can_return_default_locale(os_environ):
        os_environ['LC_MESSAGES'] = 'fr_FR.UTF-8'
>       assert Locale('fr', 'FR') == Locale.default('LC_MESSAGES')

tests/test_core.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Locale('fr', territory='FR'), language = 'fr', territory = 'FR'
script = None, variant = None, modifier = None

    def __init__(self, language: str, territory: (str | None)=None, script:
        (str | None)=None, variant: (str | None)=None, modifier: (str |
        None)=None) ->None:
        """Initialize the locale object from the given identifier components.
    
        >>> locale = Locale('en', 'US')
        >>> locale.language
        'en'
        >>> locale.territory
        'US'
    
        :param language: the language code
        :param territory: the territory (country or region) code
        :param script: the script code
        :param variant: the variant code
        :param modifier: a modifier (following the '@' symbol, sometimes called '@variant')
        :raise `UnknownLocaleError`: if no locale data is available for the
                                     requested locale
        """
        self.language = language
        self.territory = territory
        self.script = script
        self.variant = variant
        self.modifier = modifier
        self.__data: localedata.LocaleDataDict | None = None
>       identifier = str(self)
E       TypeError: __str__ returned non-string (type NoneType)

babel/core.py:151: TypeError
_______________________________ test_get_global ________________________________

    def test_get_global():
>       assert core.get_global('zone_aliases')['GMT'] == 'Etc/GMT'
E       TypeError: 'NoneType' object is not subscriptable

tests/test_core.py:59: TypeError
__________________________________ test_hash ___________________________________

    def test_hash():
>       locale_a = Locale('en', 'US')

tests/test_core.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Locale('en', territory='US'), language = 'en', territory = 'US'
script = None, variant = None, modifier = None

    def __init__(self, language: str, territory: (str | None)=None, script:
        (str | None)=None, variant: (str | None)=None, modifier: (str |
        None)=None) ->None:
        """Initialize the locale object from the given identifier components.
    
        >>> locale = Locale('en', 'US')
        >>> locale.language
        'en'
        >>> locale.territory
        'US'
    
        :param language: the language code
        :param territory: the territory (country or region) code
        :param script: the script code
        :param variant: the variant code
        :param modifier: a modifier (following the '@' symbol, sometimes called '@variant')
        :raise `UnknownLocaleError`: if no locale data is available for the
                                     requested locale
        """
        self.language = language
        self.territory = territory
        self.script = script
        self.variant = variant
        self.modifier = modifier
        self.__data: localedata.LocaleDataDict | None = None
>       identifier = str(self)
E       TypeError: __str__ returned non-string (type NoneType)

babel/core.py:151: TypeError
_____________________________ test_default_locale ______________________________

os_environ = {'BLIS_NUM_THREADS': '1', 'CFLAGS': '-g0', 'HOME': '/root', 'LANG': 'fr_FR.UTF-8', ...}

    def test_default_locale(os_environ):
        for name in ['LANGUAGE', 'LC_ALL', 'LC_CTYPE', 'LC_MESSAGES']:
            os_environ[name] = ''
        os_environ['LANG'] = 'fr_FR.UTF-8'
>       assert default_locale('LC_MESSAGES') == 'fr_FR'
E       AssertionError: assert None == 'fr_FR'
E        +  where None = default_locale('LC_MESSAGES')

tests/test_core.py:271: AssertionError
____________________________ test_negotiate_locale _____________________________

    def test_negotiate_locale():
>       assert (core.negotiate_locale(['de_DE', 'en_US'], ['de_DE', 'de_AT']) ==
                'de_DE')
E       AssertionError: assert None == 'de_DE'
E        +  where None = <function negotiate_locale at 0x7fda9a79a9e0>(['de_DE', 'en_US'], ['de_DE', 'de_AT'])
E        +    where <function negotiate_locale at 0x7fda9a79a9e0> = core.negotiate_locale

tests/test_core.py:282: AssertionError
______________________________ test_parse_locale _______________________________

    def test_parse_locale():
>       assert core.parse_locale('zh_CN') == ('zh', 'CN', None, None)
E       AssertionError: assert None == ('zh', 'CN', None, None)
E        +  where None = <function parse_locale at 0x7fda9a79aa70>('zh_CN')
E        +    where <function parse_locale at 0x7fda9a79aa70> = core.parse_locale

tests/test_core.py:295: AssertionError
_ test_compatible_classes_in_global_and_localedata[babel/locale-data/root.dat] _

filename = 'babel/locale-data/root.dat'

    @pytest.mark.parametrize('filename', [
        'babel/global.dat',
        'babel/locale-data/root.dat',
        'babel/locale-data/en.dat',
        'babel/locale-data/en_US.dat',
        'babel/locale-data/en_US_POSIX.dat',
        'babel/locale-data/zh_Hans_CN.dat',
        'babel/locale-data/zh_Hant_TW.dat',
        'babel/locale-data/es_419.dat',
    ])
    def test_compatible_classes_in_global_and_localedata(filename):
        import pickle
    
        class Unpickler(pickle.Unpickler):
    
            def find_class(self, module, name):
                # *.dat files must have compatible classes between Python 2 and 3
                if module.split('.')[0] == 'babel':
                    return pickle.Unpickler.find_class(self, module, name)
                raise pickle.UnpicklingError(f"global '{module}.{name}' is forbidden")
    
        with open(filename, 'rb') as f:
>           assert Unpickler(f).load()

tests/test_core.py:334: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_core.py:330: in find_class
    return pickle.Unpickler.find_class(self, module, name)
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    import os
    import re
>   from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)

babel/localtime/_unix.py:4: ImportError
__ test_compatible_classes_in_global_and_localedata[babel/locale-data/en.dat] __

filename = 'babel/locale-data/en.dat'

    @pytest.mark.parametrize('filename', [
        'babel/global.dat',
        'babel/locale-data/root.dat',
        'babel/locale-data/en.dat',
        'babel/locale-data/en_US.dat',
        'babel/locale-data/en_US_POSIX.dat',
        'babel/locale-data/zh_Hans_CN.dat',
        'babel/locale-data/zh_Hant_TW.dat',
        'babel/locale-data/es_419.dat',
    ])
    def test_compatible_classes_in_global_and_localedata(filename):
        import pickle
    
        class Unpickler(pickle.Unpickler):
    
            def find_class(self, module, name):
                # *.dat files must have compatible classes between Python 2 and 3
                if module.split('.')[0] == 'babel':
                    return pickle.Unpickler.find_class(self, module, name)
                raise pickle.UnpicklingError(f"global '{module}.{name}' is forbidden")
    
        with open(filename, 'rb') as f:
>           assert Unpickler(f).load()

tests/test_core.py:334: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_core.py:330: in find_class
    return pickle.Unpickler.find_class(self, module, name)
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    import os
    import re
>   from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)

babel/localtime/_unix.py:4: ImportError
_ test_compatible_classes_in_global_and_localedata[babel/locale-data/es_419.dat] _

filename = 'babel/locale-data/es_419.dat'

    @pytest.mark.parametrize('filename', [
        'babel/global.dat',
        'babel/locale-data/root.dat',
        'babel/locale-data/en.dat',
        'babel/locale-data/en_US.dat',
        'babel/locale-data/en_US_POSIX.dat',
        'babel/locale-data/zh_Hans_CN.dat',
        'babel/locale-data/zh_Hant_TW.dat',
        'babel/locale-data/es_419.dat',
    ])
    def test_compatible_classes_in_global_and_localedata(filename):
        import pickle
    
        class Unpickler(pickle.Unpickler):
    
            def find_class(self, module, name):
                # *.dat files must have compatible classes between Python 2 and 3
                if module.split('.')[0] == 'babel':
                    return pickle.Unpickler.find_class(self, module, name)
                raise pickle.UnpicklingError(f"global '{module}.{name}' is forbidden")
    
        with open(filename, 'rb') as f:
>           assert Unpickler(f).load()

tests/test_core.py:334: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_core.py:330: in find_class
    return pickle.Unpickler.find_class(self, module, name)
babel/dates.py:29: in <module>
    from babel import localtime
babel/localtime/__init__.py:18: in <module>
    from babel.localtime._unix import _get_localzone
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    import os
    import re
>   from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise
E   ImportError: cannot import name '_get_tzinfo_from_file' from 'babel.localtime._helpers' (/testbed/babel/localtime/_helpers.py)

babel/localtime/_unix.py:4: ImportError
_______________ test_issue_601_no_language_name_but_has_variant ________________

    def test_issue_601_no_language_name_but_has_variant():
        # kw_GB has a variant for Finnish but no actual language name for Finnish,
        # so `get_display_name()` previously crashed with a TypeError as it attempted
        # to concatenate " (Finnish)" to None.
        # Instead, it's better to return None altogether, as we can't reliably format
        # part of a language name.
    
>       assert Locale.parse('fi_FI').get_display_name('kw_GB') is None
E       AttributeError: 'NoneType' object has no attribute 'get_display_name'

tests/test_core.py:344: AttributeError
________________________________ test_issue_814 ________________________________

    def test_issue_814():
        loc = Locale.parse('ca_ES_valencia')
>       assert loc.variant == "VALENCIA"
E       AttributeError: 'NoneType' object has no attribute 'variant'

tests/test_core.py:349: AttributeError
___________________________ test_official_languages ____________________________

    def test_official_languages():
>       assert get_official_languages("FI") == ("fi", "sv")
E       AssertionError: assert None == ('fi', 'sv')
E        +  where None = get_official_languages('FI')

tests/test_languages.py:5: AssertionError
____________________________ test_get_language_info ____________________________

    def test_get_language_info():
>       assert (
            set(get_territory_language_info("HU")) ==
            {"hu", "fr", "en", "de", "ro", "hr", "sk", "sl"}
        )
E       TypeError: 'NoneType' object is not iterable

tests/test_languages.py:13: TypeError
_______________________________ test_format_list _______________________________

    def test_format_list():
        for list, locale, expected in [
            ([], 'en', ''),
            (['string'], 'en', 'string'),
            (['string1', 'string2'], 'en', 'string1 and string2'),
            (['string1', 'string2', 'string3'], 'en', 'string1, string2, and string3'),
            (['string1', 'string2', 'string3'], 'zh', 'string1、string2和string3'),
            (['string1', 'string2', 'string3', 'string4'], 'ne', 'string1,string2, string3 र string4'),
        ]:
>           assert lists.format_list(list, locale=locale) == expected
E           AssertionError: assert None == ''
E            +  where None = <function format_list at 0x7fda9a509b40>([], locale='en')
E            +    where <function format_list at 0x7fda9a509b40> = lists.format_list

tests/test_lists.py:15: AssertionError
____________________________ test_format_list_error ____________________________

    def test_format_list_error():
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/test_lists.py:19: Failed
____________________ MergeResolveTestCase.test_merge_items _____________________

self = <tests.test_localedata.MergeResolveTestCase testMethod=test_merge_items>

    def test_merge_items(self):
        d = {1: 'foo', 3: 'baz'}
        localedata.merge(d, {1: 'Foo', 2: 'Bar'})
>       assert d == {1: 'Foo', 2: 'Bar', 3: 'baz'}
E       AssertionError: assert {1: 'foo', 3: 'baz'} == {1: 'Foo', 2: 'Bar', 3: 'baz'}
E         
E         Omitting 1 identical items, use -vv to show
E         Differing items:
E         {1: 'foo'} != {1: 'Foo'}
E         Right contains 1 more item:
E         {2: 'Bar'}
E         Use -v to get more diff

tests/test_localedata.py:31: AssertionError
_________________ MergeResolveTestCase.test_merge_nested_dict __________________

self = <tests.test_localedata.MergeResolveTestCase testMethod=test_merge_nested_dict>

    def test_merge_nested_dict(self):
        d1 = {'x': {'a': 1, 'b': 2, 'c': 3}}
        d2 = {'x': {'a': 1, 'b': 12, 'd': 14}}
        localedata.merge(d1, d2)
>       assert d1 == {'x': {'a': 1, 'b': 12, 'c': 3, 'd': 14}}
E       AssertionError: assert {'x': {'a': 1...': 2, 'c': 3}} == {'x': {'a': 1...: 3, 'd': 14}}
E         
E         Differing items:
E         {'x': {'a': 1, 'b': 2, 'c': 3}} != {'x': {'a': 1, 'b': 12, 'c': 3, 'd': 14}}
E         Use -v to get more diff

tests/test_localedata.py:37: AssertionError
____________ MergeResolveTestCase.test_merge_nested_dict_no_overlap ____________

self = <tests.test_localedata.MergeResolveTestCase testMethod=test_merge_nested_dict_no_overlap>

    def test_merge_nested_dict_no_overlap(self):
        d1 = {'x': {'a': 1, 'b': 2}}
        d2 = {'y': {'a': 11, 'b': 12}}
        localedata.merge(d1, d2)
>       assert d1 == {'x': {'a': 1, 'b': 2}, 'y': {'a': 11, 'b': 12}}
E       AssertionError: assert {'x': {'a': 1, 'b': 2}} == {'x': {'a': 1... 11, 'b': 12}}
E         
E         Omitting 1 identical items, use -vv to show
E         Right contains 1 more item:
E         {'y': {'a': 11, 'b': 12}}
E         Use -v to get more diff

tests/test_localedata.py:43: AssertionError
____________ MergeResolveTestCase.test_merge_with_alias_and_resolve ____________

self = <tests.test_localedata.MergeResolveTestCase testMethod=test_merge_with_alias_and_resolve>

    def test_merge_with_alias_and_resolve(self):
        alias = localedata.Alias('x')
        d1 = {
            'x': {'a': 1, 'b': 2, 'c': 3},
            'y': alias,
        }
        d2 = {
            'x': {'a': 1, 'b': 12, 'd': 14},
            'y': {'b': 22, 'e': 25},
        }
        localedata.merge(d1, d2)
>       assert d1 == {'x': {'a': 1, 'b': 12, 'c': 3, 'd': 14}, 'y': (alias, {'b': 22, 'e': 25})}
E       AssertionError: assert {'x': {'a': 1...Alias ('x',)>} == {'x': {'a': 1...22, 'e': 25})}
E         
E         Differing items:
E         {'y': <Alias ('x',)>} != {'y': (<Alias ('x',)>, {'b': 22, 'e': 25})}
E         {'x': {'a': 1, 'b': 2, 'c': 3}} != {'x': {'a': 1, 'b': 12, 'c': 3, 'd': 14}}
E         Use -v to get more diff

tests/test_localedata.py:56: AssertionError
__________________________________ test_load ___________________________________

    def test_load():
>       assert localedata.load('en_US')['languages']['sv'] == 'Swedish'
E       TypeError: 'NoneType' object is not subscriptable

tests/test_localedata.py:62: TypeError
__________________________________ test_merge __________________________________

    def test_merge():
        d = {1: 'foo', 3: 'baz'}
        localedata.merge(d, {1: 'Foo', 2: 'Bar'})
>       assert d == {1: 'Foo', 2: 'Bar', 3: 'baz'}
E       AssertionError: assert {1: 'foo', 3: 'baz'} == {1: 'Foo', 2: 'Bar', 3: 'baz'}
E         
E         Omitting 1 identical items, use -vv to show
E         Differing items:
E         {1: 'foo'} != {1: 'Foo'}
E         Right contains 1 more item:
E         {2: 'Bar'}
E         Use -v to get more diff

tests/test_localedata.py:69: AssertionError
__________________________ test_locale_identification __________________________

    def test_locale_identification():
>       for locale in localedata.locale_identifiers():
E       TypeError: 'NoneType' object is not iterable

tests/test_localedata.py:73: TypeError
_______________________________ test_unique_ids ________________________________

    def test_unique_ids():
        # Check all locale IDs are uniques.
        all_ids = localedata.locale_identifiers()
>       assert len(all_ids) == len(set(all_ids))
E       TypeError: object of type 'NoneType' has no len()

tests/test_localedata.py:80: TypeError
____________________________ test_mixedcased_locale ____________________________

    def test_mixedcased_locale():
>       for locale in localedata.locale_identifiers():
E       TypeError: 'NoneType' object is not iterable

tests/test_localedata.py:87: TypeError
________________________ test_locale_identifiers_cache _________________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fda99f834f0>

    def test_locale_identifiers_cache(monkeypatch):
        original_listdir = localedata.os.listdir
        listdir_calls = []
    
        def listdir_spy(*args):
            rv = original_listdir(*args)
            listdir_calls.append((args, rv))
            return rv
    
        monkeypatch.setattr(localedata.os, 'listdir', listdir_spy)
        localedata.locale_identifiers.cache_clear()
        assert not listdir_calls
        l = localedata.locale_identifiers()
>       assert len(listdir_calls) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_localedata.py:118: AssertionError
___________________________ test_locale_name_cleanup ___________________________

    def test_locale_name_cleanup():
        """
        Test that locale identifiers are cleaned up to avoid directory traversal.
        """
        no_exist_name = os.path.join(tempfile.gettempdir(), "babel%d.dat" % random.randint(1, 99999))
        with open(no_exist_name, "wb") as f:
            pickle.dump({}, f)
    
        try:
            name = os.path.splitext(os.path.relpath(no_exist_name, localedata._dirname))[0]
        except ValueError:
            if sys.platform == "win32":
                pytest.skip("unable to form relpath")
            raise
    
        assert not localedata.exists(name)
>       with pytest.raises(IOError):
E       Failed: DID NOT RAISE <class 'OSError'>

tests/test_localedata.py:142: Failed
______________________ FormatDecimalTestCase.test_compact ______________________

self = <tests.test_numbers.FormatDecimalTestCase testMethod=test_compact>

    def test_compact(self):
>       assert numbers.format_compact_decimal(1, locale='en_US', format_type="short") == '1'
E       AssertionError: assert None == '1'
E        +  where None = <function format_compact_decimal at 0x7fda99608790>(1, locale='en_US', format_type='short')
E        +    where <function format_compact_decimal at 0x7fda99608790> = numbers.format_compact_decimal

tests/test_numbers.py:142: AssertionError
_____________________ FormatDecimalTestCase.test_decimals ______________________

self = <tests.test_numbers.FormatDecimalTestCase testMethod=test_decimals>

    def test_decimals(self):
        """Test significant digits patterns"""
>       assert numbers.format_decimal(decimal.Decimal('1.2345'), '#.00', locale='en_US') == '1.23'
E       AssertionError: assert None == '1.23'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('1.2345'), '#.00', locale='en_US')
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('1.2345') = <class 'decimal.Decimal'>('1.2345')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:82: AssertionError
_________________ FormatDecimalTestCase.test_default_rounding __________________

self = <tests.test_numbers.FormatDecimalTestCase testMethod=test_default_rounding>

    def test_default_rounding(self):
        """
        Testing Round-Half-Even (Banker's rounding)
    
        A '5' is rounded to the closest 'even' number
        """
>       assert numbers.format_decimal(5.5, '0', locale='sv') == '6'
E       AssertionError: assert None == '6'
E        +  where None = <function format_decimal at 0x7fda99608700>(5.5, '0', locale='sv')
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal

tests/test_numbers.py:53: AssertionError
_________ FormatDecimalTestCase.test_formatting_of_very_small_decimals _________

self = <tests.test_numbers.FormatDecimalTestCase testMethod=test_formatting_of_very_small_decimals>

    def test_formatting_of_very_small_decimals(self):
        # previously formatting very small decimals could lead to a type error
        # because the Decimal->string conversion was too simple (see #214)
        number = decimal.Decimal("7E-7")
>       assert numbers.format_decimal(number, format="@@@", locale='en_US') == '0.000000700'
E       AssertionError: assert None == '0.000000700'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('7E-7'), format='@@@', locale='en_US')
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal

tests/test_numbers.py:112: AssertionError
__________________ FormatDecimalTestCase.test_group_separator __________________

self = <tests.test_numbers.FormatDecimalTestCase testMethod=test_group_separator>

    def test_group_separator(self):
>       assert numbers.format_decimal(29567.12, locale='en_US', group_separator=False) == '29567.12'
E       AssertionError: assert None == '29567.12'
E        +  where None = <function format_decimal at 0x7fda99608700>(29567.12, locale='en_US', group_separator=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal

tests/test_numbers.py:125: AssertionError
_________________ FormatDecimalTestCase.test_nan_and_infinity __________________

self = <tests.test_numbers.FormatDecimalTestCase testMethod=test_nan_and_infinity>

    def test_nan_and_infinity(self):
>       assert numbers.format_decimal(decimal.Decimal('Infinity'), locale='en_US') == '∞'
E       AssertionError: assert None == '∞'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('Infinity'), locale='en_US')
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('Infinity') = <class 'decimal.Decimal'>('Infinity')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:115: AssertionError
_____________________ FormatDecimalTestCase.test_patterns ______________________

self = <tests.test_numbers.FormatDecimalTestCase testMethod=test_patterns>

    def test_patterns(self):
>       assert numbers.format_decimal(12345, '##0', locale='en_US') == '12345'
E       AssertionError: assert None == '12345'
E        +  where None = <function format_decimal at 0x7fda99608700>(12345, '##0', locale='en_US')
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal

tests/test_numbers.py:35: AssertionError
________________ FormatDecimalTestCase.test_scientific_notation ________________

self = <tests.test_numbers.FormatDecimalTestCase testMethod=test_scientific_notation>

    def test_scientific_notation(self):
>       assert numbers.format_scientific(0.1, '#E0', locale='en_US') == '1E-1'
E       AssertionError: assert None == '1E-1'
E        +  where None = <function format_scientific at 0x7fda99608a60>(0.1, '#E0', locale='en_US')
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific

tests/test_numbers.py:88: AssertionError
________________ FormatDecimalTestCase.test_significant_digits _________________

self = <tests.test_numbers.FormatDecimalTestCase testMethod=test_significant_digits>

    def test_significant_digits(self):
        """Test significant digits patterns"""
>       assert numbers.format_decimal(123004, '@@', locale='en_US') == '120000'
E       AssertionError: assert None == '120000'
E        +  where None = <function format_decimal at 0x7fda99608700>(123004, '@@', locale='en_US')
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal

tests/test_numbers.py:61: AssertionError
____________________ FormatDecimalTestCase.test_subpatterns ____________________

self = <tests.test_numbers.FormatDecimalTestCase testMethod=test_subpatterns>

    def test_subpatterns(self):
>       assert numbers.format_decimal((- 12345), '#,##0.##;-#', locale='en_US') == '-12,345'
E       AssertionError: assert None == '-12,345'
E        +  where None = <function format_decimal at 0x7fda99608700>(-12345, '#,##0.##;-#', locale='en_US')
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal

tests/test_numbers.py:44: AssertionError
________________ NumberParsingTestCase.test_can_parse_decimals _________________

self = <tests.test_numbers.NumberParsingTestCase testMethod=test_can_parse_decimals>

    def test_can_parse_decimals(self):
>       assert decimal.Decimal('1099.98') == numbers.parse_decimal('1,099.98', locale='en_US')
E       AssertionError: assert Decimal('1099.98') == None
E        +  where Decimal('1099.98') = <class 'decimal.Decimal'>('1099.98')
E        +    where <class 'decimal.Decimal'> = decimal.Decimal
E        +  and   None = <function parse_decimal at 0x7fda99608c10>('1,099.98', locale='en_US')
E        +    where <function parse_decimal at 0x7fda99608c10> = numbers.parse_decimal

tests/test_numbers.py:190: AssertionError
_____________ NumberParsingTestCase.test_parse_decimal_strict_mode _____________

self = <tests.test_numbers.NumberParsingTestCase testMethod=test_parse_decimal_strict_mode>

    def test_parse_decimal_strict_mode(self):
        # Numbers with a misplaced grouping symbol should be rejected
>       with pytest.raises(numbers.NumberFormatError) as info:
E       Failed: DID NOT RAISE <class 'babel.numbers.NumberFormatError'>

tests/test_numbers.py:200: Failed
_____________________________ test_list_currencies _____________________________

    def test_list_currencies():
>       assert isinstance(list_currencies(), set)
E       assert False
E        +  where False = isinstance(None, set)
E        +    where None = list_currencies()

tests/test_numbers.py:241: AssertionError
____________________________ test_validate_currency ____________________________

    def test_validate_currency():
        validate_currency('EUR')
    
>       with pytest.raises(UnknownCurrencyError) as excinfo:
E       Failed: DID NOT RAISE <class 'babel.numbers.UnknownCurrencyError'>

tests/test_numbers.py:259: Failed
_______________________________ test_is_currency _______________________________

    def test_is_currency():
>       assert is_currency('EUR')
E       AssertionError: assert None
E        +  where None = is_currency('EUR')

tests/test_numbers.py:265: AssertionError
___________________________ test_normalize_currency ____________________________

    def test_normalize_currency():
>       assert normalize_currency('EUR') == 'EUR'
E       AssertionError: assert None == 'EUR'
E        +  where None = normalize_currency('EUR')

tests/test_numbers.py:277: AssertionError
____________________________ test_get_currency_name ____________________________

    def test_get_currency_name():
>       assert numbers.get_currency_name('USD', locale='en_US') == 'US Dollar'
E       AssertionError: assert None == 'US Dollar'
E        +  where None = <function get_currency_name at 0x7fda9a50add0>('USD', locale='en_US')
E        +    where <function get_currency_name at 0x7fda9a50add0> = numbers.get_currency_name

tests/test_numbers.py:289: AssertionError
___________________________ test_get_currency_symbol ___________________________

    def test_get_currency_symbol():
>       assert numbers.get_currency_symbol('USD', 'en_US') == '$'
E       AssertionError: assert None == '$'
E        +  where None = <function get_currency_symbol at 0x7fda9a50aa70>('USD', 'en_US')
E        +    where <function get_currency_symbol at 0x7fda9a50aa70> = numbers.get_currency_symbol

tests/test_numbers.py:294: AssertionError
_________________________ test_get_currency_precision __________________________

    def test_get_currency_precision():
>       assert get_currency_precision('EUR') == 2
E       AssertionError: assert None == 2
E        +  where None = get_currency_precision('EUR')

tests/test_numbers.py:298: AssertionError
________________________ test_get_currency_unit_pattern ________________________

    def test_get_currency_unit_pattern():
>       assert get_currency_unit_pattern('USD', locale='en_US') == '{0} {1}'
E       AssertionError: assert None == '{0} {1}'
E        +  where None = get_currency_unit_pattern('USD', locale='en_US')

tests/test_numbers.py:303: AssertionError
________________________ test_get_territory_currencies _________________________

    def test_get_territory_currencies():
>       assert numbers.get_territory_currencies('AT', date(1995, 1, 1)) == ['ATS']
E       AssertionError: assert None == ['ATS']
E        +  where None = <function get_territory_currencies at 0x7fda99608160>('AT', datetime.date(1995, 1, 1))
E        +    where <function get_territory_currencies at 0x7fda99608160> = numbers.get_territory_currencies
E        +    and   datetime.date(1995, 1, 1) = date(1995, 1, 1)

tests/test_numbers.py:314: AssertionError
___________________________ test_get_decimal_symbol ____________________________

    def test_get_decimal_symbol():
>       assert numbers.get_decimal_symbol('en_US') == '.'
E       AssertionError: assert None == '.'
E        +  where None = <function get_decimal_symbol at 0x7fda996081f0>('en_US')
E        +    where <function get_decimal_symbol at 0x7fda996081f0> = numbers.get_decimal_symbol

tests/test_numbers.py:339: AssertionError
__________________________ test_get_plus_sign_symbol ___________________________

    def test_get_plus_sign_symbol():
>       assert numbers.get_plus_sign_symbol('en_US') == '+'
E       AssertionError: assert None == '+'
E        +  where None = <function get_plus_sign_symbol at 0x7fda99608280>('en_US')
E        +    where <function get_plus_sign_symbol at 0x7fda99608280> = numbers.get_plus_sign_symbol

tests/test_numbers.py:350: AssertionError
__________________________ test_get_minus_sign_symbol __________________________

    def test_get_minus_sign_symbol():
>       assert numbers.get_minus_sign_symbol('en_US') == '-'
E       AssertionError: assert None == '-'
E        +  where None = <function get_minus_sign_symbol at 0x7fda99608310>('en_US')
E        +    where <function get_minus_sign_symbol at 0x7fda99608310> = numbers.get_minus_sign_symbol

tests/test_numbers.py:360: AssertionError
_________________________ test_get_exponential_symbol __________________________

    def test_get_exponential_symbol():
>       assert numbers.get_exponential_symbol('en_US') == 'E'
E       AssertionError: assert None == 'E'
E        +  where None = <function get_exponential_symbol at 0x7fda996083a0>('en_US')
E        +    where <function get_exponential_symbol at 0x7fda996083a0> = numbers.get_exponential_symbol

tests/test_numbers.py:371: AssertionError
____________________________ test_get_group_symbol _____________________________

    def test_get_group_symbol():
>       assert numbers.get_group_symbol('en_US') == ','
E       AssertionError: assert None == ','
E        +  where None = <function get_group_symbol at 0x7fda99608430>('en_US')
E        +    where <function get_group_symbol at 0x7fda99608430> = numbers.get_group_symbol

tests/test_numbers.py:382: AssertionError
___________________________ test_get_infinity_symbol ___________________________

    def test_get_infinity_symbol():
>       assert numbers.get_infinity_symbol('en_US') == '∞'
E       AssertionError: assert None == '∞'
E        +  where None = <function get_infinity_symbol at 0x7fda996084c0>('en_US')
E        +    where <function get_infinity_symbol at 0x7fda996084c0> = numbers.get_infinity_symbol

tests/test_numbers.py:392: AssertionError
____________________________ test_decimal_precision ____________________________

    def test_decimal_precision():
>       assert get_decimal_precision(decimal.Decimal('0.110')) == 2
E       AssertionError: assert None == 2
E        +  where None = get_decimal_precision(Decimal('0.110'))
E        +    where Decimal('0.110') = <class 'decimal.Decimal'>('0.110')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:399: AssertionError
_____________________________ test_format_decimal ______________________________

    def test_format_decimal():
>       assert numbers.format_decimal(1099, locale='en_US') == '1,099'
E       AssertionError: assert None == '1,099'
E        +  where None = <function format_decimal at 0x7fda99608700>(1099, locale='en_US')
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal

tests/test_numbers.py:405: AssertionError
_________________ test_format_decimal_precision[10000-10,000] __________________

input_value = '10000', expected_value = '10,000'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '10,000'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('10000'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('10000') = <class 'decimal.Decimal'>('10000')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
______________________ test_format_decimal_precision[1-1] ______________________

input_value = '1', expected_value = '1'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('1'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('1') = <class 'decimal.Decimal'>('1')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
_____________________ test_format_decimal_precision[1.0-1] _____________________

input_value = '1.0', expected_value = '1'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('1.0'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('1.0') = <class 'decimal.Decimal'>('1.0')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
____________________ test_format_decimal_precision[1.1-1.1] ____________________

input_value = '1.1', expected_value = '1.1'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.1'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('1.1'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('1.1') = <class 'decimal.Decimal'>('1.1')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
___________________ test_format_decimal_precision[1.11-1.11] ___________________

input_value = '1.11', expected_value = '1.11'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.11'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('1.11'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('1.11') = <class 'decimal.Decimal'>('1.11')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
__________________ test_format_decimal_precision[1.110-1.11] ___________________

input_value = '1.110', expected_value = '1.11'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.11'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('1.110'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('1.110') = <class 'decimal.Decimal'>('1.110')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
__________________ test_format_decimal_precision[1.001-1.001] __________________

input_value = '1.001', expected_value = '1.001'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.001'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('1.001'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('1.001') = <class 'decimal.Decimal'>('1.001')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
_________________ test_format_decimal_precision[1.00100-1.001] _________________

input_value = '1.00100', expected_value = '1.001'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.001'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('1.00100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('1.00100') = <class 'decimal.Decimal'>('1.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
________________ test_format_decimal_precision[01.00100-1.001] _________________

input_value = '01.00100', expected_value = '1.001'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.001'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('1.00100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('1.00100') = <class 'decimal.Decimal'>('01.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
_______________ test_format_decimal_precision[101.00100-101.001] _______________

input_value = '101.00100', expected_value = '101.001'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '101.001'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('101.00100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('101.00100') = <class 'decimal.Decimal'>('101.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
____________________ test_format_decimal_precision[00000-0] ____________________

input_value = '00000', expected_value = '0'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('0'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('0') = <class 'decimal.Decimal'>('00000')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
______________________ test_format_decimal_precision[0-0] ______________________

input_value = '0', expected_value = '0'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('0'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('0') = <class 'decimal.Decimal'>('0')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
_____________________ test_format_decimal_precision[0.0-0] _____________________

input_value = '0.0', expected_value = '0'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('0.0'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('0.0') = <class 'decimal.Decimal'>('0.0')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
____________________ test_format_decimal_precision[0.1-0.1] ____________________

input_value = '0.1', expected_value = '0.1'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0.1'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('0.1'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('0.1') = <class 'decimal.Decimal'>('0.1')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
___________________ test_format_decimal_precision[0.11-0.11] ___________________

input_value = '0.11', expected_value = '0.11'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0.11'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('0.11'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('0.11') = <class 'decimal.Decimal'>('0.11')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
__________________ test_format_decimal_precision[0.110-0.11] ___________________

input_value = '0.110', expected_value = '0.11'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0.11'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('0.110'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('0.110') = <class 'decimal.Decimal'>('0.110')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
__________________ test_format_decimal_precision[0.001-0.001] __________________

input_value = '0.001', expected_value = '0.001'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0.001'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('0.001'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('0.001') = <class 'decimal.Decimal'>('0.001')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
_________________ test_format_decimal_precision[0.00100-0.001] _________________

input_value = '0.00100', expected_value = '0.001'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0.001'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('0.00100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('0.00100') = <class 'decimal.Decimal'>('0.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
________________ test_format_decimal_precision[00.00100-0.001] _________________

input_value = '00.00100', expected_value = '0.001'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0.001'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('0.00100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('0.00100') = <class 'decimal.Decimal'>('00.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
________________ test_format_decimal_precision[000.00100-0.001] ________________

input_value = '000.00100', expected_value = '0.001'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '10,000'),
        ('1', '1'),
        ('1.0', '1'),
        ('1.1', '1.1'),
        ('1.11', '1.11'),
        ('1.110', '1.11'),
        ('1.001', '1.001'),
        ('1.00100', '1.001'),
        ('01.00100', '1.001'),
        ('101.00100', '101.001'),
        ('00000', '0'),
        ('0', '0'),
        ('0.0', '0'),
        ('0.1', '0.1'),
        ('0.11', '0.11'),
        ('0.110', '0.11'),
        ('0.001', '0.001'),
        ('0.00100', '0.001'),
        ('00.00100', '0.001'),
        ('000.00100', '0.001'),
    ])
    def test_format_decimal_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_decimal(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0.001'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('0.00100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('0.00100') = <class 'decimal.Decimal'>('000.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:449: AssertionError
_______________________ test_format_decimal_quantization _______________________

    def test_format_decimal_quantization():
        # Test all locales.
>       for locale_code in localedata.locale_identifiers():
E       TypeError: 'NoneType' object is not iterable

tests/test_numbers.py:455: TypeError
_____________________________ test_format_currency _____________________________

    def test_format_currency():
>       assert (numbers.format_currency(1099.98, 'USD', locale='en_US')
                == '$1,099.98')
E       AssertionError: assert None == '$1,099.98'
E        +  where None = <function format_currency at 0x7fda996088b0>(1099.98, 'USD', locale='en_US')
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency

tests/test_numbers.py:461: AssertionError
_______________________ test_format_currency_format_type _______________________

    def test_format_currency_format_type():
>       assert (numbers.format_currency(1099.98, 'USD', locale='en_US',
                                        format_type="standard")
                == '$1,099.98')
E       AssertionError: assert None == '$1,099.98'
E        +  where None = <function format_currency at 0x7fda996088b0>(1099.98, 'USD', locale='en_US', format_type='standard')
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency

tests/test_numbers.py:490: AssertionError
_________________________ test_format_compact_currency _________________________

    def test_format_compact_currency():
>       assert numbers.format_compact_currency(1, 'USD', locale='en_US', format_type="short") == '$1'
E       AssertionError: assert None == '$1'
E        +  where None = <function format_compact_currency at 0x7fda99608940>(1, 'USD', locale='en_US', format_type='short')
E        +    where <function format_compact_currency at 0x7fda99608940> = numbers.format_compact_currency

tests/test_numbers.py:522: AssertionError
_______________ test_format_compact_currency_invalid_format_type _______________

    def test_format_compact_currency_invalid_format_type():
>       with pytest.raises(numbers.UnknownCurrencyFormatError):
E       Failed: DID NOT RAISE <class 'babel.numbers.UnknownCurrencyFormatError'>

tests/test_numbers.py:539: Failed
_______________ test_format_currency_precision[10000-$10,000.00] _______________

input_value = '10000', expected_value = '$10,000.00'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$10,000.00'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('10000'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('10000') = <class 'decimal.Decimal'>('10000')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
___________________ test_format_currency_precision[1-$1.00] ____________________

input_value = '1', expected_value = '$1.00'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$1.00'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('1'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('1') = <class 'decimal.Decimal'>('1')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
__________________ test_format_currency_precision[1.0-$1.00] ___________________

input_value = '1.0', expected_value = '$1.00'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$1.00'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('1.0'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('1.0') = <class 'decimal.Decimal'>('1.0')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
__________________ test_format_currency_precision[1.1-$1.10] ___________________

input_value = '1.1', expected_value = '$1.10'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$1.10'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('1.1'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('1.1') = <class 'decimal.Decimal'>('1.1')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
__________________ test_format_currency_precision[1.11-$1.11] __________________

input_value = '1.11', expected_value = '$1.11'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$1.11'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('1.11'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('1.11') = <class 'decimal.Decimal'>('1.11')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
_________________ test_format_currency_precision[1.110-$1.11] __________________

input_value = '1.110', expected_value = '$1.11'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$1.11'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('1.110'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('1.110') = <class 'decimal.Decimal'>('1.110')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
_________________ test_format_currency_precision[1.001-$1.001] _________________

input_value = '1.001', expected_value = '$1.001'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$1.001'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('1.001'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('1.001') = <class 'decimal.Decimal'>('1.001')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
________________ test_format_currency_precision[1.00100-$1.001] ________________

input_value = '1.00100', expected_value = '$1.001'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$1.001'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('1.00100'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('1.00100') = <class 'decimal.Decimal'>('1.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
_______________ test_format_currency_precision[01.00100-$1.001] ________________

input_value = '01.00100', expected_value = '$1.001'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$1.001'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('1.00100'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('1.00100') = <class 'decimal.Decimal'>('01.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
______________ test_format_currency_precision[101.00100-$101.001] ______________

input_value = '101.00100', expected_value = '$101.001'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$101.001'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('101.00100'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('101.00100') = <class 'decimal.Decimal'>('101.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
_________________ test_format_currency_precision[00000-$0.00] __________________

input_value = '00000', expected_value = '$0.00'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$0.00'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('0'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('0') = <class 'decimal.Decimal'>('00000')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
___________________ test_format_currency_precision[0-$0.00] ____________________

input_value = '0', expected_value = '$0.00'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$0.00'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('0'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('0') = <class 'decimal.Decimal'>('0')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
__________________ test_format_currency_precision[0.0-$0.00] ___________________

input_value = '0.0', expected_value = '$0.00'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$0.00'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('0.0'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('0.0') = <class 'decimal.Decimal'>('0.0')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
__________________ test_format_currency_precision[0.1-$0.10] ___________________

input_value = '0.1', expected_value = '$0.10'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$0.10'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('0.1'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('0.1') = <class 'decimal.Decimal'>('0.1')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
__________________ test_format_currency_precision[0.11-$0.11] __________________

input_value = '0.11', expected_value = '$0.11'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$0.11'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('0.11'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('0.11') = <class 'decimal.Decimal'>('0.11')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
_________________ test_format_currency_precision[0.110-$0.11] __________________

input_value = '0.110', expected_value = '$0.11'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$0.11'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('0.110'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('0.110') = <class 'decimal.Decimal'>('0.110')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
_________________ test_format_currency_precision[0.001-$0.001] _________________

input_value = '0.001', expected_value = '$0.001'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$0.001'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('0.001'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('0.001') = <class 'decimal.Decimal'>('0.001')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
________________ test_format_currency_precision[0.00100-$0.001] ________________

input_value = '0.00100', expected_value = '$0.001'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$0.001'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('0.00100'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('0.00100') = <class 'decimal.Decimal'>('0.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
_______________ test_format_currency_precision[00.00100-$0.001] ________________

input_value = '00.00100', expected_value = '$0.001'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$0.001'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('0.00100'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('0.00100') = <class 'decimal.Decimal'>('00.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
_______________ test_format_currency_precision[000.00100-$0.001] _______________

input_value = '000.00100', expected_value = '$0.001'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '$10,000.00'),
        ('1', '$1.00'),
        ('1.0', '$1.00'),
        ('1.1', '$1.10'),
        ('1.11', '$1.11'),
        ('1.110', '$1.11'),
        ('1.001', '$1.001'),
        ('1.00100', '$1.001'),
        ('01.00100', '$1.001'),
        ('101.00100', '$101.001'),
        ('00000', '$0.00'),
        ('0', '$0.00'),
        ('0.0', '$0.00'),
        ('0.1', '$0.10'),
        ('0.11', '$0.11'),
        ('0.110', '$0.11'),
        ('0.001', '$0.001'),
        ('0.00100', '$0.001'),
        ('00.00100', '$0.001'),
        ('000.00100', '$0.001'),
    ])
    def test_format_currency_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_currency(
            decimal.Decimal(input_value),
            currency='USD',
            locale='en_US',
            decimal_quantization=False,
        ) == expected_value
E       AssertionError: assert None == '$0.001'
E        +  where None = <function format_currency at 0x7fda996088b0>(Decimal('0.00100'), currency='USD', locale='en_US', decimal_quantization=False)
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency
E        +    and   Decimal('0.00100') = <class 'decimal.Decimal'>('000.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:567: AssertionError
______________________ test_format_currency_quantization _______________________

    def test_format_currency_quantization():
        # Test all locales.
>       for locale_code in localedata.locale_identifiers():
E       TypeError: 'NoneType' object is not iterable

tests/test_numbers.py:577: TypeError
____________________ test_format_currency_long_display_name ____________________

    def test_format_currency_long_display_name():
>       assert (numbers.format_currency(1099.98, 'USD', locale='en_US', format_type='name')
                == '1,099.98 US dollars')
E       AssertionError: assert None == '1,099.98 US dollars'
E        +  where None = <function format_currency at 0x7fda996088b0>(1099.98, 'USD', locale='en_US', format_type='name')
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency

tests/test_numbers.py:583: AssertionError
__________________ test_format_currency_long_display_name_all __________________

    def test_format_currency_long_display_name_all():
>       for locale_code in localedata.locale_identifiers():
E       TypeError: 'NoneType' object is not iterable

tests/test_numbers.py:615: TypeError
_____________ test_format_currency_long_display_name_custom_format _____________

    def test_format_currency_long_display_name_custom_format():
>       assert (numbers.format_currency(1099.98, 'USD', locale='en_US',
                                        format_type='name', format='##0')
                == '1099.98 US dollars')
E       AssertionError: assert None == '1099.98 US dollars'
E        +  where None = <function format_currency at 0x7fda996088b0>(1099.98, 'USD', locale='en_US', format_type='name', format='##0')
E        +    where <function format_currency at 0x7fda996088b0> = numbers.format_currency

tests/test_numbers.py:623: AssertionError
_____________________________ test_format_percent ______________________________

    def test_format_percent():
>       assert numbers.format_percent(0.34, locale='en_US') == '34%'
E       AssertionError: assert None == '34%'
E        +  where None = <function format_percent at 0x7fda996089d0>(0.34, locale='en_US')
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent

tests/test_numbers.py:633: AssertionError
__________________ test_format_percent_precision[100-10,000%] __________________

input_value = '100', expected_value = '10,000%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '10,000%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('100') = <class 'decimal.Decimal'>('100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
___________________ test_format_percent_precision[0.01-1%0] ____________________

input_value = '0.01', expected_value = '1%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.01'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.01') = <class 'decimal.Decimal'>('0.01')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
___________________ test_format_percent_precision[0.010-1%] ____________________

input_value = '0.010', expected_value = '1%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.010'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.010') = <class 'decimal.Decimal'>('0.010')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
__________________ test_format_percent_precision[0.011-1.1%0] __________________

input_value = '0.011', expected_value = '1.1%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.1%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.011'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.011') = <class 'decimal.Decimal'>('0.011')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
_________________ test_format_percent_precision[0.0111-1.11%] __________________

input_value = '0.0111', expected_value = '1.11%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.11%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.0111'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.0111') = <class 'decimal.Decimal'>('0.0111')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
_________________ test_format_percent_precision[0.01110-1.11%] _________________

input_value = '0.01110', expected_value = '1.11%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.11%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.01110'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.01110') = <class 'decimal.Decimal'>('0.01110')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
________________ test_format_percent_precision[0.01001-1.001%] _________________

input_value = '0.01001', expected_value = '1.001%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.001%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.01001'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.01001') = <class 'decimal.Decimal'>('0.01001')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
_______________ test_format_percent_precision[0.0100100-1.001%] ________________

input_value = '0.0100100', expected_value = '1.001%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.001%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.0100100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.0100100') = <class 'decimal.Decimal'>('0.0100100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
_____________ test_format_percent_precision[0.010100100-1.01001%] ______________

input_value = '0.010100100', expected_value = '1.01001%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.01001%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.010100100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.010100100') = <class 'decimal.Decimal'>('0.010100100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
__________________ test_format_percent_precision[0.000000-0%] __________________

input_value = '0.000000', expected_value = '0%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.000000'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.000000') = <class 'decimal.Decimal'>('0.000000')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
_____________________ test_format_percent_precision[0-0%] ______________________

input_value = '0', expected_value = '0%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0') = <class 'decimal.Decimal'>('0')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
____________________ test_format_percent_precision[0.00-0%] ____________________

input_value = '0.00', expected_value = '0%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.00'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.00') = <class 'decimal.Decimal'>('0.00')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
___________________ test_format_percent_precision[0.01-1%1] ____________________

input_value = '0.01', expected_value = '1%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.01'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.01') = <class 'decimal.Decimal'>('0.01')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
__________________ test_format_percent_precision[0.011-1.1%1] __________________

input_value = '0.011', expected_value = '1.1%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.1%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.011'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.011') = <class 'decimal.Decimal'>('0.011')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
__________________ test_format_percent_precision[0.0110-1.1%] __________________

input_value = '0.0110', expected_value = '1.1%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.1%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.0110'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.0110') = <class 'decimal.Decimal'>('0.0110')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
_________________ test_format_percent_precision[0.0001-0.01%] __________________

input_value = '0.0001', expected_value = '0.01%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0.01%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.0001'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.0001') = <class 'decimal.Decimal'>('0.0001')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
________________ test_format_percent_precision[0.000100-0.01%] _________________

input_value = '0.000100', expected_value = '0.01%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0.01%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.000100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.000100') = <class 'decimal.Decimal'>('0.000100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
_______________ test_format_percent_precision[0.0000100-0.001%] ________________

input_value = '0.0000100', expected_value = '0.001%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0.001%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.0000100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.0000100') = <class 'decimal.Decimal'>('0.0000100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
______________ test_format_percent_precision[0.00000100-0.0001%] _______________

input_value = '0.00000100', expected_value = '0.0001%'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('100', '10,000%'),
        ('0.01', '1%'),
        ('0.010', '1%'),
        ('0.011', '1.1%'),
        ('0.0111', '1.11%'),
        ('0.01110', '1.11%'),
        ('0.01001', '1.001%'),
        ('0.0100100', '1.001%'),
        ('0.010100100', '1.01001%'),
        ('0.000000', '0%'),
        ('0', '0%'),
        ('0.00', '0%'),
        ('0.01', '1%'),
        ('0.011', '1.1%'),
        ('0.0110', '1.1%'),
        ('0.0001', '0.01%'),
        ('0.000100', '0.01%'),
        ('0.0000100', '0.001%'),
        ('0.00000100', '0.0001%'),
    ])
    def test_format_percent_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_percent(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0.0001%'
E        +  where None = <function format_percent at 0x7fda996089d0>(Decimal('0.00000100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_percent at 0x7fda996089d0> = numbers.format_percent
E        +    and   Decimal('0.00000100') = <class 'decimal.Decimal'>('0.00000100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:670: AssertionError
_______________________ test_format_percent_quantization _______________________

    def test_format_percent_quantization():
        # Test all locales.
>       for locale_code in localedata.locale_identifiers():
E       TypeError: 'NoneType' object is not iterable

tests/test_numbers.py:676: TypeError
____________________________ test_format_scientific ____________________________

    def test_format_scientific():
>       assert numbers.format_scientific(10000, locale='en_US') == '1E4'
E       AssertionError: assert None == '1E4'
E        +  where None = <function format_scientific at 0x7fda99608a60>(10000, locale='en_US')
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific

tests/test_numbers.py:682: AssertionError
________________________ test_default_scientific_format ________________________

    def test_default_scientific_format():
        """ Check the scientific format method auto-correct the rendering pattern
        in case of a missing fractional part.
        """
>       assert numbers.format_scientific(12345, locale='en_US') == '1.2345E4'
E       AssertionError: assert None == '1.2345E4'
E        +  where None = <function format_scientific at 0x7fda99608a60>(12345, locale='en_US')
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific

tests/test_numbers.py:699: AssertionError
_________________ test_format_scientific_precision[10000-1E4] __________________

input_value = '10000', expected_value = '1E4'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1E4'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('10000'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('10000') = <class 'decimal.Decimal'>('10000')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
___________________ test_format_scientific_precision[1-1E0] ____________________

input_value = '1', expected_value = '1E0'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1E0'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('1'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('1') = <class 'decimal.Decimal'>('1')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
__________________ test_format_scientific_precision[1.0-1E0] ___________________

input_value = '1.0', expected_value = '1E0'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1E0'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('1.0'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('1.0') = <class 'decimal.Decimal'>('1.0')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
_________________ test_format_scientific_precision[1.1-1.1E0] __________________

input_value = '1.1', expected_value = '1.1E0'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.1E0'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('1.1'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('1.1') = <class 'decimal.Decimal'>('1.1')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
________________ test_format_scientific_precision[1.11-1.11E0] _________________

input_value = '1.11', expected_value = '1.11E0'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.11E0'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('1.11'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('1.11') = <class 'decimal.Decimal'>('1.11')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
________________ test_format_scientific_precision[1.110-1.11E0] ________________

input_value = '1.110', expected_value = '1.11E0'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.11E0'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('1.110'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('1.110') = <class 'decimal.Decimal'>('1.110')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
_______________ test_format_scientific_precision[1.001-1.001E0] ________________

input_value = '1.001', expected_value = '1.001E0'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.001E0'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('1.001'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('1.001') = <class 'decimal.Decimal'>('1.001')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
______________ test_format_scientific_precision[1.00100-1.001E0] _______________

input_value = '1.00100', expected_value = '1.001E0'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.001E0'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('1.00100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('1.00100') = <class 'decimal.Decimal'>('1.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
______________ test_format_scientific_precision[01.00100-1.001E0] ______________

input_value = '01.00100', expected_value = '1.001E0'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.001E0'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('1.00100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('1.00100') = <class 'decimal.Decimal'>('01.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
____________ test_format_scientific_precision[101.00100-1.01001E2] _____________

input_value = '101.00100', expected_value = '1.01001E2'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.01001E2'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('101.00100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('101.00100') = <class 'decimal.Decimal'>('101.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
_________________ test_format_scientific_precision[00000-0E0] __________________

input_value = '00000', expected_value = '0E0'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0E0'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('0'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('0') = <class 'decimal.Decimal'>('00000')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
___________________ test_format_scientific_precision[0-0E0] ____________________

input_value = '0', expected_value = '0E0'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0E0'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('0'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('0') = <class 'decimal.Decimal'>('0')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
__________________ test_format_scientific_precision[0.0-0E0] ___________________

input_value = '0.0', expected_value = '0E0'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '0E0'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('0.0'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('0.0') = <class 'decimal.Decimal'>('0.0')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
__________________ test_format_scientific_precision[0.1-1E-1] __________________

input_value = '0.1', expected_value = '1E-1'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1E-1'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('0.1'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('0.1') = <class 'decimal.Decimal'>('0.1')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
________________ test_format_scientific_precision[0.11-1.1E-1] _________________

input_value = '0.11', expected_value = '1.1E-1'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.1E-1'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('0.11'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('0.11') = <class 'decimal.Decimal'>('0.11')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
________________ test_format_scientific_precision[0.110-1.1E-1] ________________

input_value = '0.110', expected_value = '1.1E-1'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1.1E-1'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('0.110'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('0.110') = <class 'decimal.Decimal'>('0.110')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
_________________ test_format_scientific_precision[0.001-1E-3] _________________

input_value = '0.001', expected_value = '1E-3'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1E-3'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('0.001'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('0.001') = <class 'decimal.Decimal'>('0.001')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
________________ test_format_scientific_precision[0.00100-1E-3] ________________

input_value = '0.00100', expected_value = '1E-3'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1E-3'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('0.00100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('0.00100') = <class 'decimal.Decimal'>('0.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
_______________ test_format_scientific_precision[00.00100-1E-3] ________________

input_value = '00.00100', expected_value = '1E-3'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1E-3'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('0.00100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('0.00100') = <class 'decimal.Decimal'>('00.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
_______________ test_format_scientific_precision[000.00100-1E-3] _______________

input_value = '000.00100', expected_value = '1E-3'

    @pytest.mark.parametrize('input_value, expected_value', [
        ('10000', '1E4'),
        ('1', '1E0'),
        ('1.0', '1E0'),
        ('1.1', '1.1E0'),
        ('1.11', '1.11E0'),
        ('1.110', '1.11E0'),
        ('1.001', '1.001E0'),
        ('1.00100', '1.001E0'),
        ('01.00100', '1.001E0'),
        ('101.00100', '1.01001E2'),
        ('00000', '0E0'),
        ('0', '0E0'),
        ('0.0', '0E0'),
        ('0.1', '1E-1'),
        ('0.11', '1.1E-1'),
        ('0.110', '1.1E-1'),
        ('0.001', '1E-3'),
        ('0.00100', '1E-3'),
        ('00.00100', '1E-3'),
        ('000.00100', '1E-3'),
    ])
    def test_format_scientific_precision(input_value, expected_value):
        # Test precision conservation.
>       assert numbers.format_scientific(
            decimal.Decimal(input_value), locale='en_US', decimal_quantization=False) == expected_value
E       AssertionError: assert None == '1E-3'
E        +  where None = <function format_scientific at 0x7fda99608a60>(Decimal('0.00100'), locale='en_US', decimal_quantization=False)
E        +    where <function format_scientific at 0x7fda99608a60> = numbers.format_scientific
E        +    and   Decimal('0.00100') = <class 'decimal.Decimal'>('000.00100')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:729: AssertionError
_____________________ test_format_scientific_quantization ______________________

    def test_format_scientific_quantization():
        # Test all locales.
>       for locale_code in localedata.locale_identifiers():
E       TypeError: 'NoneType' object is not iterable

tests/test_numbers.py:735: TypeError
______________________________ test_parse_number _______________________________

    def test_parse_number():
>       assert numbers.parse_number('1,099', locale='en_US') == 1099
E       AssertionError: assert None == 1099
E        +  where None = <function parse_number at 0x7fda99608af0>('1,099', locale='en_US')
E        +    where <function parse_number at 0x7fda99608af0> = numbers.parse_number

tests/test_numbers.py:741: AssertionError
______________________________ test_parse_decimal ______________________________

    def test_parse_decimal():
>       assert (numbers.parse_decimal('1,099.98', locale='en_US')
                == decimal.Decimal('1099.98'))
E       AssertionError: assert None == Decimal('1099.98')
E        +  where None = <function parse_decimal at 0x7fda99608c10>('1,099.98', locale='en_US')
E        +    where <function parse_decimal at 0x7fda99608c10> = numbers.parse_decimal
E        +  and   Decimal('1099.98') = <class 'decimal.Decimal'>('1099.98')
E        +    where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:753: AssertionError
_____________________________ test_parse_grouping ______________________________

    def test_parse_grouping():
>       assert numbers.parse_grouping('##') == (1000, 1000)
E       AssertionError: assert None == (1000, 1000)
E        +  where None = <function parse_grouping at 0x7fda99608d30>('##')
E        +    where <function parse_grouping at 0x7fda99608d30> = numbers.parse_grouping

tests/test_numbers.py:763: AssertionError
______________________________ test_parse_pattern ______________________________

    def test_parse_pattern():
    
        # Original pattern is preserved
        np = numbers.parse_pattern('¤#,##0.00')
>       assert np.pattern == '¤#,##0.00'
E       AttributeError: 'NoneType' object has no attribute 'pattern'

tests/test_numbers.py:772: AttributeError
_________________________ test_parse_pattern_negative __________________________

    def test_parse_pattern_negative():
    
        # No negative format specified
        np = numbers.parse_pattern('¤#,##0.00')
>       assert np.prefix == ('¤', '-¤')
E       AttributeError: 'NoneType' object has no attribute 'prefix'

tests/test_numbers.py:791: AttributeError
___________________________ test_numberpattern_repr ____________________________

    def test_numberpattern_repr():
        """repr() outputs the pattern string"""
    
        # This implementation looks a bit funny, but that's cause strings are
        # repr'd differently in Python 2 vs 3 and this test runs under both.
        format = '¤#,##0.00;(¤#,##0.00)'
        np = numbers.parse_pattern(format)
>       assert repr(format) in repr(np)
E       assert "'¤#,##0.00;(¤#,##0.00)'" in 'None'
E        +  where "'¤#,##0.00;(¤#,##0.00)'" = repr('¤#,##0.00;(¤#,##0.00)')
E        +  and   'None' = repr(None)

tests/test_numbers.py:812: AssertionError
__________________________ test_parse_static_pattern ___________________________

    def test_parse_static_pattern():
>       assert numbers.parse_pattern('Kun')  # in the So locale in CLDR 30
E       AssertionError: assert None
E        +  where None = <function parse_pattern at 0x7fda99608dc0>('Kun')
E        +    where <function parse_pattern at 0x7fda99608dc0> = numbers.parse_pattern

tests/test_numbers.py:816: AssertionError
______________________ test_parse_decimal_nbsp_heuristics ______________________

    def test_parse_decimal_nbsp_heuristics():
        # Re https://github.com/python-babel/babel/issues/637 –
        #    for locales (of which there are many) that use U+00A0 as the group
        #    separator in numbers, it's reasonable to assume that input strings
        #    with plain spaces actually should have U+00A0s instead.
        #    This heuristic is only applied when strict=False.
        n = decimal.Decimal("12345.123")
>       assert numbers.parse_decimal("12 345.123", locale="fi") == n
E       AssertionError: assert None == Decimal('12345.123')
E        +  where None = <function parse_decimal at 0x7fda99608c10>('12 345.123', locale='fi')
E        +    where <function parse_decimal at 0x7fda99608c10> = numbers.parse_decimal

tests/test_numbers.py:827: AssertionError
___________________ test_very_small_decimal_no_quantization ____________________

    def test_very_small_decimal_no_quantization():
>       assert numbers.format_decimal(decimal.Decimal('1E-7'), locale='en', decimal_quantization=False) == '0.0000001'
E       AssertionError: assert None == '0.0000001'
E        +  where None = <function format_decimal at 0x7fda99608700>(Decimal('1E-7'), locale='en', decimal_quantization=False)
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal
E        +    and   Decimal('1E-7') = <class 'decimal.Decimal'>('1E-7')
E        +      where <class 'decimal.Decimal'> = decimal.Decimal

tests/test_numbers.py:832: AssertionError
________________________ test_single_quotes_in_pattern _________________________

    def test_single_quotes_in_pattern():
>       assert numbers.format_decimal(123, "'@0.#'00'@01'", locale='en') == '@0.#120@01'
E       assert None == '@0.#120@01'
E        +  where None = <function format_decimal at 0x7fda99608700>(123, "'@0.#'00'@01'", locale='en')
E        +    where <function format_decimal at 0x7fda99608700> = numbers.format_decimal

tests/test_numbers.py:836: AssertionError
_______________________________ test_plural_rule _______________________________

    def test_plural_rule():
>       rule = plural.PluralRule({'one': 'n is 1'})

tests/test_plural.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
babel/plural.py:91: in __init__
    ast = _Parser(expr).ast
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <babel.plural._Parser object at 0x7fda9b991e40>, string = 'n is 1'

    def __init__(self, string):
>       self.tokens = tokenize_rule(string)
E       NameError: name 'tokenize_rule' is not defined

babel/plural.py:301: NameError
_________________________ test_plural_rule_operands_i __________________________

    def test_plural_rule_operands_i():
>       rule = plural.PluralRule({'one': 'i is 1'})

tests/test_plural.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
babel/plural.py:91: in __init__
    ast = _Parser(expr).ast
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <babel.plural._Parser object at 0x7fda995dfc40>, string = 'i is 1'

    def __init__(self, string):
>       self.tokens = tokenize_rule(string)
E       NameError: name 'tokenize_rule' is not defined

babel/plural.py:301: NameError
_________________________ test_plural_rule_operands_v __________________________

    def test_plural_rule_operands_v():
>       rule = plural.PluralRule({'one': 'v is 2'})

tests/test_plural.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
babel/plural.py:91: in __init__
    ast = _Parser(expr).ast
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <babel.plural._Parser object at 0x7fda9b5b1b70>, string = 'v is 2'

    def __init__(self, string):
>       self.tokens = tokenize_rule(string)
E       NameError: name 'tokenize_rule' is not defined

babel/plural.py:301: NameError
_________________________ test_plural_rule_operands_w __________________________

    def test_plural_rule_operands_w():
>       rule = plural.PluralRule({'one': 'w is 2'})

tests/test_plural.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
babel/plural.py:91: in __init__
    ast = _Parser(expr).ast
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <babel.plural._Parser object at 0x7fda9a67b640>, string = 'w is 2'

    def __init__(self, string):
>       self.tokens = tokenize_rule(string)
E       NameError: name 'tokenize_rule' is not defined

babel/plural.py:301: NameError
_________________________ test_plural_rule_operands_f __________________________

    def test_plural_rule_operands_f():
>       rule = plural.PluralRule({'one': 'f is 20'})

tests/test_plural.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
babel/plural.py:91: in __init__
    ast = _Parser(expr).ast
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <babel.plural._Parser object at 0x7fda9a2da1d0>, string = 'f is 20'

    def __init__(self, string):
>       self.tokens = tokenize_rule(string)
E       NameError: name 'tokenize_rule' is not defined

babel/plural.py:301: NameError
_________________________ test_plural_rule_operands_t __________________________

    def test_plural_rule_operands_t():
>       rule = plural.PluralRule({'one': 't = 5'})

tests/test_plural.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
babel/plural.py:91: in __init__
    ast = _Parser(expr).ast
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <babel.plural._Parser object at 0x7fda9af0fd00>, string = 't = 5'

    def __init__(self, string):
>       self.tokens = tokenize_rule(string)
E       NameError: name 'tokenize_rule' is not defined

babel/plural.py:301: NameError
_________________________ test_plural_other_is_ignored _________________________

    def test_plural_other_is_ignored():
>       rule = plural.PluralRule({'one': 'n is 1', 'other': '@integer 2'})

tests/test_plural.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
babel/plural.py:91: in __init__
    ast = _Parser(expr).ast
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <babel.plural._Parser object at 0x7fda99eb3430>, string = 'n is 1'

    def __init__(self, string):
>       self.tokens = tokenize_rule(string)
E       NameError: name 'tokenize_rule' is not defined

babel/plural.py:301: NameError
______________________________ test_to_javascript ______________________________

    def test_to_javascript():
>       assert (plural.to_javascript({'one': 'n is 1'})
                == "(function(n) { return (n == 1) ? 'one' : 'other'; })")
E       assert None == "(function(n) { return (n == 1) ? 'one' : 'other'; })"
E        +  where None = <function to_javascript at 0x7fda9a6e79a0>({'one': 'n is 1'})
E        +    where <function to_javascript at 0x7fda9a6e79a0> = plural.to_javascript

tests/test_plural.py:71: AssertionError
________________________________ test_to_python ________________________________

    def test_to_python():
        func = plural.to_python({'one': 'n is 1', 'few': 'n in 2..4'})
>       assert func(1) == 'one'
E       TypeError: 'NoneType' object is not callable

tests/test_plural.py:77: TypeError
_______________________________ test_to_gettext ________________________________

    def test_to_gettext():
>       assert (plural.to_gettext({'one': 'n is 1', 'two': 'n is 2'})
                == 'nplurals=3; plural=((n == 1) ? 0 : (n == 2) ? 1 : 2);')
E       AssertionError: assert None == 'nplurals=3; plural=((n == 1) ? 0 : (n == 2) ? 1 : 2);'
E        +  where None = <function to_gettext at 0x7fda9a6e7f40>({'one': 'n is 1', 'two': 'n is 2'})
E        +    where <function to_gettext at 0x7fda9a6e7f40> = plural.to_gettext

tests/test_plural.py:86: AssertionError
______________________________ test_in_range_list ______________________________

    def test_in_range_list():
>       assert plural.in_range_list(1, [(1, 3)])
E       assert None
E        +  where None = <function in_range_list at 0x7fda9a798040>(1, [(1, 3)])
E        +    where <function in_range_list at 0x7fda9a798040> = plural.in_range_list

tests/test_plural.py:91: AssertionError
____________________________ test_within_range_list ____________________________

    def test_within_range_list():
>       assert plural.within_range_list(1, [(1, 3)])
E       assert None
E        +  where None = <function within_range_list at 0x7fda9a7980d0>(1, [(1, 3)])
E        +    where <function within_range_list at 0x7fda9a7980d0> = plural.within_range_list

tests/test_plural.py:100: AssertionError
_______________________________ test_cldr_modulo _______________________________

    def test_cldr_modulo():
>       assert plural.cldr_modulo(-3, 5) == -3
E       assert None == -3
E        +  where None = <function cldr_modulo at 0x7fda9a798160>(-3, 5)
E        +    where <function cldr_modulo at 0x7fda9a798160> = plural.cldr_modulo

tests/test_plural.py:109: AssertionError
___________________________ test_plural_within_rules ___________________________

    def test_plural_within_rules():
>       p = plural.PluralRule({'one': 'n is 1', 'few': 'n within 2,4,7..9'})

tests/test_plural.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
babel/plural.py:91: in __init__
    ast = _Parser(expr).ast
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <babel.plural._Parser object at 0x7fda9b5b1510>
string = 'n within 2,4,7..9'

    def __init__(self, string):
>       self.tokens = tokenize_rule(string)
E       NameError: name 'tokenize_rule' is not defined

babel/plural.py:301: NameError
________________ test_locales_with_no_plural_rules_have_default ________________

    def test_locales_with_no_plural_rules_have_default():
        from babel import Locale
>       pf = Locale.parse('ii').plural_form
E       AttributeError: 'NoneType' object has no attribute 'plural_form'

tests/test_plural.py:138: AttributeError
_____________________ test_tokenize_well_formed[-tokens0] ______________________

rule_text = '', tokens = []

    @pytest.mark.parametrize('rule_text,tokens', WELL_FORMED_TOKEN_TESTS)
    def test_tokenize_well_formed(rule_text, tokens):
>       assert plural.tokenize_rule(rule_text) == tokens
E       AttributeError: module 'babel.plural' has no attribute 'tokenize_rule'

tests/test_plural.py:187: AttributeError
___________________ test_tokenize_well_formed[n = 1-tokens1] ___________________

rule_text = 'n = 1', tokens = [('value', '1'), ('symbol', '='), ('word', 'n')]

    @pytest.mark.parametrize('rule_text,tokens', WELL_FORMED_TOKEN_TESTS)
    def test_tokenize_well_formed(rule_text, tokens):
>       assert plural.tokenize_rule(rule_text) == tokens
E       AttributeError: module 'babel.plural' has no attribute 'tokenize_rule'

tests/test_plural.py:187: AttributeError
_____________ test_tokenize_well_formed[n = 1 @integer 1-tokens2] ______________

rule_text = 'n = 1 @integer 1'
tokens = [('value', '1'), ('symbol', '='), ('word', 'n')]

    @pytest.mark.parametrize('rule_text,tokens', WELL_FORMED_TOKEN_TESTS)
    def test_tokenize_well_formed(rule_text, tokens):
>       assert plural.tokenize_rule(rule_text) == tokens
E       AttributeError: module 'babel.plural' has no attribute 'tokenize_rule'

tests/test_plural.py:187: AttributeError
__________________ test_tokenize_well_formed[n is 1-tokens3] ___________________

rule_text = 'n is 1', tokens = [('value', '1'), ('word', 'is'), ('word', 'n')]

    @pytest.mark.parametrize('rule_text,tokens', WELL_FORMED_TOKEN_TESTS)
    def test_tokenize_well_formed(rule_text, tokens):
>       assert plural.tokenize_rule(rule_text) == tokens
E       AttributeError: module 'babel.plural' has no attribute 'tokenize_rule'

tests/test_plural.py:187: AttributeError
______________ test_tokenize_well_formed[n % 100 = 3..10-tokens4] ______________

rule_text = 'n % 100 = 3..10'
tokens = [('value', '10'), ('ellipsis', '..'), ('value', '3'), ('symbol', '='), ('value', '100'), ('symbol', '%'), ...]

    @pytest.mark.parametrize('rule_text,tokens', WELL_FORMED_TOKEN_TESTS)
    def test_tokenize_well_formed(rule_text, tokens):
>       assert plural.tokenize_rule(rule_text) == tokens
E       AttributeError: module 'babel.plural' has no attribute 'tokenize_rule'

tests/test_plural.py:187: AttributeError
________________________ test_tokenize_malformed[a = 1] ________________________

rule_text = 'a = 1'

    @pytest.mark.parametrize('rule_text', MALFORMED_TOKEN_TESTS)
    def test_tokenize_malformed(rule_text):
        with pytest.raises(plural.RuleError):
>           plural.tokenize_rule(rule_text)
E           AttributeError: module 'babel.plural' has no attribute 'tokenize_rule'

tests/test_plural.py:198: AttributeError
________________________ test_tokenize_malformed[n ! 2] ________________________

rule_text = 'n ! 2'

    @pytest.mark.parametrize('rule_text', MALFORMED_TOKEN_TESTS)
    def test_tokenize_malformed(rule_text):
        with pytest.raises(plural.RuleError):
>           plural.tokenize_rule(rule_text)
E           AttributeError: module 'babel.plural' has no attribute 'tokenize_rule'

tests/test_plural.py:198: AttributeError
_______________________ TestNextTokenTestCase.test_empty _______________________

self = <tests.test_plural.TestNextTokenTestCase testMethod=test_empty>

    def test_empty(self):
>       assert not plural.test_next_token([], '')
E       AttributeError: module 'babel.plural' has no attribute 'test_next_token'

tests/test_plural.py:204: AttributeError
_____________ TestNextTokenTestCase.test_type_not_ok_and_value_ok ______________

self = <tests.test_plural.TestNextTokenTestCase testMethod=test_type_not_ok_and_value_ok>

    def test_type_not_ok_and_value_ok(self):
>       assert not plural.test_next_token([('abc', 'and')], 'word', 'and')
E       AttributeError: module 'babel.plural' has no attribute 'test_next_token'

tests/test_plural.py:216: AttributeError
_______________ TestNextTokenTestCase.test_type_ok_and_no_value ________________

self = <tests.test_plural.TestNextTokenTestCase testMethod=test_type_ok_and_no_value>

    def test_type_ok_and_no_value(self):
>       assert plural.test_next_token([('word', 'and')], 'word')
E       AttributeError: module 'babel.plural' has no attribute 'test_next_token'

tests/test_plural.py:207: AttributeError
_______________ TestNextTokenTestCase.test_type_ok_and_not_value _______________

self = <tests.test_plural.TestNextTokenTestCase testMethod=test_type_ok_and_not_value>

    def test_type_ok_and_not_value(self):
>       assert not plural.test_next_token([('word', 'and')], 'word', 'or')
E       AttributeError: module 'babel.plural' has no attribute 'test_next_token'

tests/test_plural.py:210: AttributeError
_______________ TestNextTokenTestCase.test_type_ok_and_value_ok ________________

self = <tests.test_plural.TestNextTokenTestCase testMethod=test_type_ok_and_value_ok>

    def test_type_ok_and_value_ok(self):
>       assert plural.test_next_token([('word', 'and')], 'word', 'and')
E       AttributeError: module 'babel.plural' has no attribute 'test_next_token'

tests/test_plural.py:213: AttributeError
______________________ PluralRuleParserTestCase.test_and _______________________

self = <tests.test_plural.PluralRuleParserTestCase testMethod=test_and>

    def setUp(self):
>       self.n = plural.ident_node('n')
E       AttributeError: module 'babel.plural' has no attribute 'ident_node'

tests/test_plural.py:235: AttributeError
__________________ PluralRuleParserTestCase.test_eq_relation ___________________

self = <tests.test_plural.PluralRuleParserTestCase testMethod=test_eq_relation>

    def setUp(self):
>       self.n = plural.ident_node('n')
E       AttributeError: module 'babel.plural' has no attribute 'ident_node'

tests/test_plural.py:235: AttributeError
___________ PluralRuleParserTestCase.test_error_when_unexpected_end ____________

self = <tests.test_plural.PluralRuleParserTestCase testMethod=test_error_when_unexpected_end>

    def setUp(self):
>       self.n = plural.ident_node('n')
E       AttributeError: module 'babel.plural' has no attribute 'ident_node'

tests/test_plural.py:235: AttributeError
_______________ PluralRuleParserTestCase.test_in_range_relation ________________

self = <tests.test_plural.PluralRuleParserTestCase testMethod=test_in_range_relation>

    def setUp(self):
>       self.n = plural.ident_node('n')
E       AttributeError: module 'babel.plural' has no attribute 'ident_node'

tests/test_plural.py:235: AttributeError
_____________________ PluralRuleParserTestCase.test_negate _____________________

self = <tests.test_plural.PluralRuleParserTestCase testMethod=test_negate>

    def setUp(self):
>       self.n = plural.ident_node('n')
E       AttributeError: module 'babel.plural' has no attribute 'ident_node'

tests/test_plural.py:235: AttributeError
_______________________ PluralRuleParserTestCase.test_or _______________________

self = <tests.test_plural.PluralRuleParserTestCase testMethod=test_or>

    def setUp(self):
>       self.n = plural.ident_node('n')
E       AttributeError: module 'babel.plural' has no attribute 'ident_node'

tests/test_plural.py:235: AttributeError
_____________________ PluralRuleParserTestCase.test_or_and _____________________

self = <tests.test_plural.PluralRuleParserTestCase testMethod=test_or_and>

    def setUp(self):
>       self.n = plural.ident_node('n')
E       AttributeError: module 'babel.plural' has no attribute 'ident_node'

tests/test_plural.py:235: AttributeError
_____________________ test_extract_operands[1-1-1-0-0-0-0] _____________________

source = 1, n = 1, i = 1, v = 0, w = 0, f = 0, t = 0

    @pytest.mark.parametrize('source,n,i,v,w,f,t', EXTRACT_OPERANDS_TESTS)
    def test_extract_operands(source, n, i, v, w, f, t):
>       e_n, e_i, e_v, e_w, e_f, e_t, e_c, e_e = plural.extract_operands(source)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_plural.py:288: TypeError
_________________ test_extract_operands[source1-1.0-1-1-0-0-0] _________________

source = Decimal('1.0'), n = '1.0', i = 1, v = 1, w = 0, f = 0, t = 0

    @pytest.mark.parametrize('source,n,i,v,w,f,t', EXTRACT_OPERANDS_TESTS)
    def test_extract_operands(source, n, i, v, w, f, t):
>       e_n, e_i, e_v, e_w, e_f, e_t, e_c, e_e = plural.extract_operands(source)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_plural.py:288: TypeError
________________ test_extract_operands[source2-1.00-1-2-0-0-0] _________________

source = Decimal('1.00'), n = '1.00', i = 1, v = 2, w = 0, f = 0, t = 0

    @pytest.mark.parametrize('source,n,i,v,w,f,t', EXTRACT_OPERANDS_TESTS)
    def test_extract_operands(source, n, i, v, w, f, t):
>       e_n, e_i, e_v, e_w, e_f, e_t, e_c, e_e = plural.extract_operands(source)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_plural.py:288: TypeError
_________________ test_extract_operands[source3-1.3-1-1-1-3-3] _________________

source = Decimal('1.3'), n = '1.3', i = 1, v = 1, w = 1, f = 3, t = 3

    @pytest.mark.parametrize('source,n,i,v,w,f,t', EXTRACT_OPERANDS_TESTS)
    def test_extract_operands(source, n, i, v, w, f, t):
>       e_n, e_i, e_v, e_w, e_f, e_t, e_c, e_e = plural.extract_operands(source)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_plural.py:288: TypeError
________________ test_extract_operands[source4-1.30-1-2-1-30-3] ________________

source = Decimal('1.30'), n = '1.30', i = 1, v = 2, w = 1, f = 30, t = 3

    @pytest.mark.parametrize('source,n,i,v,w,f,t', EXTRACT_OPERANDS_TESTS)
    def test_extract_operands(source, n, i, v, w, f, t):
>       e_n, e_i, e_v, e_w, e_f, e_t, e_c, e_e = plural.extract_operands(source)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_plural.py:288: TypeError
________________ test_extract_operands[source5-1.03-1-2-2-3-3] _________________

source = Decimal('1.03'), n = '1.03', i = 1, v = 2, w = 2, f = 3, t = 3

    @pytest.mark.parametrize('source,n,i,v,w,f,t', EXTRACT_OPERANDS_TESTS)
    def test_extract_operands(source, n, i, v, w, f, t):
>       e_n, e_i, e_v, e_w, e_f, e_t, e_c, e_e = plural.extract_operands(source)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_plural.py:288: TypeError
______________ test_extract_operands[source6-1.230-1-3-2-230-23] _______________

source = Decimal('1.230'), n = '1.230', i = 1, v = 3, w = 2, f = 230, t = 23

    @pytest.mark.parametrize('source,n,i,v,w,f,t', EXTRACT_OPERANDS_TESTS)
    def test_extract_operands(source, n, i, v, w, f, t):
>       e_n, e_i, e_v, e_w, e_f, e_t, e_c, e_e = plural.extract_operands(source)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_plural.py:288: TypeError
____________________ test_extract_operands[-1-1-1-0-0-0-0] _____________________

source = -1, n = 1, i = 1, v = 0, w = 0, f = 0, t = 0

    @pytest.mark.parametrize('source,n,i,v,w,f,t', EXTRACT_OPERANDS_TESTS)
    def test_extract_operands(source, n, i, v, w, f, t):
>       e_n, e_i, e_v, e_w, e_f, e_t, e_c, e_e = plural.extract_operands(source)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_plural.py:288: TypeError
___________________ test_extract_operands[1.3-1.3-1-1-1-3-3] ___________________

source = 1.3, n = '1.3', i = 1, v = 1, w = 1, f = 3, t = 3

    @pytest.mark.parametrize('source,n,i,v,w,f,t', EXTRACT_OPERANDS_TESTS)
    def test_extract_operands(source, n, i, v, w, f, t):
>       e_n, e_i, e_v, e_w, e_f, e_t, e_c, e_e = plural.extract_operands(source)
E       TypeError: cannot unpack non-iterable NoneType object

tests/test_plural.py:288: TypeError
_________________________ test_gettext_compilation[ru] _________________________

locale = 'ru'

    @pytest.mark.parametrize('locale', ('ru', 'pl'))
    def test_gettext_compilation(locale):
        # Test that new plural form elements introduced in recent CLDR versions
        # are compiled "down" to `n` when emitting Gettext rules.
>       ru_rules = localedata.load(locale)['plural_form'].rules
E       TypeError: 'NoneType' object is not subscriptable

tests/test_plural.py:303: TypeError
_________________________ test_gettext_compilation[pl] _________________________

locale = 'pl'

    @pytest.mark.parametrize('locale', ('ru', 'pl'))
    def test_gettext_compilation(locale):
        # Test that new plural form elements introduced in recent CLDR versions
        # are compiled "down" to `n` when emitting Gettext rules.
>       ru_rules = localedata.load(locale)['plural_form'].rules
E       TypeError: 'NoneType' object is not subscriptable

tests/test_plural.py:303: TypeError
--------------------------------- JSON report ----------------------------------
report saved to: report.json
=========================== short test summary info ============================
FAILED tests/test_core.py::test_locale_provides_access_to_cldr_locale_data - ...
FAILED tests/test_core.py::test_locale_repr - TypeError: __str__ returned non...
FAILED tests/test_core.py::test_locale_comparison - TypeError: __str__ return...
FAILED tests/test_core.py::test_can_return_default_locale - TypeError: __str_...
FAILED tests/test_core.py::test_get_global - TypeError: 'NoneType' object is ...
FAILED tests/test_core.py::test_hash - TypeError: __str__ returned non-string...
FAILED tests/test_core.py::test_default_locale - AssertionError: assert None ...
FAILED tests/test_core.py::test_negotiate_locale - AssertionError: assert Non...
FAILED tests/test_core.py::test_parse_locale - AssertionError: assert None ==...
FAILED tests/test_core.py::test_compatible_classes_in_global_and_localedata[babel/locale-data/root.dat]
FAILED tests/test_core.py::test_compatible_classes_in_global_and_localedata[babel/locale-data/en.dat]
FAILED tests/test_core.py::test_compatible_classes_in_global_and_localedata[babel/locale-data/es_419.dat]
FAILED tests/test_core.py::test_issue_601_no_language_name_but_has_variant - ...
FAILED tests/test_core.py::test_issue_814 - AttributeError: 'NoneType' object...
FAILED tests/test_languages.py::test_official_languages - AssertionError: ass...
FAILED tests/test_languages.py::test_get_language_info - TypeError: 'NoneType...
FAILED tests/test_lists.py::test_format_list - AssertionError: assert None == ''
FAILED tests/test_lists.py::test_format_list_error - Failed: DID NOT RAISE <c...
FAILED tests/test_localedata.py::MergeResolveTestCase::test_merge_items - Ass...
FAILED tests/test_localedata.py::MergeResolveTestCase::test_merge_nested_dict
FAILED tests/test_localedata.py::MergeResolveTestCase::test_merge_nested_dict_no_overlap
FAILED tests/test_localedata.py::MergeResolveTestCase::test_merge_with_alias_and_resolve
FAILED tests/test_localedata.py::test_load - TypeError: 'NoneType' object is ...
FAILED tests/test_localedata.py::test_merge - AssertionError: assert {1: 'foo...
FAILED tests/test_localedata.py::test_locale_identification - TypeError: 'Non...
FAILED tests/test_localedata.py::test_unique_ids - TypeError: object of type ...
FAILED tests/test_localedata.py::test_mixedcased_locale - TypeError: 'NoneTyp...
FAILED tests/test_localedata.py::test_locale_identifiers_cache - assert 0 == 1
FAILED tests/test_localedata.py::test_locale_name_cleanup - Failed: DID NOT R...
FAILED tests/test_numbers.py::FormatDecimalTestCase::test_compact - Assertion...
FAILED tests/test_numbers.py::FormatDecimalTestCase::test_decimals - Assertio...
FAILED tests/test_numbers.py::FormatDecimalTestCase::test_default_rounding - ...
FAILED tests/test_numbers.py::FormatDecimalTestCase::test_formatting_of_very_small_decimals
FAILED tests/test_numbers.py::FormatDecimalTestCase::test_group_separator - A...
FAILED tests/test_numbers.py::FormatDecimalTestCase::test_nan_and_infinity - ...
FAILED tests/test_numbers.py::FormatDecimalTestCase::test_patterns - Assertio...
FAILED tests/test_numbers.py::FormatDecimalTestCase::test_scientific_notation
FAILED tests/test_numbers.py::FormatDecimalTestCase::test_significant_digits
FAILED tests/test_numbers.py::FormatDecimalTestCase::test_subpatterns - Asser...
FAILED tests/test_numbers.py::NumberParsingTestCase::test_can_parse_decimals
FAILED tests/test_numbers.py::NumberParsingTestCase::test_parse_decimal_strict_mode
FAILED tests/test_numbers.py::test_list_currencies - assert False
FAILED tests/test_numbers.py::test_validate_currency - Failed: DID NOT RAISE ...
FAILED tests/test_numbers.py::test_is_currency - AssertionError: assert None
FAILED tests/test_numbers.py::test_normalize_currency - AssertionError: asser...
FAILED tests/test_numbers.py::test_get_currency_name - AssertionError: assert...
FAILED tests/test_numbers.py::test_get_currency_symbol - AssertionError: asse...
FAILED tests/test_numbers.py::test_get_currency_precision - AssertionError: a...
FAILED tests/test_numbers.py::test_get_currency_unit_pattern - AssertionError...
FAILED tests/test_numbers.py::test_get_territory_currencies - AssertionError:...
FAILED tests/test_numbers.py::test_get_decimal_symbol - AssertionError: asser...
FAILED tests/test_numbers.py::test_get_plus_sign_symbol - AssertionError: ass...
FAILED tests/test_numbers.py::test_get_minus_sign_symbol - AssertionError: as...
FAILED tests/test_numbers.py::test_get_exponential_symbol - AssertionError: a...
FAILED tests/test_numbers.py::test_get_group_symbol - AssertionError: assert ...
FAILED tests/test_numbers.py::test_get_infinity_symbol - AssertionError: asse...
FAILED tests/test_numbers.py::test_decimal_precision - AssertionError: assert...
FAILED tests/test_numbers.py::test_format_decimal - AssertionError: assert No...
FAILED tests/test_numbers.py::test_format_decimal_precision[10000-10,000] - A...
FAILED tests/test_numbers.py::test_format_decimal_precision[1-1] - AssertionE...
FAILED tests/test_numbers.py::test_format_decimal_precision[1.0-1] - Assertio...
FAILED tests/test_numbers.py::test_format_decimal_precision[1.1-1.1] - Assert...
FAILED tests/test_numbers.py::test_format_decimal_precision[1.11-1.11] - Asse...
FAILED tests/test_numbers.py::test_format_decimal_precision[1.110-1.11] - Ass...
FAILED tests/test_numbers.py::test_format_decimal_precision[1.001-1.001] - As...
FAILED tests/test_numbers.py::test_format_decimal_precision[1.00100-1.001] - ...
FAILED tests/test_numbers.py::test_format_decimal_precision[01.00100-1.001]
FAILED tests/test_numbers.py::test_format_decimal_precision[101.00100-101.001]
FAILED tests/test_numbers.py::test_format_decimal_precision[00000-0] - Assert...
FAILED tests/test_numbers.py::test_format_decimal_precision[0-0] - AssertionE...
FAILED tests/test_numbers.py::test_format_decimal_precision[0.0-0] - Assertio...
FAILED tests/test_numbers.py::test_format_decimal_precision[0.1-0.1] - Assert...
FAILED tests/test_numbers.py::test_format_decimal_precision[0.11-0.11] - Asse...
FAILED tests/test_numbers.py::test_format_decimal_precision[0.110-0.11] - Ass...
FAILED tests/test_numbers.py::test_format_decimal_precision[0.001-0.001] - As...
FAILED tests/test_numbers.py::test_format_decimal_precision[0.00100-0.001] - ...
FAILED tests/test_numbers.py::test_format_decimal_precision[00.00100-0.001]
FAILED tests/test_numbers.py::test_format_decimal_precision[000.00100-0.001]
FAILED tests/test_numbers.py::test_format_decimal_quantization - TypeError: '...
FAILED tests/test_numbers.py::test_format_currency - AssertionError: assert N...
FAILED tests/test_numbers.py::test_format_currency_format_type - AssertionErr...
FAILED tests/test_numbers.py::test_format_compact_currency - AssertionError: ...
FAILED tests/test_numbers.py::test_format_compact_currency_invalid_format_type
FAILED tests/test_numbers.py::test_format_currency_precision[10000-$10,000.00]
FAILED tests/test_numbers.py::test_format_currency_precision[1-$1.00] - Asser...
FAILED tests/test_numbers.py::test_format_currency_precision[1.0-$1.00] - Ass...
FAILED tests/test_numbers.py::test_format_currency_precision[1.1-$1.10] - Ass...
FAILED tests/test_numbers.py::test_format_currency_precision[1.11-$1.11] - As...
FAILED tests/test_numbers.py::test_format_currency_precision[1.110-$1.11] - A...
FAILED tests/test_numbers.py::test_format_currency_precision[1.001-$1.001] - ...
FAILED tests/test_numbers.py::test_format_currency_precision[1.00100-$1.001]
FAILED tests/test_numbers.py::test_format_currency_precision[01.00100-$1.001]
FAILED tests/test_numbers.py::test_format_currency_precision[101.00100-$101.001]
FAILED tests/test_numbers.py::test_format_currency_precision[00000-$0.00] - A...
FAILED tests/test_numbers.py::test_format_currency_precision[0-$0.00] - Asser...
FAILED tests/test_numbers.py::test_format_currency_precision[0.0-$0.00] - Ass...
FAILED tests/test_numbers.py::test_format_currency_precision[0.1-$0.10] - Ass...
FAILED tests/test_numbers.py::test_format_currency_precision[0.11-$0.11] - As...
FAILED tests/test_numbers.py::test_format_currency_precision[0.110-$0.11] - A...
FAILED tests/test_numbers.py::test_format_currency_precision[0.001-$0.001] - ...
FAILED tests/test_numbers.py::test_format_currency_precision[0.00100-$0.001]
FAILED tests/test_numbers.py::test_format_currency_precision[00.00100-$0.001]
FAILED tests/test_numbers.py::test_format_currency_precision[000.00100-$0.001]
FAILED tests/test_numbers.py::test_format_currency_quantization - TypeError: ...
FAILED tests/test_numbers.py::test_format_currency_long_display_name - Assert...
FAILED tests/test_numbers.py::test_format_currency_long_display_name_all - Ty...
FAILED tests/test_numbers.py::test_format_currency_long_display_name_custom_format
FAILED tests/test_numbers.py::test_format_percent - AssertionError: assert No...
FAILED tests/test_numbers.py::test_format_percent_precision[100-10,000%] - As...
FAILED tests/test_numbers.py::test_format_percent_precision[0.01-1%0] - Asser...
FAILED tests/test_numbers.py::test_format_percent_precision[0.010-1%] - Asser...
FAILED tests/test_numbers.py::test_format_percent_precision[0.011-1.1%0] - As...
FAILED tests/test_numbers.py::test_format_percent_precision[0.0111-1.11%] - A...
FAILED tests/test_numbers.py::test_format_percent_precision[0.01110-1.11%] - ...
FAILED tests/test_numbers.py::test_format_percent_precision[0.01001-1.001%]
FAILED tests/test_numbers.py::test_format_percent_precision[0.0100100-1.001%]
FAILED tests/test_numbers.py::test_format_percent_precision[0.010100100-1.01001%]
FAILED tests/test_numbers.py::test_format_percent_precision[0.000000-0%] - As...
FAILED tests/test_numbers.py::test_format_percent_precision[0-0%] - Assertion...
FAILED tests/test_numbers.py::test_format_percent_precision[0.00-0%] - Assert...
FAILED tests/test_numbers.py::test_format_percent_precision[0.01-1%1] - Asser...
FAILED tests/test_numbers.py::test_format_percent_precision[0.011-1.1%1] - As...
FAILED tests/test_numbers.py::test_format_percent_precision[0.0110-1.1%] - As...
FAILED tests/test_numbers.py::test_format_percent_precision[0.0001-0.01%] - A...
FAILED tests/test_numbers.py::test_format_percent_precision[0.000100-0.01%]
FAILED tests/test_numbers.py::test_format_percent_precision[0.0000100-0.001%]
FAILED tests/test_numbers.py::test_format_percent_precision[0.00000100-0.0001%]
FAILED tests/test_numbers.py::test_format_percent_quantization - TypeError: '...
FAILED tests/test_numbers.py::test_format_scientific - AssertionError: assert...
FAILED tests/test_numbers.py::test_default_scientific_format - AssertionError...
FAILED tests/test_numbers.py::test_format_scientific_precision[10000-1E4] - A...
FAILED tests/test_numbers.py::test_format_scientific_precision[1-1E0] - Asser...
FAILED tests/test_numbers.py::test_format_scientific_precision[1.0-1E0] - Ass...
FAILED tests/test_numbers.py::test_format_scientific_precision[1.1-1.1E0] - A...
FAILED tests/test_numbers.py::test_format_scientific_precision[1.11-1.11E0]
FAILED tests/test_numbers.py::test_format_scientific_precision[1.110-1.11E0]
FAILED tests/test_numbers.py::test_format_scientific_precision[1.001-1.001E0]
FAILED tests/test_numbers.py::test_format_scientific_precision[1.00100-1.001E0]
FAILED tests/test_numbers.py::test_format_scientific_precision[01.00100-1.001E0]
FAILED tests/test_numbers.py::test_format_scientific_precision[101.00100-1.01001E2]
FAILED tests/test_numbers.py::test_format_scientific_precision[00000-0E0] - A...
FAILED tests/test_numbers.py::test_format_scientific_precision[0-0E0] - Asser...
FAILED tests/test_numbers.py::test_format_scientific_precision[0.0-0E0] - Ass...
FAILED tests/test_numbers.py::test_format_scientific_precision[0.1-1E-1] - As...
FAILED tests/test_numbers.py::test_format_scientific_precision[0.11-1.1E-1]
FAILED tests/test_numbers.py::test_format_scientific_precision[0.110-1.1E-1]
FAILED tests/test_numbers.py::test_format_scientific_precision[0.001-1E-3] - ...
FAILED tests/test_numbers.py::test_format_scientific_precision[0.00100-1E-3]
FAILED tests/test_numbers.py::test_format_scientific_precision[00.00100-1E-3]
FAILED tests/test_numbers.py::test_format_scientific_precision[000.00100-1E-3]
FAILED tests/test_numbers.py::test_format_scientific_quantization - TypeError...
FAILED tests/test_numbers.py::test_parse_number - AssertionError: assert None...
FAILED tests/test_numbers.py::test_parse_decimal - AssertionError: assert Non...
FAILED tests/test_numbers.py::test_parse_grouping - AssertionError: assert No...
FAILED tests/test_numbers.py::test_parse_pattern - AttributeError: 'NoneType'...
FAILED tests/test_numbers.py::test_parse_pattern_negative - AttributeError: '...
FAILED tests/test_numbers.py::test_numberpattern_repr - assert "'¤#,##0.00;(¤...
FAILED tests/test_numbers.py::test_parse_static_pattern - AssertionError: ass...
FAILED tests/test_numbers.py::test_parse_decimal_nbsp_heuristics - AssertionE...
FAILED tests/test_numbers.py::test_very_small_decimal_no_quantization - Asser...
FAILED tests/test_numbers.py::test_single_quotes_in_pattern - assert None == ...
FAILED tests/test_plural.py::test_plural_rule - NameError: name 'tokenize_rul...
FAILED tests/test_plural.py::test_plural_rule_operands_i - NameError: name 't...
FAILED tests/test_plural.py::test_plural_rule_operands_v - NameError: name 't...
FAILED tests/test_plural.py::test_plural_rule_operands_w - NameError: name 't...
FAILED tests/test_plural.py::test_plural_rule_operands_f - NameError: name 't...
FAILED tests/test_plural.py::test_plural_rule_operands_t - NameError: name 't...
FAILED tests/test_plural.py::test_plural_other_is_ignored - NameError: name '...
FAILED tests/test_plural.py::test_to_javascript - assert None == "(function(n...
FAILED tests/test_plural.py::test_to_python - TypeError: 'NoneType' object is...
FAILED tests/test_plural.py::test_to_gettext - AssertionError: assert None ==...
FAILED tests/test_plural.py::test_in_range_list - assert None
FAILED tests/test_plural.py::test_within_range_list - assert None
FAILED tests/test_plural.py::test_cldr_modulo - assert None == -3
FAILED tests/test_plural.py::test_plural_within_rules - NameError: name 'toke...
FAILED tests/test_plural.py::test_locales_with_no_plural_rules_have_default
FAILED tests/test_plural.py::test_tokenize_well_formed[-tokens0] - AttributeE...
FAILED tests/test_plural.py::test_tokenize_well_formed[n = 1-tokens1] - Attri...
FAILED tests/test_plural.py::test_tokenize_well_formed[n = 1 @integer 1-tokens2]
FAILED tests/test_plural.py::test_tokenize_well_formed[n is 1-tokens3] - Attr...
FAILED tests/test_plural.py::test_tokenize_well_formed[n % 100 = 3..10-tokens4]
FAILED tests/test_plural.py::test_tokenize_malformed[a = 1] - AttributeError:...
FAILED tests/test_plural.py::test_tokenize_malformed[n ! 2] - AttributeError:...
FAILED tests/test_plural.py::TestNextTokenTestCase::test_empty - AttributeErr...
FAILED tests/test_plural.py::TestNextTokenTestCase::test_type_not_ok_and_value_ok
FAILED tests/test_plural.py::TestNextTokenTestCase::test_type_ok_and_no_value
FAILED tests/test_plural.py::TestNextTokenTestCase::test_type_ok_and_not_value
FAILED tests/test_plural.py::TestNextTokenTestCase::test_type_ok_and_value_ok
FAILED tests/test_plural.py::PluralRuleParserTestCase::test_and - AttributeEr...
FAILED tests/test_plural.py::PluralRuleParserTestCase::test_eq_relation - Att...
FAILED tests/test_plural.py::PluralRuleParserTestCase::test_error_when_unexpected_end
FAILED tests/test_plural.py::PluralRuleParserTestCase::test_in_range_relation
FAILED tests/test_plural.py::PluralRuleParserTestCase::test_negate - Attribut...
FAILED tests/test_plural.py::PluralRuleParserTestCase::test_or - AttributeErr...
FAILED tests/test_plural.py::PluralRuleParserTestCase::test_or_and - Attribut...
FAILED tests/test_plural.py::test_extract_operands[1-1-1-0-0-0-0] - TypeError...
FAILED tests/test_plural.py::test_extract_operands[source1-1.0-1-1-0-0-0] - T...
FAILED tests/test_plural.py::test_extract_operands[source2-1.00-1-2-0-0-0] - ...
FAILED tests/test_plural.py::test_extract_operands[source3-1.3-1-1-1-3-3] - T...
FAILED tests/test_plural.py::test_extract_operands[source4-1.30-1-2-1-30-3]
FAILED tests/test_plural.py::test_extract_operands[source5-1.03-1-2-2-3-3] - ...
FAILED tests/test_plural.py::test_extract_operands[source6-1.230-1-3-2-230-23]
FAILED tests/test_plural.py::test_extract_operands[-1-1-1-0-0-0-0] - TypeErro...
FAILED tests/test_plural.py::test_extract_operands[1.3-1.3-1-1-1-3-3] - TypeE...
FAILED tests/test_plural.py::test_gettext_compilation[ru] - TypeError: 'NoneT...
FAILED tests/test_plural.py::test_gettext_compilation[pl] - TypeError: 'NoneT...
ERROR tests/messages/test_catalog.py
ERROR tests/messages/test_checkers.py
ERROR tests/messages/test_extract.py
ERROR tests/messages/test_frontend.py
ERROR tests/messages/test_js_extract.py
ERROR tests/messages/test_jslexer.py
ERROR tests/messages/test_mofile.py
ERROR tests/messages/test_normalized_string.py
ERROR tests/messages/test_plurals.py
ERROR tests/messages/test_pofile.py
ERROR tests/test_core.py::TestLocaleClass - TypeError: 'NoneType' object is n...
ERROR tests/test_date_intervals.py
ERROR tests/test_dates.py
ERROR tests/test_day_periods.py
ERROR tests/test_smoke.py
ERROR tests/test_support.py
ERROR tests/test_util.py
============= 206 failed, 7 passed, 2 skipped, 17 errors in 3.64s ==============
